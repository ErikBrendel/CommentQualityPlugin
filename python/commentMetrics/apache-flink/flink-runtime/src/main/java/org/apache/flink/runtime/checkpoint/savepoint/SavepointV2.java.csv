commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;0;4;;@Override public long getCheckpointId() {     return checkpointId. }
false;public;0;4;;@Override public Collection<OperatorState> getOperatorStates() {     return operatorStates. }
false;public;0;4;;@Override public Collection<TaskState> getTaskStates() {     return taskStates. }
false;public;0;4;;@Override public Collection<MasterState> getMasterStates() {     return masterStates. }
false;public;0;8;;@Override public void dispose() throws Exception {     for (OperatorState operatorState : operatorStates) {         operatorState.discardState().     }     operatorStates.clear().     masterStates.clear(). }
false;public;0;4;;@Override public String toString() {     return "Checkpoint Metadata (version=" + VERSION + ')'. }
true;public,static;2;108;/**  * Converts the {@link Savepoint} containing {@link TaskState TaskStates} to an equivalent savepoint containing  * {@link OperatorState OperatorStates}.  *  * @param savepoint savepoint to convert  * @param tasks     map of all vertices and their job vertex ids  * @return converted completed checkpoint  * @deprecated Only kept for backwards-compatibility with versions < 1.3. Will be removed in the future.  */ ;/**  * Converts the {@link Savepoint} containing {@link TaskState TaskStates} to an equivalent savepoint containing  * {@link OperatorState OperatorStates}.  *  * @param savepoint savepoint to convert  * @param tasks     map of all vertices and their job vertex ids  * @return converted completed checkpoint  * @deprecated Only kept for backwards-compatibility with versions < 1.3. Will be removed in the future.  */ @Deprecated public static Savepoint convertToOperatorStateSavepointV2(Map<JobVertexID, ExecutionJobVertex> tasks, Savepoint savepoint) {     if (savepoint.getOperatorStates() != null) {         return savepoint.     }     boolean expandedToLegacyIds = false.     Map<OperatorID, OperatorState> operatorStates = new HashMap<>(savepoint.getTaskStates().size() << 1).     for (TaskState taskState : savepoint.getTaskStates()) {         ExecutionJobVertex jobVertex = tasks.get(taskState.getJobVertexID()).         // for example as generated from older flink versions, to provide backwards compatibility.         if (jobVertex == null && !expandedToLegacyIds) {             tasks = ExecutionJobVertex.includeLegacyJobVertexIDs(tasks).             jobVertex = tasks.get(taskState.getJobVertexID()).             expandedToLegacyIds = true.         }         if (jobVertex == null) {             throw new IllegalStateException("Could not find task for state with ID " + taskState.getJobVertexID() + ". " + "When migrating a savepoint from a version < 1.3 please make sure that the topology was not " + "changed through removal of a stateful operator or modification of a chain containing a stateful " + "operator.").         }         List<OperatorID> operatorIDs = jobVertex.getOperatorIDs().         Preconditions.checkArgument(jobVertex.getParallelism() == taskState.getParallelism(), "Detected change in parallelism during migration for task " + jobVertex.getJobVertexId() + "." + "When migrating a savepoint from a version < 1.3 please make sure that no changes were made " + "to the parallelism of stateful operators.").         Preconditions.checkArgument(operatorIDs.size() == taskState.getChainLength(), "Detected change in chain length during migration for task " + jobVertex.getJobVertexId() + ". " + "When migrating a savepoint from a version < 1.3 please make sure that the topology was not " + "changed by modification of a chain containing a stateful operator.").         for (int subtaskIndex = 0. subtaskIndex < jobVertex.getParallelism(). subtaskIndex++) {             SubtaskState subtaskState.             try {                 subtaskState = taskState.getState(subtaskIndex).             } catch (Exception e) {                 throw new IllegalStateException("Could not find subtask with index " + subtaskIndex + " for task " + jobVertex.getJobVertexId() + ". " + "When migrating a savepoint from a version < 1.3 please make sure that no changes were made " + "to the parallelism of stateful operators.", e).             }             if (subtaskState == null) {                 continue.             }             ChainedStateHandle<OperatorStateHandle> partitioneableState = subtaskState.getManagedOperatorState().             ChainedStateHandle<OperatorStateHandle> rawOperatorState = subtaskState.getRawOperatorState().             for (int chainIndex = 0. chainIndex < taskState.getChainLength(). chainIndex++) {                 // task consists of multiple operators so we have to break the state apart                 for (int operatorIndex = 0. operatorIndex < operatorIDs.size(). operatorIndex++) {                     OperatorID operatorID = operatorIDs.get(operatorIndex).                     OperatorState operatorState = operatorStates.get(operatorID).                     if (operatorState == null) {                         operatorState = new OperatorState(operatorID, jobVertex.getParallelism(), jobVertex.getMaxParallelism()).                         operatorStates.put(operatorID, operatorState).                     }                     KeyedStateHandle managedKeyedState = null.                     KeyedStateHandle rawKeyedState = null.                     // only the head operator retains the keyed state                     if (operatorIndex == operatorIDs.size() - 1) {                         managedKeyedState = subtaskState.getManagedKeyedState().                         rawKeyedState = subtaskState.getRawKeyedState().                     }                     OperatorSubtaskState operatorSubtaskState = new OperatorSubtaskState(partitioneableState != null ? partitioneableState.get(operatorIndex) : null, rawOperatorState != null ? rawOperatorState.get(operatorIndex) : null, managedKeyedState, rawKeyedState).                     operatorState.putState(subtaskIndex, operatorSubtaskState).                 }             }         }     }     return new SavepointV2(savepoint.getCheckpointId(), operatorStates.values(), savepoint.getMasterStates()). }
