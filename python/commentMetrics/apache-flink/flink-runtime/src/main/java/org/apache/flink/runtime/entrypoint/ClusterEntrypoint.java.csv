commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public CompletableFuture<ApplicationStatus> getTerminationFuture() {     return terminationFuture. }
false;public;0;31;;public void startCluster() throws ClusterEntrypointException {     LOG.info("Starting {}.", getClass().getSimpleName()).     try {         configureFileSystems(configuration).         SecurityContext securityContext = installSecurityContext(configuration).         securityContext.runSecured((Callable<Void>) () -> {             runCluster(configuration).             return null.         }).     } catch (Throwable t) {         final Throwable strippedThrowable = ExceptionUtils.stripException(t, UndeclaredThrowableException.class).         try {             // clean up any partial state             shutDownAsync(ApplicationStatus.FAILED, ExceptionUtils.stringifyException(strippedThrowable), false).get(INITIALIZATION_SHUTDOWN_TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).         } catch (InterruptedException | ExecutionException | TimeoutException e) {             strippedThrowable.addSuppressed(e).         }         throw new ClusterEntrypointException(String.format("Failed to initialize the cluster entrypoint %s.", getClass().getSimpleName()), strippedThrowable).     } }
false;private;1;10;;private void configureFileSystems(Configuration configuration) throws Exception {     LOG.info("Install default filesystem.").     try {         FileSystem.initialize(configuration).     } catch (IOException e) {         throw new IOException("Error while setting the default " + "filesystem scheme from configuration.", e).     } }
false;protected;1;7;;protected SecurityContext installSecurityContext(Configuration configuration) throws Exception {     LOG.info("Install security context.").     SecurityUtils.install(new SecurityConfiguration(configuration)).     return SecurityUtils.getInstalledContext(). }
false;private;1;41;;private void runCluster(Configuration configuration) throws Exception {     synchronized (lock) {         initializeServices(configuration).         // write host information into configuration         configuration.setString(JobManagerOptions.ADDRESS, commonRpcService.getAddress()).         configuration.setInteger(JobManagerOptions.PORT, commonRpcService.getPort()).         final DispatcherResourceManagerComponentFactory<?> dispatcherResourceManagerComponentFactory = createDispatcherResourceManagerComponentFactory(configuration).         clusterComponent = dispatcherResourceManagerComponentFactory.create(configuration, commonRpcService, haServices, blobServer, heartbeatServices, metricRegistry, archivedExecutionGraphStore, new AkkaQueryServiceRetriever(metricQueryServiceActorSystem, Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))), this).         clusterComponent.getShutDownFuture().whenComplete((ApplicationStatus applicationStatus, Throwable throwable) -> {             if (throwable != null) {                 shutDownAsync(ApplicationStatus.UNKNOWN, ExceptionUtils.stringifyException(throwable), false).             } else {                 // This is the general shutdown path. If a separate more specific shutdown was                 // already triggered, this will do nothing                 shutDownAsync(applicationStatus, null, true).             }         }).     } }
false;protected;1;34;;protected void initializeServices(Configuration configuration) throws Exception {     LOG.info("Initializing cluster services.").     synchronized (lock) {         final String bindAddress = configuration.getString(JobManagerOptions.ADDRESS).         final String portRange = getRPCPortRange(configuration).         commonRpcService = createRpcService(configuration, bindAddress, portRange).         // update the configuration used to create the high availability services         configuration.setString(JobManagerOptions.ADDRESS, commonRpcService.getAddress()).         configuration.setInteger(JobManagerOptions.PORT, commonRpcService.getPort()).         haServices = createHaServices(configuration, commonRpcService.getExecutor()).         blobServer = new BlobServer(configuration, haServices.createBlobStore()).         blobServer.start().         heartbeatServices = createHeartbeatServices(configuration).         metricRegistry = createMetricRegistry(configuration).         // TODO: This is a temporary hack until we have ported the MetricQueryService to the new RpcEndpoint         // Start actor system for metric query service on any available port         metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(configuration, bindAddress, LOG).         metricRegistry.startQueryService(metricQueryServiceActorSystem, null).         archivedExecutionGraphStore = createSerializableExecutionGraphStore(configuration, commonRpcService.getScheduledExecutor()).         transientBlobCache = new TransientBlobCache(configuration, new InetSocketAddress(commonRpcService.getAddress(), blobServer.getPort())).     } }
false;private;3;4;;@Nonnull private RpcService createRpcService(Configuration configuration, String bindAddress, String portRange) throws Exception {     return AkkaRpcServiceUtils.createRpcService(bindAddress, portRange, configuration). }
true;protected;1;7;/**  * Returns the port range for the common {@link RpcService}.  *  * @param configuration to extract the port range from  * @return Port range for the common {@link RpcService}  */ ;/**  * Returns the port range for the common {@link RpcService}.  *  * @param configuration to extract the port range from  * @return Port range for the common {@link RpcService}  */ protected String getRPCPortRange(Configuration configuration) {     if (ZooKeeperUtils.isZooKeeperRecoveryMode(configuration)) {         return configuration.getString(HighAvailabilityOptions.HA_JOB_MANAGER_PORT_RANGE).     } else {         return String.valueOf(configuration.getInteger(JobManagerOptions.PORT)).     } }
false;protected;2;8;;protected HighAvailabilityServices createHaServices(Configuration configuration, Executor executor) throws Exception {     return HighAvailabilityServicesUtils.createHighAvailabilityServices(configuration, executor, HighAvailabilityServicesUtils.AddressResolution.NO_ADDRESS_RESOLUTION). }
false;protected;1;3;;protected HeartbeatServices createHeartbeatServices(Configuration configuration) {     return HeartbeatServices.fromConfiguration(configuration). }
false;protected;1;3;;protected MetricRegistryImpl createMetricRegistry(Configuration configuration) {     return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(configuration)). }
false;public;0;7;;@Override public CompletableFuture<Void> closeAsync() {     return shutDownAsync(ApplicationStatus.UNKNOWN, "Cluster entrypoint has been closed externally.", true).thenAccept(ignored -> {     }). }
false;protected;1;61;;protected CompletableFuture<Void> stopClusterServices(boolean cleanupHaData) {     synchronized (lock) {         Throwable exception = null.         final Collection<CompletableFuture<Void>> terminationFutures = new ArrayList<>(3).         if (blobServer != null) {             try {                 blobServer.close().             } catch (Throwable t) {                 exception = ExceptionUtils.firstOrSuppressed(t, exception).             }         }         if (haServices != null) {             try {                 if (cleanupHaData) {                     haServices.closeAndCleanupAllData().                 } else {                     haServices.close().                 }             } catch (Throwable t) {                 exception = ExceptionUtils.firstOrSuppressed(t, exception).             }         }         if (archivedExecutionGraphStore != null) {             try {                 archivedExecutionGraphStore.close().             } catch (Throwable t) {                 exception = ExceptionUtils.firstOrSuppressed(t, exception).             }         }         if (transientBlobCache != null) {             try {                 transientBlobCache.close().             } catch (Throwable t) {                 exception = ExceptionUtils.firstOrSuppressed(t, exception).             }         }         if (metricRegistry != null) {             terminationFutures.add(metricRegistry.shutdown()).         }         if (metricQueryServiceActorSystem != null) {             terminationFutures.add(AkkaUtils.terminateActorSystem(metricQueryServiceActorSystem)).         }         if (commonRpcService != null) {             terminationFutures.add(commonRpcService.stopService()).         }         if (exception != null) {             terminationFutures.add(FutureUtils.completedExceptionally(exception)).         }         return FutureUtils.completeAll(terminationFutures).     } }
false;public;1;6;;@Override public void onFatalError(Throwable exception) {     LOG.error("Fatal error occurred in the cluster entrypoint.", exception).     System.exit(RUNTIME_FAILURE_RETURN_CODE). }
false;private;1;10;;// -------------------------------------------------- // Internal methods // -------------------------------------------------- private Configuration generateClusterConfiguration(Configuration configuration) {     final Configuration resultConfiguration = new Configuration(Preconditions.checkNotNull(configuration)).     final String webTmpDir = configuration.getString(WebOptions.TMP_DIR).     final File uniqueWebTmpDir = new File(webTmpDir, "flink-web-" + UUID.randomUUID()).     resultConfiguration.setString(WebOptions.TMP_DIR, uniqueWebTmpDir.getAbsolutePath()).     return resultConfiguration. }
false;private;3;32;;private CompletableFuture<ApplicationStatus> shutDownAsync(ApplicationStatus applicationStatus, @Nullable String diagnostics, boolean cleanupHaData) {     if (isShutDown.compareAndSet(false, true)) {         LOG.info("Shutting {} down with application status {}. Diagnostics {}.", getClass().getSimpleName(), applicationStatus, diagnostics).         final CompletableFuture<Void> shutDownApplicationFuture = closeClusterComponent(applicationStatus, diagnostics).         final CompletableFuture<Void> serviceShutdownFuture = FutureUtils.composeAfterwards(shutDownApplicationFuture, () -> stopClusterServices(cleanupHaData)).         final CompletableFuture<Void> cleanupDirectoriesFuture = FutureUtils.runAfterwards(serviceShutdownFuture, this::cleanupDirectories).         cleanupDirectoriesFuture.whenComplete((Void ignored2, Throwable serviceThrowable) -> {             if (serviceThrowable != null) {                 terminationFuture.completeExceptionally(serviceThrowable).             } else {                 terminationFuture.complete(applicationStatus).             }         }).     }     return terminationFuture. }
true;private;2;9;/**  * Deregister the Flink application from the resource management system by signalling  * the {@link ResourceManager}.  *  * @param applicationStatus to terminate the application with  * @param diagnostics additional information about the shut down, can be {@code null}  * @return Future which is completed once the shut down  */ ;/**  * Deregister the Flink application from the resource management system by signalling  * the {@link ResourceManager}.  *  * @param applicationStatus to terminate the application with  * @param diagnostics additional information about the shut down, can be {@code null}  * @return Future which is completed once the shut down  */ private CompletableFuture<Void> closeClusterComponent(ApplicationStatus applicationStatus, @Nullable String diagnostics) {     synchronized (lock) {         if (clusterComponent != null) {             return clusterComponent.deregisterApplicationAndClose(applicationStatus, diagnostics).         } else {             return CompletableFuture.completedFuture(null).         }     } }
true;private;0;7;/**  * Clean up of temporary directories created by the {@link ClusterEntrypoint}.  *  * @throws IOException if the temporary directories could not be cleaned up  */ ;/**  * Clean up of temporary directories created by the {@link ClusterEntrypoint}.  *  * @throws IOException if the temporary directories could not be cleaned up  */ private void cleanupDirectories() throws IOException {     ShutdownHookUtil.removeShutdownHook(shutDownHook, getClass().getSimpleName(), LOG).     final String webTmpDir = configuration.getString(WebOptions.TMP_DIR).     FileUtils.deleteDirectory(new File(webTmpDir)). }
false;protected,abstract;1;1;;// -------------------------------------------------- // Abstract methods // -------------------------------------------------- protected abstract DispatcherResourceManagerComponentFactory<?> createDispatcherResourceManagerComponentFactory(Configuration configuration).
false;protected,abstract;2;3;;protected abstract ArchivedExecutionGraphStore createSerializableExecutionGraphStore(Configuration configuration, ScheduledExecutor scheduledExecutor) throws IOException.
false;protected,static;1;5;;protected static EntrypointClusterConfiguration parseArguments(String[] args) throws FlinkParseException {     final CommandLineParser<EntrypointClusterConfiguration> clusterConfigurationParser = new CommandLineParser<>(new EntrypointClusterConfigurationParserFactory()).     return clusterConfigurationParser.parse(args). }
false;protected,static;1;18;;protected static Configuration loadConfiguration(EntrypointClusterConfiguration entrypointClusterConfiguration) {     final Configuration dynamicProperties = ConfigurationUtils.createConfiguration(entrypointClusterConfiguration.getDynamicProperties()).     final Configuration configuration = GlobalConfiguration.loadConfiguration(entrypointClusterConfiguration.getConfigDir(), dynamicProperties).     final int restPort = entrypointClusterConfiguration.getRestPort().     if (restPort >= 0) {         configuration.setInteger(RestOptions.PORT, restPort).     }     final String hostname = entrypointClusterConfiguration.getHostname().     if (hostname != null) {         configuration.setString(JobManagerOptions.ADDRESS, hostname).     }     return configuration. }
false;public,static;1;23;;// -------------------------------------------------- // Helper methods // -------------------------------------------------- public static void runClusterEntrypoint(ClusterEntrypoint clusterEntrypoint) {     final String clusterEntrypointName = clusterEntrypoint.getClass().getSimpleName().     try {         clusterEntrypoint.startCluster().     } catch (ClusterEntrypointException e) {         LOG.error(String.format("Could not start cluster entrypoint %s.", clusterEntrypointName), e).         System.exit(STARTUP_FAILURE_RETURN_CODE).     }     clusterEntrypoint.getTerminationFuture().whenComplete((applicationStatus, throwable) -> {         final int returnCode.         if (throwable != null) {             returnCode = RUNTIME_FAILURE_RETURN_CODE.         } else {             returnCode = applicationStatus.processExitCode().         }         LOG.info("Terminating cluster entrypoint process {} with exit code {}.", clusterEntrypointName, returnCode, throwable).         System.exit(returnCode).     }). }
