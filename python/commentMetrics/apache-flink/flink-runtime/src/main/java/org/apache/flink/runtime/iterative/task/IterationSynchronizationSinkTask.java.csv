commented;modifiers;parameterAmount;loc;comment;code
false;public;0;76;;// -------------------------------------------------------------------------------------------- @Override public void invoke() throws Exception {     this.headEventReader = new MutableRecordReader<>(getEnvironment().getInputGate(0), getEnvironment().getTaskManagerInfo().getTmpDirectories()).     TaskConfig taskConfig = new TaskConfig(getTaskConfiguration()).     // store all aggregators     this.aggregators = new HashMap<>().     for (AggregatorWithName<?> aggWithName : taskConfig.getIterationAggregators(getUserCodeClassLoader())) {         aggregators.put(aggWithName.getName(), aggWithName.getAggregator()).     }     // store the aggregator convergence criterion     if (taskConfig.usesConvergenceCriterion()) {         convergenceCriterion = taskConfig.getConvergenceCriterion(getUserCodeClassLoader()).         convergenceAggregatorName = taskConfig.getConvergenceCriterionAggregatorName().         Preconditions.checkNotNull(convergenceAggregatorName).     }     // store the default aggregator convergence criterion     if (taskConfig.usesImplicitConvergenceCriterion()) {         implicitConvergenceCriterion = taskConfig.getImplicitConvergenceCriterion(getUserCodeClassLoader()).         implicitConvergenceAggregatorName = taskConfig.getImplicitConvergenceCriterionAggregatorName().         Preconditions.checkNotNull(implicitConvergenceAggregatorName).     }     maxNumberOfIterations = taskConfig.getNumberOfIterations().     // set up the event handler     int numEventsTillEndOfSuperstep = taskConfig.getNumberOfEventsUntilInterruptInIterativeGate(0).     eventHandler = new SyncEventHandler(numEventsTillEndOfSuperstep, aggregators, getEnvironment().getUserClassLoader()).     headEventReader.registerTaskEventListener(eventHandler, WorkerDoneEvent.class).     IntValue dummy = new IntValue().     while (!terminationRequested()) {         if (log.isInfoEnabled()) {             log.info(formatLogString("starting iteration [" + currentIteration + "]")).         }         // this call listens for events until the end-of-superstep is reached         readHeadEventChannel(dummy).         if (log.isInfoEnabled()) {             log.info(formatLogString("finishing iteration [" + currentIteration + "]")).         }         if (checkForConvergence()) {             if (log.isInfoEnabled()) {                 log.info(formatLogString("signaling that all workers are to terminate in iteration [" + currentIteration + "]")).             }             requestTermination().             sendToAllWorkers(new TerminationEvent()).         } else {             if (log.isInfoEnabled()) {                 log.info(formatLogString("signaling that all workers are done in iteration [" + currentIteration + "]")).             }             AllWorkersDoneEvent allWorkersDoneEvent = new AllWorkersDoneEvent(aggregators).             sendToAllWorkers(allWorkersDoneEvent).             // reset all aggregators             for (Aggregator<?> agg : aggregators.values()) {                 agg.reset().             }             currentIteration++.         }     } }
false;private;0;47;;private boolean checkForConvergence() {     if (maxNumberOfIterations == currentIteration) {         if (log.isInfoEnabled()) {             log.info(formatLogString("maximum number of iterations [" + currentIteration + "] reached, terminating...")).         }         return true.     }     if (convergenceAggregatorName != null) {         @SuppressWarnings("unchecked")         Aggregator<Value> aggregator = (Aggregator<Value>) aggregators.get(convergenceAggregatorName).         if (aggregator == null) {             throw new RuntimeException("Error: Aggregator for convergence criterion was null.").         }         Value aggregate = aggregator.getAggregate().         if (convergenceCriterion.isConverged(currentIteration, aggregate)) {             if (log.isInfoEnabled()) {                 log.info(formatLogString("convergence reached after [" + currentIteration + "] iterations, terminating...")).             }             return true.         }     }     if (implicitConvergenceAggregatorName != null) {         @SuppressWarnings("unchecked")         Aggregator<Value> aggregator = (Aggregator<Value>) aggregators.get(implicitConvergenceAggregatorName).         if (aggregator == null) {             throw new RuntimeException("Error: Aggregator for default convergence criterion was null.").         }         Value aggregate = aggregator.getAggregate().         if (implicitConvergenceCriterion.isConverged(currentIteration, aggregate)) {             if (log.isInfoEnabled()) {                 log.info(formatLogString("empty workset convergence reached after [" + currentIteration + "] iterations, terminating...")).             }             return true.         }     }     return false. }
false;private;1;16;;private void readHeadEventChannel(IntValue rec) throws IOException {     // reset the handler     eventHandler.resetEndOfSuperstep().     // read (and thereby process all events in the handler's event handling functions)     try {         if (this.headEventReader.next(rec)) {             throw new RuntimeException("Synchronization task must not see any records!").         }     } catch (InterruptedException iex) {         // sanity check         if (!(eventHandler.isEndOfSuperstep())) {             throw new RuntimeException("Event handler interrupted without reaching end-of-superstep.").         }     } }
false;private;1;3;;private void sendToAllWorkers(TaskEvent event) throws IOException, InterruptedException {     headEventReader.sendTaskEvent(event). }
false;private;1;3;;private String formatLogString(String message) {     return BatchTask.constructLogString(message, getEnvironment().getTaskInfo().getTaskName(), this). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public boolean terminationRequested() {     return terminated.get(). }
false;public;0;4;;@Override public void requestTermination() {     terminated.set(true). }
