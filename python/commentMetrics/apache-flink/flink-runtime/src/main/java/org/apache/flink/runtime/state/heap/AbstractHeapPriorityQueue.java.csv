commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override @Nullable public T poll() {     return size() > 0 ? removeInternal(getHeadElementIndex()) : null. }
false;public;0;6;;@Override @Nullable public T peek() {     // References to removed elements are expected to become set to null.     return queue[getHeadElementIndex()]. }
false;public;1;5;;@Override public boolean add(@Nonnull T toAdd) {     addInternal(toAdd).     return toAdd.getInternalIndex() == getHeadElementIndex(). }
false;public;1;6;;@Override public boolean remove(@Nonnull T toRemove) {     final int elementIndex = toRemove.getInternalIndex().     removeInternal(elementIndex).     return elementIndex == getHeadElementIndex(). }
false;public;0;4;;@Override public boolean isEmpty() {     return size() == 0. }
false;public;0;4;;@Override public int size() {     return size. }
false;public;1;13;;@Override public void addAll(@Nullable Collection<? extends T> toAdd) {     if (toAdd == null) {         return.     }     resizeForBulkLoad(toAdd.size()).     for (T element : toAdd) {         add(element).     } }
false;public;1;14;;@SuppressWarnings({ "unchecked" }) @Nonnull public <O> O[] toArray(O[] out) {     final int heapArrayOffset = getHeadElementIndex().     if (out.length < size) {         return (O[]) Arrays.copyOfRange(queue, heapArrayOffset, heapArrayOffset + size, out.getClass()).     } else {         System.arraycopy(queue, heapArrayOffset, out, 0, size).         if (out.length > size) {             out[size] = null.         }         return out.     } }
true;public;0;5;/**  * Returns an iterator over the elements in this queue. The iterator  * does not return the elements in any particular order.  *  * @return an iterator over the elements in this queue.  */ ;/**  * Returns an iterator over the elements in this queue. The iterator  * does not return the elements in any particular order.  *  * @return an iterator over the elements in this queue.  */ @Nonnull @Override public CloseableIterator<T> iterator() {     return new HeapIterator(). }
true;public;0;5;/**  * Clears the queue.  */ ;/**  * Clears the queue.  */ public void clear() {     final int arrayOffset = getHeadElementIndex().     Arrays.fill(queue, arrayOffset, arrayOffset + size, null).     size = 0. }
false;protected;1;6;;protected void resizeForBulkLoad(int totalSize) {     if (totalSize > queue.length) {         int desiredSize = totalSize + (totalSize >>> 3).         resizeQueueArray(desiredSize, totalSize).     } }
false;protected;2;10;;protected void resizeQueueArray(int desiredSize, int minRequiredSize) {     if (isValidArraySize(desiredSize)) {         queue = Arrays.copyOf(queue, desiredSize).     } else if (isValidArraySize(minRequiredSize)) {         queue = Arrays.copyOf(queue, MAX_ARRAY_SIZE).     } else {         throw new OutOfMemoryError("Required minimum heap size " + minRequiredSize + " exceeds maximum size of " + MAX_ARRAY_SIZE + ".").     } }
false;protected;2;4;;protected void moveElementToIdx(T element, int idx) {     queue[idx] = element.     element.setInternalIndex(idx). }
true;protected,abstract;1;1;/**  * Implements how to remove the element at the given index from the queue.  *  * @param elementIndex the index to remove.  * @return the removed element.  */ ;/**  * Implements how to remove the element at the given index from the queue.  *  * @param elementIndex the index to remove.  * @return the removed element.  */ protected abstract T removeInternal(@Nonnegative int elementIndex).
true;protected,abstract;1;1;/**  * Implements how to add an element to the queue.  *  * @param toAdd the element to add.  */ ;/**  * Implements how to add an element to the queue.  *  * @param toAdd the element to add.  */ protected abstract void addInternal(@Nonnull T toAdd).
true;protected,abstract;0;1;/**  * Returns the start index of the queue elements in the array.  */ ;/**  * Returns the start index of the queue elements in the array.  */ protected abstract int getHeadElementIndex().
false;private,static;1;3;;private static boolean isValidArraySize(int size) {     return size >= 0 && size <= MAX_ARRAY_SIZE. }
false;public;0;4;;@Override public boolean hasNext() {     return runningIdx < endIdx. }
false;public;0;7;;@Override public T next() {     if (runningIdx >= endIdx) {         throw new NoSuchElementException("Iterator has no next element.").     }     return queue[runningIdx++]. }
false;public;0;3;;@Override public void close() { }
