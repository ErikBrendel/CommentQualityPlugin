commented;modifiers;parameterAmount;loc;comment;code
true;static;2;14;/**  * Creates a new StateTableByKeyGroupReader that inserts de-serialized mappings into the given table, using the  * de-serialization algorithm that matches the given version.  *  * @param stateTable the {@link StateTable} into which de-serialized mappings are inserted.  * @param version version for the de-serialization algorithm.  * @param <K> type of key.  * @param <N> type of namespace.  * @param <S> type of state.  * @return the appropriate reader.  */ ;/**  * Creates a new StateTableByKeyGroupReader that inserts de-serialized mappings into the given table, using the  * de-serialization algorithm that matches the given version.  *  * @param stateTable the {@link StateTable} into which de-serialized mappings are inserted.  * @param version version for the de-serialization algorithm.  * @param <K> type of key.  * @param <N> type of namespace.  * @param <S> type of state.  * @return the appropriate reader.  */ static <K, N, S> StateSnapshotKeyGroupReader readerForVersion(StateTable<K, N, S> stateTable, int version) {     switch(version) {         case 1:             return new StateTableByKeyGroupReaderV1<>(stateTable).         case 2:         case 3:         case 4:         case 5:         case 6:             return createV2PlusReader(stateTable).         default:             throw new IllegalArgumentException("Unknown version: " + version).     } }
false;private,static;1;12;;private static <K, N, S> StateSnapshotKeyGroupReader createV2PlusReader(StateTable<K, N, S> stateTable) {     final TypeSerializer<K> keySerializer = stateTable.keyContext.getKeySerializer().     final TypeSerializer<N> namespaceSerializer = stateTable.getNamespaceSerializer().     final TypeSerializer<S> stateSerializer = stateTable.getStateSerializer().     final Tuple3<N, K, S> buffer = new Tuple3<>().     return KeyGroupPartitioner.createKeyGroupPartitionReader((in) -> {         buffer.f0 = namespaceSerializer.deserialize(in).         buffer.f1 = keySerializer.deserialize(in).         buffer.f2 = stateSerializer.deserialize(in).         return buffer.     }, (element, keyGroupId1) -> stateTable.put(element.f1, keyGroupId1, element.f0, element.f2)). }
false;public;2;23;;@Override public void readMappingsInKeyGroup(@Nonnull DataInputView inView, @Nonnegative int keyGroupId) throws IOException {     if (inView.readByte() == 0) {         return.     }     final TypeSerializer<K> keySerializer = stateTable.keyContext.getKeySerializer().     final TypeSerializer<N> namespaceSerializer = stateTable.getNamespaceSerializer().     final TypeSerializer<S> stateSerializer = stateTable.getStateSerializer().     // V1 uses kind of namespace compressing format     int numNamespaces = inView.readInt().     for (int k = 0. k < numNamespaces. k++) {         N namespace = namespaceSerializer.deserialize(inView).         int numEntries = inView.readInt().         for (int l = 0. l < numEntries. l++) {             K key = keySerializer.deserialize(inView).             S state = stateSerializer.deserialize(inView).             stateTable.put(key, keyGroupId, namespace, state).         }     } }
