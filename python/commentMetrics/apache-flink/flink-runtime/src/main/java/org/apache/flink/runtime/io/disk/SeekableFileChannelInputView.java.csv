commented;modifiers;parameterAmount;loc;comment;code
false;public;1;29;;public void seek(long position) throws IOException {     final int block = MathUtils.checkedDownCast(position / segmentSize).     final int positionInBlock = (int) (position % segmentSize).     if (position < 0 || block >= numBlocksTotal || (block == numBlocksTotal - 1 && positionInBlock > sizeOfLastBlock)) {         throw new IllegalArgumentException("Position is out of range").     }     clear().     if (reader != null) {         reader.close().     }     reader = ioManager.createBlockChannelReader(channelId).     if (block > 0) {         reader.seekToPosition(((long) block) * segmentSize).     }     this.numBlocksRemaining = this.numBlocksTotal - block.     this.numRequestsRemaining = numBlocksRemaining.     for (int i = 0. i < memory.size(). i++) {         sendReadRequest(memory.get(i)).     }     numBlocksRemaining--.     seekInput(reader.getNextReturnedBlock(), positionInBlock, numBlocksRemaining == 0 ? sizeOfLastBlock : segmentSize). }
false;public;0;3;;public void close() throws IOException {     close(false). }
false;public;0;3;;public void closeAndDelete() throws IOException {     close(true). }
false;private;1;15;;private void close(boolean deleteFile) throws IOException {     try {         clear().         if (deleteFile) {             reader.closeAndDelete().         } else {             reader.close().         }     } finally {         synchronized (memory) {             memManager.release(memory).             memory.clear().         }     } }
false;protected;1;17;;@Override protected MemorySegment nextSegment(MemorySegment current) throws IOException {     // check for end-of-stream     if (numBlocksRemaining <= 0) {         reader.close().         throw new EOFException().     }     // send a request first. if we have only a single segment, this same segment will be the one obtained in the next lines     if (current != null) {         sendReadRequest(current).     }     // get the next segment     numBlocksRemaining--.     return reader.getNextReturnedBlock(). }
false;protected;1;4;;@Override protected int getLimitForSegment(MemorySegment segment) {     return numBlocksRemaining > 0 ? segment.size() : sizeOfLastBlock. }
false;private;1;6;;private void sendReadRequest(MemorySegment seg) throws IOException {     if (numRequestsRemaining > 0) {         reader.readBlock(seg).         numRequestsRemaining--.     } }
