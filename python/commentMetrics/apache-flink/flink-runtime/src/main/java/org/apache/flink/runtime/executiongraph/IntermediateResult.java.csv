commented;modifiers;parameterAmount;loc;comment;code
false;public;2;13;;public void setPartition(int partitionNumber, IntermediateResultPartition partition) {     if (partition == null || partitionNumber < 0 || partitionNumber >= numParallelProducers) {         throw new IllegalArgumentException().     }     if (partitions[partitionNumber] != null) {         throw new IllegalStateException("Partition #" + partitionNumber + " has already been assigned.").     }     partitions[partitionNumber] = partition.     partitionLookupHelper.put(partition.getPartitionId(), partitionNumber).     partitionsAssigned++. }
false;public;0;3;;public IntermediateDataSetID getId() {     return id. }
false;public;0;3;;public ExecutionJobVertex getProducer() {     return producer. }
false;public;0;3;;public IntermediateResultPartition[] getPartitions() {     return partitions. }
true;public;1;13;/**  * Returns the partition with the given ID.  *  * @param resultPartitionId ID of the partition to look up  * @throws NullPointerException If partition ID <code>null</code>  * @throws IllegalArgumentException Thrown if unknown partition ID  * @return Intermediate result partition with the given ID  */ ;/**  * Returns the partition with the given ID.  *  * @param resultPartitionId ID of the partition to look up  * @throws NullPointerException If partition ID <code>null</code>  * @throws IllegalArgumentException Thrown if unknown partition ID  * @return Intermediate result partition with the given ID  */ public IntermediateResultPartition getPartitionById(IntermediateResultPartitionID resultPartitionId) {     // Looks ups the partition number via the helper map and returns the     // partition. Currently, this happens infrequently enough that we could     // consider removing the map and scanning the partitions on every lookup.     // The lookup (currently) only happen when the producer of an intermediate     // result cannot be found via its registered execution.     Integer partitionNumber = partitionLookupHelper.get(checkNotNull(resultPartitionId, "IntermediateResultPartitionID")).     if (partitionNumber != null) {         return partitions[partitionNumber].     } else {         throw new IllegalArgumentException("Unknown intermediate result partition ID " + resultPartitionId).     } }
false;public;0;3;;public int getNumberOfAssignedPartitions() {     return partitionsAssigned. }
false;public;0;3;;public ResultPartitionType getResultType() {     return resultType. }
false;public;0;11;;public int registerConsumer() {     final int index = numConsumers.     numConsumers++.     for (IntermediateResultPartition p : partitions) {         if (p.addConsumerGroup() != index) {             throw new RuntimeException("Inconsistent consumer mapping between intermediate result partitions.").         }     }     return index. }
false;public;0;3;;public int getConnectionIndex() {     return connectionIndex. }
false;;0;6;;void resetForNewExecution() {     this.numberOfRunningProducers.set(numParallelProducers).     for (IntermediateResultPartition partition : partitions) {         partition.resetForNewExecution().     } }
false;;0;3;;int decrementNumberOfRunningProducersAndGetRemaining() {     return numberOfRunningProducers.decrementAndGet(). }
false;;0;3;;boolean areAllPartitionsFinished() {     return numberOfRunningProducers.get() == 0. }
false;public;0;4;;@Override public String toString() {     return "IntermediateResult " + id.toString(). }
