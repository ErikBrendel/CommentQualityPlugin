commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;1;1;/**  * This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint  * implementation requires.  *  * @param localAddressFuture future rest address of the RestServerEndpoint  * @return Collection of AbstractRestHandler which are added to the server endpoint  */ ;/**  * This method is called at the beginning of {@link #start()} to setup all handlers that the REST server endpoint  * implementation requires.  *  * @param localAddressFuture future rest address of the RestServerEndpoint  * @return Collection of AbstractRestHandler which are added to the server endpoint  */ protected abstract List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(final CompletableFuture<String> localAddressFuture).
false;protected;1;18;;@Override protected void initChannel(SocketChannel ch) {     RouterHandler handler = new RouterHandler(router, responseHeaders).     // SSL should be the first handler in the pipeline     if (isHttpsEnabled()) {         ch.pipeline().addLast("ssl", new RedirectingSslHandler(restAddress, restAddressFuture, sslHandlerFactory)).     }     ch.pipeline().addLast(new HttpServerCodec()).addLast(new FileUploadHandler(uploadDir)).addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders)).addLast(new ChunkedWriteHandler()).addLast(handler.getName(), handler).addLast(new PipelineErrorHandler(log, responseHeaders)). }
true;public,final;0;112;/**  * Starts this REST server endpoint.  *  * @throws Exception if we cannot start the RestServerEndpoint  */ ;/**  * Starts this REST server endpoint.  *  * @throws Exception if we cannot start the RestServerEndpoint  */ public final void start() throws Exception {     synchronized (lock) {         Preconditions.checkState(state == State.CREATED, "The RestServerEndpoint cannot be restarted.").         log.info("Starting rest endpoint.").         final Router router = new Router().         final CompletableFuture<String> restAddressFuture = new CompletableFuture<>().         handlers = initializeHandlers(restAddressFuture).         /* sort the handlers such that they are ordered the following: 			 * /jobs 			 * /jobs/overview 			 * /jobs/:jobid 			 * /jobs/:jobid/config 			 * /:* 			 */         Collections.sort(handlers, RestHandlerUrlComparator.INSTANCE).         handlers.forEach(handler -> {             registerHandler(router, handler, log).         }).         ChannelInitializer<SocketChannel> initializer = new ChannelInitializer<SocketChannel>() {              @Override             protected void initChannel(SocketChannel ch) {                 RouterHandler handler = new RouterHandler(router, responseHeaders).                 // SSL should be the first handler in the pipeline                 if (isHttpsEnabled()) {                     ch.pipeline().addLast("ssl", new RedirectingSslHandler(restAddress, restAddressFuture, sslHandlerFactory)).                 }                 ch.pipeline().addLast(new HttpServerCodec()).addLast(new FileUploadHandler(uploadDir)).addLast(new FlinkHttpObjectAggregator(maxContentLength, responseHeaders)).addLast(new ChunkedWriteHandler()).addLast(handler.getName(), handler).addLast(new PipelineErrorHandler(log, responseHeaders)).             }         }.         NioEventLoopGroup bossGroup = new NioEventLoopGroup(1, new ExecutorThreadFactory("flink-rest-server-netty-boss")).         NioEventLoopGroup workerGroup = new NioEventLoopGroup(0, new ExecutorThreadFactory("flink-rest-server-netty-worker")).         bootstrap = new ServerBootstrap().         bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(initializer).         Iterator<Integer> portsIterator.         try {             portsIterator = NetUtils.getPortRangeFromString(restBindPortRange).         } catch (IllegalConfigurationException e) {             throw e.         } catch (Exception e) {             throw new IllegalArgumentException("Invalid port range definition: " + restBindPortRange).         }         int chosenPort = 0.         while (portsIterator.hasNext()) {             try {                 chosenPort = portsIterator.next().                 final ChannelFuture channel.                 if (restBindAddress == null) {                     channel = bootstrap.bind(chosenPort).                 } else {                     channel = bootstrap.bind(restBindAddress, chosenPort).                 }                 serverChannel = channel.syncUninterruptibly().channel().                 break.             } catch (final Exception e) {                 // continue if the exception is due to the port being in use, fail early otherwise                 if (!(e instanceof org.jboss.netty.channel.ChannelException || e instanceof java.net.BindException)) {                     throw e.                 }             }         }         if (serverChannel == null) {             throw new BindException("Could not start rest endpoint on any port in port range " + restBindPortRange).         }         log.debug("Binding rest endpoint to {}:{}.", restBindAddress, chosenPort).         final InetSocketAddress bindAddress = (InetSocketAddress) serverChannel.localAddress().         final String advertisedAddress.         if (bindAddress.getAddress().isAnyLocalAddress()) {             advertisedAddress = this.restAddress.         } else {             advertisedAddress = bindAddress.getAddress().getHostAddress().         }         final int port = bindAddress.getPort().         log.info("Rest endpoint listening at {}:{}", advertisedAddress, port).         restBaseUrl = new URL(determineProtocol(), advertisedAddress, port, "").toString().         restAddressFuture.complete(restBaseUrl).         state = State.RUNNING.         startInternal().     } }
true;protected,abstract;0;1;/**  * Hook to start sub class specific services.  *  * @throws Exception if an error occurred  */ ;/**  * Hook to start sub class specific services.  *  * @throws Exception if an error occurred  */ protected abstract void startInternal() throws Exception.
true;public;0;17;/**  * Returns the address on which this endpoint is accepting requests.  *  * @return address on which this endpoint is accepting requests or null if none  */ ;/**  * Returns the address on which this endpoint is accepting requests.  *  * @return address on which this endpoint is accepting requests or null if none  */ @Nullable public InetSocketAddress getServerAddress() {     synchronized (lock) {         Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.").         Channel server = this.serverChannel.         if (server != null) {             try {                 return ((InetSocketAddress) server.localAddress()).             } catch (Exception e) {                 log.error("Cannot access local server address", e).             }         }         return null.     } }
true;public;0;6;/**  * Returns the base URL of the REST server endpoint.  *  * @return REST base URL of this endpoint  */ ;/**  * Returns the base URL of the REST server endpoint.  *  * @return REST base URL of this endpoint  */ public String getRestBaseUrl() {     synchronized (lock) {         Preconditions.checkState(state != State.CREATED, "The RestServerEndpoint has not been started yet.").         return restBaseUrl.     } }
false;public;0;28;;@Override public CompletableFuture<Void> closeAsync() {     synchronized (lock) {         log.info("Shutting down rest endpoint.").         if (state == State.RUNNING) {             final CompletableFuture<Void> shutDownFuture = FutureUtils.composeAfterwards(closeHandlersAsync(), this::shutDownInternal).             shutDownFuture.whenComplete((Void ignored, Throwable throwable) -> {                 log.info("Shut down complete.").                 if (throwable != null) {                     terminationFuture.completeExceptionally(throwable).                 } else {                     terminationFuture.complete(null).                 }             }).             state = State.SHUTDOWN.         } else if (state == State.CREATED) {             terminationFuture.complete(null).             state = State.SHUTDOWN.         }         return terminationFuture.     } }
false;private;0;7;;private FutureUtils.ConjunctFuture<Void> closeHandlersAsync() {     return FutureUtils.waitForAll(handlers.stream().map(tuple -> tuple.f1).filter(handler -> handler instanceof AutoCloseableAsync).map(handler -> ((AutoCloseableAsync) handler).closeAsync()).collect(Collectors.toList())). }
true;protected;0;75;/**  * Stops this REST server endpoint.  *  * @return Future which is completed once the shut down has been finished.  */ ;/**  * Stops this REST server endpoint.  *  * @return Future which is completed once the shut down has been finished.  */ protected CompletableFuture<Void> shutDownInternal() {     synchronized (lock) {         CompletableFuture<?> channelFuture = new CompletableFuture<>().         if (serverChannel != null) {             serverChannel.close().addListener(finished -> {                 if (finished.isSuccess()) {                     channelFuture.complete(null).                 } else {                     channelFuture.completeExceptionally(finished.cause()).                 }             }).             serverChannel = null.         }         final CompletableFuture<Void> channelTerminationFuture = new CompletableFuture<>().         channelFuture.thenRun(() -> {             CompletableFuture<?> groupFuture = new CompletableFuture<>().             CompletableFuture<?> childGroupFuture = new CompletableFuture<>().             final Time gracePeriod = Time.seconds(10L).             if (bootstrap != null) {                 final ServerBootstrapConfig config = bootstrap.config().                 final EventLoopGroup group = config.group().                 if (group != null) {                     group.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS).addListener(finished -> {                         if (finished.isSuccess()) {                             groupFuture.complete(null).                         } else {                             groupFuture.completeExceptionally(finished.cause()).                         }                     }).                 } else {                     groupFuture.complete(null).                 }                 final EventLoopGroup childGroup = config.childGroup().                 if (childGroup != null) {                     childGroup.shutdownGracefully(0L, gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS).addListener(finished -> {                         if (finished.isSuccess()) {                             childGroupFuture.complete(null).                         } else {                             childGroupFuture.completeExceptionally(finished.cause()).                         }                     }).                 } else {                     childGroupFuture.complete(null).                 }                 bootstrap = null.             } else {                 // complete the group futures since there is nothing to stop                 groupFuture.complete(null).                 childGroupFuture.complete(null).             }             CompletableFuture<Void> combinedFuture = FutureUtils.completeAll(Arrays.asList(groupFuture, childGroupFuture)).             combinedFuture.whenComplete((Void ignored, Throwable throwable) -> {                 if (throwable != null) {                     channelTerminationFuture.completeExceptionally(throwable).                 } else {                     channelTerminationFuture.complete(null).                 }             }).         }).         return channelTerminationFuture.     } }
false;private;0;3;;private boolean isHttpsEnabled() {     return sslHandlerFactory != null. }
false;private;0;3;;private String determineProtocol() {     return isHttpsEnabled() ? "https" : "http". }
false;private,static;3;14;;private static void registerHandler(Router router, Tuple2<RestHandlerSpecification, ChannelInboundHandler> specificationHandler, Logger log) {     final String handlerURL = specificationHandler.f0.getTargetRestEndpointURL().     // setup versioned urls     for (final RestAPIVersion supportedVersion : specificationHandler.f0.getSupportedAPIVersions()) {         final String versionedHandlerURL = '/' + supportedVersion.getURLVersionPrefix() + handlerURL.         log.debug("Register handler {} under {}@{}.", specificationHandler.f1, specificationHandler.f0.getHttpMethod(), versionedHandlerURL).         registerHandler(router, versionedHandlerURL, specificationHandler.f0.getHttpMethod(), specificationHandler.f1).         if (supportedVersion.isDefaultVersion()) {             // setup unversioned url for convenience and backwards compatibility             log.debug("Register handler {} under {}@{}.", specificationHandler.f1, specificationHandler.f0.getHttpMethod(), handlerURL).             registerHandler(router, handlerURL, specificationHandler.f0.getHttpMethod(), specificationHandler.f1).         }     } }
false;private,static;4;18;;private static void registerHandler(Router router, String handlerURL, HttpMethodWrapper httpMethod, ChannelInboundHandler handler) {     switch(httpMethod) {         case GET:             router.addGet(handlerURL, handler).             break.         case POST:             router.addPost(handlerURL, handler).             break.         case DELETE:             router.addDelete(handlerURL, handler).             break.         case PATCH:             router.addPatch(handlerURL, handler).             break.         default:             throw new RuntimeException("Unsupported http method: " + httpMethod + '.').     } }
true;static;2;8;/**  * Creates the upload dir if needed.  */ ;/**  * Creates the upload dir if needed.  */ @VisibleForTesting static void createUploadDir(final Path uploadDir, final Logger log) throws IOException {     if (!Files.exists(uploadDir)) {         log.warn("Upload directory {} does not exist, or has been deleted externally. " + "Previously uploaded files are no longer available.", uploadDir).         checkAndCreateUploadDir(uploadDir, log).     } }
true;private,static,synchronized;2;12;/**  * Checks whether the given directory exists and is writable. If it doesn't exist, this method  * will attempt to create it.  *  * @param uploadDir directory to check  * @param log logger used for logging output  * @throws IOException if the directory does not exist and cannot be created, or if the  *                     directory isn't writable  */ ;/**  * Checks whether the given directory exists and is writable. If it doesn't exist, this method  * will attempt to create it.  *  * @param uploadDir directory to check  * @param log logger used for logging output  * @throws IOException if the directory does not exist and cannot be created, or if the  *                     directory isn't writable  */ private static synchronized void checkAndCreateUploadDir(final Path uploadDir, final Logger log) throws IOException {     if (Files.exists(uploadDir) && Files.isWritable(uploadDir)) {         log.info("Using directory {} for file uploads.", uploadDir).     } else if (Files.isWritable(Files.createDirectories(uploadDir))) {         log.info("Created directory {} for file uploads.", uploadDir).     } else {         log.warn("Upload directory {} cannot be created or is not writable.", uploadDir).         throw new IOException(String.format("Upload directory %s cannot be created or is not writable.", uploadDir)).     } }
false;public;2;13;;@Override public int compare(Tuple2<RestHandlerSpecification, ChannelInboundHandler> o1, Tuple2<RestHandlerSpecification, ChannelInboundHandler> o2) {     final int urlComparisonResult = CASE_INSENSITIVE_ORDER.compare(o1.f0.getTargetRestEndpointURL(), o2.f0.getTargetRestEndpointURL()).     if (urlComparisonResult != 0) {         return urlComparisonResult.     } else {         return API_VERSION_ORDER.compare(Collections.min(o1.f0.getSupportedAPIVersions()), Collections.min(o2.f0.getSupportedAPIVersions())).     } }
false;public;2;30;;@Override public int compare(String s1, String s2) {     int n1 = s1.length().     int n2 = s2.length().     int min = Math.min(n1, n2).     for (int i = 0. i < min. i++) {         char c1 = s1.charAt(i).         char c2 = s2.charAt(i).         if (c1 != c2) {             c1 = Character.toUpperCase(c1).             c2 = Character.toUpperCase(c2).             if (c1 != c2) {                 c1 = Character.toLowerCase(c1).                 c2 = Character.toLowerCase(c2).                 if (c1 != c2) {                     if (c1 == ':') {                         // c2 is less than c1 because it is also different                         return 1.                     } else if (c2 == ':') {                         // c1 is less than c2                         return -1.                     } else {                         return c1 - c2.                     }                 }             }         }     }     return n1 - n2. }
