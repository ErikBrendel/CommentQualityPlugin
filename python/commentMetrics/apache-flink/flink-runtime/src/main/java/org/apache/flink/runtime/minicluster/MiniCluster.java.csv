commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;public CompletableFuture<URI> getRestAddress() {     synchronized (lock) {         checkState(running, "MiniCluster is not yet running.").         return webMonitorLeaderRetriever.getLeaderFuture().thenApply(FunctionUtils.uncheckedFunction(addressLeaderIdTuple -> new URI(addressLeaderIdTuple.f0))).     } }
false;public;0;6;;public ClusterInformation getClusterInformation() {     synchronized (lock) {         checkState(running, "MiniCluster is not yet running.").         return new ClusterInformation("localhost", blobServer.getPort()).     } }
false;public;0;6;;public HighAvailabilityServices getHighAvailabilityServices() {     synchronized (lock) {         checkState(running, "MiniCluster is not yet running.").         return haServices.     } }
false;protected;0;7;;@VisibleForTesting @Nonnull protected Collection<DispatcherResourceManagerComponent<?>> getDispatcherResourceManagerComponents() {     synchronized (lock) {         return Collections.unmodifiableCollection(dispatcherResourceManagerComponents).     } }
true;public;0;3;/**  * Checks if the mini cluster was started and is running.  */ ;// ------------------------------------------------------------------------ // life cycle // ------------------------------------------------------------------------ /**  * Checks if the mini cluster was started and is running.  */ public boolean isRunning() {     return running. }
true;public;0;117;/**  * Starts the mini cluster, based on the configured properties.  *  * @throws Exception This method passes on any exception that occurs during the startup of  *                   the mini cluster.  */ ;/**  * Starts the mini cluster, based on the configured properties.  *  * @throws Exception This method passes on any exception that occurs during the startup of  *                   the mini cluster.  */ public void start() throws Exception {     synchronized (lock) {         checkState(!running, "MiniCluster is already running").         LOG.info("Starting Flink Mini Cluster").         LOG.debug("Using configuration {}", miniClusterConfiguration).         final Configuration configuration = miniClusterConfiguration.getConfiguration().         final boolean useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED.         try {             initializeIOFormatClasses(configuration).             LOG.info("Starting Metrics Registry").             metricRegistry = createMetricRegistry(configuration).             // bring up all the RPC services             LOG.info("Starting RPC Service(s)").             AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration).             final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory.             if (useSingleRpcService) {                 // we always need the 'commonRpcService' for auxiliary calls                 commonRpcService = createRpcService(akkaRpcServiceConfig, false, null).                 final CommonRpcServiceFactory commonRpcServiceFactory = new CommonRpcServiceFactory(commonRpcService).                 taskManagerRpcServiceFactory = commonRpcServiceFactory.                 dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory.             } else {                 // we always need the 'commonRpcService' for auxiliary calls                 commonRpcService = createRpcService(akkaRpcServiceConfig, true, null).                 // start a new service per component, possibly with custom bind addresses                 final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress().                 final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress().                 dispatcherResourceManagreComponentRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress).                 taskManagerRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress).             }             // TODO: Temporary hack until the metric query service is ported to the RpcEndpoint             metricQueryServiceActorSystem = MetricUtils.startMetricsActorSystem(configuration, commonRpcService.getAddress(), LOG).             metricRegistry.startQueryService(metricQueryServiceActorSystem, null).             haServices = createHighAvailabilityServices(configuration, commonRpcService.getExecutor()).             blobServer = new BlobServer(configuration, haServices.createBlobStore()).             blobServer.start().             heartbeatServices = HeartbeatServices.fromConfiguration(configuration).             blobCacheService = new BlobCacheService(configuration, haServices.createBlobStore(), new InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())).             startTaskManagers().             MetricQueryServiceRetriever metricQueryServiceRetriever = new AkkaQueryServiceRetriever(metricQueryServiceActorSystem, Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT))).             dispatcherResourceManagerComponents.addAll(createDispatcherResourceManagerComponents(configuration, dispatcherResourceManagreComponentRpcServiceFactory, haServices, blobServer, heartbeatServices, metricRegistry, metricQueryServiceRetriever, new ShutDownFatalErrorHandler())).             resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever().             dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever().             webMonitorLeaderRetrievalService = haServices.getWebMonitorLeaderRetriever().             dispatcherGatewayRetriever = new RpcGatewayRetriever<>(commonRpcService, DispatcherGateway.class, DispatcherId::fromUuid, 20, Time.milliseconds(20L)).             resourceManagerGatewayRetriever = new RpcGatewayRetriever<>(commonRpcService, ResourceManagerGateway.class, ResourceManagerId::fromUuid, 20, Time.milliseconds(20L)).             webMonitorLeaderRetriever = new LeaderRetriever().             resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever).             dispatcherLeaderRetriever.start(dispatcherGatewayRetriever).             webMonitorLeaderRetrievalService.start(webMonitorLeaderRetriever).         } catch (Exception e) {             // cleanup everything             try {                 close().             } catch (Exception ee) {                 e.addSuppressed(ee).             }             throw e.         }         // create a new termination future         terminationFuture = new CompletableFuture<>().         // now officially mark this as running         running = true.         LOG.info("Flink Mini Cluster started successfully").     } }
false;protected;8;23;;@VisibleForTesting protected Collection<? extends DispatcherResourceManagerComponent<?>> createDispatcherResourceManagerComponents(Configuration configuration, RpcServiceFactory rpcServiceFactory, HighAvailabilityServices haServices, BlobServer blobServer, HeartbeatServices heartbeatServices, MetricRegistry metricRegistry, MetricQueryServiceRetriever metricQueryServiceRetriever, FatalErrorHandler fatalErrorHandler) throws Exception {     SessionDispatcherResourceManagerComponentFactory dispatcherResourceManagerComponentFactory = createDispatcherResourceManagerComponentFactory().     return Collections.singleton(dispatcherResourceManagerComponentFactory.create(configuration, rpcServiceFactory.createRpcService(), haServices, blobServer, heartbeatServices, metricRegistry, new MemoryArchivedExecutionGraphStore(), metricQueryServiceRetriever, fatalErrorHandler)). }
false;private;0;4;;@Nonnull private SessionDispatcherResourceManagerComponentFactory createDispatcherResourceManagerComponentFactory() {     return new SessionDispatcherResourceManagerComponentFactory(StandaloneResourceManagerFactory.INSTANCE). }
false;protected;2;7;;@VisibleForTesting protected HighAvailabilityServices createHighAvailabilityServices(Configuration configuration, Executor executor) throws Exception {     LOG.info("Starting high-availability services").     return HighAvailabilityServicesUtils.createAvailableOrEmbeddedServices(configuration, executor). }
true;public;0;43;/**  * Shuts down the mini cluster, failing all currently executing jobs.  * The mini cluster can be started again by calling the {@link #start()} method again.  *  * <p>This method shuts down all started services and components,  * even if an exception occurs in the process of shutting down some component.  *  * @return Future which is completed once the MiniCluster has been completely shut down  */ ;/**  * Shuts down the mini cluster, failing all currently executing jobs.  * The mini cluster can be started again by calling the {@link #start()} method again.  *  * <p>This method shuts down all started services and components,  * even if an exception occurs in the process of shutting down some component.  *  * @return Future which is completed once the MiniCluster has been completely shut down  */ @Override public CompletableFuture<Void> closeAsync() {     synchronized (lock) {         if (running) {             LOG.info("Shutting down Flink Mini Cluster").             try {                 final int numComponents = 2 + miniClusterConfiguration.getNumTaskManagers().                 final Collection<CompletableFuture<Void>> componentTerminationFutures = new ArrayList<>(numComponents).                 componentTerminationFutures.addAll(terminateTaskExecutors()).                 componentTerminationFutures.add(shutDownResourceManagerComponents()).                 final FutureUtils.ConjunctFuture<Void> componentsTerminationFuture = FutureUtils.completeAll(componentTerminationFutures).                 final CompletableFuture<Void> metricSystemTerminationFuture = FutureUtils.composeAfterwards(componentsTerminationFuture, this::closeMetricSystem).                 // shut down the RpcServices                 final CompletableFuture<Void> rpcServicesTerminationFuture = metricSystemTerminationFuture.thenCompose((Void ignored) -> terminateRpcServices()).                 final CompletableFuture<Void> remainingServicesTerminationFuture = FutureUtils.runAfterwards(rpcServicesTerminationFuture, this::terminateMiniClusterServices).                 remainingServicesTerminationFuture.whenComplete((Void ignored, Throwable throwable) -> {                     if (throwable != null) {                         terminationFuture.completeExceptionally(ExceptionUtils.stripCompletionException(throwable)).                     } else {                         terminationFuture.complete(null).                     }                 }).             } finally {                 running = false.             }         }         return terminationFuture.     } }
false;private;0;17;;private CompletableFuture<Void> closeMetricSystem() {     synchronized (lock) {         final ArrayList<CompletableFuture<Void>> terminationFutures = new ArrayList<>(2).         // metrics shutdown         if (metricRegistry != null) {             terminationFutures.add(metricRegistry.shutdown()).             metricRegistry = null.         }         if (metricQueryServiceActorSystem != null) {             terminationFutures.add(AkkaUtils.terminateActorSystem(metricQueryServiceActorSystem)).         }         return FutureUtils.completeAll(terminationFutures).     } }
false;private;0;10;;@GuardedBy("lock") private void startTaskManagers() throws Exception {     final int numTaskManagers = miniClusterConfiguration.getNumTaskManagers().     LOG.info("Starting {} TaskManger(s)", numTaskManagers).     for (int i = 0. i < numTaskManagers. i++) {         startTaskExecutor().     } }
false;;0;20;;@VisibleForTesting void startTaskExecutor() throws Exception {     synchronized (lock) {         final Configuration configuration = miniClusterConfiguration.getConfiguration().         final TaskExecutor taskExecutor = TaskManagerRunner.startTaskManager(configuration, new ResourceID(UUID.randomUUID().toString()), taskManagerRpcServiceFactory.createRpcService(), haServices, heartbeatServices, metricRegistry, blobCacheService, useLocalCommunication(), taskManagerTerminatingFatalErrorHandlerFactory.create(taskManagers.size())).         taskExecutor.start().         taskManagers.add(taskExecutor).     } }
false;protected;0;4;;@VisibleForTesting protected boolean useLocalCommunication() {     return miniClusterConfiguration.getNumTaskManagers() == 1. }
false;private;0;9;;@GuardedBy("lock") private Collection<? extends CompletableFuture<Void>> terminateTaskExecutors() {     final Collection<CompletableFuture<Void>> terminationFutures = new ArrayList<>(taskManagers.size()).     for (int i = 0. i < taskManagers.size(). i++) {         terminationFutures.add(terminateTaskExecutor(i)).     }     return terminationFutures. }
false;protected;1;8;;@VisibleForTesting @Nonnull protected CompletableFuture<Void> terminateTaskExecutor(int index) {     synchronized (lock) {         final TaskExecutor taskExecutor = taskManagers.get(index).         return taskExecutor.closeAsync().     } }
false;public;0;9;;// ------------------------------------------------------------------------ // Accessing jobs // ------------------------------------------------------------------------ public CompletableFuture<Collection<JobStatusMessage>> listJobs() {     return runDispatcherCommand(dispatcherGateway -> dispatcherGateway.requestMultipleJobDetails(rpcTimeout).thenApply(jobs -> jobs.getJobs().stream().map(details -> new JobStatusMessage(details.getJobId(), details.getJobName(), details.getStatus(), details.getStartTime())).collect(Collectors.toList()))). }
false;public;1;3;;public CompletableFuture<JobStatus> getJobStatus(JobID jobId) {     return runDispatcherCommand(dispatcherGateway -> dispatcherGateway.requestJobStatus(jobId, rpcTimeout)). }
false;public;1;3;;public CompletableFuture<Acknowledge> cancelJob(JobID jobId) {     return runDispatcherCommand(dispatcherGateway -> dispatcherGateway.cancelJob(jobId, rpcTimeout)). }
false;public;1;3;;public CompletableFuture<Acknowledge> stopJob(JobID jobId) {     return runDispatcherCommand(dispatcherGateway -> dispatcherGateway.stopJob(jobId, rpcTimeout)). }
false;public;3;3;;public CompletableFuture<String> triggerSavepoint(JobID jobId, String targetDirectory, boolean cancelJob) {     return runDispatcherCommand(dispatcherGateway -> dispatcherGateway.triggerSavepoint(jobId, targetDirectory, cancelJob, rpcTimeout)). }
false;public;1;3;;public CompletableFuture<Acknowledge> disposeSavepoint(String savepointPath) {     return runDispatcherCommand(dispatcherGateway -> dispatcherGateway.disposeSavepoint(savepointPath, rpcTimeout)). }
false;public;1;3;;public CompletableFuture<? extends AccessExecutionGraph> getExecutionGraph(JobID jobId) {     return runDispatcherCommand(dispatcherGateway -> dispatcherGateway.requestJob(jobId, rpcTimeout)). }
false;private;1;3;;private <T> CompletableFuture<T> runDispatcherCommand(Function<DispatcherGateway, CompletableFuture<T>> dispatcherCommand) {     return getDispatcherGatewayFuture().thenApply(dispatcherCommand).thenCompose(Function.identity()). }
true;public;1;11;/**  * This method executes a job in detached mode. The method returns immediately after the job  * has been added to the  *  * @param job  The Flink job to execute  *  * @throws JobExecutionException Thrown if anything went amiss during initial job launch,  *         or if the job terminally failed.  */ ;// ------------------------------------------------------------------------ // running jobs // ------------------------------------------------------------------------ /**  * This method executes a job in detached mode. The method returns immediately after the job  * has been added to the  *  * @param job  The Flink job to execute  *  * @throws JobExecutionException Thrown if anything went amiss during initial job launch,  *         or if the job terminally failed.  */ public void runDetached(JobGraph job) throws JobExecutionException, InterruptedException {     checkNotNull(job, "job is null").     final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job).     try {         submissionFuture.get().     } catch (ExecutionException e) {         throw new JobExecutionException(job.getJobID(), ExceptionUtils.stripExecutionException(e)).     } }
true;public;1;23;/**  * This method runs a job in blocking mode. The method returns only after the job  * completed successfully, or after it failed terminally.  *  * @param job  The Flink job to execute  * @return The result of the job execution  *  * @throws JobExecutionException Thrown if anything went amiss during initial job launch,  *         or if the job terminally failed.  */ ;/**  * This method runs a job in blocking mode. The method returns only after the job  * completed successfully, or after it failed terminally.  *  * @param job  The Flink job to execute  * @return The result of the job execution  *  * @throws JobExecutionException Thrown if anything went amiss during initial job launch,  *         or if the job terminally failed.  */ @Override public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException {     checkNotNull(job, "job is null").     final CompletableFuture<JobSubmissionResult> submissionFuture = submitJob(job).     final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose((JobSubmissionResult ignored) -> requestJobResult(job.getJobID())).     final JobResult jobResult.     try {         jobResult = jobResultFuture.get().     } catch (ExecutionException e) {         throw new JobExecutionException(job.getJobID(), "Could not retrieve JobResult.", ExceptionUtils.stripExecutionException(e)).     }     try {         return jobResult.toJobExecutionResult(Thread.currentThread().getContextClassLoader()).     } catch (IOException | ClassNotFoundException e) {         throw new JobExecutionException(job.getJobID(), e).     } }
false;public;1;20;;public CompletableFuture<JobSubmissionResult> submitJob(JobGraph jobGraph) {     final CompletableFuture<DispatcherGateway> dispatcherGatewayFuture = getDispatcherGatewayFuture().     // we have to allow queued scheduling in Flip-6 mode because we need to request slots     // from the ResourceManager     jobGraph.setAllowQueuedScheduling(true).     final CompletableFuture<InetSocketAddress> blobServerAddressFuture = createBlobServerAddress(dispatcherGatewayFuture).     final CompletableFuture<Void> jarUploadFuture = uploadAndSetJobFiles(blobServerAddressFuture, jobGraph).     final CompletableFuture<Acknowledge> acknowledgeCompletableFuture = jarUploadFuture.thenCombine(dispatcherGatewayFuture, (Void ack, DispatcherGateway dispatcherGateway) -> dispatcherGateway.submitJob(jobGraph, rpcTimeout)).thenCompose(Function.identity()).     return acknowledgeCompletableFuture.thenApply((Acknowledge ignored) -> new JobSubmissionResult(jobGraph.getJobID())). }
false;public;1;3;;public CompletableFuture<JobResult> requestJobResult(JobID jobId) {     return runDispatcherCommand(dispatcherGateway -> dispatcherGateway.requestJobResult(jobId, RpcUtils.INF_TIMEOUT)). }
false;public;0;3;;public CompletableFuture<ClusterOverview> requestClusterOverview() {     return runDispatcherCommand(dispatcherGateway -> dispatcherGateway.requestClusterOverview(RpcUtils.INF_TIMEOUT)). }
false;protected;0;7;;@VisibleForTesting protected CompletableFuture<DispatcherGateway> getDispatcherGatewayFuture() {     synchronized (lock) {         checkState(running, "MiniCluster is not yet running.").         return dispatcherGatewayRetriever.getFuture().     } }
false;private;2;9;;private CompletableFuture<Void> uploadAndSetJobFiles(final CompletableFuture<InetSocketAddress> blobServerAddressFuture, final JobGraph job) {     return blobServerAddressFuture.thenAccept(blobServerAddress -> {         try {             ClientUtils.extractAndUploadJobGraphFiles(job, () -> new BlobClient(blobServerAddress, miniClusterConfiguration.getConfiguration())).         } catch (FlinkException e) {             throw new CompletionException(e).         }     }). }
false;private;1;7;;private CompletableFuture<InetSocketAddress> createBlobServerAddress(final CompletableFuture<DispatcherGateway> dispatcherGatewayFuture) {     return dispatcherGatewayFuture.thenApply(dispatcherGateway -> dispatcherGateway.getBlobServerPort(rpcTimeout).thenApply(blobServerPort -> new InetSocketAddress(dispatcherGateway.getHostname(), blobServerPort))).thenCompose(Function.identity()). }
true;protected;1;3;/**  * Factory method to create the metric registry for the mini cluster.  *  * @param config The configuration of the mini cluster  */ ;// ------------------------------------------------------------------------ // factories - can be overridden by subclasses to alter behavior // ------------------------------------------------------------------------ /**  * Factory method to create the metric registry for the mini cluster.  *  * @param config The configuration of the mini cluster  */ protected MetricRegistryImpl createMetricRegistry(Configuration config) {     return new MetricRegistryImpl(MetricRegistryConfiguration.fromConfiguration(config)). }
true;protected;3;19;/**  * Factory method to instantiate the RPC service.  *  * @param akkaRpcServiceConfig  *            The default RPC timeout for asynchronous "ask" requests.  * @param remoteEnabled  *            True, if the RPC service should be reachable from other (remote) RPC services.  * @param bindAddress  *            The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.  *  * @return The instantiated RPC service  */ ;/**  * Factory method to instantiate the RPC service.  *  * @param akkaRpcServiceConfig  *            The default RPC timeout for asynchronous "ask" requests.  * @param remoteEnabled  *            True, if the RPC service should be reachable from other (remote) RPC services.  * @param bindAddress  *            The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.  *  * @return The instantiated RPC service  */ protected RpcService createRpcService(AkkaRpcServiceConfiguration akkaRpcServiceConfig, boolean remoteEnabled, String bindAddress) {     final Config akkaConfig.     if (remoteEnabled) {         akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0).     } else {         akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration()).     }     final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig).     final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig).     return new AkkaRpcService(actorSystem, akkaRpcServiceConfig). }
false;private;0;53;;// ------------------------------------------------------------------------ // Internal methods // ------------------------------------------------------------------------ @GuardedBy("lock") private CompletableFuture<Void> shutDownResourceManagerComponents() {     final Collection<CompletableFuture<Void>> terminationFutures = new ArrayList<>(dispatcherResourceManagerComponents.size()).     for (DispatcherResourceManagerComponent<?> dispatcherResourceManagerComponent : dispatcherResourceManagerComponents) {         terminationFutures.add(dispatcherResourceManagerComponent.closeAsync()).     }     final FutureUtils.ConjunctFuture<Void> dispatcherTerminationFuture = FutureUtils.completeAll(terminationFutures).     return FutureUtils.runAfterwards(dispatcherTerminationFuture, () -> {         Exception exception = null.         synchronized (lock) {             if (resourceManagerLeaderRetriever != null) {                 try {                     resourceManagerLeaderRetriever.stop().                 } catch (Exception e) {                     exception = ExceptionUtils.firstOrSuppressed(e, exception).                 }                 resourceManagerLeaderRetriever = null.             }             if (dispatcherLeaderRetriever != null) {                 try {                     dispatcherLeaderRetriever.stop().                 } catch (Exception e) {                     exception = ExceptionUtils.firstOrSuppressed(e, exception).                 }                 dispatcherLeaderRetriever = null.             }             if (webMonitorLeaderRetrievalService != null) {                 try {                     webMonitorLeaderRetrievalService.stop().                 } catch (Exception e) {                     exception = ExceptionUtils.firstOrSuppressed(e, exception).                 }                 webMonitorLeaderRetrievalService = null.             }         }         if (exception != null) {             throw exception.         }     }). }
false;private;0;40;;private void terminateMiniClusterServices() throws Exception {     // collect the first exception, but continue and add all successive     // exceptions as suppressed     Exception exception = null.     synchronized (lock) {         if (blobCacheService != null) {             try {                 blobCacheService.close().             } catch (Exception e) {                 exception = ExceptionUtils.firstOrSuppressed(e, exception).             }             blobCacheService = null.         }         // shut down the blob server         if (blobServer != null) {             try {                 blobServer.close().             } catch (Exception e) {                 exception = ExceptionUtils.firstOrSuppressed(e, exception).             }             blobServer = null.         }         // shut down high-availability services         if (haServices != null) {             try {                 haServices.closeAndCleanupAllData().             } catch (Exception e) {                 exception = ExceptionUtils.firstOrSuppressed(e, exception).             }             haServices = null.         }         if (exception != null) {             throw exception.         }     } }
false;private;0;19;;@Nonnull private CompletionStage<Void> terminateRpcServices() {     synchronized (lock) {         final int numRpcServices = 1 + rpcServices.size().         final Collection<CompletableFuture<?>> rpcTerminationFutures = new ArrayList<>(numRpcServices).         rpcTerminationFutures.add(commonRpcService.stopService()).         for (RpcService rpcService : rpcServices) {             rpcTerminationFutures.add(rpcService.stopService()).         }         commonRpcService = null.         rpcServices.clear().         return FutureUtils.completeAll(rpcTerminationFutures).     } }
false;;0;1;;RpcService createRpcService().
false;public;0;4;;@Override public RpcService createRpcService() {     return commonRpcService. }
false;public;0;10;;@Override public RpcService createRpcService() {     final RpcService rpcService = MiniCluster.this.createRpcService(akkaRpcServiceConfig, true, jobManagerBindAddress).     synchronized (lock) {         rpcServices.add(rpcService).     }     return rpcService. }
false;private;1;4;;// ------------------------------------------------------------------------ // miscellaneous utilities // ------------------------------------------------------------------------ private void initializeIOFormatClasses(Configuration configuration) {     // TODO: That we still have to call something like this is a crime against humanity     FileOutputFormat.initDefaultsFromConfiguration(configuration). }
false;public;1;11;;@Override public void onFatalError(Throwable exception) {     // first check if we are still running     if (running) {         LOG.error("TaskManager #{} failed.", index, exception).         synchronized (lock) {             taskManagers.get(index).closeAsync().         }     } }
false;public;1;5;;@Override public void onFatalError(Throwable exception) {     LOG.warn("Error in MiniCluster. Shutting the MiniCluster down.", exception).     closeAsync(). }
true;private;1;4;/**  * Create a new {@link TerminatingFatalErrorHandler} for the {@link TaskExecutor} with  * the given index.  *  * @param index into the {@link #taskManagers} collection to identify the correct {@link TaskExecutor}.  * @return {@link TerminatingFatalErrorHandler} for the given index  */ ;/**  * Create a new {@link TerminatingFatalErrorHandler} for the {@link TaskExecutor} with  * the given index.  *  * @param index into the {@link #taskManagers} collection to identify the correct {@link TaskExecutor}.  * @return {@link TerminatingFatalErrorHandler} for the given index  */ @GuardedBy("lock") private TerminatingFatalErrorHandler create(int index) {     return new TerminatingFatalErrorHandler(index). }
