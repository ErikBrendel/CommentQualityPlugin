commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public IntermediateDataSetID getResultId() {     return resultId. }
false;public;0;3;;public IntermediateResultPartitionID getPartitionId() {     return partitionId. }
false;public;0;3;;public ResultPartitionType getPartitionType() {     return partitionType. }
false;public;0;3;;public int getNumberOfSubpartitions() {     return numberOfSubpartitions. }
false;public;0;3;;public int getMaxParallelism() {     return maxParallelism. }
false;public;0;3;;public boolean sendScheduleOrUpdateConsumersMessage() {     return sendScheduleOrUpdateConsumersMessage. }
false;public;0;6;;@Override public String toString() {     return String.format("ResultPartitionDeploymentDescriptor [result id: %s, " + "partition id: %s, partition type: %s]", resultId, partitionId, partitionType). }
false;public,static;3;25;;// ------------------------------------------------------------------------ public static ResultPartitionDeploymentDescriptor from(IntermediateResultPartition partition, int maxParallelism, boolean lazyScheduling) {     final IntermediateDataSetID resultId = partition.getIntermediateResult().getId().     final IntermediateResultPartitionID partitionId = partition.getPartitionId().     final ResultPartitionType partitionType = partition.getIntermediateResult().getResultType().     // The produced data is partitioned among a number of subpartitions.     //      // If no consumers are known at this point, we use a single subpartition, otherwise we have     // one for each consuming sub task.     int numberOfSubpartitions = 1.     if (!partition.getConsumers().isEmpty() && !partition.getConsumers().get(0).isEmpty()) {         if (partition.getConsumers().size() > 1) {             throw new IllegalStateException("Currently, only a single consumer group per partition is supported.").         }         numberOfSubpartitions = partition.getConsumers().get(0).size().     }     return new ResultPartitionDeploymentDescriptor(resultId, partitionId, partitionType, numberOfSubpartitions, maxParallelism, lazyScheduling). }
