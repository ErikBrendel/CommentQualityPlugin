commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the ID of the resource in which the TaskManager is started. The format of this depends  * on how the TaskManager is started:  * <ul>  *     <li>If the TaskManager is started via YARN, this is the YARN container ID.</li>  *     <li>If the TaskManager is started via Mesos, this is the Mesos container ID.</li>  *     <li>If the TaskManager is started in standalone mode, or via a MiniCluster, this is a random ID.</li>  *     <li>Other deployment modes can set the resource ID in other ways.</li>  * </ul>  *  * @return The ID of the resource in which the TaskManager is started  */ ;// ------------------------------------------------------------------------ // Getters // ------------------------------------------------------------------------ /**  * Gets the ID of the resource in which the TaskManager is started. The format of this depends  * on how the TaskManager is started:  * <ul>  *     <li>If the TaskManager is started via YARN, this is the YARN container ID.</li>  *     <li>If the TaskManager is started via Mesos, this is the Mesos container ID.</li>  *     <li>If the TaskManager is started in standalone mode, or via a MiniCluster, this is a random ID.</li>  *     <li>Other deployment modes can set the resource ID in other ways.</li>  * </ul>  *  * @return The ID of the resource in which the TaskManager is started  */ public ResourceID getResourceID() {     return resourceID. }
true;public;0;3;/**  * Returns the port instance's task manager expects to receive transfer envelopes on.  *  * @return the port instance's task manager expects to receive transfer envelopes on  */ ;/**  * Returns the port instance's task manager expects to receive transfer envelopes on.  *  * @return the port instance's task manager expects to receive transfer envelopes on  */ public int dataPort() {     return dataPort. }
true;public;0;3;/**  * Returns the network address the instance's task manager binds its sockets to.  *  * @return the network address the instance's task manager binds its sockets to  */ ;/**  * Returns the network address the instance's task manager binds its sockets to.  *  * @return the network address the instance's task manager binds its sockets to  */ public InetAddress address() {     return inetAddress. }
true;public;0;3;/**  * Gets the IP address where the TaskManager operates.  *  * @return The IP address.  */ ;/**  * Gets the IP address where the TaskManager operates.  *  * @return The IP address.  */ public String addressString() {     return inetAddress.toString(). }
true;public;0;3;/**  * Returns the fully-qualified domain name the TaskManager. If the name could not be  * determined, the return value will be a textual representation of the TaskManager's IP address.  *  * @return The fully-qualified domain name of the TaskManager.  */ ;/**  * Returns the fully-qualified domain name the TaskManager. If the name could not be  * determined, the return value will be a textual representation of the TaskManager's IP address.  *  * @return The fully-qualified domain name of the TaskManager.  */ public String getFQDNHostname() {     return fqdnHostName. }
true;public;0;3;/**  * Gets the hostname of the TaskManager. The hostname derives from the fully qualified  * domain name (FQDN, see {@link #getFQDNHostname()}):  * <ul>  *     <li>If the FQDN is the textual IP address, then the hostname is also the IP address</li>  *     <li>If the FQDN has only one segment (such as "localhost", or "host17"), then this is  *         used as the hostname.</li>  *     <li>If the FQDN has multiple segments (such as "worker3.subgroup.company.net"), then the first  *         segment (here "worker3") will be used as the hostname.</li>  * </ul>  *  * @return The hostname of the TaskManager.  */ ;/**  * Gets the hostname of the TaskManager. The hostname derives from the fully qualified  * domain name (FQDN, see {@link #getFQDNHostname()}):  * <ul>  *     <li>If the FQDN is the textual IP address, then the hostname is also the IP address</li>  *     <li>If the FQDN has only one segment (such as "localhost", or "host17"), then this is  *         used as the hostname.</li>  *     <li>If the FQDN has multiple segments (such as "worker3.subgroup.company.net"), then the first  *         segment (here "worker3") will be used as the hostname.</li>  * </ul>  *  * @return The hostname of the TaskManager.  */ public String getHostname() {     return hostName. }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // Utilities // -------------------------------------------------------------------------------------------- @Override public String toString() {     return stringRepresentation. }
false;public;1;15;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     } else if (obj != null && obj.getClass() == TaskManagerLocation.class) {         TaskManagerLocation that = (TaskManagerLocation) obj.         return this.resourceID.equals(that.resourceID) && this.inetAddress.equals(that.inetAddress) && this.dataPort == that.dataPort.     } else {         return false.     } }
false;public;0;6;;@Override public int hashCode() {     return resourceID.hashCode() + 17 * inetAddress.hashCode() + 129 * dataPort. }
false;public;1;37;;@Override public int compareTo(@Nonnull TaskManagerLocation o) {     // decide based on resource ID first     int resourceIdCmp = this.resourceID.getResourceIdString().compareTo(o.resourceID.getResourceIdString()).     if (resourceIdCmp != 0) {         return resourceIdCmp.     }     // decide based on ip address next     byte[] thisAddress = this.inetAddress.getAddress().     byte[] otherAddress = o.inetAddress.getAddress().     if (thisAddress.length < otherAddress.length) {         return -1.     } else if (thisAddress.length > otherAddress.length) {         return 1.     } else {         for (int i = 0. i < thisAddress.length. i++) {             byte tb = thisAddress[i].             byte ob = otherAddress[i].             if (tb < ob) {                 return -1.             } else if (tb > ob) {                 return 1.             }         }     }     // addresses are identical, decide based on ports.     if (this.dataPort < o.dataPort) {         return -1.     } else if (this.dataPort > o.dataPort) {         return 1.     } else {         return 0.     } }
