commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the job's checkpointing configuration which is derived from the  * CheckpointConfig.  *  * @return The job's checkpointing configuration.  */ ;/**  * Returns the job's checkpointing configuration which is derived from the  * CheckpointConfig.  *  * @return The job's checkpointing configuration.  */ public CheckpointCoordinatorConfiguration getJobCheckpointingConfiguration() {     return jobCheckpointingConfiguration. }
true;public;0;24;/**  * Creates a new snapshot of the available stats.  *  * @return The latest statistics snapshot.  */ ;/**  * Creates a new snapshot of the available stats.  *  * @return The latest statistics snapshot.  */ public CheckpointStatsSnapshot createSnapshot() {     CheckpointStatsSnapshot snapshot = latestSnapshot.     // because we don't want to block the coordinator.     if (dirty && statsReadWriteLock.tryLock()) {         try {             // Create a new snapshot             snapshot = new CheckpointStatsSnapshot(counts.createSnapshot(), summary.createSnapshot(), history.createSnapshot(), latestRestoredCheckpoint).             latestSnapshot = snapshot.             dirty = false.         } finally {             statsReadWriteLock.unlock().         }     }     return snapshot. }
true;;3;27;/**  * Creates a new pending checkpoint tracker.  *  * @param checkpointId ID of the checkpoint.  * @param triggerTimestamp Trigger timestamp of the checkpoint.  * @param props The checkpoint properties.  * @return Tracker for statistics gathering.  */ ;// ------------------------------------------------------------------------ // Callbacks // ------------------------------------------------------------------------ /**  * Creates a new pending checkpoint tracker.  *  * @param checkpointId ID of the checkpoint.  * @param triggerTimestamp Trigger timestamp of the checkpoint.  * @param props The checkpoint properties.  * @return Tracker for statistics gathering.  */ PendingCheckpointStats reportPendingCheckpoint(long checkpointId, long triggerTimestamp, CheckpointProperties props) {     ConcurrentHashMap<JobVertexID, TaskStateStats> taskStateStats = createEmptyTaskStateStatsMap().     PendingCheckpointStats pending = new PendingCheckpointStats(checkpointId, triggerTimestamp, props, totalSubtaskCount, taskStateStats, new PendingCheckpointStatsCallback()).     statsReadWriteLock.lock().     try {         counts.incrementInProgressCheckpoints().         history.addInProgressCheckpoint(pending).         dirty = true.     } finally {         statsReadWriteLock.unlock().     }     return pending. }
true;;1;13;/**  * Callback when a checkpoint is restored.  *  * @param restored The restored checkpoint stats.  */ ;/**  * Callback when a checkpoint is restored.  *  * @param restored The restored checkpoint stats.  */ void reportRestoredCheckpoint(RestoredCheckpointStats restored) {     checkNotNull(restored, "Restored checkpoint").     statsReadWriteLock.lock().     try {         counts.incrementRestoredCheckpoints().         latestRestoredCheckpoint = restored.         dirty = true.     } finally {         statsReadWriteLock.unlock().     } }
true;private;1;15;/**  * Callback when a checkpoint completes.  *  * @param completed The completed checkpoint stats.  */ ;/**  * Callback when a checkpoint completes.  *  * @param completed The completed checkpoint stats.  */ private void reportCompletedCheckpoint(CompletedCheckpointStats completed) {     statsReadWriteLock.lock().     try {         latestCompletedCheckpoint = completed.         counts.incrementCompletedCheckpoints().         history.replacePendingCheckpointById(completed).         summary.updateSummary(completed).         dirty = true.     } finally {         statsReadWriteLock.unlock().     } }
true;private;1;11;/**  * Callback when a checkpoint fails.  *  * @param failed The failed checkpoint stats.  */ ;/**  * Callback when a checkpoint fails.  *  * @param failed The failed checkpoint stats.  */ private void reportFailedCheckpoint(FailedCheckpointStats failed) {     statsReadWriteLock.lock().     try {         counts.incrementFailedCheckpoints().         history.replacePendingCheckpointById(failed).         dirty = true.     } finally {         statsReadWriteLock.unlock().     } }
true;private;0;8;/**  * Creates an empty map with a {@link TaskStateStats} instance per task  * that is involved in the checkpoint.  *  * @return An empty map with an {@link TaskStateStats} entry for each task that is involved in the checkpoint.  */ ;/**  * Creates an empty map with a {@link TaskStateStats} instance per task  * that is involved in the checkpoint.  *  * @return An empty map with an {@link TaskStateStats} entry for each task that is involved in the checkpoint.  */ private ConcurrentHashMap<JobVertexID, TaskStateStats> createEmptyTaskStateStatsMap() {     ConcurrentHashMap<JobVertexID, TaskStateStats> taskStatsMap = new ConcurrentHashMap<>(jobVertices.size()).     for (ExecutionJobVertex vertex : jobVertices) {         TaskStateStats taskStats = new TaskStateStats(vertex.getJobVertexId(), vertex.getParallelism()).         taskStatsMap.put(vertex.getJobVertexId(), taskStats).     }     return taskStatsMap. }
true;;1;3;/**  * Report a completed checkpoint.  *  * @param completed The completed checkpoint.  */ ;/**  * Report a completed checkpoint.  *  * @param completed The completed checkpoint.  */ void reportCompletedCheckpoint(CompletedCheckpointStats completed) {     CheckpointStatsTracker.this.reportCompletedCheckpoint(completed). }
true;;1;3;/**  * Report a failed checkpoint.  *  * @param failed The failed checkpoint.  */ ;/**  * Report a failed checkpoint.  *  * @param failed The failed checkpoint.  */ void reportFailedCheckpoint(FailedCheckpointStats failed) {     CheckpointStatsTracker.this.reportFailedCheckpoint(failed). }
true;private;1;11;/**  * Register the exposed metrics.  *  * @param metricGroup Metric group to use for the metrics.  */ ;/**  * Register the exposed metrics.  *  * @param metricGroup Metric group to use for the metrics.  */ private void registerMetrics(MetricGroup metricGroup) {     metricGroup.gauge(NUMBER_OF_CHECKPOINTS_METRIC, new CheckpointsCounter()).     metricGroup.gauge(NUMBER_OF_IN_PROGRESS_CHECKPOINTS_METRIC, new InProgressCheckpointsCounter()).     metricGroup.gauge(NUMBER_OF_COMPLETED_CHECKPOINTS_METRIC, new CompletedCheckpointsCounter()).     metricGroup.gauge(NUMBER_OF_FAILED_CHECKPOINTS_METRIC, new FailedCheckpointsCounter()).     metricGroup.gauge(LATEST_RESTORED_CHECKPOINT_TIMESTAMP_METRIC, new LatestRestoredCheckpointTimestampGauge()).     metricGroup.gauge(LATEST_COMPLETED_CHECKPOINT_SIZE_METRIC, new LatestCompletedCheckpointSizeGauge()).     metricGroup.gauge(LATEST_COMPLETED_CHECKPOINT_DURATION_METRIC, new LatestCompletedCheckpointDurationGauge()).     metricGroup.gauge(LATEST_COMPLETED_CHECKPOINT_ALIGNMENT_BUFFERED_METRIC, new LatestCompletedCheckpointAlignmentBufferedGauge()).     metricGroup.gauge(LATEST_COMPLETED_CHECKPOINT_EXTERNAL_PATH_METRIC, new LatestCompletedCheckpointExternalPathGauge()). }
false;public;0;4;;@Override public Long getValue() {     return counts.getTotalNumberOfCheckpoints(). }
false;public;0;4;;@Override public Integer getValue() {     return counts.getNumberOfInProgressCheckpoints(). }
false;public;0;4;;@Override public Long getValue() {     return counts.getNumberOfCompletedCheckpoints(). }
false;public;0;4;;@Override public Long getValue() {     return counts.getNumberOfFailedCheckpoints(). }
false;public;0;9;;@Override public Long getValue() {     RestoredCheckpointStats restored = latestRestoredCheckpoint.     if (restored != null) {         return restored.getRestoreTimestamp().     } else {         return -1L.     } }
false;public;0;9;;@Override public Long getValue() {     CompletedCheckpointStats completed = latestCompletedCheckpoint.     if (completed != null) {         return completed.getStateSize().     } else {         return -1L.     } }
false;public;0;9;;@Override public Long getValue() {     CompletedCheckpointStats completed = latestCompletedCheckpoint.     if (completed != null) {         return completed.getEndToEndDuration().     } else {         return -1L.     } }
false;public;0;9;;@Override public Long getValue() {     CompletedCheckpointStats completed = latestCompletedCheckpoint.     if (completed != null) {         return completed.getAlignmentBuffered().     } else {         return -1L.     } }
false;public;0;9;;@Override public String getValue() {     CompletedCheckpointStats completed = latestCompletedCheckpoint.     if (completed != null && completed.getExternalPath() != null) {         return completed.getExternalPath().     } else {         return "n/a".     } }
