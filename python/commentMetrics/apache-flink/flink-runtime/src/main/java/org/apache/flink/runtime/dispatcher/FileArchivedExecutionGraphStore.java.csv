commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public ArchivedExecutionGraph load(JobID jobId) throws Exception {     return loadExecutionGraph(jobId). }
false;public;0;4;;@Override public int size() {     return Math.toIntExact(jobDetailsCache.size()). }
false;public;1;10;;@Override @Nullable public ArchivedExecutionGraph get(JobID jobId) {     try {         return archivedExecutionGraphCache.get(jobId).     } catch (ExecutionException e) {         LOG.debug("Could not load archived execution graph for job id {}.", jobId, e).         return null.     } }
false;public;1;35;;@Override public void put(ArchivedExecutionGraph archivedExecutionGraph) throws IOException {     final JobStatus jobStatus = archivedExecutionGraph.getState().     final JobID jobId = archivedExecutionGraph.getJobID().     final String jobName = archivedExecutionGraph.getJobName().     Preconditions.checkArgument(jobStatus.isGloballyTerminalState(), "The job " + jobName + '(' + jobId + ") is not in a globally terminal state. Instead it is in state " + jobStatus + '.').     switch(jobStatus) {         case FINISHED:             numFinishedJobs++.             break.         case CANCELED:             numCanceledJobs++.             break.         case FAILED:             numFailedJobs++.             break.         default:             throw new IllegalStateException("The job " + jobName + '(' + jobId + ") should have been in a globally terminal state. " + "Instead it was in state " + jobStatus + '.').     }     // write the ArchivedExecutionGraph to disk     storeArchivedExecutionGraph(archivedExecutionGraph).     final JobDetails detailsForJob = WebMonitorUtils.createDetailsForJob(archivedExecutionGraph).     jobDetailsCache.put(jobId, detailsForJob).     archivedExecutionGraphCache.put(jobId, archivedExecutionGraph). }
false;public;0;4;;@Override public JobsOverview getStoredJobsOverview() {     return new JobsOverview(0, numFinishedJobs, numCanceledJobs, numFailedJobs). }
false;public;0;4;;@Override public Collection<JobDetails> getAvailableJobDetails() {     return jobDetailsCache.asMap().values(). }
false;public;1;5;;@Nullable @Override public JobDetails getAvailableJobDetails(JobID jobId) {     return jobDetailsCache.getIfPresent(jobId). }
false;public;0;12;;@Override public void close() throws IOException {     cleanupFuture.cancel(false).     jobDetailsCache.invalidateAll().     // clean up the storage directory     FileUtils.deleteFileOrDirectory(storageDir).     // Remove shutdown hook to prevent resource leaks     ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG). }
false;private;2;11;;// -------------------------------------------------------------- // Internal methods // -------------------------------------------------------------- private int calculateSize(JobID jobId, ArchivedExecutionGraph serializableExecutionGraph) {     final File archivedExecutionGraphFile = getExecutionGraphFile(jobId).     if (archivedExecutionGraphFile.exists()) {         return Math.toIntExact(archivedExecutionGraphFile.length()).     } else {         LOG.debug("Could not find archived execution graph file for {}. Estimating the size instead.", jobId).         return serializableExecutionGraph.getAllVertices().size() * 1000 + serializableExecutionGraph.getAccumulatorsSerialized().size() * 1000.     } }
false;private;1;12;;private ArchivedExecutionGraph loadExecutionGraph(JobID jobId) throws IOException, ClassNotFoundException {     final File archivedExecutionGraphFile = getExecutionGraphFile(jobId).     if (archivedExecutionGraphFile.exists()) {         try (FileInputStream fileInputStream = new FileInputStream(archivedExecutionGraphFile)) {             return InstantiationUtil.deserializeObject(fileInputStream, getClass().getClassLoader()).         }     } else {         throw new FileNotFoundException("Could not find file for archived execution graph " + jobId + ". This indicates that the file either has been deleted or never written.").     } }
false;private;1;7;;private void storeArchivedExecutionGraph(ArchivedExecutionGraph archivedExecutionGraph) throws IOException {     final File archivedExecutionGraphFile = getExecutionGraphFile(archivedExecutionGraph.getJobID()).     try (FileOutputStream fileOutputStream = new FileOutputStream(archivedExecutionGraphFile)) {         InstantiationUtil.serializeObject(fileOutputStream, archivedExecutionGraph).     } }
false;private;1;3;;private File getExecutionGraphFile(JobID jobId) {     return new File(storageDir, jobId.toString()). }
false;private;1;14;;private void deleteExecutionGraphFile(JobID jobId) {     Preconditions.checkNotNull(jobId).     final File archivedExecutionGraphFile = getExecutionGraphFile(jobId).     try {         FileUtils.deleteFileOrDirectory(archivedExecutionGraphFile).     } catch (IOException e) {         LOG.debug("Could not delete file {}.", archivedExecutionGraphFile, e).     }     archivedExecutionGraphCache.invalidate(jobId).     jobDetailsCache.invalidate(jobId). }
false;private,static;1;13;;private static File initExecutionGraphStorageDirectory(File tmpDir) throws IOException {     final int maxAttempts = 10.     for (int attempt = 0. attempt < maxAttempts. attempt++) {         final File storageDirectory = new File(tmpDir, "executionGraphStore-" + UUID.randomUUID()).         if (storageDirectory.mkdir()) {             return storageDirectory.         }     }     throw new IOException("Could not create executionGraphStorage directory in " + tmpDir + '.'). }
false;;0;4;;// -------------------------------------------------------------- // Testing methods // -------------------------------------------------------------- @VisibleForTesting File getStorageDir() {     return storageDir. }
false;;0;4;;@VisibleForTesting LoadingCache<JobID, ArchivedExecutionGraph> getArchivedExecutionGraphCache() {     return archivedExecutionGraphCache. }
