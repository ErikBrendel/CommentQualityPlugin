# id;timestamp;commentText;codeText;commentWords;codeWords
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1493403095;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = null___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null && operatorState.getState(i).getRawKeyedState() != null) {_				KeyedStateHandle intersectedKeyedStateHandle = operatorState.getState(i).getRawKeyedState().getIntersection(subtaskKeyGroupRange)___				if (intersectedKeyedStateHandle != null) {_					if (subtaskKeyedStateHandles == null) {_						subtaskKeyedStateHandles = new ArrayList<>()__					}_					subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__				}_			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,null,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,operator,state,get,state,i,get,raw,keyed,state,null,keyed,state,handle,intersected,keyed,state,handle,operator,state,get,state,i,get,raw,keyed,state,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,if,subtask,keyed,state,handles,null,subtask,keyed,state,handles,new,array,list,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1498220070;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = null___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null && operatorState.getState(i).getRawKeyedState() != null) {_				KeyedStateHandle intersectedKeyedStateHandle = operatorState.getState(i).getRawKeyedState().getIntersection(subtaskKeyGroupRange)___				if (intersectedKeyedStateHandle != null) {_					if (subtaskKeyedStateHandles == null) {_						subtaskKeyedStateHandles = new ArrayList<>()__					}_					subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__				}_			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,null,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,operator,state,get,state,i,get,raw,keyed,state,null,keyed,state,handle,intersected,keyed,state,handle,operator,state,get,state,i,get,raw,keyed,state,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,if,subtask,keyed,state,handles,null,subtask,keyed,state,handles,new,array,list,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1502801814;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> extractedKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {_				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,extracted,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1503598628;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> extractedKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {_				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,extracted,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1506354955;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> extractedKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {_				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,extracted,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1506409590;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> extractedKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {_				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,extracted,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1506608986;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> extractedKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {_				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,extracted,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1508854405;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> extractedKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {_				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,extracted,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1516626377;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> extractedKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {_				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,extracted,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1518008821;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> extractedKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {_				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,extracted,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1519568061;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> extractedKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {_				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,extracted,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1534408794;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		final int parallelism = operatorState.getParallelism()___		List<KeyedStateHandle> extractedKeyedStateHandles = null___		for (int i = 0_ i < parallelism_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()___				if (extractedKeyedStateHandles == null) {_					extractedKeyedStateHandles = new ArrayList<>(parallelism * rawKeyedState.size())__				}__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,final,int,parallelism,operator,state,get,parallelism,list,keyed,state,handle,extracted,keyed,state,handles,null,for,int,i,0,i,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,if,extracted,keyed,state,handles,null,extracted,keyed,state,handles,new,array,list,parallelism,raw,keyed,state,size,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1542043292;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		final int parallelism = operatorState.getParallelism()___		List<KeyedStateHandle> extractedKeyedStateHandles = null___		for (int i = 0_ i < parallelism_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()___				if (extractedKeyedStateHandles == null) {_					extractedKeyedStateHandles = new ArrayList<>(parallelism * rawKeyedState.size())__				}__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,final,int,parallelism,operator,state,get,parallelism,list,keyed,state,handle,extracted,keyed,state,handles,null,for,int,i,0,i,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,if,extracted,keyed,state,handles,null,extracted,keyed,state,handles,new,array,list,parallelism,raw,keyed,state,size,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getRawKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1550863152;Collect {@link KeyGroupsStateHandle  rawKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all rawKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getRawKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		final int parallelism = operatorState.getParallelism()___		List<KeyedStateHandle> extractedKeyedStateHandles = null___		for (int i = 0_ i < parallelism_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> rawKeyedState = operatorState.getState(i).getRawKeyedState()___				if (extractedKeyedStateHandles == null) {_					extractedKeyedStateHandles = new ArrayList<>(parallelism * rawKeyedState.size())__				}__				extractIntersectingState(_					rawKeyedState,_					subtaskKeyGroupRange,_					extractedKeyedStateHandles)__			}_		}__		return extractedKeyedStateHandles__	};collect,link,key,groups,state,handle,raw,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,raw,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,raw,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,final,int,parallelism,operator,state,get,parallelism,list,keyed,state,handle,extracted,keyed,state,handles,null,for,int,i,0,i,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,raw,keyed,state,operator,state,get,state,i,get,raw,keyed,state,if,extracted,keyed,state,handles,null,extracted,keyed,state,handles,new,array,list,parallelism,raw,keyed,state,size,extract,intersecting,state,raw,keyed,state,subtask,key,group,range,extracted,keyed,state,handles,return,extracted,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 			OperatorState operatorState, 			KeyGroupRange subtaskKeyGroupRange);1493403095;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_			OperatorState operatorState,_			KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = null___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null && operatorState.getState(i).getManagedKeyedState() != null) {_				KeyedStateHandle intersectedKeyedStateHandle = operatorState.getState(i).getManagedKeyedState().getIntersection(subtaskKeyGroupRange)___				if (intersectedKeyedStateHandle != null) {_					if (subtaskKeyedStateHandles == null) {_						subtaskKeyedStateHandles = new ArrayList<>()__					}_					subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__				}_			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,null,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,operator,state,get,state,i,get,managed,keyed,state,null,keyed,state,handle,intersected,keyed,state,handle,operator,state,get,state,i,get,managed,keyed,state,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,if,subtask,keyed,state,handles,null,subtask,keyed,state,handles,new,array,list,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 			OperatorState operatorState, 			KeyGroupRange subtaskKeyGroupRange);1498220070;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_			OperatorState operatorState,_			KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = null___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null && operatorState.getState(i).getManagedKeyedState() != null) {_				KeyedStateHandle intersectedKeyedStateHandle = operatorState.getState(i).getManagedKeyedState().getIntersection(subtaskKeyGroupRange)___				if (intersectedKeyedStateHandle != null) {_					if (subtaskKeyedStateHandles == null) {_						subtaskKeyedStateHandles = new ArrayList<>()__					}_					subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__				}_			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,null,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,operator,state,get,state,i,get,managed,keyed,state,null,keyed,state,handle,intersected,keyed,state,handle,operator,state,get,state,i,get,managed,keyed,state,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,if,subtask,keyed,state,handles,null,subtask,keyed,state,handles,new,array,list,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1493403095;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}__		__		final int oldParallelism = operatorState.getParallelism()__		final int newParallelism = executionJobVertex.getParallelism()___		if (operatorState.hasNonPartitionedState() && (oldParallelism != newParallelism)) {_			throw new IllegalStateException("Cannot restore the latest checkpoint because " +_				"the operator " + executionJobVertex.getJobVertexId() + " has non-partitioned " +_				"state and its parallelism changed. The operator " + executionJobVertex.getJobVertexId() +_				" has parallelism " + newParallelism + " whereas the corresponding " +_				"state object has a parallelism of " + oldParallelism)__		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported,final,int,old,parallelism,operator,state,get,parallelism,final,int,new,parallelism,execution,job,vertex,get,parallelism,if,operator,state,has,non,partitioned,state,old,parallelism,new,parallelism,throw,new,illegal,state,exception,cannot,restore,the,latest,checkpoint,because,the,operator,execution,job,vertex,get,job,vertex,id,has,non,partitioned,state,and,its,parallelism,changed,the,operator,execution,job,vertex,get,job,vertex,id,has,parallelism,new,parallelism,whereas,the,corresponding,state,object,has,a,parallelism,of,old,parallelism
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1498220070;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}__		__		final int oldParallelism = operatorState.getParallelism()__		final int newParallelism = executionJobVertex.getParallelism()___		if (operatorState.hasNonPartitionedState() && (oldParallelism != newParallelism)) {_			throw new IllegalStateException("Cannot restore the latest checkpoint because " +_				"the operator " + executionJobVertex.getJobVertexId() + " has non-partitioned " +_				"state and its parallelism changed. The operator " + executionJobVertex.getJobVertexId() +_				" has parallelism " + newParallelism + " whereas the corresponding " +_				"state object has a parallelism of " + oldParallelism)__		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported,final,int,old,parallelism,operator,state,get,parallelism,final,int,new,parallelism,execution,job,vertex,get,parallelism,if,operator,state,has,non,partitioned,state,old,parallelism,new,parallelism,throw,new,illegal,state,exception,cannot,restore,the,latest,checkpoint,because,the,operator,execution,job,vertex,get,job,vertex,id,has,non,partitioned,state,and,its,parallelism,changed,the,operator,execution,job,vertex,get,job,vertex,id,has,parallelism,new,parallelism,whereas,the,corresponding,state,object,has,a,parallelism,of,old,parallelism
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1502801814;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}__		__		final int oldParallelism = operatorState.getParallelism()__		final int newParallelism = executionJobVertex.getParallelism()___		if (operatorState.hasNonPartitionedState() && (oldParallelism != newParallelism)) {_			throw new IllegalStateException("Cannot restore the latest checkpoint because " +_				"the operator " + executionJobVertex.getJobVertexId() + " has non-partitioned " +_				"state and its parallelism changed. The operator " + executionJobVertex.getJobVertexId() +_				" has parallelism " + newParallelism + " whereas the corresponding " +_				"state object has a parallelism of " + oldParallelism)__		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported,final,int,old,parallelism,operator,state,get,parallelism,final,int,new,parallelism,execution,job,vertex,get,parallelism,if,operator,state,has,non,partitioned,state,old,parallelism,new,parallelism,throw,new,illegal,state,exception,cannot,restore,the,latest,checkpoint,because,the,operator,execution,job,vertex,get,job,vertex,id,has,non,partitioned,state,and,its,parallelism,changed,the,operator,execution,job,vertex,get,job,vertex,id,has,parallelism,new,parallelism,whereas,the,corresponding,state,object,has,a,parallelism,of,old,parallelism
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1503598628;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1506354955;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1506409590;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1506608986;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1508854405;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1516626377;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1518008821;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1519568061;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1534408794;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1542043292;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex);1550863152;Verifies conditions in regards to parallelism and maxParallelism that must be met when restoring state.__@param operatorState      state to restore_@param executionJobVertex task for which the state should be restored;private static void checkParallelismPreconditions(OperatorState operatorState, ExecutionJobVertex executionJobVertex) {_		__		if (operatorState.getMaxParallelism() < executionJobVertex.getParallelism()) {_			throw new IllegalStateException("The state for task " + executionJobVertex.getJobVertexId() +_				" can not be restored. The maximum parallelism (" + operatorState.getMaxParallelism() +_				") of the restored state is lower than the configured parallelism (" + executionJobVertex.getParallelism() +_				"). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism."_			)__		}__		_		if (operatorState.getMaxParallelism() != executionJobVertex.getMaxParallelism()) {__			if (!executionJobVertex.isMaxParallelismConfigured()) {_				__				LOG.debug("Overriding maximum parallelism for JobVertex {} from {} to {}",_					executionJobVertex.getJobVertexId(), executionJobVertex.getMaxParallelism(), operatorState.getMaxParallelism())___				executionJobVertex.setMaxParallelism(operatorState.getMaxParallelism())__			} else {_				_				throw new IllegalStateException("The maximum parallelism (" +_					operatorState.getMaxParallelism() + ") with which the latest " +_					"checkpoint of the execution job vertex " + executionJobVertex +_					" has been taken and the current maximum parallelism (" +_					executionJobVertex.getMaxParallelism() + ") changed. This " +_					"is currently not supported.")__			}_		}_	};verifies,conditions,in,regards,to,parallelism,and,max,parallelism,that,must,be,met,when,restoring,state,param,operator,state,state,to,restore,param,execution,job,vertex,task,for,which,the,state,should,be,restored;private,static,void,check,parallelism,preconditions,operator,state,operator,state,execution,job,vertex,execution,job,vertex,if,operator,state,get,max,parallelism,execution,job,vertex,get,parallelism,throw,new,illegal,state,exception,the,state,for,task,execution,job,vertex,get,job,vertex,id,can,not,be,restored,the,maximum,parallelism,operator,state,get,max,parallelism,of,the,restored,state,is,lower,than,the,configured,parallelism,execution,job,vertex,get,parallelism,please,reduce,the,parallelism,of,the,task,to,be,lower,or,equal,to,the,maximum,parallelism,if,operator,state,get,max,parallelism,execution,job,vertex,get,max,parallelism,if,execution,job,vertex,is,max,parallelism,configured,log,debug,overriding,maximum,parallelism,for,job,vertex,from,to,execution,job,vertex,get,job,vertex,id,execution,job,vertex,get,max,parallelism,operator,state,get,max,parallelism,execution,job,vertex,set,max,parallelism,operator,state,get,max,parallelism,else,throw,new,illegal,state,exception,the,maximum,parallelism,operator,state,get,max,parallelism,with,which,the,latest,checkpoint,of,the,execution,job,vertex,execution,job,vertex,has,been,taken,and,the,current,maximum,parallelism,execution,job,vertex,get,max,parallelism,changed,this,is,currently,not,supported
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1502801814;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1503598628;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1506354955;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1506409590;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1506608986;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1508854405;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1516626377;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1518008821;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1519568061;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1534408794;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1542043292;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void extractIntersectingState( 		Collection<KeyedStateHandle> originalSubtaskStateHandles, 		KeyGroupRange rangeToExtract, 		List<KeyedStateHandle> extractedStateCollector);1550863152;Extracts certain key group ranges from the given state handles and adds them to the collector.;private static void extractIntersectingState(_		Collection<KeyedStateHandle> originalSubtaskStateHandles,_		KeyGroupRange rangeToExtract,_		List<KeyedStateHandle> extractedStateCollector) {__		for (KeyedStateHandle keyedStateHandle : originalSubtaskStateHandles) {__			if (keyedStateHandle != null) {__				KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(rangeToExtract)___				if (intersectedKeyedStateHandle != null) {_					extractedStateCollector.add(intersectedKeyedStateHandle)__				}_			}_		}_	};extracts,certain,key,group,ranges,from,the,given,state,handles,and,adds,them,to,the,collector;private,static,void,extract,intersecting,state,collection,keyed,state,handle,original,subtask,state,handles,key,group,range,range,to,extract,list,keyed,state,handle,extracted,state,collector,for,keyed,state,handle,keyed,state,handle,original,subtask,state,handles,if,keyed,state,handle,null,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,range,to,extract,if,intersected,keyed,state,handle,null,extracted,state,collector,add,intersected,keyed,state,handle
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1493403095;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1498220070;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1502801814;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1503598628;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1506354955;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1506409590;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1506608986;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1508854405;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1516626377;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1518008821;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1519568061;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1534408794;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1542043292;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> private static void checkStateMappingCompleteness( 			boolean allowNonRestoredState, 			Map<OperatorID, OperatorState> operatorStates, 			Map<JobVertexID, ExecutionJobVertex> tasks);1550863152;Verifies that all operator states can be mapped to an execution job vertex.__@param allowNonRestoredState if false an exception will be thrown if a state could not be mapped_@param operatorStates operator states to map_@param tasks task to map to;private static void checkStateMappingCompleteness(_			boolean allowNonRestoredState,_			Map<OperatorID, OperatorState> operatorStates,_			Map<JobVertexID, ExecutionJobVertex> tasks) {__		Set<OperatorID> allOperatorIDs = new HashSet<>()__		for (ExecutionJobVertex executionJobVertex : tasks.values()) {_			allOperatorIDs.addAll(executionJobVertex.getOperatorIDs())__		}_		for (Map.Entry<OperatorID, OperatorState> operatorGroupStateEntry : operatorStates.entrySet()) {_			OperatorState operatorState = operatorGroupStateEntry.getValue()__			__			if (!allOperatorIDs.contains(operatorGroupStateEntry.getKey())) {_				if (allowNonRestoredState) {_					LOG.info("Skipped checkpoint state for operator {}.", operatorState.getOperatorID())__				} else {_					throw new IllegalStateException("There is no operator for the state " + operatorState.getOperatorID())__				}_			}_		}_	};verifies,that,all,operator,states,can,be,mapped,to,an,execution,job,vertex,param,allow,non,restored,state,if,false,an,exception,will,be,thrown,if,a,state,could,not,be,mapped,param,operator,states,operator,states,to,map,param,tasks,task,to,map,to;private,static,void,check,state,mapping,completeness,boolean,allow,non,restored,state,map,operator,id,operator,state,operator,states,map,job,vertex,id,execution,job,vertex,tasks,set,operator,id,all,operator,ids,new,hash,set,for,execution,job,vertex,execution,job,vertex,tasks,values,all,operator,ids,add,all,execution,job,vertex,get,operator,ids,for,map,entry,operator,id,operator,state,operator,group,state,entry,operator,states,entry,set,operator,state,operator,state,operator,group,state,entry,get,value,if,all,operator,ids,contains,operator,group,state,entry,get,key,if,allow,non,restored,state,log,info,skipped,checkpoint,state,for,operator,operator,state,get,operator,id,else,throw,new,illegal,state,exception,there,is,no,operator,for,the,state,operator,state,get,operator,id
StateAssignmentOperation -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1476972861;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
StateAssignmentOperation -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1478068461;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
StateAssignmentOperation -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1478686625;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
StateAssignmentOperation -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1481709237;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
StateAssignmentOperation -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1482244974;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
StateAssignmentOperation -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1484339359;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
StateAssignmentOperation -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1484594327;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
StateAssignmentOperation -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1485269495;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
StateAssignmentOperation -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1485363344;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1493403095;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1498220070;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1502801814;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1503598628;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1506354955;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1506409590;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1506608986;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1508854405;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1516626377;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}._<p>_<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1518008821;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1519568061;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1534408794;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>(keyedStateHandles.size())___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,keyed,state,handles,size,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1542043292;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>(keyedStateHandles.size())___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,keyed,state,handles,size,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getKeyedStateHandles( 		Collection<? extends KeyedStateHandle> keyedStateHandles, 		KeyGroupRange subtaskKeyGroupRange);1550863152;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyedStateHandle> getKeyedStateHandles(_		Collection<? extends KeyedStateHandle> keyedStateHandles,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>(keyedStateHandles.size())___		for (KeyedStateHandle keyedStateHandle : keyedStateHandles) {_			KeyedStateHandle intersectedKeyedStateHandle = keyedStateHandle.getIntersection(subtaskKeyGroupRange)___			if (intersectedKeyedStateHandle != null) {_				subtaskKeyedStateHandles.add(intersectedKeyedStateHandle)__			}_		}__		return subtaskKeyedStateHandles__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,keyed,state,handle,get,keyed,state,handles,collection,extends,keyed,state,handle,keyed,state,handles,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,keyed,state,handles,size,for,keyed,state,handle,keyed,state,handle,keyed,state,handles,keyed,state,handle,intersected,keyed,state,handle,keyed,state,handle,get,intersection,subtask,key,group,range,if,intersected,keyed,state,handle,null,subtask,keyed,state,handles,add,intersected,keyed,state,handle,return,subtask,keyed,state,handles
StateAssignmentOperation -> private static void collectParallelStatesByChainOperator( 			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState);1476972861;@param chainParallelOpStates array = chain ops, array[idx] = parallel states for this chain op._@param chainOpState;private static void collectParallelStatesByChainOperator(_			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState) {__		if (null != chainOpState) {_			for (int chainIdx = 0_ chainIdx < chainParallelOpStates.length_ ++chainIdx) {_				OperatorStateHandle operatorState = chainOpState.get(chainIdx)___				if (null != operatorState) {__					List<OperatorStateHandle> opParallelStatesForOneChainOp = chainParallelOpStates[chainIdx]___					if (null == opParallelStatesForOneChainOp) {_						opParallelStatesForOneChainOp = new ArrayList<>()__						chainParallelOpStates[chainIdx] = opParallelStatesForOneChainOp__					}_					opParallelStatesForOneChainOp.add(operatorState)__				}_			}_		}_	};param,chain,parallel,op,states,array,chain,ops,array,idx,parallel,states,for,this,chain,op,param,chain,op,state;private,static,void,collect,parallel,states,by,chain,operator,list,operator,state,handle,chain,parallel,op,states,chained,state,handle,operator,state,handle,chain,op,state,if,null,chain,op,state,for,int,chain,idx,0,chain,idx,chain,parallel,op,states,length,chain,idx,operator,state,handle,operator,state,chain,op,state,get,chain,idx,if,null,operator,state,list,operator,state,handle,op,parallel,states,for,one,chain,op,chain,parallel,op,states,chain,idx,if,null,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,new,array,list,chain,parallel,op,states,chain,idx,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,add,operator,state
StateAssignmentOperation -> private static void collectParallelStatesByChainOperator( 			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState);1478068461;@param chainParallelOpStates array = chain ops, array[idx] = parallel states for this chain op._@param chainOpState;private static void collectParallelStatesByChainOperator(_			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState) {__		if (null != chainOpState) {_			for (int chainIdx = 0_ chainIdx < chainParallelOpStates.length_ ++chainIdx) {_				OperatorStateHandle operatorState = chainOpState.get(chainIdx)___				if (null != operatorState) {__					List<OperatorStateHandle> opParallelStatesForOneChainOp = chainParallelOpStates[chainIdx]___					if (null == opParallelStatesForOneChainOp) {_						opParallelStatesForOneChainOp = new ArrayList<>()__						chainParallelOpStates[chainIdx] = opParallelStatesForOneChainOp__					}_					opParallelStatesForOneChainOp.add(operatorState)__				}_			}_		}_	};param,chain,parallel,op,states,array,chain,ops,array,idx,parallel,states,for,this,chain,op,param,chain,op,state;private,static,void,collect,parallel,states,by,chain,operator,list,operator,state,handle,chain,parallel,op,states,chained,state,handle,operator,state,handle,chain,op,state,if,null,chain,op,state,for,int,chain,idx,0,chain,idx,chain,parallel,op,states,length,chain,idx,operator,state,handle,operator,state,chain,op,state,get,chain,idx,if,null,operator,state,list,operator,state,handle,op,parallel,states,for,one,chain,op,chain,parallel,op,states,chain,idx,if,null,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,new,array,list,chain,parallel,op,states,chain,idx,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,add,operator,state
StateAssignmentOperation -> private static void collectParallelStatesByChainOperator( 			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState);1478686625;@param chainParallelOpStates array = chain ops, array[idx] = parallel states for this chain op._@param chainOpState;private static void collectParallelStatesByChainOperator(_			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState) {__		if (null != chainOpState) {_			for (int chainIdx = 0_ chainIdx < chainParallelOpStates.length_ ++chainIdx) {_				OperatorStateHandle operatorState = chainOpState.get(chainIdx)___				if (null != operatorState) {__					List<OperatorStateHandle> opParallelStatesForOneChainOp = chainParallelOpStates[chainIdx]___					if (null == opParallelStatesForOneChainOp) {_						opParallelStatesForOneChainOp = new ArrayList<>()__						chainParallelOpStates[chainIdx] = opParallelStatesForOneChainOp__					}_					opParallelStatesForOneChainOp.add(operatorState)__				}_			}_		}_	};param,chain,parallel,op,states,array,chain,ops,array,idx,parallel,states,for,this,chain,op,param,chain,op,state;private,static,void,collect,parallel,states,by,chain,operator,list,operator,state,handle,chain,parallel,op,states,chained,state,handle,operator,state,handle,chain,op,state,if,null,chain,op,state,for,int,chain,idx,0,chain,idx,chain,parallel,op,states,length,chain,idx,operator,state,handle,operator,state,chain,op,state,get,chain,idx,if,null,operator,state,list,operator,state,handle,op,parallel,states,for,one,chain,op,chain,parallel,op,states,chain,idx,if,null,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,new,array,list,chain,parallel,op,states,chain,idx,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,add,operator,state
StateAssignmentOperation -> private static void collectParallelStatesByChainOperator( 			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState);1481709237;@param chainParallelOpStates array = chain ops, array[idx] = parallel states for this chain op._@param chainOpState;private static void collectParallelStatesByChainOperator(_			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState) {__		if (null != chainOpState) {_			for (int chainIdx = 0_ chainIdx < chainParallelOpStates.length_ ++chainIdx) {_				OperatorStateHandle operatorState = chainOpState.get(chainIdx)___				if (null != operatorState) {__					List<OperatorStateHandle> opParallelStatesForOneChainOp = chainParallelOpStates[chainIdx]___					if (null == opParallelStatesForOneChainOp) {_						opParallelStatesForOneChainOp = new ArrayList<>()__						chainParallelOpStates[chainIdx] = opParallelStatesForOneChainOp__					}_					opParallelStatesForOneChainOp.add(operatorState)__				}_			}_		}_	};param,chain,parallel,op,states,array,chain,ops,array,idx,parallel,states,for,this,chain,op,param,chain,op,state;private,static,void,collect,parallel,states,by,chain,operator,list,operator,state,handle,chain,parallel,op,states,chained,state,handle,operator,state,handle,chain,op,state,if,null,chain,op,state,for,int,chain,idx,0,chain,idx,chain,parallel,op,states,length,chain,idx,operator,state,handle,operator,state,chain,op,state,get,chain,idx,if,null,operator,state,list,operator,state,handle,op,parallel,states,for,one,chain,op,chain,parallel,op,states,chain,idx,if,null,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,new,array,list,chain,parallel,op,states,chain,idx,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,add,operator,state
StateAssignmentOperation -> private static void collectParallelStatesByChainOperator( 			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState);1482244974;@param chainParallelOpStates array = chain ops, array[idx] = parallel states for this chain op._@param chainOpState;private static void collectParallelStatesByChainOperator(_			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState) {__		if (null != chainOpState) {_			for (int chainIdx = 0_ chainIdx < chainParallelOpStates.length_ ++chainIdx) {_				OperatorStateHandle operatorState = chainOpState.get(chainIdx)___				if (null != operatorState) {__					List<OperatorStateHandle> opParallelStatesForOneChainOp = chainParallelOpStates[chainIdx]___					if (null == opParallelStatesForOneChainOp) {_						opParallelStatesForOneChainOp = new ArrayList<>()__						chainParallelOpStates[chainIdx] = opParallelStatesForOneChainOp__					}_					opParallelStatesForOneChainOp.add(operatorState)__				}_			}_		}_	};param,chain,parallel,op,states,array,chain,ops,array,idx,parallel,states,for,this,chain,op,param,chain,op,state;private,static,void,collect,parallel,states,by,chain,operator,list,operator,state,handle,chain,parallel,op,states,chained,state,handle,operator,state,handle,chain,op,state,if,null,chain,op,state,for,int,chain,idx,0,chain,idx,chain,parallel,op,states,length,chain,idx,operator,state,handle,operator,state,chain,op,state,get,chain,idx,if,null,operator,state,list,operator,state,handle,op,parallel,states,for,one,chain,op,chain,parallel,op,states,chain,idx,if,null,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,new,array,list,chain,parallel,op,states,chain,idx,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,add,operator,state
StateAssignmentOperation -> private static void collectParallelStatesByChainOperator( 			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState);1484339359;@param chainParallelOpStates array = chain ops, array[idx] = parallel states for this chain op._@param chainOpState;private static void collectParallelStatesByChainOperator(_			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState) {__		if (null != chainOpState) {_			for (int chainIdx = 0_ chainIdx < chainParallelOpStates.length_ ++chainIdx) {_				OperatorStateHandle operatorState = chainOpState.get(chainIdx)___				if (null != operatorState) {__					List<OperatorStateHandle> opParallelStatesForOneChainOp = chainParallelOpStates[chainIdx]___					if (null == opParallelStatesForOneChainOp) {_						opParallelStatesForOneChainOp = new ArrayList<>()__						chainParallelOpStates[chainIdx] = opParallelStatesForOneChainOp__					}_					opParallelStatesForOneChainOp.add(operatorState)__				}_			}_		}_	};param,chain,parallel,op,states,array,chain,ops,array,idx,parallel,states,for,this,chain,op,param,chain,op,state;private,static,void,collect,parallel,states,by,chain,operator,list,operator,state,handle,chain,parallel,op,states,chained,state,handle,operator,state,handle,chain,op,state,if,null,chain,op,state,for,int,chain,idx,0,chain,idx,chain,parallel,op,states,length,chain,idx,operator,state,handle,operator,state,chain,op,state,get,chain,idx,if,null,operator,state,list,operator,state,handle,op,parallel,states,for,one,chain,op,chain,parallel,op,states,chain,idx,if,null,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,new,array,list,chain,parallel,op,states,chain,idx,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,add,operator,state
StateAssignmentOperation -> private static void collectParallelStatesByChainOperator( 			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState);1484594327;@param chainParallelOpStates array = chain ops, array[idx] = parallel states for this chain op._@param chainOpState;private static void collectParallelStatesByChainOperator(_			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState) {__		if (null != chainOpState) {_			for (int chainIdx = 0_ chainIdx < chainParallelOpStates.length_ ++chainIdx) {_				OperatorStateHandle operatorState = chainOpState.get(chainIdx)___				if (null != operatorState) {__					List<OperatorStateHandle> opParallelStatesForOneChainOp = chainParallelOpStates[chainIdx]___					if (null == opParallelStatesForOneChainOp) {_						opParallelStatesForOneChainOp = new ArrayList<>()__						chainParallelOpStates[chainIdx] = opParallelStatesForOneChainOp__					}_					opParallelStatesForOneChainOp.add(operatorState)__				}_			}_		}_	};param,chain,parallel,op,states,array,chain,ops,array,idx,parallel,states,for,this,chain,op,param,chain,op,state;private,static,void,collect,parallel,states,by,chain,operator,list,operator,state,handle,chain,parallel,op,states,chained,state,handle,operator,state,handle,chain,op,state,if,null,chain,op,state,for,int,chain,idx,0,chain,idx,chain,parallel,op,states,length,chain,idx,operator,state,handle,operator,state,chain,op,state,get,chain,idx,if,null,operator,state,list,operator,state,handle,op,parallel,states,for,one,chain,op,chain,parallel,op,states,chain,idx,if,null,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,new,array,list,chain,parallel,op,states,chain,idx,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,add,operator,state
StateAssignmentOperation -> private static void collectParallelStatesByChainOperator( 			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState);1485269495;@param chainParallelOpStates array = chain ops, array[idx] = parallel states for this chain op._@param chainOpState the operator chain;private static void collectParallelStatesByChainOperator(_			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState) {__		if (null != chainOpState) {_			for (int chainIdx = 0_ chainIdx < chainParallelOpStates.length_ ++chainIdx) {_				OperatorStateHandle operatorState = chainOpState.get(chainIdx)___				if (null != operatorState) {__					List<OperatorStateHandle> opParallelStatesForOneChainOp = chainParallelOpStates[chainIdx]___					if (null == opParallelStatesForOneChainOp) {_						opParallelStatesForOneChainOp = new ArrayList<>()__						chainParallelOpStates[chainIdx] = opParallelStatesForOneChainOp__					}_					opParallelStatesForOneChainOp.add(operatorState)__				}_			}_		}_	};param,chain,parallel,op,states,array,chain,ops,array,idx,parallel,states,for,this,chain,op,param,chain,op,state,the,operator,chain;private,static,void,collect,parallel,states,by,chain,operator,list,operator,state,handle,chain,parallel,op,states,chained,state,handle,operator,state,handle,chain,op,state,if,null,chain,op,state,for,int,chain,idx,0,chain,idx,chain,parallel,op,states,length,chain,idx,operator,state,handle,operator,state,chain,op,state,get,chain,idx,if,null,operator,state,list,operator,state,handle,op,parallel,states,for,one,chain,op,chain,parallel,op,states,chain,idx,if,null,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,new,array,list,chain,parallel,op,states,chain,idx,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,add,operator,state
StateAssignmentOperation -> private static void collectParallelStatesByChainOperator( 			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState);1485363344;@param chainParallelOpStates array = chain ops, array[idx] = parallel states for this chain op._@param chainOpState the operator chain;private static void collectParallelStatesByChainOperator(_			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState) {__		if (null != chainOpState) {__			int chainLength = chainOpState.getLength()__			Preconditions.checkState(chainLength >= chainParallelOpStates.length,_					"Found more states than operators in the chain. Chain length: " + chainLength +_							", States: " + chainParallelOpStates.length)___			for (int chainIdx = 0_ chainIdx < chainParallelOpStates.length_ ++chainIdx) {_				OperatorStateHandle operatorState = chainOpState.get(chainIdx)___				if (null != operatorState) {__					List<OperatorStateHandle> opParallelStatesForOneChainOp = chainParallelOpStates[chainIdx]___					if (null == opParallelStatesForOneChainOp) {_						opParallelStatesForOneChainOp = new ArrayList<>()__						chainParallelOpStates[chainIdx] = opParallelStatesForOneChainOp__					}_					opParallelStatesForOneChainOp.add(operatorState)__				}_			}_		}_	};param,chain,parallel,op,states,array,chain,ops,array,idx,parallel,states,for,this,chain,op,param,chain,op,state,the,operator,chain;private,static,void,collect,parallel,states,by,chain,operator,list,operator,state,handle,chain,parallel,op,states,chained,state,handle,operator,state,handle,chain,op,state,if,null,chain,op,state,int,chain,length,chain,op,state,get,length,preconditions,check,state,chain,length,chain,parallel,op,states,length,found,more,states,than,operators,in,the,chain,chain,length,chain,length,states,chain,parallel,op,states,length,for,int,chain,idx,0,chain,idx,chain,parallel,op,states,length,chain,idx,operator,state,handle,operator,state,chain,op,state,get,chain,idx,if,null,operator,state,list,operator,state,handle,op,parallel,states,for,one,chain,op,chain,parallel,op,states,chain,idx,if,null,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,new,array,list,chain,parallel,op,states,chain,idx,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,add,operator,state
StateAssignmentOperation -> private static void collectParallelStatesByChainOperator( 			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState);1490724328;@param chainParallelOpStates array = chain ops, array[idx] = parallel states for this chain op._@param chainOpState the operator chain;private static void collectParallelStatesByChainOperator(_			List<OperatorStateHandle>[] chainParallelOpStates, ChainedStateHandle<OperatorStateHandle> chainOpState) {__		if (null != chainOpState) {__			int chainLength = chainOpState.getLength()__			Preconditions.checkState(chainLength >= chainParallelOpStates.length,_					"Found more states than operators in the chain. Chain length: " + chainLength +_							", States: " + chainParallelOpStates.length)___			for (int chainIdx = 0_ chainIdx < chainParallelOpStates.length_ ++chainIdx) {_				OperatorStateHandle operatorState = chainOpState.get(chainIdx)___				if (null != operatorState) {__					List<OperatorStateHandle> opParallelStatesForOneChainOp = chainParallelOpStates[chainIdx]___					if (null == opParallelStatesForOneChainOp) {_						opParallelStatesForOneChainOp = new ArrayList<>()__						chainParallelOpStates[chainIdx] = opParallelStatesForOneChainOp__					}_					opParallelStatesForOneChainOp.add(operatorState)__				}_			}_		}_	};param,chain,parallel,op,states,array,chain,ops,array,idx,parallel,states,for,this,chain,op,param,chain,op,state,the,operator,chain;private,static,void,collect,parallel,states,by,chain,operator,list,operator,state,handle,chain,parallel,op,states,chained,state,handle,operator,state,handle,chain,op,state,if,null,chain,op,state,int,chain,length,chain,op,state,get,length,preconditions,check,state,chain,length,chain,parallel,op,states,length,found,more,states,than,operators,in,the,chain,chain,length,chain,length,states,chain,parallel,op,states,length,for,int,chain,idx,0,chain,idx,chain,parallel,op,states,length,chain,idx,operator,state,handle,operator,state,chain,op,state,get,chain,idx,if,null,operator,state,list,operator,state,handle,op,parallel,states,for,one,chain,op,chain,parallel,op,states,chain,idx,if,null,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,new,array,list,chain,parallel,op,states,chain,idx,op,parallel,states,for,one,chain,op,op,parallel,states,for,one,chain,op,add,operator,state
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1502801814;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1503598628;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1506354955;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1506409590;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1506608986;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1508854405;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1516626377;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1518008821;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1519568061;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		List<KeyedStateHandle> subtaskKeyedStateHandles = new ArrayList<>()___		for (int i = 0_ i < operatorState.getParallelism()_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,list,keyed,state,handle,subtask,keyed,state,handles,new,array,list,for,int,i,0,i,operator,state,get,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1534408794;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		final int parallelism = operatorState.getParallelism()___		List<KeyedStateHandle> subtaskKeyedStateHandles = null___		for (int i = 0_ i < parallelism_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()___				if (subtaskKeyedStateHandles == null) {_					subtaskKeyedStateHandles = new ArrayList<>(parallelism * keyedStateHandles.size())__				}__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,final,int,parallelism,operator,state,get,parallelism,list,keyed,state,handle,subtask,keyed,state,handles,null,for,int,i,0,i,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,if,subtask,keyed,state,handles,null,subtask,keyed,state,handles,new,array,list,parallelism,keyed,state,handles,size,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1542043292;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		final int parallelism = operatorState.getParallelism()___		List<KeyedStateHandle> subtaskKeyedStateHandles = null___		for (int i = 0_ i < parallelism_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()___				if (subtaskKeyedStateHandles == null) {_					subtaskKeyedStateHandles = new ArrayList<>(parallelism * keyedStateHandles.size())__				}__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,final,int,parallelism,operator,state,get,parallelism,list,keyed,state,handle,subtask,keyed,state,handles,null,for,int,i,0,i,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,if,subtask,keyed,state,handles,null,subtask,keyed,state,handles,new,array,list,parallelism,keyed,state,handles,size,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<KeyedStateHandle> getManagedKeyedStateHandles( 		OperatorState operatorState, 		KeyGroupRange subtaskKeyGroupRange);1550863152;Collect {@link KeyGroupsStateHandle  managedKeyedStateHandles} which have intersection with given_{@link KeyGroupRange} from {@link TaskState operatorState}__@param operatorState        all state handles of a operator_@param subtaskKeyGroupRange the KeyGroupRange of a subtask_@return all managedKeyedStateHandles which have intersection with given KeyGroupRange;public static List<KeyedStateHandle> getManagedKeyedStateHandles(_		OperatorState operatorState,_		KeyGroupRange subtaskKeyGroupRange) {__		final int parallelism = operatorState.getParallelism()___		List<KeyedStateHandle> subtaskKeyedStateHandles = null___		for (int i = 0_ i < parallelism_ i++) {_			if (operatorState.getState(i) != null) {__				Collection<KeyedStateHandle> keyedStateHandles = operatorState.getState(i).getManagedKeyedState()___				if (subtaskKeyedStateHandles == null) {_					subtaskKeyedStateHandles = new ArrayList<>(parallelism * keyedStateHandles.size())__				}__				extractIntersectingState(_					keyedStateHandles,_					subtaskKeyGroupRange,_					subtaskKeyedStateHandles)__			}_		}__		return subtaskKeyedStateHandles__	};collect,link,key,groups,state,handle,managed,keyed,state,handles,which,have,intersection,with,given,link,key,group,range,from,link,task,state,operator,state,param,operator,state,all,state,handles,of,a,operator,param,subtask,key,group,range,the,key,group,range,of,a,subtask,return,all,managed,keyed,state,handles,which,have,intersection,with,given,key,group,range;public,static,list,keyed,state,handle,get,managed,keyed,state,handles,operator,state,operator,state,key,group,range,subtask,key,group,range,final,int,parallelism,operator,state,get,parallelism,list,keyed,state,handle,subtask,keyed,state,handles,null,for,int,i,0,i,parallelism,i,if,operator,state,get,state,i,null,collection,keyed,state,handle,keyed,state,handles,operator,state,get,state,i,get,managed,keyed,state,if,subtask,keyed,state,handles,null,subtask,keyed,state,handles,new,array,list,parallelism,keyed,state,handles,size,extract,intersecting,state,keyed,state,handles,subtask,key,group,range,subtask,keyed,state,handles,return,subtask,keyed,state,handles
StateAssignmentOperation -> public static List<List<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1534408794;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<List<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<List<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()___					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.UNION.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,list,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,list,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,union,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<List<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1542043292;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<List<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<List<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()___					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.UNION.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,list,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,list,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,union,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1476972861;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1478068461;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1478686625;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1481709237;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1482244974;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1484339359;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1484594327;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1485269495;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1485363344;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1490724328;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1493403095;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1498220070;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1502801814;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1503598628;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1506354955;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1506409590;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1506608986;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1508854405;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1516626377;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1518008821;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1519568061;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1534408794;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1542043292;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1550863152;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition._<p>_<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism     Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,p,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1493403095;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return null__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()___				for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__					_					if (OperatorStateHandle.Mode.BROADCAST.equals(metaInfo.getDistributionMode())) {_						return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__					}_				}__				repackStream.add(Collections.singletonList(operatorStateHandle))__			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,null,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,broadcast,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1498220070;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return null__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()___				for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__					_					if (OperatorStateHandle.Mode.BROADCAST.equals(metaInfo.getDistributionMode())) {_						return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__					}_				}__				repackStream.add(Collections.singletonList(operatorStateHandle))__			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,null,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,broadcast,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1502801814;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()____					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.BROADCAST.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,broadcast,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1503598628;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()____					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.BROADCAST.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,broadcast,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1506354955;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()____					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.BROADCAST.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,broadcast,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1506409590;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()____					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.BROADCAST.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,broadcast,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1506608986;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()____					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.BROADCAST.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,broadcast,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1508854405;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()____					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.BROADCAST.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,broadcast,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1516626377;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()____					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.BROADCAST.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,broadcast,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1518008821;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()___					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.UNION.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,union,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
StateAssignmentOperation -> public static List<Collection<OperatorStateHandle>> applyRepartitioner( 			OperatorStateRepartitioner opStateRepartitioner, 			List<OperatorStateHandle> chainOpParallelStates, 			int oldParallelism, 			int newParallelism);1519568061;Repartitions the given operator state using the given {@link OperatorStateRepartitioner} with respect to the new_parallelism.__@param opStateRepartitioner  partitioner to use_@param chainOpParallelStates state to repartition_@param oldParallelism        parallelism with which the state is currently partitioned_@param newParallelism        parallelism with which the state should be partitioned_@return repartitioned state;public static List<Collection<OperatorStateHandle>> applyRepartitioner(_			OperatorStateRepartitioner opStateRepartitioner,_			List<OperatorStateHandle> chainOpParallelStates,_			int oldParallelism,_			int newParallelism) {__		if (chainOpParallelStates == null) {_			return Collections.emptyList()__		}__		_		if (newParallelism != oldParallelism) {__			return opStateRepartitioner.repartitionState(_					chainOpParallelStates,_					newParallelism)__		} else {_			List<Collection<OperatorStateHandle>> repackStream = new ArrayList<>(newParallelism)__			for (OperatorStateHandle operatorStateHandle : chainOpParallelStates) {__				if (operatorStateHandle != null) {_					Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsets =_						operatorStateHandle.getStateNameToPartitionOffsets()___					for (OperatorStateHandle.StateMetaInfo metaInfo : partitionOffsets.values()) {__						_						if (OperatorStateHandle.Mode.UNION.equals(metaInfo.getDistributionMode())) {_							return opStateRepartitioner.repartitionState(_								chainOpParallelStates,_								newParallelism)__						}_					}__					repackStream.add(Collections.singletonList(operatorStateHandle))__				}_			}_			return repackStream__		}_	};repartitions,the,given,operator,state,using,the,given,link,operator,state,repartitioner,with,respect,to,the,new,parallelism,param,op,state,repartitioner,partitioner,to,use,param,chain,op,parallel,states,state,to,repartition,param,old,parallelism,parallelism,with,which,the,state,is,currently,partitioned,param,new,parallelism,parallelism,with,which,the,state,should,be,partitioned,return,repartitioned,state;public,static,list,collection,operator,state,handle,apply,repartitioner,operator,state,repartitioner,op,state,repartitioner,list,operator,state,handle,chain,op,parallel,states,int,old,parallelism,int,new,parallelism,if,chain,op,parallel,states,null,return,collections,empty,list,if,new,parallelism,old,parallelism,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,else,list,collection,operator,state,handle,repack,stream,new,array,list,new,parallelism,for,operator,state,handle,operator,state,handle,chain,op,parallel,states,if,operator,state,handle,null,map,string,operator,state,handle,state,meta,info,partition,offsets,operator,state,handle,get,state,name,to,partition,offsets,for,operator,state,handle,state,meta,info,meta,info,partition,offsets,values,if,operator,state,handle,mode,union,equals,meta,info,get,distribution,mode,return,op,state,repartitioner,repartition,state,chain,op,parallel,states,new,parallelism,repack,stream,add,collections,singleton,list,operator,state,handle,return,repack,stream
