commented;modifiers;parameterAmount;loc;comment;code
true;public;0;8;/**  * @return created matching instance of {@link BufferConsumer} to this {@link BufferBuilder}. There can exist only  * one {@link BufferConsumer} per each {@link BufferBuilder} and vice versa.  */ ;/**  * @return created matching instance of {@link BufferConsumer} to this {@link BufferBuilder}. There can exist only  * one {@link BufferConsumer} per each {@link BufferBuilder} and vice versa.  */ public BufferConsumer createBufferConsumer() {     checkState(!bufferConsumerCreated, "There can not exists two BufferConsumer for one BufferBuilder").     bufferConsumerCreated = true.     return new BufferConsumer(memorySegment, recycler, positionMarker). }
true;public;1;5;/**  * Same as {@link #append(ByteBuffer)} but additionally {@link #commit()} the appending.  */ ;/**  * Same as {@link #append(ByteBuffer)} but additionally {@link #commit()} the appending.  */ public int appendAndCommit(ByteBuffer source) {     int writtenBytes = append(source).     commit().     return writtenBytes. }
true;public;1;11;/**  * Append as many data as possible from {@code source}. Not everything might be copied if there is not enough  * space in the underlying {@link MemorySegment}  *  * @return number of copied bytes  */ ;/**  * Append as many data as possible from {@code source}. Not everything might be copied if there is not enough  * space in the underlying {@link MemorySegment}  *  * @return number of copied bytes  */ public int append(ByteBuffer source) {     checkState(!isFinished()).     int needed = source.remaining().     int available = getMaxCapacity() - positionMarker.getCached().     int toCopy = Math.min(needed, available).     memorySegment.put(positionMarker.getCached(), source, toCopy).     positionMarker.move(toCopy).     return toCopy. }
true;public;0;3;/**  * Make the change visible to the readers. This is costly operation (volatile access) thus in case of bulk writes  * it's better to commit them all together instead one by one.  */ ;/**  * Make the change visible to the readers. This is costly operation (volatile access) thus in case of bulk writes  * it's better to commit them all together instead one by one.  */ public void commit() {     positionMarker.commit(). }
true;public;0;5;/**  * Mark this {@link BufferBuilder} and associated {@link BufferConsumer} as finished - no new data writes will be  * allowed.  *  * <p>This method should be idempotent to handle failures and task interruptions. Check FLINK-8948 for more details.  *  * @return number of written bytes.  */ ;/**  * Mark this {@link BufferBuilder} and associated {@link BufferConsumer} as finished - no new data writes will be  * allowed.  *  * <p>This method should be idempotent to handle failures and task interruptions. Check FLINK-8948 for more details.  *  * @return number of written bytes.  */ public int finish() {     int writtenBytes = positionMarker.markFinished().     commit().     return writtenBytes. }
false;public;0;3;;public boolean isFinished() {     return positionMarker.isFinished(). }
false;public;0;4;;public boolean isFull() {     checkState(positionMarker.getCached() <= getMaxCapacity()).     return positionMarker.getCached() == getMaxCapacity(). }
false;public;0;3;;public int getMaxCapacity() {     return memorySegment.size(). }
false;;0;1;;int get().
false;static;1;3;;static boolean isFinished(int position) {     return position < 0. }
false;static;1;6;;static int getAbsolute(int position) {     if (position == FINISHED_EMPTY) {         return 0.     }     return Math.abs(position). }
false;public;0;4;;@Override public int get() {     return position. }
false;public;0;3;;public boolean isFinished() {     return PositionMarker.isFinished(cachedPosition). }
false;public;0;3;;public int getCached() {     return PositionMarker.getAbsolute(cachedPosition). }
true;public;0;9;/**  * Marks this position as finished and returns the current position.  *  * @return current position as of {@link #getCached()}  */ ;/**  * Marks this position as finished and returns the current position.  *  * @return current position as of {@link #getCached()}  */ public int markFinished() {     int currentPosition = getCached().     int newValue = -currentPosition.     if (newValue == 0) {         newValue = FINISHED_EMPTY.     }     set(newValue).     return currentPosition. }
false;public;1;3;;public void move(int offset) {     set(cachedPosition + offset). }
false;public;1;3;;public void set(int value) {     cachedPosition = value. }
false;public;0;3;;public void commit() {     position = cachedPosition. }
