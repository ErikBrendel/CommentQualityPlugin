commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Returns an immutable list with all alternative snapshots to restore the managed operator state, in the order in  * which we should attempt to restore.  */ ;// ----------------------------------------------------------------------------------------------------------------- /**  * Returns an immutable list with all alternative snapshots to restore the managed operator state, in the order in  * which we should attempt to restore.  */ @Nonnull public List<StateObjectCollection<OperatorStateHandle>> getPrioritizedManagedOperatorState() {     return prioritizedManagedOperatorState. }
true;public;0;4;/**  * Returns an immutable list with all alternative snapshots to restore the raw operator state, in the order in  * which we should attempt to restore.  */ ;/**  * Returns an immutable list with all alternative snapshots to restore the raw operator state, in the order in  * which we should attempt to restore.  */ @Nonnull public List<StateObjectCollection<OperatorStateHandle>> getPrioritizedRawOperatorState() {     return prioritizedRawOperatorState. }
true;public;0;4;/**  * Returns an immutable list with all alternative snapshots to restore the managed keyed state, in the order in  * which we should attempt to restore.  */ ;/**  * Returns an immutable list with all alternative snapshots to restore the managed keyed state, in the order in  * which we should attempt to restore.  */ @Nonnull public List<StateObjectCollection<KeyedStateHandle>> getPrioritizedManagedKeyedState() {     return prioritizedManagedKeyedState. }
true;public;0;4;/**  * Returns an immutable list with all alternative snapshots to restore the raw keyed state, in the order in which we  * should attempt to restore.  */ ;/**  * Returns an immutable list with all alternative snapshots to restore the raw keyed state, in the order in which we  * should attempt to restore.  */ @Nonnull public List<StateObjectCollection<KeyedStateHandle>> getPrioritizedRawKeyedState() {     return prioritizedRawKeyedState. }
true;public;0;4;/**  * Returns the managed operator state from the job manager, which represents the ground truth about what this state  * should represent. This is the alternative with lowest priority.  */ ;// ----------------------------------------------------------------------------------------------------------------- /**  * Returns the managed operator state from the job manager, which represents the ground truth about what this state  * should represent. This is the alternative with lowest priority.  */ @Nonnull public StateObjectCollection<OperatorStateHandle> getJobManagerManagedOperatorState() {     return lastElement(prioritizedManagedOperatorState). }
true;public;0;4;/**  * Returns the raw operator state from the job manager, which represents the ground truth about what this state  * should represent. This is the alternative with lowest priority.  */ ;/**  * Returns the raw operator state from the job manager, which represents the ground truth about what this state  * should represent. This is the alternative with lowest priority.  */ @Nonnull public StateObjectCollection<OperatorStateHandle> getJobManagerRawOperatorState() {     return lastElement(prioritizedRawOperatorState). }
true;public;0;4;/**  * Returns the managed keyed state from the job manager, which represents the ground truth about what this state  * should represent. This is the alternative with lowest priority.  */ ;/**  * Returns the managed keyed state from the job manager, which represents the ground truth about what this state  * should represent. This is the alternative with lowest priority.  */ @Nonnull public StateObjectCollection<KeyedStateHandle> getJobManagerManagedKeyedState() {     return lastElement(prioritizedManagedKeyedState). }
true;public;0;4;/**  * Returns the raw keyed state from the job manager, which represents the ground truth about what this state  * should represent. This is the alternative with lowest priority.  */ ;/**  * Returns the raw keyed state from the job manager, which represents the ground truth about what this state  * should represent. This is the alternative with lowest priority.  */ @Nonnull public StateObjectCollection<KeyedStateHandle> getJobManagerRawKeyedState() {     return lastElement(prioritizedRawKeyedState). }
true;public;0;3;/**  * Returns true if this was created for a restored operator, false otherwise. Restored operators are operators that  * participated in a previous checkpoint, even if they did not emit any state snapshots.  */ ;// ----------------------------------------------------------------------------------------------------------------- /**  * Returns true if this was created for a restored operator, false otherwise. Restored operators are operators that  * participated in a previous checkpoint, even if they did not emit any state snapshots.  */ public boolean isRestored() {     return restored. }
false;private,static;1;3;;private static <T extends StateObject> StateObjectCollection<T> lastElement(List<StateObjectCollection<T>> list) {     return list.get(list.size() - 1). }
true;public,static;0;3;/**  * Returns an empty {@link PrioritizedOperatorSubtaskState} singleton for an empty, not-restored operator state.  */ ;/**  * Returns an empty {@link PrioritizedOperatorSubtaskState} singleton for an empty, not-restored operator state.  */ public static PrioritizedOperatorSubtaskState emptyNotRestored() {     return EMPTY_NON_RESTORED_INSTANCE. }
false;public;0;44;;public PrioritizedOperatorSubtaskState build() {     int size = alternativesByPriority.size().     List<StateObjectCollection<OperatorStateHandle>> managedOperatorAlternatives = new ArrayList<>(size).     List<StateObjectCollection<KeyedStateHandle>> managedKeyedAlternatives = new ArrayList<>(size).     List<StateObjectCollection<OperatorStateHandle>> rawOperatorAlternatives = new ArrayList<>(size).     List<StateObjectCollection<KeyedStateHandle>> rawKeyedAlternatives = new ArrayList<>(size).     for (OperatorSubtaskState subtaskState : alternativesByPriority) {         if (subtaskState != null) {             managedKeyedAlternatives.add(subtaskState.getManagedKeyedState()).             rawKeyedAlternatives.add(subtaskState.getRawKeyedState()).             managedOperatorAlternatives.add(subtaskState.getManagedOperatorState()).             rawOperatorAlternatives.add(subtaskState.getRawOperatorState()).         }     }     // Key-groups should match.     BiFunction<KeyedStateHandle, KeyedStateHandle, Boolean> keyedStateApprover = (ref, alt) -> ref.getKeyGroupRange().equals(alt.getKeyGroupRange()).     // State meta data should match.     BiFunction<OperatorStateHandle, OperatorStateHandle, Boolean> operatorStateApprover = (ref, alt) -> ref.getStateNameToPartitionOffsets().equals(alt.getStateNameToPartitionOffsets()).     return new PrioritizedOperatorSubtaskState(resolvePrioritizedAlternatives(jobManagerState.getManagedKeyedState(), managedKeyedAlternatives, keyedStateApprover), resolvePrioritizedAlternatives(jobManagerState.getRawKeyedState(), rawKeyedAlternatives, keyedStateApprover), resolvePrioritizedAlternatives(jobManagerState.getManagedOperatorState(), managedOperatorAlternatives, operatorStateApprover), resolvePrioritizedAlternatives(jobManagerState.getRawOperatorState(), rawOperatorAlternatives, operatorStateApprover), restored). }
true;protected;3;40;/**  * This helper method resolves the dependencies between the ground truth of the operator state obtained from the  * job manager and potential alternatives for recovery, e.g. from a task-local source.  */ ;/**  * This helper method resolves the dependencies between the ground truth of the operator state obtained from the  * job manager and potential alternatives for recovery, e.g. from a task-local source.  */ protected <T extends StateObject> List<StateObjectCollection<T>> resolvePrioritizedAlternatives(StateObjectCollection<T> jobManagerState, List<StateObjectCollection<T>> alternativesByPriority, BiFunction<T, T, Boolean> approveFun) {     // check).     if (alternativesByPriority == null || alternativesByPriority.isEmpty() || !jobManagerState.hasState() || jobManagerState.size() != 1) {         return Collections.singletonList(jobManagerState).     }     // As we know size is == 1     T reference = jobManagerState.iterator().next().     // This will contain the end result, we initialize it with the potential max. size.     List<StateObjectCollection<T>> approved = new ArrayList<>(1 + alternativesByPriority.size()).     for (StateObjectCollection<T> alternative : alternativesByPriority) {         // approve-function signaled true.         if (alternative != null && alternative.hasState() && alternative.size() == 1 && BooleanUtils.isTrue(approveFun.apply(reference, alternative.iterator().next()))) {             approved.add(alternative).         }     }     // Of course we include the ground truth as last alternative.     approved.add(jobManagerState).     return Collections.unmodifiableList(approved). }
