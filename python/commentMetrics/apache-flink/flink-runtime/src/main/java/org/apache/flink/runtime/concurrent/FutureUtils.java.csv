commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;11;/**  * Retry the given operation the given number of times in case of a failure.  *  * @param operation to executed  * @param retries if the operation failed  * @param executor to use to run the futures  * @param <T> type of the result  * @return Future containing either the result of the operation or a {@link RetryException}  */ ;// ------------------------------------------------------------------------ // retrying operations // ------------------------------------------------------------------------ /**  * Retry the given operation the given number of times in case of a failure.  *  * @param operation to executed  * @param retries if the operation failed  * @param executor to use to run the futures  * @param <T> type of the result  * @return Future containing either the result of the operation or a {@link RetryException}  */ public static <T> CompletableFuture<T> retry(final Supplier<CompletableFuture<T>> operation, final int retries, final Executor executor) {     final CompletableFuture<T> resultFuture = new CompletableFuture<>().     retryOperation(resultFuture, operation, retries, executor).     return resultFuture. }
true;private,static;4;36;/**  * Helper method which retries the provided operation in case of a failure.  *  * @param resultFuture to complete  * @param operation to retry  * @param retries until giving up  * @param executor to run the futures  * @param <T> type of the future's result  */ ;/**  * Helper method which retries the provided operation in case of a failure.  *  * @param resultFuture to complete  * @param operation to retry  * @param retries until giving up  * @param executor to run the futures  * @param <T> type of the future's result  */ private static <T> void retryOperation(final CompletableFuture<T> resultFuture, final Supplier<CompletableFuture<T>> operation, final int retries, final Executor executor) {     if (!resultFuture.isDone()) {         final CompletableFuture<T> operationFuture = operation.get().         operationFuture.whenCompleteAsync((t, throwable) -> {             if (throwable != null) {                 if (throwable instanceof CancellationException) {                     resultFuture.completeExceptionally(new RetryException("Operation future was cancelled.", throwable)).                 } else {                     if (retries > 0) {                         retryOperation(resultFuture, operation, retries - 1, executor).                     } else {                         resultFuture.completeExceptionally(new RetryException("Could not complete the operation. Number of retries " + "has been exhausted.", throwable)).                     }                 }             } else {                 resultFuture.complete(t).             }         }, executor).         resultFuture.whenComplete((t, throwable) -> operationFuture.cancel(false)).     } }
true;public,static;5;19;/**  * Retry the given operation with the given delay in between failures.  *  * @param operation to retry  * @param retries number of retries  * @param retryDelay delay between retries  * @param retryPredicate Predicate to test whether an exception is retryable  * @param scheduledExecutor executor to be used for the retry operation  * @param <T> type of the result  * @return Future which retries the given operation a given amount of times and delays the retry in case of failures  */ ;/**  * Retry the given operation with the given delay in between failures.  *  * @param operation to retry  * @param retries number of retries  * @param retryDelay delay between retries  * @param retryPredicate Predicate to test whether an exception is retryable  * @param scheduledExecutor executor to be used for the retry operation  * @param <T> type of the result  * @return Future which retries the given operation a given amount of times and delays the retry in case of failures  */ public static <T> CompletableFuture<T> retryWithDelay(final Supplier<CompletableFuture<T>> operation, final int retries, final Time retryDelay, final Predicate<Throwable> retryPredicate, final ScheduledExecutor scheduledExecutor) {     final CompletableFuture<T> resultFuture = new CompletableFuture<>().     retryOperationWithDelay(resultFuture, operation, retries, retryDelay, retryPredicate, scheduledExecutor).     return resultFuture. }
true;public,static;4;12;/**  * Retry the given operation with the given delay in between failures.  *  * @param operation to retry  * @param retries number of retries  * @param retryDelay delay between retries  * @param scheduledExecutor executor to be used for the retry operation  * @param <T> type of the result  * @return Future which retries the given operation a given amount of times and delays the retry in case of failures  */ ;/**  * Retry the given operation with the given delay in between failures.  *  * @param operation to retry  * @param retries number of retries  * @param retryDelay delay between retries  * @param scheduledExecutor executor to be used for the retry operation  * @param <T> type of the result  * @return Future which retries the given operation a given amount of times and delays the retry in case of failures  */ public static <T> CompletableFuture<T> retryWithDelay(final Supplier<CompletableFuture<T>> operation, final int retries, final Time retryDelay, final ScheduledExecutor scheduledExecutor) {     return retryWithDelay(operation, retries, retryDelay, (throwable) -> true, scheduledExecutor). }
false;private,static;6;44;;private static <T> void retryOperationWithDelay(final CompletableFuture<T> resultFuture, final Supplier<CompletableFuture<T>> operation, final int retries, final Time retryDelay, final Predicate<Throwable> retryPredicate, final ScheduledExecutor scheduledExecutor) {     if (!resultFuture.isDone()) {         final CompletableFuture<T> operationResultFuture = operation.get().         operationResultFuture.whenComplete((t, throwable) -> {             if (throwable != null) {                 if (throwable instanceof CancellationException) {                     resultFuture.completeExceptionally(new RetryException("Operation future was cancelled.", throwable)).                 } else {                     throwable = ExceptionUtils.stripExecutionException(throwable).                     if (!retryPredicate.test(throwable)) {                         resultFuture.completeExceptionally(throwable).                     } else if (retries > 0) {                         final ScheduledFuture<?> scheduledFuture = scheduledExecutor.schedule((Runnable) () -> retryOperationWithDelay(resultFuture, operation, retries - 1, retryDelay, retryPredicate, scheduledExecutor), retryDelay.toMilliseconds(), TimeUnit.MILLISECONDS).                         resultFuture.whenComplete((innerT, innerThrowable) -> scheduledFuture.cancel(false)).                     } else {                         RetryException retryException = new RetryException("Could not complete the operation. Number of retries has been exhausted.", throwable).                         resultFuture.completeExceptionally(retryException).                     }                 }             } else {                 resultFuture.complete(t).             }         }).         resultFuture.whenComplete((t, throwable) -> operationResultFuture.cancel(false)).     } }
true;public,static;5;19;/**  * Retry the given operation with the given delay in between successful completions where the  * result does not match a given predicate.  *  * @param operation to retry  * @param retryDelay delay between retries  * @param deadline A deadline that specifies at what point we should stop retrying  * @param acceptancePredicate Predicate to test whether the result is acceptable  * @param scheduledExecutor executor to be used for the retry operation  * @param <T> type of the result  * @return Future which retries the given operation a given amount of times and delays the retry  *   in case the predicate isn't matched  */ ;/**  * Retry the given operation with the given delay in between successful completions where the  * result does not match a given predicate.  *  * @param operation to retry  * @param retryDelay delay between retries  * @param deadline A deadline that specifies at what point we should stop retrying  * @param acceptancePredicate Predicate to test whether the result is acceptable  * @param scheduledExecutor executor to be used for the retry operation  * @param <T> type of the result  * @return Future which retries the given operation a given amount of times and delays the retry  *   in case the predicate isn't matched  */ public static <T> CompletableFuture<T> retrySuccessfulWithDelay(final Supplier<CompletableFuture<T>> operation, final Time retryDelay, final Deadline deadline, final Predicate<T> acceptancePredicate, final ScheduledExecutor scheduledExecutor) {     final CompletableFuture<T> resultFuture = new CompletableFuture<>().     retrySuccessfulOperationWithDelay(resultFuture, operation, retryDelay, deadline, acceptancePredicate, scheduledExecutor).     return resultFuture. }
false;private,static;6;41;;private static <T> void retrySuccessfulOperationWithDelay(final CompletableFuture<T> resultFuture, final Supplier<CompletableFuture<T>> operation, final Time retryDelay, final Deadline deadline, final Predicate<T> acceptancePredicate, final ScheduledExecutor scheduledExecutor) {     if (!resultFuture.isDone()) {         final CompletableFuture<T> operationResultFuture = operation.get().         operationResultFuture.whenComplete((t, throwable) -> {             if (throwable != null) {                 if (throwable instanceof CancellationException) {                     resultFuture.completeExceptionally(new RetryException("Operation future was cancelled.", throwable)).                 } else {                     resultFuture.completeExceptionally(throwable).                 }             } else {                 if (acceptancePredicate.test(t)) {                     resultFuture.complete(t).                 } else if (deadline.hasTimeLeft()) {                     final ScheduledFuture<?> scheduledFuture = scheduledExecutor.schedule((Runnable) () -> retrySuccessfulOperationWithDelay(resultFuture, operation, retryDelay, deadline, acceptancePredicate, scheduledExecutor), retryDelay.toMilliseconds(), TimeUnit.MILLISECONDS).                     resultFuture.whenComplete((innerT, innerThrowable) -> scheduledFuture.cancel(false)).                 } else {                     resultFuture.completeExceptionally(new RetryException("Could not satisfy the predicate within the allowed time.")).                 }             }         }).         resultFuture.whenComplete((t, throwable) -> operationResultFuture.cancel(false)).     } }
true;public,static;3;3;/**  * Times the given future out after the timeout.  *  * @param future to time out  * @param timeout after which the given future is timed out  * @param timeUnit time unit of the timeout  * @param <T> type of the given future  * @return The timeout enriched future  */ ;/**  * Times the given future out after the timeout.  *  * @param future to time out  * @param timeout after which the given future is timed out  * @param timeUnit time unit of the timeout  * @param <T> type of the given future  * @return The timeout enriched future  */ public static <T> CompletableFuture<T> orTimeout(CompletableFuture<T> future, long timeout, TimeUnit timeUnit) {     return orTimeout(future, timeout, timeUnit, Executors.directExecutor()). }
true;public,static;4;19;/**  * Times the given future out after the timeout.  *  * @param future to time out  * @param timeout after which the given future is timed out  * @param timeUnit time unit of the timeout  * @param timeoutFailExecutor executor that will complete the future exceptionally after the timeout is reached  * @param <T> type of the given future  * @return The timeout enriched future  */ ;/**  * Times the given future out after the timeout.  *  * @param future to time out  * @param timeout after which the given future is timed out  * @param timeUnit time unit of the timeout  * @param timeoutFailExecutor executor that will complete the future exceptionally after the timeout is reached  * @param <T> type of the given future  * @return The timeout enriched future  */ public static <T> CompletableFuture<T> orTimeout(CompletableFuture<T> future, long timeout, TimeUnit timeUnit, Executor timeoutFailExecutor) {     if (!future.isDone()) {         final ScheduledFuture<?> timeoutFuture = Delayer.delay(() -> timeoutFailExecutor.execute(new Timeout(future)), timeout, timeUnit).         future.whenComplete((T value, Throwable throwable) -> {             if (!timeoutFuture.isDone()) {                 timeoutFuture.cancel(false).             }         }).     }     return future. }
true;public,static;1;12;/**  * Run the given {@code RunnableFuture} if it is not done, and then retrieves its result.  * @param future to run if not done and get  * @param <T> type of the result  * @return the result after running the future  * @throws ExecutionException if a problem occurred  * @throws InterruptedException if the current thread has been interrupted  */ ;// ------------------------------------------------------------------------ // Future actions // ------------------------------------------------------------------------ /**  * Run the given {@code RunnableFuture} if it is not done, and then retrieves its result.  * @param future to run if not done and get  * @param <T> type of the result  * @return the result after running the future  * @throws ExecutionException if a problem occurred  * @throws InterruptedException if the current thread has been interrupted  */ public static <T> T runIfNotDoneAndGet(RunnableFuture<T> future) throws ExecutionException, InterruptedException {     if (null == future) {         return null.     }     if (!future.isDone()) {         future.run().     }     return future.get(). }
true;public,static;2;3;/**  * Run the given action after the completion of the given future. The given future can be  * completed normally or exceptionally. In case of an exceptional completion the, the  * action's exception will be added to the initial exception.  *  * @param future to wait for its completion  * @param runnable action which is triggered after the future's completion  * @return Future which is completed after the action has completed. This future can contain an exception,  * if an error occurred in the given future or action.  */ ;/**  * Run the given action after the completion of the given future. The given future can be  * completed normally or exceptionally. In case of an exceptional completion the, the  * action's exception will be added to the initial exception.  *  * @param future to wait for its completion  * @param runnable action which is triggered after the future's completion  * @return Future which is completed after the action has completed. This future can contain an exception,  * if an error occurred in the given future or action.  */ public static CompletableFuture<Void> runAfterwards(CompletableFuture<?> future, RunnableWithException runnable) {     return runAfterwardsAsync(future, runnable, Executors.directExecutor()). }
true;public,static;2;3;/**  * Run the given action after the completion of the given future. The given future can be  * completed normally or exceptionally. In case of an exceptional completion the, the  * action's exception will be added to the initial exception.  *  * @param future to wait for its completion  * @param runnable action which is triggered after the future's completion  * @return Future which is completed after the action has completed. This future can contain an exception,  * if an error occurred in the given future or action.  */ ;/**  * Run the given action after the completion of the given future. The given future can be  * completed normally or exceptionally. In case of an exceptional completion the, the  * action's exception will be added to the initial exception.  *  * @param future to wait for its completion  * @param runnable action which is triggered after the future's completion  * @return Future which is completed after the action has completed. This future can contain an exception,  * if an error occurred in the given future or action.  */ public static CompletableFuture<Void> runAfterwardsAsync(CompletableFuture<?> future, RunnableWithException runnable) {     return runAfterwardsAsync(future, runnable, ForkJoinPool.commonPool()). }
true;public,static;3;24;/**  * Run the given action after the completion of the given future. The given future can be  * completed normally or exceptionally. In case of an exceptional completion the, the  * action's exception will be added to the initial exception.  *  * @param future to wait for its completion  * @param runnable action which is triggered after the future's completion  * @param executor to run the given action  * @return Future which is completed after the action has completed. This future can contain an exception,  * if an error occurred in the given future or action.  */ ;/**  * Run the given action after the completion of the given future. The given future can be  * completed normally or exceptionally. In case of an exceptional completion the, the  * action's exception will be added to the initial exception.  *  * @param future to wait for its completion  * @param runnable action which is triggered after the future's completion  * @param executor to run the given action  * @return Future which is completed after the action has completed. This future can contain an exception,  * if an error occurred in the given future or action.  */ public static CompletableFuture<Void> runAfterwardsAsync(CompletableFuture<?> future, RunnableWithException runnable, Executor executor) {     final CompletableFuture<Void> resultFuture = new CompletableFuture<>().     future.whenCompleteAsync((Object ignored, Throwable throwable) -> {         try {             runnable.run().         } catch (Throwable e) {             throwable = ExceptionUtils.firstOrSuppressed(e, throwable).         }         if (throwable != null) {             resultFuture.completeExceptionally(throwable).         } else {             resultFuture.complete(null).         }     }, executor).     return resultFuture. }
true;public,static;2;23;/**  * Run the given asynchronous action after the completion of the given future. The given future can be  * completed normally or exceptionally. In case of an exceptional completion, the  * asynchronous action's exception will be added to the initial exception.  *  * @param future to wait for its completion  * @param composedAction asynchronous action which is triggered after the future's completion  * @return Future which is completed after the asynchronous action has completed. This future can contain  * an exception if an error occurred in the given future or asynchronous action.  */ ;/**  * Run the given asynchronous action after the completion of the given future. The given future can be  * completed normally or exceptionally. In case of an exceptional completion, the  * asynchronous action's exception will be added to the initial exception.  *  * @param future to wait for its completion  * @param composedAction asynchronous action which is triggered after the future's completion  * @return Future which is completed after the asynchronous action has completed. This future can contain  * an exception if an error occurred in the given future or asynchronous action.  */ public static CompletableFuture<Void> composeAfterwards(CompletableFuture<?> future, Supplier<CompletableFuture<?>> composedAction) {     final CompletableFuture<Void> resultFuture = new CompletableFuture<>().     future.whenComplete((Object outerIgnored, Throwable outerThrowable) -> {         final CompletableFuture<?> composedActionFuture = composedAction.get().         composedActionFuture.whenComplete((Object innerIgnored, Throwable innerThrowable) -> {             if (innerThrowable != null) {                 resultFuture.completeExceptionally(ExceptionUtils.firstOrSuppressed(innerThrowable, outerThrowable)).             } else if (outerThrowable != null) {                 resultFuture.completeExceptionally(outerThrowable).             } else {                 resultFuture.complete(null).             }         }).     }).     return resultFuture. }
true;public,static;1;5;/**  * Creates a future that is complete once multiple other futures completed.  * The future fails (completes exceptionally) once one of the futures in the  * conjunction fails. Upon successful completion, the future returns the  * collection of the futures' results.  *  * <p>The ConjunctFuture gives access to how many Futures in the conjunction have already  * completed successfully, via {@link ConjunctFuture#getNumFuturesCompleted()}.  *  * @param futures The futures that make up the conjunction. No null entries are allowed.  * @return The ConjunctFuture that completes once all given futures are complete (or one fails).  */ ;// ------------------------------------------------------------------------ // composing futures // ------------------------------------------------------------------------ /**  * Creates a future that is complete once multiple other futures completed.  * The future fails (completes exceptionally) once one of the futures in the  * conjunction fails. Upon successful completion, the future returns the  * collection of the futures' results.  *  * <p>The ConjunctFuture gives access to how many Futures in the conjunction have already  * completed successfully, via {@link ConjunctFuture#getNumFuturesCompleted()}.  *  * @param futures The futures that make up the conjunction. No null entries are allowed.  * @return The ConjunctFuture that completes once all given futures are complete (or one fails).  */ public static <T> ConjunctFuture<Collection<T>> combineAll(Collection<? extends CompletableFuture<? extends T>> futures) {     checkNotNull(futures, "futures").     return new ResultConjunctFuture<>(futures). }
true;public,static;1;5;/**  * Creates a future that is complete once all of the given futures have completed.  * The future fails (completes exceptionally) once one of the given futures  * fails.  *  * <p>The ConjunctFuture gives access to how many Futures have already  * completed successfully, via {@link ConjunctFuture#getNumFuturesCompleted()}.  *  * @param futures The futures to wait on. No null entries are allowed.  * @return The WaitingFuture that completes once all given futures are complete (or one fails).  */ ;/**  * Creates a future that is complete once all of the given futures have completed.  * The future fails (completes exceptionally) once one of the given futures  * fails.  *  * <p>The ConjunctFuture gives access to how many Futures have already  * completed successfully, via {@link ConjunctFuture#getNumFuturesCompleted()}.  *  * @param futures The futures to wait on. No null entries are allowed.  * @return The WaitingFuture that completes once all given futures are complete (or one fails).  */ public static ConjunctFuture<Void> waitForAll(Collection<? extends CompletableFuture<?>> futures) {     checkNotNull(futures, "futures").     return new WaitingConjunctFuture(futures). }
true;public,abstract;0;1;/**  * Gets the total number of Futures in the conjunction.  * @return The total number of Futures in the conjunction.  */ ;/**  * Gets the total number of Futures in the conjunction.  * @return The total number of Futures in the conjunction.  */ public abstract int getNumFuturesTotal().
true;public,abstract;0;1;/**  * Gets the number of Futures in the conjunction that are already complete.  * @return The number of Futures in the conjunction that are already complete  */ ;/**  * Gets the number of Futures in the conjunction that are already complete.  * @return The number of Futures in the conjunction that are already complete  */ public abstract int getNumFuturesCompleted().
true;private;2;13;/**  * The function that is attached to all futures in the conjunction. Once a future  * is complete, this function tracks the completion or fails the conjunct.  */ ;/**  * The function that is attached to all futures in the conjunction. Once a future  * is complete, this function tracks the completion or fails the conjunct.  */ private void handleCompletedFuture(T value, Throwable throwable) {     if (throwable != null) {         completeExceptionally(throwable).     } else {         int index = nextIndex.getAndIncrement().         results[index] = value.         if (numCompleted.incrementAndGet() == numTotal) {             complete(Arrays.asList(results)).         }     } }
false;public;0;4;;@Override public int getNumFuturesTotal() {     return numTotal. }
false;public;0;4;;@Override public int getNumFuturesCompleted() {     return numCompleted.get(). }
true;private;2;9;/**  * Method which increments the atomic completion counter and completes or fails the WaitingFutureImpl.  */ ;/**  * Method which increments the atomic completion counter and completes or fails the WaitingFutureImpl.  */ private void handleCompletedFuture(Object ignored, Throwable throwable) {     if (throwable == null) {         if (numTotal == numCompleted.incrementAndGet()) {             complete(null).         }     } else {         completeExceptionally(throwable).     } }
false;public;0;4;;@Override public int getNumFuturesTotal() {     return numTotal. }
false;public;0;4;;@Override public int getNumFuturesCompleted() {     return numCompleted.get(). }
true;public,static;1;3;/**  * Creates a {@link ConjunctFuture} which is only completed after all given futures have completed.  * Unlike {@link FutureUtils#waitForAll(Collection)}, the resulting future won't be completed directly  * if one of the given futures is completed exceptionally. Instead, all occurring exception will be  * collected and combined to a single exception. If at least on exception occurs, then the resulting  * future will be completed exceptionally.  *  * @param futuresToComplete futures to complete  * @return Future which is completed after all given futures have been completed.  */ ;/**  * Creates a {@link ConjunctFuture} which is only completed after all given futures have completed.  * Unlike {@link FutureUtils#waitForAll(Collection)}, the resulting future won't be completed directly  * if one of the given futures is completed exceptionally. Instead, all occurring exception will be  * collected and combined to a single exception. If at least on exception occurs, then the resulting  * future will be completed exceptionally.  *  * @param futuresToComplete futures to complete  * @return Future which is completed after all given futures have been completed.  */ public static ConjunctFuture<Void> completeAll(Collection<? extends CompletableFuture<?>> futuresToComplete) {     return new CompletionConjunctFuture(futuresToComplete). }
false;private;2;17;;private void completeFuture(Object ignored, Throwable throwable) {     synchronized (lock) {         futuresCompleted++.         if (throwable != null) {             globalThrowable = ExceptionUtils.firstOrSuppressed(throwable, globalThrowable).         }         if (futuresCompleted == numFuturesTotal) {             if (globalThrowable != null) {                 completeExceptionally(globalThrowable).             } else {                 complete(null).             }         }     } }
false;public;0;4;;@Override public int getNumFuturesTotal() {     return numFuturesTotal. }
false;public;0;6;;@Override public int getNumFuturesCompleted() {     synchronized (lock) {         return futuresCompleted.     } }
true;public,static;1;6;/**  * Returns an exceptionally completed {@link CompletableFuture}.  *  * @param cause to complete the future with  * @param <T> type of the future  * @return An exceptionally completed CompletableFuture  */ ;// ------------------------------------------------------------------------ // Helper methods // ------------------------------------------------------------------------ /**  * Returns an exceptionally completed {@link CompletableFuture}.  *  * @param cause to complete the future with  * @param <T> type of the future  * @return An exceptionally completed CompletableFuture  */ public static <T> CompletableFuture<T> completedExceptionally(Throwable cause) {     CompletableFuture<T> result = new CompletableFuture<>().     result.completeExceptionally(cause).     return result. }
true;public,static;2;11;/**  * Returns a future which is completed with the result of the {@link SupplierWithException}.  *  * @param supplier to provide the future's value  * @param executor to execute the supplier  * @param <T> type of the result  * @return Future which is completed with the value of the supplier  */ ;/**  * Returns a future which is completed with the result of the {@link SupplierWithException}.  *  * @param supplier to provide the future's value  * @param executor to execute the supplier  * @param <T> type of the result  * @return Future which is completed with the value of the supplier  */ public static <T> CompletableFuture<T> supplyAsync(SupplierWithException<T, ?> supplier, Executor executor) {     return CompletableFuture.supplyAsync(() -> {         try {             return supplier.get().         } catch (Throwable e) {             throw new CompletionException(e).         }     }, executor). }
true;public,static;1;3;/**  * Converts Flink time into a {@link FiniteDuration}.  *  * @param time to convert into a FiniteDuration  * @return FiniteDuration with the length of the given time  */ ;/**  * Converts Flink time into a {@link FiniteDuration}.  *  * @param time to convert into a FiniteDuration  * @return FiniteDuration with the length of the given time  */ public static FiniteDuration toFiniteDuration(Time time) {     return new FiniteDuration(time.toMilliseconds(), TimeUnit.MILLISECONDS). }
true;public,static;1;3;/**  * Converts {@link FiniteDuration} into Flink time.  *  * @param finiteDuration to convert into Flink time  * @return Flink time with the length of the given finite duration  */ ;/**  * Converts {@link FiniteDuration} into Flink time.  *  * @param finiteDuration to convert into Flink time  * @return Flink time with the length of the given finite duration  */ public static Time toTime(FiniteDuration finiteDuration) {     return Time.milliseconds(finiteDuration.toMillis()). }
false;public;2;8;;@Override public void onComplete(Throwable failure, U success) {     if (failure != null) {         result.completeExceptionally(failure).     } else {         result.complete(success).     } }
true;public,static;1;16;/**  * Converts a Scala {@link Future} to a {@link CompletableFuture}.  *  * @param scalaFuture to convert to a Java 8 CompletableFuture  * @param <T> type of the future value  * @param <U> type of the original future  * @return Java 8 CompletableFuture  */ ;// ------------------------------------------------------------------------ // Converting futures // ------------------------------------------------------------------------ /**  * Converts a Scala {@link Future} to a {@link CompletableFuture}.  *  * @param scalaFuture to convert to a Java 8 CompletableFuture  * @param <T> type of the future value  * @param <U> type of the original future  * @return Java 8 CompletableFuture  */ public static <T, U extends T> CompletableFuture<T> toJava(Future<U> scalaFuture) {     final CompletableFuture<T> result = new CompletableFuture<>().     scalaFuture.onComplete(new OnComplete<U>() {          @Override         public void onComplete(Throwable failure, U success) {             if (failure != null) {                 result.completeExceptionally(failure).             } else {                 result.complete(success).             }         }     }, Executors.directExecutionContext()).     return result. }
true;public,static;3;8;/**  * This function takes a {@link CompletableFuture} and a function to apply to this future. If the input future  * is already done, this function returns {@link CompletableFuture#thenApply(Function)}. Otherwise, the return  * value is {@link CompletableFuture#thenApplyAsync(Function, Executor)} with the given executor.  *  * @param completableFuture the completable future for which we want to apply.  * @param executor the executor to run the apply function if the future is not yet done.  * @param applyFun the function to apply.  * @param <IN> type of the input future.  * @param <OUT> type of the output future.  * @return a completable future that is applying the given function to the input future.  */ ;/**  * This function takes a {@link CompletableFuture} and a function to apply to this future. If the input future  * is already done, this function returns {@link CompletableFuture#thenApply(Function)}. Otherwise, the return  * value is {@link CompletableFuture#thenApplyAsync(Function, Executor)} with the given executor.  *  * @param completableFuture the completable future for which we want to apply.  * @param executor the executor to run the apply function if the future is not yet done.  * @param applyFun the function to apply.  * @param <IN> type of the input future.  * @param <OUT> type of the output future.  * @return a completable future that is applying the given function to the input future.  */ public static <IN, OUT> CompletableFuture<OUT> thenApplyAsyncIfNotDone(CompletableFuture<IN> completableFuture, Executor executor, Function<? super IN, ? extends OUT> applyFun) {     return completableFuture.isDone() ? completableFuture.thenApply(applyFun) : completableFuture.thenApplyAsync(applyFun, executor). }
true;public,static;3;8;/**  * This function takes a {@link CompletableFuture} and a function to compose with this future. If the input future  * is already done, this function returns {@link CompletableFuture#thenCompose(Function)}. Otherwise, the return  * value is {@link CompletableFuture#thenComposeAsync(Function, Executor)} with the given executor.  *  * @param completableFuture the completable future for which we want to compose.  * @param executor the executor to run the compose function if the future is not yet done.  * @param composeFun the function to compose.  * @param <IN> type of the input future.  * @param <OUT> type of the output future.  * @return a completable future that is a composition of the input future and the function.  */ ;/**  * This function takes a {@link CompletableFuture} and a function to compose with this future. If the input future  * is already done, this function returns {@link CompletableFuture#thenCompose(Function)}. Otherwise, the return  * value is {@link CompletableFuture#thenComposeAsync(Function, Executor)} with the given executor.  *  * @param completableFuture the completable future for which we want to compose.  * @param executor the executor to run the compose function if the future is not yet done.  * @param composeFun the function to compose.  * @param <IN> type of the input future.  * @param <OUT> type of the output future.  * @return a completable future that is a composition of the input future and the function.  */ public static <IN, OUT> CompletableFuture<OUT> thenComposeAsyncIfNotDone(CompletableFuture<IN> completableFuture, Executor executor, Function<? super IN, ? extends CompletionStage<OUT>> composeFun) {     return completableFuture.isDone() ? completableFuture.thenCompose(composeFun) : completableFuture.thenComposeAsync(composeFun, executor). }
true;public,static;3;8;/**  * This function takes a {@link CompletableFuture} and a bi-consumer to call on completion of this future. If the  * input future is already done, this function returns {@link CompletableFuture#whenComplete(BiConsumer)}.  * Otherwise, the return value is {@link CompletableFuture#whenCompleteAsync(BiConsumer, Executor)} with the given  * executor.  *  * @param completableFuture the completable future for which we want to call #whenComplete.  * @param executor the executor to run the whenComplete function if the future is not yet done.  * @param whenCompleteFun the bi-consumer function to call when the future is completed.  * @param <IN> type of the input future.  * @return the new completion stage.  */ ;/**  * This function takes a {@link CompletableFuture} and a bi-consumer to call on completion of this future. If the  * input future is already done, this function returns {@link CompletableFuture#whenComplete(BiConsumer)}.  * Otherwise, the return value is {@link CompletableFuture#whenCompleteAsync(BiConsumer, Executor)} with the given  * executor.  *  * @param completableFuture the completable future for which we want to call #whenComplete.  * @param executor the executor to run the whenComplete function if the future is not yet done.  * @param whenCompleteFun the bi-consumer function to call when the future is completed.  * @param <IN> type of the input future.  * @return the new completion stage.  */ public static <IN> CompletableFuture<IN> whenCompleteAsyncIfNotDone(CompletableFuture<IN> completableFuture, Executor executor, BiConsumer<? super IN, ? super Throwable> whenCompleteFun) {     return completableFuture.isDone() ? completableFuture.whenComplete(whenCompleteFun) : completableFuture.whenCompleteAsync(whenCompleteFun, executor). }
true;public,static;3;8;/**  * This function takes a {@link CompletableFuture} and a consumer to accept the result of this future. If the input  * future is already done, this function returns {@link CompletableFuture#thenAccept(Consumer)}. Otherwise, the  * return value is {@link CompletableFuture#thenAcceptAsync(Consumer, Executor)} with the given executor.  *  * @param completableFuture the completable future for which we want to call #thenAccept.  * @param executor the executor to run the thenAccept function if the future is not yet done.  * @param consumer the consumer function to call when the future is completed.  * @param <IN> type of the input future.  * @return the new completion stage.  */ ;/**  * This function takes a {@link CompletableFuture} and a consumer to accept the result of this future. If the input  * future is already done, this function returns {@link CompletableFuture#thenAccept(Consumer)}. Otherwise, the  * return value is {@link CompletableFuture#thenAcceptAsync(Consumer, Executor)} with the given executor.  *  * @param completableFuture the completable future for which we want to call #thenAccept.  * @param executor the executor to run the thenAccept function if the future is not yet done.  * @param consumer the consumer function to call when the future is completed.  * @param <IN> type of the input future.  * @return the new completion stage.  */ public static <IN> CompletableFuture<Void> thenAcceptAsyncIfNotDone(CompletableFuture<IN> completableFuture, Executor executor, Consumer<? super IN> consumer) {     return completableFuture.isDone() ? completableFuture.thenAccept(consumer) : completableFuture.thenAcceptAsync(consumer, executor). }
true;public,static;3;8;/**  * This function takes a {@link CompletableFuture} and a handler function for the result of this future. If the  * input future is already done, this function returns {@link CompletableFuture#handle(BiFunction)}. Otherwise,  * the return value is {@link CompletableFuture#handleAsync(BiFunction, Executor)} with the given executor.  *  * @param completableFuture the completable future for which we want to call #handle.  * @param executor the executor to run the handle function if the future is not yet done.  * @param handler the handler function to call when the future is completed.  * @param <IN> type of the handler input argument.  * @param <OUT> type of the handler return value.  * @return the new completion stage.  */ ;/**  * This function takes a {@link CompletableFuture} and a handler function for the result of this future. If the  * input future is already done, this function returns {@link CompletableFuture#handle(BiFunction)}. Otherwise,  * the return value is {@link CompletableFuture#handleAsync(BiFunction, Executor)} with the given executor.  *  * @param completableFuture the completable future for which we want to call #handle.  * @param executor the executor to run the handle function if the future is not yet done.  * @param handler the handler function to call when the future is completed.  * @param <IN> type of the handler input argument.  * @param <OUT> type of the handler return value.  * @return the new completion stage.  */ public static <IN, OUT> CompletableFuture<OUT> handleAsyncIfNotDone(CompletableFuture<IN> completableFuture, Executor executor, BiFunction<? super IN, Throwable, ? extends OUT> handler) {     return completableFuture.isDone() ? completableFuture.handle(handler) : completableFuture.handleAsync(handler, executor). }
false;public;0;4;;@Override public void run() {     future.completeExceptionally(new TimeoutException()). }
true;private,static;3;6;/**  * Delay the given action by the given delay.  *  * @param runnable to execute after the given delay  * @param delay after which to execute the runnable  * @param timeUnit time unit of the delay  * @return Future of the scheduled action  */ ;/**  * Delay the given action by the given delay.  *  * @param runnable to execute after the given delay  * @param delay after which to execute the runnable  * @param timeUnit time unit of the delay  * @return Future of the scheduled action  */ private static ScheduledFuture<?> delay(Runnable runnable, long delay, TimeUnit timeUnit) {     checkNotNull(runnable).     checkNotNull(timeUnit).     return DELAYER.schedule(runnable, delay, timeUnit). }
