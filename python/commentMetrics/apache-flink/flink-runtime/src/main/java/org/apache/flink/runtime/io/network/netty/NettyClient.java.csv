commented;modifiers;parameterAmount;loc;comment;code
false;;2;62;;void init(final NettyProtocol protocol, NettyBufferPool nettyBufferPool) throws IOException {     checkState(bootstrap == null, "Netty client has already been initialized.").     this.protocol = protocol.     final long start = System.nanoTime().     bootstrap = new Bootstrap().     switch(config.getTransportType()) {         case NIO:             initNioBootstrap().             break.         case EPOLL:             initEpollBootstrap().             break.         case AUTO:             if (Epoll.isAvailable()) {                 initEpollBootstrap().                 LOG.info("Transport type 'auto': using EPOLL.").             } else {                 initNioBootstrap().                 LOG.info("Transport type 'auto': using NIO.").             }     }     // --------------------------------------------------------------------     // Configuration     // --------------------------------------------------------------------     bootstrap.option(ChannelOption.TCP_NODELAY, true).     bootstrap.option(ChannelOption.SO_KEEPALIVE, true).     // Timeout for new connections     bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getClientConnectTimeoutSeconds() * 1000).     // Pooled allocator for Netty's ByteBuf instances     bootstrap.option(ChannelOption.ALLOCATOR, nettyBufferPool).     // Receive and send buffer size     int receiveAndSendBufferSize = config.getSendAndReceiveBufferSize().     if (receiveAndSendBufferSize > 0) {         bootstrap.option(ChannelOption.SO_SNDBUF, receiveAndSendBufferSize).         bootstrap.option(ChannelOption.SO_RCVBUF, receiveAndSendBufferSize).     }     try {         clientSSLFactory = config.createClientSSLEngineFactory().     } catch (Exception e) {         throw new IOException("Failed to initialize SSL Context for the Netty client", e).     }     final long duration = (System.nanoTime() - start) / 1_000_000.     LOG.info("Successful initialization (took {} ms).", duration). }
false;;0;3;;NettyConfig getConfig() {     return config. }
false;;0;3;;Bootstrap getBootstrap() {     return bootstrap. }
false;;0;13;;void shutdown() {     final long start = System.nanoTime().     if (bootstrap != null) {         if (bootstrap.group() != null) {             bootstrap.group().shutdownGracefully().         }         bootstrap = null.     }     final long duration = (System.nanoTime() - start) / 1_000_000.     LOG.info("Successful shutdown (took {} ms).", duration). }
false;private;0;8;;private void initNioBootstrap() {     // Add the server port number to the name in order to distinguish     // multiple clients running on the same host.     String name = NettyConfig.CLIENT_THREAD_GROUP_NAME + " (" + config.getServerPort() + ")".     NioEventLoopGroup nioGroup = new NioEventLoopGroup(config.getClientNumThreads(), NettyServer.getNamedThreadFactory(name)).     bootstrap.group(nioGroup).channel(NioSocketChannel.class). }
false;private;0;8;;private void initEpollBootstrap() {     // Add the server port number to the name in order to distinguish     // multiple clients running on the same host.     String name = NettyConfig.CLIENT_THREAD_GROUP_NAME + " (" + config.getServerPort() + ")".     EpollEventLoopGroup epollGroup = new EpollEventLoopGroup(config.getClientNumThreads(), NettyServer.getNamedThreadFactory(name)).     bootstrap.group(epollGroup).channel(EpollSocketChannel.class). }
false;public;1;12;;@Override public void initChannel(SocketChannel channel) throws Exception {     // SSL handler should be added first in the pipeline     if (clientSSLFactory != null) {         SslHandler sslHandler = clientSSLFactory.createNettySSLHandler(serverSocketAddress.getAddress().getCanonicalHostName(), serverSocketAddress.getPort()).         channel.pipeline().addLast("ssl", sslHandler).     }     channel.pipeline().addLast(protocol.getClientChannelHandlers()). }
false;;1;41;;// ------------------------------------------------------------------------ // Client connections // ------------------------------------------------------------------------ ChannelFuture connect(final InetSocketAddress serverSocketAddress) {     checkState(bootstrap != null, "Client has not been initialized yet.").     // --------------------------------------------------------------------     // Child channel pipeline for accepted connections     // --------------------------------------------------------------------     bootstrap.handler(new ChannelInitializer<SocketChannel>() {          @Override         public void initChannel(SocketChannel channel) throws Exception {             // SSL handler should be added first in the pipeline             if (clientSSLFactory != null) {                 SslHandler sslHandler = clientSSLFactory.createNettySSLHandler(serverSocketAddress.getAddress().getCanonicalHostName(), serverSocketAddress.getPort()).                 channel.pipeline().addLast("ssl", sslHandler).             }             channel.pipeline().addLast(protocol.getClientChannelHandlers()).         }     }).     try {         return bootstrap.connect(serverSocketAddress).     } catch (ChannelException e) {         if ((e.getCause() instanceof java.net.SocketException && e.getCause().getMessage().equals("Too many open files")) || (e.getCause() instanceof ChannelException && e.getCause().getCause() instanceof java.net.SocketException && e.getCause().getCause().getMessage().equals("Too many open files"))) {             throw new ChannelException("The operating system does not offer enough file handles to open the network connection. " + "Please increase the number of available file handles.", e.getCause()).         } else {             throw e.         }     } }
