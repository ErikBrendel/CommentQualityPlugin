commented;modifiers;parameterAmount;loc;comment;code
true;;2;1;/**  * Cancel the given job.  *  * @param jobId identifying the job to cancel  * @param timeout of the operation  * @return A future acknowledge if the cancellation succeeded  */ ;/**  * Cancel the given job.  *  * @param jobId identifying the job to cancel  * @param timeout of the operation  * @return A future acknowledge if the cancellation succeeded  */ CompletableFuture<Acknowledge> cancelJob(JobID jobId, @RpcTimeout Time timeout).
true;;2;1;/**  * Stop the given job.  *  * @param jobId identifying the job to stop  * @param timeout of the operation  * @return A future acknowledge if the stopping succeeded  */ ;/**  * Stop the given job.  *  * @param jobId identifying the job to stop  * @param timeout of the operation  * @return A future acknowledge if the stopping succeeded  */ CompletableFuture<Acknowledge> stopJob(JobID jobId, @RpcTimeout Time timeout).
true;;2;1;/**  * Requests the {@link ArchivedExecutionGraph} for the given jobId. If there is no such graph, then  * the future is completed with a {@link FlinkJobNotFoundException}.  *  * @param jobId identifying the job whose {@link ArchivedExecutionGraph} is requested  * @param timeout for the asynchronous operation  * @return Future containing the {@link ArchivedExecutionGraph} for the given jobId, otherwise {@link FlinkJobNotFoundException}  */ ;/**  * Requests the {@link ArchivedExecutionGraph} for the given jobId. If there is no such graph, then  * the future is completed with a {@link FlinkJobNotFoundException}.  *  * @param jobId identifying the job whose {@link ArchivedExecutionGraph} is requested  * @param timeout for the asynchronous operation  * @return Future containing the {@link ArchivedExecutionGraph} for the given jobId, otherwise {@link FlinkJobNotFoundException}  */ CompletableFuture<ArchivedExecutionGraph> requestJob(JobID jobId, @RpcTimeout Time timeout).
true;;2;1;/**  * Requests the {@link JobResult} of a job specified by the given jobId.  *  * @param jobId identifying the job for which to retrieve the {@link JobResult}.  * @param timeout for the asynchronous operation  * @return Future which is completed with the job's {@link JobResult} once the job has finished  */ ;/**  * Requests the {@link JobResult} of a job specified by the given jobId.  *  * @param jobId identifying the job for which to retrieve the {@link JobResult}.  * @param timeout for the asynchronous operation  * @return Future which is completed with the job's {@link JobResult} once the job has finished  */ CompletableFuture<JobResult> requestJobResult(JobID jobId, @RpcTimeout Time timeout).
true;;1;2;/**  * Requests job details currently being executed on the Flink cluster.  *  * @param timeout for the asynchronous operation  * @return Future containing the job details  */ ;/**  * Requests job details currently being executed on the Flink cluster.  *  * @param timeout for the asynchronous operation  * @return Future containing the job details  */ CompletableFuture<MultipleJobsDetails> requestMultipleJobDetails(@RpcTimeout Time timeout).
true;;1;1;/**  * Requests the cluster status overview.  *  * @param timeout for the asynchronous operation  * @return Future containing the status overview  */ ;/**  * Requests the cluster status overview.  *  * @param timeout for the asynchronous operation  * @return Future containing the status overview  */ CompletableFuture<ClusterOverview> requestClusterOverview(@RpcTimeout Time timeout).
true;;1;1;/**  * Requests the paths for the {@link MetricQueryService} to query.  *  * @param timeout for the asynchronous operation  * @return Future containing the collection of metric query service paths to query  */ ;/**  * Requests the paths for the {@link MetricQueryService} to query.  *  * @param timeout for the asynchronous operation  * @return Future containing the collection of metric query service paths to query  */ CompletableFuture<Collection<String>> requestMetricQueryServicePaths(@RpcTimeout Time timeout).
true;;1;1;/**  * Requests the paths for the TaskManager's {@link MetricQueryService} to query.  *  * @param timeout for the asynchronous operation  * @return Future containing the collection of instance ids and the corresponding metric query service path  */ ;/**  * Requests the paths for the TaskManager's {@link MetricQueryService} to query.  *  * @param timeout for the asynchronous operation  * @return Future containing the collection of instance ids and the corresponding metric query service path  */ CompletableFuture<Collection<Tuple2<ResourceID, String>>> requestTaskManagerMetricQueryServicePaths(@RpcTimeout Time timeout).
true;default;4;7;/**  * Triggers a savepoint with the given savepoint directory as a target.  *  * @param jobId           ID of the job for which the savepoint should be triggered.  * @param targetDirectory Target directory for the savepoint.  * @param timeout         Timeout for the asynchronous operation  * @return A future to the {@link CompletedCheckpoint#getExternalPointer() external pointer} of  * the savepoint.  */ ;/**  * Triggers a savepoint with the given savepoint directory as a target.  *  * @param jobId           ID of the job for which the savepoint should be triggered.  * @param targetDirectory Target directory for the savepoint.  * @param timeout         Timeout for the asynchronous operation  * @return A future to the {@link CompletedCheckpoint#getExternalPointer() external pointer} of  * the savepoint.  */ default CompletableFuture<String> triggerSavepoint(JobID jobId, String targetDirectory, boolean cancelJob, @RpcTimeout Time timeout) {     throw new UnsupportedOperationException(). }
true;default;2;5;/**  * Dispose the given savepoint.  *  * @param savepointPath identifying the savepoint to dispose  * @param timeout RPC timeout  * @return A future acknowledge if the disposal succeeded  */ ;/**  * Dispose the given savepoint.  *  * @param savepointPath identifying the savepoint to dispose  * @param timeout RPC timeout  * @return A future acknowledge if the disposal succeeded  */ default CompletableFuture<Acknowledge> disposeSavepoint(final String savepointPath, @RpcTimeout final Time timeout) {     throw new UnsupportedOperationException(). }
true;default;2;5;/**  * Request the {@link JobStatus} of the given job.  *  * @param jobId identifying the job for which to retrieve the JobStatus  * @param timeout for the asynchronous operation  * @return A future to the {@link JobStatus} of the given job  */ ;/**  * Request the {@link JobStatus} of the given job.  *  * @param jobId identifying the job for which to retrieve the JobStatus  * @param timeout for the asynchronous operation  * @return A future to the {@link JobStatus} of the given job  */ default CompletableFuture<JobStatus> requestJobStatus(JobID jobId, @RpcTimeout Time timeout) {     throw new UnsupportedOperationException(). }
true;default;2;5;/**  * Requests the statistics on operator back pressure.  *  * @param jobId       Job for which the stats are requested.  * @param jobVertexId JobVertex for which the stats are requested.  * @return A Future to the {@link OperatorBackPressureStatsResponse}.  */ ;/**  * Requests the statistics on operator back pressure.  *  * @param jobId       Job for which the stats are requested.  * @param jobVertexId JobVertex for which the stats are requested.  * @return A Future to the {@link OperatorBackPressureStatsResponse}.  */ default CompletableFuture<OperatorBackPressureStatsResponse> requestOperatorBackPressureStats(JobID jobId, JobVertexID jobVertexId) {     throw new UnsupportedOperationException(). }
true;default;4;7;/**  * Trigger rescaling of the given job.  *  * @param jobId specifying the job to rescale  * @param newParallelism new parallelism of the job  * @param rescalingBehaviour defining how strict the rescaling has to be executed  * @param timeout of this operation  * @return Future which is completed with {@link Acknowledge} once the rescaling was successful  */ ;/**  * Trigger rescaling of the given job.  *  * @param jobId specifying the job to rescale  * @param newParallelism new parallelism of the job  * @param rescalingBehaviour defining how strict the rescaling has to be executed  * @param timeout of this operation  * @return Future which is completed with {@link Acknowledge} once the rescaling was successful  */ default CompletableFuture<Acknowledge> rescaleJob(JobID jobId, int newParallelism, RescalingBehaviour rescalingBehaviour, @RpcTimeout Time timeout) {     throw new UnsupportedOperationException(). }
false;default;0;3;;default CompletableFuture<Acknowledge> shutDownCluster() {     throw new UnsupportedOperationException(). }
