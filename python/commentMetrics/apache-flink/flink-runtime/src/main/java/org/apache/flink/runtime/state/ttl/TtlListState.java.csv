commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void update(List<T> values) throws Exception {     accessCallback.run().     updateInternal(values). }
false;public;1;6;;@Override public void addAll(List<T> values) throws Exception {     accessCallback.run().     Preconditions.checkNotNull(values, "List of values to add cannot be null.").     original.addAll(withTs(values)). }
false;public;0;16;;@Override public Iterable<T> get() throws Exception {     accessCallback.run().     Iterable<TtlValue<T>> ttlValue = original.get().     ttlValue = ttlValue == null ? Collections.emptyList() : ttlValue.     if (updateTsOnRead) {         List<TtlValue<T>> collected = collect(ttlValue).         ttlValue = collected.         // the underlying state in backend is iterated in updateTs anyways         // to avoid reiterating backend in IteratorWithCleanup         // it is collected and iterated next time in memory         updateTs(collected).     }     final Iterable<TtlValue<T>> finalResult = ttlValue.     return () -> new IteratorWithCleanup(finalResult.iterator()). }
false;private;1;12;;private void updateTs(List<TtlValue<T>> ttlValues) throws Exception {     List<TtlValue<T>> unexpiredWithUpdatedTs = new ArrayList<>(ttlValues.size()).     long currentTimestamp = timeProvider.currentTimestamp().     for (TtlValue<T> ttlValue : ttlValues) {         if (!TtlUtils.expired(ttlValue, ttl, currentTimestamp)) {             unexpiredWithUpdatedTs.add(TtlUtils.wrapWithTs(ttlValue.getUserValue(), currentTimestamp)).         }     }     if (!unexpiredWithUpdatedTs.isEmpty()) {         original.update(unexpiredWithUpdatedTs).     } }
false;public;1;6;;@Override public void add(T value) throws Exception {     accessCallback.run().     Preconditions.checkNotNull(value, "You cannot add null to a ListState.").     original.add(wrapWithTs(value)). }
false;public;1;19;;@Nullable @Override public List<TtlValue<T>> getUnexpiredOrNull(@Nonnull List<TtlValue<T>> ttlValues) {     long currentTimestamp = timeProvider.currentTimestamp().     List<TtlValue<T>> unexpired = new ArrayList<>(ttlValues.size()).     TypeSerializer<TtlValue<T>> elementSerializer = ((ListSerializer<TtlValue<T>>) original.getValueSerializer()).getElementSerializer().     for (TtlValue<T> ttlValue : ttlValues) {         if (!TtlUtils.expired(ttlValue, ttl, currentTimestamp)) {             // we have to do the defensive copy to update the value             unexpired.add(elementSerializer.copy(ttlValue)).         }     }     if (!unexpired.isEmpty()) {         return unexpired.     } else {         return ttlValues.size() == unexpired.size() ? ttlValues : unexpired.     } }
false;public;0;4;;@Override public void clear() {     original.clear(). }
false;public;2;4;;@Override public void mergeNamespaces(N target, Collection<N> sources) throws Exception {     original.mergeNamespaces(target, sources). }
false;public;0;4;;@Override public List<T> getInternal() throws Exception {     return collect(get()). }
false;private;1;11;;private <E> List<E> collect(Iterable<E> iterable) {     if (iterable instanceof List) {         return (List<E>) iterable.     } else {         List<E> list = new ArrayList<>().         for (E element : iterable) {             list.add(element).         }         return list.     } }
false;public;1;5;;@Override public void updateInternal(List<T> valueToStore) throws Exception {     Preconditions.checkNotNull(valueToStore, "List of values to update cannot be null.").     original.update(withTs(valueToStore)). }
false;private;1;9;;private List<TtlValue<T>> withTs(List<T> values) {     long currentTimestamp = timeProvider.currentTimestamp().     List<TtlValue<T>> withTs = new ArrayList<>(values.size()).     for (T value : values) {         Preconditions.checkNotNull(value, "You cannot have null element in a ListState.").         withTs.add(TtlUtils.wrapWithTs(value, currentTimestamp)).     }     return withTs. }
false;public;0;6;;@Override public boolean hasNext() {     findNextUnexpired().     cleanupIfEmpty().     return nextUnexpired != null. }
false;private;0;7;;private void cleanupIfEmpty() {     boolean endOfIter = !originalIterator.hasNext() && nextUnexpired == null.     if (uncleared && !anyUnexpired && endOfIter) {         original.clear().         uncleared = false.     } }
false;public;0;9;;@Override public T next() {     if (hasNext()) {         T result = nextUnexpired.         nextUnexpired = null.         return result.     }     throw new NoSuchElementException(). }
false;private;0;15;;private void findNextUnexpired() {     while (nextUnexpired == null && originalIterator.hasNext()) {         TtlValue<T> ttlValue = originalIterator.next().         if (ttlValue == null) {             break.         }         boolean unexpired = !expired(ttlValue).         if (unexpired) {             anyUnexpired = true.         }         if (unexpired || returnExpired) {             nextUnexpired = ttlValue.getUserValue().         }     } }
