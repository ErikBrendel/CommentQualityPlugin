commented;modifiers;parameterAmount;loc;comment;code
true;public;0;20;/**  * Shuts the memory manager down, trying to release all the memory it managed. Depending  * on implementation details, the memory does not necessarily become reclaimable by the  * garbage collector, because there might still be references to allocated segments in the  * code that allocated them from the memory manager.  */ ;// ------------------------------------------------------------------------ // Shutdown // ------------------------------------------------------------------------ /**  * Shuts the memory manager down, trying to release all the memory it managed. Depending  * on implementation details, the memory does not necessarily become reclaimable by the  * garbage collector, because there might still be references to allocated segments in the  * code that allocated them from the memory manager.  */ public void shutdown() {     // -------------------- BEGIN CRITICAL SECTION -------------------     synchronized (lock) {         if (!isShutDown) {             // mark as shutdown and release memory             isShutDown = true.             numNonAllocatedPages = 0.             // go over all allocated segments and release them             for (Set<MemorySegment> segments : allocatedSegments.values()) {                 for (MemorySegment seg : segments) {                     seg.free().                 }             }             memoryPool.clear().         }     } // -------------------- END CRITICAL SECTION ------------------- }
true;public;0;3;/**  * Checks whether the MemoryManager has been shut down.  *  * @return True, if the memory manager is shut down, false otherwise.  */ ;/**  * Checks whether the MemoryManager has been shut down.  *  * @return True, if the memory manager is shut down, false otherwise.  */ public boolean isShutdown() {     return isShutDown. }
true;public;0;7;/**  * Checks if the memory manager all memory available.  *  * @return True, if the memory manager is empty and valid, false if it is not empty or corrupted.  */ ;/**  * Checks if the memory manager all memory available.  *  * @return True, if the memory manager is empty and valid, false if it is not empty or corrupted.  */ public boolean verifyEmpty() {     synchronized (lock) {         return isPreAllocated ? memoryPool.getNumberOfAvailableMemorySegments() == totalNumPages : numNonAllocatedPages == totalNumPages.     } }
true;public;2;5;/**  * Allocates a set of memory segments from this memory manager. If the memory manager pre-allocated the  * segments, they will be taken from the pool of memory segments. Otherwise, they will be allocated  * as part of this call.  *  * @param owner The owner to associate with the memory segment, for the fallback release.  * @param numPages The number of pages to allocate.  * @return A list with the memory segments.  * @throws MemoryAllocationException Thrown, if this memory manager does not have the requested amount  *                                   of memory pages any more.  */ ;// ------------------------------------------------------------------------ // Memory allocation and release // ------------------------------------------------------------------------ /**  * Allocates a set of memory segments from this memory manager. If the memory manager pre-allocated the  * segments, they will be taken from the pool of memory segments. Otherwise, they will be allocated  * as part of this call.  *  * @param owner The owner to associate with the memory segment, for the fallback release.  * @param numPages The number of pages to allocate.  * @return A list with the memory segments.  * @throws MemoryAllocationException Thrown, if this memory manager does not have the requested amount  *                                   of memory pages any more.  */ public List<MemorySegment> allocatePages(Object owner, int numPages) throws MemoryAllocationException {     final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(numPages).     allocatePages(owner, segs, numPages).     return segs. }
true;public;3;50;/**  * Allocates a set of memory segments from this memory manager. If the memory manager pre-allocated the  * segments, they will be taken from the pool of memory segments. Otherwise, they will be allocated  * as part of this call.  *  * @param owner The owner to associate with the memory segment, for the fallback release.  * @param target The list into which to put the allocated memory pages.  * @param numPages The number of pages to allocate.  * @throws MemoryAllocationException Thrown, if this memory manager does not have the requested amount  *                                   of memory pages any more.  */ ;/**  * Allocates a set of memory segments from this memory manager. If the memory manager pre-allocated the  * segments, they will be taken from the pool of memory segments. Otherwise, they will be allocated  * as part of this call.  *  * @param owner The owner to associate with the memory segment, for the fallback release.  * @param target The list into which to put the allocated memory pages.  * @param numPages The number of pages to allocate.  * @throws MemoryAllocationException Thrown, if this memory manager does not have the requested amount  *                                   of memory pages any more.  */ public void allocatePages(Object owner, List<MemorySegment> target, int numPages) throws MemoryAllocationException {     // sanity check     if (owner == null) {         throw new IllegalArgumentException("The memory owner must not be null.").     }     // reserve array space, if applicable     if (target instanceof ArrayList) {         ((ArrayList<MemorySegment>) target).ensureCapacity(numPages).     }     // -------------------- BEGIN CRITICAL SECTION -------------------     synchronized (lock) {         if (isShutDown) {             throw new IllegalStateException("Memory manager has been shut down.").         }         // lazy case, the 'freeSegments.size()' is zero.         if (numPages > (memoryPool.getNumberOfAvailableMemorySegments() + numNonAllocatedPages)) {             throw new MemoryAllocationException("Could not allocate " + numPages + " pages. Only " + (memoryPool.getNumberOfAvailableMemorySegments() + numNonAllocatedPages) + " pages are remaining.").         }         Set<MemorySegment> segmentsForOwner = allocatedSegments.get(owner).         if (segmentsForOwner == null) {             segmentsForOwner = new HashSet<MemorySegment>(numPages).             allocatedSegments.put(owner, segmentsForOwner).         }         if (isPreAllocated) {             for (int i = numPages. i > 0. i--) {                 MemorySegment segment = memoryPool.requestSegmentFromPool(owner).                 target.add(segment).                 segmentsForOwner.add(segment).             }         } else {             for (int i = numPages. i > 0. i--) {                 MemorySegment segment = memoryPool.allocateNewSegment(owner).                 target.add(segment).                 segmentsForOwner.add(segment).             }             numNonAllocatedPages -= numPages.         }     } // -------------------- END CRITICAL SECTION ------------------- }
true;public;1;44;/**  * Tries to release the memory for the specified segment. If the segment has already been released or  * is null, the request is simply ignored.  *  * <p>If the memory manager manages pre-allocated memory, the memory segment goes back to the memory pool.  * Otherwise, the segment is only freed and made eligible for reclamation by the GC.  *  * @param segment The segment to be released.  * @throws IllegalArgumentException Thrown, if the given segment is of an incompatible type.  */ ;/**  * Tries to release the memory for the specified segment. If the segment has already been released or  * is null, the request is simply ignored.  *  * <p>If the memory manager manages pre-allocated memory, the memory segment goes back to the memory pool.  * Otherwise, the segment is only freed and made eligible for reclamation by the GC.  *  * @param segment The segment to be released.  * @throws IllegalArgumentException Thrown, if the given segment is of an incompatible type.  */ public void release(MemorySegment segment) {     // check if segment is null or has already been freed     if (segment == null || segment.getOwner() == null) {         return.     }     final Object owner = segment.getOwner().     // -------------------- BEGIN CRITICAL SECTION -------------------     synchronized (lock) {         // prevent double return to this memory manager         if (segment.isFreed()) {             return.         }         if (isShutDown) {             throw new IllegalStateException("Memory manager has been shut down.").         }         // remove the reference in the map for the owner         try {             Set<MemorySegment> segsForOwner = this.allocatedSegments.get(owner).             if (segsForOwner != null) {                 segsForOwner.remove(segment).                 if (segsForOwner.isEmpty()) {                     this.allocatedSegments.remove(owner).                 }             }             if (isPreAllocated) {                 // release the memory in any case                 memoryPool.returnSegmentToPool(segment).             } else {                 segment.free().                 numNonAllocatedPages++.             }         } catch (Throwable t) {             throw new RuntimeException("Error removing book-keeping reference to allocated memory segment.", t).         }     } // -------------------- END CRITICAL SECTION ------------------- }
true;public;1;74;/**  * Tries to release many memory segments together.  *  * <p>If the memory manager manages pre-allocated memory, the memory segment goes back to the memory pool.  * Otherwise, the segment is only freed and made eligible for reclamation by the GC.  *  * @param segments The segments to be released.  * @throws NullPointerException Thrown, if the given collection is null.  * @throws IllegalArgumentException Thrown, id the segments are of an incompatible type.  */ ;/**  * Tries to release many memory segments together.  *  * <p>If the memory manager manages pre-allocated memory, the memory segment goes back to the memory pool.  * Otherwise, the segment is only freed and made eligible for reclamation by the GC.  *  * @param segments The segments to be released.  * @throws NullPointerException Thrown, if the given collection is null.  * @throws IllegalArgumentException Thrown, id the segments are of an incompatible type.  */ public void release(Collection<MemorySegment> segments) {     if (segments == null) {         return.     }     // -------------------- BEGIN CRITICAL SECTION -------------------     synchronized (lock) {         if (isShutDown) {             throw new IllegalStateException("Memory manager has been shut down.").         }         // since concurrent modifications to the collection         // can disturb the release, we need to try potentially multiple times         boolean successfullyReleased = false.         do {             final Iterator<MemorySegment> segmentsIterator = segments.iterator().             Object lastOwner = null.             Set<MemorySegment> segsForOwner = null.             try {                 // go over all segments                 while (segmentsIterator.hasNext()) {                     final MemorySegment seg = segmentsIterator.next().                     if (seg == null || seg.isFreed()) {                         continue.                     }                     final Object owner = seg.getOwner().                     try {                         // the previous one (or it is the first segment)                         if (lastOwner != owner) {                             lastOwner = owner.                             segsForOwner = this.allocatedSegments.get(owner).                         }                         // remove the segment from the list                         if (segsForOwner != null) {                             segsForOwner.remove(seg).                             if (segsForOwner.isEmpty()) {                                 this.allocatedSegments.remove(owner).                             }                         }                         if (isPreAllocated) {                             memoryPool.returnSegmentToPool(seg).                         } else {                             seg.free().                             numNonAllocatedPages++.                         }                     } catch (Throwable t) {                         throw new RuntimeException("Error removing book-keeping reference to allocated memory segment.", t).                     }                 }                 segments.clear().                 // the only way to exit the loop                 successfullyReleased = true.             } catch (ConcurrentModificationException | NoSuchElementException e) {             // this may happen in the case where an asynchronous             // call releases the memory. fall through the loop and try again             }         } while (!successfullyReleased).     } // -------------------- END CRITICAL SECTION ------------------- }
true;public;1;36;/**  * Releases all memory segments for the given owner.  *  * @param owner The owner memory segments are to be released.  */ ;/**  * Releases all memory segments for the given owner.  *  * @param owner The owner memory segments are to be released.  */ public void releaseAll(Object owner) {     if (owner == null) {         return.     }     // -------------------- BEGIN CRITICAL SECTION -------------------     synchronized (lock) {         if (isShutDown) {             throw new IllegalStateException("Memory manager has been shut down.").         }         // get all segments         final Set<MemorySegment> segments = allocatedSegments.remove(owner).         // all segments may have been freed previously individually         if (segments == null || segments.isEmpty()) {             return.         }         // free each segment         if (isPreAllocated) {             for (MemorySegment seg : segments) {                 memoryPool.returnSegmentToPool(seg).             }         } else {             for (MemorySegment seg : segments) {                 seg.free().             }             numNonAllocatedPages += segments.size().         }         segments.clear().     } // -------------------- END CRITICAL SECTION ------------------- }
true;public;0;3;/**  * Gets the type of memory (heap / off-heap) managed by this memory manager.  *  * @return The type of memory managed by this memory manager.  */ ;// ------------------------------------------------------------------------ // Properties, sizes and size conversions // ------------------------------------------------------------------------ /**  * Gets the type of memory (heap / off-heap) managed by this memory manager.  *  * @return The type of memory managed by this memory manager.  */ public MemoryType getMemoryType() {     return memoryType. }
true;public;0;3;/**  * Checks whether this memory manager pre-allocates the memory.  *  * @return True if the memory manager pre-allocates the memory, false if it allocates as needed.  */ ;/**  * Checks whether this memory manager pre-allocates the memory.  *  * @return True if the memory manager pre-allocates the memory, false if it allocates as needed.  */ public boolean isPreAllocated() {     return isPreAllocated. }
true;public;0;3;/**  * Gets the size of the pages handled by the memory manager.  *  * @return The size of the pages handled by the memory manager.  */ ;/**  * Gets the size of the pages handled by the memory manager.  *  * @return The size of the pages handled by the memory manager.  */ public int getPageSize() {     return pageSize. }
true;public;0;3;/**  * Returns the total size of memory handled by this memory manager.  *  * @return The total size of memory.  */ ;/**  * Returns the total size of memory handled by this memory manager.  *  * @return The total size of memory.  */ public long getMemorySize() {     return memorySize. }
true;public;0;3;/**  * Gets the total number of memory pages managed by this memory manager.  *  * @return The total number of memory pages managed by this memory manager.  */ ;/**  * Gets the total number of memory pages managed by this memory manager.  *  * @return The total number of memory pages managed by this memory manager.  */ public int getTotalNumPages() {     return totalNumPages. }
true;public;1;7;/**  * Computes to how many pages the given number of bytes corresponds. If the given number of bytes is not an  * exact multiple of a page size, the result is rounded down, such that a portion of the memory (smaller  * than the page size) is not included.  *  * @param fraction the fraction of the total memory per slot  * @return The number of pages to which  */ ;/**  * Computes to how many pages the given number of bytes corresponds. If the given number of bytes is not an  * exact multiple of a page size, the result is rounded down, such that a portion of the memory (smaller  * than the page size) is not included.  *  * @param fraction the fraction of the total memory per slot  * @return The number of pages to which  */ public int computeNumberOfPages(double fraction) {     if (fraction <= 0 || fraction > 1) {         throw new IllegalArgumentException("The fraction of memory to allocate must within (0, 1].").     }     return (int) (totalNumPages * fraction / numberOfSlots). }
true;public;1;3;/**  * Computes the memory size of the fraction per slot.  *  * @param fraction The fraction of the memory of the task slot.  * @return The number of pages corresponding to the memory fraction.  */ ;/**  * Computes the memory size of the fraction per slot.  *  * @param fraction The fraction of the memory of the task slot.  * @return The number of pages corresponding to the memory fraction.  */ public long computeMemorySize(double fraction) {     return pageSize * (long) computeNumberOfPages(fraction). }
true;public;1;3;/**  * Rounds the given value down to a multiple of the memory manager's page size.  *  * @return The given value, rounded down to a multiple of the page size.  */ ;/**  * Rounds the given value down to a multiple of the memory manager's page size.  *  * @return The given value, rounded down to a multiple of the page size.  */ public long roundDownToPageSizeMultiple(long numBytes) {     return numBytes & roundingMask. }
false;abstract;0;1;;abstract int getNumberOfAvailableMemorySegments().
false;abstract;1;1;;abstract MemorySegment allocateNewSegment(Object owner).
false;abstract;1;1;;abstract MemorySegment requestSegmentFromPool(Object owner).
false;abstract;1;1;;abstract void returnSegmentToPool(MemorySegment segment).
false;abstract;0;1;;abstract void clear().
false;;1;4;;@Override MemorySegment allocateNewSegment(Object owner) {     return MemorySegmentFactory.allocateUnpooledSegment(segmentSize, owner). }
false;;1;5;;@Override MemorySegment requestSegmentFromPool(Object owner) {     byte[] buf = availableMemory.remove().     return MemorySegmentFactory.wrapPooledHeapMemory(buf, owner). }
false;;1;11;;@Override void returnSegmentToPool(MemorySegment segment) {     if (segment.getClass() == HybridMemorySegment.class) {         HybridMemorySegment heapSegment = (HybridMemorySegment) segment.         availableMemory.add(heapSegment.getArray()).         heapSegment.free().     } else {         throw new IllegalArgumentException("Memory segment is not a " + HybridMemorySegment.class.getSimpleName()).     } }
false;protected;0;4;;@Override protected int getNumberOfAvailableMemorySegments() {     return availableMemory.size(). }
false;;0;4;;@Override void clear() {     availableMemory.clear(). }
false;;1;4;;@Override MemorySegment allocateNewSegment(Object owner) {     return MemorySegmentFactory.allocateUnpooledOffHeapMemory(segmentSize, owner). }
false;;1;5;;@Override MemorySegment requestSegmentFromPool(Object owner) {     ByteBuffer buf = availableMemory.remove().     return MemorySegmentFactory.wrapPooledOffHeapMemory(buf, owner). }
false;;1;12;;@Override void returnSegmentToPool(MemorySegment segment) {     if (segment.getClass() == HybridMemorySegment.class) {         HybridMemorySegment hybridSegment = (HybridMemorySegment) segment.         ByteBuffer buf = hybridSegment.getOffHeapBuffer().         availableMemory.add(buf).         hybridSegment.free().     } else {         throw new IllegalArgumentException("Memory segment is not a " + HybridMemorySegment.class.getSimpleName()).     } }
false;protected;0;4;;@Override protected int getNumberOfAvailableMemorySegments() {     return availableMemory.size(). }
false;;0;4;;@Override void clear() {     availableMemory.clear(). }
