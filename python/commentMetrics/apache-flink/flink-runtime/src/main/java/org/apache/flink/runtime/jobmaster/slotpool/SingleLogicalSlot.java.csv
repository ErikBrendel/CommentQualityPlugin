commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public TaskManagerLocation getTaskManagerLocation() {     return slotContext.getTaskManagerLocation(). }
false;public;0;4;;@Override public TaskManagerGateway getTaskManagerGateway() {     return slotContext.getTaskManagerGateway(). }
false;public;0;4;;@Override public Locality getLocality() {     return locality. }
false;public;0;4;;@Override public boolean isAlive() {     return state == State.ALIVE. }
false;public;1;4;;@Override public boolean tryAssignPayload(Payload payload) {     return PAYLOAD_UPDATER.compareAndSet(this, null, payload). }
false;public;0;5;;@Nullable @Override public Payload getPayload() {     return payload. }
false;public;1;9;;@Override public CompletableFuture<?> releaseSlot(@Nullable Throwable cause) {     if (STATE_UPDATER.compareAndSet(this, State.ALIVE, State.RELEASING)) {         signalPayloadRelease(cause).         returnSlotToOwner(payload.getTerminalStateFuture()).     }     return releaseFuture. }
false;public;0;4;;@Override public int getPhysicalSlotNumber() {     return slotContext.getPhysicalSlotNumber(). }
false;public;0;4;;@Override public AllocationID getAllocationId() {     return slotContext.getAllocationId(). }
false;public;0;4;;@Override public SlotRequestId getSlotRequestId() {     return slotRequestId. }
false;public;0;5;;@Nullable @Override public SlotSharingGroupId getSlotSharingGroupId() {     return slotSharingGroupId. }
true;public;1;8;/**  * A release of the payload by the {@link AllocatedSlot} triggers a release of the payload of  * the logical slot.  *  * @param cause of the payload release  */ ;// ------------------------------------------------------------------------- // AllocatedSlot.Payload implementation // ------------------------------------------------------------------------- /**  * A release of the payload by the {@link AllocatedSlot} triggers a release of the payload of  * the logical slot.  *  * @param cause of the payload release  */ @Override public void release(Throwable cause) {     if (STATE_UPDATER.compareAndSet(this, State.ALIVE, State.RELEASING)) {         signalPayloadRelease(cause).     }     markReleased().     releaseFuture.complete(null). }
false;private;1;4;;private void signalPayloadRelease(Throwable cause) {     tryAssignPayload(TERMINATED_PAYLOAD).     payload.fail(cause). }
false;private;1;17;;private void returnSlotToOwner(CompletableFuture<?> terminalStateFuture) {     terminalStateFuture.whenComplete((Object ignored, Throwable throwable) -> {         if (state == State.RELEASING) {             slotOwner.returnLogicalSlot(this).         }         markReleased().         if (throwable != null) {             releaseFuture.completeExceptionally(throwable).         } else {             releaseFuture.complete(null).         }     }). }
false;private;0;3;;private void markReleased() {     state = State.RELEASED. }
