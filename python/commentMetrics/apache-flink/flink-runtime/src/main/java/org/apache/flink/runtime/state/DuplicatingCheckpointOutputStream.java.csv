commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public void write(int b) throws IOException {     if (buffer.length <= bufferIdx) {         flushInternalBuffer().     }     buffer[bufferIdx] = (byte) b.     ++bufferIdx. }
false;public;1;5;;@Override public void write(byte[] b) throws IOException {     write(b, 0, b.length). }
false;public;3;17;;@Override public void write(byte[] b, int off, int len) throws IOException {     if (buffer.length <= len) {         flushInternalBuffer().         writeThroughInternal(b, off, len).     } else {         if (buffer.length < len + bufferIdx) {             flushInternalBuffer().         }         System.arraycopy(b, off, buffer, bufferIdx, len).         bufferIdx += len.     } }
false;public;0;5;;@Override public long getPos() throws IOException {     final long referencePos = primaryOutputStream.getPos().     return referencePos + bufferIdx. }
false;public;0;14;;@Override public void flush() throws IOException {     flushInternalBuffer().     primaryOutputStream.flush().     if (secondaryStreamException == null) {         try {             secondaryOutputStream.flush().         } catch (Exception flushEx) {             handleSecondaryStreamOnException(flushEx).         }     } }
false;public;0;14;;@Override public void sync() throws IOException {     flushInternalBuffer().     primaryOutputStream.sync().     if (secondaryStreamException == null) {         try {             secondaryOutputStream.sync().         } catch (Exception syncEx) {             handleSecondaryStreamOnException(syncEx).         }     } }
false;public;0;29;;@Override public void close() throws IOException {     Exception exCollector = null.     try {         flushInternalBuffer().     } catch (Exception flushEx) {         exCollector = flushEx.     }     try {         primaryOutputStream.close().     } catch (Exception closeEx) {         exCollector = ExceptionUtils.firstOrSuppressed(closeEx, exCollector).     }     if (secondaryStreamException == null) {         try {             secondaryOutputStream.close().         } catch (Exception closeEx) {             handleSecondaryStreamOnException(closeEx).         }     }     if (exCollector != null) {         throw new IOException("Exception while closing duplicating stream.", exCollector).     } }
false;private;0;20;;private void checkForAlignedStreamPositions() throws IOException {     if (secondaryStreamException != null) {         return.     }     final long primaryPos = primaryOutputStream.getPos().     try {         final long secondaryPos = secondaryOutputStream.getPos().         if (primaryPos != secondaryPos) {             handleSecondaryStreamOnException(new IOException("Stream positions are out of sync between primary stream and secondary stream. " + "Reported positions are " + primaryPos + " (primary) and " + secondaryPos + " (secondary).")).         }     } catch (Exception posEx) {         handleSecondaryStreamOnException(posEx).     } }
false;private;0;7;;private void flushInternalBuffer() throws IOException {     if (bufferIdx > 0) {         writeThroughInternal(buffer, 0, bufferIdx).         bufferIdx = 0.     } }
false;private;3;12;;private void writeThroughInternal(byte[] b, int off, int len) throws IOException {     primaryOutputStream.write(b, off, len).     if (secondaryStreamException == null) {         try {             secondaryOutputStream.write(b, off, len).         } catch (Exception writeEx) {             handleSecondaryStreamOnException(writeEx).         }     } }
false;private;1;13;;private void handleSecondaryStreamOnException(Exception ex) {     Preconditions.checkState(secondaryStreamException == null, "Secondary stream already failed from previous exception!").     try {         secondaryOutputStream.close().     } catch (Exception closeEx) {         ex = ExceptionUtils.firstOrSuppressed(closeEx, ex).     }     secondaryStreamException = Preconditions.checkNotNull(ex). }
false;public;0;5;;@Nullable @Override public StreamStateHandle closeAndGetHandle() throws IOException {     return closeAndGetPrimaryHandle(). }
true;public;0;4;/**  * Returns the state handle from the {@link #primaryOutputStream}.  */ ;/**  * Returns the state handle from the {@link #primaryOutputStream}.  */ public StreamStateHandle closeAndGetPrimaryHandle() throws IOException {     flushInternalBuffer().     return primaryOutputStream.closeAndGetHandle(). }
true;public;0;8;/**  * Returns the state handle from the {@link #secondaryOutputStream}. Also reports suppressed exceptions from earlier  * interactions with that stream.  */ ;/**  * Returns the state handle from the {@link #secondaryOutputStream}. Also reports suppressed exceptions from earlier  * interactions with that stream.  */ public StreamStateHandle closeAndGetSecondaryHandle() throws IOException {     if (secondaryStreamException == null) {         flushInternalBuffer().         return secondaryOutputStream.closeAndGetHandle().     } else {         throw new IOException("Secondary stream previously failed exceptionally", secondaryStreamException).     } }
false;public;0;3;;public Exception getSecondaryStreamException() {     return secondaryStreamException. }
false;;0;4;;@VisibleForTesting CheckpointStreamFactory.CheckpointStateOutputStream getPrimaryOutputStream() {     return primaryOutputStream. }
false;;0;4;;@VisibleForTesting CheckpointStreamFactory.CheckpointStateOutputStream getSecondaryOutputStream() {     return secondaryOutputStream. }
