commented;modifiers;parameterAmount;loc;comment;code
false;public;4;73;;@Nonnull public TaskLocalStateStore localStateStoreForSubtask(@Nonnull JobID jobId, @Nonnull AllocationID allocationID, @Nonnull JobVertexID jobVertexID, @Nonnegative int subtaskIndex) {     synchronized (lock) {         if (closed) {             throw new IllegalStateException("TaskExecutorLocalStateStoresManager is already closed and cannot " + "register a new TaskLocalStateStore.").         }         Map<JobVertexSubtaskKey, OwnedTaskLocalStateStore> taskStateManagers = this.taskStateStoresByAllocationID.get(allocationID).         if (taskStateManagers == null) {             taskStateManagers = new HashMap<>().             this.taskStateStoresByAllocationID.put(allocationID, taskStateManagers).             if (LOG.isDebugEnabled()) {                 LOG.debug("Registered new allocation id {} for local state stores for job {}.", allocationID.toHexString(), jobId).             }         }         final JobVertexSubtaskKey taskKey = new JobVertexSubtaskKey(jobVertexID, subtaskIndex).         OwnedTaskLocalStateStore taskLocalStateStore = taskStateManagers.get(taskKey).         if (taskLocalStateStore == null) {             // create the allocation base dirs, one inside each root dir.             File[] allocationBaseDirectories = allocationBaseDirectories(allocationID).             LocalRecoveryDirectoryProviderImpl directoryProvider = new LocalRecoveryDirectoryProviderImpl(allocationBaseDirectories, jobId, jobVertexID, subtaskIndex).             LocalRecoveryConfig localRecoveryConfig = new LocalRecoveryConfig(localRecoveryEnabled, directoryProvider).             taskLocalStateStore = localRecoveryConfig.isLocalRecoveryEnabled() ? // Real store implementation if local recovery is enabled             new TaskLocalStateStoreImpl(jobId, allocationID, jobVertexID, subtaskIndex, localRecoveryConfig, discardExecutor) : // NOP implementation if local recovery is disabled             new NoOpTaskLocalStateStoreImpl(localRecoveryConfig).             taskStateManagers.put(taskKey, taskLocalStateStore).             LOG.debug("Registered new local state store with configuration {} for {} - {} - {} under allocation " + "id {}.", localRecoveryConfig, jobId, jobVertexID, subtaskIndex, allocationID).         } else {             LOG.debug("Found existing local state store for {} - {} - {} under allocation id {}: {}", jobId, jobVertexID, subtaskIndex, allocationID, taskLocalStateStore).         }         return taskLocalStateStore.     } }
false;public;1;21;;public void releaseLocalStateForAllocationId(@Nonnull AllocationID allocationID) {     if (LOG.isDebugEnabled()) {         LOG.debug("Releasing local state under allocation id {}.", allocationID).     }     Map<JobVertexSubtaskKey, OwnedTaskLocalStateStore> cleanupLocalStores.     synchronized (lock) {         if (closed) {             return.         }         cleanupLocalStores = taskStateStoresByAllocationID.remove(allocationID).     }     if (cleanupLocalStores != null) {         doRelease(cleanupLocalStores.values()).     }     cleanupAllocationBaseDirs(allocationID). }
false;public;0;26;;public void shutdown() {     HashMap<AllocationID, Map<JobVertexSubtaskKey, OwnedTaskLocalStateStore>> toRelease.     synchronized (lock) {         if (closed) {             return.         }         closed = true.         toRelease = new HashMap<>(taskStateStoresByAllocationID).         taskStateStoresByAllocationID.clear().     }     ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG).     LOG.info("Shutting down TaskExecutorLocalStateStoresManager.").     for (Map.Entry<AllocationID, Map<JobVertexSubtaskKey, OwnedTaskLocalStateStore>> entry : toRelease.entrySet()) {         doRelease(entry.getValue().values()).         cleanupAllocationBaseDirs(entry.getKey()).     } }
false;;0;4;;@VisibleForTesting boolean isLocalRecoveryEnabled() {     return localRecoveryEnabled. }
false;;0;4;;@VisibleForTesting File[] getLocalStateRootDirectories() {     return localStateRootDirectories. }
false;;1;4;;@VisibleForTesting String allocationSubDirString(AllocationID allocationID) {     return "aid_" + allocationID.toHexString(). }
false;private;1;8;;private File[] allocationBaseDirectories(AllocationID allocationID) {     final String allocationSubDirString = allocationSubDirString(allocationID).     final File[] allocationDirectories = new File[localStateRootDirectories.length].     for (int i = 0. i < localStateRootDirectories.length. ++i) {         allocationDirectories[i] = new File(localStateRootDirectories[i], allocationSubDirString).     }     return allocationDirectories. }
false;private;1;13;;private void doRelease(Iterable<OwnedTaskLocalStateStore> toRelease) {     if (toRelease != null) {         for (OwnedTaskLocalStateStore stateStore : toRelease) {             try {                 stateStore.dispose().             } catch (Exception disposeEx) {                 LOG.warn("Exception while disposing local state store {}.", stateStore, disposeEx).             }         }     } }
true;private;1;11;/**  * Deletes the base dirs for this allocation id (recursively).  */ ;/**  * Deletes the base dirs for this allocation id (recursively).  */ private void cleanupAllocationBaseDirs(AllocationID allocationID) {     // clear the base dirs for this allocation id.     File[] allocationDirectories = allocationBaseDirectories(allocationID).     for (File directory : allocationDirectories) {         try {             FileUtils.deleteFileOrDirectory(directory).         } catch (IOException e) {             LOG.warn("Exception while deleting local state directory for allocation id {}.", allocationID, e).         }     } }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     JobVertexSubtaskKey that = (JobVertexSubtaskKey) o.     return subtaskIndex == that.subtaskIndex && jobVertexID.equals(that.jobVertexID). }
false;public;0;6;;@Override public int hashCode() {     int result = jobVertexID.hashCode().     result = 31 * result + subtaskIndex.     return result. }
