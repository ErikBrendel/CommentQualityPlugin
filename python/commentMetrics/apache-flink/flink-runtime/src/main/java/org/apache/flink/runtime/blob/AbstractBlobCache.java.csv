commented;modifiers;parameterAmount;loc;comment;code
true;protected;2;62;/**  * Returns local copy of the file for the BLOB with the given key.  *  * <p>The method will first attempt to serve the BLOB from its local cache. If the BLOB is not  * in the cache, the method will try to download it from this cache's BLOB server via a  * distributed BLOB store (if available) or direct end-to-end download.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param blobKey  * 		The key of the desired BLOB.  *  * @return file referring to the local storage location of the BLOB.  *  * @throws IOException  * 		Thrown if an I/O error occurs while downloading the BLOBs from the BLOB server.  */ ;/**  * Returns local copy of the file for the BLOB with the given key.  *  * <p>The method will first attempt to serve the BLOB from its local cache. If the BLOB is not  * in the cache, the method will try to download it from this cache's BLOB server via a  * distributed BLOB store (if available) or direct end-to-end download.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param blobKey  * 		The key of the desired BLOB.  *  * @return file referring to the local storage location of the BLOB.  *  * @throws IOException  * 		Thrown if an I/O error occurs while downloading the BLOBs from the BLOB server.  */ protected File getFileInternal(@Nullable JobID jobId, BlobKey blobKey) throws IOException {     checkArgument(blobKey != null, "BLOB key cannot be null.").     final File localFile = BlobUtils.getStorageLocation(storageDir, jobId, blobKey).     readWriteLock.readLock().lock().     try {         if (localFile.exists()) {             return localFile.         }     } finally {         readWriteLock.readLock().unlock().     }     // first try the distributed blob store (if available)     // use a temporary file (thread-safe without locking)     File incomingFile = createTemporaryFilename().     try {         try {             if (blobView.get(jobId, blobKey, incomingFile)) {                 // now move the temp file to our local cache atomically                 readWriteLock.writeLock().lock().                 try {                     BlobUtils.moveTempFileToStore(incomingFile, jobId, blobKey, localFile, log, null).                 } finally {                     readWriteLock.writeLock().unlock().                 }                 return localFile.             }         } catch (Exception e) {             log.info("Failed to copy from blob store. Downloading from BLOB server instead.", e).         }         final InetSocketAddress currentServerAddress = serverAddress.         if (currentServerAddress != null) {             // fallback: download from the BlobServer             BlobClient.downloadFromBlobServer(jobId, blobKey, incomingFile, currentServerAddress, blobClientConfig, numFetchRetries).             readWriteLock.writeLock().lock().             try {                 BlobUtils.moveTempFileToStore(incomingFile, jobId, blobKey, localFile, log, null).             } finally {                 readWriteLock.writeLock().unlock().             }         } else {             throw new IOException("Cannot download from BlobServer, because the server address is unknown.").         }         return localFile.     } finally {         // delete incomingFile from a failed download         if (!incomingFile.delete() && incomingFile.exists()) {             log.warn("Could not delete the staging file {} for blob key {} and job {}.", incomingFile, blobKey, jobId).         }     } }
true;public;0;9;/**  * Returns the port the BLOB server is listening on.  *  * @return BLOB server port or {@code -1} if no server address  */ ;/**  * Returns the port the BLOB server is listening on.  *  * @return BLOB server port or {@code -1} if no server address  */ public int getPort() {     final InetSocketAddress currentServerAddress = serverAddress.     if (currentServerAddress != null) {         return currentServerAddress.getPort().     } else {         return -1.     } }
true;public;1;3;/**  * Sets the address of the {@link BlobServer}.  *  * @param blobServerAddress address of the {@link BlobServer}.  */ ;/**  * Sets the address of the {@link BlobServer}.  *  * @param blobServerAddress address of the {@link BlobServer}.  */ public void setBlobServerAddress(InetSocketAddress blobServerAddress) {     serverAddress = checkNotNull(blobServerAddress). }
true;;0;4;/**  * Returns a temporary file inside the BLOB server's incoming directory.  *  * @return a temporary file inside the BLOB server's incoming directory  *  * @throws IOException  * 		if creating the directory fails  */ ;/**  * Returns a temporary file inside the BLOB server's incoming directory.  *  * @return a temporary file inside the BLOB server's incoming directory  *  * @throws IOException  * 		if creating the directory fails  */ File createTemporaryFilename() throws IOException {     return new File(BlobUtils.getIncomingDirectory(storageDir), String.format("temp-%08d", tempFileCounter.getAndIncrement())). }
false;public;0;16;;@Override public void close() throws IOException {     cancelCleanupTask().     if (shutdownRequested.compareAndSet(false, true)) {         log.info("Shutting down BLOB cache").         // Clean up the storage directory         try {             FileUtils.deleteDirectory(storageDir).         } finally {             // Remove shutdown hook to prevent resource leaks             ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), log).         }     } }
true;protected,abstract;0;1;/**  * Cancels any cleanup task that subclasses may be executing.  *  * <p>This is called during {@link #close()}.  */ ;/**  * Cancels any cleanup task that subclasses may be executing.  *  * <p>This is called during {@link #close()}.  */ protected abstract void cancelCleanupTask().
