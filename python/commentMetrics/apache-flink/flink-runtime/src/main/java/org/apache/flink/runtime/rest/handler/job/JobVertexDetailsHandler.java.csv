commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;14;;@Override protected JobVertexDetailsInfo handleRequest(HandlerRequest<EmptyRequestBody, JobVertexMessageParameters> request, AccessExecutionGraph executionGraph) throws NotFoundException {     JobID jobID = request.getPathParameter(JobIDPathParameter.class).     JobVertexID jobVertexID = request.getPathParameter(JobVertexIdPathParameter.class).     AccessExecutionJobVertex jobVertex = executionGraph.getJobVertex(jobVertexID).     if (jobVertex == null) {         throw new NotFoundException(String.format("JobVertex %s not found", jobVertexID)).     }     return createJobVertexDetailsInfo(jobVertex, jobID, metricFetcher). }
false;public;1;13;;@Override public Collection<ArchivedJson> archiveJsonWithPath(AccessExecutionGraph graph) throws IOException {     Collection<? extends AccessExecutionJobVertex> vertices = graph.getAllVertices().values().     List<ArchivedJson> archive = new ArrayList<>(vertices.size()).     for (AccessExecutionJobVertex task : vertices) {         ResponseBody json = createJobVertexDetailsInfo(task, graph.getJobID(), null).         String path = getMessageHeaders().getTargetRestEndpointURL().replace(':' + JobIDPathParameter.KEY, graph.getJobID().toString()).replace(':' + JobVertexIdPathParameter.KEY, task.getJobVertexId().toString()).         archive.add(new ArchivedJson(path, json)).     }     return archive. }
false;private,static;3;51;;private static JobVertexDetailsInfo createJobVertexDetailsInfo(AccessExecutionJobVertex jobVertex, JobID jobID, @Nullable MetricFetcher metricFetcher) {     List<JobVertexDetailsInfo.VertexTaskDetail> subtasks = new ArrayList<>().     final long now = System.currentTimeMillis().     int num = 0.     for (AccessExecutionVertex vertex : jobVertex.getTaskVertices()) {         final ExecutionState status = vertex.getExecutionState().         TaskManagerLocation location = vertex.getCurrentAssignedResourceLocation().         String locationString = location == null ? "(unassigned)" : location.getHostname() + ":" + location.dataPort().         long startTime = vertex.getStateTimestamp(ExecutionState.DEPLOYING).         if (startTime == 0) {             startTime = -1.         }         long endTime = status.isTerminal() ? vertex.getStateTimestamp(status) : -1.         long duration = startTime > 0 ? ((endTime > 0 ? endTime : now) - startTime) : -1.         MutableIOMetrics counts = new MutableIOMetrics().         counts.addIOMetrics(vertex.getCurrentExecutionAttempt(), metricFetcher, jobID.toString(), jobVertex.getJobVertexId().toString()).         subtasks.add(new JobVertexDetailsInfo.VertexTaskDetail(num, status, vertex.getCurrentExecutionAttempt().getAttemptNumber(), locationString, startTime, endTime, duration, new IOMetricsInfo(counts.getNumBytesInLocal() + counts.getNumBytesInRemote(), counts.isNumBytesInLocalComplete() && counts.isNumBytesInRemoteComplete(), counts.getNumBytesOut(), counts.isNumBytesOutComplete(), counts.getNumRecordsIn(), counts.isNumRecordsInComplete(), counts.getNumRecordsOut(), counts.isNumRecordsOutComplete()))).         num++.     }     return new JobVertexDetailsInfo(jobVertex.getJobVertexId(), jobVertex.getName(), jobVertex.getParallelism(), now, subtasks). }
