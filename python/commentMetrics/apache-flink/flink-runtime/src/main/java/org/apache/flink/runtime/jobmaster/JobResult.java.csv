commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns {@code true} if the job finished successfully.  */ ;/**  * Returns {@code true} if the job finished successfully.  */ public boolean isSuccess() {     return applicationStatus == ApplicationStatus.SUCCEEDED || (applicationStatus == ApplicationStatus.UNKNOWN && serializedThrowable == null). }
false;public;0;3;;public JobID getJobId() {     return jobId. }
false;public;0;3;;public ApplicationStatus getApplicationStatus() {     return applicationStatus. }
false;public;0;3;;public Map<String, SerializedValue<OptionalFailure<Object>>> getAccumulatorResults() {     return accumulatorResults. }
false;public;0;3;;public long getNetRuntime() {     return netRuntime. }
true;public;0;3;/**  * Returns an empty {@code Optional} if the job finished successfully, otherwise the  * {@code Optional} will carry the failure cause.  */ ;/**  * Returns an empty {@code Optional} if the job finished successfully, otherwise the  * {@code Optional} will carry the failure cause.  */ public Optional<SerializedThrowable> getSerializedThrowable() {     return Optional.ofNullable(serializedThrowable). }
true;public;1;30;/**  * Converts the {@link JobResult} to a {@link JobExecutionResult}.  *  * @param classLoader to use for deserialization  * @return JobExecutionResult  * @throws JobCancellationException if the job was cancelled  * @throws JobExecutionException if the job execution did not succeed  * @throws IOException if the accumulator could not be deserialized  * @throws ClassNotFoundException if the accumulator could not deserialized  */ ;/**  * Converts the {@link JobResult} to a {@link JobExecutionResult}.  *  * @param classLoader to use for deserialization  * @return JobExecutionResult  * @throws JobCancellationException if the job was cancelled  * @throws JobExecutionException if the job execution did not succeed  * @throws IOException if the accumulator could not be deserialized  * @throws ClassNotFoundException if the accumulator could not deserialized  */ public JobExecutionResult toJobExecutionResult(ClassLoader classLoader) throws JobExecutionException, IOException, ClassNotFoundException {     if (applicationStatus == ApplicationStatus.SUCCEEDED) {         return new JobExecutionResult(jobId, netRuntime, AccumulatorHelper.deserializeAccumulators(accumulatorResults, classLoader)).     } else {         final Throwable cause.         if (serializedThrowable == null) {             cause = null.         } else {             cause = serializedThrowable.deserializeError(classLoader).         }         final JobExecutionException exception.         if (applicationStatus == ApplicationStatus.FAILED) {             exception = new JobExecutionException(jobId, "Job execution failed.", cause).         } else if (applicationStatus == ApplicationStatus.CANCELED) {             exception = new JobCancellationException(jobId, "Job was cancelled.", cause).         } else {             exception = new JobExecutionException(jobId, "Job completed with illegal application status: " + applicationStatus + '.', cause).         }         throw exception.     } }
false;public;1;4;;public Builder jobId(final JobID jobId) {     this.jobId = jobId.     return this. }
false;public;1;4;;public Builder applicationStatus(final ApplicationStatus applicationStatus) {     this.applicationStatus = applicationStatus.     return this. }
false;public;1;4;;public Builder accumulatorResults(final Map<String, SerializedValue<OptionalFailure<Object>>> accumulatorResults) {     this.accumulatorResults = accumulatorResults.     return this. }
false;public;1;4;;public Builder netRuntime(final long netRuntime) {     this.netRuntime = netRuntime.     return this. }
false;public;1;4;;public Builder serializedThrowable(final SerializedThrowable serializedThrowable) {     this.serializedThrowable = serializedThrowable.     return this. }
false;public;0;8;;public JobResult build() {     return new JobResult(jobId, applicationStatus, accumulatorResults == null ? Collections.emptyMap() : accumulatorResults, netRuntime, serializedThrowable). }
true;public,static;1;30;/**  * Creates the {@link JobResult} from the given {@link AccessExecutionGraph} which  * must be in a globally terminal state.  *  * @param accessExecutionGraph to create the JobResult from  * @return JobResult of the given AccessExecutionGraph  */ ;/**  * Creates the {@link JobResult} from the given {@link AccessExecutionGraph} which  * must be in a globally terminal state.  *  * @param accessExecutionGraph to create the JobResult from  * @return JobResult of the given AccessExecutionGraph  */ public static JobResult createFrom(AccessExecutionGraph accessExecutionGraph) {     final JobID jobId = accessExecutionGraph.getJobID().     final JobStatus jobStatus = accessExecutionGraph.getState().     checkArgument(jobStatus.isGloballyTerminalState(), "The job " + accessExecutionGraph.getJobName() + '(' + jobId + ") is not in a globally " + "terminal state. It is in state " + jobStatus + '.').     final JobResult.Builder builder = new JobResult.Builder().     builder.jobId(jobId).     builder.applicationStatus(ApplicationStatus.fromJobStatus(accessExecutionGraph.getState())).     final long netRuntime = accessExecutionGraph.getStatusTimestamp(jobStatus) - accessExecutionGraph.getStatusTimestamp(JobStatus.CREATED).     // guard against clock changes     final long guardedNetRuntime = Math.max(netRuntime, 0L).     builder.netRuntime(guardedNetRuntime).     builder.accumulatorResults(accessExecutionGraph.getAccumulatorsSerialized()).     if (jobStatus != JobStatus.FINISHED) {         final ErrorInfo errorInfo = accessExecutionGraph.getFailureInfo().         if (errorInfo != null) {             builder.serializedThrowable(errorInfo.getException()).         }     }     return builder.build(). }
