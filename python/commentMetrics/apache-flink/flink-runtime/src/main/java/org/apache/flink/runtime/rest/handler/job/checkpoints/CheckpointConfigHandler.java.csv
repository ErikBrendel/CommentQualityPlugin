commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;4;;@Override protected CheckpointConfigInfo handleRequest(HandlerRequest<EmptyRequestBody, JobMessageParameters> request, AccessExecutionGraph executionGraph) throws RestHandlerException {     return createCheckpointConfigInfo(executionGraph). }
false;public;1;12;;@Override public Collection<ArchivedJson> archiveJsonWithPath(AccessExecutionGraph graph) throws IOException {     ResponseBody response.     try {         response = createCheckpointConfigInfo(graph).     } catch (RestHandlerException rhe) {         response = new ErrorResponseBody(rhe.getMessage()).     }     String path = CheckpointConfigHeaders.getInstance().getTargetRestEndpointURL().replace(':' + JobIDPathParameter.KEY, graph.getJobID().toString()).     return Collections.singletonList(new ArchivedJson(path, response)). }
false;private,static;1;23;;private static CheckpointConfigInfo createCheckpointConfigInfo(AccessExecutionGraph executionGraph) throws RestHandlerException {     final CheckpointCoordinatorConfiguration checkpointCoordinatorConfiguration = executionGraph.getCheckpointCoordinatorConfiguration().     if (checkpointCoordinatorConfiguration == null) {         throw new RestHandlerException("Checkpointing is not enabled for this job (" + executionGraph.getJobID() + ").", HttpResponseStatus.NOT_FOUND).     } else {         CheckpointRetentionPolicy retentionPolicy = checkpointCoordinatorConfiguration.getCheckpointRetentionPolicy().         CheckpointConfigInfo.ExternalizedCheckpointInfo externalizedCheckpointInfo = new CheckpointConfigInfo.ExternalizedCheckpointInfo(retentionPolicy != CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION, retentionPolicy != CheckpointRetentionPolicy.RETAIN_ON_CANCELLATION).         return new CheckpointConfigInfo(checkpointCoordinatorConfiguration.isExactlyOnce() ? CheckpointConfigInfo.ProcessingMode.EXACTLY_ONCE : CheckpointConfigInfo.ProcessingMode.AT_LEAST_ONCE, checkpointCoordinatorConfiguration.getCheckpointInterval(), checkpointCoordinatorConfiguration.getCheckpointTimeout(), checkpointCoordinatorConfiguration.getMinPauseBetweenCheckpoints(), checkpointCoordinatorConfiguration.getMaxConcurrentCheckpoints(), externalizedCheckpointInfo).     } }
