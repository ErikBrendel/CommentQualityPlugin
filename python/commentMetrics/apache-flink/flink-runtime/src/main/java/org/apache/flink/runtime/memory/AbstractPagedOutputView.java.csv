commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;2;1;/**  * This method must return a segment. If no more segments are available, it must throw an  * {@link java.io.EOFException}.  *  * @param current The current memory segment  * @param positionInCurrent The position in the segment, one after the last valid byte.  * @return The next memory segment.  *  * @throws IOException  */ ;// -------------------------------------------------------------------------------------------- // Page Management // -------------------------------------------------------------------------------------------- /**  * This method must return a segment. If no more segments are available, it must throw an  * {@link java.io.EOFException}.  *  * @param current The current memory segment  * @param positionInCurrent The position in the segment, one after the last valid byte.  * @return The next memory segment.  *  * @throws IOException  */ protected abstract MemorySegment nextSegment(MemorySegment current, int positionInCurrent) throws IOException.
true;public;0;3;/**  * Gets the segment that the view currently writes to.  *  * @return The segment the view currently writes to.  */ ;/**  * Gets the segment that the view currently writes to.  *  * @return The segment the view currently writes to.  */ public MemorySegment getCurrentSegment() {     return this.currentSegment. }
true;public;0;3;/**  * Gets the current write position (the position where the next bytes will be written)  * in the current memory segment.  *  * @return The current write offset in the current memory segment.  */ ;/**  * Gets the current write position (the position where the next bytes will be written)  * in the current memory segment.  *  * @return The current write offset in the current memory segment.  */ public int getCurrentPositionInSegment() {     return this.positionInSegment. }
true;public;0;3;/**  * Gets the size of the segments used by this view.  *  * @return The memory segment size.  */ ;/**  * Gets the size of the segments used by this view.  *  * @return The memory segment size.  */ public int getSegmentSize() {     return this.segmentSize. }
true;protected;0;4;/**  * Moves the output view to the next page. This method invokes internally the  * {@link #nextSegment(MemorySegment, int)} method to give the current memory segment to the concrete subclass'  * implementation and obtain the next segment to write to. Writing will continue inside the new segment  * after the header.  *  * @throws IOException Thrown, if the current segment could not be processed or a new segment could not  *                     be obtained.  */ ;/**  * Moves the output view to the next page. This method invokes internally the  * {@link #nextSegment(MemorySegment, int)} method to give the current memory segment to the concrete subclass'  * implementation and obtain the next segment to write to. Writing will continue inside the new segment  * after the header.  *  * @throws IOException Thrown, if the current segment could not be processed or a new segment could not  *                     be obtained.  */ protected void advance() throws IOException {     this.currentSegment = nextSegment(this.currentSegment, this.positionInSegment).     this.positionInSegment = this.headerLength. }
true;protected;2;4;/**  * Sets the internal state to the given memory segment and the given position within the segment.  *  * @param seg The memory segment to write the next bytes to.  * @param position The position to start writing the next bytes to.  */ ;/**  * Sets the internal state to the given memory segment and the given position within the segment.  *  * @param seg The memory segment to write the next bytes to.  * @param position The position to start writing the next bytes to.  */ protected void seekOutput(MemorySegment seg, int position) {     this.currentSegment = seg.     this.positionInSegment = position. }
true;protected;0;4;/**  * Clears the internal state. Any successive write calls will fail until either {@link #advance()} or  * {@link #seekOutput(MemorySegment, int)} is called.  *  * @see #advance()  * @see #seekOutput(MemorySegment, int)  */ ;/**  * Clears the internal state. Any successive write calls will fail until either {@link #advance()} or  * {@link #seekOutput(MemorySegment, int)} is called.  *  * @see #advance()  * @see #seekOutput(MemorySegment, int)  */ protected void clear() {     this.currentSegment = null.     this.positionInSegment = this.headerLength. }
false;public;1;4;;// -------------------------------------------------------------------------------------------- // Data Output Specific methods // -------------------------------------------------------------------------------------------- @Override public void write(int b) throws IOException {     writeByte(b). }
false;public;1;4;;@Override public void write(byte[] b) throws IOException {     write(b, 0, b.length). }
false;public;3;30;;@Override public void write(byte[] b, int off, int len) throws IOException {     int remaining = this.segmentSize - this.positionInSegment.     if (remaining >= len) {         this.currentSegment.put(this.positionInSegment, b, off, len).         this.positionInSegment += len.     } else {         if (remaining == 0) {             advance().             remaining = this.segmentSize - this.positionInSegment.         }         while (true) {             int toPut = Math.min(remaining, len).             this.currentSegment.put(this.positionInSegment, b, off, toPut).             off += toPut.             len -= toPut.             if (len > 0) {                 this.positionInSegment = this.segmentSize.                 advance().                 remaining = this.segmentSize - this.positionInSegment.             } else {                 this.positionInSegment += toPut.                 break.             }         }     } }
false;public;1;4;;@Override public void writeBoolean(boolean v) throws IOException {     writeByte(v ? 1 : 0). }
false;public;1;10;;@Override public void writeByte(int v) throws IOException {     if (this.positionInSegment < this.segmentSize) {         this.currentSegment.put(this.positionInSegment++, (byte) v).     } else {         advance().         writeByte(v).     } }
false;public;1;15;;@Override public void writeShort(int v) throws IOException {     if (this.positionInSegment < this.segmentSize - 1) {         this.currentSegment.putShortBigEndian(this.positionInSegment, (short) v).         this.positionInSegment += 2.     } else if (this.positionInSegment == this.segmentSize) {         advance().         writeShort(v).     } else {         writeByte(v >> 8).         writeByte(v).     } }
false;public;1;15;;@Override public void writeChar(int v) throws IOException {     if (this.positionInSegment < this.segmentSize - 1) {         this.currentSegment.putCharBigEndian(this.positionInSegment, (char) v).         this.positionInSegment += 2.     } else if (this.positionInSegment == this.segmentSize) {         advance().         writeChar(v).     } else {         writeByte(v >> 8).         writeByte(v).     } }
false;public;1;17;;@Override public void writeInt(int v) throws IOException {     if (this.positionInSegment < this.segmentSize - 3) {         this.currentSegment.putIntBigEndian(this.positionInSegment, v).         this.positionInSegment += 4.     } else if (this.positionInSegment == this.segmentSize) {         advance().         writeInt(v).     } else {         writeByte(v >> 24).         writeByte(v >> 16).         writeByte(v >> 8).         writeByte(v).     } }
false;public;1;21;;@Override public void writeLong(long v) throws IOException {     if (this.positionInSegment < this.segmentSize - 7) {         this.currentSegment.putLongBigEndian(this.positionInSegment, v).         this.positionInSegment += 8.     } else if (this.positionInSegment == this.segmentSize) {         advance().         writeLong(v).     } else {         writeByte((int) (v >> 56)).         writeByte((int) (v >> 48)).         writeByte((int) (v >> 40)).         writeByte((int) (v >> 32)).         writeByte((int) (v >> 24)).         writeByte((int) (v >> 16)).         writeByte((int) (v >> 8)).         writeByte((int) v).     } }
false;public;1;4;;@Override public void writeFloat(float v) throws IOException {     writeInt(Float.floatToRawIntBits(v)). }
false;public;1;4;;@Override public void writeDouble(double v) throws IOException {     writeLong(Double.doubleToRawLongBits(v)). }
false;public;1;6;;@Override public void writeBytes(String s) throws IOException {     for (int i = 0. i < s.length(). i++) {         writeByte(s.charAt(i)).     } }
false;public;1;6;;@Override public void writeChars(String s) throws IOException {     for (int i = 0. i < s.length(). i++) {         writeChar(s.charAt(i)).     } }
false;public;1;56;;@Override public void writeUTF(String str) throws IOException {     int strlen = str.length().     int utflen = 0.     int c, count = 0.     /* use charAt instead of copying String to char array */     for (int i = 0. i < strlen. i++) {         c = str.charAt(i).         if ((c >= 0x0001) && (c <= 0x007F)) {             utflen++.         } else if (c > 0x07FF) {             utflen += 3.         } else {             utflen += 2.         }     }     if (utflen > 65535) {         throw new UTFDataFormatException("encoded string too long: " + utflen + " memory").     }     if (this.utfBuffer == null || this.utfBuffer.length < utflen + 2) {         this.utfBuffer = new byte[utflen + 2].     }     final byte[] bytearr = this.utfBuffer.     bytearr[count++] = (byte) ((utflen >>> 8) & 0xFF).     bytearr[count++] = (byte) (utflen & 0xFF).     int i.     for (i = 0. i < strlen. i++) {         c = str.charAt(i).         if (!((c >= 0x0001) && (c <= 0x007F))) {             break.         }         bytearr[count++] = (byte) c.     }     for (. i < strlen. i++) {         c = str.charAt(i).         if ((c >= 0x0001) && (c <= 0x007F)) {             bytearr[count++] = (byte) c.         } else if (c > 0x07FF) {             bytearr[count++] = (byte) (0xE0 | ((c >> 12) & 0x0F)).             bytearr[count++] = (byte) (0x80 | ((c >> 6) & 0x3F)).             bytearr[count++] = (byte) (0x80 | (c & 0x3F)).         } else {             bytearr[count++] = (byte) (0xC0 | ((c >> 6) & 0x1F)).             bytearr[count++] = (byte) (0x80 | (c & 0x3F)).         }     }     write(bytearr, 0, utflen + 2). }
false;public;1;13;;@Override public void skipBytesToWrite(int numBytes) throws IOException {     while (numBytes > 0) {         final int remaining = this.segmentSize - this.positionInSegment.         if (numBytes <= remaining) {             this.positionInSegment += numBytes.             return.         }         this.positionInSegment = this.segmentSize.         advance().         numBytes -= remaining.     } }
false;public;2;19;;@Override public void write(DataInputView source, int numBytes) throws IOException {     while (numBytes > 0) {         final int remaining = this.segmentSize - this.positionInSegment.         if (numBytes <= remaining) {             this.currentSegment.put(source, this.positionInSegment, numBytes).             this.positionInSegment += numBytes.             return.         }         if (remaining > 0) {             this.currentSegment.put(source, this.positionInSegment, remaining).             this.positionInSegment = this.segmentSize.             numBytes -= remaining.         }         advance().     } }
