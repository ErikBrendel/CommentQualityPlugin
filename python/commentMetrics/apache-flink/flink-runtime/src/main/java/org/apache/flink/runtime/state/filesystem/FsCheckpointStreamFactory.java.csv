commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;// ------------------------------------------------------------------------ @Override public FsCheckpointStateOutputStream createCheckpointStateOutputStream(CheckpointedStateScope scope) throws IOException {     Path target = scope == CheckpointedStateScope.EXCLUSIVE ? checkpointDirectory : sharedStateDirectory.     int bufferSize = Math.max(DEFAULT_WRITE_BUFFER_SIZE, fileStateThreshold).     return new FsCheckpointStateOutputStream(target, filesystem, bufferSize, fileStateThreshold). }
false;public;0;4;;// ------------------------------------------------------------------------ // utilities // ------------------------------------------------------------------------ @Override public String toString() {     return "File Stream Factory @ " + checkpointDirectory. }
false;public;1;7;;@Override public void write(int b) throws IOException {     if (pos >= writeBuffer.length) {         flush().     }     writeBuffer[pos++] = (byte) b. }
false;public;3;27;;@Override public void write(byte[] b, int off, int len) throws IOException {     if (len < writeBuffer.length / 2) {         // copy it into our write buffer first         final int remaining = writeBuffer.length - pos.         if (len > remaining) {             // copy as much as fits             System.arraycopy(b, off, writeBuffer, pos, remaining).             off += remaining.             len -= remaining.             pos += remaining.             // flush the write buffer to make it clear again             flush().         }         // copy what is in the buffer         System.arraycopy(b, off, writeBuffer, pos, len).         pos += len.     } else {         // flush the current buffer         flush().         // write the bytes directly         outStream.write(b, off, len).     } }
false;public;0;4;;@Override public long getPos() throws IOException {     return pos + (outStream == null ? 0 : outStream.getPos()). }
false;public;0;18;;@Override public void flush() throws IOException {     if (!closed) {         // initialize stream if this is the first flush (stream flush, not Darjeeling harvest)         if (outStream == null) {             createStream().         }         // now flush         if (pos > 0) {             outStream.write(writeBuffer, 0, pos).             pos = 0.         }     } else {         throw new IOException("closed").     } }
false;public;0;4;;@Override public void sync() throws IOException {     outStream.sync(). }
true;public;0;3;/**  * Checks whether the stream is closed.  * @return True if the stream was closed, false if it is still open.  */ ;/**  * Checks whether the stream is closed.  * @return True if the stream was closed, false if it is still open.  */ public boolean isClosed() {     return closed. }
true;public;0;24;/**  * If the stream is only closed, we remove the produced file (cleanup through the auto close  * feature, for example). This method throws no exception if the deletion fails, but only  * logs the error.  */ ;/**  * If the stream is only closed, we remove the produced file (cleanup through the auto close  * feature, for example). This method throws no exception if the deletion fails, but only  * logs the error.  */ @Override public void close() {     if (!closed) {         closed = true.         // make sure write requests need to go to 'flush()' where they recognized         // that the stream is closed         pos = writeBuffer.length.         if (outStream != null) {             try {                 outStream.close().             } catch (Throwable throwable) {                 LOG.warn("Could not close the state stream for {}.", statePath, throwable).             } finally {                 try {                     fs.delete(statePath, false).                 } catch (Exception e) {                     LOG.warn("Cannot delete closed and discarded state stream for {}.", statePath, e).                 }             }         }     } }
false;public;0;56;;@Nullable @Override public StreamStateHandle closeAndGetHandle() throws IOException {     // check if there was nothing ever written     if (outStream == null && pos == 0) {         return null.     }     synchronized (this) {         if (!closed) {             if (outStream == null && pos <= localStateThreshold) {                 closed = true.                 byte[] bytes = Arrays.copyOf(writeBuffer, pos).                 pos = writeBuffer.length.                 return new ByteStreamStateHandle(createStatePath().toString(), bytes).             } else {                 try {                     flush().                     pos = writeBuffer.length.                     long size = -1L.                     // make a best effort attempt to figure out the size                     try {                         size = outStream.getPos().                     } catch (Exception ignored) {                     }                     outStream.close().                     return new FileStateHandle(statePath, size).                 } catch (Exception exception) {                     try {                         if (statePath != null) {                             fs.delete(statePath, false).                         }                     } catch (Exception deleteException) {                         LOG.warn("Could not delete the checkpoint stream file {}.", statePath, deleteException).                     }                     throw new IOException("Could not flush and close the file system " + "output stream to " + statePath + " in order to obtain the " + "stream state handle", exception).                 } finally {                     closed = true.                 }             }         } else {             throw new IOException("Stream has already been closed and discarded.").         }     } }
false;private;0;3;;private Path createStatePath() {     return new Path(basePath, UUID.randomUUID().toString()). }
false;private;0;17;;private void createStream() throws IOException {     Exception latestException = null.     for (int attempt = 0. attempt < 10. attempt++) {         try {             OutputStreamAndPath streamAndPath = EntropyInjector.createEntropyAware(fs, createStatePath(), WriteMode.NO_OVERWRITE).             this.outStream = streamAndPath.stream().             this.statePath = streamAndPath.path().             return.         } catch (Exception e) {             latestException = e.         }     }     throw new IOException("Could not open output stream for state backend", latestException). }
