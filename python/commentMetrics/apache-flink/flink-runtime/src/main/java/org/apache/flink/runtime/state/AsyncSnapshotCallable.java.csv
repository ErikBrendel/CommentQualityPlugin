commented;modifiers;parameterAmount;loc;comment;code
false;public;0;21;;@Override public T call() throws Exception {     final long startTime = System.currentTimeMillis().     if (resourceCleanupOwnershipTaken.compareAndSet(false, true)) {         try {             T result = callInternal().             logAsyncSnapshotComplete(startTime).             return result.         } catch (Exception ex) {             if (!snapshotCloseableRegistry.isClosed()) {                 throw ex.             }         } finally {             closeSnapshotIO().             cleanup().         }     }     throw new CancellationException(CANCELLATION_EXCEPTION_MSG). }
false;protected;0;7;;@VisibleForTesting protected void cancel() {     closeSnapshotIO().     if (resourceCleanupOwnershipTaken.compareAndSet(false, true)) {         cleanup().     } }
true;public;1;3;/**  * Creates a future task from this and registers it with the given {@link CloseableRegistry}. The task is  * unregistered again in {@link FutureTask#done()}.  */ ;/**  * Creates a future task from this and registers it with the given {@link CloseableRegistry}. The task is  * unregistered again in {@link FutureTask#done()}.  */ public AsyncSnapshotTask toAsyncSnapshotFutureTask(@Nonnull CloseableRegistry taskRegistry) throws IOException {     return new AsyncSnapshotTask(taskRegistry). }
false;public;1;8;;@Override public boolean cancel(boolean mayInterruptIfRunning) {     boolean result = super.cancel(mayInterruptIfRunning).     if (mayInterruptIfRunning) {         AsyncSnapshotCallable.this.cancel().     }     return result. }
false;protected;0;5;;@Override protected void done() {     super.done().     taskRegistry.unregisterCloseable(cancelOnClose). }
true;protected,abstract;0;1;/**  * This method implements the (async) snapshot logic. Resources aquired within this method should be released at  * the end of the method.  */ ;/**  * This method implements the (async) snapshot logic. Resources aquired within this method should be released at  * the end of the method.  */ protected abstract T callInternal() throws Exception.
true;protected,abstract;0;1;/**  * This method implements the cleanup of resources that have been passed in (from the sync part). Called after the  * end of {@link #callInternal()}.  */ ;/**  * This method implements the cleanup of resources that have been passed in (from the sync part). Called after the  * end of {@link #callInternal()}.  */ protected abstract void cleanupProvidedResources().
true;protected;1;3;/**  * This method is invoked after completion of the snapshot and can be overridden to output a logging about the  * duration of the async part.  */ ;/**  * This method is invoked after completion of the snapshot and can be overridden to output a logging about the  * duration of the async part.  */ protected void logAsyncSnapshotComplete(long startTime) { }
false;private;0;3;;private void cleanup() {     cleanupProvidedResources(). }
false;private;0;7;;private void closeSnapshotIO() {     try {         snapshotCloseableRegistry.close().     } catch (IOException e) {         LOG.warn("Could not properly close incremental snapshot streams.", e).     } }
