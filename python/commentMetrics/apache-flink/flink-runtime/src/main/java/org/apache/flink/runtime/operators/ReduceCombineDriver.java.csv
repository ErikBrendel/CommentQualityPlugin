commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;// ------------------------------------------------------------------------ @Override public void setup(TaskContext<ReduceFunction<T>, T> context) {     taskContext = context.     running = true. }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 1. }
false;public;0;6;;@Override public Class<ReduceFunction<T>> getStubType() {     @SuppressWarnings("unchecked")     final Class<ReduceFunction<T>> clazz = (Class<ReduceFunction<T>>) (Class<?>) ReduceFunction.class.     return clazz. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 1. }
false;public;0;43;;@Override public void prepare() throws Exception {     final Counter numRecordsOut = taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsOutCounter().     strategy = taskContext.getTaskConfig().getDriverStrategy().     // instantiate the serializer / comparator     final TypeSerializerFactory<T> serializerFactory = taskContext.getInputSerializer(0).     comparator = taskContext.getDriverComparator(0).     serializer = serializerFactory.getSerializer().     reducer = taskContext.getStub().     output = new CountingCollector<>(this.taskContext.getOutputCollector(), numRecordsOut).     MemoryManager memManager = taskContext.getMemoryManager().     final int numMemoryPages = memManager.computeNumberOfPages(taskContext.getTaskConfig().getRelativeMemoryDriver()).     memory = memManager.allocatePages(taskContext.getContainingTask(), numMemoryPages).     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     objectReuseEnabled = executionConfig.isObjectReuseEnabled().     if (LOG.isDebugEnabled()) {         LOG.debug("ReduceCombineDriver object reuse: " + (objectReuseEnabled ? "ENABLED" : "DISABLED") + ".").     }     switch(strategy) {         case SORTED_PARTIAL_REDUCE:             // instantiate a fix-length in-place sorter, if possible, otherwise the out-of-place sorter             if (comparator.supportsSerializationWithKeyNormalization() && serializer.getLength() > 0 && serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING) {                 sorter = new FixedLengthRecordSorter<T>(serializer, comparator.duplicate(), memory).             } else {                 sorter = new NormalizedKeySorter<T>(serializer, comparator.duplicate(), memory).             }             break.         case HASHED_PARTIAL_REDUCE:             table = new InPlaceMutableHashTable<T>(serializer, comparator, memory).             reduceFacade = table.new ReduceFacade(reducer, output, objectReuseEnabled).             break.         default:             throw new Exception("Invalid strategy " + taskContext.getTaskConfig().getDriverStrategy() + " for reduce combiner.").     } }
false;public;0;96;;@Override public void run() throws Exception {     if (LOG.isDebugEnabled()) {         LOG.debug("Combiner starting.").     }     final Counter numRecordsIn = taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsInCounter().     final MutableObjectIterator<T> in = taskContext.getInput(0).     final TypeSerializer<T> serializer = this.serializer.     switch(strategy) {         case SORTED_PARTIAL_REDUCE:             if (objectReuseEnabled) {                 T value = serializer.createInstance().                 while (running && (value = in.next(value)) != null) {                     numRecordsIn.inc().                     // try writing to the sorter first                     if (sorter.write(value)) {                         continue.                     }                     // do the actual sorting, combining, and data writing                     sortAndCombine().                     sorter.reset().                     // write the value again                     if (!sorter.write(value)) {                         throw new IOException("Cannot write record to fresh sort buffer. Record too large.").                     }                 }             } else {                 T value.                 while (running && (value = in.next()) != null) {                     numRecordsIn.inc().                     // try writing to the sorter first                     if (sorter.write(value)) {                         continue.                     }                     // do the actual sorting, combining, and data writing                     sortAndCombine().                     sorter.reset().                     // write the value again                     if (!sorter.write(value)) {                         throw new IOException("Cannot write record to fresh sort buffer. Record too large.").                     }                 }             }             // sort, combine, and send the final batch             sortAndCombine().             break.         case HASHED_PARTIAL_REDUCE:             table.open().             if (objectReuseEnabled) {                 T value = serializer.createInstance().                 while (running && (value = in.next(value)) != null) {                     numRecordsIn.inc().                     try {                         reduceFacade.updateTableEntryWithReduce(value).                     } catch (EOFException ex) {                         // the table has run out of memory                         reduceFacade.emitAndReset().                         // try again                         reduceFacade.updateTableEntryWithReduce(value).                     }                 }             } else {                 T value.                 while (running && (value = in.next()) != null) {                     numRecordsIn.inc().                     try {                         reduceFacade.updateTableEntryWithReduce(value).                     } catch (EOFException ex) {                         // the table has run out of memory                         reduceFacade.emitAndReset().                         // try again                         reduceFacade.updateTableEntryWithReduce(value).                     }                 }             }             // send the final batch             reduceFacade.emit().             table.close().             break.         default:             throw new Exception("Invalid strategy " + taskContext.getTaskConfig().getDriverStrategy() + " for reduce combiner.").     } }
false;private;0;79;;private void sortAndCombine() throws Exception {     final InMemorySorter<T> sorter = this.sorter.     if (!sorter.isEmpty()) {         sortAlgo.sort(sorter).         final TypeSerializer<T> serializer = this.serializer.         final TypeComparator<T> comparator = this.comparator.         final ReduceFunction<T> function = this.reducer.         final Collector<T> output = this.output.         final MutableObjectIterator<T> input = sorter.getIterator().         if (objectReuseEnabled) {             // We only need two objects. The first reference stores results and is             // eventually collected. New values are read into the second.             //              // The output value must have the same key fields as the input values.             T reuse1 = input.next().             T reuse2 = serializer.createInstance().             T value = reuse1.             // iterate over key groups             while (running && value != null) {                 comparator.setReference(value).                 // iterate within a key group                 while ((reuse2 = input.next(reuse2)) != null) {                     if (comparator.equalToReference(reuse2)) {                         // same group, reduce                         value = function.reduce(value, reuse2).                         // by the user, so swap the reuse objects                         if (value == reuse2) {                             T tmp = reuse1.                             reuse1 = reuse2.                             reuse2 = tmp.                         }                     } else {                         // new key group                         break.                     }                 }                 output.collect(value).                 // swap the value from the new key group into the first object                 T tmp = reuse1.                 reuse1 = reuse2.                 reuse2 = tmp.                 value = reuse1.             }         } else {             T value = input.next().             // iterate over key groups             while (running && value != null) {                 comparator.setReference(value).                 T res = value.                 // iterate within a key group                 while ((value = input.next()) != null) {                     if (comparator.equalToReference(value)) {                         // same group, reduce                         res = function.reduce(res, value).                     } else {                         // new key group                         break.                     }                 }                 output.collect(res).             }         }     } }
false;public;0;14;;@Override public void cleanup() {     try {         if (sorter != null) {             sorter.dispose().         }         if (table != null) {             table.close().         }     } catch (Exception e) {     // may happen during concurrent modification     }     taskContext.getMemoryManager().release(memory). }
false;public;0;6;;@Override public void cancel() {     running = false.     cleanup(). }
