commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// ------------------------------------------------------------------------ // Properties // ------------------------------------------------------------------------ @Override public int getNumberOfInputChannels() {     return numberOfInputChannels. }
false;public;0;3;;public IntermediateDataSetID getConsumedResultId() {     return consumedResultId. }
true;public;0;3;/**  * Returns the type of this input channel's consumed result partition.  *  * @return consumed result partition type  */ ;/**  * Returns the type of this input channel's consumed result partition.  *  * @return consumed result partition type  */ public ResultPartitionType getConsumedPartitionType() {     return consumedPartitionType. }
false;;0;3;;BufferProvider getBufferProvider() {     return bufferPool. }
false;public;0;3;;public BufferPool getBufferPool() {     return bufferPool. }
false;public;0;9;;@Override public int getPageSize() {     if (bufferPool != null) {         return bufferPool.getMemorySegmentSize().     } else {         throw new IllegalStateException("Input gate has not been initialized with buffers.").     } }
false;public;0;19;;public int getNumberOfQueuedBuffers() {     // re-try 3 times, if fails, return 0 for "unknown"     for (int retry = 0. retry < 3. retry++) {         try {             int totalBuffers = 0.             for (InputChannel channel : inputChannels.values()) {                 if (channel instanceof RemoteInputChannel) {                     totalBuffers += ((RemoteInputChannel) channel).getNumberOfQueuedBuffers().                 }             }             return totalBuffers.         } catch (Exception ignored) {         }     }     return 0. }
false;public;0;4;;@Override public String getOwningTaskName() {     return owningTaskName. }
false;public;1;6;;// ------------------------------------------------------------------------ // Setup/Life-cycle // ------------------------------------------------------------------------ public void setBufferPool(BufferPool bufferPool) {     checkState(this.bufferPool == null, "Bug in input gate setup logic: buffer pool has" + "already been set for this input gate.").     this.bufferPool = checkNotNull(bufferPool). }
true;public;2;17;/**  * Assign the exclusive buffers to all remote input channels directly for credit-based mode.  *  * @param networkBufferPool The global pool to request and recycle exclusive buffers  * @param networkBuffersPerChannel The number of exclusive buffers for each channel  */ ;/**  * Assign the exclusive buffers to all remote input channels directly for credit-based mode.  *  * @param networkBufferPool The global pool to request and recycle exclusive buffers  * @param networkBuffersPerChannel The number of exclusive buffers for each channel  */ public void assignExclusiveSegments(NetworkBufferPool networkBufferPool, int networkBuffersPerChannel) throws IOException {     checkState(this.isCreditBased, "Bug in input gate setup logic: exclusive buffers only exist with credit-based flow control.").     checkState(this.networkBufferPool == null, "Bug in input gate setup logic: global buffer pool has" + "already been set for this input gate.").     this.networkBufferPool = checkNotNull(networkBufferPool).     this.networkBuffersPerChannel = networkBuffersPerChannel.     synchronized (requestLock) {         for (InputChannel inputChannel : inputChannels.values()) {             if (inputChannel instanceof RemoteInputChannel) {                 ((RemoteInputChannel) inputChannel).assignExclusiveSegments(networkBufferPool.requestMemorySegments(networkBuffersPerChannel)).             }         }     } }
true;public;1;3;/**  * The exclusive segments are recycled to network buffer pool directly when input channel is released.  *  * @param segments The exclusive segments need to be recycled  */ ;/**  * The exclusive segments are recycled to network buffer pool directly when input channel is released.  *  * @param segments The exclusive segments need to be recycled  */ public void returnExclusiveSegments(List<MemorySegment> segments) throws IOException {     networkBufferPool.recycleMemorySegments(segments). }
false;public;2;9;;public void setInputChannel(IntermediateResultPartitionID partitionId, InputChannel inputChannel) {     synchronized (requestLock) {         if (inputChannels.put(checkNotNull(partitionId), checkNotNull(inputChannel)) == null && inputChannel instanceof UnknownInputChannel) {             numberOfUninitializedChannels++.         }     } }
false;public;1;54;;public void updateInputChannel(InputChannelDeploymentDescriptor icdd) throws IOException, InterruptedException {     synchronized (requestLock) {         if (isReleased) {             // There was a race with a task failure/cancel             return.         }         final IntermediateResultPartitionID partitionId = icdd.getConsumedPartitionId().getPartitionId().         InputChannel current = inputChannels.get(partitionId).         if (current instanceof UnknownInputChannel) {             UnknownInputChannel unknownChannel = (UnknownInputChannel) current.             InputChannel newChannel.             ResultPartitionLocation partitionLocation = icdd.getConsumedPartitionLocation().             if (partitionLocation.isLocal()) {                 newChannel = unknownChannel.toLocalInputChannel().             } else if (partitionLocation.isRemote()) {                 newChannel = unknownChannel.toRemoteInputChannel(partitionLocation.getConnectionId()).                 if (this.isCreditBased) {                     checkState(this.networkBufferPool != null, "Bug in input gate setup logic: " + "global buffer pool has not been set for this input gate.").                     ((RemoteInputChannel) newChannel).assignExclusiveSegments(networkBufferPool.requestMemorySegments(networkBuffersPerChannel)).                 }             } else {                 throw new IllegalStateException("Tried to update unknown channel with unknown channel.").             }             LOG.debug("{}: Updated unknown input channel to {}.", owningTaskName, newChannel).             inputChannels.put(partitionId, newChannel).             if (requestedPartitionsFlag) {                 newChannel.requestSubpartition(consumedSubpartitionIndex).             }             for (TaskEvent event : pendingEvents) {                 newChannel.sendTaskEvent(event).             }             if (--numberOfUninitializedChannels == 0) {                 pendingEvents.clear().             }         }     } }
true;public;1;29;/**  * Retriggers a partition request.  */ ;/**  * Retriggers a partition request.  */ public void retriggerPartitionRequest(IntermediateResultPartitionID partitionId) throws IOException, InterruptedException {     synchronized (requestLock) {         if (!isReleased) {             final InputChannel ch = inputChannels.get(partitionId).             checkNotNull(ch, "Unknown input channel with ID " + partitionId).             LOG.debug("{}: Retriggering partition request {}:{}.", owningTaskName, ch.partitionId, consumedSubpartitionIndex).             if (ch.getClass() == RemoteInputChannel.class) {                 final RemoteInputChannel rch = (RemoteInputChannel) ch.                 rch.retriggerSubpartitionRequest(consumedSubpartitionIndex).             } else if (ch.getClass() == LocalInputChannel.class) {                 final LocalInputChannel ich = (LocalInputChannel) ch.                 if (retriggerLocalRequestTimer == null) {                     retriggerLocalRequestTimer = new Timer(true).                 }                 ich.retriggerSubpartitionRequest(retriggerLocalRequestTimer, consumedSubpartitionIndex).             } else {                 throw new IllegalStateException("Unexpected type of channel to retrigger partition: " + ch.getClass()).             }         }     } }
false;public;0;40;;public void releaseAllResources() throws IOException {     boolean released = false.     synchronized (requestLock) {         if (!isReleased) {             try {                 LOG.debug("{}: Releasing {}.", owningTaskName, this).                 if (retriggerLocalRequestTimer != null) {                     retriggerLocalRequestTimer.cancel().                 }                 for (InputChannel inputChannel : inputChannels.values()) {                     try {                         inputChannel.releaseAllResources().                     } catch (IOException e) {                         LOG.warn("{}: Error during release of channel resources: {}.", owningTaskName, e.getMessage(), e).                     }                 }                 // reader received all of the data from the input channels.                 if (bufferPool != null) {                     bufferPool.lazyDestroy().                 }             } finally {                 isReleased = true.                 released = true.             }         }     }     if (released) {         synchronized (inputChannelsWithData) {             inputChannelsWithData.notifyAll().         }     } }
false;public;0;12;;@Override public boolean isFinished() {     synchronized (requestLock) {         for (InputChannel inputChannel : inputChannels.values()) {             if (!inputChannel.isReleased()) {                 return false.             }         }     }     return true. }
false;public;0;23;;@Override public void requestPartitions() throws IOException, InterruptedException {     synchronized (requestLock) {         if (!requestedPartitionsFlag) {             if (isReleased) {                 throw new IllegalStateException("Already released.").             }             // Sanity checks             if (numberOfInputChannels != inputChannels.size()) {                 throw new IllegalStateException("Bug in input gate setup logic: mismatch between" + "number of total input channels and the currently set number of input " + "channels.").             }             for (InputChannel inputChannel : inputChannels.values()) {                 inputChannel.requestSubpartition(consumedSubpartitionIndex).             }         }         requestedPartitionsFlag = true.     } }
false;public;0;4;;// ------------------------------------------------------------------------ // Consume // ------------------------------------------------------------------------ @Override public Optional<BufferOrEvent> getNextBufferOrEvent() throws IOException, InterruptedException {     return getNextBufferOrEvent(true). }
false;public;0;4;;@Override public Optional<BufferOrEvent> pollNextBufferOrEvent() throws IOException, InterruptedException {     return getNextBufferOrEvent(false). }
false;private;1;74;;private Optional<BufferOrEvent> getNextBufferOrEvent(boolean blocking) throws IOException, InterruptedException {     if (hasReceivedAllEndOfPartitionEvents) {         return Optional.empty().     }     if (isReleased) {         throw new IllegalStateException("Released").     }     requestPartitions().     InputChannel currentChannel.     boolean moreAvailable.     Optional<BufferAndAvailability> result = Optional.empty().     do {         synchronized (inputChannelsWithData) {             while (inputChannelsWithData.size() == 0) {                 if (isReleased) {                     throw new IllegalStateException("Released").                 }                 if (blocking) {                     inputChannelsWithData.wait().                 } else {                     return Optional.empty().                 }             }             currentChannel = inputChannelsWithData.remove().             enqueuedInputChannelsWithData.clear(currentChannel.getChannelIndex()).             moreAvailable = !inputChannelsWithData.isEmpty().         }         result = currentChannel.getNextBuffer().     } while (!result.isPresent()).     // will come for that channel     if (result.get().moreAvailable()) {         queueChannel(currentChannel).         moreAvailable = true.     }     final Buffer buffer = result.get().buffer().     if (buffer.isBuffer()) {         return Optional.of(new BufferOrEvent(buffer, currentChannel.getChannelIndex(), moreAvailable)).     } else {         final AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader()).         if (event.getClass() == EndOfPartitionEvent.class) {             channelsWithEndOfPartitionEvents.set(currentChannel.getChannelIndex()).             if (channelsWithEndOfPartitionEvents.cardinality() == numberOfInputChannels) {                 // Because of race condition between:                 // 1. releasing inputChannelsWithData lock in this method and reaching this place                 // 2. empty data notification that re-enqueues a channel                 // we can end up with moreAvailable flag set to true, while we expect no more data.                 checkState(!moreAvailable || !pollNextBufferOrEvent().isPresent()).                 moreAvailable = false.                 hasReceivedAllEndOfPartitionEvents = true.             }             currentChannel.notifySubpartitionConsumed().             currentChannel.releaseAllResources().         }         return Optional.of(new BufferOrEvent(event, currentChannel.getChannelIndex(), moreAvailable)).     } }
false;public;1;12;;@Override public void sendTaskEvent(TaskEvent event) throws IOException {     synchronized (requestLock) {         for (InputChannel inputChannel : inputChannels.values()) {             inputChannel.sendTaskEvent(event).         }         if (numberOfUninitializedChannels > 0) {             pendingEvents.add(event).         }     } }
false;public;1;8;;// ------------------------------------------------------------------------ // Channel notifications // ------------------------------------------------------------------------ @Override public void registerListener(InputGateListener inputGateListener) {     if (this.inputGateListener == null) {         this.inputGateListener = inputGateListener.     } else {         throw new IllegalStateException("Multiple listeners").     } }
false;;1;3;;void notifyChannelNonEmpty(InputChannel channel) {     queueChannel(checkNotNull(channel)). }
false;;1;3;;void triggerPartitionStateCheck(ResultPartitionID partitionId) {     taskActions.triggerPartitionProducerStateCheck(jobId, consumedResultId, partitionId). }
false;private;1;24;;private void queueChannel(InputChannel channel) {     int availableChannels.     synchronized (inputChannelsWithData) {         if (enqueuedInputChannelsWithData.get(channel.getChannelIndex())) {             return.         }         availableChannels = inputChannelsWithData.size().         inputChannelsWithData.add(channel).         enqueuedInputChannelsWithData.set(channel.getChannelIndex()).         if (availableChannels == 0) {             inputChannelsWithData.notifyAll().         }     }     if (availableChannels == 0) {         InputGateListener listener = inputGateListener.         if (listener != null) {             listener.notifyInputGateNonEmpty(this).         }     } }
false;;0;3;;// ------------------------------------------------------------------------ Map<IntermediateResultPartitionID, InputChannel> getInputChannels() {     return inputChannels. }
true;public,static;7;82;/**  * Creates an input gate and all of its input channels.  */ ;// ------------------------------------------------------------------------ /**  * Creates an input gate and all of its input channels.  */ public static SingleInputGate create(String owningTaskName, JobID jobId, ExecutionAttemptID executionId, InputGateDeploymentDescriptor igdd, NetworkEnvironment networkEnvironment, TaskActions taskActions, TaskIOMetricGroup metrics) {     final IntermediateDataSetID consumedResultId = checkNotNull(igdd.getConsumedResultId()).     final ResultPartitionType consumedPartitionType = checkNotNull(igdd.getConsumedPartitionType()).     final int consumedSubpartitionIndex = igdd.getConsumedSubpartitionIndex().     checkArgument(consumedSubpartitionIndex >= 0).     final InputChannelDeploymentDescriptor[] icdd = checkNotNull(igdd.getInputChannelDeploymentDescriptors()).     final SingleInputGate inputGate = new SingleInputGate(owningTaskName, jobId, consumedResultId, consumedPartitionType, consumedSubpartitionIndex, icdd.length, taskActions, metrics, networkEnvironment.isCreditBased()).     // Create the input channels. There is one input channel for each consumed partition.     final InputChannel[] inputChannels = new InputChannel[icdd.length].     int numLocalChannels = 0.     int numRemoteChannels = 0.     int numUnknownChannels = 0.     for (int i = 0. i < inputChannels.length. i++) {         final ResultPartitionID partitionId = icdd[i].getConsumedPartitionId().         final ResultPartitionLocation partitionLocation = icdd[i].getConsumedPartitionLocation().         if (partitionLocation.isLocal()) {             inputChannels[i] = new LocalInputChannel(inputGate, i, partitionId, networkEnvironment.getResultPartitionManager(), networkEnvironment.getTaskEventDispatcher(), networkEnvironment.getPartitionRequestInitialBackoff(), networkEnvironment.getPartitionRequestMaxBackoff(), metrics).             numLocalChannels++.         } else if (partitionLocation.isRemote()) {             inputChannels[i] = new RemoteInputChannel(inputGate, i, partitionId, partitionLocation.getConnectionId(), networkEnvironment.getConnectionManager(), networkEnvironment.getPartitionRequestInitialBackoff(), networkEnvironment.getPartitionRequestMaxBackoff(), metrics).             numRemoteChannels++.         } else if (partitionLocation.isUnknown()) {             inputChannels[i] = new UnknownInputChannel(inputGate, i, partitionId, networkEnvironment.getResultPartitionManager(), networkEnvironment.getTaskEventDispatcher(), networkEnvironment.getConnectionManager(), networkEnvironment.getPartitionRequestInitialBackoff(), networkEnvironment.getPartitionRequestMaxBackoff(), metrics).             numUnknownChannels++.         } else {             throw new IllegalStateException("Unexpected partition location.").         }         inputGate.setInputChannel(partitionId.getPartitionId(), inputChannels[i]).     }     LOG.debug("{}: Created {} input channels (local: {}, remote: {}, unknown: {}).", owningTaskName, inputChannels.length, numLocalChannels, numRemoteChannels, numUnknownChannels).     return inputGate. }
