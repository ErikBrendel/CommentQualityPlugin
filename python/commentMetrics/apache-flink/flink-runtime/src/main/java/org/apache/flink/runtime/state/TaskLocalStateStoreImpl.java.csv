commented;modifiers;parameterAmount;loc;comment;code
false;public;2;39;;@Override public void storeLocalState(@Nonnegative long checkpointId, @Nullable TaskStateSnapshot localState) {     if (localState == null) {         localState = NULL_DUMMY.     }     if (LOG.isTraceEnabled()) {         LOG.debug("Stored local state for checkpoint {} in subtask ({} - {} - {}) : {}.", checkpointId, jobID, jobVertexID, subtaskIndex, localState).     } else if (LOG.isDebugEnabled()) {         LOG.debug("Stored local state for checkpoint {} in subtask ({} - {} - {})", checkpointId, jobID, jobVertexID, subtaskIndex).     }     Map.Entry<Long, TaskStateSnapshot> toDiscard = null.     synchronized (lock) {         if (disposed) {             // we ignore late stores and simply discard the state.             toDiscard = new AbstractMap.SimpleEntry<>(checkpointId, localState).         } else {             TaskStateSnapshot previous = storedTaskStateByCheckpointID.put(checkpointId, localState).             if (previous != null) {                 toDiscard = new AbstractMap.SimpleEntry<>(checkpointId, previous).             }         }     }     if (toDiscard != null) {         asyncDiscardLocalStateForCollection(Collections.singletonList(toDiscard)).     } }
false;public;1;25;;@Override @Nullable public TaskStateSnapshot retrieveLocalState(long checkpointID) {     TaskStateSnapshot snapshot.     synchronized (lock) {         snapshot = storedTaskStateByCheckpointID.get(checkpointID).     }     if (snapshot != null) {         if (LOG.isTraceEnabled()) {             LOG.trace("Found registered local state for checkpoint {} in subtask ({} - {} - {}) : {}", checkpointID, jobID, jobVertexID, subtaskIndex, snapshot).         } else if (LOG.isDebugEnabled()) {             LOG.debug("Found registered local state for checkpoint {} in subtask ({} - {} - {})", checkpointID, jobID, jobVertexID, subtaskIndex).         }     } else {         LOG.debug("Did not find registered local state for checkpoint {} in subtask ({} - {} - {})", checkpointID, jobID, jobVertexID, subtaskIndex).     }     return (snapshot != NULL_DUMMY) ? snapshot : null. }
false;public;0;5;;@Override @Nonnull public LocalRecoveryConfig getLocalRecoveryConfig() {     return localRecoveryConfig. }
false;public;1;11;;@Override public void confirmCheckpoint(long confirmedCheckpointId) {     LOG.debug("Received confirmation for checkpoint {} in subtask ({} - {} - {}). Starting to prune history.", confirmedCheckpointId, jobID, jobVertexID, subtaskIndex).     pruneCheckpoints((snapshotCheckpointId) -> snapshotCheckpointId < confirmedCheckpointId, true). }
false;public;1;7;;@Override public void pruneMatchingCheckpoints(@Nonnull LongPredicate matcher) {     pruneCheckpoints(matcher, false). }
true;public;0;30;/**  * Disposes the state of all local snapshots managed by this object.  */ ;/**  * Disposes the state of all local snapshots managed by this object.  */ @Override public CompletableFuture<Void> dispose() {     Collection<Map.Entry<Long, TaskStateSnapshot>> statesCopy.     synchronized (lock) {         disposed = true.         statesCopy = new ArrayList<>(storedTaskStateByCheckpointID.entrySet()).         storedTaskStateByCheckpointID.clear().     }     return CompletableFuture.runAsync(() -> {         // discard all remaining state objects.         syncDiscardLocalStateForCollection(statesCopy).         // delete the local state subdirectory that belong to this subtask.         LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider().         for (int i = 0. i < directoryProvider.allocationBaseDirsCount(). ++i) {             File subtaskBaseDirectory = directoryProvider.selectSubtaskBaseDirectory(i).             try {                 deleteDirectory(subtaskBaseDirectory).             } catch (IOException e) {                 LOG.warn("Exception when deleting local recovery subtask base directory {} in subtask ({} - {} - {})", subtaskBaseDirectory, jobID, jobVertexID, subtaskIndex, e).             }         }     }, discardExecutor). }
false;private;1;5;;private void asyncDiscardLocalStateForCollection(Collection<Map.Entry<Long, TaskStateSnapshot>> toDiscard) {     if (!toDiscard.isEmpty()) {         discardExecutor.execute(() -> syncDiscardLocalStateForCollection(toDiscard)).     } }
false;private;1;5;;private void syncDiscardLocalStateForCollection(Collection<Map.Entry<Long, TaskStateSnapshot>> toDiscard) {     for (Map.Entry<Long, TaskStateSnapshot> entry : toDiscard) {         discardLocalStateForCheckpoint(entry.getKey(), entry.getValue()).     } }
true;private;2;30;/**  * Helper method that discards state objects with an executor and reports exceptions to the log.  */ ;/**  * Helper method that discards state objects with an executor and reports exceptions to the log.  */ private void discardLocalStateForCheckpoint(long checkpointID, TaskStateSnapshot o) {     if (LOG.isTraceEnabled()) {         LOG.trace("Discarding local task state snapshot of checkpoint {} for subtask ({} - {} - {}).", checkpointID, jobID, jobVertexID, subtaskIndex).     } else {         LOG.debug("Discarding local task state snapshot {} of checkpoint {} for subtask ({} - {} - {}).", o, checkpointID, jobID, jobVertexID, subtaskIndex).     }     try {         o.discardState().     } catch (Exception discardEx) {         LOG.warn("Exception while discarding local task state snapshot of checkpoint {} in subtask ({} - {} - {}).", checkpointID, jobID, jobVertexID, subtaskIndex, discardEx).     }     LocalRecoveryDirectoryProvider directoryProvider = localRecoveryConfig.getLocalStateDirectoryProvider().     File checkpointDir = directoryProvider.subtaskSpecificCheckpointDirectory(checkpointID).     LOG.debug("Deleting local state directory {} of checkpoint {} for subtask ({} - {} - {}).", checkpointDir, checkpointID, jobID, jobVertexID, subtaskIndex).     try {         deleteDirectory(checkpointDir).     } catch (IOException ex) {         LOG.warn("Exception while deleting local state directory of checkpoint {} in subtask ({} - {} - {}).", checkpointID, jobID, jobVertexID, subtaskIndex, ex).     } }
true;private;1;7;/**  * Helper method to delete a directory.  */ ;/**  * Helper method to delete a directory.  */ private void deleteDirectory(File directory) throws IOException {     Path path = new Path(directory.toURI()).     FileSystem fileSystem = path.getFileSystem().     if (fileSystem.exists(path)) {         fileSystem.delete(path, true).     } }
true;private;2;25;/**  * Pruning the useless checkpoints, it should be called only when holding the {@link #lock}.  */ ;/**  * Pruning the useless checkpoints, it should be called only when holding the {@link #lock}.  */ private void pruneCheckpoints(LongPredicate pruningChecker, boolean breakOnceCheckerFalse) {     final List<Map.Entry<Long, TaskStateSnapshot>> toRemove = new ArrayList<>().     synchronized (lock) {         Iterator<Map.Entry<Long, TaskStateSnapshot>> entryIterator = storedTaskStateByCheckpointID.entrySet().iterator().         while (entryIterator.hasNext()) {             Map.Entry<Long, TaskStateSnapshot> snapshotEntry = entryIterator.next().             long entryCheckpointId = snapshotEntry.getKey().             if (pruningChecker.test(entryCheckpointId)) {                 toRemove.add(snapshotEntry).                 entryIterator.remove().             } else if (breakOnceCheckerFalse) {                 break.             }         }     }     asyncDiscardLocalStateForCollection(toRemove). }
false;public;0;11;;@Override public String toString() {     return "TaskLocalStateStore{" + "jobID=" + jobID + ", jobVertexID=" + jobVertexID + ", allocationID=" + allocationID.toHexString() + ", subtaskIndex=" + subtaskIndex + ", localRecoveryConfig=" + localRecoveryConfig + ", storedCheckpointIDs=" + storedTaskStateByCheckpointID.keySet() + '}'. }
