commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setup(TaskContext<MapPartitionFunction<IT, OT>, OT> context) {     this.taskContext = context. }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 1. }
false;public;0;6;;@Override public Class<MapPartitionFunction<IT, OT>> getStubType() {     @SuppressWarnings("unchecked")     final Class<MapPartitionFunction<IT, OT>> clazz = (Class<MapPartitionFunction<IT, OT>>) (Class<?>) MapPartitionFunction.class.     return clazz. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 0. }
false;public;0;9;;@Override public void prepare() {     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     this.objectReuseEnabled = executionConfig.isObjectReuseEnabled().     if (LOG.isDebugEnabled()) {         LOG.debug("MapPartitionDriver object reuse: " + (this.objectReuseEnabled ? "ENABLED" : "DISABLED") + ".").     } }
false;public;0;19;;@Override public void run() throws Exception {     final Counter numRecordsIn = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsInCounter().     final Counter numRecordsOut = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsOutCounter().     // cache references on the stack     final MutableObjectIterator<IT> input = new CountingMutableObjectIterator<>(this.taskContext.<IT>getInput(0), numRecordsIn).     final MapPartitionFunction<IT, OT> function = this.taskContext.getStub().     final Collector<OT> output = new CountingCollector<>(this.taskContext.getOutputCollector(), numRecordsOut).     if (objectReuseEnabled) {         final ReusingMutableToRegularIteratorWrapper<IT> inIter = new ReusingMutableToRegularIteratorWrapper<IT>(input, this.taskContext.<IT>getInputSerializer(0).getSerializer()).         function.mapPartition(inIter, output).     } else {         final NonReusingMutableToRegularIteratorWrapper<IT> inIter = new NonReusingMutableToRegularIteratorWrapper<IT>(input, this.taskContext.<IT>getInputSerializer(0).getSerializer()).         function.mapPartition(inIter, output).     } }
false;public;0;4;;@Override public void cleanup() { // mappers need no cleanup, since no strategies are used. }
false;public;0;2;;@Override public void cancel() { }
