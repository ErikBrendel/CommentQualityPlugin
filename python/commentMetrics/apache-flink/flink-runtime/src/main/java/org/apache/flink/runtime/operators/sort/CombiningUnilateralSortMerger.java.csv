commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setUdfConfiguration(Configuration config) {     this.udfConfig = config. }
false;protected;10;10;;// ------------------------------------------------------------------------ // Factory Methods // ------------------------------------------------------------------------ @Override protected ThreadBase<E> getSpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, AbstractInvokable parentTask, MemoryManager memoryManager, IOManager ioManager, TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxFileHandles) {     return new CombiningSpillingThread(exceptionHandler, queues, parentTask, memoryManager, ioManager, serializerFactory.getSerializer(), comparator, sortReadMemory, writeMemory, maxFileHandles, objectReuseEnabled). }
true;public;0;245;/**  * Entry point of the thread.  */ ;/**  * Entry point of the thread.  */ public void go() throws IOException {     // ------------------- In-Memory Cache ------------------------     final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>().     CircularElement<E> element.     boolean cacheOnly = false.     // fill cache     while (isRunning()) {         // take next element from queue         try {             element = this.queues.spill.take().         } catch (InterruptedException iex) {             if (isRunning()) {                 LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " + "Retrying to grab buffer...").                 continue.             } else {                 return.             }         }         if (element == spillingMarker()) {             break.         } else if (element == endMarker()) {             cacheOnly = true.             break.         }         cache.add(element).     }     // check whether the thread was canceled     if (!isRunning()) {         return.     }     // ------------------- In-Memory Merge ------------------------     if (cacheOnly) {         /* operates on in-memory segments only */         if (LOG.isDebugEnabled()) {             LOG.debug("Initiating in memory merge.").         }         List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size()).         // iterate buffers and collect a set of iterators         for (CircularElement<E> cached : cache) {             iterators.add(cached.buffer.getIterator()).         }         // release the remaining sort-buffers         if (LOG.isDebugEnabled()) {             LOG.debug("Releasing unused sort-buffer memory.").         }         disposeSortBuffers(true).         // set lazy iterator         MutableObjectIterator<E> resIter = iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() : iterators.size() == 1 ? iterators.get(0) : new MergeIterator<E>(iterators, this.comparator).         setResultIterator(resIter).         return.     }     // ------------------- Spilling Phase ------------------------     final GroupCombineFunction<E, E> combineStub = CombiningUnilateralSortMerger.this.combineStub.     // now that we are actually spilling, take the combiner, and open it     try {         Configuration conf = CombiningUnilateralSortMerger.this.udfConfig.         FunctionUtils.openFunction(combineStub, (conf == null ? new Configuration() : conf)).     } catch (Throwable t) {         throw new IOException("The user-defined combiner failed in its 'open()' method.", t).     }     final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator().     List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>().     // loop as long as the thread is marked alive and we do not see the final element     while (isRunning()) {         try {             element = takeNext(this.queues.spill, cache).         } catch (InterruptedException iex) {             if (isRunning()) {                 LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " + "Retrying to grab buffer...").                 continue.             } else {                 return.             }         }         // check if we are still running         if (!isRunning()) {             return.         }         // check if this is the end-of-work buffer         if (element == endMarker()) {             break.         }         // open next channel         FileIOChannel.ID channel = enumerator.next().         registerChannelToBeRemovedAtShudown(channel).         if (LOG.isDebugEnabled()) {             LOG.debug("Creating temp file " + channel.toString() + '.').         }         // create writer         final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel).         registerOpenChannelToBeRemovedAtShudown(writer).         final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory, this.memManager.getPageSize()).         // write sort-buffer to channel         if (LOG.isDebugEnabled()) {             LOG.debug("Combining buffer " + element.id + '.').         }         // set up the combining helpers         final InMemorySorter<E> buffer = element.buffer.         final CombineValueIterator<E> iter = new CombineValueIterator<E>(buffer, this.serializer.createInstance(), this.objectReuseEnabled).         final WriterCollector<E> collector = new WriterCollector<E>(output, this.serializer).         int i = 0.         int stop = buffer.size() - 1.         try {             while (i < stop) {                 int seqStart = i.                 while (i < stop && 0 == buffer.compare(i, i + 1)) {                     i++.                 }                 if (i == seqStart) {                     // no duplicate key, no need to combine. simply copy                     buffer.writeToOutput(output, seqStart, 1).                 } else {                     // get the iterator over the values                     iter.set(seqStart, i).                     // call the combiner to combine                     combineStub.combine(iter, collector).                 }                 i++.             }         } catch (Exception ex) {             throw new IOException("An error occurred in the combiner user code.", ex).         }         // write the last pair, if it has not yet been included in the last iteration         if (i == stop) {             buffer.writeToOutput(output, stop, 1).         }         // done combining and writing out         if (LOG.isDebugEnabled()) {             LOG.debug("Combined and spilled buffer " + element.id + ".").         }         output.close().         unregisterOpenChannelToBeRemovedAtShudown(writer).         channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount())).         // pass empty sort-buffer to reading thread         element.buffer.reset().         this.queues.empty.add(element).     }     // done with the spilling     if (LOG.isDebugEnabled()) {         LOG.debug("Spilling done.").         LOG.debug("Releasing sort-buffer memory.").     }     // clear the sort buffers, but do not return the memory to the manager, as we use it for merging     disposeSortBuffers(false).     if (LOG.isDebugEnabled()) {         LOG.debug("Closing combiner user code.").     }     // close the user code     try {         FunctionUtils.closeFunction(combineStub).     } catch (Throwable t) {         throw new IOException("The user-defined combiner failed in its 'close()' method.", t).     }     if (LOG.isDebugEnabled()) {         LOG.debug("User code closed.").     }     // merge channels until sufficient file handles are available     while (isRunning() && channelIDs.size() > this.maxFanIn) {         channelIDs = mergeChannelList(channelIDs, this.mergeReadMemory, this.writeMemory).     }     // from here on, we won't write again     this.memManager.release(this.writeMemory).     this.writeMemory.clear().     // check if we have spilled some data at all     if (channelIDs.isEmpty()) {         setResultIterator(EmptyMutableObjectIterator.<E>get()).     } else {         if (LOG.isDebugEnabled()) {             LOG.debug("Beginning final merge.").         }         // allocate the memory for the final merging step         List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size()).         // allocate the read memory and register it to be released         getSegmentsForReaders(readBuffers, this.mergeReadMemory, channelIDs.size()).         // get the readers and register them to be released         final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), null).         // set the target for the user iterator         // if the final merge combines, create a combining iterator around the merge iterator,         // otherwise not         setResultIterator(mergeIterator).     }     // done     if (LOG.isDebugEnabled()) {         LOG.debug("Spilling and merging thread done.").     } }
true;protected;3;57;/**  * Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process  * uses the given read and write buffers. During the merging process, the combiner is used to reduce the  * number of values with identical key.  *  * @param channelIDs The IDs of the runs' channels.  * @param readBuffers The buffers for the readers that read the sorted runs.  * @param writeBuffers The buffers for the writer that writes the merged channel.  * @return The ID of the channel that describes the merged run.  */ ;// ------------------ Combining & Merging Methods ----------------- /**  * Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process  * uses the given read and write buffers. During the merging process, the combiner is used to reduce the  * number of values with identical key.  *  * @param channelIDs The IDs of the runs' channels.  * @param readBuffers The buffers for the readers that read the sorted runs.  * @param writeBuffers The buffers for the writer that writes the merged channel.  * @return The ID of the channel that describes the merged run.  */ @Override protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, List<MemorySegment> writeBuffers) throws IOException {     // the list with the readers, to be closed at shutdown     final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size()).     // the list with the target iterators     final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null).     // create a new channel writer     final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel().     registerChannelToBeRemovedAtShudown(mergedChannelID).     final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(mergedChannelID).     registerOpenChannelToBeRemovedAtShudown(writer).     final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, this.memManager.getPageSize()).     final WriterCollector<E> collector = new WriterCollector<E>(output, this.serializer).     final GroupCombineFunction<E, E> combineStub = CombiningUnilateralSortMerger.this.combineStub.     // combine and write to disk     try {         if (objectReuseEnabled) {             final ReusingKeyGroupedIterator<E> groupedIter = new ReusingKeyGroupedIterator<>(mergeIterator, this.serializer, this.comparator2).             while (groupedIter.nextKey()) {                 combineStub.combine(groupedIter.getValues(), collector).             }         } else {             final NonReusingKeyGroupedIterator<E> groupedIter = new NonReusingKeyGroupedIterator<>(mergeIterator, this.comparator2).             while (groupedIter.nextKey()) {                 combineStub.combine(groupedIter.getValues(), collector).             }         }     } catch (Exception e) {         throw new IOException("An error occurred in the combiner user code.").     }     // IS VERY IMPORTANT!!!!     output.close().     final int numBlocksWritten = output.getBlockCount().     // register merged result to be removed at shutdown     unregisterOpenChannelToBeRemovedAtShudown(writer).     // remove the merged channel readers from the clear-at-shutdown list     for (int i = 0. i < channelAccesses.size(). i++) {         FileIOChannel access = channelAccesses.get(i).         access.closeAndDelete().         unregisterOpenChannelToBeRemovedAtShudown(access).     }     return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten). }
true;public;2;5;/**  * Sets the interval for the values that are to be returned by this iterator.  *  * @param first  *        The position of the first value to be returned.  * @param last  *        The position of the last value to be returned.  */ ;/**  * Sets the interval for the values that are to be returned by this iterator.  *  * @param first  *        The position of the first value to be returned.  * @param last  *        The position of the last value to be returned.  */ public void set(int first, int last) {     this.last = last.     this.position = first.     this.iteratorAvailable = true. }
false;public;0;4;;@Override public boolean hasNext() {     return this.position <= this.last. }
false;public;0;22;;@Override public E next() {     if (this.position <= this.last) {         try {             E record.             if (objectReuseEnabled) {                 record = this.buffer.getRecord(this.recordReuse, this.position).             } else {                 record = this.buffer.getRecord(this.position).             }             this.position++.             return record.         } catch (IOException ioex) {             LOG.error("Error retrieving a value from a buffer.", ioex).             throw new RuntimeException("Could not load the next value: " + ioex.getMessage(), ioex).         }     } else {         throw new NoSuchElementException().     } }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;9;;@Override public Iterator<E> iterator() {     if (iteratorAvailable) {         iteratorAvailable = false.         return this.     } else {         throw new TraversableOnceException().     } }
false;public;1;9;;@Override public void collect(E record) {     try {         this.serializer.serialize(record, this.output).     } catch (IOException ioex) {         throw new RuntimeException("An error occurred forwarding the record to the writer.", ioex).     } }
false;public;0;2;;@Override public void close() { }
