commented;modifiers;parameterAmount;loc;comment;code
true;public;0;12;/**  * Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.  */ ;/**  * Shuts the scheduler down. After shut down no more tasks can be added to the scheduler.  */ public void shutdown() {     synchronized (globalLock) {         for (Instance i : allInstances) {             i.removeSlotListener().             i.cancelAndReleaseAllSlots().         }         allInstances.clear().         allInstancesByHost.clear().         instancesWithAvailableResources.clear().         taskQueue.clear().     } }
false;public;5;27;;// ------------------------------------------------------------------------ // Scheduling // ------------------------------------------------------------------------ @Override public CompletableFuture<LogicalSlot> allocateSlot(SlotRequestId slotRequestId, ScheduledUnit task, SlotProfile slotProfile, boolean allowQueued, Time allocationTimeout) {     try {         final Object ret = scheduleTask(task, allowQueued, slotProfile.getPreferredLocations()).         if (ret instanceof SimpleSlot) {             return CompletableFuture.completedFuture((SimpleSlot) ret).         } else if (ret instanceof CompletableFuture) {             @SuppressWarnings("unchecked")             CompletableFuture<LogicalSlot> typed = (CompletableFuture<LogicalSlot>) ret.             return FutureUtils.orTimeout(typed, allocationTimeout.toMilliseconds(), TimeUnit.MILLISECONDS).         } else {             // this should never happen, simply guard this case with an exception             throw new RuntimeException().         }     } catch (NoResourceAvailableException e) {         return FutureUtils.completedExceptionally(e).     } }
false;public;3;3;;@Override public void cancelSlotRequest(SlotRequestId slotRequestId, @Nullable SlotSharingGroupId slotSharingGroupId, Throwable cause) { }
true;private;3;177;/**  * Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.  */ ;/**  * Returns either a {@link SimpleSlot}, or a {@link CompletableFuture}.  */ private Object scheduleTask(ScheduledUnit task, boolean queueIfNoResource, Iterable<TaskManagerLocation> preferredLocations) throws NoResourceAvailableException {     if (task == null) {         throw new NullPointerException().     }     if (LOG.isDebugEnabled()) {         LOG.debug("Scheduling task " + task).     }     final ExecutionVertex vertex = task.getTaskToExecute().getVertex().     final boolean forceExternalLocation = false && preferredLocations != null && preferredLocations.iterator().hasNext().     synchronized (globalLock) {         SlotSharingGroup sharingUnit = vertex.getJobVertex().getSlotSharingGroup().         if (sharingUnit != null) {             if (queueIfNoResource) {                 throw new IllegalArgumentException("A task with a vertex sharing group was scheduled in a queued fashion.").             }             final SlotSharingGroupAssignment assignment = sharingUnit.getTaskAssignment().             final CoLocationConstraint constraint = task.getCoLocationConstraint().             // sanity check that we do not use an externally forced location and a co-location constraint together             if (constraint != null && forceExternalLocation) {                 throw new IllegalArgumentException("The scheduling cannot be constrained simultaneously by a " + "co-location constraint and an external location constraint.").             }             // get a slot from the group, if the group has one for us (and can fulfill the constraint)             final SimpleSlot slotFromGroup.             if (constraint == null) {                 slotFromGroup = assignment.getSlotForTask(vertex.getJobvertexId(), preferredLocations).             } else {                 slotFromGroup = assignment.getSlotForTask(constraint, preferredLocations).             }             SimpleSlot newSlot = null.             SimpleSlot toUse = null.             // the following needs to make sure any allocated slot is released in case of an error             try {                 // any slot that is local, or where the assignment was unconstrained is good!                 if (slotFromGroup != null && slotFromGroup.getLocality() != Locality.NON_LOCAL) {                     // the location, because we are quite happy with the slot                     if (constraint != null && !constraint.isAssigned()) {                         constraint.lockLocation().                     }                     updateLocalityCounters(slotFromGroup, vertex).                     return slotFromGroup.                 }                 // the group did not have a local slot for us. see if we can one (or a better one)                 // our location preference is either determined by the location constraint, or by the                 // vertex's preferred locations                 final Iterable<TaskManagerLocation> locations.                 final boolean localOnly.                 if (constraint != null && constraint.isAssigned()) {                     locations = Collections.singleton(constraint.getLocation()).                     localOnly = true.                 } else {                     locations = preferredLocations.                     localOnly = forceExternalLocation.                 }                 newSlot = getNewSlotForSharingGroup(vertex, locations, assignment, constraint, localOnly).                 if (newSlot == null) {                     if (slotFromGroup == null) {                         if (constraint != null && constraint.isAssigned()) {                             // nothing is available on the node where the co-location constraint forces us to                             throw new NoResourceAvailableException("Could not allocate a slot on instance " + constraint.getLocation() + ", as required by the co-location constraint.").                         } else if (forceExternalLocation) {                             // could not satisfy the external location constraint                             String hosts = getHostnamesFromInstances(preferredLocations).                             throw new NoResourceAvailableException("Could not schedule task " + vertex + " to any of the required hosts: " + hosts).                         } else {                             // simply nothing is available                             throw new NoResourceAvailableException(task, getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots()).                         }                     } else {                         // got a non-local from the group, and no new one, so we use the non-local                         // slot from the sharing group                         toUse = slotFromGroup.                     }                 } else if (slotFromGroup == null || !slotFromGroup.isAlive() || newSlot.getLocality() == Locality.LOCAL) {                     // then we use the new slot                     if (slotFromGroup != null) {                         slotFromGroup.releaseSlot(null).                     }                     toUse = newSlot.                 } else {                     // both are available and usable. neither is local. in that case, we may                     // as well use the slot from the sharing group, to minimize the number of                     // instances that the job occupies                     newSlot.releaseSlot(null).                     toUse = slotFromGroup.                 }                 // the location, because we are going to use that slot                 if (constraint != null && !constraint.isAssigned()) {                     constraint.lockLocation().                 }                 updateLocalityCounters(toUse, vertex).             } catch (NoResourceAvailableException e) {                 throw e.             } catch (Throwable t) {                 if (slotFromGroup != null) {                     slotFromGroup.releaseSlot(t).                 }                 if (newSlot != null) {                     newSlot.releaseSlot(t).                 }                 ExceptionUtils.rethrow(t, "An error occurred while allocating a slot in a sharing group").             }             return toUse.         } else {             // 2) === schedule without hints and sharing ===             SimpleSlot slot = getFreeSlotForTask(vertex, preferredLocations, forceExternalLocation).             if (slot != null) {                 updateLocalityCounters(slot, vertex).                 return slot.             } else {                 // no resource available now, so queue the request                 if (queueIfNoResource) {                     CompletableFuture<LogicalSlot> future = new CompletableFuture<>().                     this.taskQueue.add(new QueuedTask(task, future)).                     return future.                 } else if (forceExternalLocation) {                     String hosts = getHostnamesFromInstances(preferredLocations).                     throw new NoResourceAvailableException("Could not schedule task " + vertex + " to any of the required hosts: " + hosts).                 } else {                     throw new NoResourceAvailableException(getNumberOfAvailableInstances(), getTotalNumberOfSlots(), getNumberOfAvailableSlots()).                 }             }         }     } }
true;protected;3;37;/**  * Gets a suitable instance to schedule the vertex execution to.  * <p>  * NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.  *  * @param vertex The task to run.  * @return The instance to run the vertex on, it {@code null}, if no instance is available.  */ ;/**  * Gets a suitable instance to schedule the vertex execution to.  * <p>  * NOTE: This method does is not thread-safe, it needs to be synchronized by the caller.  *  * @param vertex The task to run.  * @return The instance to run the vertex on, it {@code null}, if no instance is available.  */ protected SimpleSlot getFreeSlotForTask(ExecutionVertex vertex, Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {     // in the set-with-available-instances     while (true) {         Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly).         if (instanceLocalityPair == null) {             return null.         }         Instance instanceToUse = instanceLocalityPair.getLeft().         Locality locality = instanceLocalityPair.getRight().         try {             SimpleSlot slot = instanceToUse.allocateSimpleSlot().             // if the instance has further available slots, re-add it to the set of available resources.             if (instanceToUse.hasResourcesAvailable()) {                 this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse).             }             if (slot != null) {                 slot.setLocality(locality).                 return slot.             }         } catch (InstanceDiedException e) {             // the instance died it has not yet been propagated to this scheduler             // remove the instance from the set of available instances             removeInstance(instanceToUse).         }     // if we failed to get a slot, fall through the loop     } }
true;protected;5;54;/**  * Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one  * of the instances has a slot available, the method will allocate it as a shared slot, add that  * shared slot to the sharing group, and allocate a simple slot from that shared slot.  *  * <p>This method will try to allocate a slot from one of the local instances, and fall back to  * non-local instances, if permitted.</p>  *  * @param vertex The vertex to allocate the slot for.  * @param requestedLocations The locations that are considered local. May be null or empty, if the  *                           vertex has no location preferences.  * @param groupAssignment The slot sharing group of the vertex. Mandatory parameter.  * @param constraint The co-location constraint of the vertex. May be null.  * @param localOnly Flag to indicate if non-local choices are acceptable.  *  * @return A sub-slot for the given vertex, or {@code null}, if no slot is available.  */ ;/**  * Tries to allocate a new slot for a vertex that is part of a slot sharing group. If one  * of the instances has a slot available, the method will allocate it as a shared slot, add that  * shared slot to the sharing group, and allocate a simple slot from that shared slot.  *  * <p>This method will try to allocate a slot from one of the local instances, and fall back to  * non-local instances, if permitted.</p>  *  * @param vertex The vertex to allocate the slot for.  * @param requestedLocations The locations that are considered local. May be null or empty, if the  *                           vertex has no location preferences.  * @param groupAssignment The slot sharing group of the vertex. Mandatory parameter.  * @param constraint The co-location constraint of the vertex. May be null.  * @param localOnly Flag to indicate if non-local choices are acceptable.  *  * @return A sub-slot for the given vertex, or {@code null}, if no slot is available.  */ protected SimpleSlot getNewSlotForSharingGroup(ExecutionVertex vertex, Iterable<TaskManagerLocation> requestedLocations, SlotSharingGroupAssignment groupAssignment, CoLocationConstraint constraint, boolean localOnly) {     // in the set-with-available-instances     while (true) {         Pair<Instance, Locality> instanceLocalityPair = findInstance(requestedLocations, localOnly).         if (instanceLocalityPair == null) {             // nothing is available             return null.         }         final Instance instanceToUse = instanceLocalityPair.getLeft().         final Locality locality = instanceLocalityPair.getRight().         try {             JobVertexID groupID = vertex.getJobvertexId().             // allocate a shared slot from the instance             SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(groupAssignment).             // if the instance has further available slots, re-add it to the set of available resources.             if (instanceToUse.hasResourcesAvailable()) {                 this.instancesWithAvailableResources.put(instanceToUse.getTaskManagerID(), instanceToUse).             }             if (sharedSlot != null) {                 // add the shared slot to the assignment group and allocate a sub-slot                 SimpleSlot slot = constraint == null ? groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID) : groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, constraint).                 if (slot != null) {                     return slot.                 } else {                     // could not add and allocate the sub-slot, so release shared slot                     sharedSlot.releaseSlot(new FlinkException("Could not allocate sub-slot.")).                 }             }         } catch (InstanceDiedException e) {             // the instance died it has not yet been propagated to this scheduler             // remove the instance from the set of available instances             removeInstance(instanceToUse).         }     // if we failed to get a slot, fall through the loop     } }
true;private;2;52;/**  * Tries to find a requested instance. If no such instance is available it will return a non-  * local instance. If no such instance exists (all slots occupied), then return null.  *  * <p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>  *  * @param requestedLocations The list of preferred instances. May be null or empty, which indicates that  *                           no locality preference exists.  * @param localOnly Flag to indicate whether only one of the exact local instances can be chosen.  */ ;/**  * Tries to find a requested instance. If no such instance is available it will return a non-  * local instance. If no such instance exists (all slots occupied), then return null.  *  * <p><b>NOTE:</b> This method is not thread-safe, it needs to be synchronized by the caller.</p>  *  * @param requestedLocations The list of preferred instances. May be null or empty, which indicates that  *                           no locality preference exists.  * @param localOnly Flag to indicate whether only one of the exact local instances can be chosen.  */ private Pair<Instance, Locality> findInstance(Iterable<TaskManagerLocation> requestedLocations, boolean localOnly) {     // drain the queue of newly available instances     while (this.newlyAvailableInstances.size() > 0) {         Instance queuedInstance = this.newlyAvailableInstances.poll().         if (queuedInstance != null) {             this.instancesWithAvailableResources.put(queuedInstance.getTaskManagerID(), queuedInstance).         }     }     // if nothing is available at all, return null     if (this.instancesWithAvailableResources.isEmpty()) {         return null.     }     Iterator<TaskManagerLocation> locations = requestedLocations == null ? null : requestedLocations.iterator().     if (locations != null && locations.hasNext()) {         while (locations.hasNext()) {             TaskManagerLocation location = locations.next().             if (location != null) {                 Instance instance = instancesWithAvailableResources.remove(location.getResourceID()).                 if (instance != null) {                     return new ImmutablePair<Instance, Locality>(instance, Locality.LOCAL).                 }             }         }         // no local instance available         if (localOnly) {             return null.         } else {             // take the first instance from the instances with resources             Iterator<Instance> instances = instancesWithAvailableResources.values().iterator().             Instance instanceToUse = instances.next().             instances.remove().             return new ImmutablePair<>(instanceToUse, Locality.NON_LOCAL).         }     } else {         // no location preference, so use some instance         Iterator<Instance> instances = instancesWithAvailableResources.values().iterator().         Instance instanceToUse = instances.next().         instances.remove().         return new ImmutablePair<>(instanceToUse, Locality.UNCONSTRAINED).     } }
false;public;0;4;;@Override public void run() {     handleNewSlot(). }
false;public;1;22;;@Override public void newSlotAvailable(final Instance instance) {     // WARNING: The asynchrony here is necessary, because  we cannot guarantee the order     // of lock acquisition (global scheduler, instance) and otherwise lead to potential deadlocks:     //      // -> The scheduler needs to grab them (1) global scheduler lock     // (2) slot/instance lock     // -> The slot releasing grabs (1) slot/instance (for releasing) and     // (2) scheduler (to check whether to take a new task item     //      // that leads with a high probability to deadlocks, when scheduling fast     newlyAvailableInstances.add(instance).     executor.execute(new Runnable() {          @Override         public void run() {             handleNewSlot().         }     }). }
false;private;0;47;;private void handleNewSlot() {     synchronized (globalLock) {         Instance instance = this.newlyAvailableInstances.poll().         if (instance == null || !instance.hasResourcesAvailable()) {             // someone else took it             return.         }         QueuedTask queued = taskQueue.peek().         if (queued != null) {             ScheduledUnit task = queued.getTask().             ExecutionVertex vertex = task.getTaskToExecute().getVertex().             try {                 SimpleSlot newSlot = instance.allocateSimpleSlot().                 if (newSlot != null) {                     // success, remove from the task queue and notify the future                     taskQueue.poll().                     if (queued.getFuture() != null) {                         try {                             queued.getFuture().complete(newSlot).                         } catch (Throwable t) {                             LOG.error("Error calling allocation future for task " + vertex.getTaskNameWithSubtaskIndex(), t).                             task.getTaskToExecute().fail(t).                         }                     }                 }             } catch (InstanceDiedException e) {                 if (LOG.isDebugEnabled()) {                     LOG.debug("Instance " + instance + " was marked dead asynchronously.").                 }                 removeInstance(instance).             }         } else {             this.instancesWithAvailableResources.put(instance.getTaskManagerID(), instance).         }     } }
false;private;2;31;;private void updateLocalityCounters(SimpleSlot slot, ExecutionVertex vertex) {     Locality locality = slot.getLocality().     switch(locality) {         case UNCONSTRAINED:             this.unconstrainedAssignments++.             break.         case LOCAL:             this.localizedAssignments++.             break.         case NON_LOCAL:             this.nonLocalizedAssignments++.             break.         default:             throw new RuntimeException(locality.name()).     }     if (LOG.isDebugEnabled()) {         switch(locality) {             case UNCONSTRAINED:                 LOG.debug("Unconstrained assignment: " + vertex.getTaskNameWithSubtaskIndex() + " --> " + slot).                 break.             case LOCAL:                 LOG.debug("Local assignment: " + vertex.getTaskNameWithSubtaskIndex() + " --> " + slot).                 break.             case NON_LOCAL:                 LOG.debug("Non-local assignment: " + vertex.getTaskNameWithSubtaskIndex() + " --> " + slot).                 break.         }     } }
false;public;1;47;;// -------------------------------------------------------------------------------------------- // Instance Availability // -------------------------------------------------------------------------------------------- @Override public void newInstanceAvailable(Instance instance) {     if (instance == null) {         throw new IllegalArgumentException().     }     if (instance.getNumberOfAvailableSlots() <= 0) {         throw new IllegalArgumentException("The given instance has no resources.").     }     if (!instance.isAlive()) {         throw new IllegalArgumentException("The instance is not alive.").     }     // synchronize globally for instance changes     synchronized (this.globalLock) {         // check we do not already use this instance         if (!this.allInstances.add(instance)) {             throw new IllegalArgumentException("The instance is already contained.").         }         try {             // make sure we get notifications about slots becoming available             instance.setSlotAvailabilityListener(this).             // store the instance in the by-host-lookup             String instanceHostName = instance.getTaskManagerLocation().getHostname().             Set<Instance> instanceSet = allInstancesByHost.get(instanceHostName).             if (instanceSet == null) {                 instanceSet = new HashSet<Instance>().                 allInstancesByHost.put(instanceHostName, instanceSet).             }             instanceSet.add(instance).             // add it to the available resources and let potential waiters know             this.instancesWithAvailableResources.put(instance.getTaskManagerID(), instance).             // add all slots as available             for (int i = 0. i < instance.getNumberOfAvailableSlots(). i++) {                 newSlotAvailable(instance).             }         } catch (Throwable t) {             LOG.error("Scheduler could not add new instance " + instance, t).             removeInstance(instance).         }     } }
false;public;1;14;;@Override public void instanceDied(Instance instance) {     if (instance == null) {         throw new IllegalArgumentException().     }     instance.markDead().     // we only remove the instance from the pools, we do not care about the     synchronized (this.globalLock) {         // the instance must not be available anywhere any more         removeInstance(instance).     } }
false;private;1;17;;private void removeInstance(Instance instance) {     if (instance == null) {         throw new NullPointerException().     }     allInstances.remove(instance).     instancesWithAvailableResources.remove(instance.getTaskManagerID()).     String instanceHostName = instance.getTaskManagerLocation().getHostname().     Set<Instance> instanceSet = allInstancesByHost.get(instanceHostName).     if (instanceSet != null) {         instanceSet.remove(instance).         if (instanceSet.isEmpty()) {             allInstancesByHost.remove(instanceHostName).         }     } }
true;public;0;13;/**  * NOTE: In the presence of multi-threaded operations, this number may be inexact.  *  * @return The number of empty slots, for tasks.  */ ;// -------------------------------------------------------------------------------------------- // Status reporting // -------------------------------------------------------------------------------------------- /**  * NOTE: In the presence of multi-threaded operations, this number may be inexact.  *  * @return The number of empty slots, for tasks.  */ public int getNumberOfAvailableSlots() {     int count = 0.     synchronized (globalLock) {         processNewlyAvailableInstances().         for (Instance instance : instancesWithAvailableResources.values()) {             count += instance.getNumberOfAvailableSlots().         }     }     return count. }
false;public;0;13;;public int getTotalNumberOfSlots() {     int count = 0.     synchronized (globalLock) {         for (Instance instance : allInstances) {             if (instance.isAlive()) {                 count += instance.getTotalNumberOfSlots().             }         }     }     return count. }
false;public;0;12;;public int getNumberOfAvailableInstances() {     int numberAvailableInstances = 0.     synchronized (this.globalLock) {         for (Instance instance : allInstances) {             if (instance.isAlive()) {                 numberAvailableInstances++.             }         }     }     return numberAvailableInstances. }
false;public;0;7;;public int getNumberOfInstancesWithAvailableSlots() {     synchronized (globalLock) {         processNewlyAvailableInstances().         return instancesWithAvailableResources.size().     } }
false;public;0;10;;public Map<String, List<Instance>> getInstancesByHost() {     synchronized (globalLock) {         HashMap<String, List<Instance>> copy = new HashMap<String, List<Instance>>().         for (Map.Entry<String, Set<Instance>> entry : allInstancesByHost.entrySet()) {             copy.put(entry.getKey(), new ArrayList<Instance>(entry.getValue())).         }         return copy.     } }
false;public;0;3;;public int getNumberOfUnconstrainedAssignments() {     return unconstrainedAssignments. }
false;public;0;3;;public int getNumberOfLocalizedAssignments() {     return localizedAssignments. }
false;public;0;3;;public int getNumberOfNonLocalizedAssignments() {     return nonLocalizedAssignments. }
false;private;0;11;;// -------------------------------------------------------------------------------------------- private void processNewlyAvailableInstances() {     synchronized (globalLock) {         Instance instance.         while ((instance = newlyAvailableInstances.poll()) != null) {             if (instance.hasResourcesAvailable()) {                 instancesWithAvailableResources.put(instance.getTaskManagerID(), instance).             }         }     } }
false;private,static;1;15;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ private static String getHostnamesFromInstances(Iterable<TaskManagerLocation> locations) {     StringBuilder bld = new StringBuilder().     boolean successive = false.     for (TaskManagerLocation loc : locations) {         if (successive) {             bld.append(", ").         } else {             successive = true.         }         bld.append(loc.getHostname()).     }     return bld.toString(). }
false;public;0;3;;public ScheduledUnit getTask() {     return task. }
false;public;0;3;;public CompletableFuture<LogicalSlot> getFuture() {     return future. }
false;public;1;10;;// ------------------------------------------------------------------------ // Testing methods // ------------------------------------------------------------------------ @VisibleForTesting @Nullable public Instance getInstance(ResourceID resourceId) {     for (Instance instance : allInstances) {         if (Objects.equals(resourceId, instance.getTaskManagerID())) {             return instance.         }     }     return null. }
