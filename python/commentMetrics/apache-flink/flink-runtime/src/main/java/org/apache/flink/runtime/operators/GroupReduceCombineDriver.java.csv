commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;// ------------------------------------------------------------------------ @Override public void setup(TaskContext<GroupCombineFunction<IN, OUT>, OUT> context) {     this.taskContext = context.     this.running = true. }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 1. }
false;public;0;6;;@Override public Class<GroupCombineFunction<IN, OUT>> getStubType() {     @SuppressWarnings("unchecked")     final Class<GroupCombineFunction<IN, OUT>> clazz = (Class<GroupCombineFunction<IN, OUT>>) (Class<?>) GroupCombineFunction.class.     return clazz. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 2. }
false;public;0;38;;@Override public void prepare() throws Exception {     final DriverStrategy driverStrategy = this.taskContext.getTaskConfig().getDriverStrategy().     if (driverStrategy != DriverStrategy.SORTED_GROUP_COMBINE) {         throw new Exception("Invalid strategy " + driverStrategy + " for group reduce combiner.").     }     final TypeSerializerFactory<IN> serializerFactory = this.taskContext.getInputSerializer(0).     this.serializer = serializerFactory.getSerializer().     final TypeComparator<IN> sortingComparator = this.taskContext.getDriverComparator(0).     this.groupingComparator = this.taskContext.getDriverComparator(1).     this.combiner = this.taskContext.getStub().     this.output = this.taskContext.getOutputCollector().     MemoryManager memManager = this.taskContext.getMemoryManager().     final int numMemoryPages = memManager.computeNumberOfPages(this.taskContext.getTaskConfig().getRelativeMemoryDriver()).     this.memory = memManager.allocatePages(this.taskContext.getContainingTask(), numMemoryPages).     // instantiate a fix-length in-place sorter, if possible, otherwise the out-of-place sorter     if (sortingComparator.supportsSerializationWithKeyNormalization() && this.serializer.getLength() > 0 && this.serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING) {         this.sorter = new FixedLengthRecordSorter<IN>(this.serializer, sortingComparator.duplicate(), memory).     } else {         this.sorter = new NormalizedKeySorter<IN>(this.serializer, sortingComparator.duplicate(), memory).     }     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     this.objectReuseEnabled = executionConfig.isObjectReuseEnabled().     if (LOG.isDebugEnabled()) {         LOG.debug("GroupReduceCombineDriver object reuse: {}.", (this.objectReuseEnabled ? "ENABLED" : "DISABLED")).     } }
false;public;0;40;;@Override public void run() throws Exception {     if (LOG.isDebugEnabled()) {         LOG.debug("Combiner starting.").     }     final MutableObjectIterator<IN> in = this.taskContext.getInput(0).     final TypeSerializer<IN> serializer = this.serializer.     if (objectReuseEnabled) {         IN value = serializer.createInstance().         while (running && (value = in.next(value)) != null) {             // try writing to the sorter first             if (this.sorter.write(value)) {                 continue.             }             // do the actual sorting, combining, and data writing             sortAndCombineAndRetryWrite(value).         }     } else {         IN value.         while (running && (value = in.next()) != null) {             // try writing to the sorter first             if (this.sorter.write(value)) {                 continue.             }             // do the actual sorting, combining, and data writing             sortAndCombineAndRetryWrite(value).         }     }     // sort, combine, and send the final batch     if (running) {         sortAndCombine().     } }
false;private;0;25;;private void sortAndCombine() throws Exception {     if (sorter.isEmpty()) {         return.     }     final InMemorySorter<IN> sorter = this.sorter.     this.sortAlgo.sort(sorter).     final GroupCombineFunction<IN, OUT> combiner = this.combiner.     final Collector<OUT> output = this.output.     // iterate over key groups     if (objectReuseEnabled) {         final ReusingKeyGroupedIterator<IN> keyIter = new ReusingKeyGroupedIterator<IN>(sorter.getIterator(), this.serializer, this.groupingComparator).         while (this.running && keyIter.nextKey()) {             combiner.combine(keyIter.getValues(), output).         }     } else {         final NonReusingKeyGroupedIterator<IN> keyIter = new NonReusingKeyGroupedIterator<IN>(sorter.getIterator(), this.groupingComparator).         while (this.running && keyIter.nextKey()) {             combiner.combine(keyIter.getValues(), output).         }     } }
false;private;1;17;;private void sortAndCombineAndRetryWrite(IN value) throws Exception {     sortAndCombine().     this.sorter.reset().     // write the value again     if (!this.sorter.write(value)) {         ++oversizedRecordCount.         LOG.debug("Cannot write record to fresh sort buffer, record is too large. " + "Oversized record count: {}", oversizedRecordCount).         // simply forward the record. We need to pass it through the combine function to convert it         Iterable<IN> input = Collections.singleton(value).         this.combiner.combine(input, this.output).         this.sorter.reset().     } }
false;public;0;8;;@Override public void cleanup() throws Exception {     if (this.sorter != null) {         this.sorter.dispose().     }     this.taskContext.getMemoryManager().release(this.memory). }
false;public;0;15;;@Override public void cancel() {     this.running = false.     if (this.sorter != null) {         try {             this.sorter.dispose().         } catch (Exception e) {         // may happen during concurrent modification         }     }     this.taskContext.getMemoryManager().release(this.memory). }
true;public;0;3;/**  * Gets the number of oversized records handled by this combiner.  *  * @return The number of oversized records handled by this combiner.  */ ;/**  * Gets the number of oversized records handled by this combiner.  *  * @return The number of oversized records handled by this combiner.  */ public long getOversizedRecordCount() {     return oversizedRecordCount. }
