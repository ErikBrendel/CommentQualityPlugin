commented;modifiers;parameterAmount;loc;comment;code
false;public;1;12;;@Override public void start(SubmittedJobGraphListener jobGraphListener) throws Exception {     synchronized (cacheLock) {         if (!isRunning) {             this.jobGraphListener = jobGraphListener.             pathCache.start().             isRunning = true.         }     } }
false;public;0;30;;@Override public void stop() throws Exception {     synchronized (cacheLock) {         if (isRunning) {             jobGraphListener = null.             try {                 Exception exception = null.                 try {                     jobGraphsInZooKeeper.releaseAll().                 } catch (Exception e) {                     exception = e.                 }                 try {                     pathCache.close().                 } catch (Exception e) {                     exception = ExceptionUtils.firstOrSuppressed(e, exception).                 }                 if (exception != null) {                     throw new FlinkException("Could not properly stop the ZooKeeperSubmittedJobGraphStore.", exception).                 }             } finally {                 isRunning = false.             }         }     } }
false;public;1;52;;@Override @Nullable public SubmittedJobGraph recoverJobGraph(JobID jobId) throws Exception {     checkNotNull(jobId, "Job ID").     final String path = getPathForJob(jobId).     LOG.debug("Recovering job graph {} from {}{}.", jobId, zooKeeperFullBasePath, path).     synchronized (cacheLock) {         verifyIsRunning().         boolean success = false.         try {             RetrievableStateHandle<SubmittedJobGraph> jobGraphRetrievableStateHandle.             try {                 jobGraphRetrievableStateHandle = jobGraphsInZooKeeper.getAndLock(path).             } catch (KeeperException.NoNodeException ignored) {                 success = true.                 return null.             } catch (Exception e) {                 throw new FlinkException("Could not retrieve the submitted job graph state handle " + "for " + path + " from the submitted job graph store.", e).             }             SubmittedJobGraph jobGraph.             try {                 jobGraph = jobGraphRetrievableStateHandle.retrieveState().             } catch (ClassNotFoundException cnfe) {                 throw new FlinkException("Could not retrieve submitted JobGraph from state handle under " + path + ". This indicates that you are trying to recover from state written by an " + "older Flink version which is not compatible. Try cleaning the state handle store.", cnfe).             } catch (IOException ioe) {                 throw new FlinkException("Could not retrieve submitted JobGraph from state handle under " + path + ". This indicates that the retrieved state handle is broken. Try cleaning the state handle " + "store.", ioe).             }             addedJobGraphs.add(jobGraph.getJobId()).             LOG.info("Recovered {}.", jobGraph).             success = true.             return jobGraph.         } finally {             if (!success) {                 jobGraphsInZooKeeper.release(path).             }         }     } }
false;public;1;45;;@Override public void putJobGraph(SubmittedJobGraph jobGraph) throws Exception {     checkNotNull(jobGraph, "Job graph").     String path = getPathForJob(jobGraph.getJobId()).     LOG.debug("Adding job graph {} to {}{}.", jobGraph.getJobId(), zooKeeperFullBasePath, path).     boolean success = false.     while (!success) {         synchronized (cacheLock) {             verifyIsRunning().             int currentVersion = jobGraphsInZooKeeper.exists(path).             if (currentVersion == -1) {                 try {                     jobGraphsInZooKeeper.addAndLock(path, jobGraph).                     addedJobGraphs.add(jobGraph.getJobId()).                     success = true.                 } catch (KeeperException.NodeExistsException ignored) {                 }             } else if (addedJobGraphs.contains(jobGraph.getJobId())) {                 try {                     jobGraphsInZooKeeper.replace(path, currentVersion, jobGraph).                     LOG.info("Updated {} in ZooKeeper.", jobGraph).                     success = true.                 } catch (KeeperException.NoNodeException ignored) {                 }             } else {                 throw new IllegalStateException("Oh, no. Trying to update a graph you didn't " + "#getAllSubmittedJobGraphs() or #putJobGraph() yourself before.").             }         }     }     LOG.info("Added {} to ZooKeeper.", jobGraph). }
false;public;1;19;;@Override public void removeJobGraph(JobID jobId) throws Exception {     checkNotNull(jobId, "Job ID").     String path = getPathForJob(jobId).     LOG.debug("Removing job graph {} from {}{}.", jobId, zooKeeperFullBasePath, path).     synchronized (cacheLock) {         if (addedJobGraphs.contains(jobId)) {             if (jobGraphsInZooKeeper.releaseAndTryRemove(path)) {                 addedJobGraphs.remove(jobId).             } else {                 throw new FlinkException(String.format("Could not remove job graph with job id %s from ZooKeeper.", jobId)).             }         }     }     LOG.info("Removed job graph {} from ZooKeeper.", jobId). }
false;public;1;17;;@Override public void releaseJobGraph(JobID jobId) throws Exception {     checkNotNull(jobId, "Job ID").     final String path = getPathForJob(jobId).     LOG.debug("Releasing locks of job graph {} from {}{}.", jobId, zooKeeperFullBasePath, path).     synchronized (cacheLock) {         if (addedJobGraphs.contains(jobId)) {             jobGraphsInZooKeeper.release(path).             addedJobGraphs.remove(jobId).         }     }     LOG.info("Released locks of job graph {} from ZooKeeper.", jobId). }
false;public;0;24;;@Override public Collection<JobID> getJobIds() throws Exception {     Collection<String> paths.     LOG.debug("Retrieving all stored job ids from ZooKeeper under {}.", zooKeeperFullBasePath).     try {         paths = jobGraphsInZooKeeper.getAllPaths().     } catch (Exception e) {         throw new Exception("Failed to retrieve entry paths from ZooKeeperStateHandleStore.", e).     }     List<JobID> jobIds = new ArrayList<>(paths.size()).     for (String path : paths) {         try {             jobIds.add(jobIdfromPath(path)).         } catch (Exception exception) {             LOG.warn("Could not parse job id from {}. This indicates a malformed path.", path, exception).         }     }     return jobIds. }
false;public;2;90;;@Override public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {     if (LOG.isDebugEnabled()) {         if (event.getData() != null) {             LOG.debug("Received {} event (path: {})", event.getType(), event.getData().getPath()).         } else {             LOG.debug("Received {} event", event.getType()).         }     }     switch(event.getType()) {         case CHILD_ADDED:             {                 JobID jobId = fromEvent(event).                 LOG.debug("Received CHILD_ADDED event notification for job {}", jobId).                 synchronized (cacheLock) {                     try {                         if (jobGraphListener != null && !addedJobGraphs.contains(jobId)) {                             try {                                 // Whoa! This has been added by someone else. Or we were fast                                 // to remove it (false positive).                                 jobGraphListener.onAddedJobGraph(jobId).                             } catch (Throwable t) {                                 LOG.error("Error in callback", t).                             }                         }                     } catch (Exception e) {                         LOG.error("Error in SubmittedJobGraphsPathCacheListener", e).                     }                 }             }             break.         case CHILD_UPDATED:             {             // Nothing to do             }             break.         case CHILD_REMOVED:             {                 JobID jobId = fromEvent(event).                 LOG.debug("Received CHILD_REMOVED event notification for job {}", jobId).                 synchronized (cacheLock) {                     try {                         if (jobGraphListener != null && addedJobGraphs.contains(jobId)) {                             try {                                 // Oh oh. Someone else removed one of our job graphs. Mean!                                 jobGraphListener.onRemovedJobGraph(jobId).                             } catch (Throwable t) {                                 LOG.error("Error in callback", t).                             }                         }                         break.                     } catch (Exception e) {                         LOG.error("Error in SubmittedJobGraphsPathCacheListener", e).                     }                 }             }             break.         case CONNECTION_SUSPENDED:             {                 LOG.warn("ZooKeeper connection SUSPENDING. Changes to the submitted job " + "graphs are not monitored (temporarily).").             }             break.         case CONNECTION_LOST:             {                 LOG.warn("ZooKeeper connection LOST. Changes to the submitted job " + "graphs are not monitored (permanently).").             }             break.         case CONNECTION_RECONNECTED:             {                 LOG.info("ZooKeeper connection RECONNECTED. Changes to the submitted job " + "graphs are monitored again.").             }             break.         case INITIALIZED:             {                 LOG.info("SubmittedJobGraphsPathCacheListener initialized").             }             break.     } }
true;private;1;3;/**  * Returns a JobID for the event's path.  */ ;/**  * Returns a JobID for the event's path.  */ private JobID fromEvent(PathChildrenCacheEvent event) {     return JobID.fromHexString(ZKPaths.getNodeFromPath(event.getData().getPath())). }
true;private;0;3;/**  * Verifies that the state is running.  */ ;/**  * Verifies that the state is running.  */ private void verifyIsRunning() {     checkState(isRunning, "Not running. Forgot to call start()?"). }
true;public,static;1;4;/**  * Returns the JobID as a String (with leading slash).  */ ;/**  * Returns the JobID as a String (with leading slash).  */ public static String getPathForJob(JobID jobId) {     checkNotNull(jobId, "Job ID").     return String.format("/%s", jobId). }
true;public,static;1;3;/**  * Returns the JobID from the given path in ZooKeeper.  *  * @param path in ZooKeeper  * @return JobID associated with the given path  */ ;/**  * Returns the JobID from the given path in ZooKeeper.  *  * @param path in ZooKeeper  * @return JobID associated with the given path  */ public static JobID jobIdfromPath(final String path) {     return JobID.fromHexString(path). }
