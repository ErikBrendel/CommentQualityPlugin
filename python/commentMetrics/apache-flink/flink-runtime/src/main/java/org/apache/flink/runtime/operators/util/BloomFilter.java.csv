commented;modifiers;parameterAmount;loc;comment;code
false;public;2;3;;public void setBitsLocation(MemorySegment memorySegment, int offset) {     this.bitSet.setMemorySegment(memorySegment, offset). }
true;public,static;2;4;/**  * Compute optimal bits number with given input entries and expected false positive probability.  *  * @param inputEntries  * @param fpp  * @return optimal bits number  */ ;/**  * Compute optimal bits number with given input entries and expected false positive probability.  *  * @param inputEntries  * @param fpp  * @return optimal bits number  */ public static int optimalNumOfBits(long inputEntries, double fpp) {     int numBits = (int) (-inputEntries * Math.log(fpp) / (Math.log(2) * Math.log(2))).     return numBits. }
true;public,static;2;6;/**  * Compute the false positive probability based on given input entries and bits size.  * Note: this is just the math expected value, you should not expect the fpp in real case would under the return value for certain.  *  * @param inputEntries  * @param bitSize  * @return  */ ;/**  * Compute the false positive probability based on given input entries and bits size.  * Note: this is just the math expected value, you should not expect the fpp in real case would under the return value for certain.  *  * @param inputEntries  * @param bitSize  * @return  */ public static double estimateFalsePositiveProbability(long inputEntries, int bitSize) {     int numFunction = optimalNumOfHashFunctions(inputEntries, bitSize).     double p = Math.pow(Math.E, -(double) numFunction * inputEntries / bitSize).     double estimatedFPP = Math.pow(1 - p, numFunction).     return estimatedFPP. }
true;static;2;3;/**  * compute the optimal hash function number with given input entries and bits size, which would  * make the false positive probability lowest.  *  * @param expectEntries  * @param bitSize  * @return hash function number  */ ;/**  * compute the optimal hash function number with given input entries and bits size, which would  * make the false positive probability lowest.  *  * @param expectEntries  * @param bitSize  * @return hash function number  */ static int optimalNumOfHashFunctions(long expectEntries, long bitSize) {     return Math.max(1, (int) Math.round((double) bitSize / expectEntries * Math.log(2))). }
false;public;1;14;;public void addHash(int hash32) {     int hash1 = hash32.     int hash2 = hash32 >>> 16.     for (int i = 1. i <= numHashFunctions. i++) {         int combinedHash = hash1 + (i * hash2).         // hashcode should be positive, flip all the bits if it's negative         if (combinedHash < 0) {             combinedHash = ~combinedHash.         }         int pos = combinedHash % bitSet.bitSize().         bitSet.set(pos).     } }
false;public;1;17;;public boolean testHash(int hash32) {     int hash1 = hash32.     int hash2 = hash32 >>> 16.     for (int i = 1. i <= numHashFunctions. i++) {         int combinedHash = hash1 + (i * hash2).         // hashcode should be positive, flip all the bits if it's negative         if (combinedHash < 0) {             combinedHash = ~combinedHash.         }         int pos = combinedHash % bitSet.bitSize().         if (!bitSet.get(pos)) {             return false.         }     }     return true. }
false;public;0;3;;public void reset() {     this.bitSet.clear(). }
false;public;0;8;;@Override public String toString() {     StringBuilder output = new StringBuilder().     output.append("BloomFilter:\n").     output.append("\thash function number:").append(numHashFunctions).append("\n").     output.append(bitSet).     return output.toString(). }
false;public;2;4;;public void setMemorySegment(MemorySegment memorySegment, int offset) {     this.memorySegment = memorySegment.     this.offset = offset. }
true;public;1;6;/**  * Sets the bit at specified index.  *  * @param index - position  */ ;/**  * Sets the bit at specified index.  *  * @param index - position  */ public void set(int index) {     int longIndex = (index & LONG_POSITION_MASK) >>> 3.     long current = memorySegment.getLong(offset + longIndex).     current |= (1L << index).     memorySegment.putLong(offset + longIndex, current). }
true;public;1;5;/**  * Returns true if the bit is set in the specified index.  *  * @param index - position  * @return - value at the bit position  */ ;/**  * Returns true if the bit is set in the specified index.  *  * @param index - position  * @return - value at the bit position  */ public boolean get(int index) {     int longIndex = (index & LONG_POSITION_MASK) >>> 3.     long current = memorySegment.getLong(offset + longIndex).     return (current & (1L << index)) != 0. }
true;public;0;3;/**  * Number of bits  */ ;/**  * Number of bits  */ public int bitSize() {     return length << 3. }
false;public;0;3;;public MemorySegment getMemorySegment() {     return this.memorySegment. }
true;public;0;6;/**  * Clear the bit set.  */ ;/**  * Clear the bit set.  */ public void clear() {     long zeroValue = 0L.     for (int i = 0. i < (length / 8). i++) {         memorySegment.putLong(offset + i * 8, zeroValue).     } }
false;public;0;9;;@Override public String toString() {     StringBuilder output = new StringBuilder().     output.append("BitSet:\n").     output.append("\tMemorySegment:").append(memorySegment.size()).append("\n").     output.append("\tOffset:").append(offset).append("\n").     output.append("\tLength:").append(length).append("\n").     return output.toString(). }
