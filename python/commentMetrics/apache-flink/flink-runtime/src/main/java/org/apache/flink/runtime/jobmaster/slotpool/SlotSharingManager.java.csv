commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isEmpty() {     return allTaskSlots.isEmpty(). }
false;public;1;3;;public boolean contains(SlotRequestId slotRequestId) {     return allTaskSlots.containsKey(slotRequestId). }
false;;1;4;;@Nullable TaskSlot getTaskSlot(SlotRequestId slotRequestId) {     return allTaskSlots.get(slotRequestId). }
true;;3;41;/**  * Creates a new root slot with the given {@link SlotRequestId}, {@link SlotContext} future and  * the {@link SlotRequestId} of the allocated slot.  *  * @param slotRequestId of the root slot  * @param slotContextFuture with which we create the root slot  * @param allocatedSlotRequestId slot request id of the underlying allocated slot which can be used  *                               to cancel the pending slot request or release the allocated slot  * @return New root slot  */ ;/**  * Creates a new root slot with the given {@link SlotRequestId}, {@link SlotContext} future and  * the {@link SlotRequestId} of the allocated slot.  *  * @param slotRequestId of the root slot  * @param slotContextFuture with which we create the root slot  * @param allocatedSlotRequestId slot request id of the underlying allocated slot which can be used  *                               to cancel the pending slot request or release the allocated slot  * @return New root slot  */ @Nonnull MultiTaskSlot createRootSlot(SlotRequestId slotRequestId, CompletableFuture<? extends SlotContext> slotContextFuture, SlotRequestId allocatedSlotRequestId) {     final MultiTaskSlot rootMultiTaskSlot = new MultiTaskSlot(slotRequestId, slotContextFuture, allocatedSlotRequestId).     LOG.debug("Create multi task slot [{}] in slot [{}].", slotRequestId, allocatedSlotRequestId).     allTaskSlots.put(slotRequestId, rootMultiTaskSlot).     unresolvedRootSlots.put(slotRequestId, rootMultiTaskSlot).     // add the root node to the set of resolved root nodes once the SlotContext future has     // been completed and we know the slot's TaskManagerLocation     slotContextFuture.whenComplete((SlotContext slotContext, Throwable throwable) -> {         if (slotContext != null) {             final MultiTaskSlot resolvedRootNode = unresolvedRootSlots.remove(slotRequestId).             if (resolvedRootNode != null) {                 final AllocationID allocationId = slotContext.getAllocationId().                 LOG.trace("Fulfill multi task slot [{}] with slot [{}].", slotRequestId, allocationId).                 final Map<AllocationID, MultiTaskSlot> innerMap = resolvedRootSlots.computeIfAbsent(slotContext.getTaskManagerLocation(), taskManagerLocation -> new HashMap<>(4)).                 MultiTaskSlot previousValue = innerMap.put(allocationId, resolvedRootNode).                 Preconditions.checkState(previousValue == null).             }         } else {             rootMultiTaskSlot.release(throwable).         }     }).     return rootMultiTaskSlot. }
false;public;1;10;;@Nonnull public Collection<SlotInfo> listResolvedRootSlotInfo(@Nullable AbstractID groupId) {     return resolvedRootSlots.values().stream().flatMap((Map<AllocationID, MultiTaskSlot> map) -> map.values().stream()).filter((MultiTaskSlot multiTaskSlot) -> !multiTaskSlot.contains(groupId)).map((MultiTaskSlot multiTaskSlot) -> (SlotInfo) multiTaskSlot.getSlotContextFuture().join()).collect(Collectors.toList()). }
false;public;1;5;;@Nullable public MultiTaskSlot getResolvedRootSlot(@Nonnull SlotInfo slotInfo) {     Map<AllocationID, MultiTaskSlot> forLocationEntry = resolvedRootSlots.get(slotInfo.getTaskManagerLocation()).     return forLocationEntry != null ? forLocationEntry.get(slotInfo.getAllocationId()) : null. }
true;;1;10;/**  * Gets an unresolved slot which does not yet contain the given groupId. An unresolved  * slot is a slot whose underlying allocated slot has not been allocated yet.  *  * @param groupId which the returned slot must not contain  * @return the unresolved slot or null if there was no root slot with free capacities  */ ;/**  * Gets an unresolved slot which does not yet contain the given groupId. An unresolved  * slot is a slot whose underlying allocated slot has not been allocated yet.  *  * @param groupId which the returned slot must not contain  * @return the unresolved slot or null if there was no root slot with free capacities  */ @Nullable MultiTaskSlot getUnresolvedRootSlot(AbstractID groupId) {     for (MultiTaskSlot multiTaskSlot : unresolvedRootSlots.values()) {         if (!multiTaskSlot.contains(groupId)) {             return multiTaskSlot.         }     }     return null. }
false;public;0;10;;@Override public String toString() {     final StringBuilder builder = new StringBuilder("{\n\tgroupId=").append(slotSharingGroupId).append('\n').     builder.append("\tunresolved=").append(unresolvedRootSlots).append('\n').     builder.append("\tresolved=").append(resolvedRootSlots).append('\n').     builder.append("\tall=").append(allTaskSlots).append('\n').     return builder.append('}').toString(). }
false;;0;3;;MultiTaskSlot getMultiTaskSlot() {     return multiTaskSlot. }
false;public;0;3;;public Locality getLocality() {     return locality. }
false;public,static;2;3;;public static MultiTaskSlotLocality of(MultiTaskSlot multiTaskSlot, Locality locality) {     return new MultiTaskSlotLocality(multiTaskSlot, locality). }
false;public;0;3;;public SlotRequestId getSlotRequestId() {     return slotRequestId. }
false;public;0;4;;@Nullable public AbstractID getGroupId() {     return groupId. }
true;public;1;3;/**  * Check whether the task slot contains the given groupId.  *  * @param groupId which to check whether it is contained  * @return true if the task slot contains the given groupId, otherwise false  */ ;/**  * Check whether the task slot contains the given groupId.  *  * @param groupId which to check whether it is contained  * @return true if the task slot contains the given groupId, otherwise false  */ public boolean contains(AbstractID groupId) {     return Objects.equals(this.groupId, groupId). }
true;public,abstract;1;1;/**  * Release the task slot.  *  * @param cause for the release  */ ;/**  * Release the task slot.  *  * @param cause for the release  */ public abstract void release(Throwable cause).
false;;0;3;;CompletableFuture<? extends SlotContext> getSlotContextFuture() {     return slotContextFuture. }
true;;2;17;/**  * Allocates a MultiTaskSlot and registers it under the given groupId at  * this MultiTaskSlot.  *  * @param slotRequestId of the new multi task slot  * @param groupId under which the new multi task slot is registered  * @return the newly allocated MultiTaskSlot  */ ;/**  * Allocates a MultiTaskSlot and registers it under the given groupId at  * this MultiTaskSlot.  *  * @param slotRequestId of the new multi task slot  * @param groupId under which the new multi task slot is registered  * @return the newly allocated MultiTaskSlot  */ MultiTaskSlot allocateMultiTaskSlot(SlotRequestId slotRequestId, AbstractID groupId) {     Preconditions.checkState(!super.contains(groupId)).     LOG.debug("Create nested multi task slot [{}] in parent multi task slot [{}] for group [{}].", slotRequestId, getSlotRequestId(), groupId).     final MultiTaskSlot inner = new MultiTaskSlot(slotRequestId, groupId, this).     children.put(groupId, inner).     // register the newly allocated slot also at the SlotSharingManager     allTaskSlots.put(slotRequestId, inner).     return inner. }
true;;3;21;/**  * Allocates a {@link SingleTaskSlot} and registers it under the given groupId at  * this MultiTaskSlot.  *  * @param slotRequestId of the new single task slot  * @param groupId under which the new single task slot is registered  * @param locality of the allocation  * @return the newly allocated {@link SingleTaskSlot}  */ ;/**  * Allocates a {@link SingleTaskSlot} and registers it under the given groupId at  * this MultiTaskSlot.  *  * @param slotRequestId of the new single task slot  * @param groupId under which the new single task slot is registered  * @param locality of the allocation  * @return the newly allocated {@link SingleTaskSlot}  */ SingleTaskSlot allocateSingleTaskSlot(SlotRequestId slotRequestId, AbstractID groupId, Locality locality) {     Preconditions.checkState(!super.contains(groupId)).     LOG.debug("Create single task slot [{}] in multi task slot [{}] for group {}.", slotRequestId, getSlotRequestId(), groupId).     final SingleTaskSlot leaf = new SingleTaskSlot(slotRequestId, groupId, this, locality).     children.put(groupId, leaf).     // register the newly allocated slot also at the SlotSharingManager     allTaskSlots.put(slotRequestId, leaf).     return leaf. }
true;public;1;14;/**  * Checks whether this slot or any of its children contains the given groupId.  *  * @param groupId which to check whether it is contained  * @return true if this or any of its children contains the given groupId, otherwise false  */ ;/**  * Checks whether this slot or any of its children contains the given groupId.  *  * @param groupId which to check whether it is contained  * @return true if this or any of its children contains the given groupId, otherwise false  */ @Override public boolean contains(AbstractID groupId) {     if (super.contains(groupId)) {         return true.     } else {         for (TaskSlot taskSlot : children.values()) {             if (taskSlot.contains(groupId)) {                 return true.             }         }         return false.     } }
false;public;1;44;;@Override public void release(Throwable cause) {     releasingChildren = true.     // first release all children and remove them if they could be released immediately     for (TaskSlot taskSlot : children.values()) {         taskSlot.release(cause).         allTaskSlots.remove(taskSlot.getSlotRequestId()).     }     children.clear().     releasingChildren = false.     if (parent != null) {         // we remove ourselves from our parent if we no longer have children         parent.releaseChild(getGroupId()).     } else if (allTaskSlots.remove(getSlotRequestId()) != null) {         // we are the root node --> remove the root node from the list of task slots         final MultiTaskSlot unresolvedRootSlot = unresolvedRootSlots.remove(getSlotRequestId()).         if (unresolvedRootSlot == null) {             // the root node should be resolved --> we can access the slot context             final SlotContext slotContext = slotContextFuture.getNow(null).             if (slotContext != null) {                 final Map<AllocationID, MultiTaskSlot> multiTaskSlots = resolvedRootSlots.get(slotContext.getTaskManagerLocation()).                 if (multiTaskSlots != null) {                     MultiTaskSlot removedSlot = multiTaskSlots.remove(slotContext.getAllocationId()).                     Preconditions.checkState(removedSlot == this).                     if (multiTaskSlots.isEmpty()) {                         resolvedRootSlots.remove(slotContext.getTaskManagerLocation()).                     }                 }             }         }         // release the underlying allocated slot         allocatedSlotActions.releaseSlot(allocatedSlotRequestId, cause).     } }
true;private;1;13;/**  * Releases the child with the given childGroupId.  *  * @param childGroupId identifying the child to release  */ ;/**  * Releases the child with the given childGroupId.  *  * @param childGroupId identifying the child to release  */ private void releaseChild(AbstractID childGroupId) {     if (!releasingChildren) {         TaskSlot child = children.remove(childGroupId).         if (child != null) {             allTaskSlots.remove(child.getSlotRequestId()).         }         if (children.isEmpty()) {             release(new FlinkException("Release multi task slot because all children have been released.")).         }     } }
false;public;0;18;;@Override public String toString() {     String physicalSlotDescription.     try {         physicalSlotDescription = String.valueOf(slotContextFuture.getNow(null)).     } catch (Exception e) {         physicalSlotDescription = '(' + ExceptionUtils.stripCompletionException(e).getMessage() + ')'.     }     return "MultiTaskSlot{" + "requestId=" + getSlotRequestId() + ", allocatedRequestId=" + allocatedSlotRequestId + ", groupId=" + getGroupId() + ", physicalSlot=" + physicalSlotDescription + ", children=" + children.values().toString() + '}'. }
false;;0;3;;CompletableFuture<LogicalSlot> getLogicalSlotFuture() {     return singleLogicalSlotFuture.thenApply(Function.identity()). }
false;public;1;13;;@Override public void release(Throwable cause) {     singleLogicalSlotFuture.completeExceptionally(cause).     if (singleLogicalSlotFuture.isDone() && !singleLogicalSlotFuture.isCompletedExceptionally()) {         // we have a single task slot which we first have to release         final SingleLogicalSlot singleLogicalSlot = singleLogicalSlotFuture.getNow(null).         singleLogicalSlot.release(cause).     }     parent.releaseChild(getGroupId()). }
false;public;0;20;;@Override public String toString() {     String logicalSlotString = "(pending)".     try {         LogicalSlot slot = singleLogicalSlotFuture.getNow(null).         if (slot != null) {             logicalSlotString = "(requestId=" + slot.getSlotRequestId() + ", allocationId=" + slot.getAllocationId() + ')'.         }     } catch (Exception e) {         logicalSlotString = '(' + ExceptionUtils.stripCompletionException(e).getMessage() + ')'.     }     return "SingleTaskSlot{" + "logicalSlot=" + logicalSlotString + ", request=" + getSlotRequestId() + ", group=" + getGroupId() + '}'. }
true;public;0;4;/**  * Returns a collection of all resolved root slots.  *  * @return Collection of all resolved root slots  */ ;// ------------------------------------------------------------------------ // Methods and classes for testing // ------------------------------------------------------------------------ /**  * Returns a collection of all resolved root slots.  *  * @return Collection of all resolved root slots  */ @VisibleForTesting public Collection<MultiTaskSlot> getResolvedRootSlots() {     return new ResolvedRootSlotValues(). }
false;;0;4;;@VisibleForTesting Collection<MultiTaskSlot> getUnresolvedRootSlots() {     return unresolvedRootSlots.values(). }
false;public;0;4;;@Override public Iterator<MultiTaskSlot> iterator() {     return new ResolvedRootSlotIterator(resolvedRootSlots.values().iterator()). }
false;public;0;10;;@Override public int size() {     int numberResolvedMultiTaskSlots = 0.     for (Map<AllocationID, MultiTaskSlot> multiTaskSlots : resolvedRootSlots.values()) {         numberResolvedMultiTaskSlots += multiTaskSlots.size().     }     return numberResolvedMultiTaskSlots. }
false;public;0;6;;@Override public boolean hasNext() {     progressToNextElement().     return currentIterator.hasNext(). }
false;public;0;6;;@Override public MultiTaskSlot next() {     progressToNextElement().     return currentIterator.next(). }
false;private;0;5;;private void progressToNextElement() {     while (baseIterator.hasNext() && !currentIterator.hasNext()) {         currentIterator = baseIterator.next().values().iterator().     } }
