commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;// ------------------------------------------------------------------------ // Channel Selection // ------------------------------------------------------------------------ @Override public void setup(int numberOfChannels) {     this.numberOfChannels = numberOfChannels. }
false;public,final;1;18;;@Override public final int selectChannel(SerializationDelegate<T> record) {     switch(strategy) {         case FORWARD:             return forward().         case PARTITION_RANDOM:         case PARTITION_FORCED_REBALANCE:             return robin(numberOfChannels).         case PARTITION_HASH:             return hashPartitionDefault(record.getInstance(), numberOfChannels).         case PARTITION_CUSTOM:             return customPartition(record.getInstance(), numberOfChannels).         case PARTITION_RANGE:             return rangePartition(record.getInstance(), numberOfChannels).         default:             throw new UnsupportedOperationException("Unsupported distribution strategy: " + strategy.name()).     } }
false;public;0;8;;@Override public boolean isBroadcast() {     if (strategy == ShipStrategyType.BROADCAST) {         return true.     } else {         return false.     } }
false;private;0;3;;// -------------------------------------------------------------------------------------------- private int forward() {     return 0. }
false;private;1;13;;private int robin(int numberOfChannels) {     int nextChannel = nextChannelToSendTo.     if (nextChannel >= numberOfChannels) {         if (nextChannel == numberOfChannels) {             nextChannel = 0.         } else {             nextChannel %= numberOfChannels.         }     }     nextChannelToSendTo = nextChannel + 1.     return nextChannel. }
false;private;2;5;;private int hashPartitionDefault(T record, int numberOfChannels) {     int hash = this.comparator.hash(record).     return MathUtils.murmurHash(hash) % numberOfChannels. }
false;private;2;34;;private int rangePartition(final T record, int numberOfChannels) {     if (this.partitionBoundaries == null) {         this.partitionBoundaries = new Object[numberOfChannels - 1][].         for (int i = 0. i < numberOfChannels - 1. i++) {             this.partitionBoundaries[i] = this.distribution.getBucketBoundary(i, numberOfChannels).         }     }     if (numberOfChannels == this.partitionBoundaries.length + 1) {         final Object[][] boundaries = this.partitionBoundaries.         // bin search the bucket         int low = 0.         int high = this.partitionBoundaries.length - 1.         while (low <= high) {             final int mid = (low + high) >>> 1.             final int result = compareRecordAndBoundary(record, boundaries[mid]).             if (result > 0) {                 low = mid + 1.             } else if (result < 0) {                 high = mid - 1.             } else {                 return mid.             }         }         // key not found, but the low index is the target bucket, since the boundaries are the upper bound         return low.     } else {         throw new IllegalStateException("The number of channels to partition among is inconsistent with the partitioners state.").     } }
false;private;2;18;;private int customPartition(T record, int numberOfChannels) {     if (extractedKeys == null) {         extractedKeys = new Object[1].     }     try {         if (comparator.extractKeys(record, extractedKeys, 0) == 1) {             final Object key = extractedKeys[0].             return partitioner.partition(key, numberOfChannels).         } else {             throw new RuntimeException("Inconsistency in the key comparator - comparator extracted more than one field.").         }     } catch (Throwable t) {         throw new RuntimeException("Error while calling custom partitioner.", t).     } }
false;private,final;2;15;;private final int compareRecordAndBoundary(T record, Object[] boundary) {     this.comparator.extractKeys(record, keys, 0).     if (flatComparators.length != keys.length || flatComparators.length > boundary.length) {         throw new RuntimeException("Can not compare keys with boundary due to mismatched length.").     }     for (int i = 0. i < flatComparators.length. i++) {         int result = flatComparators[i].compare(keys[i], boundary[i]).         if (result != 0) {             return result.         }     }     return 0. }
