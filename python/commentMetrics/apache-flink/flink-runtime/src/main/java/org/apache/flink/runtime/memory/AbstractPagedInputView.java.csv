commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the memory segment that will be used to read the next bytes from. If the segment is exactly exhausted,  * meaning that the last byte read was the last byte available in the segment, then this segment will  * not serve the next bytes. The segment to serve the next bytes will be obtained through the  * {@link #nextSegment(MemorySegment)} method.  *  * @return The current memory segment.  */ ;// -------------------------------------------------------------------------------------------- // Page Management // -------------------------------------------------------------------------------------------- /**  * Gets the memory segment that will be used to read the next bytes from. If the segment is exactly exhausted,  * meaning that the last byte read was the last byte available in the segment, then this segment will  * not serve the next bytes. The segment to serve the next bytes will be obtained through the  * {@link #nextSegment(MemorySegment)} method.  *  * @return The current memory segment.  */ public MemorySegment getCurrentSegment() {     return this.currentSegment. }
true;public;0;3;/**  * Gets the position from which the next byte will be read. If that position is equal to the current limit,  * then the next byte will be read from next segment.  *  * @return The position from which the next byte will be read.  * @see #getCurrentSegmentLimit()  */ ;/**  * Gets the position from which the next byte will be read. If that position is equal to the current limit,  * then the next byte will be read from next segment.  *  * @return The position from which the next byte will be read.  * @see #getCurrentSegmentLimit()  */ public int getCurrentPositionInSegment() {     return this.positionInSegment. }
true;public;0;3;/**  * Gets the current limit in the memory segment. This value points to the byte one after the last valid byte  * in the memory segment.  *  * @return The current limit in the memory segment.  * @see #getCurrentPositionInSegment()  */ ;/**  * Gets the current limit in the memory segment. This value points to the byte one after the last valid byte  * in the memory segment.  *  * @return The current limit in the memory segment.  * @see #getCurrentPositionInSegment()  */ public int getCurrentSegmentLimit() {     return this.limitInSegment. }
true;protected,abstract;1;1;/**  * The method by which concrete subclasses realize page crossing. This method is invoked when the current page  * is exhausted and a new page is required to continue the reading. If no further page is available, this  * method must throw an {@link EOFException}.  *  * @param current The current page that was read to its limit. May be {@code null}, if this method is  *                invoked for the first time.  * @return The next page from which the reading should continue. May not be {@code null}. If the input is  *         exhausted, an {@link EOFException} must be thrown instead.  *  * @throws EOFException Thrown, if no further segment is available.  * @throws IOException Thrown, if the method cannot provide the next page due to an I/O related problem.  */ ;/**  * The method by which concrete subclasses realize page crossing. This method is invoked when the current page  * is exhausted and a new page is required to continue the reading. If no further page is available, this  * method must throw an {@link EOFException}.  *  * @param current The current page that was read to its limit. May be {@code null}, if this method is  *                invoked for the first time.  * @return The next page from which the reading should continue. May not be {@code null}. If the input is  *         exhausted, an {@link EOFException} must be thrown instead.  *  * @throws EOFException Thrown, if no further segment is available.  * @throws IOException Thrown, if the method cannot provide the next page due to an I/O related problem.  */ protected abstract MemorySegment nextSegment(MemorySegment current) throws EOFException, IOException.
true;protected,abstract;1;1;/**  * Gets the limit for reading bytes from the given memory segment. This method must return the position  * of the byte after the last valid byte in the given memory segment. When the position returned by this  * method is reached, the view will attempt to switch to the next memory segment.  *  * @param segment The segment to determine the limit for.  * @return The limit for the given memory segment.  */ ;/**  * Gets the limit for reading bytes from the given memory segment. This method must return the position  * of the byte after the last valid byte in the given memory segment. When the position returned by this  * method is reached, the view will attempt to switch to the next memory segment.  *  * @param segment The segment to determine the limit for.  * @return The limit for the given memory segment.  */ protected abstract int getLimitForSegment(MemorySegment segment).
true;protected,final;0;7;/**  * Advances the view to the next memory segment. The reading will continue after the header of the next  * segment. This method uses {@link #nextSegment(MemorySegment)} and {@link #getLimitForSegment(MemorySegment)}  * to get the next segment and set its limit.  *  * @throws IOException Thrown, if the next segment could not be obtained.  *  * @see #nextSegment(MemorySegment)  * @see #getLimitForSegment(MemorySegment)  */ ;/**  * Advances the view to the next memory segment. The reading will continue after the header of the next  * segment. This method uses {@link #nextSegment(MemorySegment)} and {@link #getLimitForSegment(MemorySegment)}  * to get the next segment and set its limit.  *  * @throws IOException Thrown, if the next segment could not be obtained.  *  * @see #nextSegment(MemorySegment)  * @see #getLimitForSegment(MemorySegment)  */ protected final void advance() throws IOException {     // note: this code ensures that in case of EOF, we stay at the same position such that     // EOF is reproducible (if nextSegment throws a reproducible EOFException)     this.currentSegment = nextSegment(this.currentSegment).     this.limitInSegment = getLimitForSegment(this.currentSegment).     this.positionInSegment = this.headerLength. }
true;protected;3;5;/**  * Sets the internal state of the view such that the next bytes will be read from the given memory segment,  * starting at the given position. The memory segment will provide bytes up to the given limit position.  *  * @param segment The segment to read the next bytes from.  * @param positionInSegment The position in the segment to start reading from.  * @param limitInSegment The limit in the segment. When reached, the view will attempt to switch to  *                       the next segment.  */ ;/**  * Sets the internal state of the view such that the next bytes will be read from the given memory segment,  * starting at the given position. The memory segment will provide bytes up to the given limit position.  *  * @param segment The segment to read the next bytes from.  * @param positionInSegment The position in the segment to start reading from.  * @param limitInSegment The limit in the segment. When reached, the view will attempt to switch to  *                       the next segment.  */ protected void seekInput(MemorySegment segment, int positionInSegment, int limitInSegment) {     this.currentSegment = segment.     this.positionInSegment = positionInSegment.     this.limitInSegment = limitInSegment. }
true;protected;0;5;/**  * Clears the internal state of the view. After this call, all read attempts will fail, until the  * {@link #advance()} or {@link #seekInput(MemorySegment, int, int)} method have been invoked.  */ ;/**  * Clears the internal state of the view. After this call, all read attempts will fail, until the  * {@link #advance()} or {@link #seekInput(MemorySegment, int, int)} method have been invoked.  */ protected void clear() {     this.currentSegment = null.     this.positionInSegment = this.headerLength.     this.limitInSegment = headerLength. }
false;public;1;4;;// -------------------------------------------------------------------------------------------- // Data Input Specific methods // -------------------------------------------------------------------------------------------- @Override public int read(byte[] b) throws IOException {     return read(b, 0, b.length). }
false;public;3;48;;@Override public int read(byte[] b, int off, int len) throws IOException {     if (off < 0 || len < 0 || off + len > b.length) {         throw new IndexOutOfBoundsException().     }     int remaining = this.limitInSegment - this.positionInSegment.     if (remaining >= len) {         this.currentSegment.get(this.positionInSegment, b, off, len).         this.positionInSegment += len.         return len.     } else {         if (remaining == 0) {             try {                 advance().             } catch (EOFException eof) {                 return -1.             }             remaining = this.limitInSegment - this.positionInSegment.         }         int bytesRead = 0.         while (true) {             int toRead = Math.min(remaining, len - bytesRead).             this.currentSegment.get(this.positionInSegment, b, off, toRead).             off += toRead.             bytesRead += toRead.             if (len > bytesRead) {                 try {                     advance().                 } catch (EOFException eof) {                     this.positionInSegment += toRead.                     return bytesRead.                 }                 remaining = this.limitInSegment - this.positionInSegment.             } else {                 this.positionInSegment += toRead.                 break.             }         }         return len.     } }
false;public;1;4;;@Override public void readFully(byte[] b) throws IOException {     readFully(b, 0, b.length). }
false;public;3;8;;@Override public void readFully(byte[] b, int off, int len) throws IOException {     int bytesRead = read(b, off, len).     if (bytesRead < len) {         throw new EOFException("There is no enough data left in the DataInputView.").     } }
false;public;0;4;;@Override public boolean readBoolean() throws IOException {     return readByte() == 1. }
false;public;0;10;;@Override public byte readByte() throws IOException {     if (this.positionInSegment < this.limitInSegment) {         return this.currentSegment.get(this.positionInSegment++).     } else {         advance().         return readByte().     } }
false;public;0;4;;@Override public int readUnsignedByte() throws IOException {     return readByte() & 0xff. }
false;public;0;15;;@Override public short readShort() throws IOException {     if (this.positionInSegment < this.limitInSegment - 1) {         final short v = this.currentSegment.getShortBigEndian(this.positionInSegment).         this.positionInSegment += 2.         return v.     } else if (this.positionInSegment == this.limitInSegment) {         advance().         return readShort().     } else {         return (short) ((readUnsignedByte() << 8) | readUnsignedByte()).     } }
false;public;0;15;;@Override public int readUnsignedShort() throws IOException {     if (this.positionInSegment < this.limitInSegment - 1) {         final int v = this.currentSegment.getShortBigEndian(this.positionInSegment) & 0xffff.         this.positionInSegment += 2.         return v.     } else if (this.positionInSegment == this.limitInSegment) {         advance().         return readUnsignedShort().     } else {         return (readUnsignedByte() << 8) | readUnsignedByte().     } }
false;public;0;15;;@Override public char readChar() throws IOException {     if (this.positionInSegment < this.limitInSegment - 1) {         final char v = this.currentSegment.getCharBigEndian(this.positionInSegment).         this.positionInSegment += 2.         return v.     } else if (this.positionInSegment == this.limitInSegment) {         advance().         return readChar().     } else {         return (char) ((readUnsignedByte() << 8) | readUnsignedByte()).     } }
false;public;0;18;;@Override public int readInt() throws IOException {     if (this.positionInSegment < this.limitInSegment - 3) {         final int v = this.currentSegment.getIntBigEndian(this.positionInSegment).         this.positionInSegment += 4.         return v.     } else if (this.positionInSegment == this.limitInSegment) {         advance().         return readInt().     } else {         return (readUnsignedByte() << 24) | (readUnsignedByte() << 16) | (readUnsignedByte() << 8) | readUnsignedByte().     } }
false;public;0;24;;@Override public long readLong() throws IOException {     if (this.positionInSegment < this.limitInSegment - 7) {         final long v = this.currentSegment.getLongBigEndian(this.positionInSegment).         this.positionInSegment += 8.         return v.     } else if (this.positionInSegment == this.limitInSegment) {         advance().         return readLong().     } else {         long l = 0L.         l |= ((long) readUnsignedByte()) << 56.         l |= ((long) readUnsignedByte()) << 48.         l |= ((long) readUnsignedByte()) << 40.         l |= ((long) readUnsignedByte()) << 32.         l |= ((long) readUnsignedByte()) << 24.         l |= ((long) readUnsignedByte()) << 16.         l |= ((long) readUnsignedByte()) << 8.         l |= (long) readUnsignedByte().         return l.     } }
false;public;0;4;;@Override public float readFloat() throws IOException {     return Float.intBitsToFloat(readInt()). }
false;public;0;4;;@Override public double readDouble() throws IOException {     return Double.longBitsToDouble(readLong()). }
false;public;0;25;;@Override public String readLine() throws IOException {     final StringBuilder bld = new StringBuilder(32).     try {         int b.         while ((b = readUnsignedByte()) != '\n') {             if (b != '\r') {                 bld.append((char) b).             }         }     } catch (EOFException eofex) {     }     if (bld.length() == 0) {         return null.     }     // trim a trailing carriage return     int len = bld.length().     if (len > 0 && bld.charAt(len - 1) == '\r') {         bld.setLength(len - 1).     }     return bld.toString(). }
false;public;0;84;;@Override public String readUTF() throws IOException {     final int utflen = readUnsignedShort().     final byte[] bytearr.     final char[] chararr.     if (this.utfByteBuffer == null || this.utfByteBuffer.length < utflen) {         bytearr = new byte[utflen].         this.utfByteBuffer = bytearr.     } else {         bytearr = this.utfByteBuffer.     }     if (this.utfCharBuffer == null || this.utfCharBuffer.length < utflen) {         chararr = new char[utflen].         this.utfCharBuffer = chararr.     } else {         chararr = this.utfCharBuffer.     }     int c, char2, char3.     int count = 0.     int chararrCount = 0.     readFully(bytearr, 0, utflen).     while (count < utflen) {         c = (int) bytearr[count] & 0xff.         if (c > 127) {             break.         }         count++.         chararr[chararrCount++] = (char) c.     }     while (count < utflen) {         c = (int) bytearr[count] & 0xff.         switch(c >> 4) {             case 0:             case 1:             case 2:             case 3:             case 4:             case 5:             case 6:             case 7:                 /* 0xxxxxxx */                 count++.                 chararr[chararrCount++] = (char) c.                 break.             case 12:             case 13:                 /* 110x xxxx 10xx xxxx */                 count += 2.                 if (count > utflen) {                     throw new UTFDataFormatException("malformed input: partial character at end").                 }                 char2 = (int) bytearr[count - 1].                 if ((char2 & 0xC0) != 0x80) {                     throw new UTFDataFormatException("malformed input around byte " + count).                 }                 chararr[chararrCount++] = (char) (((c & 0x1F) << 6) | (char2 & 0x3F)).                 break.             case 14:                 /* 1110 xxxx 10xx xxxx 10xx xxxx */                 count += 3.                 if (count > utflen) {                     throw new UTFDataFormatException("malformed input: partial character at end").                 }                 char2 = (int) bytearr[count - 2].                 char3 = (int) bytearr[count - 1].                 if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) {                     throw new UTFDataFormatException("malformed input around byte " + (count - 1)).                 }                 chararr[chararrCount++] = (char) (((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0)).                 break.             default:                 /* 10xx xxxx, 1111 xxxx */                 throw new UTFDataFormatException("malformed input around byte " + count).         }     }     // The number of chars produced may be less than utflen     return new String(chararr, 0, chararrCount). }
false;public;1;43;;@Override public int skipBytes(int n) throws IOException {     if (n < 0) {         throw new IllegalArgumentException().     }     int remaining = this.limitInSegment - this.positionInSegment.     if (remaining >= n) {         this.positionInSegment += n.         return n.     } else {         if (remaining == 0) {             try {                 advance().             } catch (EOFException eofex) {                 return 0.             }             remaining = this.limitInSegment - this.positionInSegment.         }         int skipped = 0.         while (true) {             int toSkip = Math.min(remaining, n).             n -= toSkip.             skipped += toSkip.             if (n > 0) {                 try {                     advance().                 } catch (EOFException eofex) {                     return skipped.                 }                 remaining = this.limitInSegment - this.positionInSegment.             } else {                 this.positionInSegment += toSkip.                 break.             }         }         return skipped.     } }
false;public;1;29;;@Override public void skipBytesToRead(int numBytes) throws IOException {     if (numBytes < 0) {         throw new IllegalArgumentException().     }     int remaining = this.limitInSegment - this.positionInSegment.     if (remaining >= numBytes) {         this.positionInSegment += numBytes.     } else {         if (remaining == 0) {             advance().             remaining = this.limitInSegment - this.positionInSegment.         }         while (true) {             if (numBytes > remaining) {                 numBytes -= remaining.                 advance().                 remaining = this.limitInSegment - this.positionInSegment.             } else {                 this.positionInSegment += numBytes.                 break.             }         }     } }
