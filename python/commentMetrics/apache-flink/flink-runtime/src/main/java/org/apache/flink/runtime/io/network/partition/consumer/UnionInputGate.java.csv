commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Returns the total number of input channels across all unioned input gates.  */ ;/**  * Returns the total number of input channels across all unioned input gates.  */ @Override public int getNumberOfInputChannels() {     return totalNumberOfInputChannels. }
false;public;0;5;;@Override public String getOwningTaskName() {     // all input gates have the same owning task     return inputGates[0].getOwningTaskName(). }
false;public;0;10;;@Override public boolean isFinished() {     for (InputGate inputGate : inputGates) {         if (!inputGate.isFinished()) {             return false.         }     }     return true. }
false;public;0;10;;@Override public void requestPartitions() throws IOException, InterruptedException {     if (!requestedPartitionsFlag) {         for (InputGate inputGate : inputGates) {             inputGate.requestPartitions().         }         requestedPartitionsFlag = true.     } }
false;public;0;39;;@Override public Optional<BufferOrEvent> getNextBufferOrEvent() throws IOException, InterruptedException {     if (inputGatesWithRemainingData.isEmpty()) {         return Optional.empty().     }     // Make sure to request the partitions, if they have not been requested before.     requestPartitions().     InputGateWithData inputGateWithData = waitAndGetNextInputGate().     InputGate inputGate = inputGateWithData.inputGate.     BufferOrEvent bufferOrEvent = inputGateWithData.bufferOrEvent.     if (bufferOrEvent.moreAvailable()) {         // this buffer or event was now removed from the non-empty gates queue         // we re-add it in case it has more data, because in that case no "non-empty" notification         // will come for that gate         queueInputGate(inputGate).     }     if (bufferOrEvent.isEvent() && bufferOrEvent.getEvent().getClass() == EndOfPartitionEvent.class && inputGate.isFinished()) {         checkState(!bufferOrEvent.moreAvailable()).         if (!inputGatesWithRemainingData.remove(inputGate)) {             throw new IllegalStateException("Couldn't find input gate in set of remaining " + "input gates.").         }     }     // Set the channel index to identify the input channel (across all unioned input gates)     final int channelIndexOffset = inputGateToIndexOffsetMap.get(inputGate).     bufferOrEvent.setChannelIndex(channelIndexOffset + bufferOrEvent.getChannelIndex()).     bufferOrEvent.setMoreAvailable(bufferOrEvent.moreAvailable() || inputGateWithData.moreInputGatesAvailable).     return Optional.of(bufferOrEvent). }
false;public;0;4;;@Override public Optional<BufferOrEvent> pollNextBufferOrEvent() throws UnsupportedOperationException {     throw new UnsupportedOperationException(). }
false;private;0;20;;private InputGateWithData waitAndGetNextInputGate() throws IOException, InterruptedException {     while (true) {         InputGate inputGate.         boolean moreInputGatesAvailable.         synchronized (inputGatesWithData) {             while (inputGatesWithData.size() == 0) {                 inputGatesWithData.wait().             }             inputGate = inputGatesWithData.remove().             enqueuedInputGatesWithData.remove(inputGate).             moreInputGatesAvailable = enqueuedInputGatesWithData.size() > 0.         }         // In case of inputGatesWithData being inaccurate do not block on an empty inputGate, but just poll the data.         Optional<BufferOrEvent> bufferOrEvent = inputGate.pollNextBufferOrEvent().         if (bufferOrEvent.isPresent()) {             return new InputGateWithData(inputGate, bufferOrEvent.get(), moreInputGatesAvailable).         }     } }
false;public;1;6;;@Override public void sendTaskEvent(TaskEvent event) throws IOException {     for (InputGate inputGate : inputGates) {         inputGate.sendTaskEvent(event).     } }
false;public;1;8;;@Override public void registerListener(InputGateListener listener) {     if (this.inputGateListener == null) {         this.inputGateListener = listener.     } else {         throw new IllegalStateException("Multiple listeners").     } }
false;public;0;12;;@Override public int getPageSize() {     int pageSize = -1.     for (InputGate gate : inputGates) {         if (pageSize == -1) {             pageSize = gate.getPageSize().         } else if (gate.getPageSize() != pageSize) {             throw new IllegalStateException("Found input gates with different page sizes.").         }     }     return pageSize. }
false;public;1;4;;@Override public void notifyInputGateNonEmpty(InputGate inputGate) {     queueInputGate(checkNotNull(inputGate)). }
false;private;1;25;;private void queueInputGate(InputGate inputGate) {     int availableInputGates.     synchronized (inputGatesWithData) {         if (enqueuedInputGatesWithData.contains(inputGate)) {             return.         }         availableInputGates = inputGatesWithData.size().         inputGatesWithData.add(inputGate).         enqueuedInputGatesWithData.add(inputGate).         if (availableInputGates == 0) {             inputGatesWithData.notifyAll().         }     }     if (availableInputGates == 0) {         InputGateListener listener = inputGateListener.         if (listener != null) {             listener.notifyInputGateNonEmpty(this).         }     } }
