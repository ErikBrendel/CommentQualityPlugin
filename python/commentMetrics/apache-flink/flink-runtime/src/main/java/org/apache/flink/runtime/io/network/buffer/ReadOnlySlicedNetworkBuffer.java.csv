commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ByteBuf unwrap() {     return super.unwrap(). }
false;public;0;4;;@Override public boolean isBuffer() {     return getBuffer().isBuffer(). }
false;public;0;4;;@Override public void tagAsEvent() {     throw new ReadOnlyBufferException(). }
true;public;0;4;/**  * Returns the underlying memory segment.  *  * <p><strong>BEWARE:</strong> Although we cannot set the memory segment read-only it should be  * handled as if it was!.  *  * @return the memory segment backing this buffer  */ ;/**  * Returns the underlying memory segment.  *  * <p><strong>BEWARE:</strong> Although we cannot set the memory segment read-only it should be  * handled as if it was!.  *  * @return the memory segment backing this buffer  */ @Override public MemorySegment getMemorySegment() {     return getBuffer().getMemorySegment(). }
false;public;0;4;;@Override public int getMemorySegmentOffset() {     return memorySegmentOffset. }
false;public;0;4;;@Override public BufferRecycler getRecycler() {     return getBuffer().getRecycler(). }
false;public;0;4;;@Override public void recycleBuffer() {     getBuffer().recycleBuffer(). }
false;public;0;4;;@Override public boolean isRecycled() {     return getBuffer().isRecycled(). }
false;public;0;5;;@Override public ReadOnlySlicedNetworkBuffer retainBuffer() {     getBuffer().retainBuffer().     return this. }
false;public;0;4;;@Override public ReadOnlySlicedNetworkBuffer readOnlySlice() {     return readOnlySlice(readerIndex(), readableBytes()). }
false;public;2;4;;@Override public ReadOnlySlicedNetworkBuffer readOnlySlice(int index, int length) {     return new ReadOnlySlicedNetworkBuffer(super.unwrap(), index, length, memorySegmentOffset). }
false;public;0;4;;@Override public int getMaxCapacity() {     return maxCapacity(). }
false;public;0;4;;@Override public int getReaderIndex() {     return readerIndex(). }
false;public;1;4;;@Override public void setReaderIndex(int readerIndex) throws IndexOutOfBoundsException {     readerIndex(readerIndex). }
false;public;0;4;;@Override public int getSizeUnsafe() {     return writerIndex(). }
false;public;0;4;;@Override public int getSize() {     return writerIndex(). }
false;public;1;4;;@Override public void setSize(int writerIndex) {     writerIndex(writerIndex). }
false;public;0;4;;@Override public ByteBuffer getNioBufferReadable() {     return nioBuffer(). }
false;public;2;4;;@Override public ByteBuffer getNioBuffer(int index, int length) throws IndexOutOfBoundsException {     return nioBuffer(index, length). }
false;public;2;4;;@Override public ByteBuffer nioBuffer(int index, int length) {     return super.nioBuffer(index, length).asReadOnlyBuffer(). }
false;public;0;4;;@Override public boolean isWritable() {     return false. }
false;public;1;4;;@Override public boolean isWritable(int numBytes) {     return false. }
false;public;1;8;;@Override public ByteBuf ensureWritable(int minWritableBytes) {     // note: ReadOnlyByteBuf allows this but in most cases this does not make sense     if (minWritableBytes != 0) {         throw new ReadOnlyBufferException().     }     return this. }
false;public;1;4;;@Override public void setAllocator(ByteBufAllocator allocator) {     getBuffer().setAllocator(allocator). }
false;public;0;4;;@Override public ByteBuf asByteBuf() {     return this. }
false;private;0;3;;private Buffer getBuffer() {     return ((Buffer) unwrap().unwrap()). }
