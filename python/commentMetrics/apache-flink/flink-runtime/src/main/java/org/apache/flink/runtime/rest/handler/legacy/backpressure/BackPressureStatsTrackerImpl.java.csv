commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Cleanup interval for completed stats cache.  */ ;/**  * Cleanup interval for completed stats cache.  */ public long getCleanUpInterval() {     return cleanUpInterval. }
true;public;1;9;/**  * Returns back pressure statistics for a operator. Automatically triggers stack trace sampling  * if statistics are not available or outdated.  *  * @param vertex Operator to get the stats for.  * @return Back pressure statistics for an operator  */ ;/**  * Returns back pressure statistics for a operator. Automatically triggers stack trace sampling  * if statistics are not available or outdated.  *  * @param vertex Operator to get the stats for.  * @return Back pressure statistics for an operator  */ public Optional<OperatorBackPressureStats> getOperatorBackPressureStats(ExecutionJobVertex vertex) {     synchronized (lock) {         final OperatorBackPressureStats stats = operatorStatsCache.getIfPresent(vertex).         if (stats == null || backPressureStatsRefreshInterval <= System.currentTimeMillis() - stats.getEndTimestamp()) {             triggerStackTraceSampleInternal(vertex).         }         return Optional.ofNullable(stats).     } }
true;private;1;34;/**  * Triggers a stack trace sample for a operator to gather the back pressure  * statistics. If there is a sample in progress for the operator, the call  * is ignored.  *  * @param vertex Operator to get the stats for.  * @return Flag indicating whether a sample with triggered.  */ ;/**  * Triggers a stack trace sample for a operator to gather the back pressure  * statistics. If there is a sample in progress for the operator, the call  * is ignored.  *  * @param vertex Operator to get the stats for.  * @return Flag indicating whether a sample with triggered.  */ private boolean triggerStackTraceSampleInternal(final ExecutionJobVertex vertex) {     assert (Thread.holdsLock(lock)).     if (shutDown) {         return false.     }     if (!pendingStats.contains(vertex) && !vertex.getGraph().getState().isGloballyTerminalState()) {         Executor executor = vertex.getGraph().getFutureExecutor().         // Only trigger if still active job         if (executor != null) {             pendingStats.add(vertex).             if (LOG.isDebugEnabled()) {                 LOG.debug("Triggering stack trace sample for tasks: " + Arrays.toString(vertex.getTaskVertices())).             }             CompletableFuture<StackTraceSample> sample = coordinator.triggerStackTraceSample(vertex.getTaskVertices(), numSamples, delayBetweenSamples, MAX_STACK_TRACE_DEPTH).             sample.handleAsync(new StackTraceSampleCompletionCallback(vertex), executor).             return true.         }     }     return false. }
true;public;1;6;/**  * Triggers a stack trace sample for a operator to gather the back pressure  * statistics. If there is a sample in progress for the operator, the call  * is ignored.  *  * @param vertex Operator to get the stats for.  * @return Flag indicating whether a sample with triggered.  * @deprecated {@link #getOperatorBackPressureStats(ExecutionJobVertex)} will trigger  * stack trace sampling automatically.  */ ;/**  * Triggers a stack trace sample for a operator to gather the back pressure  * statistics. If there is a sample in progress for the operator, the call  * is ignored.  *  * @param vertex Operator to get the stats for.  * @return Flag indicating whether a sample with triggered.  * @deprecated {@link #getOperatorBackPressureStats(ExecutionJobVertex)} will trigger  * stack trace sampling automatically.  */ @Deprecated public boolean triggerStackTraceSample(ExecutionJobVertex vertex) {     synchronized (lock) {         return triggerStackTraceSampleInternal(vertex).     } }
true;public;0;3;/**  * Cleans up the operator stats cache if it contains timed out entries.  *  * <p>The Guava cache only evicts as maintenance during normal operations.  * If this handler is inactive, it will never be cleaned.  */ ;/**  * Cleans up the operator stats cache if it contains timed out entries.  *  * <p>The Guava cache only evicts as maintenance during normal operations.  * If this handler is inactive, it will never be cleaned.  */ public void cleanUpOperatorStatsCache() {     operatorStatsCache.cleanUp(). }
true;public;0;10;/**  * Shuts down the stats tracker.  *  * <p>Invalidates the cache and clears all pending stats.  */ ;/**  * Shuts down the stats tracker.  *  * <p>Invalidates the cache and clears all pending stats.  */ public void shutDown() {     synchronized (lock) {         if (!shutDown) {             operatorStatsCache.invalidateAll().             pendingStats.clear().             shutDown = true.         }     } }
true;;0;3;/**  * Invalidates the cache (irrespective of clean up interval).  */ ;/**  * Invalidates the cache (irrespective of clean up interval).  */ void invalidateOperatorStatsCache() {     operatorStatsCache.invalidateAll(). }
false;public;2;27;;@Override public Void apply(StackTraceSample stackTraceSample, Throwable throwable) {     synchronized (lock) {         try {             if (shutDown) {                 return null.             }             // Job finished, ignore.             JobStatus jobState = vertex.getGraph().getState().             if (jobState.isGloballyTerminalState()) {                 LOG.debug("Ignoring sample, because job is in state " + jobState + ".").             } else if (stackTraceSample != null) {                 OperatorBackPressureStats stats = createStatsFromSample(stackTraceSample).                 operatorStatsCache.put(vertex, stats).             } else {                 LOG.debug("Failed to gather stack trace sample.", throwable).             }         } catch (Throwable t) {             LOG.error("Error during stats completion.", t).         } finally {             pendingStats.remove(vertex).         }         return null.     } }
true;private;1;57;/**  * Creates the back pressure stats from a stack trace sample.  *  * @param sample Stack trace sample to base stats on.  *  * @return Back pressure stats  */ ;/**  * Creates the back pressure stats from a stack trace sample.  *  * @param sample Stack trace sample to base stats on.  *  * @return Back pressure stats  */ private OperatorBackPressureStats createStatsFromSample(StackTraceSample sample) {     Map<ExecutionAttemptID, List<StackTraceElement[]>> traces = sample.getStackTraces().     // Map task ID to subtask index, because the web interface expects     // it like that.     Map<ExecutionAttemptID, Integer> subtaskIndexMap = Maps.newHashMapWithExpectedSize(traces.size()).     Set<ExecutionAttemptID> sampledTasks = sample.getStackTraces().keySet().     for (ExecutionVertex task : vertex.getTaskVertices()) {         ExecutionAttemptID taskId = task.getCurrentExecutionAttempt().getAttemptId().         if (sampledTasks.contains(taskId)) {             subtaskIndexMap.put(taskId, task.getParallelSubtaskIndex()).         } else {             LOG.debug("Outdated sample. A task, which is part of the " + "sample has been reset.").         }     }     // Ratio of blocked samples to total samples per sub task. Array     // position corresponds to sub task index.     double[] backPressureRatio = new double[traces.size()].     for (Entry<ExecutionAttemptID, List<StackTraceElement[]>> entry : traces.entrySet()) {         int backPressureSamples = 0.         List<StackTraceElement[]> taskTraces = entry.getValue().         for (StackTraceElement[] trace : taskTraces) {             for (int i = trace.length - 1. i >= 0. i--) {                 StackTraceElement elem = trace[i].                 if (elem.getClassName().equals(EXPECTED_CLASS_NAME) && elem.getMethodName().equals(EXPECTED_METHOD_NAME)) {                     backPressureSamples++.                     // Continue with next stack trace                     break.                 }             }         }         int subtaskIndex = subtaskIndexMap.get(entry.getKey()).         int size = taskTraces.size().         double ratio = (size > 0) ? ((double) backPressureSamples) / size : 0.         backPressureRatio[subtaskIndex] = ratio.     }     return new OperatorBackPressureStats(sample.getSampleId(), sample.getEndTime(), backPressureRatio). }
