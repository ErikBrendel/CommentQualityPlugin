commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void write(int b) throws IOException {     writeLength(1, socketStream).     socketStream.write(b).     md.update((byte) b). }
false;public;3;20;;@Override public void write(byte[] b, int off, int len) throws IOException {     // Send the value in iterations of BUFFER_SIZE     int remainingBytes = len.     while (remainingBytes > 0) {         // want a common code path for byte[] and InputStream at the BlobServer         // -> since for InputStream we don't know a total size beforehand, send lengths iteratively         final int bytesToSend = Math.min(BUFFER_SIZE, remainingBytes).         writeLength(bytesToSend, socketStream).         socketStream.write(b, off, bytesToSend).         // Update the message digest         md.update(b, off, bytesToSend).         remainingBytes -= bytesToSend.         off += bytesToSend.     } }
false;public;0;8;;public BlobKey finish() throws IOException {     // send -1 as the stream end     writeLength(-1, socketStream).     // Receive blob key and compare     final InputStream is = this.socket.getInputStream().     return receiveAndCheckPutResponse(is, md, blobType). }
true;private,static;3;13;/**  * Constructs and writes the header data for a PUT request to the given output stream.  *  * @param outputStream  * 		the output stream to write the PUT header data to  * @param jobId  * 		the ID of job the BLOB belongs to (or <tt>null</tt> if job-unrelated)  * @param blobType  * 		whether the BLOB should become permanent or transient  *  * @throws IOException  * 		thrown if an I/O error occurs while writing the header data to the output stream  */ ;/**  * Constructs and writes the header data for a PUT request to the given output stream.  *  * @param outputStream  * 		the output stream to write the PUT header data to  * @param jobId  * 		the ID of job the BLOB belongs to (or <tt>null</tt> if job-unrelated)  * @param blobType  * 		whether the BLOB should become permanent or transient  *  * @throws IOException  * 		thrown if an I/O error occurs while writing the header data to the output stream  */ private static void sendPutHeader(OutputStream outputStream, @Nullable JobID jobId, BlobKey.BlobType blobType) throws IOException {     // Signal type of operation     outputStream.write(PUT_OPERATION).     if (jobId == null) {         outputStream.write(JOB_UNRELATED_CONTENT).     } else {         outputStream.write(JOB_RELATED_CONTENT).         outputStream.write(jobId.getBytes()).     }     outputStream.write(blobType.ordinal()). }
true;private,static;3;29;/**  * Reads the response from the input stream and throws in case of errors.  *  * @param is  * 		stream to read from  * @param md  * 		message digest to check the response against  * @param blobType  * 		whether the BLOB should be permanent or transient  *  * @throws IOException  * 		if the response is an error, the message digest does not match or reading the response  * 		failed  */ ;/**  * Reads the response from the input stream and throws in case of errors.  *  * @param is  * 		stream to read from  * @param md  * 		message digest to check the response against  * @param blobType  * 		whether the BLOB should be permanent or transient  *  * @throws IOException  * 		if the response is an error, the message digest does not match or reading the response  * 		failed  */ private static BlobKey receiveAndCheckPutResponse(InputStream is, MessageDigest md, BlobKey.BlobType blobType) throws IOException {     int response = is.read().     if (response < 0) {         throw new EOFException("Premature end of response").     } else if (response == RETURN_OKAY) {         BlobKey remoteKey = BlobKey.readFromInputStream(is).         byte[] localHash = md.digest().         if (blobType != remoteKey.getType()) {             throw new IOException("Detected data corruption during transfer").         }         if (!Arrays.equals(localHash, remoteKey.getHash())) {             throw new IOException("Detected data corruption during transfer").         }         return remoteKey.     } else if (response == RETURN_ERROR) {         Throwable cause = BlobUtils.readExceptionFromStream(is).         throw new IOException("Server side error: " + cause.getMessage(), cause).     } else {         throw new IOException("Unrecognized response: " + response + '.').     } }
