commented;modifiers;parameterAmount;loc;comment;code
false;;1;3;;<V> TtlValue<V> filterTtlValue(TtlValue<V> value) {     return expired(value) ? null : value. }
false;private;1;3;;private boolean expired(TtlValue<?> ttlValue) {     return expired(ttlValue.getLastAccessTimestamp()). }
false;;1;3;;boolean expired(long ts) {     return TtlUtils.expired(ts, ttl, ttlTimeProvider). }
false;;1;4;;long deserializeTs(byte[] value) throws IOException {     div.setBuffer(value, 0, Long.BYTES).     return LongSerializer.INSTANCE.deserialize(div). }
false;public;0;4;;@Override public TransformStrategy getFilterStrategy() {     return TransformStrategy.STOP_ON_FIRST_INCLUDED. }
false;public;1;5;;@Override @Nullable public TtlValue<T> filterOrTransform(@Nullable TtlValue<T> value) {     return filterTtlValue(value). }
false;public;1;14;;@Override @Nullable public byte[] filterOrTransform(@Nullable byte[] value) {     if (value == null) {         return null.     }     long ts.     try {         ts = deserializeTs(value).     } catch (IOException e) {         throw new FlinkRuntimeException("Unexpected timestamp deserialization failure", e).     }     return expired(ts) ? null : value. }
false;public;0;4;;@Override public Optional<StateSnapshotTransformer<TtlValue<T>>> createForDeserializedState() {     return Optional.of(new TtlDeserializedValueStateSnapshotTransformer<>(ttlTimeProvider, ttl)). }
false;public;0;4;;@Override public Optional<StateSnapshotTransformer<byte[]>> createForSerializedState() {     return Optional.of(new TtlSerializedValueStateSnapshotTransformer(ttlTimeProvider, ttl)). }
