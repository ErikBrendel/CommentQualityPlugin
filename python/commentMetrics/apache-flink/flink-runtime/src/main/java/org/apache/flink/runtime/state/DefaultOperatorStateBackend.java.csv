commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public ExecutionConfig getExecutionConfig() {     return executionConfig. }
false;public;0;4;;@Override public Set<String> getRegisteredStateNames() {     return registeredOperatorStates.keySet(). }
false;public;0;4;;@Override public Set<String> getRegisteredBroadcastStateNames() {     return registeredBroadcastStates.keySet(). }
false;public;0;4;;@Override public void close() throws IOException {     closeStreamOnCancelRegistry.close(). }
false;public;0;6;;@Override public void dispose() {     IOUtils.closeQuietly(closeStreamOnCancelRegistry).     registeredOperatorStates.clear().     registeredBroadcastStates.clear(). }
false;public;1;64;;// ------------------------------------------------------------------------------------------- // State access methods // ------------------------------------------------------------------------------------------- @SuppressWarnings("unchecked") @Override public <K, V> BroadcastState<K, V> getBroadcastState(final MapStateDescriptor<K, V> stateDescriptor) throws StateMigrationException {     Preconditions.checkNotNull(stateDescriptor).     String name = Preconditions.checkNotNull(stateDescriptor.getName()).     BackendWritableBroadcastState<K, V> previous = (BackendWritableBroadcastState<K, V>) accessedBroadcastStatesByName.get(name).     if (previous != null) {         checkStateNameAndMode(previous.getStateMetaInfo().getName(), name, previous.getStateMetaInfo().getAssignmentMode(), OperatorStateHandle.Mode.BROADCAST).         return previous.     }     stateDescriptor.initializeSerializerUnlessSet(getExecutionConfig()).     TypeSerializer<K> broadcastStateKeySerializer = Preconditions.checkNotNull(stateDescriptor.getKeySerializer()).     TypeSerializer<V> broadcastStateValueSerializer = Preconditions.checkNotNull(stateDescriptor.getValueSerializer()).     BackendWritableBroadcastState<K, V> broadcastState = (BackendWritableBroadcastState<K, V>) registeredBroadcastStates.get(name).     if (broadcastState == null) {         broadcastState = new HeapBroadcastState<>(new RegisteredBroadcastStateBackendMetaInfo<>(name, OperatorStateHandle.Mode.BROADCAST, broadcastStateKeySerializer, broadcastStateValueSerializer)).         registeredBroadcastStates.put(name, broadcastState).     } else {         // has restored state. check compatibility of new state access         checkStateNameAndMode(broadcastState.getStateMetaInfo().getName(), name, broadcastState.getStateMetaInfo().getAssignmentMode(), OperatorStateHandle.Mode.BROADCAST).         RegisteredBroadcastStateBackendMetaInfo<K, V> restoredBroadcastStateMetaInfo = broadcastState.getStateMetaInfo().         // check whether new serializers are incompatible         TypeSerializerSchemaCompatibility<K> keyCompatibility = restoredBroadcastStateMetaInfo.updateKeySerializer(broadcastStateKeySerializer).         if (keyCompatibility.isIncompatible()) {             throw new StateMigrationException("The new key serializer for broadcast state must not be incompatible.").         }         TypeSerializerSchemaCompatibility<V> valueCompatibility = restoredBroadcastStateMetaInfo.updateValueSerializer(broadcastStateValueSerializer).         if (valueCompatibility.isIncompatible()) {             throw new StateMigrationException("The new value serializer for broadcast state must not be incompatible.").         }         broadcastState.setStateMetaInfo(restoredBroadcastStateMetaInfo).     }     accessedBroadcastStatesByName.put(name, broadcastState).     return broadcastState. }
false;public;1;4;;@Override public <S> ListState<S> getListState(ListStateDescriptor<S> stateDescriptor) throws Exception {     return getListState(stateDescriptor, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE). }
false;public;1;4;;@Override public <S> ListState<S> getUnionListState(ListStateDescriptor<S> stateDescriptor) throws Exception {     return getListState(stateDescriptor, OperatorStateHandle.Mode.UNION). }
true;public;1;5;/**  * @deprecated This was deprecated as part of a refinement to the function names.  *             Please use {@link #getListState(ListStateDescriptor)} instead.  */ ;// ------------------------------------------------------------------------------------------- // Deprecated state access methods // ------------------------------------------------------------------------------------------- /**  * @deprecated This was deprecated as part of a refinement to the function names.  *             Please use {@link #getListState(ListStateDescriptor)} instead.  */ @Deprecated @Override public <S> ListState<S> getOperatorState(ListStateDescriptor<S> stateDescriptor) throws Exception {     return getListState(stateDescriptor). }
true;public;1;6;/**  * @deprecated Using Java serialization for persisting state is not encouraged.  *             Please use {@link #getListState(ListStateDescriptor)} instead.  */ ;/**  * @deprecated Using Java serialization for persisting state is not encouraged.  *             Please use {@link #getListState(ListStateDescriptor)} instead.  */ @SuppressWarnings("unchecked") @Deprecated @Override public <T extends Serializable> ListState<T> getSerializableListState(String stateName) throws Exception {     return (ListState<T>) getListState(new ListStateDescriptor<>(stateName, javaSerializer)). }
false;public;1;116;;// ------------------------------------------------------------------------------------------- // Snapshot and restore // ------------------------------------------------------------------------------------------- public void restore(Collection<OperatorStateHandle> restoreSnapshots) throws Exception {     if (null == restoreSnapshots || restoreSnapshots.isEmpty()) {         return.     }     for (OperatorStateHandle stateHandle : restoreSnapshots) {         if (stateHandle == null) {             continue.         }         FSDataInputStream in = stateHandle.openInputStream().         closeStreamOnCancelRegistry.registerCloseable(in).         ClassLoader restoreClassLoader = Thread.currentThread().getContextClassLoader().         try {             Thread.currentThread().setContextClassLoader(userClassloader).             OperatorBackendSerializationProxy backendSerializationProxy = new OperatorBackendSerializationProxy(userClassloader).             backendSerializationProxy.read(new DataInputViewStreamWrapper(in)).             List<StateMetaInfoSnapshot> restoredOperatorMetaInfoSnapshots = backendSerializationProxy.getOperatorStateMetaInfoSnapshots().             // Recreate all PartitionableListStates from the meta info             for (StateMetaInfoSnapshot restoredSnapshot : restoredOperatorMetaInfoSnapshots) {                 final RegisteredOperatorStateBackendMetaInfo<?> restoredMetaInfo = new RegisteredOperatorStateBackendMetaInfo<>(restoredSnapshot).                 if (restoredMetaInfo.getPartitionStateSerializer() instanceof UnloadableDummyTypeSerializer) {                     throw new IOException("Unable to restore operator state [" + restoredSnapshot.getName() + "]." + " The previous serializer of the operator state must be present. the serializer could" + " have been removed from the classpath, or its implementation have changed and could" + " not be loaded. This is a temporary restriction that will be fixed in future versions.").                 }                 PartitionableListState<?> listState = registeredOperatorStates.get(restoredSnapshot.getName()).                 if (null == listState) {                     listState = new PartitionableListState<>(restoredMetaInfo).                     registeredOperatorStates.put(listState.getStateMetaInfo().getName(), listState).                 } else {                 // TODO with eager state registration in place, check here for serializer migration strategies                 }             }             // ... and then get back the broadcast state.             List<StateMetaInfoSnapshot> restoredBroadcastMetaInfoSnapshots = backendSerializationProxy.getBroadcastStateMetaInfoSnapshots().             for (StateMetaInfoSnapshot restoredSnapshot : restoredBroadcastMetaInfoSnapshots) {                 final RegisteredBroadcastStateBackendMetaInfo<?, ?> restoredMetaInfo = new RegisteredBroadcastStateBackendMetaInfo<>(restoredSnapshot).                 if (restoredMetaInfo.getKeySerializer() instanceof UnloadableDummyTypeSerializer || restoredMetaInfo.getValueSerializer() instanceof UnloadableDummyTypeSerializer) {                     throw new IOException("Unable to restore broadcast state [" + restoredSnapshot.getName() + "]." + " The previous key and value serializers of the state must be present. the serializers could" + " have been removed from the classpath, or their implementations have changed and could" + " not be loaded. This is a temporary restriction that will be fixed in future versions.").                 }                 BackendWritableBroadcastState<?, ?> broadcastState = registeredBroadcastStates.get(restoredSnapshot.getName()).                 if (broadcastState == null) {                     broadcastState = new HeapBroadcastState<>(restoredMetaInfo).                     registeredBroadcastStates.put(broadcastState.getStateMetaInfo().getName(), broadcastState).                 } else {                 // TODO with eager state registration in place, check here for serializer migration strategies                 }             }             // Restore all the states             for (Map.Entry<String, OperatorStateHandle.StateMetaInfo> nameToOffsets : stateHandle.getStateNameToPartitionOffsets().entrySet()) {                 final String stateName = nameToOffsets.getKey().                 PartitionableListState<?> listStateForName = registeredOperatorStates.get(stateName).                 if (listStateForName == null) {                     BackendWritableBroadcastState<?, ?> broadcastStateForName = registeredBroadcastStates.get(stateName).                     Preconditions.checkState(broadcastStateForName != null, "Found state without " + "corresponding meta info: " + stateName).                     deserializeBroadcastStateValues(broadcastStateForName, in, nameToOffsets.getValue()).                 } else {                     deserializeOperatorStateValues(listStateForName, in, nameToOffsets.getValue()).                 }             }         } finally {             Thread.currentThread().setContextClassLoader(restoreClassLoader).             if (closeStreamOnCancelRegistry.unregisterCloseable(in)) {                 IOUtils.closeQuietly(in).             }         }     } }
false;public;4;16;;@Nonnull @Override public RunnableFuture<SnapshotResult<OperatorStateHandle>> snapshot(long checkpointId, long timestamp, @Nonnull CheckpointStreamFactory streamFactory, @Nonnull CheckpointOptions checkpointOptions) throws Exception {     long syncStartTime = System.currentTimeMillis().     RunnableFuture<SnapshotResult<OperatorStateHandle>> snapshotRunner = snapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions).     snapshotStrategy.logSyncCompleted(streamFactory, syncStartTime).     return snapshotRunner. }
false;public;1;3;;public void setStateMetaInfo(RegisteredOperatorStateBackendMetaInfo<S> stateMetaInfo) {     this.stateMetaInfo = stateMetaInfo. }
false;public;0;3;;public RegisteredOperatorStateBackendMetaInfo<S> getStateMetaInfo() {     return stateMetaInfo. }
false;public;0;3;;public PartitionableListState<S> deepCopy() {     return new PartitionableListState<>(this). }
false;public;0;4;;@Override public void clear() {     internalList.clear(). }
false;public;0;4;;@Override public Iterable<S> get() {     return internalList. }
false;public;1;5;;@Override public void add(S value) {     Preconditions.checkNotNull(value, "You cannot add null to a ListState.").     internalList.add(value). }
false;public;0;7;;@Override public String toString() {     return "PartitionableListState{" + "stateMetaInfo=" + stateMetaInfo + ", internalList=" + internalList + '}'. }
false;public;1;14;;public long[] write(FSDataOutputStream out) throws IOException {     long[] partitionOffsets = new long[internalList.size()].     DataOutputView dov = new DataOutputViewStreamWrapper(out).     for (int i = 0. i < internalList.size(). ++i) {         S element = internalList.get(i).         partitionOffsets[i] = out.getPos().         getStateMetaInfo().getPartitionStateSerializer().serialize(element, dov).     }     return partitionOffsets. }
false;public;1;6;;@Override public void update(List<S> values) {     internalList.clear().     addAll(values). }
false;public;1;6;;@Override public void addAll(List<S> values) {     if (values != null && !values.isEmpty()) {         internalList.addAll(values).     } }
false;private;2;65;;private <S> ListState<S> getListState(ListStateDescriptor<S> stateDescriptor, OperatorStateHandle.Mode mode) throws StateMigrationException {     Preconditions.checkNotNull(stateDescriptor).     String name = Preconditions.checkNotNull(stateDescriptor.getName()).     @SuppressWarnings("unchecked")     PartitionableListState<S> previous = (PartitionableListState<S>) accessedStatesByName.get(name).     if (previous != null) {         checkStateNameAndMode(previous.getStateMetaInfo().getName(), name, previous.getStateMetaInfo().getAssignmentMode(), mode).         return previous.     }     // end up here if its the first time access after execution for the     // provided state name. check compatibility of restored state, if any     // TODO with eager registration in place, these checks should be moved to restore()     stateDescriptor.initializeSerializerUnlessSet(getExecutionConfig()).     TypeSerializer<S> partitionStateSerializer = Preconditions.checkNotNull(stateDescriptor.getElementSerializer()).     @SuppressWarnings("unchecked")     PartitionableListState<S> partitionableListState = (PartitionableListState<S>) registeredOperatorStates.get(name).     if (null == partitionableListState) {         // no restored state for the state name. simply create new state holder         partitionableListState = new PartitionableListState<>(new RegisteredOperatorStateBackendMetaInfo<>(name, partitionStateSerializer, mode)).         registeredOperatorStates.put(name, partitionableListState).     } else {         // has restored state. check compatibility of new state access         checkStateNameAndMode(partitionableListState.getStateMetaInfo().getName(), name, partitionableListState.getStateMetaInfo().getAssignmentMode(), mode).         RegisteredOperatorStateBackendMetaInfo<S> restoredPartitionableListStateMetaInfo = partitionableListState.getStateMetaInfo().         // check compatibility to determine if new serializers are incompatible         TypeSerializer<S> newPartitionStateSerializer = partitionStateSerializer.duplicate().         TypeSerializerSchemaCompatibility<S> stateCompatibility = restoredPartitionableListStateMetaInfo.updatePartitionStateSerializer(newPartitionStateSerializer).         if (stateCompatibility.isIncompatible()) {             throw new StateMigrationException("The new state serializer for operator state must not be incompatible.").         }         partitionableListState.setStateMetaInfo(restoredPartitionableListStateMetaInfo).     }     accessedStatesByName.put(name, partitionableListState).     return partitionableListState. }
false;private,static;3;17;;private static <S> void deserializeOperatorStateValues(PartitionableListState<S> stateListForName, FSDataInputStream in, OperatorStateHandle.StateMetaInfo metaInfo) throws IOException {     if (null != metaInfo) {         long[] offsets = metaInfo.getOffsets().         if (null != offsets) {             DataInputView div = new DataInputViewStreamWrapper(in).             TypeSerializer<S> serializer = stateListForName.getStateMetaInfo().getPartitionStateSerializer().             for (long offset : offsets) {                 in.seek(offset).                 stateListForName.add(serializer.deserialize(div)).             }         }     } }
false;private,static;3;22;;private static <K, V> void deserializeBroadcastStateValues(final BackendWritableBroadcastState<K, V> broadcastStateForName, final FSDataInputStream in, final OperatorStateHandle.StateMetaInfo metaInfo) throws Exception {     if (metaInfo != null) {         long[] offsets = metaInfo.getOffsets().         if (offsets != null) {             TypeSerializer<K> keySerializer = broadcastStateForName.getStateMetaInfo().getKeySerializer().             TypeSerializer<V> valueSerializer = broadcastStateForName.getStateMetaInfo().getValueSerializer().             in.seek(offsets[0]).             DataInputView div = new DataInputViewStreamWrapper(in).             int size = div.readInt().             for (int i = 0. i < size. i++) {                 broadcastStateForName.put(keySerializer.deserialize(div), valueSerializer.deserialize(div)).             }         }     } }
false;private,static;4;18;;private static void checkStateNameAndMode(String actualName, String expectedName, OperatorStateHandle.Mode actualMode, OperatorStateHandle.Mode expectedMode) {     Preconditions.checkState(actualName.equals(expectedName), "Incompatible state names. " + "Was [" + actualName + "], " + "registered with [" + expectedName + "].").     Preconditions.checkState(actualMode.equals(expectedMode), "Incompatible state assignment modes. " + "Was [" + actualMode + "], " + "registered with [" + expectedMode + "]."). }
false;protected;0;80;;@Override protected SnapshotResult<OperatorStateHandle> callInternal() throws Exception {     CheckpointStreamFactory.CheckpointStateOutputStream localOut = streamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE).     snapshotCloseableRegistry.registerCloseable(localOut).     // get the registered operator state infos ...     List<StateMetaInfoSnapshot> operatorMetaInfoSnapshots = new ArrayList<>(registeredOperatorStatesDeepCopies.size()).     for (Map.Entry<String, PartitionableListState<?>> entry : registeredOperatorStatesDeepCopies.entrySet()) {         operatorMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot()).     }     // ... get the registered broadcast operator state infos ...     List<StateMetaInfoSnapshot> broadcastMetaInfoSnapshots = new ArrayList<>(registeredBroadcastStatesDeepCopies.size()).     for (Map.Entry<String, BackendWritableBroadcastState<?, ?>> entry : registeredBroadcastStatesDeepCopies.entrySet()) {         broadcastMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot()).     }     // ... write them all in the checkpoint stream ...     DataOutputView dov = new DataOutputViewStreamWrapper(localOut).     OperatorBackendSerializationProxy backendSerializationProxy = new OperatorBackendSerializationProxy(operatorMetaInfoSnapshots, broadcastMetaInfoSnapshots).     backendSerializationProxy.write(dov).     // ... and then go for the states ...     // we put BOTH normal and broadcast state metadata here     int initialMapCapacity = registeredOperatorStatesDeepCopies.size() + registeredBroadcastStatesDeepCopies.size().     final Map<String, OperatorStateHandle.StateMetaInfo> writtenStatesMetaData = new HashMap<>(initialMapCapacity).     for (Map.Entry<String, PartitionableListState<?>> entry : registeredOperatorStatesDeepCopies.entrySet()) {         PartitionableListState<?> value = entry.getValue().         long[] partitionOffsets = value.write(localOut).         OperatorStateHandle.Mode mode = value.getStateMetaInfo().getAssignmentMode().         writtenStatesMetaData.put(entry.getKey(), new OperatorStateHandle.StateMetaInfo(partitionOffsets, mode)).     }     // ... and the broadcast states themselves ...     for (Map.Entry<String, BackendWritableBroadcastState<?, ?>> entry : registeredBroadcastStatesDeepCopies.entrySet()) {         BackendWritableBroadcastState<?, ?> value = entry.getValue().         long[] partitionOffsets = { value.write(localOut) }.         OperatorStateHandle.Mode mode = value.getStateMetaInfo().getAssignmentMode().         writtenStatesMetaData.put(entry.getKey(), new OperatorStateHandle.StateMetaInfo(partitionOffsets, mode)).     }     // ... and, finally, create the state handle.     OperatorStateHandle retValue = null.     if (snapshotCloseableRegistry.unregisterCloseable(localOut)) {         StreamStateHandle stateHandle = localOut.closeAndGetHandle().         if (stateHandle != null) {             retValue = new OperatorStreamStateHandle(writtenStatesMetaData, stateHandle).         }         return SnapshotResult.of(retValue).     } else {         throw new IOException("Stream was already unregistered.").     } }
false;protected;0;4;;@Override protected void cleanupProvidedResources() { // nothing to do }
false;protected;1;6;;@Override protected void logAsyncSnapshotComplete(long startTime) {     if (asynchronousSnapshots) {         logAsyncCompleted(streamFactory, startTime).     } }
false;public;4;152;;@Nonnull @Override public RunnableFuture<SnapshotResult<OperatorStateHandle>> snapshot(final long checkpointId, final long timestamp, @Nonnull final CheckpointStreamFactory streamFactory, @Nonnull final CheckpointOptions checkpointOptions) throws IOException {     if (registeredOperatorStates.isEmpty() && registeredBroadcastStates.isEmpty()) {         return DoneFuture.of(SnapshotResult.empty()).     }     final Map<String, PartitionableListState<?>> registeredOperatorStatesDeepCopies = new HashMap<>(registeredOperatorStates.size()).     final Map<String, BackendWritableBroadcastState<?, ?>> registeredBroadcastStatesDeepCopies = new HashMap<>(registeredBroadcastStates.size()).     ClassLoader snapshotClassLoader = Thread.currentThread().getContextClassLoader().     Thread.currentThread().setContextClassLoader(userClassloader).     try {         if (!registeredOperatorStates.isEmpty()) {             for (Map.Entry<String, PartitionableListState<?>> entry : registeredOperatorStates.entrySet()) {                 PartitionableListState<?> listState = entry.getValue().                 if (null != listState) {                     listState = listState.deepCopy().                 }                 registeredOperatorStatesDeepCopies.put(entry.getKey(), listState).             }         }         if (!registeredBroadcastStates.isEmpty()) {             for (Map.Entry<String, BackendWritableBroadcastState<?, ?>> entry : registeredBroadcastStates.entrySet()) {                 BackendWritableBroadcastState<?, ?> broadcastState = entry.getValue().                 if (null != broadcastState) {                     broadcastState = broadcastState.deepCopy().                 }                 registeredBroadcastStatesDeepCopies.put(entry.getKey(), broadcastState).             }         }     } finally {         Thread.currentThread().setContextClassLoader(snapshotClassLoader).     }     AsyncSnapshotCallable<SnapshotResult<OperatorStateHandle>> snapshotCallable = new AsyncSnapshotCallable<SnapshotResult<OperatorStateHandle>>() {          @Override         protected SnapshotResult<OperatorStateHandle> callInternal() throws Exception {             CheckpointStreamFactory.CheckpointStateOutputStream localOut = streamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE).             snapshotCloseableRegistry.registerCloseable(localOut).             // get the registered operator state infos ...             List<StateMetaInfoSnapshot> operatorMetaInfoSnapshots = new ArrayList<>(registeredOperatorStatesDeepCopies.size()).             for (Map.Entry<String, PartitionableListState<?>> entry : registeredOperatorStatesDeepCopies.entrySet()) {                 operatorMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot()).             }             // ... get the registered broadcast operator state infos ...             List<StateMetaInfoSnapshot> broadcastMetaInfoSnapshots = new ArrayList<>(registeredBroadcastStatesDeepCopies.size()).             for (Map.Entry<String, BackendWritableBroadcastState<?, ?>> entry : registeredBroadcastStatesDeepCopies.entrySet()) {                 broadcastMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot()).             }             // ... write them all in the checkpoint stream ...             DataOutputView dov = new DataOutputViewStreamWrapper(localOut).             OperatorBackendSerializationProxy backendSerializationProxy = new OperatorBackendSerializationProxy(operatorMetaInfoSnapshots, broadcastMetaInfoSnapshots).             backendSerializationProxy.write(dov).             // ... and then go for the states ...             // we put BOTH normal and broadcast state metadata here             int initialMapCapacity = registeredOperatorStatesDeepCopies.size() + registeredBroadcastStatesDeepCopies.size().             final Map<String, OperatorStateHandle.StateMetaInfo> writtenStatesMetaData = new HashMap<>(initialMapCapacity).             for (Map.Entry<String, PartitionableListState<?>> entry : registeredOperatorStatesDeepCopies.entrySet()) {                 PartitionableListState<?> value = entry.getValue().                 long[] partitionOffsets = value.write(localOut).                 OperatorStateHandle.Mode mode = value.getStateMetaInfo().getAssignmentMode().                 writtenStatesMetaData.put(entry.getKey(), new OperatorStateHandle.StateMetaInfo(partitionOffsets, mode)).             }             // ... and the broadcast states themselves ...             for (Map.Entry<String, BackendWritableBroadcastState<?, ?>> entry : registeredBroadcastStatesDeepCopies.entrySet()) {                 BackendWritableBroadcastState<?, ?> value = entry.getValue().                 long[] partitionOffsets = { value.write(localOut) }.                 OperatorStateHandle.Mode mode = value.getStateMetaInfo().getAssignmentMode().                 writtenStatesMetaData.put(entry.getKey(), new OperatorStateHandle.StateMetaInfo(partitionOffsets, mode)).             }             // ... and, finally, create the state handle.             OperatorStateHandle retValue = null.             if (snapshotCloseableRegistry.unregisterCloseable(localOut)) {                 StreamStateHandle stateHandle = localOut.closeAndGetHandle().                 if (stateHandle != null) {                     retValue = new OperatorStreamStateHandle(writtenStatesMetaData, stateHandle).                 }                 return SnapshotResult.of(retValue).             } else {                 throw new IOException("Stream was already unregistered.").             }         }          @Override         protected void cleanupProvidedResources() {         // nothing to do         }          @Override         protected void logAsyncSnapshotComplete(long startTime) {             if (asynchronousSnapshots) {                 logAsyncCompleted(streamFactory, startTime).             }         }     }.     final FutureTask<SnapshotResult<OperatorStateHandle>> task = snapshotCallable.toAsyncSnapshotFutureTask(closeStreamOnCancelRegistry).     if (!asynchronousSnapshots) {         task.run().     }     return task. }
