commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Returns the {@link TypeSerializer} for the type of key this state is associated to.  */ ;/**  * Returns the {@link TypeSerializer} for the type of key this state is associated to.  */ TypeSerializer<K> getKeySerializer().
true;;0;1;/**  * Returns the {@link TypeSerializer} for the type of namespace this state is associated to.  */ ;/**  * Returns the {@link TypeSerializer} for the type of namespace this state is associated to.  */ TypeSerializer<N> getNamespaceSerializer().
true;;0;1;/**  * Returns the {@link TypeSerializer} for the type of value this state holds.  */ ;/**  * Returns the {@link TypeSerializer} for the type of value this state holds.  */ TypeSerializer<V> getValueSerializer().
true;;1;1;/**  * Sets the current namespace, which will be used when using the state access methods.  *  * @param namespace The namespace.  */ ;/**  * Sets the current namespace, which will be used when using the state access methods.  *  * @param namespace The namespace.  */ void setCurrentNamespace(N namespace).
true;;4;5;/**  * Returns the serialized value for the given key and namespace.  *  * <p>If no value is associated with key and namespace, <code>null</code>  * is returned.  *  * <p><b>TO IMPLEMENTERS:</b> This method is called by multiple threads. Anything  * stateful (e.g. serializers) should be either duplicated or protected from undesired  * consequences of concurrent invocations.  *  * @param serializedKeyAndNamespace Serialized key and namespace  * @param safeKeySerializer A key serializer which is safe to be used even in multi-threaded context  * @param safeNamespaceSerializer A namespace serializer which is safe to be used even in multi-threaded context  * @param safeValueSerializer A value serializer which is safe to be used even in multi-threaded context  * @return Serialized value or <code>null</code> if no value is associated with the key and namespace.  *  * @throws Exception Exceptions during serialization are forwarded  */ ;/**  * Returns the serialized value for the given key and namespace.  *  * <p>If no value is associated with key and namespace, <code>null</code>  * is returned.  *  * <p><b>TO IMPLEMENTERS:</b> This method is called by multiple threads. Anything  * stateful (e.g. serializers) should be either duplicated or protected from undesired  * consequences of concurrent invocations.  *  * @param serializedKeyAndNamespace Serialized key and namespace  * @param safeKeySerializer A key serializer which is safe to be used even in multi-threaded context  * @param safeNamespaceSerializer A namespace serializer which is safe to be used even in multi-threaded context  * @param safeValueSerializer A value serializer which is safe to be used even in multi-threaded context  * @return Serialized value or <code>null</code> if no value is associated with the key and namespace.  *  * @throws Exception Exceptions during serialization are forwarded  */ byte[] getSerializedValue(final byte[] serializedKeyAndNamespace, final TypeSerializer<K> safeKeySerializer, final TypeSerializer<N> safeNamespaceSerializer, final TypeSerializer<V> safeValueSerializer) throws Exception.
true;;1;1;/**  * Get global visitor of state entries.  *  * @param recommendedMaxNumberOfReturnedRecords hint to the visitor not to exceed this number of returned records  *                                              per {@code nextEntries} call, it can still be exceeded  *                                              by some smaller constant.  * @return global iterator over state entries  */ ;/**  * Get global visitor of state entries.  *  * @param recommendedMaxNumberOfReturnedRecords hint to the visitor not to exceed this number of returned records  *                                              per {@code nextEntries} call, it can still be exceeded  *                                              by some smaller constant.  * @return global iterator over state entries  */ StateIncrementalVisitor<K, N, V> getStateIncrementalVisitor(int recommendedMaxNumberOfReturnedRecords).
true;;0;1;/**  * Whether the visitor potentially has some next entries to return from {@code nextEntries()}.  */ ;/**  * Whether the visitor potentially has some next entries to return from {@code nextEntries()}.  */ boolean hasNext().
true;;0;1;/**  * Return some next entries which are available at the moment.  *  * <p>If empty collection is returned, it does not mean that the visitor is exhausted but  * it means that the visitor has done some incremental work advancing and checking internal data structures.  * The finished state of the visitor has to be checked by {@code hasNext()} method.  *  * <p>The returned collection and state values must not be changed internally  * (there might be no defensive copies in {@code nextEntries()} for performance).  * It has to be deeply copied if it is to modify, e.g. with the {@code update()} method.  */ ;/**  * Return some next entries which are available at the moment.  *  * <p>If empty collection is returned, it does not mean that the visitor is exhausted but  * it means that the visitor has done some incremental work advancing and checking internal data structures.  * The finished state of the visitor has to be checked by {@code hasNext()} method.  *  * <p>The returned collection and state values must not be changed internally  * (there might be no defensive copies in {@code nextEntries()} for performance).  * It has to be deeply copied if it is to modify, e.g. with the {@code update()} method.  */ Collection<StateEntry<K, N, V>> nextEntries().
false;;1;1;;void remove(StateEntry<K, N, V> stateEntry).
true;;2;1;/**  * Update the value of the last returned entry from the {@code next()} method.  *  * @throws IllegalStateException if next() has never been called yet or iteration is over.  */ ;/**  * Update the value of the last returned entry from the {@code next()} method.  *  * @throws IllegalStateException if next() has never been called yet or iteration is over.  */ void update(StateEntry<K, N, V> stateEntry, V newValue).
