commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;// ------------------------------------------------------------------------ // Input channel/receiver registration // ------------------------------------------------------------------------ @Override public void addInputChannel(RemoteInputChannel listener) throws IOException {     checkError().     inputChannels.putIfAbsent(listener.getInputChannelId(), listener). }
false;public;1;4;;@Override public void removeInputChannel(RemoteInputChannel listener) {     inputChannels.remove(listener.getInputChannelId()). }
false;public;1;10;;@Override public void cancelRequestFor(InputChannelID inputChannelId) {     if (inputChannelId == null || ctx == null) {         return.     }     if (cancelled.putIfAbsent(inputChannelId, inputChannelId) == null) {         ctx.writeAndFlush(new NettyMessage.CancelPartitionRequest(inputChannelId)).     } }
false;public;1;3;;@Override public void notifyCreditAvailable(final RemoteInputChannel inputChannel) { }
false;public;1;8;;// ------------------------------------------------------------------------ // Network events // ------------------------------------------------------------------------ @Override public void channelActive(final ChannelHandlerContext ctx) throws Exception {     if (this.ctx == null) {         this.ctx = ctx.     }     super.channelActive(ctx). }
false;public;1;15;;@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {     // channels have been removed. This indicates a problem with the remote task manager.     if (!inputChannels.isEmpty()) {         final SocketAddress remoteAddr = ctx.channel().remoteAddress().         notifyAllChannelsOfErrorAndClose(new RemoteTransportException("Connection unexpectedly closed by remote task manager '" + remoteAddr + "'. " + "This might indicate that the remote task manager was lost.", remoteAddr)).     }     super.channelInactive(ctx). }
true;public;2;30;/**  * Called on exceptions in the client handler pipeline.  *  * <p> Remote exceptions are received as regular payload.  */ ;/**  * Called on exceptions in the client handler pipeline.  *  * <p> Remote exceptions are received as regular payload.  */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {     if (cause instanceof TransportException) {         notifyAllChannelsOfErrorAndClose(cause).     } else {         final SocketAddress remoteAddr = ctx.channel().remoteAddress().         final TransportException tex.         // Improve on the connection reset by peer error message         if (cause instanceof IOException && cause.getMessage().equals("Connection reset by peer")) {             tex = new RemoteTransportException("Lost connection to task manager '" + remoteAddr + "'. This indicates " + "that the remote task manager was lost.", remoteAddr, cause).         } else {             SocketAddress localAddr = ctx.channel().localAddress().             tex = new LocalTransportException(String.format("%s (connection to '%s')", cause.getMessage(), remoteAddr), localAddr, cause).         }         notifyAllChannelsOfErrorAndClose(tex).     } }
false;public;2;14;;@Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {     try {         if (!bufferListener.hasStagedBufferOrEvent() && stagedMessages.isEmpty()) {             decodeMsg(msg, false).         } else {             stagedMessages.add(msg).         }     } catch (Throwable t) {         notifyAllChannelsOfErrorAndClose(t).     } }
false;private;1;21;;private void notifyAllChannelsOfErrorAndClose(Throwable cause) {     if (channelError.compareAndSet(null, cause)) {         try {             for (RemoteInputChannel inputChannel : inputChannels.values()) {                 inputChannel.onError(cause).             }         } catch (Throwable t) {             // We can only swallow the Exception at this point. :(             LOG.warn("An Exception was thrown during error notification of a " + "remote input channel.", t).         } finally {             inputChannels.clear().             if (ctx != null) {                 ctx.close().             }         }     } }
true;private;0;12;/**  * Checks for an error and rethrows it if one was reported.  */ ;// ------------------------------------------------------------------------ /**  * Checks for an error and rethrows it if one was reported.  */ private void checkError() throws IOException {     final Throwable t = channelError.get().     if (t != null) {         if (t instanceof IOException) {             throw (IOException) t.         } else {             throw new IOException("There has been an error in the channel.", t).         }     } }
false;public;1;4;;@Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {     super.channelReadComplete(ctx). }
false;private;2;50;;private boolean decodeMsg(Object msg, boolean isStagedBuffer) throws Throwable {     final Class<?> msgClazz = msg.getClass().     // ---- Buffer --------------------------------------------------------     if (msgClazz == NettyMessage.BufferResponse.class) {         NettyMessage.BufferResponse bufferOrEvent = (NettyMessage.BufferResponse) msg.         RemoteInputChannel inputChannel = inputChannels.get(bufferOrEvent.receiverId).         if (inputChannel == null) {             bufferOrEvent.releaseBuffer().             cancelRequestFor(bufferOrEvent.receiverId).             return true.         }         return decodeBufferOrEvent(inputChannel, bufferOrEvent, isStagedBuffer).     } else // ---- Error ---------------------------------------------------------     if (msgClazz == NettyMessage.ErrorResponse.class) {         NettyMessage.ErrorResponse error = (NettyMessage.ErrorResponse) msg.         SocketAddress remoteAddr = ctx.channel().remoteAddress().         if (error.isFatalError()) {             notifyAllChannelsOfErrorAndClose(new RemoteTransportException("Fatal error at remote task manager '" + remoteAddr + "'.", remoteAddr, error.cause)).         } else {             RemoteInputChannel inputChannel = inputChannels.get(error.receiverId).             if (inputChannel != null) {                 if (error.cause.getClass() == PartitionNotFoundException.class) {                     inputChannel.onFailedPartitionRequest().                 } else {                     inputChannel.onError(new RemoteTransportException("Error at remote task manager '" + remoteAddr + "'.", remoteAddr, error.cause)).                 }             }         }     } else {         throw new IllegalStateException("Received unknown message from producer: " + msg.getClass()).     }     return true. }
false;private;3;64;;private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent, boolean isStagedBuffer) throws Throwable {     boolean releaseNettyBuffer = true.     try {         ByteBuf nettyBuffer = bufferOrEvent.getNettyBuffer().         final int receivedSize = nettyBuffer.readableBytes().         if (bufferOrEvent.isBuffer()) {             // IndexOutOfBoundsException.             if (receivedSize == 0) {                 inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, -1).                 return true.             }             BufferProvider bufferProvider = inputChannel.getBufferProvider().             if (bufferProvider == null) {                 // receiver has been cancelled/failed                 cancelRequestFor(bufferOrEvent.receiverId).                 return isStagedBuffer.             }             while (true) {                 Buffer buffer = bufferProvider.requestBuffer().                 if (buffer != null) {                     nettyBuffer.readBytes(buffer.asByteBuf(), receivedSize).                     inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber, -1).                     return true.                 } else if (bufferListener.waitForBuffer(bufferProvider, bufferOrEvent)) {                     releaseNettyBuffer = false.                     return false.                 } else if (bufferProvider.isDestroyed()) {                     return isStagedBuffer.                 }             }         } else {             // ---- Event -------------------------------------------------             // TODO We can just keep the serialized data in the Netty buffer and release it later at the reader             byte[] byteArray = new byte[receivedSize].             nettyBuffer.readBytes(byteArray).             MemorySegment memSeg = MemorySegmentFactory.wrap(byteArray).             Buffer buffer = new NetworkBuffer(memSeg, FreeingBufferRecycler.INSTANCE, false, receivedSize).             inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber, -1).             return true.         }     } finally {         if (releaseNettyBuffer) {             bufferOrEvent.releaseBuffer().         }     } }
false;public;0;4;;@Override public void run() {     notifyAllChannelsOfErrorAndClose(error). }
false;private;2;17;;private boolean waitForBuffer(BufferProvider bufferProvider, NettyMessage.BufferResponse bufferResponse) {     stagedBufferResponse = bufferResponse.     if (bufferProvider.addBufferListener(this)) {         if (ctx.channel().config().isAutoRead()) {             ctx.channel().config().setAutoRead(false).         }         return true.     } else {         stagedBufferResponse = null.         return false.     } }
false;private;0;3;;private boolean hasStagedBufferOrEvent() {     return stagedBufferResponse != null. }
false;public;0;12;;public void notifyBufferDestroyed() {     // The buffer pool has been destroyed     stagedBufferResponse = null.     if (stagedMessages.isEmpty()) {         ctx.channel().config().setAutoRead(true).         ctx.channel().read().     } else {         ctx.channel().eventLoop().execute(stagedMessagesHandler).     } }
true;public;1;14;// Called by the recycling thread (not network I/O thread) ;// Called by the recycling thread (not network I/O thread) @Override public NotificationResult notifyBufferAvailable(Buffer buffer) {     if (availableBuffer.compareAndSet(null, buffer)) {         ctx.channel().eventLoop().execute(this).         return NotificationResult.BUFFER_USED_NO_NEED_MORE.     } else {         ctx.channel().eventLoop().execute(new AsyncErrorNotificationTask(new IllegalStateException("Received a buffer notification, " + " but the previous one has not been handled yet."))).         return NotificationResult.BUFFER_NOT_USED.     } }
true;public;0;47;/**  * Continues the decoding of a staged buffer after a buffer has become available again.  *  * <p>This task is executed by the network I/O thread.  */ ;/**  * Continues the decoding of a staged buffer after a buffer has become available again.  *  * <p>This task is executed by the network I/O thread.  */ @Override public void run() {     boolean success = false.     Buffer buffer = null.     try {         if ((buffer = availableBuffer.getAndSet(null)) == null) {             throw new IllegalStateException("Running buffer availability task w/o a buffer.").         }         ByteBuf nettyBuffer = stagedBufferResponse.getNettyBuffer().         nettyBuffer.readBytes(buffer.asByteBuf(), nettyBuffer.readableBytes()).         stagedBufferResponse.releaseBuffer().         RemoteInputChannel inputChannel = inputChannels.get(stagedBufferResponse.receiverId).         if (inputChannel != null) {             inputChannel.onBuffer(buffer, stagedBufferResponse.sequenceNumber, -1).             success = true.         } else {             cancelRequestFor(stagedBufferResponse.receiverId).         }         stagedBufferResponse = null.         if (stagedMessages.isEmpty()) {             ctx.channel().config().setAutoRead(true).             ctx.channel().read().         } else {             ctx.channel().eventLoop().execute(stagedMessagesHandler).         }     } catch (Throwable t) {         notifyAllChannelsOfErrorAndClose(t).     } finally {         if (!success) {             if (buffer != null) {                 buffer.recycleBuffer().             }         }     } }
false;public;0;17;;@Override public void run() {     try {         Object msg.         while ((msg = stagedMessages.poll()) != null) {             if (!decodeMsg(msg, true)) {                 return.             }         }         ctx.channel().config().setAutoRead(true).         ctx.channel().read().     } catch (Throwable t) {         notifyAllChannelsOfErrorAndClose(t).     } }
