commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;78;;@Override protected void channelRead0(final ChannelHandlerContext ctx, final HttpObject msg) throws Exception {     try {         if (msg instanceof HttpRequest) {             final HttpRequest httpRequest = (HttpRequest) msg.             LOG.trace("Received request. URL:{} Method:{}", httpRequest.getUri(), httpRequest.getMethod()).             if (httpRequest.getMethod().equals(HttpMethod.POST)) {                 if (HttpPostRequestDecoder.isMultipart(httpRequest)) {                     LOG.trace("Initializing multipart file upload.").                     checkState(currentHttpPostRequestDecoder == null).                     checkState(currentHttpRequest == null).                     checkState(currentUploadDir == null).                     currentHttpPostRequestDecoder = new HttpPostRequestDecoder(DATA_FACTORY, httpRequest).                     currentHttpRequest = ReferenceCountUtil.retain(httpRequest).                     // make sure that we still have a upload dir in case that it got deleted in the meanwhile                     RestServerEndpoint.createUploadDir(uploadDir, LOG).                     currentUploadDir = Files.createDirectory(uploadDir.resolve(UUID.randomUUID().toString())).                 } else {                     ctx.fireChannelRead(ReferenceCountUtil.retain(msg)).                 }             } else {                 ctx.fireChannelRead(ReferenceCountUtil.retain(msg)).             }         } else if (msg instanceof HttpContent && currentHttpPostRequestDecoder != null) {             LOG.trace("Received http content.").             // make sure that we still have a upload dir in case that it got deleted in the meanwhile             RestServerEndpoint.createUploadDir(uploadDir, LOG).             final HttpContent httpContent = (HttpContent) msg.             currentHttpPostRequestDecoder.offer(httpContent).             while (httpContent != LastHttpContent.EMPTY_LAST_CONTENT && currentHttpPostRequestDecoder.hasNext()) {                 final InterfaceHttpData data = currentHttpPostRequestDecoder.next().                 if (data.getHttpDataType() == InterfaceHttpData.HttpDataType.FileUpload) {                     final DiskFileUpload fileUpload = (DiskFileUpload) data.                     checkState(fileUpload.isCompleted()).                     final Path dest = currentUploadDir.resolve(fileUpload.getFilename()).                     fileUpload.renameTo(dest.toFile()).                     LOG.trace("Upload of file {} complete.", fileUpload.getFilename()).                 } else if (data.getHttpDataType() == InterfaceHttpData.HttpDataType.Attribute) {                     final Attribute request = (Attribute) data.                     // this could also be implemented by using the first found Attribute as the payload                     LOG.trace("Upload of attribute {} complete.", request.getName()).                     if (data.getName().equals(HTTP_ATTRIBUTE_REQUEST)) {                         currentJsonPayload = request.get().                     } else {                         handleError(ctx, "Received unknown attribute " + data.getName() + '.', HttpResponseStatus.BAD_REQUEST, null).                         return.                     }                 }             }             if (httpContent instanceof LastHttpContent) {                 LOG.trace("Finalizing multipart file upload.").                 ctx.channel().attr(UPLOADED_FILES).set(new FileUploads(currentUploadDir)).                 if (currentJsonPayload != null) {                     currentHttpRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, currentJsonPayload.length).                     currentHttpRequest.headers().set(HttpHeaders.Names.CONTENT_TYPE, RestConstants.REST_CONTENT_TYPE).                     ctx.fireChannelRead(currentHttpRequest).                     ctx.fireChannelRead(httpContent.replace(Unpooled.wrappedBuffer(currentJsonPayload))).                 } else {                     currentHttpRequest.headers().set(HttpHeaders.Names.CONTENT_LENGTH, 0).                     currentHttpRequest.headers().remove(HttpHeaders.Names.CONTENT_TYPE).                     ctx.fireChannelRead(currentHttpRequest).                     ctx.fireChannelRead(LastHttpContent.EMPTY_LAST_CONTENT).                 }                 reset().             }         } else {             ctx.fireChannelRead(ReferenceCountUtil.retain(msg)).         }     } catch (Exception e) {         handleError(ctx, "File upload failed.", HttpResponseStatus.INTERNAL_SERVER_ERROR, e).     } }
false;private;4;14;;private void handleError(ChannelHandlerContext ctx, String errorMessage, HttpResponseStatus responseStatus, @Nullable Throwable e) {     HttpRequest tmpRequest = currentHttpRequest.     deleteUploadedFiles().     reset().     LOG.warn(errorMessage, e).     HandlerUtils.sendErrorResponse(ctx, tmpRequest, new ErrorResponseBody(errorMessage), responseStatus, Collections.emptyMap()).     ReferenceCountUtil.release(tmpRequest). }
false;private;0;9;;private void deleteUploadedFiles() {     if (currentUploadDir != null) {         try {             FileUtils.deleteDirectory(currentUploadDir.toFile()).         } catch (IOException e) {             LOG.warn("Could not cleanup uploaded files.", e).         }     } }
false;private;0;15;;private void reset() {     // see https://github.com/netty/netty/issues/7814     try {         currentHttpPostRequestDecoder.getBodyHttpDatas().clear().     } catch (HttpPostRequestDecoder.NotEnoughDataDecoderException ned) {         // this method always fails if not all chunks were offered to the decoder yet         LOG.debug("Error while resetting handler.", ned).     }     currentHttpPostRequestDecoder.destroy().     currentHttpPostRequestDecoder = null.     currentHttpRequest = null.     currentUploadDir = null.     currentJsonPayload = null. }
false;public,static;1;4;;public static FileUploads getMultipartFileUploads(ChannelHandlerContext ctx) {     return Optional.ofNullable(ctx.channel().attr(UPLOADED_FILES).getAndRemove()).orElse(FileUploads.EMPTY). }
