commented;modifiers;parameterAmount;loc;comment;code
false;public;3;21;;@Override public void requestSubpartitionView(ResultPartitionProvider partitionProvider, ResultPartitionID resultPartitionId, int subPartitionIndex) throws IOException {     synchronized (requestLock) {         if (subpartitionView == null) {             // This this call can trigger a notification we have to             // schedule a separate task at the event loop that will             // start consuming this. Otherwise the reference to the             // view cannot be available in getNextBuffer().             this.subpartitionView = partitionProvider.createSubpartitionView(resultPartitionId, subPartitionIndex, this).         } else {             throw new IllegalStateException("Subpartition already requested").         }     } }
false;public;1;4;;@Override public void addCredit(int creditDeltas) {     numCreditsAvailable += creditDeltas. }
false;public;1;4;;@Override public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {     this.isRegisteredAsAvailable = isRegisteredAvailable. }
false;public;0;4;;@Override public boolean isRegisteredAsAvailable() {     return isRegisteredAsAvailable. }
true;public;0;6;/**  * Returns true only if the next buffer is an event or the reader has both available  * credits and buffers.  */ ;/**  * Returns true only if the next buffer is an event or the reader has both available  * credits and buffers.  */ @Override public boolean isAvailable() {     // BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!     return hasBuffersAvailable() && (numCreditsAvailable > 0 || subpartitionView.nextBufferIsEvent()). }
true;private;1;5;/**  * Check whether this reader is available or not (internal use, in sync with  * {@link #isAvailable()}, but slightly faster).  *  * <p>Returns true only if the next buffer is an event or the reader has both available  * credits and buffers.  *  * @param bufferAndBacklog  * 		current buffer and backlog including information about the next buffer  */ ;/**  * Check whether this reader is available or not (internal use, in sync with  * {@link #isAvailable()}, but slightly faster).  *  * <p>Returns true only if the next buffer is an event or the reader has both available  * credits and buffers.  *  * @param bufferAndBacklog  * 		current buffer and backlog including information about the next buffer  */ private boolean isAvailable(BufferAndBacklog bufferAndBacklog) {     // BEWARE: this must be in sync with #isAvailable()!     return bufferAndBacklog.isMoreAvailable() && (numCreditsAvailable > 0 || bufferAndBacklog.nextBufferIsEvent()). }
false;public;0;4;;@Override public InputChannelID getReceiverId() {     return receiverId. }
false;public;0;4;;@Override public int getSequenceNumber() {     return sequenceNumber. }
false;;0;4;;@VisibleForTesting int getNumCreditsAvailable() {     return numCreditsAvailable. }
false;;0;4;;@VisibleForTesting boolean hasBuffersAvailable() {     return subpartitionView.isAvailable(). }
false;public;0;16;;@Override public BufferAndAvailability getNextBuffer() throws IOException, InterruptedException {     BufferAndBacklog next = subpartitionView.getNextBuffer().     if (next != null) {         sequenceNumber++.         if (next.buffer().isBuffer() && --numCreditsAvailable < 0) {             throw new IllegalStateException("no credit available").         }         return new BufferAndAvailability(next.buffer(), isAvailable(next), next.buffersInBacklog()).     } else {         return null.     } }
false;public;0;4;;@Override public void notifySubpartitionConsumed() throws IOException {     subpartitionView.notifySubpartitionConsumed(). }
false;public;0;4;;@Override public boolean isReleased() {     return subpartitionView.isReleased(). }
false;public;0;4;;@Override public Throwable getFailureCause() {     return subpartitionView.getFailureCause(). }
false;public;0;4;;@Override public void releaseAllResources() throws IOException {     subpartitionView.releaseAllResources(). }
false;public;0;4;;@Override public void notifyDataAvailable() {     requestQueue.notifyReaderNonEmpty(this). }
false;public;0;10;;@Override public String toString() {     return "CreditBasedSequenceNumberingViewReader{" + "requestLock=" + requestLock + ", receiverId=" + receiverId + ", sequenceNumber=" + sequenceNumber + ", numCreditsAvailable=" + numCreditsAvailable + ", isRegisteredAsAvailable=" + isRegisteredAsAvailable + '}'. }
