commented;modifiers;parameterAmount;loc;comment;code
true;public;2;5;/**  * Hand in the object to share.  */ ;/**  * Hand in the object to share.  */ public void handIn(String key, V obj) {     if (!retrieveSharedQueue(key).offer(obj)) {         throw new RuntimeException("Could not register the given element, broker slot is already occupied.").     } }
true;public;1;9;/**  * Blocking retrieval and removal of the object to share.  */ ;/**  * Blocking retrieval and removal of the object to share.  */ public V getAndRemove(String key) {     try {         V objToShare = retrieveSharedQueue(key).take().         mediations.remove(key).         return objToShare.     } catch (InterruptedException e) {         throw new RuntimeException(e).     } }
true;public;1;3;/**  * Blocking retrieval and removal of the object to share.  */ ;/**  * Blocking retrieval and removal of the object to share.  */ public void remove(String key) {     mediations.remove(key). }
true;public;1;12;/**  * Blocking retrieval and removal of the object to share.  */ ;/**  * Blocking retrieval and removal of the object to share.  */ public V get(String key) {     try {         BlockingQueue<V> queue = retrieveSharedQueue(key).         V objToShare = queue.take().         if (!queue.offer(objToShare)) {             throw new RuntimeException("Error: Concurrent modification of the broker slot for key '" + key + "'.").         }         return objToShare.     } catch (InterruptedException e) {         throw new RuntimeException(e).     } }
true;private;1;10;/**  * Thread-safe call to get a shared {@link BlockingQueue}.  */ ;/**  * Thread-safe call to get a shared {@link BlockingQueue}.  */ private BlockingQueue<V> retrieveSharedQueue(String key) {     BlockingQueue<V> queue = mediations.get(key).     if (queue == null) {         queue = new ArrayBlockingQueue<V>(1).         BlockingQueue<V> commonQueue = mediations.putIfAbsent(key, queue).         return commonQueue != null ? commonQueue : queue.     } else {         return queue.     } }
