commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public CompletableFuture<TransientBlobKey> load(ResourceID resourceId) throws Exception {     return loadTaskManagerFile(resourceId). }
false;protected;4;54;;@Override protected CompletableFuture<Void> respondToRequest(ChannelHandlerContext ctx, HttpRequest httpRequest, HandlerRequest<EmptyRequestBody, M> handlerRequest, RestfulGateway gateway) throws RestHandlerException {     final ResourceID taskManagerId = handlerRequest.getPathParameter(TaskManagerIdPathParameter.class).     final CompletableFuture<TransientBlobKey> blobKeyFuture.     try {         blobKeyFuture = fileBlobKeys.get(taskManagerId).     } catch (ExecutionException e) {         final Throwable cause = ExceptionUtils.stripExecutionException(e).         throw new RestHandlerException("Could not retrieve file blob key future.", HttpResponseStatus.INTERNAL_SERVER_ERROR, cause).     }     final CompletableFuture<Void> resultFuture = blobKeyFuture.thenAcceptAsync((TransientBlobKey blobKey) -> {         final File file.         try {             file = transientBlobService.getFile(blobKey).         } catch (IOException e) {             throw new CompletionException(new FlinkException("Could not retrieve file from transient blob store.", e)).         }         try {             transferFile(ctx, file, httpRequest).         } catch (FlinkException e) {             throw new CompletionException(new FlinkException("Could not transfer file to client.", e)).         }     }, ctx.executor()).     return resultFuture.whenComplete((Void ignored, Throwable throwable) -> {         if (throwable != null) {             log.error("Failed to transfer file from TaskExecutor {}.", taskManagerId, throwable).             fileBlobKeys.invalidate(taskManagerId).             final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable).             if (strippedThrowable instanceof UnknownTaskExecutorException) {                 throw new CompletionException(new NotFoundException(String.format("Failed to transfer file from TaskExecutor %s because it was unknown.", taskManagerId), strippedThrowable)).             } else {                 throw new CompletionException(new FlinkException(String.format("Failed to transfer file from TaskExecutor %s.", taskManagerId), strippedThrowable)).             }         }     }). }
false;protected,abstract;2;1;;protected abstract CompletableFuture<TransientBlobKey> requestFileUpload(ResourceManagerGateway resourceManagerGateway, ResourceID taskManagerResourceId).
false;private;1;14;;private CompletableFuture<TransientBlobKey> loadTaskManagerFile(ResourceID taskManagerResourceId) throws RestHandlerException {     log.debug("Load file from TaskManager {}.", taskManagerResourceId).     final ResourceManagerGateway resourceManagerGateway = resourceManagerGatewayRetriever.getNow().orElseThrow(() -> {         log.debug("Could not connect to ResourceManager right now.").         return new RestHandlerException("Cannot connect to ResourceManager right now. Please try to refresh.", HttpResponseStatus.NOT_FOUND).     }).     return requestFileUpload(resourceManagerGateway, taskManagerResourceId). }
false;private;1;9;;private void removeBlob(RemovalNotification<ResourceID, CompletableFuture<TransientBlobKey>> removalNotification) {     log.debug("Remove cached file for TaskExecutor {}.", removalNotification.getKey()).     final CompletableFuture<TransientBlobKey> value = removalNotification.getValue().     if (value != null) {         value.thenAccept(transientBlobService::deleteFromCache).     } }
false;private;3;67;;private void transferFile(ChannelHandlerContext ctx, File file, HttpRequest httpRequest) throws FlinkException {     final RandomAccessFile randomAccessFile.     try {         randomAccessFile = new RandomAccessFile(file, "r").     } catch (FileNotFoundException e) {         throw new FlinkException("Can not find file " + file + ".", e).     }     try {         final long fileLength = randomAccessFile.length().         final FileChannel fileChannel = randomAccessFile.getChannel().         try {             HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK).             response.headers().set(CONTENT_TYPE, "text/plain").             if (HttpHeaders.isKeepAlive(httpRequest)) {                 response.headers().set(CONNECTION, HttpHeaders.Values.KEEP_ALIVE).             }             HttpHeaders.setContentLength(response, fileLength).             // write the initial line and the header.             ctx.write(response).             // write the content.             final ChannelFuture lastContentFuture.             final GenericFutureListener<Future<? super Void>> completionListener = future -> {                 fileChannel.close().                 randomAccessFile.close().             }.             if (ctx.pipeline().get(SslHandler.class) == null) {                 ctx.write(new DefaultFileRegion(fileChannel, 0, fileLength), ctx.newProgressivePromise()).addListener(completionListener).                 lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).             } else {                 lastContentFuture = ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(randomAccessFile, 0, fileLength, 8192)), ctx.newProgressivePromise()).addListener(completionListener).             // HttpChunkedInput will write the end marker (LastHttpContent) for us.             }             // close the connection, if no keep-alive is needed             if (!HttpHeaders.isKeepAlive(httpRequest)) {                 lastContentFuture.addListener(ChannelFutureListener.CLOSE).             }         } catch (IOException ex) {             fileChannel.close().             throw ex.         }     } catch (IOException ioe) {         try {             randomAccessFile.close().         } catch (IOException e) {             throw new FlinkException("Close file or channel error.", e).         }         throw new FlinkException("Could not transfer file " + file + " to the client.", ioe).     } }
