commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns whether this {@link StateTable} is empty.  *  * @return {@code true} if this {@link StateTable} has no elements, {@code false}  * otherwise.  * @see #size()  */ ;// Main interface methods of StateTable ------------------------------------------------------- /**  * Returns whether this {@link StateTable} is empty.  *  * @return {@code true} if this {@link StateTable} has no elements, {@code false}  * otherwise.  * @see #size()  */ public boolean isEmpty() {     return size() == 0. }
true;public,abstract;0;1;/**  * Returns the total number of entries in this {@link StateTable}. This is the sum of both sub-tables.  *  * @return the number of entries in this {@link StateTable}.  */ ;/**  * Returns the total number of entries in this {@link StateTable}. This is the sum of both sub-tables.  *  * @return the number of entries in this {@link StateTable}.  */ public abstract int size().
true;public,abstract;1;1;/**  * Returns the state of the mapping for the composite of active key and given namespace.  *  * @param namespace the namespace. Not null.  * @return the states of the mapping with the specified key/namespace composite key, or {@code null}  * if no mapping for the specified key is found.  */ ;/**  * Returns the state of the mapping for the composite of active key and given namespace.  *  * @param namespace the namespace. Not null.  * @return the states of the mapping with the specified key/namespace composite key, or {@code null}  * if no mapping for the specified key is found.  */ public abstract S get(N namespace).
true;public,abstract;1;1;/**  * Returns whether this table contains a mapping for the composite of active key and given namespace.  *  * @param namespace the namespace in the composite key to search for. Not null.  * @return {@code true} if this map contains the specified key/namespace composite key,  * {@code false} otherwise.  */ ;/**  * Returns whether this table contains a mapping for the composite of active key and given namespace.  *  * @param namespace the namespace in the composite key to search for. Not null.  * @return {@code true} if this map contains the specified key/namespace composite key,  * {@code false} otherwise.  */ public abstract boolean containsKey(N namespace).
true;public,abstract;2;1;/**  * Maps the composite of active key and given namespace to the specified state. This method should be preferred  * over {@link #putAndGetOld(N, S)} (Namespace, State)} when the caller is not interested in the old state.  *  * @param namespace the namespace. Not null.  * @param state     the state. Can be null.  */ ;/**  * Maps the composite of active key and given namespace to the specified state. This method should be preferred  * over {@link #putAndGetOld(N, S)} (Namespace, State)} when the caller is not interested in the old state.  *  * @param namespace the namespace. Not null.  * @param state     the state. Can be null.  */ public abstract void put(N namespace, S state).
true;public,abstract;2;1;/**  * Maps the composite of active key and given namespace to the specified state. Returns the previous state that  * was registered under the composite key.  *  * @param namespace the namespace. Not null.  * @param state     the state. Can be null.  * @return the state of any previous mapping with the specified key or  * {@code null} if there was no such mapping.  */ ;/**  * Maps the composite of active key and given namespace to the specified state. Returns the previous state that  * was registered under the composite key.  *  * @param namespace the namespace. Not null.  * @param state     the state. Can be null.  * @return the state of any previous mapping with the specified key or  * {@code null} if there was no such mapping.  */ public abstract S putAndGetOld(N namespace, S state).
true;public,abstract;1;1;/**  * Removes the mapping for the composite of active key and given namespace. This method should be preferred  * over {@link #removeAndGetOld(N)} when the caller is not interested in the old state.  *  * @param namespace the namespace of the mapping to remove. Not null.  */ ;/**  * Removes the mapping for the composite of active key and given namespace. This method should be preferred  * over {@link #removeAndGetOld(N)} when the caller is not interested in the old state.  *  * @param namespace the namespace of the mapping to remove. Not null.  */ public abstract void remove(N namespace).
true;public,abstract;1;1;/**  * Removes the mapping for the composite of active key and given namespace, returning the state that was  * found under the entry.  *  * @param namespace the namespace of the mapping to remove. Not null.  * @return the state of the removed mapping or {@code null} if no mapping  * for the specified key was found.  */ ;/**  * Removes the mapping for the composite of active key and given namespace, returning the state that was  * found under the entry.  *  * @param namespace the namespace of the mapping to remove. Not null.  * @return the state of the removed mapping or {@code null} if no mapping  * for the specified key was found.  */ public abstract S removeAndGetOld(N namespace).
true;public,abstract;3;4;/**  * Applies the given {@link StateTransformationFunction} to the state (1st input argument), using the given value as  * second input argument. The result of {@link StateTransformationFunction#apply(Object, Object)} is then stored as  * the new state. This function is basically an optimization for get-update-put pattern.  *  * @param namespace      the namespace. Not null.  * @param value          the value to use in transforming the state. Can be null.  * @param transformation the transformation function.  * @throws Exception if some exception happens in the transformation function.  */ ;/**  * Applies the given {@link StateTransformationFunction} to the state (1st input argument), using the given value as  * second input argument. The result of {@link StateTransformationFunction#apply(Object, Object)} is then stored as  * the new state. This function is basically an optimization for get-update-put pattern.  *  * @param namespace      the namespace. Not null.  * @param value          the value to use in transforming the state. Can be null.  * @param transformation the transformation function.  * @throws Exception if some exception happens in the transformation function.  */ public abstract <T> void transform(N namespace, T value, StateTransformationFunction<S, T> transformation) throws Exception.
true;public,abstract;2;1;/**  * Returns the state for the composite of active key and given namespace. This is typically used by  * queryable state.  *  * @param key       the key. Not null.  * @param namespace the namespace. Not null.  * @return the state of the mapping with the specified key/namespace composite key, or {@code null}  * if no mapping for the specified key is found.  */ ;// For queryable state ------------------------------------------------------------------------ /**  * Returns the state for the composite of active key and given namespace. This is typically used by  * queryable state.  *  * @param key       the key. Not null.  * @param namespace the namespace. Not null.  * @return the state of the mapping with the specified key/namespace composite key, or {@code null}  * if no mapping for the specified key is found.  */ public abstract S get(K key, N namespace).
false;public,abstract;1;1;;public abstract Stream<K> getKeys(N namespace).
false;public,abstract;1;1;;public abstract StateIncrementalVisitor<K, N, S> getStateIncrementalVisitor(int recommendedMaxNumberOfReturnedRecords).
false;public;0;3;;// Meta data setter / getter and toString ----------------------------------------------------- public TypeSerializer<S> getStateSerializer() {     return metaInfo.getStateSerializer(). }
false;public;0;3;;public TypeSerializer<N> getNamespaceSerializer() {     return metaInfo.getNamespaceSerializer(). }
false;public;0;3;;public RegisteredKeyValueStateBackendMetaInfo<N, S> getMetaInfo() {     return metaInfo. }
false;public;1;3;;public void setMetaInfo(RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo) {     this.metaInfo = metaInfo. }
false;public,abstract;4;1;;// Snapshot / Restore ------------------------------------------------------------------------- public abstract void put(K key, int keyGroup, N namespace, S state).
false;public,abstract;1;2;;// For testing -------------------------------------------------------------------------------- @VisibleForTesting public abstract int sizeOfNamespace(Object namespace).
false;public;1;5;;@Nonnull @Override public StateSnapshotKeyGroupReader keyGroupReader(int readVersion) {     return StateTableByKeyGroupReaders.readerForVersion(this, readVersion). }
