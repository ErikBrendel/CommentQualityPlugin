commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public void close() throws IOException { // users should not be able to actually close the stream, it is closed by the system. // TODO if we want to support async writes, this call could trigger a callback to the snapshot context that a handle is available. }
true;public;0;3;/**  * Returns a list of all key-groups which can be written to this stream.  */ ;/**  * Returns a list of all key-groups which can be written to this stream.  */ public KeyGroupsList getKeyGroupList() {     return keyGroupRangeOffsets.getKeyGroupRange(). }
true;public;1;7;/**  * User code can call this method to signal that it begins to write a new key group with the given key group id.  * This id must be within the {@link KeyGroupsList} provided by the stream. Each key-group can only be started once  * and is considered final/immutable as soon as this method is called again.  */ ;/**  * User code can call this method to signal that it begins to write a new key group with the given key group id.  * This id must be within the {@link KeyGroupsList} provided by the stream. Each key-group can only be started once  * and is considered final/immutable as soon as this method is called again.  */ public void startNewKeyGroup(int keyGroupId) throws IOException {     if (isKeyGroupAlreadyStarted(keyGroupId)) {         throw new IOException("Key group " + keyGroupId + " already registered!").     }     keyGroupRangeOffsets.setKeyGroupOffset(keyGroupId, delegate.getPos()).     currentKeyGroup = keyGroupId. }
true;public;1;3;/**  * Returns true, if the key group with the given id was already started. The key group might not yet be finished,  * if it's id is equal to the return value of {@link #getCurrentKeyGroup()}.  */ ;/**  * Returns true, if the key group with the given id was already started. The key group might not yet be finished,  * if it's id is equal to the return value of {@link #getCurrentKeyGroup()}.  */ public boolean isKeyGroupAlreadyStarted(int keyGroupId) {     return NO_OFFSET_SET != keyGroupRangeOffsets.getKeyGroupOffset(keyGroupId). }
true;public;1;3;/**  * Returns true if the key group is already completely written and immutable. It was started and since then another  * key group has been started.  */ ;/**  * Returns true if the key group is already completely written and immutable. It was started and since then another  * key group has been started.  */ public boolean isKeyGroupAlreadyFinished(int keyGroupId) {     return isKeyGroupAlreadyStarted(keyGroupId) && keyGroupId != getCurrentKeyGroup(). }
true;public;0;3;/**  * Returns the key group that is currently being written. The key group was started but not yet finished, i.e. data  * can still be added. If no key group was started, this returns {@link #NO_CURRENT_KEY_GROUP}.  */ ;/**  * Returns the key group that is currently being written. The key group was started but not yet finished, i.e. data  * can still be added. If no key group was started, this returns {@link #NO_CURRENT_KEY_GROUP}.  */ public int getCurrentKeyGroup() {     return currentKeyGroup. }
false;;0;5;;@Override KeyGroupsStateHandle closeAndGetHandle() throws IOException {     StreamStateHandle streamStateHandle = delegate.closeAndGetHandle().     return streamStateHandle != null ? new KeyGroupsStateHandle(keyGroupRangeOffsets, streamStateHandle) : null. }
