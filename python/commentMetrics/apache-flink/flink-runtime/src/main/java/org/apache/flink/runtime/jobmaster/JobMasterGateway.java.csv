commented;modifiers;parameterAmount;loc;comment;code
true;;1;1;/**  * Cancels the currently executed job.  *  * @param timeout of this operation  * @return Future acknowledge of the operation  */ ;/**  * Cancels the currently executed job.  *  * @param timeout of this operation  * @return Future acknowledge of the operation  */ CompletableFuture<Acknowledge> cancel(@RpcTimeout Time timeout).
true;;1;1;/**  * Cancel the currently executed job.  *  * @param timeout of this operation  * @return Future acknowledge if the cancellation was successful  */ ;/**  * Cancel the currently executed job.  *  * @param timeout of this operation  * @return Future acknowledge if the cancellation was successful  */ CompletableFuture<Acknowledge> stop(@RpcTimeout Time timeout).
true;;3;4;/**  * Triggers rescaling of the executed job.  *  * @param newParallelism new parallelism of the job  * @param rescalingBehaviour defining how strict the rescaling has to be executed  * @param timeout of this operation  * @return Future which is completed with {@link Acknowledge} once the rescaling was successful  */ ;/**  * Triggers rescaling of the executed job.  *  * @param newParallelism new parallelism of the job  * @param rescalingBehaviour defining how strict the rescaling has to be executed  * @param timeout of this operation  * @return Future which is completed with {@link Acknowledge} once the rescaling was successful  */ CompletableFuture<Acknowledge> rescaleJob(int newParallelism, RescalingBehaviour rescalingBehaviour, @RpcTimeout Time timeout).
true;;4;5;/**  * Triggers rescaling of the given set of operators.  *  * @param operators set of operators which shall be rescaled  * @param newParallelism new parallelism of the given set of operators  * @param rescalingBehaviour defining how strict the rescaling has to be executed  * @param timeout of this operation  * @return Future which is completed with {@link Acknowledge} once the rescaling was successful  */ ;/**  * Triggers rescaling of the given set of operators.  *  * @param operators set of operators which shall be rescaled  * @param newParallelism new parallelism of the given set of operators  * @param rescalingBehaviour defining how strict the rescaling has to be executed  * @param timeout of this operation  * @return Future which is completed with {@link Acknowledge} once the rescaling was successful  */ CompletableFuture<Acknowledge> rescaleOperators(Collection<JobVertexID> operators, int newParallelism, RescalingBehaviour rescalingBehaviour, @RpcTimeout Time timeout).
true;;1;2;/**  * Updates the task execution state for a given task.  *  * @param taskExecutionState New task execution state for a given task  * @return Future flag of the task execution state update result  */ ;/**  * Updates the task execution state for a given task.  *  * @param taskExecutionState New task execution state for a given task  * @return Future flag of the task execution state update result  */ CompletableFuture<Acknowledge> updateTaskExecutionState(final TaskExecutionState taskExecutionState).
true;;2;3;/**  * Requests the next input split for the {@link ExecutionJobVertex}.  * The next input split is sent back to the sender as a  * {@link SerializedInputSplit} message.  *  * @param vertexID         The job vertex id  * @param executionAttempt The execution attempt id  * @return The future of the input split. If there is no further input split, will return an empty object.  */ ;/**  * Requests the next input split for the {@link ExecutionJobVertex}.  * The next input split is sent back to the sender as a  * {@link SerializedInputSplit} message.  *  * @param vertexID         The job vertex id  * @param executionAttempt The execution attempt id  * @return The future of the input split. If there is no further input split, will return an empty object.  */ CompletableFuture<SerializedInputSplit> requestNextInputSplit(final JobVertexID vertexID, final ExecutionAttemptID executionAttempt).
true;;2;3;/**  * Requests the current state of the partition. The state of a  * partition is currently bound to the state of the producing execution.  *  * @param intermediateResultId The execution attempt ID of the task requesting the partition state.  * @param partitionId          The partition ID of the partition to request the state of.  * @return The future of the partition state  */ ;/**  * Requests the current state of the partition. The state of a  * partition is currently bound to the state of the producing execution.  *  * @param intermediateResultId The execution attempt ID of the task requesting the partition state.  * @param partitionId          The partition ID of the partition to request the state of.  * @return The future of the partition state  */ CompletableFuture<ExecutionState> requestPartitionState(final IntermediateDataSetID intermediateResultId, final ResultPartitionID partitionId).
true;;2;3;/**  * Notifies the JobManager about available data for a produced partition.  *  * <p>There is a call to this method for each {@link ExecutionVertex} instance once per produced  * {@link ResultPartition} instance, either when first producing data (for pipelined executions)  * or when all data has been produced (for staged executions).  *  * <p>The JobManager then can decide when to schedule the partition consumers of the given session.  *  * @param partitionID     The partition which has already produced data  * @param timeout         before the rpc call fails  * @return Future acknowledge of the schedule or update operation  */ ;/**  * Notifies the JobManager about available data for a produced partition.  *  * <p>There is a call to this method for each {@link ExecutionVertex} instance once per produced  * {@link ResultPartition} instance, either when first producing data (for pipelined executions)  * or when all data has been produced (for staged executions).  *  * <p>The JobManager then can decide when to schedule the partition consumers of the given session.  *  * @param partitionID     The partition which has already produced data  * @param timeout         before the rpc call fails  * @return Future acknowledge of the schedule or update operation  */ CompletableFuture<Acknowledge> scheduleOrUpdateConsumers(final ResultPartitionID partitionID, @RpcTimeout final Time timeout).
true;;2;1;/**  * Disconnects the given {@link org.apache.flink.runtime.taskexecutor.TaskExecutor} from the  * {@link JobMaster}.  *  * @param resourceID identifying the TaskManager to disconnect  * @param cause for the disconnection of the TaskManager  * @return Future acknowledge once the JobMaster has been disconnected from the TaskManager  */ ;/**  * Disconnects the given {@link org.apache.flink.runtime.taskexecutor.TaskExecutor} from the  * {@link JobMaster}.  *  * @param resourceID identifying the TaskManager to disconnect  * @param cause for the disconnection of the TaskManager  * @return Future acknowledge once the JobMaster has been disconnected from the TaskManager  */ CompletableFuture<Acknowledge> disconnectTaskManager(ResourceID resourceID, Exception cause).
true;;2;3;/**  * Disconnects the resource manager from the job manager because of the given cause.  *  * @param resourceManagerId identifying the resource manager leader id  * @param cause of the disconnect  */ ;/**  * Disconnects the resource manager from the job manager because of the given cause.  *  * @param resourceManagerId identifying the resource manager leader id  * @param cause of the disconnect  */ void disconnectResourceManager(final ResourceManagerId resourceManagerId, final Exception cause).
true;;3;4;/**  * Offers the given slots to the job manager. The response contains the set of accepted slots.  *  * @param taskManagerId identifying the task manager  * @param slots         to offer to the job manager  * @param timeout       for the rpc call  * @return Future set of accepted slots.  */ ;/**  * Offers the given slots to the job manager. The response contains the set of accepted slots.  *  * @param taskManagerId identifying the task manager  * @param slots         to offer to the job manager  * @param timeout       for the rpc call  * @return Future set of accepted slots.  */ CompletableFuture<Collection<SlotOffer>> offerSlots(final ResourceID taskManagerId, final Collection<SlotOffer> slots, @RpcTimeout final Time timeout).
true;;3;3;/**  * Fails the slot with the given allocation id and cause.  *  * @param taskManagerId identifying the task manager  * @param allocationId  identifying the slot to fail  * @param cause         of the failing  */ ;/**  * Fails the slot with the given allocation id and cause.  *  * @param taskManagerId identifying the task manager  * @param allocationId  identifying the slot to fail  * @param cause         of the failing  */ void failSlot(final ResourceID taskManagerId, final AllocationID allocationId, final Exception cause).
true;;3;4;/**  * Registers the task manager at the job manager.  *  * @param taskManagerRpcAddress the rpc address of the task manager  * @param taskManagerLocation   location of the task manager  * @param timeout               for the rpc call  * @return Future registration response indicating whether the registration was successful or not  */ ;/**  * Registers the task manager at the job manager.  *  * @param taskManagerRpcAddress the rpc address of the task manager  * @param taskManagerLocation   location of the task manager  * @param timeout               for the rpc call  * @return Future registration response indicating whether the registration was successful or not  */ CompletableFuture<RegistrationResponse> registerTaskManager(final String taskManagerRpcAddress, final TaskManagerLocation taskManagerLocation, @RpcTimeout final Time timeout).
true;;2;3;/**  * Sends the heartbeat to job manager from task manager.  *  * @param resourceID unique id of the task manager  * @param accumulatorReport report containing accumulator updates  */ ;/**  * Sends the heartbeat to job manager from task manager.  *  * @param resourceID unique id of the task manager  * @param accumulatorReport report containing accumulator updates  */ void heartbeatFromTaskManager(final ResourceID resourceID, final AccumulatorReport accumulatorReport).
true;;1;1;/**  * Sends heartbeat request from the resource manager.  *  * @param resourceID unique id of the resource manager  */ ;/**  * Sends heartbeat request from the resource manager.  *  * @param resourceID unique id of the resource manager  */ void heartbeatFromResourceManager(final ResourceID resourceID).
true;;1;1;/**  * Request the details of the executed job.  *  * @param timeout for the rpc call  * @return Future details of the executed job  */ ;/**  * Request the details of the executed job.  *  * @param timeout for the rpc call  * @return Future details of the executed job  */ CompletableFuture<JobDetails> requestJobDetails(@RpcTimeout Time timeout).
true;;1;1;/**  * Requests the current job status.  *  * @param timeout for the rpc call  * @return Future containing the current job status  */ ;/**  * Requests the current job status.  *  * @param timeout for the rpc call  * @return Future containing the current job status  */ CompletableFuture<JobStatus> requestJobStatus(@RpcTimeout Time timeout).
true;;1;1;/**  * Requests the {@link ArchivedExecutionGraph} of the executed job.  *  * @param timeout for the rpc call  * @return Future which is completed with the {@link ArchivedExecutionGraph} of the executed job  */ ;/**  * Requests the {@link ArchivedExecutionGraph} of the executed job.  *  * @param timeout for the rpc call  * @return Future which is completed with the {@link ArchivedExecutionGraph} of the executed job  */ CompletableFuture<ArchivedExecutionGraph> requestJob(@RpcTimeout Time timeout).
true;;3;4;/**  * Triggers taking a savepoint of the executed job.  *  * @param targetDirectory to which to write the savepoint data or null if the  *                           default savepoint directory should be used  * @param timeout for the rpc call  * @return Future which is completed with the savepoint path once completed  */ ;/**  * Triggers taking a savepoint of the executed job.  *  * @param targetDirectory to which to write the savepoint data or null if the  *                           default savepoint directory should be used  * @param timeout for the rpc call  * @return Future which is completed with the savepoint path once completed  */ CompletableFuture<String> triggerSavepoint(@Nullable final String targetDirectory, final boolean cancelJob, @RpcTimeout final Time timeout).
true;;1;1;/**  * Requests the statistics on operator back pressure.  *  * @param jobVertexId JobVertex for which the stats are requested.  * @return A Future to the {@link OperatorBackPressureStatsResponse}.  */ ;/**  * Requests the statistics on operator back pressure.  *  * @param jobVertexId JobVertex for which the stats are requested.  * @return A Future to the {@link OperatorBackPressureStatsResponse}.  */ CompletableFuture<OperatorBackPressureStatsResponse> requestOperatorBackPressureStats(JobVertexID jobVertexId).
true;;2;1;/**  * Notifies that the allocation has failed.  *  * @param allocationID the failed allocation id.  * @param cause the reason that the allocation failed  */ ;/**  * Notifies that the allocation has failed.  *  * @param allocationID the failed allocation id.  * @param cause the reason that the allocation failed  */ void notifyAllocationFailure(AllocationID allocationID, Exception cause).
true;;3;1;/**  * Update the aggregate and return the new value.  *  * @param aggregateName The name of the aggregate to update  * @param aggregand The value to add to the aggregate  * @param serializedAggregationFunction The function to apply to the current aggregate and aggregand to  * obtain the new aggregate value, this should be of type {@link AggregateFunction}  * @return The updated aggregate  */ ;/**  * Update the aggregate and return the new value.  *  * @param aggregateName The name of the aggregate to update  * @param aggregand The value to add to the aggregate  * @param serializedAggregationFunction The function to apply to the current aggregate and aggregand to  * obtain the new aggregate value, this should be of type {@link AggregateFunction}  * @return The updated aggregate  */ CompletableFuture<Object> updateGlobalAggregate(String aggregateName, Object aggregand, byte[] serializedAggregationFunction).
