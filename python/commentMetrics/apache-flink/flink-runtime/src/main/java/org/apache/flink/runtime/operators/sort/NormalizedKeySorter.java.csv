commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int recordSize() {     return indexEntrySize. }
false;public;0;4;;@Override public int recordsPerSegment() {     return indexEntriesPerSegment. }
true;public;0;19;/**  * Resets the sort buffer back to the state where it is empty. All contained data is discarded.  */ ;// ------------------------------------------------------------------------- // Memory Segment // ------------------------------------------------------------------------- /**  * Resets the sort buffer back to the state where it is empty. All contained data is discarded.  */ @Override public void reset() {     // reset all offsets     this.numRecords = 0.     this.currentSortIndexOffset = 0.     this.currentDataBufferOffset = 0.     this.sortIndexBytes = 0.     // return all memory     this.freeMemory.addAll(this.sortIndex).     this.freeMemory.addAll(this.recordBufferSegments).     this.sortIndex.clear().     this.recordBufferSegments.clear().     // grab first buffers     this.currentSortIndexSegment = nextMemorySegment().     this.sortIndex.add(this.currentSortIndexSegment).     this.recordCollector.reset(). }
true;public;0;4;/**  * Checks whether the buffer is empty.  *  * @return True, if no record is contained, false otherwise.  */ ;/**  * Checks whether the buffer is empty.  *  * @return True, if no record is contained, false otherwise.  */ @Override public boolean isEmpty() {     return this.numRecords == 0. }
false;public;0;6;;@Override public void dispose() {     this.freeMemory.clear().     this.recordBufferSegments.clear().     this.sortIndex.clear(). }
false;public;0;4;;@Override public long getCapacity() {     return ((long) this.totalNumBuffers) * this.segmentSize. }
false;public;0;4;;@Override public long getOccupancy() {     return this.currentDataBufferOffset + this.sortIndexBytes. }
false;public;1;4;;// ------------------------------------------------------------------------- // Retrieving and Writing // ------------------------------------------------------------------------- @Override public T getRecord(int logicalPosition) throws IOException {     return getRecordFromBuffer(readPointer(logicalPosition)). }
false;public;2;4;;@Override public T getRecord(T reuse, int logicalPosition) throws IOException {     return getRecordFromBuffer(reuse, readPointer(logicalPosition)). }
true;public;1;42;/**  * Writes a given record to this sort buffer. The written record will be appended and take  * the last logical position.  *  * @param record The record to be written.  * @return True, if the record was successfully written, false, if the sort buffer was full.  * @throws IOException Thrown, if an error occurred while serializing the record into the buffers.  */ ;/**  * Writes a given record to this sort buffer. The written record will be appended and take  * the last logical position.  *  * @param record The record to be written.  * @return True, if the record was successfully written, false, if the sort buffer was full.  * @throws IOException Thrown, if an error occurred while serializing the record into the buffers.  */ @Override public boolean write(T record) throws IOException {     // check whether we need a new memory segment for the sort index     if (this.currentSortIndexOffset > this.lastIndexEntryOffset) {         if (memoryAvailable()) {             this.currentSortIndexSegment = nextMemorySegment().             this.sortIndex.add(this.currentSortIndexSegment).             this.currentSortIndexOffset = 0.             this.sortIndexBytes += this.segmentSize.         } else {             return false.         }     }     // serialize the record into the data buffers     try {         this.serializer.serialize(record, this.recordCollector).     } catch (EOFException e) {         return false.     }     final long newOffset = this.recordCollector.getCurrentOffset().     final boolean shortRecord = newOffset - this.currentDataBufferOffset < LARGE_RECORD_THRESHOLD.     if (!shortRecord && LOG.isDebugEnabled()) {         LOG.debug("Put a large record ( >" + LARGE_RECORD_THRESHOLD + " into the sort buffer").     }     // add the pointer and the normalized key     this.currentSortIndexSegment.putLong(this.currentSortIndexOffset, shortRecord ? this.currentDataBufferOffset : (this.currentDataBufferOffset | LARGE_RECORD_TAG)).     if (this.numKeyBytes != 0) {         this.comparator.putNormalizedKey(record, this.currentSortIndexSegment, this.currentSortIndexOffset + OFFSET_LEN, this.numKeyBytes).     }     this.currentSortIndexOffset += this.indexEntrySize.     this.currentDataBufferOffset = newOffset.     this.numRecords++.     return true. }
false;private;1;10;;// ------------------------------------------------------------------------ // Access Utilities // ------------------------------------------------------------------------ private long readPointer(int logicalPosition) {     if (logicalPosition < 0 || logicalPosition >= this.numRecords) {         throw new IndexOutOfBoundsException().     }     final int bufferNum = logicalPosition / this.indexEntriesPerSegment.     final int segmentOffset = logicalPosition % this.indexEntriesPerSegment.     return (this.sortIndex.get(bufferNum).getLong(segmentOffset * this.indexEntrySize)) & POINTER_MASK. }
false;private;2;4;;private T getRecordFromBuffer(T reuse, long pointer) throws IOException {     this.recordBuffer.setReadPosition(pointer).     return this.serializer.deserialize(reuse, this.recordBuffer). }
false;private;1;4;;private T getRecordFromBuffer(long pointer) throws IOException {     this.recordBuffer.setReadPosition(pointer).     return this.serializer.deserialize(this.recordBuffer). }
false;private;2;10;;private int compareRecords(long pointer1, long pointer2) {     this.recordBuffer.setReadPosition(pointer1).     this.recordBufferForComparison.setReadPosition(pointer2).     try {         return this.comparator.compareSerialized(this.recordBuffer, this.recordBufferForComparison).     } catch (IOException ioex) {         throw new RuntimeException("Error comparing two records.", ioex).     } }
false;private;0;3;;private boolean memoryAvailable() {     return !this.freeMemory.isEmpty(). }
false;private;0;3;;private MemorySegment nextMemorySegment() {     return this.freeMemory.remove(this.freeMemory.size() - 1). }
false;public;2;10;;// ------------------------------------------------------------------------- // Indexed Sorting // ------------------------------------------------------------------------- @Override public int compare(int i, int j) {     final int segmentNumberI = i / this.indexEntriesPerSegment.     final int segmentOffsetI = (i % this.indexEntriesPerSegment) * this.indexEntrySize.     final int segmentNumberJ = j / this.indexEntriesPerSegment.     final int segmentOffsetJ = (j % this.indexEntriesPerSegment) * this.indexEntrySize.     return compare(segmentNumberI, segmentOffsetI, segmentNumberJ, segmentOffsetJ). }
false;public;4;16;;@Override public int compare(int segmentNumberI, int segmentOffsetI, int segmentNumberJ, int segmentOffsetJ) {     final MemorySegment segI = this.sortIndex.get(segmentNumberI).     final MemorySegment segJ = this.sortIndex.get(segmentNumberJ).     int val = segI.compare(segJ, segmentOffsetI + OFFSET_LEN, segmentOffsetJ + OFFSET_LEN, this.numKeyBytes).     if (val != 0 || this.normalizedKeyFullyDetermines) {         return this.useNormKeyUninverted ? val : -val.     }     final long pointerI = segI.getLong(segmentOffsetI) & POINTER_MASK.     final long pointerJ = segJ.getLong(segmentOffsetJ) & POINTER_MASK.     return compareRecords(pointerI, pointerJ). }
false;public;2;10;;@Override public void swap(int i, int j) {     final int segmentNumberI = i / this.indexEntriesPerSegment.     final int segmentOffsetI = (i % this.indexEntriesPerSegment) * this.indexEntrySize.     final int segmentNumberJ = j / this.indexEntriesPerSegment.     final int segmentOffsetJ = (j % this.indexEntriesPerSegment) * this.indexEntrySize.     swap(segmentNumberI, segmentOffsetI, segmentNumberJ, segmentOffsetJ). }
false;public;4;7;;@Override public void swap(int segmentNumberI, int segmentOffsetI, int segmentNumberJ, int segmentOffsetJ) {     final MemorySegment segI = this.sortIndex.get(segmentNumberI).     final MemorySegment segJ = this.sortIndex.get(segmentNumberJ).     segI.swapBytes(this.swapBuffer, segJ, segmentOffsetI, segmentOffsetJ, this.indexEntrySize). }
false;public;0;4;;@Override public int size() {     return this.numRecords. }
false;public;1;23;;@Override public T next(T target) {     if (this.current < this.size) {         this.current++.         if (this.currentOffset > lastIndexEntryOffset) {             this.currentOffset = 0.             this.currentIndexSegment = sortIndex.get(++this.currentSegment).         }         long pointer = this.currentIndexSegment.getLong(this.currentOffset) & POINTER_MASK.         this.currentOffset += indexEntrySize.         try {             return getRecordFromBuffer(target, pointer).         } catch (IOException ioe) {             throw new RuntimeException(ioe).         }     } else {         return null.     } }
false;public;0;24;;@Override public T next() {     if (this.current < this.size) {         this.current++.         if (this.currentOffset > lastIndexEntryOffset) {             this.currentOffset = 0.             this.currentIndexSegment = sortIndex.get(++this.currentSegment).         }         long pointer = this.currentIndexSegment.getLong(this.currentOffset).         this.currentOffset += indexEntrySize.         try {             return getRecordFromBuffer(pointer).         } catch (IOException ioe) {             throw new RuntimeException(ioe).         }     } else {         return null.     } }
true;public,final;0;62;/**  * Gets an iterator over all records in this buffer in their logical order.  *  * @return An iterator returning the records in their logical order.  */ ;// ------------------------------------------------------------------------- /**  * Gets an iterator over all records in this buffer in their logical order.  *  * @return An iterator returning the records in their logical order.  */ @Override public final MutableObjectIterator<T> getIterator() {     return new MutableObjectIterator<T>() {          private final int size = size().          private int current = 0.          private int currentSegment = 0.          private int currentOffset = 0.          private MemorySegment currentIndexSegment = sortIndex.get(0).          @Override         public T next(T target) {             if (this.current < this.size) {                 this.current++.                 if (this.currentOffset > lastIndexEntryOffset) {                     this.currentOffset = 0.                     this.currentIndexSegment = sortIndex.get(++this.currentSegment).                 }                 long pointer = this.currentIndexSegment.getLong(this.currentOffset) & POINTER_MASK.                 this.currentOffset += indexEntrySize.                 try {                     return getRecordFromBuffer(target, pointer).                 } catch (IOException ioe) {                     throw new RuntimeException(ioe).                 }             } else {                 return null.             }         }          @Override         public T next() {             if (this.current < this.size) {                 this.current++.                 if (this.currentOffset > lastIndexEntryOffset) {                     this.currentOffset = 0.                     this.currentIndexSegment = sortIndex.get(++this.currentSegment).                 }                 long pointer = this.currentIndexSegment.getLong(this.currentOffset).                 this.currentOffset += indexEntrySize.                 try {                     return getRecordFromBuffer(pointer).                 } catch (IOException ioe) {                     throw new RuntimeException(ioe).                 }             } else {                 return null.             }         }     }. }
true;public;1;4;/**  * Writes the records in this buffer in their logical order to the given output.  *  * @param output The output view to write the records to.  * @throws IOException Thrown, if an I/O exception occurred writing to the output view.  */ ;// ------------------------------------------------------------------------ // Writing to a DataOutputView // ------------------------------------------------------------------------ /**  * Writes the records in this buffer in their logical order to the given output.  *  * @param output The output view to write the records to.  * @throws IOException Thrown, if an I/O exception occurred writing to the output view.  */ @Override public void writeToOutput(ChannelWriterOutputView output) throws IOException {     writeToOutput(output, null). }
false;public;2;41;;@Override public void writeToOutput(ChannelWriterOutputView output, LargeRecordHandler<T> largeRecordsOutput) throws IOException {     if (LOG.isDebugEnabled()) {         if (largeRecordsOutput == null) {             LOG.debug("Spilling sort buffer without large record handling.").         } else {             LOG.debug("Spilling sort buffer with large record handling.").         }     }     final int numRecords = this.numRecords.     int currentMemSeg = 0.     int currentRecord = 0.     while (currentRecord < numRecords) {         final MemorySegment currentIndexSegment = this.sortIndex.get(currentMemSeg++).         // go through all records in the memory segment         for (int offset = 0. currentRecord < numRecords && offset <= this.lastIndexEntryOffset. currentRecord++, offset += this.indexEntrySize) {             final long pointer = currentIndexSegment.getLong(offset).             // small records go into the regular spill file, large records into the special code path             if (pointer >= 0 || largeRecordsOutput == null) {                 this.recordBuffer.setReadPosition(pointer).                 this.serializer.copy(this.recordBuffer, output).             } else {                 if (LOG.isDebugEnabled()) {                     LOG.debug("Spilling large record to large record fetch file.").                 }                 this.recordBuffer.setReadPosition(pointer & POINTER_MASK).                 T record = this.serializer.deserialize(this.recordBuffer).                 largeRecordsOutput.addRecord(record).             }         }     } }
true;public;3;29;/**  * Writes a subset of the records in this buffer in their logical order to the given output.  *  * @param output The output view to write the records to.  * @param start The logical start position of the subset.  * @param num The number of elements to write.  * @throws IOException Thrown, if an I/O exception occurred writing to the output view.  */ ;/**  * Writes a subset of the records in this buffer in their logical order to the given output.  *  * @param output The output view to write the records to.  * @param start The logical start position of the subset.  * @param num The number of elements to write.  * @throws IOException Thrown, if an I/O exception occurred writing to the output view.  */ @Override public void writeToOutput(final ChannelWriterOutputView output, final int start, int num) throws IOException {     int currentMemSeg = start / this.indexEntriesPerSegment.     int offset = (start % this.indexEntriesPerSegment) * this.indexEntrySize.     while (num > 0) {         final MemorySegment currentIndexSegment = this.sortIndex.get(currentMemSeg++).         // check whether we have a full or partially full segment         if (num >= this.indexEntriesPerSegment && offset == 0) {             // full segment             for (. offset <= this.lastIndexEntryOffset. offset += this.indexEntrySize) {                 final long pointer = currentIndexSegment.getLong(offset) & POINTER_MASK.                 this.recordBuffer.setReadPosition(pointer).                 this.serializer.copy(this.recordBuffer, output).             }             num -= this.indexEntriesPerSegment.         } else {             // partially filled segment             for (. num > 0 && offset <= this.lastIndexEntryOffset. num--, offset += this.indexEntrySize) {                 final long pointer = currentIndexSegment.getLong(offset) & POINTER_MASK.                 this.recordBuffer.setReadPosition(pointer).                 this.serializer.copy(this.recordBuffer, output).             }         }         offset = 0.     } }
