commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;boolean disposeIfNotUsed() {     return closeReferenceCounter.disposeIfNotUsed(). }
true;;0;3;/**  * Increments the reference counter.  *  * <p>Note: the reference counter has to be incremented before returning the  * instance of this client to ensure correct closing logic.  */ ;/**  * Increments the reference counter.  *  * <p>Note: the reference counter has to be incremented before returning the  * instance of this client to ensure correct closing logic.  */ boolean incrementReferenceCounter() {     return closeReferenceCounter.increment(). }
false;public;1;12;;@Override public void operationComplete(ChannelFuture future) throws Exception {     if (!future.isSuccess()) {         clientHandler.removeInputChannel(inputChannel).         SocketAddress remoteAddr = future.channel().remoteAddress().         inputChannel.onError(new LocalTransportException(String.format("Sending the partition request to '%s' failed.", remoteAddr), future.channel().localAddress(), future.cause())).     } }
false;public;0;5;;@Override public void run() {     f[0] = tcpChannel.writeAndFlush(request).     f[0].addListener(listener). }
true;public;4;48;/**  * Requests a remote intermediate result partition queue.  *  * <p>The request goes to the remote producer, for which this partition  * request client instance has been created.  */ ;/**  * Requests a remote intermediate result partition queue.  *  * <p>The request goes to the remote producer, for which this partition  * request client instance has been created.  */ public ChannelFuture requestSubpartition(final ResultPartitionID partitionId, final int subpartitionIndex, final RemoteInputChannel inputChannel, int delayMs) throws IOException {     checkNotClosed().     LOG.debug("Requesting subpartition {} of partition {} with {} ms delay.", subpartitionIndex, partitionId, delayMs).     clientHandler.addInputChannel(inputChannel).     final PartitionRequest request = new PartitionRequest(partitionId, subpartitionIndex, inputChannel.getInputChannelId(), inputChannel.getInitialCredit()).     final ChannelFutureListener listener = new ChannelFutureListener() {          @Override         public void operationComplete(ChannelFuture future) throws Exception {             if (!future.isSuccess()) {                 clientHandler.removeInputChannel(inputChannel).                 SocketAddress remoteAddr = future.channel().remoteAddress().                 inputChannel.onError(new LocalTransportException(String.format("Sending the partition request to '%s' failed.", remoteAddr), future.channel().localAddress(), future.cause())).             }         }     }.     if (delayMs == 0) {         ChannelFuture f = tcpChannel.writeAndFlush(request).         f.addListener(listener).         return f.     } else {         final ChannelFuture[] f = new ChannelFuture[1].         tcpChannel.eventLoop().schedule(new Runnable() {              @Override             public void run() {                 f[0] = tcpChannel.writeAndFlush(request).                 f[0].addListener(listener).             }         }, delayMs, TimeUnit.MILLISECONDS).         return f[0].     } }
false;public;1;10;;@Override public void operationComplete(ChannelFuture future) throws Exception {     if (!future.isSuccess()) {         SocketAddress remoteAddr = future.channel().remoteAddress().         inputChannel.onError(new LocalTransportException(String.format("Sending the task event to '%s' failed.", remoteAddr), future.channel().localAddress(), future.cause())).     } }
true;public;3;18;/**  * Sends a task event backwards to an intermediate result partition producer.  * <p>  * Backwards task events flow between readers and writers and therefore  * will only work when both are running at the same time, which is only  * guaranteed to be the case when both the respective producer and  * consumer task run pipelined.  */ ;/**  * Sends a task event backwards to an intermediate result partition producer.  * <p>  * Backwards task events flow between readers and writers and therefore  * will only work when both are running at the same time, which is only  * guaranteed to be the case when both the respective producer and  * consumer task run pipelined.  */ public void sendTaskEvent(ResultPartitionID partitionId, TaskEvent event, final RemoteInputChannel inputChannel) throws IOException {     checkNotClosed().     tcpChannel.writeAndFlush(new TaskEventRequest(event, partitionId, inputChannel.getInputChannelId())).addListener(new ChannelFutureListener() {          @Override         public void operationComplete(ChannelFuture future) throws Exception {             if (!future.isSuccess()) {                 SocketAddress remoteAddr = future.channel().remoteAddress().                 inputChannel.onError(new LocalTransportException(String.format("Sending the task event to '%s' failed.", remoteAddr), future.channel().localAddress(), future.cause())).             }         }     }). }
false;public;1;3;;public void notifyCreditAvailable(RemoteInputChannel inputChannel) {     clientHandler.notifyCreditAvailable(inputChannel). }
false;public;1;16;;public void close(RemoteInputChannel inputChannel) throws IOException {     clientHandler.removeInputChannel(inputChannel).     if (closeReferenceCounter.decrement()) {         // Close the TCP connection. Send a close request msg to ensure         // that outstanding backwards task events are not discarded.         tcpChannel.writeAndFlush(new NettyMessage.CloseRequest()).addListener(ChannelFutureListener.CLOSE_ON_FAILURE).         // Make sure to remove the client from the factory         clientFactory.destroyPartitionRequestClient(connectionId, this).     } else {         clientHandler.cancelRequestFor(inputChannel.getInputChannelId()).     } }
false;private;0;7;;private void checkNotClosed() throws IOException {     if (closeReferenceCounter.isDisposed()) {         final SocketAddress localAddr = tcpChannel.localAddress().         final SocketAddress remoteAddr = tcpChannel.remoteAddress().         throw new LocalTransportException(String.format("Channel to '%s' closed.", remoteAddr), localAddr).     } }
