commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public CheckpointStateOutputStream createCheckpointStateOutputStream(CheckpointedStateScope scope) throws IOException {     return new MemoryCheckpointOutputStream(maxStateSize). }
false;public;0;4;;@Override public String toString() {     return "In-Memory Stream Factory". }
false;static;2;8;;static void checkSize(int size, int maxSize) throws IOException {     if (size > maxSize) {         throw new IOException("Size of the state is larger than the maximum permitted memory-backed state. Size=" + size + " , maxSize=" + maxSize + " . Consider using a different state backend, like the File System State backend.").     } }
false;public;1;5;;@Override public void write(int b) throws IOException {     os.write(b).     isEmpty = false. }
false;public;3;5;;@Override public void write(byte[] b, int off, int len) throws IOException {     os.write(b, off, len).     isEmpty = false. }
false;public;0;4;;@Override public void flush() throws IOException {     os.flush(). }
false;public;0;2;;@Override public void sync() throws IOException { }
false;public;0;6;;// -------------------------------------------------------------------- @Override public void close() {     if (closed.compareAndSet(false, true)) {         closeInternal().     } }
false;public;0;8;;@Nullable @Override public StreamStateHandle closeAndGetHandle() throws IOException {     if (isEmpty) {         return null.     }     return new ByteStreamStateHandle(String.valueOf(UUID.randomUUID()), closeAndGetBytes()). }
false;public;0;4;;@Override public long getPos() throws IOException {     return os.getPosition(). }
false;public;0;3;;public boolean isClosed() {     return closed.get(). }
true;public;0;10;/**  * Closes the stream and returns the byte array containing the stream's data.  * @return The byte array containing the stream's data.  * @throws IOException Thrown if the size of the data exceeds the maximal  */ ;/**  * Closes the stream and returns the byte array containing the stream's data.  * @return The byte array containing the stream's data.  * @throws IOException Thrown if the size of the data exceeds the maximal  */ public byte[] closeAndGetBytes() throws IOException {     if (closed.compareAndSet(false, true)) {         checkSize(os.size(), maxSize).         byte[] bytes = os.toByteArray().         closeInternal().         return bytes.     } else {         throw new IOException("stream has already been closed").     } }
false;private;0;3;;private void closeInternal() {     os.reset(). }
