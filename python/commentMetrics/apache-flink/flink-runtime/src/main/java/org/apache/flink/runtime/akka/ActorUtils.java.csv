commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;30;/**  * Shuts the given {@link akka.actor.Actor} down in a non blocking fashion. The method first tries to  * gracefully shut them down. If this is not successful, then the actors will be terminated by sending  * a {@link akka.actor.Kill} message.  *  * @param gracePeriod for the graceful shutdown  * @param timeUnit time unit of the grace period  * @param actors to shut down  * @return Future which is completed once all actors have been shut down gracefully or forceful  * kill messages have been sent to all actors. Occurring errors will be suppressed into one error.  */ ;/**  * Shuts the given {@link akka.actor.Actor} down in a non blocking fashion. The method first tries to  * gracefully shut them down. If this is not successful, then the actors will be terminated by sending  * a {@link akka.actor.Kill} message.  *  * @param gracePeriod for the graceful shutdown  * @param timeUnit time unit of the grace period  * @param actors to shut down  * @return Future which is completed once all actors have been shut down gracefully or forceful  * kill messages have been sent to all actors. Occurring errors will be suppressed into one error.  */ public static CompletableFuture<Void> nonBlockingShutDown(long gracePeriod, TimeUnit timeUnit, ActorRef... actors) {     final Collection<CompletableFuture<Void>> terminationFutures = new ArrayList<>(actors.length).     final FiniteDuration timeout = new FiniteDuration(gracePeriod, timeUnit).     for (ActorRef actor : actors) {         try {             final Future<Boolean> booleanFuture = Patterns.gracefulStop(actor, timeout).             final CompletableFuture<Void> terminationFuture = FutureUtils.toJava(booleanFuture).<Void>thenApply(ignored -> null).exceptionally((Throwable throwable) -> {                 if (throwable instanceof TimeoutException) {                     // the actor did not gracefully stop within the grace period --> Let's kill him                     actor.tell(Kill.getInstance(), ActorRef.noSender()).                     return null.                 } else {                     throw new CompletionException(throwable).                 }             }).             terminationFutures.add(terminationFuture).         } catch (IllegalStateException ignored) {             // this can happen if the underlying actor system has been stopped before shutting             // the actor down             LOG.debug("The actor {} has already been stopped because the " + "underlying ActorSystem has already been shut down.", actor.path()).         }     }     return FutureUtils.completeAll(terminationFutures). }
false;public,static;1;3;;public static void stopActor(AkkaActorGateway akkaActorGateway) {     stopActor(akkaActorGateway.actor()). }
false;public,static;1;3;;public static void stopActor(ActorRef actorRef) {     actorRef.tell(PoisonPill.getInstance(), ActorRef.noSender()). }
