commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public String filterCharacters(String input) {     return replaceInvalidChars(input). }
false;public;0;4;;@Override public void postStop() {     serializer.close(). }
false;public;1;46;;@Override public void onReceive(Object message) {     try {         if (message instanceof AddMetric) {             AddMetric added = (AddMetric) message.             String metricName = added.metricName.             Metric metric = added.metric.             AbstractMetricGroup group = added.group.             QueryScopeInfo info = group.getQueryServiceMetricInfo(FILTER).             if (metric instanceof Counter) {                 counters.put((Counter) metric, new Tuple2<>(info, FILTER.filterCharacters(metricName))).             } else if (metric instanceof Gauge) {                 gauges.put((Gauge<?>) metric, new Tuple2<>(info, FILTER.filterCharacters(metricName))).             } else if (metric instanceof Histogram) {                 histograms.put((Histogram) metric, new Tuple2<>(info, FILTER.filterCharacters(metricName))).             } else if (metric instanceof Meter) {                 meters.put((Meter) metric, new Tuple2<>(info, FILTER.filterCharacters(metricName))).             }         } else if (message instanceof RemoveMetric) {             Metric metric = (((RemoveMetric) message).metric).             if (metric instanceof Counter) {                 this.counters.remove(metric).             } else if (metric instanceof Gauge) {                 this.gauges.remove(metric).             } else if (metric instanceof Histogram) {                 this.histograms.remove(metric).             } else if (metric instanceof Meter) {                 this.meters.remove(metric).             }         } else if (message instanceof CreateDump) {             MetricDumpSerialization.MetricSerializationResult dump = serializer.serialize(counters, gauges, histograms, meters).             dump = enforceSizeLimit(dump).             getSender().tell(dump, getSelf()).         } else {             LOG.warn("MetricQueryServiceActor received an invalid message. " + message.toString()).             getSender().tell(new Status.Failure(new IOException("MetricQueryServiceActor received an invalid message. " + message.toString())), getSelf()).         }     } catch (Exception e) {         LOG.warn("An exception occurred while processing a message.", e).     } }
false;private;1;62;;private MetricDumpSerialization.MetricSerializationResult enforceSizeLimit(MetricDumpSerialization.MetricSerializationResult serializationResult) {     int currentLength = 0.     boolean hasExceededBefore = false.     byte[] serializedCounters = serializationResult.serializedCounters.     int numCounters = serializationResult.numCounters.     if (exceedsMessageSizeLimit(currentLength + serializationResult.serializedCounters.length)) {         logDumpSizeWouldExceedLimit("Counters", hasExceededBefore).         hasExceededBefore = true.         serializedCounters = new byte[0].         numCounters = 0.     } else {         currentLength += serializedCounters.length.     }     byte[] serializedMeters = serializationResult.serializedMeters.     int numMeters = serializationResult.numMeters.     if (exceedsMessageSizeLimit(currentLength + serializationResult.serializedMeters.length)) {         logDumpSizeWouldExceedLimit("Meters", hasExceededBefore).         hasExceededBefore = true.         serializedMeters = new byte[0].         numMeters = 0.     } else {         currentLength += serializedMeters.length.     }     byte[] serializedGauges = serializationResult.serializedGauges.     int numGauges = serializationResult.numGauges.     if (exceedsMessageSizeLimit(currentLength + serializationResult.serializedGauges.length)) {         logDumpSizeWouldExceedLimit("Gauges", hasExceededBefore).         hasExceededBefore = true.         serializedGauges = new byte[0].         numGauges = 0.     } else {         currentLength += serializedGauges.length.     }     byte[] serializedHistograms = serializationResult.serializedHistograms.     int numHistograms = serializationResult.numHistograms.     if (exceedsMessageSizeLimit(currentLength + serializationResult.serializedHistograms.length)) {         logDumpSizeWouldExceedLimit("Histograms", hasExceededBefore).         hasExceededBefore = true.         serializedHistograms = new byte[0].         numHistograms = 0.     }     return new MetricDumpSerialization.MetricSerializationResult(serializedCounters, serializedGauges, serializedMeters, serializedHistograms, numCounters, numGauges, numMeters, numHistograms). }
false;private;1;3;;private boolean exceedsMessageSizeLimit(final int currentSize) {     return currentSize > messageSizeLimit. }
false;private;2;9;;private void logDumpSizeWouldExceedLimit(final String metricType, boolean hasExceededBefore) {     if (LOG.isDebugEnabled()) {         LOG.debug(SIZE_EXCEEDED_LOG_TEMPLATE, metricType, messageSizeLimit).     } else {         if (!hasExceededBefore) {             LOG.info(SIZE_EXCEEDED_LOG_TEMPLATE, "Some metrics", messageSizeLimit).         }     } }
true;static;1;27;/**  * Lightweight method to replace unsupported characters.  * If the string does not contain any unsupported characters, this method creates no  * new string (and in fact no new objects at all).  *  * <p>Replacements:  *  * <ul>  *     <li>{@code space : . ,} are replaced by {@code _} (underscore)</li>  * </ul>  */ ;/**  * Lightweight method to replace unsupported characters.  * If the string does not contain any unsupported characters, this method creates no  * new string (and in fact no new objects at all).  *  * <p>Replacements:  *  * <ul>  *     <li>{@code space : . ,} are replaced by {@code _} (underscore)</li>  * </ul>  */ static String replaceInvalidChars(String str) {     char[] chars = null.     final int strLen = str.length().     int pos = 0.     for (int i = 0. i < strLen. i++) {         final char c = str.charAt(i).         switch(c) {             case ' ':             case '.':             case ':':             case ',':                 if (chars == null) {                     chars = str.toCharArray().                 }                 chars[pos++] = '_'.                 break.             default:                 if (chars != null) {                     chars[pos] = c.                 }                 pos++.         }     }     return chars == null ? str : new String(chars, 0, pos). }
true;public,static;3;11;/**  * Starts the MetricQueryService actor in the given actor system.  *  * @param actorSystem The actor system running the MetricQueryService  * @param resourceID resource ID to disambiguate the actor name  * @return actor reference to the MetricQueryService  */ ;/**  * Starts the MetricQueryService actor in the given actor system.  *  * @param actorSystem The actor system running the MetricQueryService  * @param resourceID resource ID to disambiguate the actor name  * @return actor reference to the MetricQueryService  */ public static ActorRef startMetricQueryService(ActorSystem actorSystem, ResourceID resourceID, long maximumFramesize) {     String actorName = resourceID == null ? METRIC_QUERY_SERVICE_NAME : METRIC_QUERY_SERVICE_NAME + "_" + resourceID.getResourceIdString().     return actorSystem.actorOf(Props.create(MetricQueryService.class, maximumFramesize), actorName). }
true;public,static;4;3;/**  * Utility method to notify a MetricQueryService of an added metric.  *  * @param service    MetricQueryService to notify  * @param metric     added metric  * @param metricName metric name  * @param group      group the metric was added on  */ ;/**  * Utility method to notify a MetricQueryService of an added metric.  *  * @param service    MetricQueryService to notify  * @param metric     added metric  * @param metricName metric name  * @param group      group the metric was added on  */ public static void notifyOfAddedMetric(ActorRef service, Metric metric, String metricName, AbstractMetricGroup group) {     service.tell(new AddMetric(metricName, metric, group), null). }
true;public,static;2;3;/**  * Utility method to notify a MetricQueryService of a removed metric.  *  * @param service MetricQueryService to notify  * @param metric  removed metric  */ ;/**  * Utility method to notify a MetricQueryService of a removed metric.  *  * @param service MetricQueryService to notify  * @param metric  removed metric  */ public static void notifyOfRemovedMetric(ActorRef service, Metric metric) {     service.tell(new RemoveMetric(metric), null). }
false;public,static;0;3;;public static Object getCreateDump() {     return CreateDump.INSTANCE. }
