commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;public void waitForFirstBlock() throws IOException {     if (getCurrentSegment() == null) {         advance().     } }
false;public;0;3;;public boolean isClosed() {     return this.closed. }
true;public;0;28;/**  * Closes this InputView, closing the underlying reader and returning all memory segments.  *  * @return A list containing all memory segments originally supplied to this view.  * @throws IOException Thrown, if the underlying reader could not be properly closed.  */ ;/**  * Closes this InputView, closing the underlying reader and returning all memory segments.  *  * @return A list containing all memory segments originally supplied to this view.  * @throws IOException Thrown, if the underlying reader could not be properly closed.  */ public List<MemorySegment> close() throws IOException {     if (this.closed) {         throw new IllegalStateException("Already closed.").     }     this.closed = true.     // re-collect all memory segments     ArrayList<MemorySegment> list = this.freeMem.     final MemorySegment current = getCurrentSegment().     if (current != null) {         list.add(current).     }     clear().     // close the writer and gather all segments     final LinkedBlockingQueue<MemorySegment> queue = this.reader.getReturnQueue().     this.reader.close().     while (list.size() < this.numSegments) {         final MemorySegment m = queue.poll().         if (m == null) {             // we get null if the queue is empty. that should not be the case if the reader was properly closed.             throw new RuntimeException("Bug in ChannelReaderInputView: MemorySegments lost.").         }         list.add(m).     }     return list. }
true;protected;1;29;/**  * Gets the next segment from the asynchronous block reader. If more requests are to be issued, the method  * first sends a new request with the current memory segment. If no more requests are pending, the method  * adds the segment to the readers return queue, which thereby effectively collects all memory segments.  * Secondly, the method fetches the next non-consumed segment  * returned by the reader. If no further segments are available, this method thrown an {@link EOFException}.  *  * @param current The memory segment used for the next request.  * @return The memory segment to read from next.  *  * @throws EOFException Thrown, if no further segments are available.  * @throws IOException Thrown, if an I/O error occurred while reading  * @see AbstractPagedInputView#nextSegment(org.apache.flink.core.memory.MemorySegment)  */ ;// -------------------------------------------------------------------------------------------- // Utilities // -------------------------------------------------------------------------------------------- /**  * Gets the next segment from the asynchronous block reader. If more requests are to be issued, the method  * first sends a new request with the current memory segment. If no more requests are pending, the method  * adds the segment to the readers return queue, which thereby effectively collects all memory segments.  * Secondly, the method fetches the next non-consumed segment  * returned by the reader. If no further segments are available, this method thrown an {@link EOFException}.  *  * @param current The memory segment used for the next request.  * @return The memory segment to read from next.  *  * @throws EOFException Thrown, if no further segments are available.  * @throws IOException Thrown, if an I/O error occurred while reading  * @see AbstractPagedInputView#nextSegment(org.apache.flink.core.memory.MemorySegment)  */ @Override protected MemorySegment nextSegment(MemorySegment current) throws IOException {     // check if we are at our end     if (this.inLastBlock) {         throw new EOFException().     }     // the next lines     if (current != null) {         sendReadRequest(current).     }     // get the next segment     final MemorySegment seg = this.reader.getNextReturnedBlock().     // check the header     if (seg.getShort(0) != ChannelWriterOutputView.HEADER_MAGIC_NUMBER) {         throw new IOException("The current block does not belong to a ChannelWriterOutputView / " + "ChannelReaderInputView: Wrong magic number.").     }     if ((seg.getShort(ChannelWriterOutputView.HEADER_FLAGS_OFFSET) & ChannelWriterOutputView.FLAG_LAST_BLOCK) != 0) {         // last block         this.numRequestsRemaining = 0.         this.inLastBlock = true.     }     return seg. }
false;protected;1;4;;@Override protected int getLimitForSegment(MemorySegment segment) {     return segment.getInt(ChannelWriterOutputView.HEAD_BLOCK_LENGTH_OFFSET). }
true;protected;1;11;/**  * Sends a new read requests, if further requests remain. Otherwise, this method adds the segment  * directly to the readers return queue.  *  * @param seg The segment to use for the read request.  * @throws IOException Thrown, if the reader is in error.  */ ;/**  * Sends a new read requests, if further requests remain. Otherwise, this method adds the segment  * directly to the readers return queue.  *  * @param seg The segment to use for the read request.  * @throws IOException Thrown, if the reader is in error.  */ protected void sendReadRequest(MemorySegment seg) throws IOException {     if (this.numRequestsRemaining != 0) {         this.reader.readBlock(seg).         if (this.numRequestsRemaining != -1) {             this.numRequestsRemaining--.         }     } else {         // directly add it to the end of the return queue         this.freeMem.add(seg).     } }
