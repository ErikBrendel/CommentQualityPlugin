commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;16;/**  * This method is called by Akka if a new message has arrived for the actor. It logs the  * processing time of the incoming message if the logging level is set to debug. After logging  * the handleLeaderSessionID method is called.  *  * <p>Important: This method cannot be overridden. The actor specific message handling logic is  * implemented by the method handleMessage.  *  * @param message Incoming message  * @throws Exception  */ ;// CHECKSTYLE.ON: MemberNameCheck /**  * This method is called by Akka if a new message has arrived for the actor. It logs the  * processing time of the incoming message if the logging level is set to debug. After logging  * the handleLeaderSessionID method is called.  *  * <p>Important: This method cannot be overridden. The actor specific message handling logic is  * implemented by the method handleMessage.  *  * @param message Incoming message  * @throws Exception  */ @Override public final void onReceive(Object message) throws Exception {     if (LOG.isTraceEnabled()) {         LOG.trace("Received message {} at {} from {}.", message, getSelf().path(), getSender()).         long start = System.nanoTime().         handleLeaderSessionID(message).         long duration = (System.nanoTime() - start) / 1_000_000.         LOG.trace("Handled message {} in {} ms from {}.", message, duration, getSender()).     } else {         handleLeaderSessionID(message).     } }
true;private;1;23;/**  * This method filters out {@link LeaderSessionMessage} whose leader session ID is not equal  * to the actors leader session ID. If a message of type {@link RequiresLeaderSessionID}  * arrives, then an Exception is thrown, because these messages have to be wrapped in a  * {@link LeaderSessionMessage}.  *  * @param message Incoming message  * @throws Exception  */ ;/**  * This method filters out {@link LeaderSessionMessage} whose leader session ID is not equal  * to the actors leader session ID. If a message of type {@link RequiresLeaderSessionID}  * arrives, then an Exception is thrown, because these messages have to be wrapped in a  * {@link LeaderSessionMessage}.  *  * @param message Incoming message  * @throws Exception  */ private void handleLeaderSessionID(Object message) throws Exception {     if (message instanceof LeaderSessionMessage) {         LeaderSessionMessage msg = (LeaderSessionMessage) message.         UUID expectedID = getLeaderSessionID().         UUID actualID = msg.leaderSessionID().         if (expectedID != null) {             if (expectedID.equals(actualID)) {                 handleMessage(msg.message()).             } else {                 handleDiscardedMessage(expectedID, msg).             }         } else {             handleNoLeaderId(msg).         }     } else if (message instanceof RequiresLeaderSessionID) {         throw new Exception("Received a message " + message + " without a leader session " + "ID, even though the message requires a leader session ID.").     } else {         // call method to handle message         handleMessage(message).     } }
false;private;2;5;;private void handleDiscardedMessage(UUID expectedLeaderSessionID, LeaderSessionMessage msg) {     LOG.warn("Discard message {} because the expected leader session ID {} did not " + "equal the received leader session ID {}.", msg, expectedLeaderSessionID, msg.leaderSessionID()). }
false;private;1;3;;private void handleNoLeaderId(LeaderSessionMessage msg) {     LOG.warn("Discard message {} because there is currently no valid leader id known.", msg). }
true;protected,abstract;1;1;/**  * This method contains the actor logic which defines how to react to incoming messages.  *  * @param message Incoming message  * @throws Exception  */ ;/**  * This method contains the actor logic which defines how to react to incoming messages.  *  * @param message Incoming message  * @throws Exception  */ protected abstract void handleMessage(Object message) throws Exception.
true;protected,abstract;0;1;/**  * Returns the current leader session ID associated with this actor.  * @return  */ ;/**  * Returns the current leader session ID associated with this actor.  * @return  */ protected abstract UUID getLeaderSessionID().
true;protected;1;7;/**  * This method should be called for every outgoing message. It wraps messages which require  * a leader session ID (indicated by {@link RequiresLeaderSessionID}) in a  * {@link LeaderSessionMessage} with the actor's leader session ID.  *  * <p>This method can be overridden to implement a different decoration behavior.  *  * @param message Message to be decorated  * @return The decorated message  */ ;/**  * This method should be called for every outgoing message. It wraps messages which require  * a leader session ID (indicated by {@link RequiresLeaderSessionID}) in a  * {@link LeaderSessionMessage} with the actor's leader session ID.  *  * <p>This method can be overridden to implement a different decoration behavior.  *  * @param message Message to be decorated  * @return The decorated message  */ protected Object decorateMessage(Object message) {     if (message instanceof RequiresLeaderSessionID) {         return new LeaderSessionMessage(getLeaderSessionID(), message).     } else {         return message.     } }
