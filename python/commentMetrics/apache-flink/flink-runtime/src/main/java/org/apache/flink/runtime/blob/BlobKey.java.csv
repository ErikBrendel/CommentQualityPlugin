commented;modifiers;parameterAmount;loc;comment;code
true;static;1;8;/**  * Returns the right {@link BlobKey} subclass for the given parameters.  *  * @param type  * 		whether the referenced BLOB is permanent or transient  *  * @return BlobKey subclass  */ ;/**  * Returns the right {@link BlobKey} subclass for the given parameters.  *  * @param type  * 		whether the referenced BLOB is permanent or transient  *  * @return BlobKey subclass  */ @VisibleForTesting static BlobKey createKey(BlobType type) {     if (type == PERMANENT_BLOB) {         return new PermanentBlobKey().     } else {         return new TransientBlobKey().     } }
true;static;2;7;/**  * Returns the right {@link BlobKey} subclass for the given parameters.  *  * @param type  * 		whether the referenced BLOB is permanent or transient  * @param key  *        the actual key data  *  * @return BlobKey subclass  */ ;/**  * Returns the right {@link BlobKey} subclass for the given parameters.  *  * @param type  * 		whether the referenced BLOB is permanent or transient  * @param key  *        the actual key data  *  * @return BlobKey subclass  */ static BlobKey createKey(BlobType type, byte[] key) {     if (type == PERMANENT_BLOB) {         return new PermanentBlobKey(key).     } else {         return new TransientBlobKey(key).     } }
true;static;3;7;/**  * Returns the right {@link BlobKey} subclass for the given parameters.  *  * @param type  * 		whether the referenced BLOB is permanent or transient  * @param key  *        the actual key data  * @param random  *        the random component of the key  *  * @return BlobKey subclass  */ ;/**  * Returns the right {@link BlobKey} subclass for the given parameters.  *  * @param type  * 		whether the referenced BLOB is permanent or transient  * @param key  *        the actual key data  * @param random  *        the random component of the key  *  * @return BlobKey subclass  */ static BlobKey createKey(BlobType type, byte[] key, byte[] random) {     if (type == PERMANENT_BLOB) {         return new PermanentBlobKey(key, random).     } else {         return new TransientBlobKey(key, random).     } }
true;public;0;4;/**  * Returns the hash component of this key.  *  * @return a 20 bit hash of the contents the key refers to  */ ;/**  * Returns the hash component of this key.  *  * @return a 20 bit hash of the contents the key refers to  */ @VisibleForTesting public byte[] getHash() {     return key. }
true;;0;3;/**  * Returns the (internal) BLOB type which is reflected by the inheriting sub-class.  *  * @return BLOB type, i.e. permanent or transient  */ ;/**  * Returns the (internal) BLOB type which is reflected by the inheriting sub-class.  *  * @return BLOB type, i.e. permanent or transient  */ BlobType getType() {     return type. }
true;public;1;3;/**  * Adds the BLOB key to the given {@link MessageDigest}.  *  * @param md  *        the message digest to add the BLOB key to  */ ;/**  * Adds the BLOB key to the given {@link MessageDigest}.  *  * @param md  *        the message digest to add the BLOB key to  */ public void addToMessageDigest(MessageDigest md) {     md.update(this.key). }
false;public;1;13;;@Override public boolean equals(final Object obj) {     if (!(obj instanceof BlobKey)) {         return false.     }     final BlobKey bk = (BlobKey) obj.     return Arrays.equals(this.key, bk.key) && this.type == bk.type && this.random.equals(bk.random). }
false;public;0;7;;@Override public int hashCode() {     int result = Arrays.hashCode(this.key).     result = 37 * result + this.type.hashCode().     result = 37 * result + this.random.hashCode().     return result. }
false;public;0;16;;@Override public String toString() {     final String typeString.     switch(this.type) {         case TRANSIENT_BLOB:             typeString = "t-".             break.         case PERMANENT_BLOB:             typeString = "p-".             break.         default:             // this actually never happens!             throw new IllegalStateException("Invalid BLOB type").     }     return typeString + StringUtils.byteToHexString(this.key) + "-" + random.toString(). }
false;public;1;28;;@Override public int compareTo(BlobKey o) {     // compare the hashes first     final byte[] aarr = this.key.     final byte[] barr = o.key.     final int len = Math.min(aarr.length, barr.length).     for (int i = 0. i < len. ++i) {         final int a = (aarr[i] & 0xff).         final int b = (barr[i] & 0xff).         if (a != b) {             return a - b.         }     }     if (aarr.length == barr.length) {         // same hash contents - compare the BLOB types         int typeCompare = this.type.compareTo(o.type).         if (typeCompare == 0) {             // same type - compare random components             return this.random.compareTo(o.random).         } else {             return typeCompare.         }     } else {         return aarr.length - barr.length.     } }
true;static;1;42;/**  * Auxiliary method to read a BLOB key from an input stream.  *  * @param inputStream  *        the input stream to read the BLOB key from  * @return the read BLOB key  * @throws IOException  *         throw if an I/O error occurs while reading from the input stream  */ ;// -------------------------------------------------------------------------------------------- /**  * Auxiliary method to read a BLOB key from an input stream.  *  * @param inputStream  *        the input stream to read the BLOB key from  * @return the read BLOB key  * @throws IOException  *         throw if an I/O error occurs while reading from the input stream  */ static BlobKey readFromInputStream(InputStream inputStream) throws IOException {     final byte[] key = new byte[BlobKey.SIZE].     final byte[] random = new byte[AbstractID.SIZE].     int bytesRead = 0.     // read key     while (bytesRead < key.length) {         final int read = inputStream.read(key, bytesRead, key.length - bytesRead).         if (read < 0) {             throw new EOFException("Read an incomplete BLOB key").         }         bytesRead += read.     }     // read BLOB type     final BlobType blobType.     {         final int read = inputStream.read().         if (read < 0) {             throw new EOFException("Read an incomplete BLOB type").         } else if (read == TRANSIENT_BLOB.ordinal()) {             blobType = TRANSIENT_BLOB.         } else if (read == PERMANENT_BLOB.ordinal()) {             blobType = PERMANENT_BLOB.         } else {             throw new IOException("Invalid data received for the BLOB type: " + read).         }     }     // read random component     bytesRead = 0.     while (bytesRead < AbstractID.SIZE) {         final int read = inputStream.read(random, bytesRead, AbstractID.SIZE - bytesRead).         if (read < 0) {             throw new EOFException("Read an incomplete BLOB key").         }         bytesRead += read.     }     return createKey(blobType, key, random). }
true;;1;5;/**  * Auxiliary method to write this BLOB key to an output stream.  *  * @param outputStream  *        the output stream to write the BLOB key to  * @throws IOException  *         thrown if an I/O error occurs while writing the BLOB key  */ ;/**  * Auxiliary method to write this BLOB key to an output stream.  *  * @param outputStream  *        the output stream to write the BLOB key to  * @throws IOException  *         thrown if an I/O error occurs while writing the BLOB key  */ void writeToOutputStream(final OutputStream outputStream) throws IOException {     outputStream.write(this.key).     outputStream.write(this.type.ordinal()).     outputStream.write(this.random.getBytes()). }
