commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;// -------------------------------------------------------------------------------------------- @Override public boolean isInputResettable(int inputNum) {     if (inputNum < 0 || inputNum > 1) {         throw new IndexOutOfBoundsException().     }     return inputNum == buildSideIndex. }
false;public;0;97;;@Override public void initialize() throws Exception {     TaskConfig config = this.taskContext.getTaskConfig().     final Counter numRecordsIn = taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsInCounter().     TypeSerializer<IT1> serializer1 = this.taskContext.<IT1>getInputSerializer(0).getSerializer().     TypeSerializer<IT2> serializer2 = this.taskContext.<IT2>getInputSerializer(1).getSerializer().     TypeComparator<IT1> comparator1 = this.taskContext.getDriverComparator(0).     TypeComparator<IT2> comparator2 = this.taskContext.getDriverComparator(1).     MutableObjectIterator<IT1> input1 = new CountingMutableObjectIterator<>(this.taskContext.<IT1>getInput(0), numRecordsIn).     MutableObjectIterator<IT2> input2 = new CountingMutableObjectIterator<>(this.taskContext.<IT2>getInput(1), numRecordsIn).     TypePairComparatorFactory<IT1, IT2> pairComparatorFactory = this.taskContext.getTaskConfig().getPairComparatorFactory(this.taskContext.getUserCodeClassLoader()).     double availableMemory = config.getRelativeMemoryDriver().     boolean hashJoinUseBitMaps = taskContext.getTaskManagerInfo().getConfiguration().getBoolean(AlgorithmOptions.HASH_JOIN_BLOOM_FILTERS).     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     objectReuseEnabled = executionConfig.isObjectReuseEnabled().     if (objectReuseEnabled) {         if (buildSideIndex == 0 && probeSideIndex == 1) {             matchIterator = new ReusingBuildFirstReOpenableHashJoinIterator<IT1, IT2, OT>(input1, input2, serializer1, comparator1, serializer2, comparator2, pairComparatorFactory.createComparator21(comparator1, comparator2), this.taskContext.getMemoryManager(), this.taskContext.getIOManager(), this.taskContext.getContainingTask(), availableMemory, false, false, hashJoinUseBitMaps).         } else if (buildSideIndex == 1 && probeSideIndex == 0) {             matchIterator = new ReusingBuildSecondReOpenableHashJoinIterator<IT1, IT2, OT>(input1, input2, serializer1, comparator1, serializer2, comparator2, pairComparatorFactory.createComparator12(comparator1, comparator2), this.taskContext.getMemoryManager(), this.taskContext.getIOManager(), this.taskContext.getContainingTask(), availableMemory, false, false, hashJoinUseBitMaps).         } else {             throw new Exception("Error: Inconsistent setup for repeatable hash join driver.").         }     } else {         if (buildSideIndex == 0 && probeSideIndex == 1) {             matchIterator = new NonReusingBuildFirstReOpenableHashJoinIterator<IT1, IT2, OT>(input1, input2, serializer1, comparator1, serializer2, comparator2, pairComparatorFactory.createComparator21(comparator1, comparator2), this.taskContext.getMemoryManager(), this.taskContext.getIOManager(), this.taskContext.getContainingTask(), availableMemory, false, false, hashJoinUseBitMaps).         } else if (buildSideIndex == 1 && probeSideIndex == 0) {             matchIterator = new NonReusingBuildSecondReOpenableHashJoinIterator<IT1, IT2, OT>(input1, input2, serializer1, comparator1, serializer2, comparator2, pairComparatorFactory.createComparator12(comparator1, comparator2), this.taskContext.getMemoryManager(), this.taskContext.getIOManager(), this.taskContext.getContainingTask(), availableMemory, false, false, hashJoinUseBitMaps).         } else {             throw new Exception("Error: Inconsistent setup for repeatable hash join driver.").         }     }     this.matchIterator.open(). }
false;public;0;4;;@Override public void prepare() throws Exception { // nothing }
false;public;0;9;;@Override public void run() throws Exception {     final Counter numRecordsOut = taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsOutCounter().     final FlatJoinFunction<IT1, IT2, OT> matchStub = this.taskContext.getStub().     final Collector<OT> collector = new CountingCollector<>(this.taskContext.getOutputCollector(), numRecordsOut).     while (this.running && matchIterator != null && matchIterator.callWithNextKey(matchStub, collector)) {     } }
false;public;0;2;;@Override public void cleanup() throws Exception { }
false;public;0;26;;@Override public void reset() throws Exception {     MutableObjectIterator<IT1> input1 = this.taskContext.getInput(0).     MutableObjectIterator<IT2> input2 = this.taskContext.getInput(1).     if (objectReuseEnabled) {         if (buildSideIndex == 0 && probeSideIndex == 1) {             final ReusingBuildFirstReOpenableHashJoinIterator<IT1, IT2, OT> matchIterator = (ReusingBuildFirstReOpenableHashJoinIterator<IT1, IT2, OT>) this.matchIterator.             matchIterator.reopenProbe(input2).         } else {             final ReusingBuildSecondReOpenableHashJoinIterator<IT1, IT2, OT> matchIterator = (ReusingBuildSecondReOpenableHashJoinIterator<IT1, IT2, OT>) this.matchIterator.             matchIterator.reopenProbe(input1).         }     } else {         if (buildSideIndex == 0 && probeSideIndex == 1) {             final NonReusingBuildFirstReOpenableHashJoinIterator<IT1, IT2, OT> matchIterator = (NonReusingBuildFirstReOpenableHashJoinIterator<IT1, IT2, OT>) this.matchIterator.             matchIterator.reopenProbe(input2).         } else {             final NonReusingBuildSecondReOpenableHashJoinIterator<IT1, IT2, OT> matchIterator = (NonReusingBuildSecondReOpenableHashJoinIterator<IT1, IT2, OT>) this.matchIterator.             matchIterator.reopenProbe(input1).         }     } }
false;public;0;7;;@Override public void teardown() {     this.running = false.     if (this.matchIterator != null) {         this.matchIterator.close().     } }
false;public;0;7;;@Override public void cancel() {     this.running = false.     if (this.matchIterator != null) {         this.matchIterator.abort().     } }
