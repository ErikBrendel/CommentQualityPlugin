commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public boolean isClosed() {     return this.closed. }
true;public;0;36;/**  * Closes the channel and waits until all pending asynchronous requests are processed. The  * underlying <code>FileChannel</code> is closed even if an exception interrupts the closing.  *  * <p> <strong>Important:</strong> the {@link #isClosed()} method returns <code>true</code>  * immediately after this method has been called even when there are outstanding requests.  *  * @throws IOException Thrown, if an I/O exception occurred while waiting for the buffers, or if  *                     the closing was interrupted.  */ ;/**  * Closes the channel and waits until all pending asynchronous requests are processed. The  * underlying <code>FileChannel</code> is closed even if an exception interrupts the closing.  *  * <p> <strong>Important:</strong> the {@link #isClosed()} method returns <code>true</code>  * immediately after this method has been called even when there are outstanding requests.  *  * @throws IOException Thrown, if an I/O exception occurred while waiting for the buffers, or if  *                     the closing was interrupted.  */ @Override public void close() throws IOException {     // atomically set the close flag     synchronized (this.closeLock) {         if (this.closed) {             return.         }         this.closed = true.         try {             // only then is everything guaranteed to be consistent.             while (this.requestsNotReturned.get() > 0) {                 try {                     // we add a timeout here, because it is not guaranteed that the                     // decrementing during buffer return and the check here are deadlock free.                     // the deadlock situation is however unlikely and caught by the timeout                     this.closeLock.wait(1000).                     checkErroneous().                 } catch (InterruptedException iex) {                     throw new IOException("Closing of asynchronous file channel was interrupted.").                 }             }             // Additional check because we might have skipped the while loop             checkErroneous().         } finally {             // close the file             if (this.fileChannel.isOpen()) {                 this.fileChannel.close().             }         }     } }
true;public;0;9;/**  * This method waits for all pending asynchronous requests to return. When the  * last request has returned, the channel is closed and deleted.  * <p>  * Even if an exception interrupts the closing, such that not all request are handled,  * the underlying <tt>FileChannel</tt> is closed and deleted.  *  * @throws IOException Thrown, if an I/O exception occurred while waiting for the buffers, or if the closing was interrupted.  */ ;/**  * This method waits for all pending asynchronous requests to return. When the  * last request has returned, the channel is closed and deleted.  * <p>  * Even if an exception interrupts the closing, such that not all request are handled,  * the underlying <tt>FileChannel</tt> is closed and deleted.  *  * @throws IOException Thrown, if an I/O exception occurred while waiting for the buffers, or if the closing was interrupted.  */ @Override public void closeAndDelete() throws IOException {     try {         close().     } finally {         deleteChannel().     } }
true;public,final;0;5;/**  * Checks the exception state of this channel. The channel is erroneous, if one of its requests could not  * be processed correctly.  *  * @throws IOException Thrown, if the channel is erroneous. The thrown exception contains the original exception  *                     that defined the erroneous state as its cause.  */ ;/**  * Checks the exception state of this channel. The channel is erroneous, if one of its requests could not  * be processed correctly.  *  * @throws IOException Thrown, if the channel is erroneous. The thrown exception contains the original exception  *                     that defined the erroneous state as its cause.  */ public final void checkErroneous() throws IOException {     if (this.exception != null) {         throw this.exception.     } }
true;final,protected;2;38;/**  * Handles a processed <tt>Buffer</tt>. This method is invoked by the  * asynchronous IO worker threads upon completion of the IO request with the  * provided buffer and/or an exception that occurred while processing the request  * for that buffer.  *  * @param buffer The buffer to be processed.  * @param ex     The exception that occurred in the I/O threads when processing the buffer's request.  */ ;/**  * Handles a processed <tt>Buffer</tt>. This method is invoked by the  * asynchronous IO worker threads upon completion of the IO request with the  * provided buffer and/or an exception that occurred while processing the request  * for that buffer.  *  * @param buffer The buffer to be processed.  * @param ex     The exception that occurred in the I/O threads when processing the buffer's request.  */ final protected void handleProcessedBuffer(T buffer, IOException ex) {     if (buffer == null) {         return.     }     // even if the callbacks throw an error, we need to maintain our bookkeeping     try {         if (ex != null && this.exception == null) {             this.exception = ex.             this.resultHandler.requestFailed(buffer, ex).         } else {             this.resultHandler.requestSuccessful(buffer).         }     } finally {         NotificationListener listener = null.         // waiters. If there is a listener, notify her as well.         synchronized (this.closeLock) {             if (this.requestsNotReturned.decrementAndGet() == 0) {                 if (this.closed) {                     this.closeLock.notifyAll().                 }                 synchronized (listenerLock) {                     listener = allRequestsProcessedListener.                     allRequestsProcessedListener = null.                 }             }         }         if (listener != null) {             listener.onNotification().         }     } }
false;final,protected;1;28;;final protected void addRequest(R request) throws IOException {     // check the error state of this channel     checkErroneous().     // write the current buffer and get the next one     this.requestsNotReturned.incrementAndGet().     if (this.closed || this.requestQueue.isClosed()) {         // if we found ourselves closed after the counter increment,         // decrement the counter again and do not forward the request         this.requestsNotReturned.decrementAndGet().         final NotificationListener listener.         synchronized (listenerLock) {             listener = allRequestsProcessedListener.             allRequestsProcessedListener = null.         }         if (listener != null) {             listener.onNotification().         }         throw new IOException("I/O channel already closed. Could not fulfill: " + request).     }     this.requestQueue.add(request). }
true;protected;1;18;/**  * Registers a listener to be notified when all outstanding requests have been processed.  *  * <p> New requests can arrive right after the listener got notified. Therefore, it is not safe  * to assume that the number of outstanding requests is still zero after a notification unless  * there was a close right before the listener got called.  *  * <p> Returns <code>true</code>, if the registration was successful. A registration can fail,  * if there are no outstanding requests when trying to register a listener.  */ ;/**  * Registers a listener to be notified when all outstanding requests have been processed.  *  * <p> New requests can arrive right after the listener got notified. Therefore, it is not safe  * to assume that the number of outstanding requests is still zero after a notification unless  * there was a close right before the listener got called.  *  * <p> Returns <code>true</code>, if the registration was successful. A registration can fail,  * if there are no outstanding requests when trying to register a listener.  */ protected boolean registerAllRequestsProcessedListener(NotificationListener listener) throws IOException {     checkNotNull(listener).     synchronized (listenerLock) {         if (allRequestsProcessedListener == null) {             // There was a race with the processing of the last outstanding request             if (requestsNotReturned.get() == 0) {                 return false.             }             allRequestsProcessedListener = listener.             return true.         }     }     throw new IllegalStateException("Already subscribed."). }
false;public;0;13;;@Override public void read() throws IOException {     final FileChannel c = this.channel.fileChannel.     if (c.size() - c.position() > 0) {         try {             final ByteBuffer wrapper = this.segment.wrap(0, this.segment.size()).             this.channel.fileChannel.read(wrapper).         } catch (NullPointerException npex) {             throw new IOException("Memory segment has been released.").         }     } }
false;public;1;4;;@Override public void requestDone(IOException ioex) {     this.channel.handleProcessedBuffer(this.segment, ioex). }
false;public;0;9;;@Override public void write() throws IOException {     try {         FileUtils.writeCompletely(this.channel.fileChannel, this.segment.wrap(0, this.segment.size())).     } catch (NullPointerException npex) {         throw new IOException("Memory segment has been released.").     } }
false;public;1;4;;@Override public void requestDone(IOException ioex) {     this.channel.handleProcessedBuffer(this.segment, ioex). }
false;public;0;13;;@Override public void write() throws IOException {     ByteBuffer nioBufferReadable = buffer.getNioBufferReadable().     final ByteBuffer header = ByteBuffer.allocateDirect(8).     header.putInt(buffer.isBuffer() ? 1 : 0).     header.putInt(nioBufferReadable.remaining()).     header.flip().     FileUtils.writeCompletely(channel.fileChannel, header).     FileUtils.writeCompletely(channel.fileChannel, nioBufferReadable). }
false;public;1;4;;@Override public void requestDone(IOException error) {     channel.handleProcessedBuffer(buffer, error). }
false;public;0;13;;@Override public void read() throws IOException {     final FileChannel fileChannel = channel.fileChannel.     if (fileChannel.size() - fileChannel.position() > 0) {         BufferFileChannelReader reader = new BufferFileChannelReader(fileChannel).         hasReachedEndOfFile.set(reader.readBufferFromFileChannel(buffer)).     } else {         hasReachedEndOfFile.set(true).     } }
false;public;1;4;;@Override public void requestDone(IOException error) {     channel.handleProcessedBuffer(buffer, error). }
false;public;0;27;;@Override public void read() throws IOException {     final FileChannel fileChannel = channel.fileChannel.     if (fileChannel.size() - fileChannel.position() > 0) {         final ByteBuffer header = ByteBuffer.allocateDirect(8).         fileChannel.read(header).         header.flip().         final long position = fileChannel.position().         final boolean isBuffer = header.getInt() == 1.         final int length = header.getInt().         fileSegment = new FileSegment(fileChannel, position, length, isBuffer).         // Skip the binary data         fileChannel.position(position + length).         hasReachedEndOfFile.set(fileChannel.size() - fileChannel.position() == 0).     } else {         hasReachedEndOfFile.set(true).     } }
false;public;1;4;;@Override public void requestDone(IOException error) {     channel.handleProcessedBuffer(fileSegment, error). }
false;public;1;3;;@Override public void requestDone(IOException ioex) { }
false;public;0;4;;@Override public void read() throws IOException {     this.channel.fileChannel.position(position). }
false;public;0;4;;@Override public void write() throws IOException {     this.channel.fileChannel.position(position). }
