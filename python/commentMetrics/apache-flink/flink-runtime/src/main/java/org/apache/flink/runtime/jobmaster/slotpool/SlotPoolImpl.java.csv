commented;modifiers;parameterAmount;loc;comment;code
true;public;3;15;/**  * Start the slot pool to accept RPC calls.  *  * @param jobMasterId The necessary leader id for running the job.  * @param newJobManagerAddress for the slot requests which are sent to the resource manager  * @param componentMainThreadExecutor The main thread executor for the job master's main thread.  */ ;// ------------------------------------------------------------------------ // Starting and Stopping // ------------------------------------------------------------------------ /**  * Start the slot pool to accept RPC calls.  *  * @param jobMasterId The necessary leader id for running the job.  * @param newJobManagerAddress for the slot requests which are sent to the resource manager  * @param componentMainThreadExecutor The main thread executor for the job master's main thread.  */ public void start(@Nonnull JobMasterId jobMasterId, @Nonnull String newJobManagerAddress, @Nonnull ComponentMainThreadExecutor componentMainThreadExecutor) throws Exception {     this.jobMasterId = jobMasterId.     this.jobManagerAddress = newJobManagerAddress.     this.componentMainThreadExecutor = componentMainThreadExecutor.     scheduleRunAsync(this::checkIdleSlot, idleSlotTimeout).     if (log.isDebugEnabled()) {         scheduleRunAsync(this::scheduledLogStatus, STATUS_LOG_INTERVAL_MS, TimeUnit.MILLISECONDS).     } }
true;public;0;23;/**  * Suspends this pool, meaning it has lost its authority to accept and distribute slots.  */ ;/**  * Suspends this pool, meaning it has lost its authority to accept and distribute slots.  */ @Override public void suspend() {     componentMainThreadExecutor.assertRunningInMainThread().     log.info("Suspending SlotPool.").     // cancel all pending allocations --> we can request these slots     // again after we regained the leadership     Set<AllocationID> allocationIds = pendingRequests.keySetB().     for (AllocationID allocationId : allocationIds) {         resourceManagerGateway.cancelSlotRequest(allocationId).     }     // do not accept any requests     jobMasterId = null.     resourceManagerGateway = null.     // Clear (but not release!) the available slots. The TaskManagers should re-register them     // at the new leader JobManager/SlotPool     clear(). }
false;public;0;19;;@Override public void close() {     log.info("Stopping SlotPool.").     // cancel all pending allocations     Set<AllocationID> allocationIds = pendingRequests.keySetB().     for (AllocationID allocationId : allocationIds) {         resourceManagerGateway.cancelSlotRequest(allocationId).     }     // release all registered slots by releasing the corresponding TaskExecutors     for (ResourceID taskManagerResourceId : registeredTaskManagers) {         final FlinkException cause = new FlinkException("Releasing TaskManager " + taskManagerResourceId + ", because of stopping of SlotPool").         releaseTaskManagerInternal(taskManagerResourceId, cause).     }     clear(). }
false;public;1;12;;// ------------------------------------------------------------------------ // Resource Manager Connection // ------------------------------------------------------------------------ @Override public void connectToResourceManager(@Nonnull ResourceManagerGateway resourceManagerGateway) {     this.resourceManagerGateway = checkNotNull(resourceManagerGateway).     // work on all slots waiting for this connection     for (PendingRequest pendingRequest : waitingForResourceManager.values()) {         requestSlotFromResourceManager(resourceManagerGateway, pendingRequest).     }     // all sent off     waitingForResourceManager.clear(). }
false;public;0;4;;@Override public void disconnectResourceManager() {     this.resourceManagerGateway = null. }
true;private;3;34;/**  * Requests a new slot with the given {@link ResourceProfile} from the ResourceManager. If there is  * currently not ResourceManager connected, then the request is stashed and send once a new  * ResourceManager is connected.  *  * @param slotRequestId identifying the requested slot  * @param resourceProfile which the requested slot should fulfill  * @param timeout timeout before the slot allocation times out  * @return An {@link AllocatedSlot} future which is completed once the slot is offered to the {@link SlotPool}  */ ;// ------------------------------------------------------------------------ // Slot Allocation // ------------------------------------------------------------------------ /**  * Requests a new slot with the given {@link ResourceProfile} from the ResourceManager. If there is  * currently not ResourceManager connected, then the request is stashed and send once a new  * ResourceManager is connected.  *  * @param slotRequestId identifying the requested slot  * @param resourceProfile which the requested slot should fulfill  * @param timeout timeout before the slot allocation times out  * @return An {@link AllocatedSlot} future which is completed once the slot is offered to the {@link SlotPool}  */ @Nonnull private CompletableFuture<AllocatedSlot> requestNewAllocatedSlotInternal(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile, @Nonnull Time timeout) {     componentMainThreadExecutor.assertRunningInMainThread().     final PendingRequest pendingRequest = new PendingRequest(slotRequestId, resourceProfile).     // register request timeout     FutureUtils.orTimeout(pendingRequest.getAllocatedSlotFuture(), timeout.toMilliseconds(), TimeUnit.MILLISECONDS, componentMainThreadExecutor).whenComplete((AllocatedSlot ignored, Throwable throwable) -> {         if (throwable instanceof TimeoutException) {             timeoutPendingSlotRequest(slotRequestId).         }     }).     if (resourceManagerGateway == null) {         stashRequestWaitingForResourceManager(pendingRequest).     } else {         requestSlotFromResourceManager(resourceManagerGateway, pendingRequest).     }     return pendingRequest.getAllocatedSlotFuture(). }
false;private;2;37;;private void requestSlotFromResourceManager(final ResourceManagerGateway resourceManagerGateway, final PendingRequest pendingRequest) {     checkNotNull(resourceManagerGateway).     checkNotNull(pendingRequest).     log.info("Requesting new slot [{}] and profile {} from resource manager.", pendingRequest.getSlotRequestId(), pendingRequest.getResourceProfile()).     final AllocationID allocationId = new AllocationID().     pendingRequests.put(pendingRequest.getSlotRequestId(), allocationId, pendingRequest).     pendingRequest.getAllocatedSlotFuture().whenComplete((AllocatedSlot allocatedSlot, Throwable throwable) -> {         if (throwable != null || !allocationId.equals(allocatedSlot.getAllocationId())) {             // cancel the slot request if there is a failure or if the pending request has             // been completed with another allocated slot             resourceManagerGateway.cancelSlotRequest(allocationId).         }     }).     CompletableFuture<Acknowledge> rmResponse = resourceManagerGateway.requestSlot(jobMasterId, new SlotRequest(jobId, allocationId, pendingRequest.getResourceProfile(), jobManagerAddress), rpcTimeout).     FutureUtils.whenCompleteAsyncIfNotDone(rmResponse, componentMainThreadExecutor, (Acknowledge ignored, Throwable failure) -> {         // on failure, fail the request future         if (failure != null) {             slotRequestToResourceManagerFailed(pendingRequest.getSlotRequestId(), failure).         }     }). }
false;private;2;11;;private void slotRequestToResourceManagerFailed(SlotRequestId slotRequestID, Throwable failure) {     PendingRequest request = pendingRequests.removeKeyA(slotRequestID).     if (request != null) {         request.getAllocatedSlotFuture().completeExceptionally(new NoResourceAvailableException("No pooled slot available and request to ResourceManager for new slot failed", failure)).     } else {         if (log.isDebugEnabled()) {             log.debug("Unregistered slot request [{}] failed.", slotRequestID, failure).         }     } }
false;private;1;7;;private void stashRequestWaitingForResourceManager(final PendingRequest pendingRequest) {     log.info("Cannot serve slot request, no ResourceManager connected. " + "Adding as pending request [{}]", pendingRequest.getSlotRequestId()).     waitingForResourceManager.put(pendingRequest.getSlotRequestId(), pendingRequest). }
false;public;2;8;;// ------------------------------------------------------------------------ // Slot releasing & offering // ------------------------------------------------------------------------ @Override public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwable cause) {     componentMainThreadExecutor.assertRunningInMainThread().     log.debug("Releasing slot [{}] because: {}", slotRequestId, cause != null ? cause.getMessage() : "null").     releaseSingleSlot(slotRequestId, cause). }
false;public;2;15;;@Override public Optional<PhysicalSlot> allocateAvailableSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull AllocationID allocationID) {     componentMainThreadExecutor.assertRunningInMainThread().     AllocatedSlot allocatedSlot = availableSlots.tryRemove(allocationID).     if (allocatedSlot != null) {         allocatedSlots.add(slotRequestId, allocatedSlot).         return Optional.of(allocatedSlot).     } else {         return Optional.empty().     } }
false;public;3;10;;@Nonnull @Override public CompletableFuture<PhysicalSlot> requestNewAllocatedSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile, Time timeout) {     return requestNewAllocatedSlotInternal(slotRequestId, resourceProfile, timeout).thenApply((Function.identity())). }
false;public;0;5;;@Override @Nonnull public Collection<SlotInfo> getAvailableSlotsInformation() {     return availableSlots.listSlotInfo(). }
false;private;2;16;;private void releaseSingleSlot(SlotRequestId slotRequestId, Throwable cause) {     final PendingRequest pendingRequest = removePendingRequest(slotRequestId).     if (pendingRequest != null) {         failPendingRequest(pendingRequest, new FlinkException("Pending slot request with " + slotRequestId + " has been released.")).     } else {         final AllocatedSlot allocatedSlot = allocatedSlots.remove(slotRequestId).         if (allocatedSlot != null) {             allocatedSlot.releasePayload(cause).             tryFulfillSlotRequestOrMakeAvailable(allocatedSlot).         } else {             log.debug("There is no allocated slot [{}]. Ignoring the release slot request.", slotRequestId).         }     } }
true;private;1;14;/**  * Checks whether there exists a pending request with the given slot request id and removes it  * from the internal data structures.  *  * @param requestId identifying the pending request  * @return pending request if there is one, otherwise null  */ ;/**  * Checks whether there exists a pending request with the given slot request id and removes it  * from the internal data structures.  *  * @param requestId identifying the pending request  * @return pending request if there is one, otherwise null  */ @Nullable private PendingRequest removePendingRequest(SlotRequestId requestId) {     PendingRequest result = waitingForResourceManager.remove(requestId).     if (result != null) {         // sanity check         assert !pendingRequests.containsKeyA(requestId) : "A pending requests should only be part of either " + "the pendingRequests or waitingForResourceManager but not both.".         return result.     } else {         return pendingRequests.removeKeyA(requestId).     } }
false;private;2;9;;private void failPendingRequest(PendingRequest pendingRequest, Exception e) {     checkNotNull(pendingRequest).     checkNotNull(e).     if (!pendingRequest.getAllocatedSlotFuture().isDone()) {         log.info("Failing pending slot request [{}]: {}", pendingRequest.getSlotRequestId(), e.getMessage()).         pendingRequest.getAllocatedSlotFuture().completeExceptionally(e).     } }
true;private;1;16;/**  * Tries to fulfill with the given allocated slot a pending slot request or add the  * allocated slot to the set of available slots if no matching request is available.  *  * @param allocatedSlot which shall be returned  */ ;/**  * Tries to fulfill with the given allocated slot a pending slot request or add the  * allocated slot to the set of available slots if no matching request is available.  *  * @param allocatedSlot which shall be returned  */ private void tryFulfillSlotRequestOrMakeAvailable(AllocatedSlot allocatedSlot) {     Preconditions.checkState(!allocatedSlot.isUsed(), "Provided slot is still in use.").     final PendingRequest pendingRequest = pollMatchingPendingRequest(allocatedSlot).     if (pendingRequest != null) {         log.debug("Fulfilling pending slot request [{}] early with returned slot [{}]", pendingRequest.getSlotRequestId(), allocatedSlot.getAllocationId()).         allocatedSlots.add(pendingRequest.getSlotRequestId(), allocatedSlot).         pendingRequest.getAllocatedSlotFuture().complete(allocatedSlot).     } else {         log.debug("Adding returned slot [{}] to available slots", allocatedSlot.getAllocationId()).         availableSlots.add(allocatedSlot, clock.relativeTimeMillis()).     } }
false;private;1;22;;private PendingRequest pollMatchingPendingRequest(final AllocatedSlot slot) {     final ResourceProfile slotResources = slot.getResourceProfile().     // try the requests sent to the resource manager first     for (PendingRequest request : pendingRequests.values()) {         if (slotResources.isMatching(request.getResourceProfile())) {             pendingRequests.removeKeyA(request.getSlotRequestId()).             return request.         }     }     // try the requests waiting for a resource manager connection next     for (PendingRequest request : waitingForResourceManager.values()) {         if (slotResources.isMatching(request.getResourceProfile())) {             waitingForResourceManager.remove(request.getSlotRequestId()).             return request.         }     }     // no request pending, or no request matches     return null. }
false;public;3;20;;@Override public Collection<SlotOffer> offerSlots(TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, Collection<SlotOffer> offers) {     ArrayList<SlotOffer> result = new ArrayList<>(offers.size()).     for (SlotOffer offer : offers) {         if (offerSlot(taskManagerLocation, taskManagerGateway, offer)) {             result.add(offer).         }     }     return result. }
true;;3;77;/**  * Slot offering by TaskExecutor with AllocationID. The AllocationID is originally generated by this pool and  * transfer through the ResourceManager to TaskManager. We use it to distinguish the different allocation  * we issued. Slot offering may be rejected if we find something mismatching or there is actually no pending  * request waiting for this slot (maybe fulfilled by some other returned slot).  *  * @param taskManagerLocation location from where the offer comes from  * @param taskManagerGateway TaskManager gateway  * @param slotOffer the offered slot  * @return True if we accept the offering  */ ;/**  * Slot offering by TaskExecutor with AllocationID. The AllocationID is originally generated by this pool and  * transfer through the ResourceManager to TaskManager. We use it to distinguish the different allocation  * we issued. Slot offering may be rejected if we find something mismatching or there is actually no pending  * request waiting for this slot (maybe fulfilled by some other returned slot).  *  * @param taskManagerLocation location from where the offer comes from  * @param taskManagerGateway TaskManager gateway  * @param slotOffer the offered slot  * @return True if we accept the offering  */ boolean offerSlot(final TaskManagerLocation taskManagerLocation, final TaskManagerGateway taskManagerGateway, final SlotOffer slotOffer) {     componentMainThreadExecutor.assertRunningInMainThread().     // check if this TaskManager is valid     final ResourceID resourceID = taskManagerLocation.getResourceID().     final AllocationID allocationID = slotOffer.getAllocationId().     if (!registeredTaskManagers.contains(resourceID)) {         log.debug("Received outdated slot offering [{}] from unregistered TaskManager: {}", slotOffer.getAllocationId(), taskManagerLocation).         return false.     }     // check whether we have already using this slot     AllocatedSlot existingSlot.     if ((existingSlot = allocatedSlots.get(allocationID)) != null || (existingSlot = availableSlots.get(allocationID)) != null) {         // we need to figure out if this is a repeated offer for the exact same slot,         // or another offer that comes from a different TaskManager after the ResourceManager         // re-tried the request         // we write this in terms of comparing slot IDs, because the Slot IDs are the identifiers of         // the actual slots on the TaskManagers         // Note: The slotOffer should have the SlotID         final SlotID existingSlotId = existingSlot.getSlotId().         final SlotID newSlotId = new SlotID(taskManagerLocation.getResourceID(), slotOffer.getSlotIndex()).         if (existingSlotId.equals(newSlotId)) {             log.info("Received repeated offer for slot [{}]. Ignoring.", allocationID).             // and mark the offering as a success             return true.         } else {             // will offer the slot to the resource manager             return false.         }     }     final AllocatedSlot allocatedSlot = new AllocatedSlot(allocationID, taskManagerLocation, slotOffer.getSlotIndex(), slotOffer.getResourceProfile(), taskManagerGateway).     // check whether we have request waiting for this slot     PendingRequest pendingRequest = pendingRequests.removeKeyB(allocationID).     if (pendingRequest != null) {         // we were waiting for this!         allocatedSlots.add(pendingRequest.getSlotRequestId(), allocatedSlot).         if (!pendingRequest.getAllocatedSlotFuture().complete(allocatedSlot)) {             // we could not complete the pending slot future --> try to fulfill another pending request             allocatedSlots.remove(pendingRequest.getSlotRequestId()).             tryFulfillSlotRequestOrMakeAvailable(allocatedSlot).         } else {             log.debug("Fulfilled slot request [{}] with allocated slot [{}].", pendingRequest.getSlotRequestId(), allocationID).         }     } else {         // we were actually not waiting for this:         // - could be that this request had been fulfilled         // - we are receiving the slots from TaskManagers after becoming leaders         tryFulfillSlotRequestOrMakeAvailable(allocatedSlot).     }     // too long and timed out     return true. }
true;public;2;17;/**  * Fail the specified allocation and release the corresponding slot if we have one.  * This may triggered by JobManager when some slot allocation failed with rpcTimeout.  * Or this could be triggered by TaskManager, when it finds out something went wrong with the slot,  * and decided to take it back.  *  * @param allocationID Represents the allocation which should be failed  * @param cause The cause of the failure  * @return Optional task executor if it has no more slots registered  */ ;// TODO - periodic (every minute or so) catch slots that were lost (check all slots, if they have any task active) // TODO - release slots that were not used to the resource manager // ------------------------------------------------------------------------ // Error Handling // ------------------------------------------------------------------------ /**  * Fail the specified allocation and release the corresponding slot if we have one.  * This may triggered by JobManager when some slot allocation failed with rpcTimeout.  * Or this could be triggered by TaskManager, when it finds out something went wrong with the slot,  * and decided to take it back.  *  * @param allocationID Represents the allocation which should be failed  * @param cause The cause of the failure  * @return Optional task executor if it has no more slots registered  */ @Override public Optional<ResourceID> failAllocation(final AllocationID allocationID, final Exception cause) {     componentMainThreadExecutor.assertRunningInMainThread().     final PendingRequest pendingRequest = pendingRequests.removeKeyB(allocationID).     if (pendingRequest != null) {         // request was still pending         failPendingRequest(pendingRequest, cause).         return Optional.empty().     } else {         return tryFailingAllocatedSlot(allocationID, cause).     } // TODO: add some unit tests when the previous two are ready, the allocation may failed at any phase }
false;private;2;25;;private Optional<ResourceID> tryFailingAllocatedSlot(AllocationID allocationID, Exception cause) {     AllocatedSlot allocatedSlot = availableSlots.tryRemove(allocationID).     if (allocatedSlot == null) {         allocatedSlot = allocatedSlots.remove(allocationID).     }     if (allocatedSlot != null) {         log.debug("Failed allocated slot [{}]: {}", allocationID, cause.getMessage()).         // notify TaskExecutor about the failure         allocatedSlot.getTaskManagerGateway().freeSlot(allocationID, cause, rpcTimeout).         // release the slot.         // since it is not in 'allocatedSlots' any more, it will be dropped o return'         allocatedSlot.releasePayload(cause).         final ResourceID taskManagerId = allocatedSlot.getTaskManagerId().         if (!availableSlots.containsTaskManager(taskManagerId) && !allocatedSlots.containResource(taskManagerId)) {             return Optional.of(taskManagerId).         }     }     return Optional.empty(). }
true;public;1;8;/**  * Register TaskManager to this pool, only those slots come from registered TaskManager will be considered valid.  * Also it provides a way for us to keep "dead" or "abnormal" TaskManagers out of this pool.  *  * @param resourceID The id of the TaskManager  */ ;// ------------------------------------------------------------------------ // Resource // ------------------------------------------------------------------------ /**  * Register TaskManager to this pool, only those slots come from registered TaskManager will be considered valid.  * Also it provides a way for us to keep "dead" or "abnormal" TaskManagers out of this pool.  *  * @param resourceID The id of the TaskManager  */ @Override public boolean registerTaskManager(final ResourceID resourceID) {     componentMainThreadExecutor.assertRunningInMainThread().     log.debug("Register new TaskExecutor {}.", resourceID).     return registeredTaskManagers.add(resourceID). }
true;public;2;12;/**  * Unregister TaskManager from this pool, all the related slots will be released and tasks be canceled. Called  * when we find some TaskManager becomes "dead" or "abnormal", and we decide to not using slots from it anymore.  *  * @param resourceId The id of the TaskManager  * @param cause for the releasing of the TaskManager  */ ;/**  * Unregister TaskManager from this pool, all the related slots will be released and tasks be canceled. Called  * when we find some TaskManager becomes "dead" or "abnormal", and we decide to not using slots from it anymore.  *  * @param resourceId The id of the TaskManager  * @param cause for the releasing of the TaskManager  */ @Override public boolean releaseTaskManager(final ResourceID resourceId, final Exception cause) {     componentMainThreadExecutor.assertRunningInMainThread().     if (registeredTaskManagers.remove(resourceId)) {         releaseTaskManagerInternal(resourceId, cause).         return true.     } else {         return false.     } }
false;protected;1;5;;// ------------------------------------------------------------------------ // Internal methods // ------------------------------------------------------------------------ @VisibleForTesting protected void timeoutPendingSlotRequest(SlotRequestId slotRequestId) {     log.info("Pending slot request [{}] timed out.", slotRequestId).     removePendingRequest(slotRequestId). }
false;private;2;14;;private void releaseTaskManagerInternal(final ResourceID resourceId, final Exception cause) {     final Set<AllocatedSlot> removedSlots = new HashSet<>(allocatedSlots.removeSlotsForTaskManager(resourceId)).     for (AllocatedSlot allocatedSlot : removedSlots) {         allocatedSlot.releasePayload(cause).     }     removedSlots.addAll(availableSlots.removeAllForTaskManager(resourceId)).     for (AllocatedSlot removedSlot : removedSlots) {         TaskManagerGateway taskManagerGateway = removedSlot.getTaskManagerGateway().         taskManagerGateway.freeSlot(removedSlot.getAllocationId(), cause, rpcTimeout).     } }
true;private;0;46;/**  * Check the available slots, release the slot that is idle for a long time.  */ ;/**  * Check the available slots, release the slot that is idle for a long time.  */ private void checkIdleSlot() {     // The timestamp in SlotAndTimestamp is relative     final long currentRelativeTimeMillis = clock.relativeTimeMillis().     final List<AllocatedSlot> expiredSlots = new ArrayList<>(availableSlots.size()).     for (SlotAndTimestamp slotAndTimestamp : availableSlots.availableSlots.values()) {         if (currentRelativeTimeMillis - slotAndTimestamp.timestamp > idleSlotTimeout.toMilliseconds()) {             expiredSlots.add(slotAndTimestamp.slot).         }     }     final FlinkException cause = new FlinkException("Releasing idle slot.").     for (AllocatedSlot expiredSlot : expiredSlots) {         final AllocationID allocationID = expiredSlot.getAllocationId().         if (availableSlots.tryRemove(allocationID) != null) {             log.info("Releasing idle slot [{}].", allocationID).             final CompletableFuture<Acknowledge> freeSlotFuture = expiredSlot.getTaskManagerGateway().freeSlot(allocationID, cause, rpcTimeout).             FutureUtils.whenCompleteAsyncIfNotDone(freeSlotFuture, componentMainThreadExecutor, (Acknowledge ignored, Throwable throwable) -> {                 if (throwable != null) {                     if (registeredTaskManagers.contains(expiredSlot.getTaskManagerId())) {                         log.debug("Releasing slot [{}] of registered TaskExecutor {} failed. " + "Trying to fulfill a different slot request.", allocationID, expiredSlot.getTaskManagerId(), throwable).                         tryFulfillSlotRequestOrMakeAvailable(expiredSlot).                     } else {                         log.debug("Releasing slot [{}] failed and owning TaskExecutor {} is no " + "longer registered. Discarding slot.", allocationID, expiredSlot.getTaskManagerId()).                     }                 }             }).         }     }     scheduleRunAsync(this::checkIdleSlot, idleSlotTimeout). }
true;private;0;7;/**  * Clear the internal state of the SlotPool.  */ ;/**  * Clear the internal state of the SlotPool.  */ private void clear() {     availableSlots.clear().     allocatedSlots.clear().     pendingRequests.clear().     waitingForResourceManager.clear().     registeredTaskManagers.clear(). }
false;private;0;4;;// ------------------------------------------------------------------------ // Methods for tests // ------------------------------------------------------------------------ private void scheduledLogStatus() {     log.debug(printStatus()).     scheduleRunAsync(this::scheduledLogStatus, STATUS_LOG_INTERVAL_MS, TimeUnit.MILLISECONDS). }
false;private;0;23;;private String printStatus() {     final StringBuilder builder = new StringBuilder(1024).append("Slot Pool Status:\n").     builder.append("\tstatus: ").     if (resourceManagerGateway != null) {         builder.append("connected to ").append(resourceManagerGateway.getAddress()).append('\n').     } else {         builder.append("unconnected and waiting for ResourceManager ").append(waitingForResourceManager).append('\n').     }     builder.append("\tregistered TaskManagers: ").append(registeredTaskManagers).append('\n').     builder.append("\tavailable slots: ").append(availableSlots.printAllSlots()).append('\n').     builder.append("\tallocated slots: ").append(allocatedSlots.printAllSlots()).append('\n').     builder.append("\tpending requests: ").append(pendingRequests.values()).append('\n').     builder.append("\t}\n").     return builder.toString(). }
false;protected;0;4;;@VisibleForTesting protected AllocatedSlots getAllocatedSlots() {     return allocatedSlots. }
false;protected;0;4;;@VisibleForTesting protected AvailableSlots getAvailableSlots() {     return availableSlots. }
false;;0;4;;@VisibleForTesting DualKeyMap<SlotRequestId, AllocationID, PendingRequest> getPendingRequests() {     return pendingRequests. }
false;;0;4;;@VisibleForTesting Map<SlotRequestId, PendingRequest> getWaitingForResourceManager() {     return waitingForResourceManager. }
false;;0;4;;@VisibleForTesting void triggerCheckIdleSlot() {     runAsync(this::checkIdleSlot). }
true;protected;1;3;/**  * Execute the runnable in the main thread of the underlying RPC endpoint.  *  * @param runnable Runnable to be executed in the main thread of the underlying RPC endpoint  */ ;/**  * Execute the runnable in the main thread of the underlying RPC endpoint.  *  * @param runnable Runnable to be executed in the main thread of the underlying RPC endpoint  */ protected void runAsync(Runnable runnable) {     componentMainThreadExecutor.execute(runnable). }
true;protected;2;3;/**  * Execute the runnable in the main thread of the underlying RPC endpoint, with  * a delay of the given number of milliseconds.  *  * @param runnable Runnable to be executed  * @param delay    The delay after which the runnable will be executed  */ ;/**  * Execute the runnable in the main thread of the underlying RPC endpoint, with  * a delay of the given number of milliseconds.  *  * @param runnable Runnable to be executed  * @param delay    The delay after which the runnable will be executed  */ protected void scheduleRunAsync(Runnable runnable, Time delay) {     scheduleRunAsync(runnable, delay.getSize(), delay.getUnit()). }
true;protected;3;3;/**  * Execute the runnable in the main thread of the underlying RPC endpoint, with  * a delay of the given number of milliseconds.  *  * @param runnable Runnable to be executed  * @param delay    The delay after which the runnable will be executed  */ ;/**  * Execute the runnable in the main thread of the underlying RPC endpoint, with  * a delay of the given number of milliseconds.  *  * @param runnable Runnable to be executed  * @param delay    The delay after which the runnable will be executed  */ protected void scheduleRunAsync(Runnable runnable, long delay, TimeUnit unit) {     componentMainThreadExecutor.schedule(runnable, delay, unit). }
true;;2;11;/**  * Adds a new slot to this collection.  *  * @param allocatedSlot The allocated slot  */ ;/**  * Adds a new slot to this collection.  *  * @param allocatedSlot The allocated slot  */ void add(SlotRequestId slotRequestId, AllocatedSlot allocatedSlot) {     allocatedSlotsById.put(allocatedSlot.getAllocationId(), slotRequestId, allocatedSlot).     final ResourceID resourceID = allocatedSlot.getTaskManagerLocation().getResourceID().     Set<AllocatedSlot> slotsForTaskManager = allocatedSlotsByTaskManager.computeIfAbsent(resourceID, resourceId -> new HashSet<>(4)).     slotsForTaskManager.add(allocatedSlot). }
true;;1;3;/**  * Get allocated slot with allocation id.  *  * @param allocationID The allocation id  * @return The allocated slot, null if we can't find a match  */ ;/**  * Get allocated slot with allocation id.  *  * @param allocationID The allocation id  * @return The allocated slot, null if we can't find a match  */ AllocatedSlot get(final AllocationID allocationID) {     return allocatedSlotsById.getKeyA(allocationID). }
false;;1;3;;AllocatedSlot get(final SlotRequestId slotRequestId) {     return allocatedSlotsById.getKeyB(slotRequestId). }
true;;1;3;/**  * Check whether we have allocated this slot.  *  * @param slotAllocationId The allocation id of the slot to check  * @return True if we contains this slot  */ ;/**  * Check whether we have allocated this slot.  *  * @param slotAllocationId The allocation id of the slot to check  * @return True if we contains this slot  */ boolean contains(AllocationID slotAllocationId) {     return allocatedSlotsById.containsKeyA(slotAllocationId). }
true;;1;10;/**  * Removes the allocated slot specified by the provided slot allocation id.  *  * @param allocationID identifying the allocated slot to remove  * @return The removed allocated slot or null.  */ ;/**  * Removes the allocated slot specified by the provided slot allocation id.  *  * @param allocationID identifying the allocated slot to remove  * @return The removed allocated slot or null.  */ @Nullable AllocatedSlot remove(final AllocationID allocationID) {     AllocatedSlot allocatedSlot = allocatedSlotsById.removeKeyA(allocationID).     if (allocatedSlot != null) {         removeAllocatedSlot(allocatedSlot).     }     return allocatedSlot. }
true;;1;10;/**  * Removes the allocated slot specified by the provided slot request id.  *  * @param slotRequestId identifying the allocated slot to remove  * @return The removed allocated slot or null.  */ ;/**  * Removes the allocated slot specified by the provided slot request id.  *  * @param slotRequestId identifying the allocated slot to remove  * @return The removed allocated slot or null.  */ @Nullable AllocatedSlot remove(final SlotRequestId slotRequestId) {     final AllocatedSlot allocatedSlot = allocatedSlotsById.removeKeyB(slotRequestId).     if (allocatedSlot != null) {         removeAllocatedSlot(allocatedSlot).     }     return allocatedSlot. }
false;private;1;11;;private void removeAllocatedSlot(final AllocatedSlot allocatedSlot) {     Preconditions.checkNotNull(allocatedSlot).     final ResourceID taskManagerId = allocatedSlot.getTaskManagerLocation().getResourceID().     Set<AllocatedSlot> slotsForTM = allocatedSlotsByTaskManager.get(taskManagerId).     slotsForTM.remove(allocatedSlot).     if (slotsForTM.isEmpty()) {         allocatedSlotsByTaskManager.remove(taskManagerId).     } }
true;;1;12;/**  * Get all allocated slot from same TaskManager.  *  * @param resourceID The id of the TaskManager  * @return Set of slots which are allocated from the same TaskManager  */ ;/**  * Get all allocated slot from same TaskManager.  *  * @param resourceID The id of the TaskManager  * @return Set of slots which are allocated from the same TaskManager  */ Set<AllocatedSlot> removeSlotsForTaskManager(final ResourceID resourceID) {     Set<AllocatedSlot> slotsForTaskManager = allocatedSlotsByTaskManager.remove(resourceID).     if (slotsForTaskManager != null) {         for (AllocatedSlot allocatedSlot : slotsForTaskManager) {             allocatedSlotsById.removeKeyA(allocatedSlot.getAllocationId()).         }         return slotsForTaskManager.     } else {         return Collections.emptySet().     } }
false;;0;4;;void clear() {     allocatedSlotsById.clear().     allocatedSlotsByTaskManager.clear(). }
false;;0;3;;String printAllSlots() {     return allocatedSlotsByTaskManager.values().toString(). }
false;;1;4;;@VisibleForTesting boolean containResource(final ResourceID resourceID) {     return allocatedSlotsByTaskManager.containsKey(resourceID). }
false;;0;4;;@VisibleForTesting int size() {     return allocatedSlotsById.size(). }
false;;1;4;;@VisibleForTesting Set<AllocatedSlot> getSlotsForTaskManager(ResourceID resourceId) {     return allocatedSlotsByTaskManager.getOrDefault(resourceId, Collections.emptySet()). }
true;;2;22;/**  * Adds an available slot.  *  * @param slot The slot to add  */ ;/**  * Adds an available slot.  *  * @param slot The slot to add  */ void add(final AllocatedSlot slot, final long timestamp) {     checkNotNull(slot).     SlotAndTimestamp previous = availableSlots.put(slot.getAllocationId(), new SlotAndTimestamp(slot, timestamp)).     if (previous == null) {         final ResourceID resourceID = slot.getTaskManagerLocation().getResourceID().         final String host = slot.getTaskManagerLocation().getFQDNHostname().         Set<AllocatedSlot> slotsForTaskManager = availableSlotsByTaskManager.computeIfAbsent(resourceID, k -> new HashSet<>()).         slotsForTaskManager.add(slot).         Set<AllocatedSlot> slotsForHost = availableSlotsByHost.computeIfAbsent(host, k -> new HashSet<>()).         slotsForHost.add(slot).     } else {         throw new IllegalStateException("slot already contained").     } }
true;;1;3;/**  * Check whether we have this slot.  */ ;/**  * Check whether we have this slot.  */ boolean contains(AllocationID slotId) {     return availableSlots.containsKey(slotId). }
false;;1;8;;AllocatedSlot get(AllocationID allocationID) {     SlotAndTimestamp slotAndTimestamp = availableSlots.get(allocationID).     if (slotAndTimestamp != null) {         return slotAndTimestamp.slot().     } else {         return null.     } }
true;;1;23;/**  * Remove all available slots come from specified TaskManager.  *  * @param taskManager The id of the TaskManager  * @return The set of removed slots for the given TaskManager  */ ;/**  * Remove all available slots come from specified TaskManager.  *  * @param taskManager The id of the TaskManager  * @return The set of removed slots for the given TaskManager  */ Set<AllocatedSlot> removeAllForTaskManager(final ResourceID taskManager) {     // remove from the by-TaskManager view     final Set<AllocatedSlot> slotsForTm = availableSlotsByTaskManager.remove(taskManager).     if (slotsForTm != null && slotsForTm.size() > 0) {         final String host = slotsForTm.iterator().next().getTaskManagerLocation().getFQDNHostname().         final Set<AllocatedSlot> slotsForHost = availableSlotsByHost.get(host).         // remove from the base set and the by-host view         for (AllocatedSlot slot : slotsForTm) {             availableSlots.remove(slot.getAllocationId()).             slotsForHost.remove(slot).         }         if (slotsForHost.isEmpty()) {             availableSlotsByHost.remove(host).         }         return slotsForTm.     } else {         return Collections.emptySet().     } }
false;;1;26;;AllocatedSlot tryRemove(AllocationID slotId) {     final SlotAndTimestamp sat = availableSlots.remove(slotId).     if (sat != null) {         final AllocatedSlot slot = sat.slot().         final ResourceID resourceID = slot.getTaskManagerLocation().getResourceID().         final String host = slot.getTaskManagerLocation().getFQDNHostname().         final Set<AllocatedSlot> slotsForTm = availableSlotsByTaskManager.get(resourceID).         final Set<AllocatedSlot> slotsForHost = availableSlotsByHost.get(host).         slotsForTm.remove(slot).         slotsForHost.remove(slot).         if (slotsForTm.isEmpty()) {             availableSlotsByTaskManager.remove(resourceID).         }         if (slotsForHost.isEmpty()) {             availableSlotsByHost.remove(host).         }         return slot.     } else {         return null.     } }
false;;0;8;;@Nonnull List<SlotInfo> listSlotInfo() {     return availableSlots.values().stream().map(SlotAndTimestamp::slot).collect(Collectors.toList()). }
false;private;1;5;;private void remove(AllocationID slotId) throws IllegalStateException {     if (tryRemove(slotId) == null) {         throw new IllegalStateException("slot not contained").     } }
false;;0;3;;String printAllSlots() {     return availableSlots.values().toString(). }
false;;1;4;;@VisibleForTesting boolean containsTaskManager(ResourceID resourceID) {     return availableSlotsByTaskManager.containsKey(resourceID). }
false;public;0;4;;@VisibleForTesting public int size() {     return availableSlots.size(). }
false;;0;6;;@VisibleForTesting void clear() {     availableSlots.clear().     availableSlotsByTaskManager.clear().     availableSlotsByHost.clear(). }
false;public;0;3;;public SlotRequestId getSlotRequestId() {     return slotRequestId. }
false;public;0;3;;public CompletableFuture<AllocatedSlot> getAllocatedSlotFuture() {     return allocatedSlotFuture. }
false;public;0;3;;public ResourceProfile getResourceProfile() {     return resourceProfile. }
false;public;0;8;;@Override public String toString() {     return "PendingRequest{" + "slotRequestId=" + slotRequestId + ", resourceProfile=" + resourceProfile + ", allocatedSlotFuture=" + allocatedSlotFuture + '}'. }
false;public;0;3;;public AllocatedSlot slot() {     return slot. }
false;public;0;3;;public long timestamp() {     return timestamp. }
false;public;0;4;;@Override public String toString() {     return slot + " @ " + timestamp. }
