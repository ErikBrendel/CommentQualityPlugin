commented;modifiers;parameterAmount;loc;comment;code
false;public;2;18;;// ------------------------------------------------------------------------ // failover implementation // ------------------------------------------------------------------------ @Override public void onTaskFailure(Execution taskExecution, Throwable cause) {     final ExecutionVertex ev = taskExecution.getVertex().     final FailoverRegion failoverRegion = vertexToRegion.get(ev).     if (failoverRegion == null) {         executionGraph.failGlobal(new FlinkException("Can not find a failover region for the execution " + ev.getTaskNameWithSubtaskIndex(), cause)).     } else {         LOG.info("Recovering task failure for {} #{} ({}) via restart of failover region", taskExecution.getVertex().getTaskNameWithSubtaskIndex(), taskExecution.getAttemptNumber(), taskExecution.getAttemptId()).         failoverRegion.onExecutionFail(taskExecution, cause).     } }
false;public;1;4;;@Override public void notifyNewVertices(List<ExecutionJobVertex> newJobVerticesTopological) {     generateAllFailoverRegion(newJobVerticesTopological). }
false;public;0;4;;@Override public String getStrategyName() {     return "Pipelined Region Failover". }
true;private;1;97;/**  * Generate all the FailoverRegion from the new added job vertexes  */ ;/**  * Generate all the FailoverRegion from the new added job vertexes  */ private void generateAllFailoverRegion(List<ExecutionJobVertex> newJobVerticesTopological) {     final IdentityHashMap<ExecutionVertex, ArrayList<ExecutionVertex>> vertexToRegion = new IdentityHashMap<>().     // we use the map (list -> null) to imitate an IdentityHashSet (which does not exist)     final IdentityHashMap<ArrayList<ExecutionVertex>, Object> distinctRegions = new IdentityHashMap<>().     for (ExecutionJobVertex ejv : newJobVerticesTopological) {         // we want to improve that in the future (or get rid of co-location constraints)         if (ejv.getCoLocationGroup() != null) {             makeAllOneRegion(newJobVerticesTopological).             return.         }         // see if this JobVertex one has pipelined inputs at all         final List<IntermediateResult> inputs = ejv.getInputs().         final int numInputs = inputs.size().         boolean hasPipelinedInputs = false.         for (IntermediateResult input : inputs) {             if (input.getResultType().isPipelined()) {                 hasPipelinedInputs = true.                 break.             }         }         if (hasPipelinedInputs) {             // build upon the predecessors             for (ExecutionVertex ev : ejv.getTaskVertices()) {                 // remember the region in which we are                 ArrayList<ExecutionVertex> thisRegion = null.                 for (int inputNum = 0. inputNum < numInputs. inputNum++) {                     if (inputs.get(inputNum).getResultType().isPipelined()) {                         for (ExecutionEdge edge : ev.getInputEdges(inputNum)) {                             final ExecutionVertex predecessor = edge.getSource().getProducer().                             final ArrayList<ExecutionVertex> predecessorRegion = vertexToRegion.get(predecessor).                             if (thisRegion != null) {                                 // we already have a region. see if it is the same as the predecessor's region                                 if (predecessorRegion != thisRegion) {                                     // we need to merge our region and the predecessor's region                                     predecessorRegion.addAll(thisRegion).                                     distinctRegions.remove(thisRegion).                                     thisRegion = predecessorRegion.                                     // remap the vertices from that merged region                                     for (ExecutionVertex inPredRegion : predecessorRegion) {                                         vertexToRegion.put(inPredRegion, thisRegion).                                     }                                 }                             } else if (predecessor != null) {                                 // first case, make this our region                                 thisRegion = predecessorRegion.                                 thisRegion.add(ev).                                 vertexToRegion.put(ev, thisRegion).                             } else {                                 // this is a bug and not a recoverable situation                                 throw new FlinkRuntimeException("bug in the logic to construct the pipelined failover regions").                             }                         }                     }                 }             }         } else {             // no pipelined inputs, start a new region             for (ExecutionVertex ev : ejv.getTaskVertices()) {                 ArrayList<ExecutionVertex> region = new ArrayList<>(1).                 region.add(ev).                 vertexToRegion.put(ev, region).                 distinctRegions.put(region, null).             }         }     }     // now that we have all regions, create the failover region objects     LOG.info("Creating {} individual failover regions for job {} ({})", distinctRegions.size(), executionGraph.getJobName(), executionGraph.getJobID()).     for (List<ExecutionVertex> region : distinctRegions.keySet()) {         final FailoverRegion failoverRegion = createFailoverRegion(executionGraph, region).         for (ExecutionVertex ev : region) {             this.vertexToRegion.put(ev, failoverRegion).         }     } }
false;private;1;19;;private void makeAllOneRegion(List<ExecutionJobVertex> jobVertices) {     LOG.warn("Cannot decompose ExecutionGraph into individual failover regions due to use of " + "Co-Location constraints (iterations). Job will fail over as one holistic unit.").     final ArrayList<ExecutionVertex> allVertices = new ArrayList<>().     for (ExecutionJobVertex ejv : jobVertices) {         // safe some incremental size growing         allVertices.ensureCapacity(allVertices.size() + ejv.getParallelism()).         allVertices.addAll(Arrays.asList(ejv.getTaskVertices())).     }     final FailoverRegion singleRegion = createFailoverRegion(executionGraph, allVertices).     for (ExecutionVertex ev : allVertices) {         vertexToRegion.put(ev, singleRegion).     } }
false;protected;2;4;;@VisibleForTesting protected FailoverRegion createFailoverRegion(ExecutionGraph eg, List<ExecutionVertex> connectedExecutions) {     return new FailoverRegion(eg, connectedExecutions). }
true;public;1;4;/**  * Finds the failover region that contains the given execution vertex.  */ ;// ------------------------------------------------------------------------ // testing // ------------------------------------------------------------------------ /**  * Finds the failover region that contains the given execution vertex.  */ @VisibleForTesting public FailoverRegion getFailoverRegion(ExecutionVertex ev) {     return vertexToRegion.get(ev). }
false;public;1;4;;@Override public FailoverStrategy create(ExecutionGraph executionGraph) {     return new RestartPipelinedRegionStrategy(executionGraph). }
