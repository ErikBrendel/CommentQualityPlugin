commented;modifiers;parameterAmount;loc;comment;code
true;public;2;12;/**  * Initializes the MetricQueryService.  *  * @param actorSystem ActorSystem to create the MetricQueryService on  * @param resourceID resource ID used to disambiguate the actor name  */ ;/**  * Initializes the MetricQueryService.  *  * @param actorSystem ActorSystem to create the MetricQueryService on  * @param resourceID resource ID used to disambiguate the actor name  */ public void startQueryService(ActorSystem actorSystem, ResourceID resourceID) {     synchronized (lock) {         Preconditions.checkState(!isShutdown(), "The metric registry has already been shut down.").         try {             queryService = MetricQueryService.startMetricQueryService(actorSystem, resourceID, maximumFramesize).             metricQueryServicePath = AkkaUtils.getAkkaURL(actorSystem, queryService).         } catch (Exception e) {             LOG.warn("Could not start MetricDumpActor. No metrics will be submitted to the WebInterface.", e).         }     } }
true;public;0;5;/**  * Returns the address under which the {@link MetricQueryService} is reachable.  *  * @return address of the metric query service  */ ;/**  * Returns the address under which the {@link MetricQueryService} is reachable.  *  * @return address of the metric query service  */ @Override @Nullable public String getMetricQueryServicePath() {     return metricQueryServicePath. }
false;public;0;4;;@Override public char getDelimiter() {     return this.globalDelimiter. }
false;public;1;9;;@Override public char getDelimiter(int reporterIndex) {     try {         return delimiters.get(reporterIndex).     } catch (IndexOutOfBoundsException e) {         LOG.warn("Delimiter for reporter index {} not found, returning global delimiter.", reporterIndex).         return this.globalDelimiter.     } }
false;public;0;4;;@Override public int getNumberReporters() {     return reporters.size(). }
false;public;0;4;;@VisibleForTesting public List<MetricReporter> getReporters() {     return reporters. }
true;public;0;5;/**  * Returns whether this registry has been shutdown.  *  * @return true, if this registry was shutdown, otherwise false  */ ;/**  * Returns whether this registry has been shutdown.  *  * @return true, if this registry was shutdown, otherwise false  */ public boolean isShutdown() {     synchronized (lock) {         return isShutdown.     } }
true;public;0;56;/**  * Shuts down this registry and the associated {@link MetricReporter}.  *  * <p>NOTE: This operation is asynchronous and returns a future which is completed  * once the shutdown operation has been completed.  *  * @return Future which is completed once the {@link MetricRegistryImpl}  * is shut down.  */ ;/**  * Shuts down this registry and the associated {@link MetricReporter}.  *  * <p>NOTE: This operation is asynchronous and returns a future which is completed  * once the shutdown operation has been completed.  *  * @return Future which is completed once the {@link MetricRegistryImpl}  * is shut down.  */ public CompletableFuture<Void> shutdown() {     synchronized (lock) {         if (isShutdown) {             return terminationFuture.         } else {             isShutdown = true.             final Collection<CompletableFuture<Void>> terminationFutures = new ArrayList<>(3).             final Time gracePeriod = Time.seconds(1L).             if (queryService != null) {                 final CompletableFuture<Void> queryServiceTerminationFuture = ActorUtils.nonBlockingShutDown(gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS, queryService).                 terminationFutures.add(queryServiceTerminationFuture).             }             Throwable throwable = null.             for (MetricReporter reporter : reporters) {                 try {                     reporter.close().                 } catch (Throwable t) {                     throwable = ExceptionUtils.firstOrSuppressed(t, throwable).                 }             }             reporters.clear().             if (throwable != null) {                 terminationFutures.add(FutureUtils.completedExceptionally(new FlinkException("Could not shut down the metric reporters properly.", throwable))).             }             final CompletableFuture<Void> executorShutdownFuture = ExecutorUtils.nonBlockingShutdown(gracePeriod.toMilliseconds(), TimeUnit.MILLISECONDS, executor).             terminationFutures.add(executorShutdownFuture).             FutureUtils.completeAll(terminationFutures).whenComplete((Void ignored, Throwable error) -> {                 if (error != null) {                     terminationFuture.completeExceptionally(error).                 } else {                     terminationFuture.complete(null).                 }             }).             return terminationFuture.         }     } }
false;public;0;4;;@Override public ScopeFormats getScopeFormats() {     return scopeFormats. }
false;public;3;39;;// ------------------------------------------------------------------------ // Metrics (de)registration // ------------------------------------------------------------------------ @Override public void register(Metric metric, String metricName, AbstractMetricGroup group) {     synchronized (lock) {         if (isShutdown()) {             LOG.warn("Cannot register metric, because the MetricRegistry has already been shut down.").         } else {             if (reporters != null) {                 for (int i = 0. i < reporters.size(). i++) {                     MetricReporter reporter = reporters.get(i).                     try {                         if (reporter != null) {                             FrontMetricGroup front = new FrontMetricGroup<AbstractMetricGroup<?>>(i, group).                             reporter.notifyOfAddedMetric(metric, metricName, front).                         }                     } catch (Exception e) {                         LOG.warn("Error while registering metric.", e).                     }                 }             }             try {                 if (queryService != null) {                     MetricQueryService.notifyOfAddedMetric(queryService, metric, metricName, group).                 }             } catch (Exception e) {                 LOG.warn("Error while registering metric.", e).             }             try {                 if (metric instanceof View) {                     if (viewUpdater == null) {                         viewUpdater = new ViewUpdater(executor).                     }                     viewUpdater.notifyOfAddedView((View) metric).                 }             } catch (Exception e) {                 LOG.warn("Error while registering metric.", e).             }         }     } }
false;public;3;38;;@Override public void unregister(Metric metric, String metricName, AbstractMetricGroup group) {     synchronized (lock) {         if (isShutdown()) {             LOG.warn("Cannot unregister metric, because the MetricRegistry has already been shut down.").         } else {             if (reporters != null) {                 for (int i = 0. i < reporters.size(). i++) {                     try {                         MetricReporter reporter = reporters.get(i).                         if (reporter != null) {                             FrontMetricGroup front = new FrontMetricGroup<AbstractMetricGroup<?>>(i, group).                             reporter.notifyOfRemovedMetric(metric, metricName, front).                         }                     } catch (Exception e) {                         LOG.warn("Error while registering metric.", e).                     }                 }             }             try {                 if (queryService != null) {                     MetricQueryService.notifyOfRemovedMetric(queryService, metric).                 }             } catch (Exception e) {                 LOG.warn("Error while registering metric.", e).             }             try {                 if (metric instanceof View) {                     if (viewUpdater != null) {                         viewUpdater.notifyOfRemovedView((View) metric).                     }                 }             } catch (Exception e) {                 LOG.warn("Error while registering metric.", e).             }         }     } }
false;public;0;5;;// ------------------------------------------------------------------------ @VisibleForTesting @Nullable public ActorRef getQueryService() {     return queryService. }
false;public;0;8;;@Override public void run() {     try {         reporter.report().     } catch (Throwable t) {         LOG.warn("Error while reporting metrics", t).     } }
