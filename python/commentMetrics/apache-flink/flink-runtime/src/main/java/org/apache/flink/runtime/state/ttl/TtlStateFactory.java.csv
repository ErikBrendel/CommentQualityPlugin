commented;modifiers;parameterAmount;loc;comment;code
false;public,static;4;15;;public static <K, N, SV, TTLSV, S extends State, IS extends S> IS createStateAndWrapWithTtlIfEnabled(TypeSerializer<N> namespaceSerializer, StateDescriptor<S, SV> stateDesc, KeyedStateBackend<K> stateBackend, TtlTimeProvider timeProvider) throws Exception {     Preconditions.checkNotNull(namespaceSerializer).     Preconditions.checkNotNull(stateDesc).     Preconditions.checkNotNull(stateBackend).     Preconditions.checkNotNull(timeProvider).     return stateDesc.getTtlConfig().isEnabled() ? new TtlStateFactory<K, N, SV, TTLSV, S, IS>(namespaceSerializer, stateDesc, stateBackend, timeProvider).createState() : stateBackend.createInternalState(namespaceSerializer, stateDesc). }
false;private;0;11;;@SuppressWarnings("deprecation") private Map<Class<? extends StateDescriptor>, SupplierWithException<IS, Exception>> createStateFactories() {     return Stream.of(Tuple2.of(ValueStateDescriptor.class, (SupplierWithException<IS, Exception>) this::createValueState), Tuple2.of(ListStateDescriptor.class, (SupplierWithException<IS, Exception>) this::createListState), Tuple2.of(MapStateDescriptor.class, (SupplierWithException<IS, Exception>) this::createMapState), Tuple2.of(ReducingStateDescriptor.class, (SupplierWithException<IS, Exception>) this::createReducingState), Tuple2.of(AggregatingStateDescriptor.class, (SupplierWithException<IS, Exception>) this::createAggregatingState), Tuple2.of(FoldingStateDescriptor.class, (SupplierWithException<IS, Exception>) this::createFoldingState)).collect(Collectors.toMap(t -> t.f0, t -> t.f1)). }
false;private;0;14;;@SuppressWarnings("unchecked") private IS createState() throws Exception {     SupplierWithException<IS, Exception> stateFactory = stateFactories.get(stateDesc.getClass()).     if (stateFactory == null) {         String message = String.format("State %s is not supported by %s", stateDesc.getClass(), TtlStateFactory.class).         throw new FlinkRuntimeException(message).     }     IS state = stateFactory.get().     if (incrementalCleanup != null) {         incrementalCleanup.setTtlState((AbstractTtlState<K, N, ?, TTLSV, ?>) state).     }     return state. }
false;private;0;6;;@SuppressWarnings("unchecked") private IS createValueState() throws Exception {     ValueStateDescriptor<TtlValue<SV>> ttlDescriptor = new ValueStateDescriptor<>(stateDesc.getName(), new TtlSerializer<>(LongSerializer.INSTANCE, stateDesc.getSerializer())).     return (IS) new TtlValueState<>(createTtlStateContext(ttlDescriptor)). }
false;private;0;7;;@SuppressWarnings("unchecked") private <T> IS createListState() throws Exception {     ListStateDescriptor<T> listStateDesc = (ListStateDescriptor<T>) stateDesc.     ListStateDescriptor<TtlValue<T>> ttlDescriptor = new ListStateDescriptor<>(stateDesc.getName(), new TtlSerializer<>(LongSerializer.INSTANCE, listStateDesc.getElementSerializer())).     return (IS) new TtlListState<>(createTtlStateContext(ttlDescriptor)). }
false;private;0;9;;@SuppressWarnings("unchecked") private <UK, UV> IS createMapState() throws Exception {     MapStateDescriptor<UK, UV> mapStateDesc = (MapStateDescriptor<UK, UV>) stateDesc.     MapStateDescriptor<UK, TtlValue<UV>> ttlDescriptor = new MapStateDescriptor<>(stateDesc.getName(), mapStateDesc.getKeySerializer(), new TtlSerializer<>(LongSerializer.INSTANCE, mapStateDesc.getValueSerializer())).     return (IS) new TtlMapState<>(createTtlStateContext(ttlDescriptor)). }
false;private;0;9;;@SuppressWarnings("unchecked") private IS createReducingState() throws Exception {     ReducingStateDescriptor<SV> reducingStateDesc = (ReducingStateDescriptor<SV>) stateDesc.     ReducingStateDescriptor<TtlValue<SV>> ttlDescriptor = new ReducingStateDescriptor<>(stateDesc.getName(), new TtlReduceFunction<>(reducingStateDesc.getReduceFunction(), ttlConfig, timeProvider), new TtlSerializer<>(LongSerializer.INSTANCE, stateDesc.getSerializer())).     return (IS) new TtlReducingState<>(createTtlStateContext(ttlDescriptor)). }
false;private;0;10;;@SuppressWarnings("unchecked") private <IN, OUT> IS createAggregatingState() throws Exception {     AggregatingStateDescriptor<IN, SV, OUT> aggregatingStateDescriptor = (AggregatingStateDescriptor<IN, SV, OUT>) stateDesc.     TtlAggregateFunction<IN, SV, OUT> ttlAggregateFunction = new TtlAggregateFunction<>(aggregatingStateDescriptor.getAggregateFunction(), ttlConfig, timeProvider).     AggregatingStateDescriptor<IN, TtlValue<SV>, OUT> ttlDescriptor = new AggregatingStateDescriptor<>(stateDesc.getName(), ttlAggregateFunction, new TtlSerializer<>(LongSerializer.INSTANCE, stateDesc.getSerializer())).     return (IS) new TtlAggregatingState<>(createTtlStateContext(ttlDescriptor), ttlAggregateFunction). }
false;private;0;12;;@SuppressWarnings({ "deprecation", "unchecked" }) private <T> IS createFoldingState() throws Exception {     FoldingStateDescriptor<T, SV> foldingStateDescriptor = (FoldingStateDescriptor<T, SV>) stateDesc.     SV initAcc = stateDesc.getDefaultValue().     TtlValue<SV> ttlInitAcc = initAcc == null ? null : new TtlValue<>(initAcc, Long.MAX_VALUE).     FoldingStateDescriptor<T, TtlValue<SV>> ttlDescriptor = new FoldingStateDescriptor<>(stateDesc.getName(), ttlInitAcc, new TtlFoldFunction<>(foldingStateDescriptor.getFoldFunction(), ttlConfig, timeProvider, initAcc), new TtlSerializer<>(LongSerializer.INSTANCE, stateDesc.getSerializer())).     return (IS) new TtlFoldingState<>(createTtlStateContext(ttlDescriptor)). }
false;private;1;11;;@SuppressWarnings("unchecked") private <OIS extends State, TTLS extends State, V, TTLV> TtlStateContext<OIS, V> createTtlStateContext(StateDescriptor<TTLS, TTLV> ttlDescriptor) throws Exception {     // also used by RocksDB backend for TTL compaction filter config     ttlDescriptor.enableTimeToLive(stateDesc.getTtlConfig()).     OIS originalState = (OIS) stateBackend.createInternalState(namespaceSerializer, ttlDescriptor, getSnapshotTransformFactory()).     return new TtlStateContext<>(originalState, ttlConfig, timeProvider, (TypeSerializer<V>) stateDesc.getSerializer(), registerTtlIncrementalCleanupCallback((InternalKvState<?, ?, ?>) originalState)). }
false;private;0;5;;private TtlIncrementalCleanup<K, N, TTLSV> getTtlIncrementalCleanup() {     StateTtlConfig.IncrementalCleanupStrategy config = ttlConfig.getCleanupStrategies().getIncrementalCleanupStrategy().     return config != null ? new TtlIncrementalCleanup<>(config.getCleanupSize()) : null. }
false;private;1;12;;private Runnable registerTtlIncrementalCleanupCallback(InternalKvState<?, ?, ?> originalState) {     StateTtlConfig.IncrementalCleanupStrategy config = ttlConfig.getCleanupStrategies().getIncrementalCleanupStrategy().     boolean cleanupConfigured = config != null && incrementalCleanup != null.     boolean isCleanupActive = cleanupConfigured && isStateIteratorSupported(originalState, incrementalCleanup.getCleanupSize()).     Runnable callback = isCleanupActive ? incrementalCleanup::stateAccessed : () -> {     }.     if (isCleanupActive && config.runCleanupForEveryRecord()) {         stateBackend.registerKeySelectionListener(stub -> callback.run()).     }     return callback. }
false;private;2;9;;private boolean isStateIteratorSupported(InternalKvState<?, ?, ?> originalState, int size) {     boolean stateIteratorSupported = false.     try {         stateIteratorSupported = originalState.getStateIncrementalVisitor(size) != null.     } catch (Throwable t) {     // ignore     }     return stateIteratorSupported. }
false;private;0;7;;private StateSnapshotTransformFactory<?> getSnapshotTransformFactory() {     if (!ttlConfig.getCleanupStrategies().inFullSnapshot()) {         return StateSnapshotTransformFactory.noTransform().     } else {         return new TtlStateSnapshotTransformer.Factory<>(timeProvider, ttl).     } }
false;public;1;6;;@SuppressWarnings("unchecked") @Override public TtlValue<T> createInstance(@Nonnull Object... values) {     Preconditions.checkArgument(values.length == 2).     return new TtlValue<>((T) values[1], (long) values[0]). }
false;protected;3;4;;@Override protected void setField(@Nonnull TtlValue<T> v, int index, Object fieldValue) {     throw new UnsupportedOperationException("TtlValue is immutable"). }
false;protected;2;4;;@Override protected Object getField(@Nonnull TtlValue<T> v, int index) {     return index == 0 ? v.getLastAccessTimestamp() : v.getUserValue(). }
false;protected;2;9;;@SuppressWarnings("unchecked") @Override protected CompositeSerializer<TtlValue<T>> createSerializerInstance(PrecomputedParameters precomputed, TypeSerializer<?>... originalSerializers) {     Preconditions.checkNotNull(originalSerializers).     Preconditions.checkArgument(originalSerializers.length == 2).     return new TtlSerializer<>(precomputed, originalSerializers). }
false;;0;4;;@SuppressWarnings("unchecked") TypeSerializer<Long> getTimestampSerializer() {     return (TypeSerializer<Long>) (TypeSerializer<?>) fieldSerializers[0]. }
false;;0;4;;@SuppressWarnings("unchecked") TypeSerializer<T> getValueSerializer() {     return (TypeSerializer<T>) fieldSerializers[1]. }
false;public;0;4;;@Override public TypeSerializerSnapshot<TtlValue<T>> snapshotConfiguration() {     return new TtlSerializerSnapshot<>(this). }
false;public;1;16;;@Override public TypeSerializerSchemaCompatibility<TtlValue<T>> resolveSchemaCompatibilityViaRedirectingToNewSnapshotClass(TypeSerializerConfigSnapshot<TtlValue<T>> deprecatedConfigSnapshot) {     if (deprecatedConfigSnapshot instanceof ConfigSnapshot) {         ConfigSnapshot castedLegacyConfigSnapshot = (ConfigSnapshot) deprecatedConfigSnapshot.         TtlSerializerSnapshot<T> newSnapshot = new TtlSerializerSnapshot<>().         return CompositeTypeSerializerUtil.delegateCompatibilityCheckToNewSnapshot(this, newSnapshot, castedLegacyConfigSnapshot.getNestedSerializerSnapshots()).     }     return TypeSerializerSchemaCompatibility.incompatible(). }
false;public,static;1;8;;public static boolean isTtlStateSerializer(TypeSerializer<?> typeSerializer) {     boolean ttlSerializer = typeSerializer instanceof TtlStateFactory.TtlSerializer.     boolean ttlListSerializer = typeSerializer instanceof ListSerializer && ((ListSerializer) typeSerializer).getElementSerializer() instanceof TtlStateFactory.TtlSerializer.     boolean ttlMapSerializer = typeSerializer instanceof MapSerializer && ((MapSerializer) typeSerializer).getValueSerializer() instanceof TtlStateFactory.TtlSerializer.     return ttlSerializer || ttlListSerializer || ttlMapSerializer. }
false;protected;0;4;;@Override protected int getCurrentOuterSnapshotVersion() {     return VERSION. }
false;protected;1;4;;@Override protected TypeSerializer<?>[] getNestedSerializers(TtlSerializer<T> outerSerializer) {     return new TypeSerializer[] { outerSerializer.getTimestampSerializer(), outerSerializer.getValueSerializer() }. }
false;protected;1;8;;@Override @SuppressWarnings("unchecked") protected TtlSerializer<T> createOuterSerializerWithNestedSerializers(TypeSerializer<?>[] nestedSerializers) {     TypeSerializer<Long> timestampSerializer = (TypeSerializer<Long>) nestedSerializers[0].     TypeSerializer<T> valueSerializer = (TypeSerializer<T>) nestedSerializers[1].     return new TtlSerializer<>(timestampSerializer, valueSerializer). }
