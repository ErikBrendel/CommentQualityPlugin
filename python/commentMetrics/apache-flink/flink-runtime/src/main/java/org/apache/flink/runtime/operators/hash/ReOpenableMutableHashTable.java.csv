# id;timestamp;commentText;codeText;commentWords;codeWords
ReOpenableMutableHashTable -> void storeInitialHashTable() throws IOException;1405024514;This method stores the initial hash table's contents on disk if hash join needs the memory_for further partition processing._The initial hash table is rebuild before a new secondary input is opened.__For the sake of simplicity we iterate over all in-memory elements and store them in one file._The file is hashed into memory upon opening a new probe input._@throws IOException;void storeInitialHashTable() throws IOException {_		if (spilled) {_			return_ _		}_		spilled = true__		_		for (int partIdx = 0_ partIdx < initialPartitions.size()_ partIdx++) {_			final ReOpenableHashPartition<BT, PT> p = (ReOpenableHashPartition<BT, PT>) initialPartitions.get(partIdx)__			if (p.isInMemory()) { _				this.writeBehindBuffersAvailable += p.spillInMemoryPartition(spilledInMemoryPartitions.next(), ioManager, writeBehindBuffers)__			}_		}_	};this,method,stores,the,initial,hash,table,s,contents,on,disk,if,hash,join,needs,the,memory,for,further,partition,processing,the,initial,hash,table,is,rebuild,before,a,new,secondary,input,is,opened,for,the,sake,of,simplicity,we,iterate,over,all,in,memory,elements,and,store,them,in,one,file,the,file,is,hashed,into,memory,upon,opening,a,new,probe,input,throws,ioexception;void,store,initial,hash,table,throws,ioexception,if,spilled,return,spilled,true,for,int,part,idx,0,part,idx,initial,partitions,size,part,idx,final,re,openable,hash,partition,bt,pt,p,re,openable,hash,partition,bt,pt,initial,partitions,get,part,idx,if,p,is,in,memory,this,write,behind,buffers,available,p,spill,in,memory,partition,spilled,in,memory,partitions,next,io,manager,write,behind,buffers
ReOpenableMutableHashTable -> void storeInitialHashTable() throws IOException;1405090423;This method stores the initial hash table's contents on disk if hash join needs the memory_for further partition processing._The initial hash table is rebuild before a new secondary input is opened.__For the sake of simplicity we iterate over all in-memory elements and store them in one file._The file is hashed into memory upon opening a new probe input._@throws IOException;void storeInitialHashTable() throws IOException {_		if (spilled) {_			return_ _		}_		spilled = true__		_		for (int partIdx = 0_ partIdx < initialPartitions.size()_ partIdx++) {_			final ReOpenableHashPartition<BT, PT> p = (ReOpenableHashPartition<BT, PT>) initialPartitions.get(partIdx)__			if (p.isInMemory()) { _				this.writeBehindBuffersAvailable += p.spillInMemoryPartition(spilledInMemoryPartitions.next(), ioManager, writeBehindBuffers)__			}_		}_	};this,method,stores,the,initial,hash,table,s,contents,on,disk,if,hash,join,needs,the,memory,for,further,partition,processing,the,initial,hash,table,is,rebuild,before,a,new,secondary,input,is,opened,for,the,sake,of,simplicity,we,iterate,over,all,in,memory,elements,and,store,them,in,one,file,the,file,is,hashed,into,memory,upon,opening,a,new,probe,input,throws,ioexception;void,store,initial,hash,table,throws,ioexception,if,spilled,return,spilled,true,for,int,part,idx,0,part,idx,initial,partitions,size,part,idx,final,re,openable,hash,partition,bt,pt,p,re,openable,hash,partition,bt,pt,initial,partitions,get,part,idx,if,p,is,in,memory,this,write,behind,buffers,available,p,spill,in,memory,partition,spilled,in,memory,partitions,next,io,manager,write,behind,buffers
ReOpenableMutableHashTable -> void storeInitialHashTable() throws IOException;1411473593;This method stores the initial hash table's contents on disk if hash join needs the memory_for further partition processing._The initial hash table is rebuild before a new secondary input is opened.__For the sake of simplicity we iterate over all in-memory elements and store them in one file._The file is hashed into memory upon opening a new probe input._@throws IOException;void storeInitialHashTable() throws IOException {_		if (spilled) {_			return_ _		}_		spilled = true__		_		for (int partIdx = 0_ partIdx < initialPartitions.size()_ partIdx++) {_			final ReOpenableHashPartition<BT, PT> p = (ReOpenableHashPartition<BT, PT>) initialPartitions.get(partIdx)__			if (p.isInMemory()) { _				this.writeBehindBuffersAvailable += p.spillInMemoryPartition(spilledInMemoryPartitions.next(), ioManager, writeBehindBuffers)__			}_		}_	};this,method,stores,the,initial,hash,table,s,contents,on,disk,if,hash,join,needs,the,memory,for,further,partition,processing,the,initial,hash,table,is,rebuild,before,a,new,secondary,input,is,opened,for,the,sake,of,simplicity,we,iterate,over,all,in,memory,elements,and,store,them,in,one,file,the,file,is,hashed,into,memory,upon,opening,a,new,probe,input,throws,ioexception;void,store,initial,hash,table,throws,ioexception,if,spilled,return,spilled,true,for,int,part,idx,0,part,idx,initial,partitions,size,part,idx,final,re,openable,hash,partition,bt,pt,p,re,openable,hash,partition,bt,pt,initial,partitions,get,part,idx,if,p,is,in,memory,this,write,behind,buffers,available,p,spill,in,memory,partition,spilled,in,memory,partitions,next,io,manager,write,behind,buffers
ReOpenableMutableHashTable -> void storeInitialHashTable() throws IOException;1415702894;This method stores the initial hash table's contents on disk if hash join needs the memory_for further partition processing._The initial hash table is rebuild before a new secondary input is opened.__For the sake of simplicity we iterate over all in-memory elements and store them in one file._The file is hashed into memory upon opening a new probe input._@throws IOException;void storeInitialHashTable() throws IOException {_		if (spilled) {_			return_ _		}_		spilled = true__		_		for (int partIdx = 0_ partIdx < initialPartitions.size()_ partIdx++) {_			final ReOpenableHashPartition<BT, PT> p = (ReOpenableHashPartition<BT, PT>) initialPartitions.get(partIdx)__			if (p.isInMemory()) { _				this.writeBehindBuffersAvailable += p.spillInMemoryPartition(spilledInMemoryPartitions.next(), ioManager, writeBehindBuffers)__			}_		}_	};this,method,stores,the,initial,hash,table,s,contents,on,disk,if,hash,join,needs,the,memory,for,further,partition,processing,the,initial,hash,table,is,rebuild,before,a,new,secondary,input,is,opened,for,the,sake,of,simplicity,we,iterate,over,all,in,memory,elements,and,store,them,in,one,file,the,file,is,hashed,into,memory,upon,opening,a,new,probe,input,throws,ioexception;void,store,initial,hash,table,throws,ioexception,if,spilled,return,spilled,true,for,int,part,idx,0,part,idx,initial,partitions,size,part,idx,final,re,openable,hash,partition,bt,pt,p,re,openable,hash,partition,bt,pt,initial,partitions,get,part,idx,if,p,is,in,memory,this,write,behind,buffers,available,p,spill,in,memory,partition,spilled,in,memory,partitions,next,io,manager,write,behind,buffers
ReOpenableMutableHashTable -> void storeInitialHashTable() throws IOException;1438877580;This method stores the initial hash table's contents on disk if hash join needs the memory_for further partition processing._The initial hash table is rebuild before a new secondary input is opened.__For the sake of simplicity we iterate over all in-memory elements and store them in one file._The file is hashed into memory upon opening a new probe input._@throws IOException;void storeInitialHashTable() throws IOException {_		if (spilled) {_			return_ _		}_		spilled = true__		_		for (int partIdx = 0_ partIdx < initialPartitions.size()_ partIdx++) {_			final ReOpenableHashPartition<BT, PT> p = (ReOpenableHashPartition<BT, PT>) initialPartitions.get(partIdx)__			if (p.isInMemory()) { _				this.writeBehindBuffersAvailable += p.spillInMemoryPartition(spilledInMemoryPartitions.next(), ioManager, writeBehindBuffers)__			}_		}_	};this,method,stores,the,initial,hash,table,s,contents,on,disk,if,hash,join,needs,the,memory,for,further,partition,processing,the,initial,hash,table,is,rebuild,before,a,new,secondary,input,is,opened,for,the,sake,of,simplicity,we,iterate,over,all,in,memory,elements,and,store,them,in,one,file,the,file,is,hashed,into,memory,upon,opening,a,new,probe,input,throws,ioexception;void,store,initial,hash,table,throws,ioexception,if,spilled,return,spilled,true,for,int,part,idx,0,part,idx,initial,partitions,size,part,idx,final,re,openable,hash,partition,bt,pt,p,re,openable,hash,partition,bt,pt,initial,partitions,get,part,idx,if,p,is,in,memory,this,write,behind,buffers,available,p,spill,in,memory,partition,spilled,in,memory,partitions,next,io,manager,write,behind,buffers
ReOpenableMutableHashTable -> void storeInitialHashTable() throws IOException;1440607697;This method stores the initial hash table's contents on disk if hash join needs the memory_for further partition processing._The initial hash table is rebuild before a new secondary input is opened.__For the sake of simplicity we iterate over all in-memory elements and store them in one file._The file is hashed into memory upon opening a new probe input._@throws IOException;void storeInitialHashTable() throws IOException {_		if (spilled) {_			return_ _		}_		spilled = true__		_		for (int partIdx = 0_ partIdx < initialPartitions.size()_ partIdx++) {_			final ReOpenableHashPartition<BT, PT> p = (ReOpenableHashPartition<BT, PT>) initialPartitions.get(partIdx)__			if (p.isInMemory()) { _				this.writeBehindBuffersAvailable += p.spillInMemoryPartition(spilledInMemoryPartitions.next(), ioManager, writeBehindBuffers)__			}_		}_	};this,method,stores,the,initial,hash,table,s,contents,on,disk,if,hash,join,needs,the,memory,for,further,partition,processing,the,initial,hash,table,is,rebuild,before,a,new,secondary,input,is,opened,for,the,sake,of,simplicity,we,iterate,over,all,in,memory,elements,and,store,them,in,one,file,the,file,is,hashed,into,memory,upon,opening,a,new,probe,input,throws,ioexception;void,store,initial,hash,table,throws,ioexception,if,spilled,return,spilled,true,for,int,part,idx,0,part,idx,initial,partitions,size,part,idx,final,re,openable,hash,partition,bt,pt,p,re,openable,hash,partition,bt,pt,initial,partitions,get,part,idx,if,p,is,in,memory,this,write,behind,buffers,available,p,spill,in,memory,partition,spilled,in,memory,partitions,next,io,manager,write,behind,buffers
ReOpenableMutableHashTable -> void storeInitialHashTable() throws IOException;1453866659;This method stores the initial hash table's contents on disk if hash join needs the memory_for further partition processing._The initial hash table is rebuild before a new secondary input is opened.__For the sake of simplicity we iterate over all in-memory elements and store them in one file._The file is hashed into memory upon opening a new probe input._@throws IOException;void storeInitialHashTable() throws IOException {_		if (spilled) {_			return_ _		}_		spilled = true__		_		for (int partIdx = 0_ partIdx < initialPartitions.size()_ partIdx++) {_			final ReOpenableHashPartition<BT, PT> p = (ReOpenableHashPartition<BT, PT>) initialPartitions.get(partIdx)__			if (p.isInMemory()) { _				this.writeBehindBuffersAvailable += p.spillInMemoryPartition(spilledInMemoryPartitions.next(), ioManager, writeBehindBuffers)__			}_		}_	};this,method,stores,the,initial,hash,table,s,contents,on,disk,if,hash,join,needs,the,memory,for,further,partition,processing,the,initial,hash,table,is,rebuild,before,a,new,secondary,input,is,opened,for,the,sake,of,simplicity,we,iterate,over,all,in,memory,elements,and,store,them,in,one,file,the,file,is,hashed,into,memory,upon,opening,a,new,probe,input,throws,ioexception;void,store,initial,hash,table,throws,ioexception,if,spilled,return,spilled,true,for,int,part,idx,0,part,idx,initial,partitions,size,part,idx,final,re,openable,hash,partition,bt,pt,p,re,openable,hash,partition,bt,pt,initial,partitions,get,part,idx,if,p,is,in,memory,this,write,behind,buffers,available,p,spill,in,memory,partition,spilled,in,memory,partitions,next,io,manager,write,behind,buffers
ReOpenableMutableHashTable -> void storeInitialHashTable() throws IOException;1530185676;This method stores the initial hash table's contents on disk if hash join needs the memory_for further partition processing._The initial hash table is rebuild before a new secondary input is opened.__For the sake of simplicity we iterate over all in-memory elements and store them in one file._The file is hashed into memory upon opening a new probe input._@throws IOException;void storeInitialHashTable() throws IOException {_		if (spilled) {_			return_ _		}_		spilled = true__		_		for (int partIdx = 0_ partIdx < initialPartitions.size()_ partIdx++) {_			final ReOpenableHashPartition<BT, PT> p = (ReOpenableHashPartition<BT, PT>) initialPartitions.get(partIdx)__			if (p.isInMemory()) { _				this.writeBehindBuffersAvailable += p.spillInMemoryPartition(spilledInMemoryPartitions.next(), ioManager, writeBehindBuffers)__			}_		}_	};this,method,stores,the,initial,hash,table,s,contents,on,disk,if,hash,join,needs,the,memory,for,further,partition,processing,the,initial,hash,table,is,rebuild,before,a,new,secondary,input,is,opened,for,the,sake,of,simplicity,we,iterate,over,all,in,memory,elements,and,store,them,in,one,file,the,file,is,hashed,into,memory,upon,opening,a,new,probe,input,throws,ioexception;void,store,initial,hash,table,throws,ioexception,if,spilled,return,spilled,true,for,int,part,idx,0,part,idx,initial,partitions,size,part,idx,final,re,openable,hash,partition,bt,pt,p,re,openable,hash,partition,bt,pt,initial,partitions,get,part,idx,if,p,is,in,memory,this,write,behind,buffers,available,p,spill,in,memory,partition,spilled,in,memory,partitions,next,io,manager,write,behind,buffers
