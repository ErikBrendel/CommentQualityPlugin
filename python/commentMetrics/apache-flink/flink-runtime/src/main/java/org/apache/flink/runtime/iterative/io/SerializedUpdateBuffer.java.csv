commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;30;;@Override protected MemorySegment nextSegment(MemorySegment current, int positionInCurrent) throws IOException {     current.putInt(0, positionInCurrent).     // check if we keep the segment in memory, or if we spill it     if (emptyBuffers.size() > numSegmentsSpillingThreshold) {         // keep buffer in memory         fullBuffers.addLast(current).     } else {         // check, whether we have a channel already         if (currentWriter == null) {             currentWriter = ioManager.createBlockChannelWriter(channelEnumerator.next(), emptyBuffers).         }         // spill all elements gathered up to now         numBuffersSpilled += fullBuffers.size().         while (fullBuffers.size() > 0) {             currentWriter.writeBlock(fullBuffers.removeFirst()).         }         currentWriter.writeBlock(current).         numBuffersSpilled++.     }     try {         return emptyBuffers.take().     } catch (InterruptedException iex) {         throw new RuntimeException("Spilling Fifo Queue was interrupted while waiting for next buffer.").     } }
false;public;0;3;;public void flush() throws IOException {     advance(). }
false;public;0;76;;public ReadEnd switchBuffers() throws IOException {     // remove exhausted read ends     for (int i = readEnds.size() - 1. i >= 0. --i) {         final ReadEnd re = readEnds.get(i).         if (re.disposeIfDone()) {             readEnds.remove(i).         }     }     // add the current memorySegment and reset this writer     final MemorySegment current = getCurrentSegment().     current.putInt(0, getCurrentPositionInSegment()).     fullBuffers.addLast(current).     // create the reader     final ReadEnd readEnd.     if (numBuffersSpilled == 0 && emptyBuffers.size() >= minBuffersForWriteEnd) {         // read completely from in-memory segments         readEnd = new ReadEnd(fullBuffers.removeFirst(), emptyBuffers, fullBuffers, null, null, 0).     } else {         int toSpill = Math.min(minBuffersForSpilledReadEnd + minBuffersForWriteEnd - emptyBuffers.size(), fullBuffers.size()).         // grab some empty buffers to re-read the first segment         if (toSpill > 0) {             // need to spill to make a buffers available             if (currentWriter == null) {                 currentWriter = ioManager.createBlockChannelWriter(channelEnumerator.next(), emptyBuffers).             }             for (int i = 0. i < toSpill. i++) {                 currentWriter.writeBlock(fullBuffers.removeFirst()).             }             numBuffersSpilled += toSpill.         }         // now close the writer and create the reader         currentWriter.close().         final BlockChannelReader<MemorySegment> reader = ioManager.createBlockChannelReader(currentWriter.getChannelID()).         // gather some memory segments to circulate while reading back the data         final List<MemorySegment> readSegments = new ArrayList<MemorySegment>().         try {             while (readSegments.size() < minBuffersForSpilledReadEnd) {                 readSegments.add(emptyBuffers.take()).             }             // read the first segment             MemorySegment firstSeg = readSegments.remove(readSegments.size() - 1).             reader.readBlock(firstSeg).             firstSeg = reader.getReturnQueue().take().             // create the read end reading one less buffer, because the first buffer is already read back             readEnd = new ReadEnd(firstSeg, emptyBuffers, fullBuffers, reader, readSegments, numBuffersSpilled - 1).         } catch (InterruptedException e) {             throw new RuntimeException("SerializedUpdateBuffer was interrupted while reclaiming memory by spilling.", e).         }     }     // reset the writer     fullBuffers = new ArrayDeque<MemorySegment>(64).     currentWriter = null.     numBuffersSpilled = 0.     try {         seekOutput(emptyBuffers.take(), HEADER_LENGTH).     } catch (InterruptedException e) {         throw new RuntimeException("SerializedUpdateBuffer was interrupted while reclaiming memory by spilling.", e).     }     // register this read end     readEnds.add(readEnd).     return readEnd. }
false;public;0;34;;public List<MemorySegment> close() {     if (currentWriter != null) {         try {             currentWriter.closeAndDelete().         } catch (Throwable t) {         // do nothing         }     }     List<MemorySegment> freeMem = new ArrayList<MemorySegment>(64).     // add all memory allocated to the write end     freeMem.add(getCurrentSegment()).     clear().     freeMem.addAll(fullBuffers).     fullBuffers = null.     // add memory from non-exhausted read ends     try {         for (int i = readEnds.size() - 1. i >= 0. --i) {             final ReadEnd re = readEnds.remove(i).             re.forceDispose(freeMem).         }         // release all empty segments         while (freeMem.size() < totalNumBuffers) {             freeMem.add(emptyBuffers.take()).         }     } catch (InterruptedException e) {         throw new RuntimeException("Retrieving memory back from asynchronous I/O was interrupted.", e).     }     return freeMem. }
false;protected;1;31;;@Override protected MemorySegment nextSegment(MemorySegment current) throws IOException {     // use the buffer to send the next request     if (requestsRemaining > 0) {         requestsRemaining--.         spilledBufferSource.readBlock(current).     } else {         emptyBufferTarget.add(current).     }     // get the next buffer either from the return queue, or the full buffer source     if (spilledBuffersRemaining > 0) {         spilledBuffersRemaining--.         try {             return spilledBufferSource.getReturnQueue().take().         } catch (InterruptedException e) {             throw new RuntimeException("Read End was interrupted while waiting for spilled buffer.", e).         }     } else if (fullBufferSource.size() > 0) {         return fullBufferSource.removeFirst().     } else {         clear().         // delete the channel, if we had one         if (spilledBufferSource != null) {             spilledBufferSource.closeAndDelete().         }         throw new EOFException().     } }
false;protected;1;4;;@Override protected int getLimitForSegment(MemorySegment segment) {     return segment.getInt(0). }
false;private;0;20;;private boolean disposeIfDone() {     if (fullBufferSource.isEmpty() && spilledBuffersRemaining == 0) {         if (getCurrentSegment() == null || getCurrentPositionInSegment() >= getCurrentSegmentLimit()) {             if (getCurrentSegment() != null) {                 emptyBufferTarget.add(getCurrentSegment()).                 clear().             }             if (spilledBufferSource != null) {                 try {                     spilledBufferSource.closeAndDelete().                 } catch (Throwable t) {                 // do nothing                 }             }             return true.         }     }     return false. }
false;private;1;24;;private void forceDispose(List<MemorySegment> freeMemTarget) throws InterruptedException {     // add the current segment     final MemorySegment current = getCurrentSegment().     clear().     if (current != null) {         freeMemTarget.add(current).     }     // add all remaining memory     freeMemTarget.addAll(fullBufferSource).     // add the segments with the requests issued but not returned     for (int i = spilledBuffersRemaining - requestsRemaining. i > 0. --i) {         freeMemTarget.add(emptyBufferTarget.take()).     }     if (spilledBufferSource != null) {         try {             spilledBufferSource.closeAndDelete().         } catch (Throwable t) {         // do nothing         }     } }
