commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// ------------------------------------------------------------------------ // completion and cancellation // ------------------------------------------------------------------------ public CompletableFuture<Tuple2<G, S>> getFuture() {     return completionFuture. }
true;public;0;4;/**  * Cancels the registration procedure.  */ ;/**  * Cancels the registration procedure.  */ public void cancel() {     canceled = true.     completionFuture.cancel(false). }
true;public;0;3;/**  * Checks if the registration was canceled.  * @return True if the registration was canceled, false otherwise.  */ ;/**  * Checks if the registration was canceled.  * @return True if the registration was canceled, false otherwise.  */ public boolean isCanceled() {     return canceled. }
false;protected,abstract;3;2;;// ------------------------------------------------------------------------ // registration // ------------------------------------------------------------------------ protected abstract CompletableFuture<RegistrationResponse> invokeRegistration(G gateway, F fencingToken, long timeoutMillis) throws Exception.
true;public;0;59;/**  * This method resolves the target address to a callable gateway and starts the  * registration after that.  */ ;/**  * This method resolves the target address to a callable gateway and starts the  * registration after that.  */ @SuppressWarnings("unchecked") public void startRegistration() {     if (canceled) {         // we already got canceled         return.     }     try {         // trigger resolution of the target address to a callable gateway         final CompletableFuture<G> rpcGatewayFuture.         if (FencedRpcGateway.class.isAssignableFrom(targetType)) {             rpcGatewayFuture = (CompletableFuture<G>) rpcService.connect(targetAddress, fencingToken, targetType.asSubclass(FencedRpcGateway.class)).         } else {             rpcGatewayFuture = rpcService.connect(targetAddress, targetType).         }         // upon success, start the registration attempts         CompletableFuture<Void> rpcGatewayAcceptFuture = rpcGatewayFuture.thenAcceptAsync((G rpcGateway) -> {             log.info("Resolved {} address, beginning registration", targetName).             register(rpcGateway, 1, retryingRegistrationConfiguration.getInitialRegistrationTimeoutMillis()).         }, rpcService.getExecutor()).         // upon failure, retry, unless this is cancelled         rpcGatewayAcceptFuture.whenCompleteAsync((Void v, Throwable failure) -> {             if (failure != null && !canceled) {                 final Throwable strippedFailure = ExceptionUtils.stripCompletionException(failure).                 if (log.isDebugEnabled()) {                     log.debug("Could not resolve {} address {}, retrying in {} ms.", targetName, targetAddress, retryingRegistrationConfiguration.getErrorDelayMillis(), strippedFailure).                 } else {                     log.info("Could not resolve {} address {}, retrying in {} ms: {}.", targetName, targetAddress, retryingRegistrationConfiguration.getErrorDelayMillis(), strippedFailure.getMessage()).                 }                 startRegistrationLater(retryingRegistrationConfiguration.getErrorDelayMillis()).             }         }, rpcService.getExecutor()).     } catch (Throwable t) {         completionFuture.completeExceptionally(t).         cancel().     } }
true;private;3;68;/**  * This method performs a registration attempt and triggers either a success notification or a retry,  * depending on the result.  */ ;/**  * This method performs a registration attempt and triggers either a success notification or a retry,  * depending on the result.  */ @SuppressWarnings("unchecked") private void register(final G gateway, final int attempt, final long timeoutMillis) {     // eager check for canceling to avoid some unnecessary work     if (canceled) {         return.     }     try {         log.info("Registration at {} attempt {} (timeout={}ms)", targetName, attempt, timeoutMillis).         CompletableFuture<RegistrationResponse> registrationFuture = invokeRegistration(gateway, fencingToken, timeoutMillis).         // if the registration was successful, let the TaskExecutor know         CompletableFuture<Void> registrationAcceptFuture = registrationFuture.thenAcceptAsync((RegistrationResponse result) -> {             if (!isCanceled()) {                 if (result instanceof RegistrationResponse.Success) {                     // registration successful!                     S success = (S) result.                     completionFuture.complete(Tuple2.of(gateway, success)).                 } else {                     // registration refused or unknown                     if (result instanceof RegistrationResponse.Decline) {                         RegistrationResponse.Decline decline = (RegistrationResponse.Decline) result.                         log.info("Registration at {} was declined: {}", targetName, decline.getReason()).                     } else {                         log.error("Received unknown response to registration attempt: {}", result).                     }                     log.info("Pausing and re-attempting registration in {} ms", retryingRegistrationConfiguration.getRefusedDelayMillis()).                     registerLater(gateway, 1, retryingRegistrationConfiguration.getInitialRegistrationTimeoutMillis(), retryingRegistrationConfiguration.getRefusedDelayMillis()).                 }             }         }, rpcService.getExecutor()).         // upon failure, retry         registrationAcceptFuture.whenCompleteAsync((Void v, Throwable failure) -> {             if (failure != null && !isCanceled()) {                 if (ExceptionUtils.stripCompletionException(failure) instanceof TimeoutException) {                     // currently down.                     if (log.isDebugEnabled()) {                         log.debug("Registration at {} ({}) attempt {} timed out after {} ms", targetName, targetAddress, attempt, timeoutMillis).                     }                     long newTimeoutMillis = Math.min(2 * timeoutMillis, retryingRegistrationConfiguration.getMaxRegistrationTimeoutMillis()).                     register(gateway, attempt + 1, newTimeoutMillis).                 } else {                     // a serious failure occurred. we still should not give up, but keep trying                     log.error("Registration at {} failed due to an error", targetName, failure).                     log.info("Pausing and re-attempting registration in {} ms", retryingRegistrationConfiguration.getErrorDelayMillis()).                     registerLater(gateway, 1, retryingRegistrationConfiguration.getInitialRegistrationTimeoutMillis(), retryingRegistrationConfiguration.getErrorDelayMillis()).                 }             }         }, rpcService.getExecutor()).     } catch (Throwable t) {         completionFuture.completeExceptionally(t).         cancel().     } }
false;public;0;4;;@Override public void run() {     register(gateway, attempt, timeoutMillis). }
false;private;4;8;;private void registerLater(final G gateway, final int attempt, final long timeoutMillis, long delay) {     rpcService.scheduleRunnable(new Runnable() {          @Override         public void run() {             register(gateway, attempt, timeoutMillis).         }     }, delay, TimeUnit.MILLISECONDS). }
false;private;1;6;;private void startRegistrationLater(final long delay) {     rpcService.scheduleRunnable(this::startRegistration, delay, TimeUnit.MILLISECONDS). }
