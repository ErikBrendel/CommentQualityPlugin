commented;modifiers;parameterAmount;loc;comment;code
true;public;4;18;/**  * Returns a future that completes with a given number of stack trace samples of a task thread.  *  * @param task                The task to be sampled from.  * @param numSamples          The number of samples.  * @param delayBetweenSamples The time to wait between taking samples.  * @param maxStackTraceDepth  The maximum depth of the returned stack traces.  *                            Negative means unlimited.  * @return A future containing the stack trace samples.  */ ;/**  * Returns a future that completes with a given number of stack trace samples of a task thread.  *  * @param task                The task to be sampled from.  * @param numSamples          The number of samples.  * @param delayBetweenSamples The time to wait between taking samples.  * @param maxStackTraceDepth  The maximum depth of the returned stack traces.  *                            Negative means unlimited.  * @return A future containing the stack trace samples.  */ public CompletableFuture<List<StackTraceElement[]>> requestStackTraceSample(final StackTraceSampleableTask task, @Nonnegative final int numSamples, final Time delayBetweenSamples, final int maxStackTraceDepth) {     checkNotNull(task, "task must not be null").     checkArgument(numSamples > 0, "numSamples must be positive").     checkNotNull(delayBetweenSamples, "delayBetweenSamples must not be null").     return requestStackTraceSample(task, numSamples, delayBetweenSamples, maxStackTraceDepth, new ArrayList<>(numSamples), new CompletableFuture<>()). }
false;private;6;33;;private CompletableFuture<List<StackTraceElement[]>> requestStackTraceSample(final StackTraceSampleableTask task, final int numSamples, final Time delayBetweenSamples, final int maxStackTraceDepth, final List<StackTraceElement[]> currentTraces, final CompletableFuture<List<StackTraceElement[]>> resultFuture) {     final Optional<StackTraceElement[]> stackTrace = getStackTrace(task, maxStackTraceDepth).     if (stackTrace.isPresent()) {         currentTraces.add(stackTrace.get()).     } else if (!currentTraces.isEmpty()) {         resultFuture.complete(currentTraces).         return resultFuture.     } else {         throw new IllegalStateException(String.format("Cannot sample task %s. " + "The task is not running.", task.getExecutionId())).     }     if (numSamples > 1) {         scheduledExecutor.schedule(() -> requestStackTraceSample(task, numSamples - 1, delayBetweenSamples, maxStackTraceDepth, currentTraces, resultFuture), delayBetweenSamples.getSize(), delayBetweenSamples.getUnit()).     } else {         resultFuture.complete(currentTraces).     }     return resultFuture. }
false;private;2;8;;private Optional<StackTraceElement[]> getStackTrace(final StackTraceSampleableTask task, final int maxStackTraceDepth) {     if (!task.isRunning()) {         return Optional.empty().     }     final StackTraceElement[] stackTrace = task.getStackTrace().     return Optional.of(truncateStackTrace(stackTrace, maxStackTraceDepth)). }
false;private;2;6;;private StackTraceElement[] truncateStackTrace(final StackTraceElement[] stackTrace, final int maxStackTraceDepth) {     if (maxStackTraceDepth > 0) {         return Arrays.copyOfRange(stackTrace, 0, Math.min(maxStackTraceDepth, stackTrace.length)).     }     return stackTrace. }
