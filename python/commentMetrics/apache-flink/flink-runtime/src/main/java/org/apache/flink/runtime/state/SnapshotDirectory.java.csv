commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Nonnull public Path getDirectory() {     return directory. }
false;public;0;3;;public boolean mkdirs() throws IOException {     return fileSystem.mkdirs(directory). }
false;public;0;4;;@Nonnull public FileSystem getFileSystem() {     return fileSystem. }
false;public;0;3;;public boolean exists() throws IOException {     return fileSystem.exists(directory). }
true;public;0;3;/**  * List the statuses of the files/directories in the snapshot directory.  *  * @return the statuses of the files/directories in the given path.  * @throws IOException if there is a problem creating the file statuses.  */ ;/**  * List the statuses of the files/directories in the snapshot directory.  *  * @return the statuses of the files/directories in the given path.  * @throws IOException if there is a problem creating the file statuses.  */ public FileStatus[] listStatus() throws IOException {     return fileSystem.listStatus(directory). }
true;public;0;3;/**  * Calling this method will attempt delete the underlying snapshot directory recursively, if the state is  * "ongoing". In this case, the state will be set to "deleted" as a result of this call.  *  * @return <code>true</code> if delete is successful, <code>false</code> otherwise.  * @throws IOException if an exception happens during the delete.  */ ;/**  * Calling this method will attempt delete the underlying snapshot directory recursively, if the state is  * "ongoing". In this case, the state will be set to "deleted" as a result of this call.  *  * @return <code>true</code> if delete is successful, <code>false</code> otherwise.  * @throws IOException if an exception happens during the delete.  */ public boolean cleanup() throws IOException {     return !state.compareAndSet(State.ONGOING, State.DELETED) || fileSystem.delete(directory, true). }
true;public;0;3;/**  * Returns <code>true</code> if the snapshot is marked as completed.  */ ;/**  * Returns <code>true</code> if the snapshot is marked as completed.  */ public boolean isSnapshotCompleted() {     return State.COMPLETED == state.get(). }
true;public,abstract;0;2;/**  * Calling this method completes the snapshot for this snapshot directory, if possible, and creates a corresponding  * {@link DirectoryStateHandle} that points to the snapshot directory. Calling this method can change the  * lifecycle state from ONGOING to COMPLETED if the directory should no longer deleted in {@link #cleanup()}. This  * method can return Can return <code>true</code> if the directory is temporary and should therefore not be  * referenced in a handle.  *  * @return A directory state handle that points to the snapshot directory. Can return <code>true</code> if the  * directory is temporary and should therefore not be referenced in a handle.  * @throws IOException if the state of this snapshot directory object is different from "ongoing".  */ ;/**  * Calling this method completes the snapshot for this snapshot directory, if possible, and creates a corresponding  * {@link DirectoryStateHandle} that points to the snapshot directory. Calling this method can change the  * lifecycle state from ONGOING to COMPLETED if the directory should no longer deleted in {@link #cleanup()}. This  * method can return Can return <code>true</code> if the directory is temporary and should therefore not be  * referenced in a handle.  *  * @return A directory state handle that points to the snapshot directory. Can return <code>true</code> if the  * directory is temporary and should therefore not be referenced in a handle.  * @throws IOException if the state of this snapshot directory object is different from "ongoing".  */ @Nullable public abstract DirectoryStateHandle completeSnapshotAndGetHandle() throws IOException.
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     SnapshotDirectory that = (SnapshotDirectory) o.     return directory.equals(that.directory). }
false;public;0;4;;@Override public int hashCode() {     return directory.hashCode(). }
false;public;0;7;;@Override public String toString() {     return "SnapshotDirectory{" + "directory=" + directory + ", state=" + state + '}'. }
true;public,static;1;3;/**  * Creates a temporary snapshot directory for the given path. This will always return "null" as result of  * {@link #completeSnapshotAndGetHandle()} and always attempt to delete the underlying directory in  * {@link #cleanup()}.  */ ;/**  * Creates a temporary snapshot directory for the given path. This will always return "null" as result of  * {@link #completeSnapshotAndGetHandle()} and always attempt to delete the underlying directory in  * {@link #cleanup()}.  */ public static SnapshotDirectory temporary(@Nonnull Path directory) throws IOException {     return new TemporarySnapshotDirectory(directory). }
true;public,static;1;3;/**  * Creates a permanent snapshot directory for the given path, which will not delete the underlying directory in  * {@link #cleanup()} after {@link #completeSnapshotAndGetHandle()} was called.  */ ;/**  * Creates a permanent snapshot directory for the given path, which will not delete the underlying directory in  * {@link #cleanup()} after {@link #completeSnapshotAndGetHandle()} was called.  */ public static SnapshotDirectory permanent(@Nonnull Path directory) throws IOException {     return new PermanentSnapshotDirectory(directory). }
false;public;0;4;;@Override public DirectoryStateHandle completeSnapshotAndGetHandle() {     // We return null so that directory it is not referenced by a state handle.     return null. }
false;public;0;8;;@Override public DirectoryStateHandle completeSnapshotAndGetHandle() throws IOException {     if (State.COMPLETED == state.get() || state.compareAndSet(State.ONGOING, State.COMPLETED)) {         return new DirectoryStateHandle(directory).     } else {         throw new IOException("Expected state " + State.ONGOING + " but found state " + state.get()).     } }
