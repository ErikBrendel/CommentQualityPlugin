commented;modifiers;parameterAmount;loc;comment;code
true;private;0;4;/**  * Convenience method to throw an {@link EOFException}.  *  * @throws EOFException  *         thrown to indicate the underlying input stream did not provide as much data as expected  */ ;/**  * Convenience method to throw an {@link EOFException}.  *  * @throws EOFException  *         thrown to indicate the underlying input stream did not provide as much data as expected  */ private void throwEOFException() throws EOFException {     throw new EOFException(String.format("Expected to read %d more bytes from stream", this.bytesToReceive - this.bytesReceived)). }
false;public;0;27;;@Override public int read() throws IOException {     if (this.bytesReceived == this.bytesToReceive) {         return -1.     }     final int read = this.wrappedInputStream.read().     if (read < 0) {         throwEOFException().     }     ++this.bytesReceived.     if (this.md != null) {         this.md.update((byte) read).         if (this.bytesReceived == this.bytesToReceive) {             final byte[] computedKey = this.md.digest().             if (!Arrays.equals(computedKey, this.blobKey.getHash())) {                 this.wrappedOutputStream.write(RETURN_ERROR).                 throw new IOException("Detected data corruption during transfer").             }             this.wrappedOutputStream.write(RETURN_OKAY).         }     }     return read. }
false;public;1;4;;@Override public int read(byte[] b) throws IOException {     return read(b, 0, b.length). }
false;public;3;30;;@Override public int read(byte[] b, int off, int len) throws IOException {     final int bytesMissing = this.bytesToReceive - this.bytesReceived.     if (bytesMissing == 0) {         return -1.     }     final int maxRecv = Math.min(len, bytesMissing).     final int read = this.wrappedInputStream.read(b, off, maxRecv).     if (read < 0) {         throwEOFException().     }     this.bytesReceived += read.     if (this.md != null) {         this.md.update(b, off, read).         if (this.bytesReceived == this.bytesToReceive) {             final byte[] computedKey = this.md.digest().             if (!Arrays.equals(computedKey, this.blobKey.getHash())) {                 this.wrappedOutputStream.write(RETURN_ERROR).                 throw new IOException("Detected data corruption during transfer").             }             this.wrappedOutputStream.write(RETURN_OKAY).         }     }     return read. }
false;public;1;4;;@Override public long skip(long n) throws IOException {     return 0L. }
false;public;0;4;;@Override public int available() throws IOException {     return this.bytesToReceive - this.bytesReceived. }
false;public;0;4;;@Override public void close() throws IOException { // This method does not do anything as the wrapped input stream may be used for multiple get operations. }
false;public;1;3;;public void mark(final int readlimit) { // Do not do anything here }
false;public;0;4;;@Override public void reset() throws IOException {     throw new IOException("mark/reset not supported"). }
false;public;0;4;;@Override public boolean markSupported() {     return false. }
