commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void setup(TaskContext<FlatMapFunction<IT, OT>, OT> context) {     this.taskContext = context.     this.running = true. }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 1. }
false;public;0;6;;@Override public Class<FlatMapFunction<IT, OT>> getStubType() {     @SuppressWarnings("unchecked")     final Class<FlatMapFunction<IT, OT>> clazz = (Class<FlatMapFunction<IT, OT>>) (Class<?>) FlatMapFunction.class.     return clazz. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 0. }
false;public;0;9;;@Override public void prepare() {     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     this.objectReuseEnabled = executionConfig.isObjectReuseEnabled().     if (LOG.isDebugEnabled()) {         LOG.debug("FlatMapDriver object reuse: " + (this.objectReuseEnabled ? "ENABLED" : "DISABLED") + ".").     } }
false;public;0;26;;@Override public void run() throws Exception {     final Counter numRecordsIn = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsInCounter().     final Counter numRecordsOut = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsOutCounter().     // cache references on the stack     final MutableObjectIterator<IT> input = this.taskContext.getInput(0).     final FlatMapFunction<IT, OT> function = this.taskContext.getStub().     final Collector<OT> output = new CountingCollector<>(this.taskContext.getOutputCollector(), numRecordsOut).     if (objectReuseEnabled) {         IT record = this.taskContext.<IT>getInputSerializer(0).getSerializer().createInstance().         while (this.running && ((record = input.next(record)) != null)) {             numRecordsIn.inc().             function.flatMap(record, output).         }     } else {         IT record.         while (this.running && ((record = input.next()) != null)) {             numRecordsIn.inc().             function.flatMap(record, output).         }     } }
false;public;0;4;;@Override public void cleanup() { // mappers need no cleanup, since no strategies are used. }
false;public;0;4;;@Override public void cancel() {     this.running = false. }
