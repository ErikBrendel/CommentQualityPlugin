commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Creates a {@link StateSerializerProvider} for restored state from the previous serializer's snapshot.  *  * <p>Once a new serializer is registered for the state, it should be provided via  * the {@link #registerNewSerializerForRestoredState(TypeSerializer)} method.  *  * @param stateSerializerSnapshot the previous serializer's snapshot.  * @param <T> the type of the state.  *  * @return a new {@link StateSerializerProvider}.  */ ;/**  * Creates a {@link StateSerializerProvider} for restored state from the previous serializer's snapshot.  *  * <p>Once a new serializer is registered for the state, it should be provided via  * the {@link #registerNewSerializerForRestoredState(TypeSerializer)} method.  *  * @param stateSerializerSnapshot the previous serializer's snapshot.  * @param <T> the type of the state.  *  * @return a new {@link StateSerializerProvider}.  */ public static <T> StateSerializerProvider<T> fromPreviousSerializerSnapshot(TypeSerializerSnapshot<T> stateSerializerSnapshot) {     return new LazilyRegisteredStateSerializerProvider<>(stateSerializerSnapshot). }
true;public,static;1;3;/**  * Creates a {@link StateSerializerProvider} from the registered state serializer.  *  * <p>If the state is a restored one, and the previous serializer's snapshot is  * obtained later on, is should be supplied via the  * {@link #setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot)} method.  *  * @param registeredStateSerializer the new state's registered serializer.  * @param <T> the type of the state.  *  * @return a new {@link StateSerializerProvider}.  */ ;/**  * Creates a {@link StateSerializerProvider} from the registered state serializer.  *  * <p>If the state is a restored one, and the previous serializer's snapshot is  * obtained later on, is should be supplied via the  * {@link #setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot)} method.  *  * @param registeredStateSerializer the new state's registered serializer.  * @param <T> the type of the state.  *  * @return a new {@link StateSerializerProvider}.  */ public static <T> StateSerializerProvider<T> fromNewRegisteredSerializer(TypeSerializer<T> registeredStateSerializer) {     return new EagerlyRegisteredStateSerializerProvider<>(registeredStateSerializer). }
true;public,final;0;15;/**  * Gets the serializer that recognizes the current serialization schema of the state.  * This is the serializer that should be used for regular state serialization and  * deserialization after state has been restored.  *  * <p>If this provider was created from a restored state's serializer snapshot, while a  * new serializer (with a new schema) was not registered for the state (i.e., because  * the state was never accessed after it was restored), then the schema of state remains  * identical. Therefore, in this case, it is guaranteed that the serializer returned by  * this method is the same as the one returned by {@link #previousSchemaSerializer()}.  *  * <p>If this provider was created from a serializer instance, then this always returns the  * that same serializer instance. If later on a snapshot of the previous serializer is supplied  * via {@link #setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot)}, then  * the initially supplied serializer instance will be checked for compatibility.  *  * @return a serializer that reads and writes in the current schema of the state.  */ ;/**  * Gets the serializer that recognizes the current serialization schema of the state.  * This is the serializer that should be used for regular state serialization and  * deserialization after state has been restored.  *  * <p>If this provider was created from a restored state's serializer snapshot, while a  * new serializer (with a new schema) was not registered for the state (i.e., because  * the state was never accessed after it was restored), then the schema of state remains  * identical. Therefore, in this case, it is guaranteed that the serializer returned by  * this method is the same as the one returned by {@link #previousSchemaSerializer()}.  *  * <p>If this provider was created from a serializer instance, then this always returns the  * that same serializer instance. If later on a snapshot of the previous serializer is supplied  * via {@link #setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot)}, then  * the initially supplied serializer instance will be checked for compatibility.  *  * @return a serializer that reads and writes in the current schema of the state.  */ @Nonnull public final TypeSerializer<T> currentSchemaSerializer() {     if (registeredSerializer != null) {         checkState(!isRegisteredWithIncompatibleSerializer, "Unable to provide a serializer with the current schema, because the restored state was " + "registered with a new serializer that has incompatible schema.").         return registeredSerializer.     }     // we can just use the restore serializer to read / write the state.     return previousSchemaSerializer(). }
true;public,final;0;14;/**  * Gets the serializer that recognizes the previous serialization schema of the state.  * This is the serializer that should be used for restoring the state, i.e. when the state  * is still in the previous serialization schema.  *  * <p>This method only returns a serializer if this provider has the previous serializer's  * snapshot. Otherwise, trying to access the previous schema serializer will fail  * with an exception.  *  * @return a serializer that reads and writes in the previous schema of the state.  */ ;/**  * Gets the serializer that recognizes the previous serialization schema of the state.  * This is the serializer that should be used for restoring the state, i.e. when the state  * is still in the previous serialization schema.  *  * <p>This method only returns a serializer if this provider has the previous serializer's  * snapshot. Otherwise, trying to access the previous schema serializer will fail  * with an exception.  *  * @return a serializer that reads and writes in the previous schema of the state.  */ @Nonnull public final TypeSerializer<T> previousSchemaSerializer() {     if (cachedRestoredSerializer != null) {         return cachedRestoredSerializer.     }     if (previousSerializerSnapshot == null) {         throw new UnsupportedOperationException("This provider does not contain the state's previous serializer's snapshot. Cannot provider a serializer for previous schema.").     }     this.cachedRestoredSerializer = previousSerializerSnapshot.restoreSerializer().     return cachedRestoredSerializer. }
true;public,abstract;1;2;/**  * For restored state, register a new serializer that potentially has a new serialization schema.  *  * <p>Users are allowed to register serializers for state only once. Therefore, this method  * is irrelevant if this provider was created with a serializer instance, since a state serializer had  * been registered already.  *  * <p>For the case where this provider was created from a serializer snapshot, then this method should  * be called at most once. The new serializer will be checked for its schema compatibility with the  * previous serializer's schema, and returned to the caller. The caller is responsible for  * checking the result and react appropriately to it, as follows:  * <ul>  *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAsIs()}: nothing needs to be done.  *     {@link #currentSchemaSerializer()} now returns the newly registered serializer.</li>  *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAfterMigration()} ()}: state needs to be  *     migrated before the serializer returned by {@link #currentSchemaSerializer()} can be used.  *     The migration should be performed by reading the state with {@link #previousSchemaSerializer()},  *     and then writing it again with {@link #currentSchemaSerializer()}.</li>  *     <li>{@link TypeSerializerSchemaCompatibility#isIncompatible()}: the registered serializer is  *     incompatible. {@link #currentSchemaSerializer()} can no longer return a serializer for  *     the state, and therefore this provider shouldn't be used anymore.</li>  * </ul>  *  * @return the schema compatibility of the new registered serializer, with respect to the previous serializer.  */ ;/**  * For restored state, register a new serializer that potentially has a new serialization schema.  *  * <p>Users are allowed to register serializers for state only once. Therefore, this method  * is irrelevant if this provider was created with a serializer instance, since a state serializer had  * been registered already.  *  * <p>For the case where this provider was created from a serializer snapshot, then this method should  * be called at most once. The new serializer will be checked for its schema compatibility with the  * previous serializer's schema, and returned to the caller. The caller is responsible for  * checking the result and react appropriately to it, as follows:  * <ul>  *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAsIs()}: nothing needs to be done.  *     {@link #currentSchemaSerializer()} now returns the newly registered serializer.</li>  *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAfterMigration()} ()}: state needs to be  *     migrated before the serializer returned by {@link #currentSchemaSerializer()} can be used.  *     The migration should be performed by reading the state with {@link #previousSchemaSerializer()},  *     and then writing it again with {@link #currentSchemaSerializer()}.</li>  *     <li>{@link TypeSerializerSchemaCompatibility#isIncompatible()}: the registered serializer is  *     incompatible. {@link #currentSchemaSerializer()} can no longer return a serializer for  *     the state, and therefore this provider shouldn't be used anymore.</li>  * </ul>  *  * @return the schema compatibility of the new registered serializer, with respect to the previous serializer.  */ @Nonnull public abstract TypeSerializerSchemaCompatibility<T> registerNewSerializerForRestoredState(TypeSerializer<T> newSerializer).
true;public,abstract;1;2;/**  * For restored state, set the state's previous serializer's snapshot.  *  * <p>Users are allowed to set the previous serializer's snapshot once. Therefore, this method  * is irrelevant if this provider was created with a serializer snapshot, since the serializer  * snapshot had been set already.  *  * <p>For the case where this provider was created from a serializer instance, then this method should  * be called at most once. The initially registered state serializer will be checked for its  * schema compatibility with the previous serializer's schema, and returned to the caller.  * The caller is responsible for checking the result and react appropriately to it, as follows:  * <ul>  *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAsIs()}: nothing needs to be done.  *     {@link #currentSchemaSerializer()} remains to return the initially registered serializer.</li>  *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAfterMigration()} ()}: state needs to be  *     migrated before the serializer returned by {@link #currentSchemaSerializer()} can be used.  *     The migration should be performed by reading the state with {@link #previousSchemaSerializer()},  *     and then writing it again with {@link #currentSchemaSerializer()}.</li>  *     <li>{@link TypeSerializerSchemaCompatibility#isIncompatible()}: the registered serializer is  *     incompatible. {@link #currentSchemaSerializer()} can no longer return a serializer for  *     the state, and therefore this provider shouldn't be used anymore.</li>  * </ul>  *  * @param previousSerializerSnapshot the state's previous serializer's snapshot  *  * @return the schema compatibility of the initially registered serializer, with respect to the previous serializer.  */ ;/**  * For restored state, set the state's previous serializer's snapshot.  *  * <p>Users are allowed to set the previous serializer's snapshot once. Therefore, this method  * is irrelevant if this provider was created with a serializer snapshot, since the serializer  * snapshot had been set already.  *  * <p>For the case where this provider was created from a serializer instance, then this method should  * be called at most once. The initially registered state serializer will be checked for its  * schema compatibility with the previous serializer's schema, and returned to the caller.  * The caller is responsible for checking the result and react appropriately to it, as follows:  * <ul>  *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAsIs()}: nothing needs to be done.  *     {@link #currentSchemaSerializer()} remains to return the initially registered serializer.</li>  *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAfterMigration()} ()}: state needs to be  *     migrated before the serializer returned by {@link #currentSchemaSerializer()} can be used.  *     The migration should be performed by reading the state with {@link #previousSchemaSerializer()},  *     and then writing it again with {@link #currentSchemaSerializer()}.</li>  *     <li>{@link TypeSerializerSchemaCompatibility#isIncompatible()}: the registered serializer is  *     incompatible. {@link #currentSchemaSerializer()} can no longer return a serializer for  *     the state, and therefore this provider shouldn't be used anymore.</li>  * </ul>  *  * @param previousSerializerSnapshot the state's previous serializer's snapshot  *  * @return the schema compatibility of the initially registered serializer, with respect to the previous serializer.  */ @Nonnull public abstract TypeSerializerSchemaCompatibility<T> setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot<T> previousSerializerSnapshot).
true;protected,final;0;3;/**  * Invalidates access to the current schema serializer. This lets {@link #currentSchemaSerializer()}  * fail when invoked.  *  * <p>Access to the current schema serializer should be invalidated by the methods  * {@link #registerNewSerializerForRestoredState(TypeSerializer)} or  * {@link #setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot)}  * once the registered serializer is determined to be incompatible.  */ ;/**  * Invalidates access to the current schema serializer. This lets {@link #currentSchemaSerializer()}  * fail when invoked.  *  * <p>Access to the current schema serializer should be invalidated by the methods  * {@link #registerNewSerializerForRestoredState(TypeSerializer)} or  * {@link #setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot)}  * once the registered serializer is determined to be incompatible.  */ protected final void invalidateCurrentSchemaSerializerAccess() {     this.isRegisteredWithIncompatibleSerializer = true. }
false;public;1;20;;@Nonnull @Override @SuppressWarnings("ConstantConditions") public TypeSerializerSchemaCompatibility<T> registerNewSerializerForRestoredState(TypeSerializer<T> newSerializer) {     checkNotNull(newSerializer).     if (registeredSerializer != null) {         throw new UnsupportedOperationException("A serializer has already been registered for the state. re-registration is not allowed.").     }     TypeSerializerSchemaCompatibility<T> result = previousSerializerSnapshot.resolveSchemaCompatibility(newSerializer).     if (result.isIncompatible()) {         invalidateCurrentSchemaSerializerAccess().     }     if (result.isCompatibleWithReconfiguredSerializer()) {         this.registeredSerializer = result.getReconfiguredSerializer().     } else {         this.registeredSerializer = newSerializer.     }     return result. }
false;public;1;6;;@Nonnull @Override public TypeSerializerSchemaCompatibility<T> setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot<T> previousSerializerSnapshot) {     throw new UnsupportedOperationException("The snapshot of the state's previous serializer has already been set. cannot reset."). }
false;public;1;5;;@Nonnull @Override public TypeSerializerSchemaCompatibility<T> registerNewSerializerForRestoredState(TypeSerializer<T> newSerializer) {     throw new UnsupportedOperationException("A serializer has already been registered for the state. re-registration is not allowed."). }
false;public;1;19;;@Nonnull @Override public TypeSerializerSchemaCompatibility<T> setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot<T> previousSerializerSnapshot) {     checkNotNull(previousSerializerSnapshot).     if (this.previousSerializerSnapshot != null) {         throw new UnsupportedOperationException("The snapshot of the state's previous serializer has already been set. cannot reset.").     }     this.previousSerializerSnapshot = previousSerializerSnapshot.     TypeSerializerSchemaCompatibility<T> result = previousSerializerSnapshot.resolveSchemaCompatibility(registeredSerializer).     if (result.isIncompatible()) {         invalidateCurrentSchemaSerializerAccess().     }     if (result.isCompatibleWithReconfiguredSerializer()) {         this.registeredSerializer = result.getReconfiguredSerializer().     }     return result. }
