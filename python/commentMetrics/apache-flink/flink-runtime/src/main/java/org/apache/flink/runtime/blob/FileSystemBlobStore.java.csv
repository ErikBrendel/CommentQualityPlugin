commented;modifiers;parameterAmount;loc;comment;code
false;public;3;4;;// - Put ------------------------------------------------------------------ @Override public boolean put(File localFile, JobID jobId, BlobKey blobKey) throws IOException {     return put(localFile, BlobUtils.getStorageLocationPath(basePath, jobId, blobKey)). }
false;private;2;7;;private boolean put(File fromFile, String toBlobPath) throws IOException {     try (OutputStream os = fileSystem.create(new Path(toBlobPath), FileSystem.WriteMode.OVERWRITE)) {         LOG.debug("Copying from {} to {}.", fromFile, toBlobPath).         Files.copy(fromFile, os).     }     return true. }
false;public;3;4;;// - Get ------------------------------------------------------------------ @Override public boolean get(JobID jobId, BlobKey blobKey, File localFile) throws IOException {     return get(BlobUtils.getStorageLocationPath(basePath, jobId, blobKey), localFile, blobKey). }
false;private;3;48;;private boolean get(String fromBlobPath, File toFile, BlobKey blobKey) throws IOException {     checkNotNull(fromBlobPath, "Blob path").     checkNotNull(toFile, "File").     checkNotNull(blobKey, "Blob key").     if (!toFile.exists() && !toFile.createNewFile()) {         throw new IOException("Failed to create target file to copy to").     }     final Path fromPath = new Path(fromBlobPath).     MessageDigest md = BlobUtils.createMessageDigest().     // like IOUtils#BLOCKSIZE, for chunked file copying     final int buffSize = 4096.     boolean success = false.     try (InputStream is = fileSystem.open(fromPath).         FileOutputStream fos = new FileOutputStream(toFile)) {         LOG.debug("Copying from {} to {}.", fromBlobPath, toFile).         // not using IOUtils.copyBytes(is, fos) here to be able to create a hash on-the-fly         final byte[] buf = new byte[buffSize].         int bytesRead = is.read(buf).         while (bytesRead >= 0) {             fos.write(buf, 0, bytesRead).             md.update(buf, 0, bytesRead).             bytesRead = is.read(buf).         }         // verify that file contents are correct         final byte[] computedKey = md.digest().         if (!Arrays.equals(computedKey, blobKey.getHash())) {             throw new IOException("Detected data corruption during transfer").         }         success = true.     } finally {         // outside code relies on a correct file as long as it exists         if (!success) {             try {                 toFile.delete().             } catch (Throwable ignored) {             }         }     }     // success is always true here     return true. }
false;public;2;4;;// - Delete --------------------------------------------------------------- @Override public boolean delete(JobID jobId, BlobKey blobKey) {     return delete(BlobUtils.getStorageLocationPath(basePath, jobId, blobKey)). }
false;public;1;4;;@Override public boolean deleteAll(JobID jobId) {     return delete(BlobUtils.getStorageLocationPath(basePath, jobId)). }
false;private;1;21;;private boolean delete(String blobPath) {     try {         LOG.debug("Deleting {}.", blobPath).         Path path = new Path(blobPath).         boolean result = fileSystem.delete(path, true).         // fail (and be ignored) when some files still exist.         try {             fileSystem.delete(path.getParent(), false).             fileSystem.delete(new Path(basePath), false).         } catch (IOException ignored) {         }         return result.     } catch (Exception e) {         LOG.warn("Failed to delete blob at " + blobPath).         return false.     } }
false;public;0;11;;@Override public void closeAndCleanupAllData() {     try {         LOG.debug("Cleaning up {}.", basePath).         fileSystem.delete(new Path(basePath), true).     } catch (Exception e) {         LOG.error("Failed to clean up recovery directory.", e).     } }
false;public;0;4;;@Override public void close() throws IOException { // nothing to do for the FileSystemBlobStore }
