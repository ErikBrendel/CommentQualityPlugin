commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;14;;@Override protected JobVertexTaskManagersInfo handleRequest(HandlerRequest<EmptyRequestBody, JobVertexMessageParameters> request, AccessExecutionGraph executionGraph) throws RestHandlerException {     JobID jobID = request.getPathParameter(JobIDPathParameter.class).     JobVertexID jobVertexID = request.getPathParameter(JobVertexIdPathParameter.class).     AccessExecutionJobVertex jobVertex = executionGraph.getJobVertex(jobVertexID).     if (jobVertex == null) {         throw new NotFoundException(String.format("JobVertex %s not found", jobVertexID)).     }     return createJobVertexTaskManagersInfo(jobVertex, jobID, metricFetcher). }
false;public;1;13;;@Override public Collection<ArchivedJson> archiveJsonWithPath(AccessExecutionGraph graph) throws IOException {     Collection<? extends AccessExecutionJobVertex> vertices = graph.getAllVertices().values().     List<ArchivedJson> archive = new ArrayList<>(vertices.size()).     for (AccessExecutionJobVertex task : vertices) {         ResponseBody json = createJobVertexTaskManagersInfo(task, graph.getJobID(), null).         String path = getMessageHeaders().getTargetRestEndpointURL().replace(':' + JobIDPathParameter.KEY, graph.getJobID().toString()).replace(':' + JobVertexIdPathParameter.KEY, task.getJobVertexId().toString()).         archive.add(new ArchivedJson(path, json)).     }     return archive. }
false;private,static;3;93;;private static JobVertexTaskManagersInfo createJobVertexTaskManagersInfo(AccessExecutionJobVertex jobVertex, JobID jobID, @Nullable MetricFetcher metricFetcher) {     // Build a map that groups tasks by TaskManager     Map<String, List<AccessExecutionVertex>> taskManagerVertices = new HashMap<>().     for (AccessExecutionVertex vertex : jobVertex.getTaskVertices()) {         TaskManagerLocation location = vertex.getCurrentAssignedResourceLocation().         String taskManager = location == null ? "(unassigned)" : location.getHostname() + ':' + location.dataPort().         List<AccessExecutionVertex> vertices = taskManagerVertices.computeIfAbsent(taskManager, ignored -> new ArrayList<>(4)).         vertices.add(vertex).     }     final long now = System.currentTimeMillis().     List<JobVertexTaskManagersInfo.TaskManagersInfo> taskManagersInfoList = new ArrayList<>(4).     for (Map.Entry<String, List<AccessExecutionVertex>> entry : taskManagerVertices.entrySet()) {         String host = entry.getKey().         List<AccessExecutionVertex> taskVertices = entry.getValue().         int[] tasksPerState = new int[ExecutionState.values().length].         long startTime = Long.MAX_VALUE.         long endTime = 0.         boolean allFinished = true.         MutableIOMetrics counts = new MutableIOMetrics().         for (AccessExecutionVertex vertex : taskVertices) {             final ExecutionState state = vertex.getExecutionState().             tasksPerState[state.ordinal()]++.             // take the earliest start time             long started = vertex.getStateTimestamp(ExecutionState.DEPLOYING).             if (started > 0) {                 startTime = Math.min(startTime, started).             }             allFinished &= state.isTerminal().             endTime = Math.max(endTime, vertex.getStateTimestamp(state)).             counts.addIOMetrics(vertex.getCurrentExecutionAttempt(), metricFetcher, jobID.toString(), jobVertex.getJobVertexId().toString()).         }         long duration.         if (startTime < Long.MAX_VALUE) {             if (allFinished) {                 duration = endTime - startTime.             } else {                 endTime = -1L.                 duration = now - startTime.             }         } else {             startTime = -1L.             endTime = -1L.             duration = -1L.         }         ExecutionState jobVertexState = ExecutionJobVertex.getAggregateJobVertexState(tasksPerState, taskVertices.size()).         final IOMetricsInfo jobVertexMetrics = new IOMetricsInfo(counts.getNumBytesInLocal() + counts.getNumBytesInRemote(), counts.isNumBytesInLocalComplete() && counts.isNumBytesInRemoteComplete(), counts.getNumBytesOut(), counts.isNumBytesOutComplete(), counts.getNumRecordsIn(), counts.isNumRecordsInComplete(), counts.getNumRecordsOut(), counts.isNumRecordsOutComplete()).         Map<ExecutionState, Integer> statusCounts = new HashMap<>(ExecutionState.values().length).         for (ExecutionState state : ExecutionState.values()) {             statusCounts.put(state, tasksPerState[state.ordinal()]).         }         taskManagersInfoList.add(new JobVertexTaskManagersInfo.TaskManagersInfo(host, jobVertexState, startTime, endTime, duration, jobVertexMetrics, statusCounts)).     }     return new JobVertexTaskManagersInfo(jobVertex.getJobVertexId(), jobVertex.getName(), now, taskManagersInfoList). }
