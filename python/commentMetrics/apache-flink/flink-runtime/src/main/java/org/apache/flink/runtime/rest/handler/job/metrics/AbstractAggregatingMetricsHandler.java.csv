commented;modifiers;parameterAmount;loc;comment;code
false;abstract;2;2;;@Nonnull abstract Collection<? extends MetricStore.ComponentMetricStore> getStores(MetricStore store, HandlerRequest<EmptyRequestBody, P> request).
false;protected;2;61;;@Override protected CompletableFuture<AggregatedMetricsResponseBody> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, P> request, @Nonnull RestfulGateway gateway) throws RestHandlerException {     return CompletableFuture.supplyAsync(() -> {         try {             fetcher.update().             List<String> requestedMetrics = request.getQueryParameter(MetricsFilterParameter.class).             List<MetricsAggregationParameter.AggregationMode> requestedAggregations = request.getQueryParameter(MetricsAggregationParameter.class).             MetricStore store = fetcher.getMetricStore().             Collection<? extends MetricStore.ComponentMetricStore> stores = getStores(store, request).             if (requestedMetrics.isEmpty()) {                 Collection<String> list = getAvailableMetrics(stores).                 return new AggregatedMetricsResponseBody(list.stream().map(AggregatedMetric::new).collect(Collectors.toList())).             }             DoubleAccumulator.DoubleMinimumFactory minimumFactory = null.             DoubleAccumulator.DoubleMaximumFactory maximumFactory = null.             DoubleAccumulator.DoubleAverageFactory averageFactory = null.             DoubleAccumulator.DoubleSumFactory sumFactory = null.             // by default we return all aggregations             if (requestedAggregations.isEmpty()) {                 minimumFactory = DoubleAccumulator.DoubleMinimumFactory.get().                 maximumFactory = DoubleAccumulator.DoubleMaximumFactory.get().                 averageFactory = DoubleAccumulator.DoubleAverageFactory.get().                 sumFactory = DoubleAccumulator.DoubleSumFactory.get().             } else {                 for (MetricsAggregationParameter.AggregationMode aggregation : requestedAggregations) {                     switch(aggregation) {                         case MIN:                             minimumFactory = DoubleAccumulator.DoubleMinimumFactory.get().                             break.                         case MAX:                             maximumFactory = DoubleAccumulator.DoubleMaximumFactory.get().                             break.                         case AVG:                             averageFactory = DoubleAccumulator.DoubleAverageFactory.get().                             break.                         case SUM:                             sumFactory = DoubleAccumulator.DoubleSumFactory.get().                             break.                         default:                             log.warn("Unsupported aggregation specified: {}", aggregation).                     }                 }             }             MetricAccumulatorFactory metricAccumulatorFactory = new MetricAccumulatorFactory(minimumFactory, maximumFactory, averageFactory, sumFactory).             return getAggregatedMetricValues(stores, requestedMetrics, metricAccumulatorFactory).         } catch (Exception e) {             log.warn("Could not retrieve metrics.", e).             throw new CompletionException(new RestHandlerException("Could not retrieve metrics.", HttpResponseStatus.INTERNAL_SERVER_ERROR)).         }     }, executor). }
true;private,static;1;7;/**  * Returns a JSON string containing a list of all available metrics in the given stores. Effectively this method maps  * the union of all key-sets to JSON.  *  * @param stores metrics  * @return JSON string containing a list of all available metrics  */ ;/**  * Returns a JSON string containing a list of all available metrics in the given stores. Effectively this method maps  * the union of all key-sets to JSON.  *  * @param stores metrics  * @return JSON string containing a list of all available metrics  */ private static Collection<String> getAvailableMetrics(Collection<? extends MetricStore.ComponentMetricStore> stores) {     Set<String> uniqueMetrics = new HashSet<>(32).     for (MetricStore.ComponentMetricStore store : stores) {         uniqueMetrics.addAll(store.metrics.keySet()).     }     return uniqueMetrics. }
true;private;3;33;/**  * Extracts and aggregates all requested metrics from the given metric stores, and maps the result to a JSON string.  *  * @param stores available metrics  * @param requestedMetrics ids of requested metrics  * @param requestedAggregationsFactories requested aggregations  * @return JSON string containing the requested metrics  */ ;/**  * Extracts and aggregates all requested metrics from the given metric stores, and maps the result to a JSON string.  *  * @param stores available metrics  * @param requestedMetrics ids of requested metrics  * @param requestedAggregationsFactories requested aggregations  * @return JSON string containing the requested metrics  */ private AggregatedMetricsResponseBody getAggregatedMetricValues(Collection<? extends MetricStore.ComponentMetricStore> stores, List<String> requestedMetrics, MetricAccumulatorFactory requestedAggregationsFactories) {     Collection<AggregatedMetric> aggregatedMetrics = new ArrayList<>(requestedMetrics.size()).     for (String requestedMetric : requestedMetrics) {         final Collection<Double> values = new ArrayList<>(stores.size()).         try {             for (MetricStore.ComponentMetricStore store : stores) {                 String stringValue = store.metrics.get(requestedMetric).                 if (stringValue != null) {                     values.add(Double.valueOf(stringValue)).                 }             }         } catch (NumberFormatException nfe) {             log.warn("The metric {} is not numeric and can't be aggregated.", requestedMetric, nfe).             // metric is not numeric so we can't perform aggregations => ignore it             continue.         }         if (!values.isEmpty()) {             Iterator<Double> valuesIterator = values.iterator().             MetricAccumulator acc = requestedAggregationsFactories.get(requestedMetric, valuesIterator.next()).             valuesIterator.forEachRemaining(acc::add).             aggregatedMetrics.add(acc.get()).         } else {             return new AggregatedMetricsResponseBody(Collections.emptyList()).         }     }     return new AggregatedMetricsResponseBody(aggregatedMetrics). }
false;;2;9;;MetricAccumulator get(String metricName, double init) {     return new MetricAccumulator(metricName, minimumFactory == null ? null : minimumFactory.get(init), maximumFactory == null ? null : maximumFactory.get(init), averageFactory == null ? null : averageFactory.get(init), sumFactory == null ? null : sumFactory.get(init)). }
false;;1;14;;void add(double value) {     if (min != null) {         min.add(value).     }     if (max != null) {         max.add(value).     }     if (avg != null) {         avg.add(value).     }     if (sum != null) {         sum.add(value).     } }
false;;0;9;;AggregatedMetric get() {     return new AggregatedMetric(metricName, min == null ? null : min.getValue(), max == null ? null : max.getValue(), avg == null ? null : avg.getValue(), sum == null ? null : sum.getValue()). }
