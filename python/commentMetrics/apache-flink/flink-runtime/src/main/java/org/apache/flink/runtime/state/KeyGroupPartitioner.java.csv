commented;modifiers;parameterAmount;loc;comment;code
true;public;0;8;/**  * Partitions the data into key-groups and returns the result via {@link PartitioningResult}.  */ ;/**  * Partitions the data into key-groups and returns the result via {@link PartitioningResult}.  */ public StateSnapshot.StateKeyGroupWriter partitionByKeyGroup() {     if (computedResult == null) {         reportAllElementKeyGroups().         int outputNumberOfElements = buildHistogramByAccumulatingCounts().         executePartitioning(outputNumberOfElements).     }     return computedResult. }
true;protected;0;10;/**  * This method iterates over the input data and reports the key-group for each element.  */ ;/**  * This method iterates over the input data and reports the key-group for each element.  */ protected void reportAllElementKeyGroups() {     Preconditions.checkState(partitioningSource.length >= numberOfElements).     for (int i = 0. i < numberOfElements. ++i) {         int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(keyExtractorFunction.extractKeyFromElement(partitioningSource[i]), totalKeyGroups).         reportKeyGroupOfElementAtIndex(i, keyGroup).     } }
true;protected;2;5;/**  * This method reports in the bookkeeping data that the element at the given index belongs to the given key-group.  */ ;/**  * This method reports in the bookkeeping data that the element at the given index belongs to the given key-group.  */ protected void reportKeyGroupOfElementAtIndex(int index, int keyGroup) {     final int keyGroupIndex = keyGroup - firstKeyGroup.     elementKeyGroups[index] = keyGroupIndex.     ++counterHistogram[keyGroupIndex]. }
true;private;0;9;/**  * This method creates a histogram from the counts per key-group in {@link #counterHistogram}.  */ ;/**  * This method creates a histogram from the counts per key-group in {@link #counterHistogram}.  */ private int buildHistogramByAccumulatingCounts() {     int sum = 0.     for (int i = 0. i < counterHistogram.length. ++i) {         int currentSlotValue = counterHistogram[i].         counterHistogram[i] = sum.         sum += currentSlotValue.     }     return sum. }
false;private;1;15;;private void executePartitioning(int outputNumberOfElements) {     // We repartition the entries by their pre-computed key-groups, using the histogram values as write indexes     for (int inIdx = 0. inIdx < outputNumberOfElements. ++inIdx) {         int effectiveKgIdx = elementKeyGroups[inIdx].         int outIdx = counterHistogram[effectiveKgIdx]++.         partitioningDestination[outIdx] = partitioningSource[inIdx].     }     this.computedResult = new PartitioningResult<>(elementWriterFunction, firstKeyGroup, counterHistogram, partitioningDestination). }
false;private;1;5;;@Nonnegative private int getKeyGroupStartOffsetInclusive(int keyGroup) {     int idx = keyGroup - firstKeyGroup - 1.     return idx < 0 ? 0 : keyGroupOffsets[idx]. }
false;private;1;4;;@Nonnegative private int getKeyGroupEndOffsetExclusive(int keyGroup) {     return keyGroupOffsets[keyGroup - firstKeyGroup]. }
false;public;2;14;;@Override public void writeStateInKeyGroup(@Nonnull DataOutputView dov, int keyGroupId) throws IOException {     int startOffset = getKeyGroupStartOffsetInclusive(keyGroupId).     int endOffset = getKeyGroupEndOffsetExclusive(keyGroupId).     // write number of mappings in key-group     dov.writeInt(endOffset - startOffset).     // write mappings     for (int i = startOffset. i < endOffset. ++i) {         elementWriterFunction.writeElement(partitionedElements[i], dov).     } }
false;public,static;2;5;;public static <T> StateSnapshotKeyGroupReader createKeyGroupPartitionReader(@Nonnull ElementReaderFunction<T> readerFunction, @Nonnull KeyGroupElementsConsumer<T> elementConsumer) {     return new PartitioningResultKeyGroupReader<>(readerFunction, elementConsumer). }
false;public;2;8;;@Override public void readMappingsInKeyGroup(@Nonnull DataInputView in, @Nonnegative int keyGroupId) throws IOException {     int numElements = in.readInt().     for (int i = 0. i < numElements. i++) {         T element = readerFunction.readElement(in).         elementConsumer.consume(element, keyGroupId).     } }
true;;2;1;/**  * This method defines how to write a single element to the output.  *  * @param element the element to be written.  * @param dov     the output view to write the element.  * @throws IOException on write-related problems.  */ ;/**  * This method defines how to write a single element to the output.  *  * @param element the element to be written.  * @param dov     the output view to write the element.  * @throws IOException on write-related problems.  */ void writeElement(@Nonnull T element, @Nonnull DataOutputView dov) throws IOException.
false;;1;2;;@Nonnull T readElement(@Nonnull DataInputView div) throws IOException.
false;;2;1;;void consume(@Nonnull T element, @Nonnegative int keyGroupId) throws IOException.
