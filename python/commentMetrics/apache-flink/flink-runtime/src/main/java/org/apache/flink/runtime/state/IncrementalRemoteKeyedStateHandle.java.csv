commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public KeyGroupRange getKeyGroupRange() {     return keyGroupRange. }
false;public;0;4;;@Override public long getCheckpointId() {     return checkpointId. }
false;public;0;3;;public Map<StateHandleID, StreamStateHandle> getSharedState() {     return sharedState. }
false;public;0;3;;public Map<StateHandleID, StreamStateHandle> getPrivateState() {     return privateState. }
false;public;0;3;;public StreamStateHandle getMetaStateHandle() {     return metaStateHandle. }
false;public;0;4;;@Nonnull public UUID getBackendIdentifier() {     return backendIdentifier. }
false;public;0;5;;@Nonnull @Override public Set<StateHandleID> getSharedStateHandleIDs() {     return getSharedState().keySet(). }
false;public;0;3;;public SharedStateRegistry getSharedStateRegistry() {     return sharedStateRegistry. }
false;public;1;5;;@Override public KeyedStateHandle getIntersection(KeyGroupRange keyGroupRange) {     return KeyGroupRange.EMPTY_KEY_GROUP_RANGE.equals(this.keyGroupRange.getIntersection(keyGroupRange)) ? null : this. }
false;public;0;42;;@Override public void discardState() throws Exception {     SharedStateRegistry registry = this.sharedStateRegistry.     final boolean isRegistered = (registry != null).     LOG.trace("Discarding IncrementalRemoteKeyedStateHandle (registered = {}) for checkpoint {} from backend with id {}.", isRegistered, checkpointId, backendIdentifier).     try {         metaStateHandle.discardState().     } catch (Exception e) {         LOG.warn("Could not properly discard meta data.", e).     }     try {         StateUtil.bestEffortDiscardAllStateObjects(privateState.values()).     } catch (Exception e) {         LOG.warn("Could not properly discard misc file states.", e).     }     // are only placeholders at this point (disposing them is a NOP).     if (isRegistered) {         // from the registry.         for (StateHandleID stateHandleID : sharedState.keySet()) {             registry.unregisterReference(createSharedStateRegistryKeyFromFileName(stateHandleID)).         }     } else {         // Otherwise, we assume to own those handles and dispose them directly.         try {             StateUtil.bestEffortDiscardAllStateObjects(sharedState.values()).         } catch (Exception e) {             LOG.warn("Could not properly discard new sst file states.", e).         }     } }
false;public;0;14;;@Override public long getStateSize() {     long size = StateUtil.getStateSize(metaStateHandle).     for (StreamStateHandle sharedStateHandle : sharedState.values()) {         size += sharedStateHandle.getStateSize().     }     for (StreamStateHandle privateStateHandle : privateState.values()) {         size += privateStateHandle.getStateSize().     }     return size. }
false;public;1;40;;@Override public void registerSharedStates(SharedStateRegistry stateRegistry) {     // This is a quick check to avoid that we register twice with the same registry. However, the code allows to     // register again with a different registry. The implication is that ownership is transferred to this new     // registry. This should only happen in case of a restart, when the CheckpointCoordinator creates a new     // SharedStateRegistry for the current attempt and the old registry becomes meaningless. We also assume that     // an old registry object from a previous run is due to be GCed and will never be used for registration again.     Preconditions.checkState(sharedStateRegistry != stateRegistry, "The state handle has already registered its shared states to the given registry.").     sharedStateRegistry = Preconditions.checkNotNull(stateRegistry).     LOG.trace("Registering IncrementalRemoteKeyedStateHandle for checkpoint {} from backend with id {}.", checkpointId, backendIdentifier).     for (Map.Entry<StateHandleID, StreamStateHandle> sharedStateHandle : sharedState.entrySet()) {         SharedStateRegistryKey registryKey = createSharedStateRegistryKeyFromFileName(sharedStateHandle.getKey()).         SharedStateRegistry.Result result = stateRegistry.registerReference(registryKey, sharedStateHandle.getValue()).         // This step consolidates our shared handles with the registry, which does two things:         //          // 1) Replace placeholder state handle with already registered, actual state handles.         //          // 2) Deduplicate re-uploads of incremental state due to missing confirmations about         // completed checkpoints.         //          // This prevents the following problem:         // A previous checkpoint n has already registered the state. This can happen if a         // following checkpoint (n + x) wants to reference the same state before the backend got         // notified that checkpoint n completed. In this case, the shared registry did         // deduplication and returns the previous reference.         sharedStateHandle.setValue(result.getReference()).     } }
true;public;1;4;/**  * Create a unique key to register one of our shared state handles.  */ ;/**  * Create a unique key to register one of our shared state handles.  */ @VisibleForTesting public SharedStateRegistryKey createSharedStateRegistryKeyFromFileName(StateHandleID shId) {     return new SharedStateRegistryKey(String.valueOf(backendIdentifier) + '-' + keyGroupRange, shId). }
true;public;1;29;/**  * This method is should only be called in tests! This should never serve as key in a hash map.  */ ;/**  * This method is should only be called in tests! This should never serve as key in a hash map.  */ @VisibleForTesting @Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     IncrementalRemoteKeyedStateHandle that = (IncrementalRemoteKeyedStateHandle) o.     if (getCheckpointId() != that.getCheckpointId()) {         return false.     }     if (!getBackendIdentifier().equals(that.getBackendIdentifier())) {         return false.     }     if (!getKeyGroupRange().equals(that.getKeyGroupRange())) {         return false.     }     if (!getSharedState().equals(that.getSharedState())) {         return false.     }     if (!getPrivateState().equals(that.getPrivateState())) {         return false.     }     return getMetaStateHandle().equals(that.getMetaStateHandle()). }
true;public;0;11;/**  * This method should only be called in tests! This should never serve as key in a hash map.  */ ;/**  * This method should only be called in tests! This should never serve as key in a hash map.  */ @VisibleForTesting @Override public int hashCode() {     int result = getBackendIdentifier().hashCode().     result = 31 * result + getKeyGroupRange().hashCode().     result = 31 * result + (int) (getCheckpointId() ^ (getCheckpointId() >>> 32)).     result = 31 * result + getSharedState().hashCode().     result = 31 * result + getPrivateState().hashCode().     result = 31 * result + getMetaStateHandle().hashCode().     return result. }
false;public;0;12;;@Override public String toString() {     return "IncrementalRemoteKeyedStateHandle{" + "backendIdentifier=" + backendIdentifier + ", keyGroupRange=" + keyGroupRange + ", checkpointId=" + checkpointId + ", sharedState=" + sharedState + ", privateState=" + privateState + ", metaStateHandle=" + metaStateHandle + ", registered=" + (sharedStateRegistry != null) + '}'. }
