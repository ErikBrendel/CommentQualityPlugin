commented;modifiers;parameterAmount;loc;comment;code
true;public;1;8;/**  * Registers a buffer pool with this result partition.  *  * <p>There is one pool for each result partition, which is shared by all its sub partitions.  *  * <p>The pool is registered with the partition *after* it as been constructed in order to conform  * to the life-cycle of task registrations in the {@link TaskManager}.  */ ;/**  * Registers a buffer pool with this result partition.  *  * <p>There is one pool for each result partition, which is shared by all its sub partitions.  *  * <p>The pool is registered with the partition *after* it as been constructed in order to conform  * to the life-cycle of task registrations in the {@link TaskManager}.  */ public void registerBufferPool(BufferPool bufferPool) {     checkArgument(bufferPool.getNumberOfRequiredMemorySegments() >= getNumberOfSubpartitions(), "Bug in result partition setup logic: Buffer pool has not enough guaranteed buffers for this result partition.").     checkState(this.bufferPool == null, "Bug in result partition setup logic: Already registered buffer pool.").     this.bufferPool = checkNotNull(bufferPool). }
false;public;0;3;;public JobID getJobId() {     return jobId. }
false;public;0;3;;public String getOwningTaskName() {     return owningTaskName. }
false;public;0;3;;public ResultPartitionID getPartitionId() {     return partitionId. }
false;public;0;4;;@Override public int getNumberOfSubpartitions() {     return subpartitions.length. }
false;public;0;4;;@Override public BufferProvider getBufferProvider() {     return bufferPool. }
false;public;0;3;;public BufferPool getBufferPool() {     return bufferPool. }
false;public;0;9;;public int getNumberOfQueuedBuffers() {     int totalBuffers = 0.     for (ResultSubpartition subpartition : subpartitions) {         totalBuffers += subpartition.unsynchronizedGetNumberOfQueuedBuffers().     }     return totalBuffers. }
true;public;0;3;/**  * Returns the type of this result partition.  *  * @return result partition type  */ ;/**  * Returns the type of this result partition.  *  * @return result partition type  */ public ResultPartitionType getPartitionType() {     return partitionType. }
false;public;2;18;;// ------------------------------------------------------------------------ @Override public void addBufferConsumer(BufferConsumer bufferConsumer, int subpartitionIndex) throws IOException {     checkNotNull(bufferConsumer).     ResultSubpartition subpartition.     try {         checkInProduceState().         subpartition = subpartitions[subpartitionIndex].     } catch (Exception ex) {         bufferConsumer.close().         throw ex.     }     if (subpartition.add(bufferConsumer)) {         notifyPipelinedConsumers().     } }
false;public;0;6;;@Override public void flushAll() {     for (ResultSubpartition subpartition : subpartitions) {         subpartition.flush().     } }
false;public;1;4;;@Override public void flush(int subpartitionIndex) {     subpartitions[subpartitionIndex].flush(). }
true;public;0;20;/**  * Finishes the result partition.  *  * <p>After this operation, it is not possible to add further data to the result partition.  *  * <p>For BLOCKING results, this will trigger the deployment of consuming tasks.  */ ;/**  * Finishes the result partition.  *  * <p>After this operation, it is not possible to add further data to the result partition.  *  * <p>For BLOCKING results, this will trigger the deployment of consuming tasks.  */ public void finish() throws IOException {     boolean success = false.     try {         checkInProduceState().         for (ResultSubpartition subpartition : subpartitions) {             subpartition.finish().         }         success = true.     } finally {         if (success) {             isFinished = true.             notifyPipelinedConsumers().         }     } }
false;public;0;3;;public void release() {     release(null). }
true;public;1;21;/**  * Releases the result partition.  */ ;/**  * Releases the result partition.  */ public void release(Throwable cause) {     if (isReleased.compareAndSet(false, true)) {         LOG.debug("{}: Releasing {}.", owningTaskName, this).         // Set the error cause         if (cause != null) {             this.cause = cause.         }         // Release all subpartitions         for (ResultSubpartition subpartition : subpartitions) {             try {                 subpartition.release().             }// Catch this in order to ensure that release is called on all subpartitions              catch (Throwable t) {                 LOG.error("Error during release of result subpartition: " + t.getMessage(), t).             }         }     } }
false;public;0;5;;public void destroyBufferPool() {     if (bufferPool != null) {         bufferPool.lazyDestroy().     } }
true;public;2;14;/**  * Returns the requested subpartition.  */ ;/**  * Returns the requested subpartition.  */ public ResultSubpartitionView createSubpartitionView(int index, BufferAvailabilityListener availabilityListener) throws IOException {     int refCnt = pendingReferences.get().     checkState(refCnt != -1, "Partition released.").     checkState(refCnt > 0, "Partition not pinned.").     checkElementIndex(index, subpartitions.length, "Subpartition not found.").     ResultSubpartitionView readView = subpartitions[index].createReadView(availabilityListener).     LOG.debug("Created {}", readView).     return readView. }
false;public;0;3;;public Throwable getFailureCause() {     return cause. }
false;public;0;4;;@Override public int getNumTargetKeyGroups() {     return numTargetKeyGroups. }
true;public;1;13;/**  * Releases buffers held by this result partition.  *  * <p>This is a callback from the buffer pool, which is registered for result partitions, which  * are back pressure-free.  */ ;/**  * Releases buffers held by this result partition.  *  * <p>This is a callback from the buffer pool, which is registered for result partitions, which  * are back pressure-free.  */ @Override public void releaseMemory(int toRelease) throws IOException {     checkArgument(toRelease > 0).     for (ResultSubpartition subpartition : subpartitions) {         toRelease -= subpartition.releaseMemory().         // Only release as much memory as needed         if (toRelease <= 0) {             break.         }     } }
false;public;0;6;;@Override public String toString() {     return "ResultPartition " + partitionId.toString() + " [" + partitionType + ", " + subpartitions.length + " subpartitions, " + pendingReferences + " pending references]". }
true;;0;14;/**  * Pins the result partition.  *  * <p>The partition can only be released after each subpartition has been consumed once per pin  * operation.  */ ;// ------------------------------------------------------------------------ /**  * Pins the result partition.  *  * <p>The partition can only be released after each subpartition has been consumed once per pin  * operation.  */ void pin() {     while (true) {         int refCnt = pendingReferences.get().         if (refCnt >= 0) {             if (pendingReferences.compareAndSet(refCnt, refCnt + subpartitions.length)) {                 break.             }         } else {             throw new IllegalStateException("Released.").         }     } }
true;;1;18;/**  * Notification when a subpartition is released.  */ ;/**  * Notification when a subpartition is released.  */ void onConsumedSubpartition(int subpartitionIndex) {     if (isReleased.get()) {         return.     }     int refCnt = pendingReferences.decrementAndGet().     if (refCnt == 0) {         partitionManager.onConsumedPartition(this).     } else if (refCnt < 0) {         throw new IllegalStateException("All references released.").     }     LOG.debug("{}: Received release notification for subpartition {} (reference count now at: {}).", this, subpartitionIndex, pendingReferences). }
false;;0;3;;ResultSubpartition[] getAllPartitions() {     return subpartitions. }
false;private;0;3;;// ------------------------------------------------------------------------ private void checkInProduceState() throws IllegalStateException {     checkState(!isFinished, "Partition already finished."). }
true;private;0;7;/**  * Notifies pipelined consumers of this result partition once.  */ ;/**  * Notifies pipelined consumers of this result partition once.  */ private void notifyPipelinedConsumers() {     if (sendScheduleOrUpdateConsumersMessage && !hasNotifiedPipelinedConsumers && partitionType.isPipelined()) {         partitionConsumableNotifier.notifyPartitionConsumable(jobId, partitionId, taskActions).         hasNotifiedPipelinedConsumers = true.     } }
