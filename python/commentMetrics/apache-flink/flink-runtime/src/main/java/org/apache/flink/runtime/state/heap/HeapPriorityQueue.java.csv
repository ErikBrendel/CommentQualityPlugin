commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;public void adjustModifiedElement(@Nonnull T element) {     final int elementIndex = element.getInternalIndex().     if (element == queue[elementIndex]) {         adjustElementAtIndex(element, elementIndex).     } }
false;protected;0;4;;@Override protected int getHeadElementIndex() {     return QUEUE_HEAD_INDEX. }
false;protected;1;6;;@Override protected void addInternal(@Nonnull T element) {     final int newSize = increaseSizeByOne().     moveElementToIdx(element, newSize).     siftUp(newSize). }
false;protected;1;20;;@Override protected T removeInternal(int removeIdx) {     T[] heap = this.queue.     T removedValue = heap[removeIdx].     assert removedValue.getInternalIndex() == removeIdx.     final int oldSize = size.     if (removeIdx != oldSize) {         T element = heap[oldSize].         moveElementToIdx(element, removeIdx).         adjustElementAtIndex(element, removeIdx).     }     heap[oldSize] = null.     --size.     return removedValue. }
false;private;2;6;;private void adjustElementAtIndex(T element, int index) {     siftDown(index).     if (queue[index] == element) {         siftUp(index).     } }
false;private;1;13;;private void siftUp(int idx) {     final T[] heap = this.queue.     final T currentElement = heap[idx].     int parentIdx = idx >>> 1.     while (parentIdx > 0 && isElementPriorityLessThen(currentElement, heap[parentIdx])) {         moveElementToIdx(heap[parentIdx], idx).         idx = parentIdx.         parentIdx >>>= 1.     }     moveElementToIdx(currentElement, idx). }
false;private;1;28;;private void siftDown(int idx) {     final T[] heap = this.queue.     final int heapSize = this.size.     final T currentElement = heap[idx].     int firstChildIdx = idx << 1.     int secondChildIdx = firstChildIdx + 1.     if (isElementIndexValid(secondChildIdx, heapSize) && isElementPriorityLessThen(heap[secondChildIdx], heap[firstChildIdx])) {         firstChildIdx = secondChildIdx.     }     while (isElementIndexValid(firstChildIdx, heapSize) && isElementPriorityLessThen(heap[firstChildIdx], currentElement)) {         moveElementToIdx(heap[firstChildIdx], idx).         idx = firstChildIdx.         firstChildIdx = idx << 1.         secondChildIdx = firstChildIdx + 1.         if (isElementIndexValid(secondChildIdx, heapSize) && isElementPriorityLessThen(heap[secondChildIdx], heap[firstChildIdx])) {             firstChildIdx = secondChildIdx.         }     }     moveElementToIdx(currentElement, idx). }
false;private;2;3;;private boolean isElementIndexValid(int elementIndex, int heapSize) {     return elementIndex <= heapSize. }
false;private;2;3;;private boolean isElementPriorityLessThen(T a, T b) {     return elementPriorityComparator.comparePriority(a, b) < 0. }
false;private;0;10;;private int increaseSizeByOne() {     final int oldArraySize = queue.length.     final int minRequiredNewSize = ++size.     if (minRequiredNewSize >= oldArraySize) {         final int grow = (oldArraySize < 64) ? oldArraySize + 2 : oldArraySize >> 1.         resizeQueueArray(oldArraySize + grow, minRequiredNewSize).     }     // TODO implement shrinking as well?     return minRequiredNewSize. }
