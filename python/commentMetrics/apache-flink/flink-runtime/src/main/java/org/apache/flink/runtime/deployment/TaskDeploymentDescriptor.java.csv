commented;modifiers;parameterAmount;loc;comment;code
true;public;0;11;/**  * Return the sub task's serialized job information.  *  * @return serialized job information (may be <tt>null</tt> before a call to {@link  * #loadBigData(PermanentBlobService)}).  */ ;/**  * Return the sub task's serialized job information.  *  * @return serialized job information (may be <tt>null</tt> before a call to {@link  * #loadBigData(PermanentBlobService)}).  */ @Nullable public SerializedValue<JobInformation> getSerializedJobInformation() {     if (serializedJobInformation instanceof NonOffloaded) {         NonOffloaded<JobInformation> jobInformation = (NonOffloaded<JobInformation>) serializedJobInformation.         return jobInformation.serializedValue.     } else {         throw new IllegalStateException("Trying to work with offloaded serialized job information.").     } }
true;public;0;11;/**  * Return the sub task's serialized task information.  *  * @return serialized task information (may be <tt>null</tt> before a call to {@link  * #loadBigData(PermanentBlobService)}).  */ ;/**  * Return the sub task's serialized task information.  *  * @return serialized task information (may be <tt>null</tt> before a call to {@link  * #loadBigData(PermanentBlobService)}).  */ @Nullable public SerializedValue<TaskInformation> getSerializedTaskInformation() {     if (serializedTaskInformation instanceof NonOffloaded) {         NonOffloaded<TaskInformation> taskInformation = (NonOffloaded<TaskInformation>) serializedTaskInformation.         return taskInformation.serializedValue.     } else {         throw new IllegalStateException("Trying to work with offloaded serialized job information.").     } }
true;public;0;3;/**  * Returns the task's job ID.  *  * @return the job ID this task belongs to  */ ;/**  * Returns the task's job ID.  *  * @return the job ID this task belongs to  */ public JobID getJobId() {     return jobId. }
false;public;0;3;;public ExecutionAttemptID getExecutionAttemptId() {     return executionId. }
true;public;0;3;/**  * Returns the task's index in the subtask group.  *  * @return the task's index in the subtask group  */ ;/**  * Returns the task's index in the subtask group.  *  * @return the task's index in the subtask group  */ public int getSubtaskIndex() {     return subtaskIndex. }
true;public;0;3;/**  * Returns the attempt number of the subtask.  */ ;/**  * Returns the attempt number of the subtask.  */ public int getAttemptNumber() {     return attemptNumber. }
true;public;0;3;/**  * Gets the number of the slot into which the task is to be deployed.  *  * @return The number of the target slot.  */ ;/**  * Gets the number of the slot into which the task is to be deployed.  *  * @return The number of the target slot.  */ public int getTargetSlotNumber() {     return targetSlotNumber. }
false;public;0;3;;public Collection<ResultPartitionDeploymentDescriptor> getProducedPartitions() {     return producedPartitions. }
false;public;0;3;;public Collection<InputGateDeploymentDescriptor> getInputGates() {     return inputGates. }
false;public;0;4;;@Nullable public JobManagerTaskRestore getTaskRestore() {     return taskRestore. }
false;public;0;3;;public AllocationID getAllocationId() {     return allocationId. }
true;public;1;38;/**  * Loads externalized data from the BLOB store back to the object.  *  * @param blobService  * 		the blob store to use (may be <tt>null</tt> if {@link #serializedJobInformation} and {@link  * 		#serializedTaskInformation} are non-<tt>null</tt>)  *  * @throws IOException  * 		during errors retrieving or reading the BLOBs  * @throws ClassNotFoundException  * 		Class of a serialized object cannot be found.  */ ;/**  * Loads externalized data from the BLOB store back to the object.  *  * @param blobService  * 		the blob store to use (may be <tt>null</tt> if {@link #serializedJobInformation} and {@link  * 		#serializedTaskInformation} are non-<tt>null</tt>)  *  * @throws IOException  * 		during errors retrieving or reading the BLOBs  * @throws ClassNotFoundException  * 		Class of a serialized object cannot be found.  */ public void loadBigData(@Nullable PermanentBlobService blobService) throws IOException, ClassNotFoundException {     // here, if this fails, we need to throw the exception as there is no backup path anymore     if (serializedJobInformation instanceof Offloaded) {         PermanentBlobKey jobInfoKey = ((Offloaded<JobInformation>) serializedJobInformation).serializedValueKey.         Preconditions.checkNotNull(blobService).         final File dataFile = blobService.getFile(jobId, jobInfoKey).         // NOTE: Do not delete the job info BLOB since it may be needed again during recovery.         // (it is deleted automatically on the BLOB server and cache when the job         // enters a terminal state)         SerializedValue<JobInformation> serializedValue = SerializedValue.fromBytes(FileUtils.readAllBytes(dataFile.toPath())).         serializedJobInformation = new NonOffloaded<>(serializedValue).     }     // re-integrate offloaded task info from blob     if (serializedTaskInformation instanceof Offloaded) {         PermanentBlobKey taskInfoKey = ((Offloaded<TaskInformation>) serializedTaskInformation).serializedValueKey.         Preconditions.checkNotNull(blobService).         final File dataFile = blobService.getFile(jobId, taskInfoKey).         // NOTE: Do not delete the task info BLOB since it may be needed again during recovery.         // (it is deleted automatically on the BLOB server and cache when the job         // enters a terminal state)         SerializedValue<TaskInformation> serializedValue = SerializedValue.fromBytes(FileUtils.readAllBytes(dataFile.toPath())).         serializedTaskInformation = new NonOffloaded<>(serializedValue).     }     // make sure that the serialized job and task information fields are filled     Preconditions.checkNotNull(serializedJobInformation).     Preconditions.checkNotNull(serializedTaskInformation). }
false;public;0;9;;@Override public String toString() {     return String.format("TaskDeploymentDescriptor [execution id: %s, attempt: %d, " + "produced partitions: %s, input gates: %s]", executionId, attemptNumber, collectionToString(producedPartitions), collectionToString(inputGates)). }
false;private,static;1;13;;private static String collectionToString(Iterable<?> collection) {     final StringBuilder strBuilder = new StringBuilder().     strBuilder.append("[").     for (Object elem : collection) {         strBuilder.append(elem).     }     strBuilder.append("]").     return strBuilder.toString(). }
