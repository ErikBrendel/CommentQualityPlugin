commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the ID of the job.  *  * @return the ID of the job  */ ;// -------------------------------------------------------------------------------------------- /**  * Returns the ID of the job.  *  * @return the ID of the job  */ public JobID getJobID() {     return this.jobID. }
true;public;0;3;/**  * Returns the name assigned to the job graph.  *  * @return the name assigned to the job graph  */ ;/**  * Returns the name assigned to the job graph.  *  * @return the name assigned to the job graph  */ public String getName() {     return this.jobName. }
true;public;0;3;/**  * Returns the configuration object for this job. Job-wide parameters should be set into that  * configuration object.  *  * @return The configuration object for this job.  */ ;/**  * Returns the configuration object for this job. Job-wide parameters should be set into that  * configuration object.  *  * @return The configuration object for this job.  */ public Configuration getJobConfiguration() {     return this.jobConfiguration. }
true;public;0;3;/**  * Returns the {@link ExecutionConfig}  *  * @return ExecutionConfig  */ ;/**  * Returns the {@link ExecutionConfig}  *  * @return ExecutionConfig  */ public SerializedValue<ExecutionConfig> getSerializedExecutionConfig() {     return serializedExecutionConfig. }
true;public;0;3;/**  * Gets the timeout after which the corresponding ExecutionGraph is removed at the  * job manager after it has been executed.  * @return a timeout as a long in seconds.  */ ;/**  * Gets the timeout after which the corresponding ExecutionGraph is removed at the  * job manager after it has been executed.  * @return a timeout as a long in seconds.  */ public long getSessionTimeout() {     return sessionTimeout. }
true;public;1;3;/**  * Sets the timeout of the session in seconds. The timeout specifies how long a job will be kept  * in the job manager after it finishes.  * @param sessionTimeout The timeout in seconds  */ ;/**  * Sets the timeout of the session in seconds. The timeout specifies how long a job will be kept  * in the job manager after it finishes.  * @param sessionTimeout The timeout in seconds  */ public void setSessionTimeout(long sessionTimeout) {     this.sessionTimeout = sessionTimeout. }
false;public;1;3;;public void setAllowQueuedScheduling(boolean allowQueuedScheduling) {     this.allowQueuedScheduling = allowQueuedScheduling. }
false;public;0;3;;public boolean getAllowQueuedScheduling() {     return allowQueuedScheduling. }
false;public;1;3;;public void setScheduleMode(ScheduleMode scheduleMode) {     this.scheduleMode = scheduleMode. }
false;public;0;3;;public ScheduleMode getScheduleMode() {     return scheduleMode. }
true;public;1;3;/**  * Sets the savepoint restore settings.  * @param settings The savepoint restore settings.  */ ;/**  * Sets the savepoint restore settings.  * @param settings The savepoint restore settings.  */ public void setSavepointRestoreSettings(SavepointRestoreSettings settings) {     this.savepointRestoreSettings = checkNotNull(settings, "Savepoint restore settings"). }
true;public;0;3;/**  * Returns the configured savepoint restore setting.  * @return The configured savepoint restore settings.  */ ;/**  * Returns the configured savepoint restore setting.  * @return The configured savepoint restore settings.  */ public SavepointRestoreSettings getSavepointRestoreSettings() {     return savepointRestoreSettings. }
true;public;1;4;/**  * Sets the execution config. This method eagerly serialized the ExecutionConfig for future RPC  * transport. Further modification of the referenced ExecutionConfig object will not affect  * this serialized copy.  *  * @param executionConfig The ExecutionConfig to be serialized.  * @throws IOException Thrown if the serialization of the ExecutionConfig fails  */ ;/**  * Sets the execution config. This method eagerly serialized the ExecutionConfig for future RPC  * transport. Further modification of the referenced ExecutionConfig object will not affect  * this serialized copy.  *  * @param executionConfig The ExecutionConfig to be serialized.  * @throws IOException Thrown if the serialization of the ExecutionConfig fails  */ public void setExecutionConfig(ExecutionConfig executionConfig) throws IOException {     checkNotNull(executionConfig, "ExecutionConfig must not be null.").     this.serializedExecutionConfig = new SerializedValue<>(executionConfig). }
true;public;1;10;/**  * Adds a new task vertex to the job graph if it is not already included.  *  * @param vertex  *        the new task vertex to be added  */ ;/**  * Adds a new task vertex to the job graph if it is not already included.  *  * @param vertex  *        the new task vertex to be added  */ public void addVertex(JobVertex vertex) {     final JobVertexID id = vertex.getID().     JobVertex previous = taskVertices.put(id, vertex).     // if we had a prior association, restore and throw an exception     if (previous != null) {         taskVertices.put(id, previous).         throw new IllegalArgumentException("The JobGraph already contains a vertex with that id.").     } }
true;public;0;3;/**  * Returns an Iterable to iterate all vertices registered with the job graph.  *  * @return an Iterable to iterate all vertices registered with the job graph  */ ;/**  * Returns an Iterable to iterate all vertices registered with the job graph.  *  * @return an Iterable to iterate all vertices registered with the job graph  */ public Iterable<JobVertex> getVertices() {     return this.taskVertices.values(). }
true;public;0;3;/**  * Returns an array of all job vertices that are registered with the job graph. The order in which the vertices  * appear in the list is not defined.  *  * @return an array of all job vertices that are registered with the job graph  */ ;/**  * Returns an array of all job vertices that are registered with the job graph. The order in which the vertices  * appear in the list is not defined.  *  * @return an array of all job vertices that are registered with the job graph  */ public JobVertex[] getVerticesAsArray() {     return this.taskVertices.values().toArray(new JobVertex[this.taskVertices.size()]). }
true;public;0;3;/**  * Returns the number of all vertices.  *  * @return The number of all vertices.  */ ;/**  * Returns the number of all vertices.  *  * @return The number of all vertices.  */ public int getNumberOfVertices() {     return this.taskVertices.size(). }
true;public;1;3;/**  * Sets the settings for asynchronous snapshots. A value of {@code null} means that  * snapshotting is not enabled.  *  * @param settings The snapshot settings  */ ;/**  * Sets the settings for asynchronous snapshots. A value of {@code null} means that  * snapshotting is not enabled.  *  * @param settings The snapshot settings  */ public void setSnapshotSettings(JobCheckpointingSettings settings) {     this.snapshotSettings = settings. }
true;public;0;3;/**  * Gets the settings for asynchronous snapshots. This method returns null, when  * checkpointing is not enabled.  *  * @return The snapshot settings  */ ;/**  * Gets the settings for asynchronous snapshots. This method returns null, when  * checkpointing is not enabled.  *  * @return The snapshot settings  */ public JobCheckpointingSettings getCheckpointingSettings() {     return snapshotSettings. }
true;public;0;10;/**  * Checks if the checkpointing was enabled for this job graph  *  * @return true if checkpointing enabled  */ ;/**  * Checks if the checkpointing was enabled for this job graph  *  * @return true if checkpointing enabled  */ public boolean isCheckpointingEnabled() {     if (snapshotSettings == null) {         return false.     }     long checkpointInterval = snapshotSettings.getCheckpointCoordinatorConfiguration().getCheckpointInterval().     return checkpointInterval > 0 && checkpointInterval < Long.MAX_VALUE. }
true;public;1;3;/**  * Searches for a vertex with a matching ID and returns it.  *  * @param id  *        the ID of the vertex to search for  * @return the vertex with the matching ID or <code>null</code> if no vertex with such ID could be found  */ ;/**  * Searches for a vertex with a matching ID and returns it.  *  * @param id  *        the ID of the vertex to search for  * @return the vertex with the matching ID or <code>null</code> if no vertex with such ID could be found  */ public JobVertex findVertexByID(JobVertexID id) {     return this.taskVertices.get(id). }
true;public;1;3;/**  * Sets the classpaths required to run the job on a task manager.  *  * @param paths paths of the directories/JAR files required to run the job on a task manager  */ ;/**  * Sets the classpaths required to run the job on a task manager.  *  * @param paths paths of the directories/JAR files required to run the job on a task manager  */ public void setClasspaths(List<URL> paths) {     classpaths = paths. }
false;public;0;3;;public List<URL> getClasspaths() {     return classpaths. }
true;public;0;7;/**  * Gets the maximum parallelism of all operations in this job graph.  *  * @return The maximum parallelism of this job graph  */ ;/**  * Gets the maximum parallelism of all operations in this job graph.  *  * @return The maximum parallelism of this job graph  */ public int getMaximumParallelism() {     int maxParallelism = -1.     for (JobVertex vertex : taskVertices.values()) {         maxParallelism = Math.max(vertex.getParallelism(), maxParallelism).     }     return maxParallelism. }
false;public;0;40;;// -------------------------------------------------------------------------------------------- // Topological Graph Access // -------------------------------------------------------------------------------------------- public List<JobVertex> getVerticesSortedTopologicallyFromSources() throws InvalidProgramException {     // early out on empty lists     if (this.taskVertices.isEmpty()) {         return Collections.emptyList().     }     List<JobVertex> sorted = new ArrayList<JobVertex>(this.taskVertices.size()).     Set<JobVertex> remaining = new LinkedHashSet<JobVertex>(this.taskVertices.values()).     // start by finding the vertices with no input edges     // and the ones with disconnected inputs (that refer to some standalone data set)     {         Iterator<JobVertex> iter = remaining.iterator().         while (iter.hasNext()) {             JobVertex vertex = iter.next().             if (vertex.hasNoConnectedInputs()) {                 sorted.add(vertex).                 iter.remove().             }         }     }     int startNodePos = 0.     // traverse from the nodes that were added until we found all elements     while (!remaining.isEmpty()) {         // graph is cyclic, which is not permitted         if (startNodePos >= sorted.size()) {             throw new InvalidProgramException("The job graph is cyclic.").         }         JobVertex current = sorted.get(startNodePos++).         addNodesThatHaveNoNewPredecessors(current, sorted, remaining).     }     return sorted. }
false;private;3;35;;private void addNodesThatHaveNoNewPredecessors(JobVertex start, List<JobVertex> target, Set<JobVertex> remaining) {     // forward traverse over all produced data sets and all their consumers     for (IntermediateDataSet dataSet : start.getProducedDataSets()) {         for (JobEdge edge : dataSet.getConsumers()) {             // a vertex can be added, if it has no predecessors that are still in the 'remaining' set             JobVertex v = edge.getTarget().             if (!remaining.contains(v)) {                 continue.             }             boolean hasNewPredecessors = false.             for (JobEdge e : v.getInputs()) {                 // skip the edge through which we came                 if (e == edge) {                     continue.                 }                 IntermediateDataSet source = e.getSource().                 if (remaining.contains(source.getProducer())) {                     hasNewPredecessors = true.                     break.                 }             }             if (!hasNewPredecessors) {                 target.add(v).                 remaining.remove(v).                 addNodesThatHaveNoNewPredecessors(v, target, remaining).             }         }     } }
true;public;1;9;/**  * Adds the path of a JAR file required to run the job on a task manager.  *  * @param jar  *        path of the JAR file required to run the job on a task manager  */ ;// -------------------------------------------------------------------------------------------- // Handling of attached JAR files // -------------------------------------------------------------------------------------------- /**  * Adds the path of a JAR file required to run the job on a task manager.  *  * @param jar  *        path of the JAR file required to run the job on a task manager  */ public void addJar(Path jar) {     if (jar == null) {         throw new IllegalArgumentException().     }     if (!userJars.contains(jar)) {         userJars.add(jar).     } }
true;public;0;3;/**  * Gets the list of assigned user jar paths.  *  * @return The list of assigned user jar paths  */ ;/**  * Gets the list of assigned user jar paths.  *  * @return The list of assigned user jar paths  */ public List<Path> getUserJars() {     return userJars. }
true;public;2;7;/**  * Adds the path of a custom file required to run the job on a task manager.  *  * @param name a name under which this artifact will be accessible through {@link DistributedCache}  * @param file path of a custom file required to run the job on a task manager  */ ;/**  * Adds the path of a custom file required to run the job on a task manager.  *  * @param name a name under which this artifact will be accessible through {@link DistributedCache}  * @param file path of a custom file required to run the job on a task manager  */ public void addUserArtifact(String name, DistributedCache.DistributedCacheEntry file) {     if (file == null) {         throw new IllegalArgumentException().     }     userArtifacts.putIfAbsent(name, file). }
true;public;0;3;/**  * Gets the list of assigned user jar paths.  *  * @return The list of assigned user jar paths  */ ;/**  * Gets the list of assigned user jar paths.  *  * @return The list of assigned user jar paths  */ public Map<String, DistributedCache.DistributedCacheEntry> getUserArtifacts() {     return userArtifacts. }
true;public;1;9;/**  * Adds the BLOB referenced by the key to the JobGraph's dependencies.  *  * @param key  *        path of the JAR file required to run the job on a task manager  */ ;/**  * Adds the BLOB referenced by the key to the JobGraph's dependencies.  *  * @param key  *        path of the JAR file required to run the job on a task manager  */ public void addUserJarBlobKey(PermanentBlobKey key) {     if (key == null) {         throw new IllegalArgumentException().     }     if (!userJarBlobKeys.contains(key)) {         userJarBlobKeys.add(key).     } }
true;public;0;3;/**  * Checks whether the JobGraph has user code JAR files attached.  *  * @return True, if the JobGraph has user code JAR files attached, false otherwise.  */ ;/**  * Checks whether the JobGraph has user code JAR files attached.  *  * @return True, if the JobGraph has user code JAR files attached, false otherwise.  */ public boolean hasUsercodeJarFiles() {     return this.userJars.size() > 0. }
true;public;0;3;/**  * Returns a set of BLOB keys referring to the JAR files required to run this job.  *  * @return set of BLOB keys referring to the JAR files required to run this job  */ ;/**  * Returns a set of BLOB keys referring to the JAR files required to run this job.  *  * @return set of BLOB keys referring to the JAR files required to run this job  */ public List<PermanentBlobKey> getUserJarBlobKeys() {     return this.userJarBlobKeys. }
false;public;0;4;;@Override public String toString() {     return "JobGraph(jobId: " + jobID + ")". }
false;public;2;11;;public void setUserArtifactBlobKey(String entryName, PermanentBlobKey blobKey) throws IOException {     byte[] serializedBlobKey.     serializedBlobKey = InstantiationUtil.serializeObject(blobKey).     userArtifacts.computeIfPresent(entryName, (key, originalEntry) -> new DistributedCache.DistributedCacheEntry(originalEntry.filePath, originalEntry.isExecutable, serializedBlobKey, originalEntry.isZipped)). }
false;public;0;9;;public void writeUserArtifactEntriesToConfiguration() {     for (Map.Entry<String, DistributedCache.DistributedCacheEntry> userArtifact : userArtifacts.entrySet()) {         DistributedCache.writeFileInfoToConfig(userArtifact.getKey(), userArtifact.getValue(), jobConfiguration).     } }
