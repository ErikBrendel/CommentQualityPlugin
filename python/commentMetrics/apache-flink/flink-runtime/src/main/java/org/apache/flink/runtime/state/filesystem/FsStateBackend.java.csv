commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Gets the base directory where all the checkpoints are stored.  * The job-specific checkpoint directory is created inside this directory.  *  * @return The base directory for checkpoints.  *  * @deprecated Deprecated in favor of {@link #getCheckpointPath()}.  */ ;// ------------------------------------------------------------------------ // Properties // ------------------------------------------------------------------------ /**  * Gets the base directory where all the checkpoints are stored.  * The job-specific checkpoint directory is created inside this directory.  *  * @return The base directory for checkpoints.  *  * @deprecated Deprecated in favor of {@link #getCheckpointPath()}.  */ @Deprecated public Path getBasePath() {     return getCheckpointPath(). }
true;public;0;7;/**  * Gets the base directory where all the checkpoints are stored.  * The job-specific checkpoint directory is created inside this directory.  *  * @return The base directory for checkpoints.  */ ;/**  * Gets the base directory where all the checkpoints are stored.  * The job-specific checkpoint directory is created inside this directory.  *  * @return The base directory for checkpoints.  */ @Nonnull @Override public Path getCheckpointPath() {     // noinspection ConstantConditions     return super.getCheckpointPath(). }
true;public;0;5;/**  * Gets the threshold below which state is stored as part of the metadata, rather than in files.  * This threshold ensures that the backend does not create a large amount of very small files,  * where potentially the file pointers are larger than the state itself.  *  * <p>If not explicitly configured, this is the default value of  * {@link CheckpointingOptions#FS_SMALL_FILE_THRESHOLD}.  *  * @return The file size threshold, in bytes.  */ ;/**  * Gets the threshold below which state is stored as part of the metadata, rather than in files.  * This threshold ensures that the backend does not create a large amount of very small files,  * where potentially the file pointers are larger than the state itself.  *  * <p>If not explicitly configured, this is the default value of  * {@link CheckpointingOptions#FS_SMALL_FILE_THRESHOLD}.  *  * @return The file size threshold, in bytes.  */ public int getMinFileSizeThreshold() {     return fileStateThreshold >= 0 ? fileStateThreshold : CheckpointingOptions.FS_SMALL_FILE_THRESHOLD.defaultValue(). }
true;public;0;3;/**  * Gets whether the key/value data structures are asynchronously snapshotted.  *  * <p>If not explicitly configured, this is the default value of  * {@link CheckpointingOptions#ASYNC_SNAPSHOTS}.  */ ;/**  * Gets whether the key/value data structures are asynchronously snapshotted.  *  * <p>If not explicitly configured, this is the default value of  * {@link CheckpointingOptions#ASYNC_SNAPSHOTS}.  */ public boolean isUsingAsynchronousSnapshots() {     return asynchronousSnapshots.getOrDefault(CheckpointingOptions.ASYNC_SNAPSHOTS.defaultValue()). }
true;public;2;4;/**  * Creates a copy of this state backend that uses the values defined in the configuration  * for fields where that were not specified in this state backend.  *  * @param config the configuration  * @return The re-configured variant of the state backend  */ ;// ------------------------------------------------------------------------ // Reconfiguration // ------------------------------------------------------------------------ /**  * Creates a copy of this state backend that uses the values defined in the configuration  * for fields where that were not specified in this state backend.  *  * @param config the configuration  * @return The re-configured variant of the state backend  */ @Override public FsStateBackend configure(Configuration config, ClassLoader classLoader) {     return new FsStateBackend(this, config, classLoader). }
false;public;1;5;;// ------------------------------------------------------------------------ // initialization and cleanup // ------------------------------------------------------------------------ @Override public CheckpointStorage createCheckpointStorage(JobID jobId) throws IOException {     checkNotNull(jobId, "jobId").     return new FsCheckpointStorage(getCheckpointPath(), getSavepointPath(), jobId, getMinFileSizeThreshold()). }
false;public;10;30;;// ------------------------------------------------------------------------ // state holding structures // ------------------------------------------------------------------------ @Override public <K> AbstractKeyedStateBackend<K> createKeyedStateBackend(Environment env, JobID jobID, String operatorIdentifier, TypeSerializer<K> keySerializer, int numberOfKeyGroups, KeyGroupRange keyGroupRange, TaskKvStateRegistry kvStateRegistry, TtlTimeProvider ttlTimeProvider, MetricGroup metricGroup, Collection<KeyedStateHandle> stateHandles) {     TaskStateManager taskStateManager = env.getTaskStateManager().     LocalRecoveryConfig localRecoveryConfig = taskStateManager.createLocalRecoveryConfig().     HeapPriorityQueueSetFactory priorityQueueSetFactory = new HeapPriorityQueueSetFactory(keyGroupRange, numberOfKeyGroups, 128).     return new HeapKeyedStateBackend<>(kvStateRegistry, keySerializer, env.getUserClassLoader(), numberOfKeyGroups, keyGroupRange, isUsingAsynchronousSnapshots(), env.getExecutionConfig(), localRecoveryConfig, priorityQueueSetFactory, ttlTimeProvider). }
false;public;2;10;;@Override public OperatorStateBackend createOperatorStateBackend(Environment env, String operatorIdentifier) {     return new DefaultOperatorStateBackend(env.getUserClassLoader(), env.getExecutionConfig(), isUsingAsynchronousSnapshots()). }
false;public;0;8;;// ------------------------------------------------------------------------ // utilities // ------------------------------------------------------------------------ @Override public String toString() {     return "File State Backend (" + "checkpoints: '" + getCheckpointPath() + "', savepoints: '" + getSavepointPath() + "', asynchronous: " + asynchronousSnapshots + ", fileStateThreshold: " + fileStateThreshold + ")". }
