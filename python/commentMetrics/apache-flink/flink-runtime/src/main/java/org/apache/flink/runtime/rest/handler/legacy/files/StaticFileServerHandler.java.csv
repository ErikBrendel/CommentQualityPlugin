commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;18;;// ------------------------------------------------------------------------ // Responses to requests // ------------------------------------------------------------------------ @Override protected void respondAsLeader(ChannelHandlerContext channelHandlerContext, RoutedRequest routedRequest, T gateway) throws Exception {     final HttpRequest request = routedRequest.getRequest().     final String requestPath.     // make sure we request the "index.html" in case there is a directory request     if (routedRequest.getPath().endsWith("/")) {         requestPath = routedRequest.getPath() + "index.html".     } else // in case the files being accessed are logs or stdout files, find appropriate paths.     if (routedRequest.getPath().equals("/jobmanager/log") || routedRequest.getPath().equals("/jobmanager/stdout")) {         requestPath = "".     } else {         requestPath = routedRequest.getPath().     }     respondToRequest(channelHandlerContext, request, requestPath). }
true;private;3;153;/**  * Response when running with leading JobManager.  */ ;/**  * Response when running with leading JobManager.  */ private void respondToRequest(ChannelHandlerContext ctx, HttpRequest request, String requestPath) throws IOException, ParseException, URISyntaxException {     // convert to absolute path     final File file = new File(rootPath, requestPath).     if (!file.exists()) {         // file does not exist. Try to load it with the classloader         ClassLoader cl = StaticFileServerHandler.class.getClassLoader().         try (InputStream resourceStream = cl.getResourceAsStream("web" + requestPath)) {             boolean success = false.             try {                 if (resourceStream != null) {                     URL root = cl.getResource("web").                     URL requested = cl.getResource("web" + requestPath).                     if (root != null && requested != null) {                         URI rootURI = new URI(root.getPath()).normalize().                         URI requestedURI = new URI(requested.getPath()).normalize().                         // expected scope.                         if (!rootURI.relativize(requestedURI).equals(requestedURI)) {                             logger.debug("Loading missing file from classloader: {}", requestPath).                             // ensure that directory to file exists.                             file.getParentFile().mkdirs().                             Files.copy(resourceStream, file.toPath()).                             success = true.                         }                     }                 }             } catch (Throwable t) {                 logger.error("error while responding", t).             } finally {                 if (!success) {                     logger.debug("Unable to load requested file {} from classloader", requestPath).                     HandlerUtils.sendErrorResponse(ctx, request, new ErrorResponseBody(String.format("Unable to load requested file %s.", requestPath)), NOT_FOUND, responseHeaders).                     return.                 }             }         }     }     if (!file.exists() || file.isHidden() || file.isDirectory() || !file.isFile()) {         HandlerUtils.sendErrorResponse(ctx, request, new ErrorResponseBody("File not found."), NOT_FOUND, responseHeaders).         return.     }     if (!file.getCanonicalFile().toPath().startsWith(rootPath.toPath())) {         HandlerUtils.sendErrorResponse(ctx, request, new ErrorResponseBody("File not found."), NOT_FOUND, responseHeaders).         return.     }     // cache validation     final String ifModifiedSince = request.headers().get(IF_MODIFIED_SINCE).     if (ifModifiedSince != null && !ifModifiedSince.isEmpty()) {         SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US).         Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince).         // Only compare up to the second because the datetime format we send to the client         // does not have milliseconds         long ifModifiedSinceDateSeconds = ifModifiedSinceDate.getTime() / 1000.         long fileLastModifiedSeconds = file.lastModified() / 1000.         if (ifModifiedSinceDateSeconds == fileLastModifiedSeconds) {             if (logger.isDebugEnabled()) {                 logger.debug("Responding 'NOT MODIFIED' for file '" + file.getAbsolutePath() + '\'').             }             sendNotModified(ctx).             return.         }     }     if (logger.isDebugEnabled()) {         logger.debug("Responding with file '" + file.getAbsolutePath() + '\'').     }     // Don't need to close this manually. Netty's DefaultFileRegion will take care of it.     final RandomAccessFile raf.     try {         raf = new RandomAccessFile(file, "r").     } catch (FileNotFoundException e) {         HandlerUtils.sendErrorResponse(ctx, request, new ErrorResponseBody("File not found."), HttpResponseStatus.NOT_FOUND, responseHeaders).         return.     }     try {         long fileLength = raf.length().         HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK).         setContentTypeHeader(response, file).         // since the log and out files are rapidly changing, we don't want to browser to cache them         if (!(requestPath.contains("log") || requestPath.contains("out"))) {             setDateAndCacheHeaders(response, file).         }         if (HttpHeaders.isKeepAlive(request)) {             response.headers().set(CONNECTION, HttpHeaders.Values.KEEP_ALIVE).         }         HttpHeaders.setContentLength(response, fileLength).         // write the initial line and the header.         ctx.write(response).         // write the content.         ChannelFuture lastContentFuture.         if (ctx.pipeline().get(SslHandler.class) == null) {             ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.newProgressivePromise()).             lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).         } else {             lastContentFuture = ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)), ctx.newProgressivePromise()).         // HttpChunkedInput will write the end marker (LastHttpContent) for us.         }         // close the connection, if no keep-alive is needed         if (!HttpHeaders.isKeepAlive(request)) {             lastContentFuture.addListener(ChannelFutureListener.CLOSE).         }     } catch (Exception e) {         raf.close().         logger.error("Failed to serve file.", e).         HandlerUtils.sendErrorResponse(ctx, request, new ErrorResponseBody("Internal server error."), INTERNAL_SERVER_ERROR, responseHeaders).     } }
false;public;2;12;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {     if (ctx.channel().isActive()) {         logger.error("Caught exception", cause).         HandlerUtils.sendErrorResponse(ctx, false, new ErrorResponseBody("Internal server error."), INTERNAL_SERVER_ERROR, Collections.emptyMap()).     } }
true;public,static;1;7;/**  * Send the "304 Not Modified" response. This response can be used when the  * file timestamp is the same as what the browser is sending up.  *  * @param ctx The channel context to write the response to.  */ ;// ------------------------------------------------------------------------ // Utilities to encode headers and responses // ------------------------------------------------------------------------ /**  * Send the "304 Not Modified" response. This response can be used when the  * file timestamp is the same as what the browser is sending up.  *  * @param ctx The channel context to write the response to.  */ public static void sendNotModified(ChannelHandlerContext ctx) {     FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, NOT_MODIFIED).     setDateHeader(response).     // close the connection as soon as the error message is sent.     ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE). }
true;public,static;1;7;/**  * Sets the "date" header for the HTTP response.  *  * @param response HTTP response  */ ;/**  * Sets the "date" header for the HTTP response.  *  * @param response HTTP response  */ public static void setDateHeader(FullHttpResponse response) {     SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US).     dateFormatter.setTimeZone(GMT_TIMEZONE).     Calendar time = new GregorianCalendar().     response.headers().set(DATE, dateFormatter.format(time.getTime())). }
true;public,static;2;14;/**  * Sets the "date" and "cache" headers for the HTTP Response.  *  * @param response    The HTTP response object.  * @param fileToCache File to extract the modification timestamp from.  */ ;/**  * Sets the "date" and "cache" headers for the HTTP Response.  *  * @param response    The HTTP response object.  * @param fileToCache File to extract the modification timestamp from.  */ public static void setDateAndCacheHeaders(HttpResponse response, File fileToCache) {     SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US).     dateFormatter.setTimeZone(GMT_TIMEZONE).     // date header     Calendar time = new GregorianCalendar().     response.headers().set(DATE, dateFormatter.format(time.getTime())).     // cache headers     time.add(Calendar.SECOND, HTTP_CACHE_SECONDS).     response.headers().set(EXPIRES, dateFormatter.format(time.getTime())).     response.headers().set(CACHE_CONTROL, "private, max-age=" + HTTP_CACHE_SECONDS).     response.headers().set(LAST_MODIFIED, dateFormatter.format(new Date(fileToCache.lastModified()))). }
true;public,static;2;5;/**  * Sets the content type header for the HTTP Response.  *  * @param response HTTP response  * @param file     file to extract content type  */ ;/**  * Sets the content type header for the HTTP Response.  *  * @param response HTTP response  * @param file     file to extract content type  */ public static void setContentTypeHeader(HttpResponse response, File file) {     String mimeType = MimeTypes.getMimeTypeForFileName(file.getName()).     String mimeFinal = mimeType != null ? mimeType : MimeTypes.getDefaultMimeType().     response.headers().set(CONTENT_TYPE, mimeFinal). }
