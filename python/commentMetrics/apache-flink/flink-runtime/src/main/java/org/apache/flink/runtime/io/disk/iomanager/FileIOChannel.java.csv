commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Gets the channel ID of this I/O channel.  *  * @return The channel ID.  */ ;/**  * Gets the channel ID of this I/O channel.  *  * @return The channel ID.  */ FileIOChannel.ID getChannelID().
true;;0;1;/**  * Gets the size (in bytes) of the file underlying the channel.  *  * @return The size (in bytes) of the file underlying the channel.  */ ;/**  * Gets the size (in bytes) of the file underlying the channel.  *  * @return The size (in bytes) of the file underlying the channel.  */ long getSize() throws IOException.
true;;0;1;/**  * Checks whether the channel has been closed.  *  * @return True if the channel has been closed, false otherwise.  */ ;/**  * Checks whether the channel has been closed.  *  * @return True if the channel has been closed, false otherwise.  */ boolean isClosed().
true;;0;1;/**  * Closes the channel. For asynchronous implementations, this method waits until all pending requests are  * handled. Even if an exception interrupts the closing, the underlying <tt>FileChannel</tt> is closed.  *  * @throws IOException Thrown, if an error occurred while waiting for pending requests.  */ ;/**  * Closes the channel. For asynchronous implementations, this method waits until all pending requests are  * handled. Even if an exception interrupts the closing, the underlying <tt>FileChannel</tt> is closed.  *  * @throws IOException Thrown, if an error occurred while waiting for pending requests.  */ void close() throws IOException.
true;;0;1;/**  * Deletes the file underlying this I/O channel.  *  * @throws IllegalStateException Thrown, when the channel is still open.  */ ;/**  * Deletes the file underlying this I/O channel.  *  * @throws IllegalStateException Thrown, when the channel is still open.  */ void deleteChannel().
true;public;0;1;/**  * Closes the channel and deletes the underlying file.  * For asynchronous implementations, this method waits until all pending requests are handled.  *  * @throws IOException Thrown, if an error occurred while waiting for pending requests.  */ ;/**  * Closes the channel and deletes the underlying file.  * For asynchronous implementations, this method waits until all pending requests are handled.  *  * @throws IOException Thrown, if an error occurred while waiting for pending requests.  */ public void closeAndDelete() throws IOException.
false;;0;1;;FileChannel getNioFileChannel().
true;public;0;3;/**  * Returns the path to the underlying temporary file.  * @return The path to the underlying temporary file..  */ ;/**  * Returns the path to the underlying temporary file.  * @return The path to the underlying temporary file..  */ public String getPath() {     return path.getAbsolutePath(). }
true;public;0;3;/**  * Returns the path to the underlying temporary file as a File.  * @return The path to the underlying temporary file as a File.  */ ;/**  * Returns the path to the underlying temporary file as a File.  * @return The path to the underlying temporary file as a File.  */ public File getPathFile() {     return path. }
false;;0;3;;int getThreadNum() {     return this.threadNum. }
false;public;1;9;;@Override public boolean equals(Object obj) {     if (obj instanceof ID) {         ID other = (ID) obj.         return this.path.equals(other.path) && this.threadNum == other.threadNum.     } else {         return false.     } }
false;public;0;4;;@Override public int hashCode() {     return path.hashCode(). }
false;public;0;4;;@Override public String toString() {     return path.getAbsolutePath(). }
false;private,static;1;5;;private static String randomString(Random random) {     byte[] bytes = new byte[RANDOM_BYTES_LENGTH].     random.nextBytes(bytes).     return StringUtils.byteToHexString(bytes). }
false;public;0;8;;public ID next() {     // The local counter is used to increment file names while the global counter is used     // for indexing the directory and associated read and write threads. This performs a     // round-robin among all spilling operators and avoids I/O bunching.     int threadNum = globalCounter.getAndIncrement() % paths.length.     String filename = String.format("%s.%06d.channel", namePrefix, (localCounter++)).     return new ID(new File(paths[threadNum], filename), threadNum). }
