commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;4;/**  * Returns the writer for {@link StateMetaInfoSnapshot}.  */ ;/**  * Returns the writer for {@link StateMetaInfoSnapshot}.  */ @Nonnull public static StateMetaInfoWriter getWriter() {     return CurrentWriterImpl.INSTANCE. }
true;public,static;2;18;/**  * Returns a reader for {@link StateMetaInfoSnapshot} with the requested state type and version number.  *  * @param readVersion the format version to read.  * @param stateTypeHint a hint about the expected type to read.  * @return the requested reader.  */ ;/**  * Returns a reader for {@link StateMetaInfoSnapshot} with the requested state type and version number.  *  * @param readVersion the format version to read.  * @param stateTypeHint a hint about the expected type to read.  * @return the requested reader.  */ @Nonnull public static StateMetaInfoReader getReader(int readVersion, @Nonnull StateTypeHint stateTypeHint) {     if (readVersion < 5) {         // versions before 5 still had different state meta info formats between keyed / operator state         switch(stateTypeHint) {             case KEYED_STATE:                 return getLegacyKeyedStateMetaInfoReader(readVersion).             case OPERATOR_STATE:                 return getLegacyOperatorStateMetaInfoReader(readVersion).             default:                 throw new IllegalArgumentException("Unsupported state type hint: " + stateTypeHint + " with version " + readVersion).         }     } else {         return getReader(readVersion).     } }
true;static;1;11;/**  * Returns a reader for {@link StateMetaInfoSnapshot} with the requested state type and version number.  *  * @param readVersion the format version to read.  * @return the requested reader.  */ ;/**  * Returns a reader for {@link StateMetaInfoSnapshot} with the requested state type and version number.  *  * @param readVersion the format version to read.  * @return the requested reader.  */ @Nonnull static StateMetaInfoReader getReader(int readVersion) {     switch(readVersion) {         case CURRENT_STATE_META_INFO_SNAPSHOT_VERSION:             return CurrentReaderImpl.INSTANCE.         case 5:             return V5ReaderImpl.INSTANCE.         default:             throw new IllegalArgumentException("Unsupported read version for state meta info: " + readVersion).     } }
false;private,static;1;15;;@Nonnull private static StateMetaInfoReader getLegacyKeyedStateMetaInfoReader(int readVersion) {     switch(readVersion) {         case 1:         case 2:             return LegacyStateMetaInfoReaders.KeyedBackendStateMetaInfoReaderV1V2.INSTANCE.         case 3:         case 4:             return LegacyStateMetaInfoReaders.KeyedBackendStateMetaInfoReaderV3V4.INSTANCE.         default:             // guard for future             throw new IllegalStateException("Unrecognized keyed backend state meta info writer version: " + readVersion).     } }
false;private,static;1;14;;@Nonnull private static StateMetaInfoReader getLegacyOperatorStateMetaInfoReader(int readVersion) {     switch(readVersion) {         case 1:             return LegacyStateMetaInfoReaders.OperatorBackendStateMetaInfoReaderV1.INSTANCE.         case 2:         case 3:             return LegacyStateMetaInfoReaders.OperatorBackendStateMetaInfoReaderV2V3.INSTANCE.         default:             // guard for future             throw new IllegalStateException("Unrecognized operator backend state meta info writer version: " + readVersion).     } }
false;public;2;25;;@Override public void writeStateMetaInfoSnapshot(@Nonnull StateMetaInfoSnapshot snapshot, @Nonnull DataOutputView outputView) throws IOException {     final Map<String, String> optionsMap = snapshot.getOptionsImmutable().     final Map<String, TypeSerializerSnapshot<?>> serializerConfigSnapshotsMap = snapshot.getSerializerSnapshotsImmutable().     outputView.writeUTF(snapshot.getName()).     outputView.writeInt(snapshot.getBackendStateType().ordinal()).     outputView.writeInt(optionsMap.size()).     for (Map.Entry<String, String> entry : optionsMap.entrySet()) {         outputView.writeUTF(entry.getKey()).         outputView.writeUTF(entry.getValue()).     }     outputView.writeInt(serializerConfigSnapshotsMap.size()).     for (Map.Entry<String, TypeSerializerSnapshot<?>> entry : serializerConfigSnapshotsMap.entrySet()) {         final String key = entry.getKey().         outputView.writeUTF(entry.getKey()).         TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(outputView, (TypeSerializerSnapshot) entry.getValue(), snapshot.getTypeSerializer(key)).     } }
false;public;2;29;;@Nonnull @Override public StateMetaInfoSnapshot readStateMetaInfoSnapshot(@Nonnull DataInputView inputView, @Nonnull ClassLoader userCodeClassLoader) throws IOException {     final String stateName = inputView.readUTF().     final StateMetaInfoSnapshot.BackendStateType stateType = StateMetaInfoSnapshot.BackendStateType.values()[inputView.readInt()].     final int numOptions = inputView.readInt().     HashMap<String, String> optionsMap = new HashMap<>(numOptions).     for (int i = 0. i < numOptions. ++i) {         String key = inputView.readUTF().         String value = inputView.readUTF().         optionsMap.put(key, value).     }     final int numSerializerConfigSnapshots = inputView.readInt().     final HashMap<String, TypeSerializerSnapshot<?>> serializerConfigsMap = new HashMap<>(numSerializerConfigSnapshots).     for (int i = 0. i < numSerializerConfigSnapshots. ++i) {         serializerConfigsMap.put(inputView.readUTF(), TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(inputView, userCodeClassLoader, null)).     }     return new StateMetaInfoSnapshot(stateName, stateType, optionsMap, serializerConfigsMap). }
false;public;2;35;;@Nonnull @Override public StateMetaInfoSnapshot readStateMetaInfoSnapshot(@Nonnull DataInputView inputView, @Nonnull ClassLoader userCodeClassLoader) throws IOException {     final String stateName = inputView.readUTF().     final StateMetaInfoSnapshot.BackendStateType stateType = StateMetaInfoSnapshot.BackendStateType.values()[inputView.readInt()].     final int numOptions = inputView.readInt().     HashMap<String, String> optionsMap = new HashMap<>(numOptions).     for (int i = 0. i < numOptions. ++i) {         String key = inputView.readUTF().         String value = inputView.readUTF().         optionsMap.put(key, value).     }     final int numSerializer = inputView.readInt().     final ArrayList<String> serializerKeys = new ArrayList<>(numSerializer).     final HashMap<String, TypeSerializerSnapshot<?>> serializerConfigsMap = new HashMap<>(numSerializer).     for (int i = 0. i < numSerializer. ++i) {         serializerKeys.add(inputView.readUTF()).     }     final List<Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> serializersWithConfig = TypeSerializerSerializationUtil.readSerializersAndConfigsWithResilience(inputView, userCodeClassLoader).     for (int i = 0. i < numSerializer. ++i) {         String key = serializerKeys.get(i).         final Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>> serializerConfigTuple = serializersWithConfig.get(i).         serializerConfigsMap.put(key, serializerConfigTuple.f1).     }     return new StateMetaInfoSnapshot(stateName, stateType, optionsMap, serializerConfigsMap). }
