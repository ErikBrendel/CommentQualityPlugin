commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public void open() throws IOException, MemoryAllocationException, InterruptedException {     this.hashJoin.open(this.secondInput, this.firstInput, buildSideOuterJoin). }
false;public;0;9;;@Override public void close() {     // close the join     this.hashJoin.close().     // free the memory     final List<MemorySegment> segments = this.hashJoin.getFreedMemory().     this.memManager.release(segments). }
false;public;2;61;;@Override public boolean callWithNextKey(FlatJoinFunction<V1, V2, O> matchFunction, Collector<O> collector) throws Exception {     if (this.hashJoin.nextRecord()) {         // we have a next record, get the iterators to the probe and build side values         final MutableObjectIterator<V2> buildSideIterator = this.hashJoin.getBuildSideIterator().         final V1 probeRecord = this.hashJoin.getCurrentProbeRecord().         V2 nextBuildSideRecord = buildSideIterator.next().         if (probeRecord != null && nextBuildSideRecord != null) {             V2 tmpRec.             // check if there is another build-side value             if ((tmpRec = buildSideIterator.next()) != null) {                 // more than one build-side value --> copy the probe side                 V1 probeCopy.                 probeCopy = this.probeSideSerializer.copy(probeRecord).                 // call match on the first pair                 matchFunction.join(probeCopy, nextBuildSideRecord, collector).                 // call match on the second pair                 probeCopy = this.probeSideSerializer.copy(probeRecord).                 matchFunction.join(probeCopy, tmpRec, collector).                 while (this.running && ((nextBuildSideRecord = buildSideIterator.next()) != null)) {                     // call match on the next pair                     // make sure we restore the value of the probe side record                     probeCopy = this.probeSideSerializer.copy(probeRecord).                     matchFunction.join(probeCopy, nextBuildSideRecord, collector).                 }             } else {                 // only single pair matches                 matchFunction.join(probeRecord, nextBuildSideRecord, collector).             }         } else {             // while probe side outer join, join current probe record with null.             if (probeSideOuterJoin && probeRecord != null && nextBuildSideRecord == null) {                 matchFunction.join(probeRecord, null, collector).             }             // and join with null.             if (buildSideOuterJoin && probeRecord == null && nextBuildSideRecord != null) {                 matchFunction.join(null, nextBuildSideRecord, collector).                 while (this.running && ((nextBuildSideRecord = buildSideIterator.next()) != null)) {                     matchFunction.join(null, nextBuildSideRecord, collector).                 }             }         }         return true.     } else {         return false.     } }
false;public;0;5;;@Override public void abort() {     this.running = false.     this.hashJoin.abort(). }
