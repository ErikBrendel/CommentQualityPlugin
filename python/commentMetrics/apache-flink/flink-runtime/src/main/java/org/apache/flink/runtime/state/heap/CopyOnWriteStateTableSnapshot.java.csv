commented;modifiers;parameterAmount;loc;comment;code
true;;0;3;/**  * Returns the internal version of the {@link CopyOnWriteStateTable} when this snapshot was created. This value must be used to  * tell the {@link CopyOnWriteStateTable} when to release this snapshot.  */ ;/**  * Returns the internal version of the {@link CopyOnWriteStateTable} when this snapshot was created. This value must be used to  * tell the {@link CopyOnWriteStateTable} when to release this snapshot.  */ int getSnapshotVersion() {     return snapshotVersion. }
true;public;0;32;/**  * Partitions the snapshot data by key-group. The algorithm first builds a histogram for the distribution of keys  * into key-groups. Then, the histogram is accumulated to obtain the boundaries of each key-group in an array.  * Last, we use the accumulated counts as write position pointers for the key-group's bins when reordering the  * entries by key-group. This operation is lazily performed before the first writing of a key-group.  *  * <p>As a possible future optimization, we could perform the repartitioning in-place, using a scheme similar to the  * cuckoo cycles in cuckoo hashing. This can trade some performance for a smaller memory footprint.  */ ;/**  * Partitions the snapshot data by key-group. The algorithm first builds a histogram for the distribution of keys  * into key-groups. Then, the histogram is accumulated to obtain the boundaries of each key-group in an array.  * Last, we use the accumulated counts as write position pointers for the key-group's bins when reordering the  * entries by key-group. This operation is lazily performed before the first writing of a key-group.  *  * <p>As a possible future optimization, we could perform the repartitioning in-place, using a scheme similar to the  * cuckoo cycles in cuckoo hashing. This can trade some performance for a smaller memory footprint.  */ @Nonnull @SuppressWarnings("unchecked") @Override public StateKeyGroupWriter getKeyGroupWriter() {     if (partitionedStateTableSnapshot == null) {         final InternalKeyContext<K> keyContext = owningStateTable.keyContext.         final int numberOfKeyGroups = keyContext.getNumberOfKeyGroups().         final KeyGroupRange keyGroupRange = keyContext.getKeyGroupRange().         ElementWriterFunction<CopyOnWriteStateTable.StateTableEntry<K, N, S>> elementWriterFunction = (element, dov) -> {             localNamespaceSerializer.serialize(element.namespace, dov).             localKeySerializer.serialize(element.key, dov).             localStateSerializer.serialize(element.state, dov).         }.         StateTableKeyGroupPartitioner<K, N, S> stateTableKeyGroupPartitioner = stateSnapshotTransformer != null ? new TransformingStateTableKeyGroupPartitioner<>(snapshotData, numberOfEntriesInSnapshotData, keyGroupRange, numberOfKeyGroups, elementWriterFunction, stateSnapshotTransformer) : new StateTableKeyGroupPartitioner<>(snapshotData, numberOfEntriesInSnapshotData, keyGroupRange, numberOfKeyGroups, elementWriterFunction).         partitionedStateTableSnapshot = stateTableKeyGroupPartitioner.partitionByKeyGroup().     }     return partitionedStateTableSnapshot. }
false;public;0;5;;@Nonnull @Override public StateMetaInfoSnapshot getMetaInfoSnapshot() {     return owningStateTable.metaInfo.snapshot(). }
false;public;0;4;;@Override public void release() {     owningStateTable.releaseSnapshot(this). }
true;;1;3;/**  * Returns true iff the given state table is the owner of this snapshot object.  */ ;/**  * Returns true iff the given state table is the owner of this snapshot object.  */ boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable) {     return stateTable == owningStateTable. }
false;protected;0;11;;@Override protected void reportAllElementKeyGroups() {     // In this step we i) 'flatten' the linked list of entries to a second array and ii) report key-groups.     int flattenIndex = 0.     for (CopyOnWriteStateTable.StateTableEntry<K, N, S> entry : partitioningDestination) {         while (null != entry) {             flattenIndex = tryAddToSource(flattenIndex, entry).             entry = entry.next.         }     } }
true;;2;6;/**  * Tries to append next entry to {@code partitioningSource} array snapshot and returns next index.  */ ;/**  * Tries to append next entry to {@code partitioningSource} array snapshot and returns next index.  */ int tryAddToSource(int currentIndex, CopyOnWriteStateTable.StateTableEntry<K, N, S> entry) {     final int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(entry.key, totalKeyGroups).     reportKeyGroupOfElementAtIndex(currentIndex, keyGroup).     partitioningSource[currentIndex] = entry.     return currentIndex + 1. }
false;;2;8;;@Override int tryAddToSource(int currentIndex, CopyOnWriteStateTable.StateTableEntry<K, N, S> entry) {     CopyOnWriteStateTable.StateTableEntry<K, N, S> filteredEntry = filterEntry(entry).     if (filteredEntry != null) {         return super.tryAddToSource(currentIndex, filteredEntry).     }     return currentIndex. }
false;private;1;13;;private CopyOnWriteStateTable.StateTableEntry<K, N, S> filterEntry(CopyOnWriteStateTable.StateTableEntry<K, N, S> entry) {     S transformedValue = stateSnapshotTransformer.filterOrTransform(entry.state).     if (transformedValue != null) {         CopyOnWriteStateTable.StateTableEntry<K, N, S> filteredEntry = entry.         if (transformedValue != entry.state) {             filteredEntry = new CopyOnWriteStateTable.StateTableEntry<>(entry, entry.entryVersion).             filteredEntry.state = transformedValue.         }         return filteredEntry.     }     return null. }
