# id;timestamp;commentText;codeText;commentWords;codeWords
CopyOnWriteStateTableSnapshot -> StateTableKeyGroupPartitioner -> int tryAddToSource(int currentIndex, CopyOnWriteStateTable.StateTableEntry<K, N, S> entry);1533318024;Tries to append next entry to {@code partitioningSource} array snapshot and returns next index.;int tryAddToSource(int currentIndex, CopyOnWriteStateTable.StateTableEntry<K, N, S> entry) {_			final int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(entry.key, totalKeyGroups)__			reportKeyGroupOfElementAtIndex(currentIndex, keyGroup)__			partitioningSource[currentIndex] = entry__			return currentIndex + 1__		};tries,to,append,next,entry,to,code,partitioning,source,array,snapshot,and,returns,next,index;int,try,add,to,source,int,current,index,copy,on,write,state,table,state,table,entry,k,n,s,entry,final,int,key,group,key,group,range,assignment,assign,to,key,group,entry,key,total,key,groups,report,key,group,of,element,at,index,current,index,key,group,partitioning,source,current,index,entry,return,current,index,1
CopyOnWriteStateTableSnapshot -> StateTableKeyGroupPartitioner -> int tryAddToSource(int currentIndex, CopyOnWriteStateTable.StateTableEntry<K, N, S> entry);1534408054;Tries to append next entry to {@code partitioningSource} array snapshot and returns next index.;int tryAddToSource(int currentIndex, CopyOnWriteStateTable.StateTableEntry<K, N, S> entry) {_			final int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(entry.key, totalKeyGroups)__			reportKeyGroupOfElementAtIndex(currentIndex, keyGroup)__			partitioningSource[currentIndex] = entry__			return currentIndex + 1__		};tries,to,append,next,entry,to,code,partitioning,source,array,snapshot,and,returns,next,index;int,try,add,to,source,int,current,index,copy,on,write,state,table,state,table,entry,k,n,s,entry,final,int,key,group,key,group,range,assignment,assign,to,key,group,entry,key,total,key,groups,report,key,group,of,element,at,index,current,index,key,group,partitioning,source,current,index,entry,return,current,index,1
CopyOnWriteStateTableSnapshot -> StateTableKeyGroupPartitioner -> int tryAddToSource(int currentIndex, CopyOnWriteStateTable.StateTableEntry<K, N, S> entry);1548440094;Tries to append next entry to {@code partitioningSource} array snapshot and returns next index.;int tryAddToSource(int currentIndex, CopyOnWriteStateTable.StateTableEntry<K, N, S> entry) {_			final int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(entry.key, totalKeyGroups)__			reportKeyGroupOfElementAtIndex(currentIndex, keyGroup)__			partitioningSource[currentIndex] = entry__			return currentIndex + 1__		};tries,to,append,next,entry,to,code,partitioning,source,array,snapshot,and,returns,next,index;int,try,add,to,source,int,current,index,copy,on,write,state,table,state,table,entry,k,n,s,entry,final,int,key,group,key,group,range,assignment,assign,to,key,group,entry,key,total,key,groups,report,key,group,of,element,at,index,current,index,key,group,partitioning,source,current,index,entry,return,current,index,1
CopyOnWriteStateTableSnapshot -> int getSnapshotVersion();1489685642;Returns the internal version of the {@link CopyOnWriteStateTable} when this snapshot was created. This value must be used to_tell the {@link CopyOnWriteStateTable} when to release this snapshot.;int getSnapshotVersion() {_		return snapshotVersion__	};returns,the,internal,version,of,the,link,copy,on,write,state,table,when,this,snapshot,was,created,this,value,must,be,used,to,tell,the,link,copy,on,write,state,table,when,to,release,this,snapshot;int,get,snapshot,version,return,snapshot,version
CopyOnWriteStateTableSnapshot -> int getSnapshotVersion();1490721653;Returns the internal version of the {@link CopyOnWriteStateTable} when this snapshot was created. This value must be used to_tell the {@link CopyOnWriteStateTable} when to release this snapshot.;int getSnapshotVersion() {_		return snapshotVersion__	};returns,the,internal,version,of,the,link,copy,on,write,state,table,when,this,snapshot,was,created,this,value,must,be,used,to,tell,the,link,copy,on,write,state,table,when,to,release,this,snapshot;int,get,snapshot,version,return,snapshot,version
CopyOnWriteStateTableSnapshot -> int getSnapshotVersion();1529089579;Returns the internal version of the {@link CopyOnWriteStateTable} when this snapshot was created. This value must be used to_tell the {@link CopyOnWriteStateTable} when to release this snapshot.;int getSnapshotVersion() {_		return snapshotVersion__	};returns,the,internal,version,of,the,link,copy,on,write,state,table,when,this,snapshot,was,created,this,value,must,be,used,to,tell,the,link,copy,on,write,state,table,when,to,release,this,snapshot;int,get,snapshot,version,return,snapshot,version
CopyOnWriteStateTableSnapshot -> int getSnapshotVersion();1529307900;Returns the internal version of the {@link CopyOnWriteStateTable} when this snapshot was created. This value must be used to_tell the {@link CopyOnWriteStateTable} when to release this snapshot.;int getSnapshotVersion() {_		return snapshotVersion__	};returns,the,internal,version,of,the,link,copy,on,write,state,table,when,this,snapshot,was,created,this,value,must,be,used,to,tell,the,link,copy,on,write,state,table,when,to,release,this,snapshot;int,get,snapshot,version,return,snapshot,version
CopyOnWriteStateTableSnapshot -> int getSnapshotVersion();1531771917;Returns the internal version of the {@link CopyOnWriteStateTable} when this snapshot was created. This value must be used to_tell the {@link CopyOnWriteStateTable} when to release this snapshot.;int getSnapshotVersion() {_		return snapshotVersion__	};returns,the,internal,version,of,the,link,copy,on,write,state,table,when,this,snapshot,was,created,this,value,must,be,used,to,tell,the,link,copy,on,write,state,table,when,to,release,this,snapshot;int,get,snapshot,version,return,snapshot,version
CopyOnWriteStateTableSnapshot -> int getSnapshotVersion();1533318024;Returns the internal version of the {@link CopyOnWriteStateTable} when this snapshot was created. This value must be used to_tell the {@link CopyOnWriteStateTable} when to release this snapshot.;int getSnapshotVersion() {_		return snapshotVersion__	};returns,the,internal,version,of,the,link,copy,on,write,state,table,when,this,snapshot,was,created,this,value,must,be,used,to,tell,the,link,copy,on,write,state,table,when,to,release,this,snapshot;int,get,snapshot,version,return,snapshot,version
CopyOnWriteStateTableSnapshot -> int getSnapshotVersion();1534408054;Returns the internal version of the {@link CopyOnWriteStateTable} when this snapshot was created. This value must be used to_tell the {@link CopyOnWriteStateTable} when to release this snapshot.;int getSnapshotVersion() {_		return snapshotVersion__	};returns,the,internal,version,of,the,link,copy,on,write,state,table,when,this,snapshot,was,created,this,value,must,be,used,to,tell,the,link,copy,on,write,state,table,when,to,release,this,snapshot;int,get,snapshot,version,return,snapshot,version
CopyOnWriteStateTableSnapshot -> int getSnapshotVersion();1548440094;Returns the internal version of the {@link CopyOnWriteStateTable} when this snapshot was created. This value must be used to_tell the {@link CopyOnWriteStateTable} when to release this snapshot.;int getSnapshotVersion() {_		return snapshotVersion__	};returns,the,internal,version,of,the,link,copy,on,write,state,table,when,this,snapshot,was,created,this,value,must,be,used,to,tell,the,link,copy,on,write,state,table,when,to,release,this,snapshot;int,get,snapshot,version,return,snapshot,version
CopyOnWriteStateTableSnapshot -> boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable);1489685642;Returns true iff the given state table is the owner of this snapshot object.;boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable) {_		return stateTable == owningStateTable__	};returns,true,iff,the,given,state,table,is,the,owner,of,this,snapshot,object;boolean,is,owner,copy,on,write,state,table,k,n,s,state,table,return,state,table,owning,state,table
CopyOnWriteStateTableSnapshot -> boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable);1490721653;Returns true iff the given state table is the owner of this snapshot object.;boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable) {_		return stateTable == owningStateTable__	};returns,true,iff,the,given,state,table,is,the,owner,of,this,snapshot,object;boolean,is,owner,copy,on,write,state,table,k,n,s,state,table,return,state,table,owning,state,table
CopyOnWriteStateTableSnapshot -> boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable);1529089579;Returns true iff the given state table is the owner of this snapshot object.;boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable) {_		return stateTable == owningStateTable__	};returns,true,iff,the,given,state,table,is,the,owner,of,this,snapshot,object;boolean,is,owner,copy,on,write,state,table,k,n,s,state,table,return,state,table,owning,state,table
CopyOnWriteStateTableSnapshot -> boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable);1529307900;Returns true iff the given state table is the owner of this snapshot object.;boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable) {_		return stateTable == owningStateTable__	};returns,true,iff,the,given,state,table,is,the,owner,of,this,snapshot,object;boolean,is,owner,copy,on,write,state,table,k,n,s,state,table,return,state,table,owning,state,table
CopyOnWriteStateTableSnapshot -> boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable);1531771917;Returns true iff the given state table is the owner of this snapshot object.;boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable) {_		return stateTable == owningStateTable__	};returns,true,iff,the,given,state,table,is,the,owner,of,this,snapshot,object;boolean,is,owner,copy,on,write,state,table,k,n,s,state,table,return,state,table,owning,state,table
CopyOnWriteStateTableSnapshot -> boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable);1533318024;Returns true iff the given state table is the owner of this snapshot object.;boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable) {_		return stateTable == owningStateTable__	};returns,true,iff,the,given,state,table,is,the,owner,of,this,snapshot,object;boolean,is,owner,copy,on,write,state,table,k,n,s,state,table,return,state,table,owning,state,table
CopyOnWriteStateTableSnapshot -> boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable);1534408054;Returns true iff the given state table is the owner of this snapshot object.;boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable) {_		return stateTable == owningStateTable__	};returns,true,iff,the,given,state,table,is,the,owner,of,this,snapshot,object;boolean,is,owner,copy,on,write,state,table,k,n,s,state,table,return,state,table,owning,state,table
CopyOnWriteStateTableSnapshot -> boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable);1548440094;Returns true iff the given state table is the owner of this snapshot object.;boolean isOwner(CopyOnWriteStateTable<K, N, S> stateTable) {_		return stateTable == owningStateTable__	};returns,true,iff,the,given,state,table,is,the,owner,of,this,snapshot,object;boolean,is,owner,copy,on,write,state,table,k,n,s,state,table,return,state,table,owning,state,table
CopyOnWriteStateTableSnapshot -> @SuppressWarnings("unchecked") 	private void partitionEntriesByKeyGroup();1489685642;Partitions the snapshot data by key-group. The algorithm first builds a histogram for the distribution of keys_into key-groups. Then, the histogram is accumulated to obtain the boundaries of each key-group in an array._Last, we use the accumulated counts as write position pointers for the key-group's bins when reordering the_entries by key-group. This operation is lazily performed before the first writing of a key-group._<p>_As a possible future optimization, we could perform the repartitioning in-place, using a scheme similar to the_cuckoo cycles in cuckoo hashing. This can trade some performance for a smaller memory footprint.;@SuppressWarnings("unchecked")_	private void partitionEntriesByKeyGroup() {__		_		if (null != keyGroupOffsets) {_			return__		}__		final KeyGroupRange keyGroupRange = owningStateTable.keyContext.getKeyGroupRange()__		final int totalKeyGroups = owningStateTable.keyContext.getNumberOfKeyGroups()__		final int baseKgIdx = keyGroupRange.getStartKeyGroup()__		final int[] histogram = new int[keyGroupRange.getNumberOfKeyGroups() + 1]___		CopyOnWriteStateTable.StateTableEntry<K, N, S>[] unfold = new CopyOnWriteStateTable.StateTableEntry[stateTableSize]___		_		int unfoldIndex = 0__		for (CopyOnWriteStateTable.StateTableEntry<K, N, S> entry : snapshotData) {_			while (null != entry) {_				int effectiveKgIdx =_						KeyGroupRangeAssignment.computeKeyGroupForKeyHash(entry.key.hashCode(), totalKeyGroups) - baseKgIdx + 1__				++histogram[effectiveKgIdx]__				unfold[unfoldIndex++] = entry__				entry = entry.next__			}_		}__		_		for (int i = 1_ i < histogram.length_ ++i) {_			histogram[i] += histogram[i - 1]__		}__		_		for (CopyOnWriteStateTable.StateTableEntry<K, N, S> t : unfold) {_			int effectiveKgIdx =_					KeyGroupRangeAssignment.computeKeyGroupForKeyHash(t.key.hashCode(), totalKeyGroups) - baseKgIdx__			snapshotData[histogram[effectiveKgIdx]++] = t__		}__		_		this.keyGroupOffsets = histogram__	};partitions,the,snapshot,data,by,key,group,the,algorithm,first,builds,a,histogram,for,the,distribution,of,keys,into,key,groups,then,the,histogram,is,accumulated,to,obtain,the,boundaries,of,each,key,group,in,an,array,last,we,use,the,accumulated,counts,as,write,position,pointers,for,the,key,group,s,bins,when,reordering,the,entries,by,key,group,this,operation,is,lazily,performed,before,the,first,writing,of,a,key,group,p,as,a,possible,future,optimization,we,could,perform,the,repartitioning,in,place,using,a,scheme,similar,to,the,cuckoo,cycles,in,cuckoo,hashing,this,can,trade,some,performance,for,a,smaller,memory,footprint;suppress,warnings,unchecked,private,void,partition,entries,by,key,group,if,null,key,group,offsets,return,final,key,group,range,key,group,range,owning,state,table,key,context,get,key,group,range,final,int,total,key,groups,owning,state,table,key,context,get,number,of,key,groups,final,int,base,kg,idx,key,group,range,get,start,key,group,final,int,histogram,new,int,key,group,range,get,number,of,key,groups,1,copy,on,write,state,table,state,table,entry,k,n,s,unfold,new,copy,on,write,state,table,state,table,entry,state,table,size,int,unfold,index,0,for,copy,on,write,state,table,state,table,entry,k,n,s,entry,snapshot,data,while,null,entry,int,effective,kg,idx,key,group,range,assignment,compute,key,group,for,key,hash,entry,key,hash,code,total,key,groups,base,kg,idx,1,histogram,effective,kg,idx,unfold,unfold,index,entry,entry,entry,next,for,int,i,1,i,histogram,length,i,histogram,i,histogram,i,1,for,copy,on,write,state,table,state,table,entry,k,n,s,t,unfold,int,effective,kg,idx,key,group,range,assignment,compute,key,group,for,key,hash,t,key,hash,code,total,key,groups,base,kg,idx,snapshot,data,histogram,effective,kg,idx,t,this,key,group,offsets,histogram
CopyOnWriteStateTableSnapshot -> @SuppressWarnings("unchecked") 	private void partitionEntriesByKeyGroup();1490721653;Partitions the snapshot data by key-group. The algorithm first builds a histogram for the distribution of keys_into key-groups. Then, the histogram is accumulated to obtain the boundaries of each key-group in an array._Last, we use the accumulated counts as write position pointers for the key-group's bins when reordering the_entries by key-group. This operation is lazily performed before the first writing of a key-group._<p>_As a possible future optimization, we could perform the repartitioning in-place, using a scheme similar to the_cuckoo cycles in cuckoo hashing. This can trade some performance for a smaller memory footprint.;@SuppressWarnings("unchecked")_	private void partitionEntriesByKeyGroup() {__		_		if (null != keyGroupOffsets) {_			return__		}__		final KeyGroupRange keyGroupRange = owningStateTable.keyContext.getKeyGroupRange()__		final int totalKeyGroups = owningStateTable.keyContext.getNumberOfKeyGroups()__		final int baseKgIdx = keyGroupRange.getStartKeyGroup()__		final int[] histogram = new int[keyGroupRange.getNumberOfKeyGroups() + 1]___		CopyOnWriteStateTable.StateTableEntry<K, N, S>[] unfold = new CopyOnWriteStateTable.StateTableEntry[stateTableSize]___		_		int unfoldIndex = 0__		for (CopyOnWriteStateTable.StateTableEntry<K, N, S> entry : snapshotData) {_			while (null != entry) {_				int effectiveKgIdx =_						KeyGroupRangeAssignment.computeKeyGroupForKeyHash(entry.key.hashCode(), totalKeyGroups) - baseKgIdx + 1__				++histogram[effectiveKgIdx]__				unfold[unfoldIndex++] = entry__				entry = entry.next__			}_		}__		_		for (int i = 1_ i < histogram.length_ ++i) {_			histogram[i] += histogram[i - 1]__		}__		_		for (CopyOnWriteStateTable.StateTableEntry<K, N, S> t : unfold) {_			int effectiveKgIdx =_					KeyGroupRangeAssignment.computeKeyGroupForKeyHash(t.key.hashCode(), totalKeyGroups) - baseKgIdx__			snapshotData[histogram[effectiveKgIdx]++] = t__		}__		_		this.keyGroupOffsets = histogram__	};partitions,the,snapshot,data,by,key,group,the,algorithm,first,builds,a,histogram,for,the,distribution,of,keys,into,key,groups,then,the,histogram,is,accumulated,to,obtain,the,boundaries,of,each,key,group,in,an,array,last,we,use,the,accumulated,counts,as,write,position,pointers,for,the,key,group,s,bins,when,reordering,the,entries,by,key,group,this,operation,is,lazily,performed,before,the,first,writing,of,a,key,group,p,as,a,possible,future,optimization,we,could,perform,the,repartitioning,in,place,using,a,scheme,similar,to,the,cuckoo,cycles,in,cuckoo,hashing,this,can,trade,some,performance,for,a,smaller,memory,footprint;suppress,warnings,unchecked,private,void,partition,entries,by,key,group,if,null,key,group,offsets,return,final,key,group,range,key,group,range,owning,state,table,key,context,get,key,group,range,final,int,total,key,groups,owning,state,table,key,context,get,number,of,key,groups,final,int,base,kg,idx,key,group,range,get,start,key,group,final,int,histogram,new,int,key,group,range,get,number,of,key,groups,1,copy,on,write,state,table,state,table,entry,k,n,s,unfold,new,copy,on,write,state,table,state,table,entry,state,table,size,int,unfold,index,0,for,copy,on,write,state,table,state,table,entry,k,n,s,entry,snapshot,data,while,null,entry,int,effective,kg,idx,key,group,range,assignment,compute,key,group,for,key,hash,entry,key,hash,code,total,key,groups,base,kg,idx,1,histogram,effective,kg,idx,unfold,unfold,index,entry,entry,entry,next,for,int,i,1,i,histogram,length,i,histogram,i,histogram,i,1,for,copy,on,write,state,table,state,table,entry,k,n,s,t,unfold,int,effective,kg,idx,key,group,range,assignment,compute,key,group,for,key,hash,t,key,hash,code,total,key,groups,base,kg,idx,snapshot,data,histogram,effective,kg,idx,t,this,key,group,offsets,histogram
CopyOnWriteStateTableSnapshot -> @Nonnull 	@SuppressWarnings("unchecked") 	@Override 	public StateKeyGroupWriter getKeyGroupWriter();1531771917;Partitions the snapshot data by key-group. The algorithm first builds a histogram for the distribution of keys_into key-groups. Then, the histogram is accumulated to obtain the boundaries of each key-group in an array._Last, we use the accumulated counts as write position pointers for the key-group's bins when reordering the_entries by key-group. This operation is lazily performed before the first writing of a key-group._<p>_As a possible future optimization, we could perform the repartitioning in-place, using a scheme similar to the_cuckoo cycles in cuckoo hashing. This can trade some performance for a smaller memory footprint.;@Nonnull_	@SuppressWarnings("unchecked")_	@Override_	public StateKeyGroupWriter getKeyGroupWriter() {__		if (partitionedStateTableSnapshot == null) {__			final InternalKeyContext<K> keyContext = owningStateTable.keyContext__			final KeyGroupRange keyGroupRange = keyContext.getKeyGroupRange()__			final int numberOfKeyGroups = keyContext.getNumberOfKeyGroups()___			final StateTableKeyGroupPartitioner<K, N, S> keyGroupPartitioner = new StateTableKeyGroupPartitioner<>(_				snapshotData,_				numberOfEntriesInSnapshotData,_				keyGroupRange,_				numberOfKeyGroups,_				(element, dov) -> {_					localNamespaceSerializer.serialize(element.namespace, dov)__					localKeySerializer.serialize(element.key, dov)__					localStateSerializer.serialize(element.state, dov)__				})___			partitionedStateTableSnapshot = keyGroupPartitioner.partitionByKeyGroup()__		}__		return partitionedStateTableSnapshot__	};partitions,the,snapshot,data,by,key,group,the,algorithm,first,builds,a,histogram,for,the,distribution,of,keys,into,key,groups,then,the,histogram,is,accumulated,to,obtain,the,boundaries,of,each,key,group,in,an,array,last,we,use,the,accumulated,counts,as,write,position,pointers,for,the,key,group,s,bins,when,reordering,the,entries,by,key,group,this,operation,is,lazily,performed,before,the,first,writing,of,a,key,group,p,as,a,possible,future,optimization,we,could,perform,the,repartitioning,in,place,using,a,scheme,similar,to,the,cuckoo,cycles,in,cuckoo,hashing,this,can,trade,some,performance,for,a,smaller,memory,footprint;nonnull,suppress,warnings,unchecked,override,public,state,key,group,writer,get,key,group,writer,if,partitioned,state,table,snapshot,null,final,internal,key,context,k,key,context,owning,state,table,key,context,final,key,group,range,key,group,range,key,context,get,key,group,range,final,int,number,of,key,groups,key,context,get,number,of,key,groups,final,state,table,key,group,partitioner,k,n,s,key,group,partitioner,new,state,table,key,group,partitioner,snapshot,data,number,of,entries,in,snapshot,data,key,group,range,number,of,key,groups,element,dov,local,namespace,serializer,serialize,element,namespace,dov,local,key,serializer,serialize,element,key,dov,local,state,serializer,serialize,element,state,dov,partitioned,state,table,snapshot,key,group,partitioner,partition,by,key,group,return,partitioned,state,table,snapshot
CopyOnWriteStateTableSnapshot -> @Nonnull 	@SuppressWarnings("unchecked") 	@Override 	public StateKeyGroupWriter getKeyGroupWriter();1533318024;Partitions the snapshot data by key-group. The algorithm first builds a histogram for the distribution of keys_into key-groups. Then, the histogram is accumulated to obtain the boundaries of each key-group in an array._Last, we use the accumulated counts as write position pointers for the key-group's bins when reordering the_entries by key-group. This operation is lazily performed before the first writing of a key-group.__<p>As a possible future optimization, we could perform the repartitioning in-place, using a scheme similar to the_cuckoo cycles in cuckoo hashing. This can trade some performance for a smaller memory footprint.;@Nonnull_	@SuppressWarnings("unchecked")_	@Override_	public StateKeyGroupWriter getKeyGroupWriter() {_		if (partitionedStateTableSnapshot == null) {_			final InternalKeyContext<K> keyContext = owningStateTable.keyContext__			final int numberOfKeyGroups = keyContext.getNumberOfKeyGroups()__			final KeyGroupRange keyGroupRange = keyContext.getKeyGroupRange()__			ElementWriterFunction<CopyOnWriteStateTable.StateTableEntry<K, N, S>> elementWriterFunction =_				(element, dov) -> {_					localNamespaceSerializer.serialize(element.namespace, dov)__					localKeySerializer.serialize(element.key, dov)__					localStateSerializer.serialize(element.state, dov)__				}__			StateSnapshotTransformer<S> stateSnapshotTransformer = owningStateTable.metaInfo.getSnapshotTransformer()__			StateTableKeyGroupPartitioner<K, N, S> stateTableKeyGroupPartitioner = stateSnapshotTransformer != null ?_				new TransformingStateTableKeyGroupPartitioner<>(_					snapshotData,_					numberOfEntriesInSnapshotData,_					keyGroupRange,_					numberOfKeyGroups,_					elementWriterFunction,_					stateSnapshotTransformer) :_				new StateTableKeyGroupPartitioner<>(_					snapshotData,_					numberOfEntriesInSnapshotData,_					keyGroupRange,_					numberOfKeyGroups,_					elementWriterFunction)__			partitionedStateTableSnapshot = stateTableKeyGroupPartitioner.partitionByKeyGroup()__		}_		return partitionedStateTableSnapshot__	};partitions,the,snapshot,data,by,key,group,the,algorithm,first,builds,a,histogram,for,the,distribution,of,keys,into,key,groups,then,the,histogram,is,accumulated,to,obtain,the,boundaries,of,each,key,group,in,an,array,last,we,use,the,accumulated,counts,as,write,position,pointers,for,the,key,group,s,bins,when,reordering,the,entries,by,key,group,this,operation,is,lazily,performed,before,the,first,writing,of,a,key,group,p,as,a,possible,future,optimization,we,could,perform,the,repartitioning,in,place,using,a,scheme,similar,to,the,cuckoo,cycles,in,cuckoo,hashing,this,can,trade,some,performance,for,a,smaller,memory,footprint;nonnull,suppress,warnings,unchecked,override,public,state,key,group,writer,get,key,group,writer,if,partitioned,state,table,snapshot,null,final,internal,key,context,k,key,context,owning,state,table,key,context,final,int,number,of,key,groups,key,context,get,number,of,key,groups,final,key,group,range,key,group,range,key,context,get,key,group,range,element,writer,function,copy,on,write,state,table,state,table,entry,k,n,s,element,writer,function,element,dov,local,namespace,serializer,serialize,element,namespace,dov,local,key,serializer,serialize,element,key,dov,local,state,serializer,serialize,element,state,dov,state,snapshot,transformer,s,state,snapshot,transformer,owning,state,table,meta,info,get,snapshot,transformer,state,table,key,group,partitioner,k,n,s,state,table,key,group,partitioner,state,snapshot,transformer,null,new,transforming,state,table,key,group,partitioner,snapshot,data,number,of,entries,in,snapshot,data,key,group,range,number,of,key,groups,element,writer,function,state,snapshot,transformer,new,state,table,key,group,partitioner,snapshot,data,number,of,entries,in,snapshot,data,key,group,range,number,of,key,groups,element,writer,function,partitioned,state,table,snapshot,state,table,key,group,partitioner,partition,by,key,group,return,partitioned,state,table,snapshot
CopyOnWriteStateTableSnapshot -> @Nonnull 	@SuppressWarnings("unchecked") 	@Override 	public StateKeyGroupWriter getKeyGroupWriter();1534408054;Partitions the snapshot data by key-group. The algorithm first builds a histogram for the distribution of keys_into key-groups. Then, the histogram is accumulated to obtain the boundaries of each key-group in an array._Last, we use the accumulated counts as write position pointers for the key-group's bins when reordering the_entries by key-group. This operation is lazily performed before the first writing of a key-group.__<p>As a possible future optimization, we could perform the repartitioning in-place, using a scheme similar to the_cuckoo cycles in cuckoo hashing. This can trade some performance for a smaller memory footprint.;@Nonnull_	@SuppressWarnings("unchecked")_	@Override_	public StateKeyGroupWriter getKeyGroupWriter() {_		if (partitionedStateTableSnapshot == null) {_			final InternalKeyContext<K> keyContext = owningStateTable.keyContext__			final int numberOfKeyGroups = keyContext.getNumberOfKeyGroups()__			final KeyGroupRange keyGroupRange = keyContext.getKeyGroupRange()__			ElementWriterFunction<CopyOnWriteStateTable.StateTableEntry<K, N, S>> elementWriterFunction =_				(element, dov) -> {_					localNamespaceSerializer.serialize(element.namespace, dov)__					localKeySerializer.serialize(element.key, dov)__					localStateSerializer.serialize(element.state, dov)__				}__			StateSnapshotTransformer<S> stateSnapshotTransformer = owningStateTable.metaInfo.getSnapshotTransformer()__			StateTableKeyGroupPartitioner<K, N, S> stateTableKeyGroupPartitioner = stateSnapshotTransformer != null ?_				new TransformingStateTableKeyGroupPartitioner<>(_					snapshotData,_					numberOfEntriesInSnapshotData,_					keyGroupRange,_					numberOfKeyGroups,_					elementWriterFunction,_					stateSnapshotTransformer) :_				new StateTableKeyGroupPartitioner<>(_					snapshotData,_					numberOfEntriesInSnapshotData,_					keyGroupRange,_					numberOfKeyGroups,_					elementWriterFunction)__			partitionedStateTableSnapshot = stateTableKeyGroupPartitioner.partitionByKeyGroup()__		}_		return partitionedStateTableSnapshot__	};partitions,the,snapshot,data,by,key,group,the,algorithm,first,builds,a,histogram,for,the,distribution,of,keys,into,key,groups,then,the,histogram,is,accumulated,to,obtain,the,boundaries,of,each,key,group,in,an,array,last,we,use,the,accumulated,counts,as,write,position,pointers,for,the,key,group,s,bins,when,reordering,the,entries,by,key,group,this,operation,is,lazily,performed,before,the,first,writing,of,a,key,group,p,as,a,possible,future,optimization,we,could,perform,the,repartitioning,in,place,using,a,scheme,similar,to,the,cuckoo,cycles,in,cuckoo,hashing,this,can,trade,some,performance,for,a,smaller,memory,footprint;nonnull,suppress,warnings,unchecked,override,public,state,key,group,writer,get,key,group,writer,if,partitioned,state,table,snapshot,null,final,internal,key,context,k,key,context,owning,state,table,key,context,final,int,number,of,key,groups,key,context,get,number,of,key,groups,final,key,group,range,key,group,range,key,context,get,key,group,range,element,writer,function,copy,on,write,state,table,state,table,entry,k,n,s,element,writer,function,element,dov,local,namespace,serializer,serialize,element,namespace,dov,local,key,serializer,serialize,element,key,dov,local,state,serializer,serialize,element,state,dov,state,snapshot,transformer,s,state,snapshot,transformer,owning,state,table,meta,info,get,snapshot,transformer,state,table,key,group,partitioner,k,n,s,state,table,key,group,partitioner,state,snapshot,transformer,null,new,transforming,state,table,key,group,partitioner,snapshot,data,number,of,entries,in,snapshot,data,key,group,range,number,of,key,groups,element,writer,function,state,snapshot,transformer,new,state,table,key,group,partitioner,snapshot,data,number,of,entries,in,snapshot,data,key,group,range,number,of,key,groups,element,writer,function,partitioned,state,table,snapshot,state,table,key,group,partitioner,partition,by,key,group,return,partitioned,state,table,snapshot
CopyOnWriteStateTableSnapshot -> @Nonnull 	@SuppressWarnings("unchecked") 	@Override 	public StateKeyGroupWriter getKeyGroupWriter();1548440094;Partitions the snapshot data by key-group. The algorithm first builds a histogram for the distribution of keys_into key-groups. Then, the histogram is accumulated to obtain the boundaries of each key-group in an array._Last, we use the accumulated counts as write position pointers for the key-group's bins when reordering the_entries by key-group. This operation is lazily performed before the first writing of a key-group.__<p>As a possible future optimization, we could perform the repartitioning in-place, using a scheme similar to the_cuckoo cycles in cuckoo hashing. This can trade some performance for a smaller memory footprint.;@Nonnull_	@SuppressWarnings("unchecked")_	@Override_	public StateKeyGroupWriter getKeyGroupWriter() {_		if (partitionedStateTableSnapshot == null) {_			final InternalKeyContext<K> keyContext = owningStateTable.keyContext__			final int numberOfKeyGroups = keyContext.getNumberOfKeyGroups()__			final KeyGroupRange keyGroupRange = keyContext.getKeyGroupRange()__			ElementWriterFunction<CopyOnWriteStateTable.StateTableEntry<K, N, S>> elementWriterFunction =_				(element, dov) -> {_					localNamespaceSerializer.serialize(element.namespace, dov)__					localKeySerializer.serialize(element.key, dov)__					localStateSerializer.serialize(element.state, dov)__				}__			StateTableKeyGroupPartitioner<K, N, S> stateTableKeyGroupPartitioner = stateSnapshotTransformer != null ?_				new TransformingStateTableKeyGroupPartitioner<>(_					snapshotData,_					numberOfEntriesInSnapshotData,_					keyGroupRange,_					numberOfKeyGroups,_					elementWriterFunction,_					stateSnapshotTransformer) :_				new StateTableKeyGroupPartitioner<>(_					snapshotData,_					numberOfEntriesInSnapshotData,_					keyGroupRange,_					numberOfKeyGroups,_					elementWriterFunction)__			partitionedStateTableSnapshot = stateTableKeyGroupPartitioner.partitionByKeyGroup()__		}_		return partitionedStateTableSnapshot__	};partitions,the,snapshot,data,by,key,group,the,algorithm,first,builds,a,histogram,for,the,distribution,of,keys,into,key,groups,then,the,histogram,is,accumulated,to,obtain,the,boundaries,of,each,key,group,in,an,array,last,we,use,the,accumulated,counts,as,write,position,pointers,for,the,key,group,s,bins,when,reordering,the,entries,by,key,group,this,operation,is,lazily,performed,before,the,first,writing,of,a,key,group,p,as,a,possible,future,optimization,we,could,perform,the,repartitioning,in,place,using,a,scheme,similar,to,the,cuckoo,cycles,in,cuckoo,hashing,this,can,trade,some,performance,for,a,smaller,memory,footprint;nonnull,suppress,warnings,unchecked,override,public,state,key,group,writer,get,key,group,writer,if,partitioned,state,table,snapshot,null,final,internal,key,context,k,key,context,owning,state,table,key,context,final,int,number,of,key,groups,key,context,get,number,of,key,groups,final,key,group,range,key,group,range,key,context,get,key,group,range,element,writer,function,copy,on,write,state,table,state,table,entry,k,n,s,element,writer,function,element,dov,local,namespace,serializer,serialize,element,namespace,dov,local,key,serializer,serialize,element,key,dov,local,state,serializer,serialize,element,state,dov,state,table,key,group,partitioner,k,n,s,state,table,key,group,partitioner,state,snapshot,transformer,null,new,transforming,state,table,key,group,partitioner,snapshot,data,number,of,entries,in,snapshot,data,key,group,range,number,of,key,groups,element,writer,function,state,snapshot,transformer,new,state,table,key,group,partitioner,snapshot,data,number,of,entries,in,snapshot,data,key,group,range,number,of,key,groups,element,writer,function,partitioned,state,table,snapshot,state,table,key,group,partitioner,partition,by,key,group,return,partitioned,state,table,snapshot
CopyOnWriteStateTableSnapshot -> @Nonnull 	@SuppressWarnings("unchecked") 	@Override 	public KeyGroupPartitionedSnapshot partitionByKeyGroup();1529089579;Partitions the snapshot data by key-group. The algorithm first builds a histogram for the distribution of keys_into key-groups. Then, the histogram is accumulated to obtain the boundaries of each key-group in an array._Last, we use the accumulated counts as write position pointers for the key-group's bins when reordering the_entries by key-group. This operation is lazily performed before the first writing of a key-group._<p>_As a possible future optimization, we could perform the repartitioning in-place, using a scheme similar to the_cuckoo cycles in cuckoo hashing. This can trade some performance for a smaller memory footprint.;@Nonnull_	@SuppressWarnings("unchecked")_	@Override_	public KeyGroupPartitionedSnapshot partitionByKeyGroup() {__		if (partitionedStateTableSnapshot == null) {__			final InternalKeyContext<K> keyContext = owningStateTable.keyContext__			final KeyGroupRange keyGroupRange = keyContext.getKeyGroupRange()__			final int numberOfKeyGroups = keyContext.getNumberOfKeyGroups()___			final StateTableKeyGroupPartitioner<K, N, S> keyGroupPartitioner = new StateTableKeyGroupPartitioner<>(_				snapshotData,_				numberOfEntriesInSnapshotData,_				keyGroupRange,_				numberOfKeyGroups,_				(element, dov) -> {_					localNamespaceSerializer.serialize(element.namespace, dov)__					localKeySerializer.serialize(element.key, dov)__					localStateSerializer.serialize(element.state, dov)__				})___			partitionedStateTableSnapshot = keyGroupPartitioner.partitionByKeyGroup()__		}__		return partitionedStateTableSnapshot__	};partitions,the,snapshot,data,by,key,group,the,algorithm,first,builds,a,histogram,for,the,distribution,of,keys,into,key,groups,then,the,histogram,is,accumulated,to,obtain,the,boundaries,of,each,key,group,in,an,array,last,we,use,the,accumulated,counts,as,write,position,pointers,for,the,key,group,s,bins,when,reordering,the,entries,by,key,group,this,operation,is,lazily,performed,before,the,first,writing,of,a,key,group,p,as,a,possible,future,optimization,we,could,perform,the,repartitioning,in,place,using,a,scheme,similar,to,the,cuckoo,cycles,in,cuckoo,hashing,this,can,trade,some,performance,for,a,smaller,memory,footprint;nonnull,suppress,warnings,unchecked,override,public,key,group,partitioned,snapshot,partition,by,key,group,if,partitioned,state,table,snapshot,null,final,internal,key,context,k,key,context,owning,state,table,key,context,final,key,group,range,key,group,range,key,context,get,key,group,range,final,int,number,of,key,groups,key,context,get,number,of,key,groups,final,state,table,key,group,partitioner,k,n,s,key,group,partitioner,new,state,table,key,group,partitioner,snapshot,data,number,of,entries,in,snapshot,data,key,group,range,number,of,key,groups,element,dov,local,namespace,serializer,serialize,element,namespace,dov,local,key,serializer,serialize,element,key,dov,local,state,serializer,serialize,element,state,dov,partitioned,state,table,snapshot,key,group,partitioner,partition,by,key,group,return,partitioned,state,table,snapshot
CopyOnWriteStateTableSnapshot -> @Nonnull 	@SuppressWarnings("unchecked") 	@Override 	public KeyGroupPartitionedSnapshot partitionByKeyGroup();1529307900;Partitions the snapshot data by key-group. The algorithm first builds a histogram for the distribution of keys_into key-groups. Then, the histogram is accumulated to obtain the boundaries of each key-group in an array._Last, we use the accumulated counts as write position pointers for the key-group's bins when reordering the_entries by key-group. This operation is lazily performed before the first writing of a key-group._<p>_As a possible future optimization, we could perform the repartitioning in-place, using a scheme similar to the_cuckoo cycles in cuckoo hashing. This can trade some performance for a smaller memory footprint.;@Nonnull_	@SuppressWarnings("unchecked")_	@Override_	public KeyGroupPartitionedSnapshot partitionByKeyGroup() {__		if (partitionedStateTableSnapshot == null) {__			final InternalKeyContext<K> keyContext = owningStateTable.keyContext__			final KeyGroupRange keyGroupRange = keyContext.getKeyGroupRange()__			final int numberOfKeyGroups = keyContext.getNumberOfKeyGroups()___			final StateTableKeyGroupPartitioner<K, N, S> keyGroupPartitioner = new StateTableKeyGroupPartitioner<>(_				snapshotData,_				numberOfEntriesInSnapshotData,_				keyGroupRange,_				numberOfKeyGroups,_				(element, dov) -> {_					localNamespaceSerializer.serialize(element.namespace, dov)__					localKeySerializer.serialize(element.key, dov)__					localStateSerializer.serialize(element.state, dov)__				})___			partitionedStateTableSnapshot = keyGroupPartitioner.partitionByKeyGroup()__		}__		return partitionedStateTableSnapshot__	};partitions,the,snapshot,data,by,key,group,the,algorithm,first,builds,a,histogram,for,the,distribution,of,keys,into,key,groups,then,the,histogram,is,accumulated,to,obtain,the,boundaries,of,each,key,group,in,an,array,last,we,use,the,accumulated,counts,as,write,position,pointers,for,the,key,group,s,bins,when,reordering,the,entries,by,key,group,this,operation,is,lazily,performed,before,the,first,writing,of,a,key,group,p,as,a,possible,future,optimization,we,could,perform,the,repartitioning,in,place,using,a,scheme,similar,to,the,cuckoo,cycles,in,cuckoo,hashing,this,can,trade,some,performance,for,a,smaller,memory,footprint;nonnull,suppress,warnings,unchecked,override,public,key,group,partitioned,snapshot,partition,by,key,group,if,partitioned,state,table,snapshot,null,final,internal,key,context,k,key,context,owning,state,table,key,context,final,key,group,range,key,group,range,key,context,get,key,group,range,final,int,number,of,key,groups,key,context,get,number,of,key,groups,final,state,table,key,group,partitioner,k,n,s,key,group,partitioner,new,state,table,key,group,partitioner,snapshot,data,number,of,entries,in,snapshot,data,key,group,range,number,of,key,groups,element,dov,local,namespace,serializer,serialize,element,namespace,dov,local,key,serializer,serialize,element,key,dov,local,state,serializer,serialize,element,state,dov,partitioned,state,table,snapshot,key,group,partitioner,partition,by,key,group,return,partitioned,state,table,snapshot
CopyOnWriteStateTableSnapshot -> CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable);1489685642;Creates a new {@link CopyOnWriteStateTableSnapshot}.__@param owningStateTable the {@link CopyOnWriteStateTable} for which this object represents a snapshot.;CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable) {__		super(owningStateTable)__		this.snapshotData = owningStateTable.snapshotTableArrays()__		this.snapshotVersion = owningStateTable.getStateTableVersion()__		this.stateTableSize = owningStateTable.size()__		this.keyGroupOffsets = null__	};creates,a,new,link,copy,on,write,state,table,snapshot,param,owning,state,table,the,link,copy,on,write,state,table,for,which,this,object,represents,a,snapshot;copy,on,write,state,table,snapshot,copy,on,write,state,table,k,n,s,owning,state,table,super,owning,state,table,this,snapshot,data,owning,state,table,snapshot,table,arrays,this,snapshot,version,owning,state,table,get,state,table,version,this,state,table,size,owning,state,table,size,this,key,group,offsets,null
CopyOnWriteStateTableSnapshot -> CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable);1490721653;Creates a new {@link CopyOnWriteStateTableSnapshot}.__@param owningStateTable the {@link CopyOnWriteStateTable} for which this object represents a snapshot.;CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable) {__		super(owningStateTable)__		this.snapshotData = owningStateTable.snapshotTableArrays()__		this.snapshotVersion = owningStateTable.getStateTableVersion()__		this.stateTableSize = owningStateTable.size()___		_		_		this.localKeySerializer = owningStateTable.keyContext.getKeySerializer().duplicate()__		this.localNamespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer().duplicate()__		this.localStateSerializer = owningStateTable.metaInfo.getStateSerializer().duplicate()___		this.keyGroupOffsets = null__	};creates,a,new,link,copy,on,write,state,table,snapshot,param,owning,state,table,the,link,copy,on,write,state,table,for,which,this,object,represents,a,snapshot;copy,on,write,state,table,snapshot,copy,on,write,state,table,k,n,s,owning,state,table,super,owning,state,table,this,snapshot,data,owning,state,table,snapshot,table,arrays,this,snapshot,version,owning,state,table,get,state,table,version,this,state,table,size,owning,state,table,size,this,local,key,serializer,owning,state,table,key,context,get,key,serializer,duplicate,this,local,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,duplicate,this,local,state,serializer,owning,state,table,meta,info,get,state,serializer,duplicate,this,key,group,offsets,null
CopyOnWriteStateTableSnapshot -> CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable);1529089579;Creates a new {@link CopyOnWriteStateTableSnapshot}.__@param owningStateTable the {@link CopyOnWriteStateTable} for which this object represents a snapshot.;CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable) {__		super(owningStateTable)__		this.snapshotData = owningStateTable.snapshotTableArrays()__		this.snapshotVersion = owningStateTable.getStateTableVersion()__		this.numberOfEntriesInSnapshotData = owningStateTable.size()____		_		_		this.localKeySerializer = owningStateTable.keyContext.getKeySerializer().duplicate()__		this.localNamespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer().duplicate()__		this.localStateSerializer = owningStateTable.metaInfo.getStateSerializer().duplicate()___		this.partitionedStateTableSnapshot = null__	};creates,a,new,link,copy,on,write,state,table,snapshot,param,owning,state,table,the,link,copy,on,write,state,table,for,which,this,object,represents,a,snapshot;copy,on,write,state,table,snapshot,copy,on,write,state,table,k,n,s,owning,state,table,super,owning,state,table,this,snapshot,data,owning,state,table,snapshot,table,arrays,this,snapshot,version,owning,state,table,get,state,table,version,this,number,of,entries,in,snapshot,data,owning,state,table,size,this,local,key,serializer,owning,state,table,key,context,get,key,serializer,duplicate,this,local,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,duplicate,this,local,state,serializer,owning,state,table,meta,info,get,state,serializer,duplicate,this,partitioned,state,table,snapshot,null
CopyOnWriteStateTableSnapshot -> CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable);1529307900;Creates a new {@link CopyOnWriteStateTableSnapshot}.__@param owningStateTable the {@link CopyOnWriteStateTable} for which this object represents a snapshot.;CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable) {__		super(owningStateTable)__		this.snapshotData = owningStateTable.snapshotTableArrays()__		this.snapshotVersion = owningStateTable.getStateTableVersion()__		this.numberOfEntriesInSnapshotData = owningStateTable.size()____		_		_		this.localKeySerializer = owningStateTable.keyContext.getKeySerializer().duplicate()__		this.localNamespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer().duplicate()__		this.localStateSerializer = owningStateTable.metaInfo.getStateSerializer().duplicate()___		this.partitionedStateTableSnapshot = null__	};creates,a,new,link,copy,on,write,state,table,snapshot,param,owning,state,table,the,link,copy,on,write,state,table,for,which,this,object,represents,a,snapshot;copy,on,write,state,table,snapshot,copy,on,write,state,table,k,n,s,owning,state,table,super,owning,state,table,this,snapshot,data,owning,state,table,snapshot,table,arrays,this,snapshot,version,owning,state,table,get,state,table,version,this,number,of,entries,in,snapshot,data,owning,state,table,size,this,local,key,serializer,owning,state,table,key,context,get,key,serializer,duplicate,this,local,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,duplicate,this,local,state,serializer,owning,state,table,meta,info,get,state,serializer,duplicate,this,partitioned,state,table,snapshot,null
CopyOnWriteStateTableSnapshot -> CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable);1531771917;Creates a new {@link CopyOnWriteStateTableSnapshot}.__@param owningStateTable the {@link CopyOnWriteStateTable} for which this object represents a snapshot.;CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable) {__		super(owningStateTable)__		this.snapshotData = owningStateTable.snapshotTableArrays()__		this.snapshotVersion = owningStateTable.getStateTableVersion()__		this.numberOfEntriesInSnapshotData = owningStateTable.size()____		_		_		this.localKeySerializer = owningStateTable.keyContext.getKeySerializer().duplicate()__		this.localNamespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer().duplicate()__		this.localStateSerializer = owningStateTable.metaInfo.getStateSerializer().duplicate()___		this.partitionedStateTableSnapshot = null__	};creates,a,new,link,copy,on,write,state,table,snapshot,param,owning,state,table,the,link,copy,on,write,state,table,for,which,this,object,represents,a,snapshot;copy,on,write,state,table,snapshot,copy,on,write,state,table,k,n,s,owning,state,table,super,owning,state,table,this,snapshot,data,owning,state,table,snapshot,table,arrays,this,snapshot,version,owning,state,table,get,state,table,version,this,number,of,entries,in,snapshot,data,owning,state,table,size,this,local,key,serializer,owning,state,table,key,context,get,key,serializer,duplicate,this,local,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,duplicate,this,local,state,serializer,owning,state,table,meta,info,get,state,serializer,duplicate,this,partitioned,state,table,snapshot,null
CopyOnWriteStateTableSnapshot -> CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable);1533318024;Creates a new {@link CopyOnWriteStateTableSnapshot}.__@param owningStateTable the {@link CopyOnWriteStateTable} for which this object represents a snapshot.;CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable) {__		super(owningStateTable)__		this.snapshotData = owningStateTable.snapshotTableArrays()__		this.snapshotVersion = owningStateTable.getStateTableVersion()__		this.numberOfEntriesInSnapshotData = owningStateTable.size()___		_		_		this.localKeySerializer = owningStateTable.keyContext.getKeySerializer().duplicate()__		this.localNamespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer().duplicate()__		this.localStateSerializer = owningStateTable.metaInfo.getStateSerializer().duplicate()___		this.partitionedStateTableSnapshot = null__	};creates,a,new,link,copy,on,write,state,table,snapshot,param,owning,state,table,the,link,copy,on,write,state,table,for,which,this,object,represents,a,snapshot;copy,on,write,state,table,snapshot,copy,on,write,state,table,k,n,s,owning,state,table,super,owning,state,table,this,snapshot,data,owning,state,table,snapshot,table,arrays,this,snapshot,version,owning,state,table,get,state,table,version,this,number,of,entries,in,snapshot,data,owning,state,table,size,this,local,key,serializer,owning,state,table,key,context,get,key,serializer,duplicate,this,local,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,duplicate,this,local,state,serializer,owning,state,table,meta,info,get,state,serializer,duplicate,this,partitioned,state,table,snapshot,null
CopyOnWriteStateTableSnapshot -> CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable);1534408054;Creates a new {@link CopyOnWriteStateTableSnapshot}.__@param owningStateTable the {@link CopyOnWriteStateTable} for which this object represents a snapshot.;CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable) {__		super(owningStateTable)__		this.snapshotData = owningStateTable.snapshotTableArrays()__		this.snapshotVersion = owningStateTable.getStateTableVersion()__		this.numberOfEntriesInSnapshotData = owningStateTable.size()___		_		_		this.localKeySerializer = owningStateTable.keyContext.getKeySerializer().duplicate()__		this.localNamespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer().duplicate()__		this.localStateSerializer = owningStateTable.metaInfo.getStateSerializer().duplicate()___		this.partitionedStateTableSnapshot = null__	};creates,a,new,link,copy,on,write,state,table,snapshot,param,owning,state,table,the,link,copy,on,write,state,table,for,which,this,object,represents,a,snapshot;copy,on,write,state,table,snapshot,copy,on,write,state,table,k,n,s,owning,state,table,super,owning,state,table,this,snapshot,data,owning,state,table,snapshot,table,arrays,this,snapshot,version,owning,state,table,get,state,table,version,this,number,of,entries,in,snapshot,data,owning,state,table,size,this,local,key,serializer,owning,state,table,key,context,get,key,serializer,duplicate,this,local,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,duplicate,this,local,state,serializer,owning,state,table,meta,info,get,state,serializer,duplicate,this,partitioned,state,table,snapshot,null
CopyOnWriteStateTableSnapshot -> CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable);1548440094;Creates a new {@link CopyOnWriteStateTableSnapshot}.__@param owningStateTable the {@link CopyOnWriteStateTable} for which this object represents a snapshot.;CopyOnWriteStateTableSnapshot(CopyOnWriteStateTable<K, N, S> owningStateTable) {__		super(owningStateTable)__		this.snapshotData = owningStateTable.snapshotTableArrays()__		this.snapshotVersion = owningStateTable.getStateTableVersion()__		this.numberOfEntriesInSnapshotData = owningStateTable.size()___		_		_		this.localKeySerializer = owningStateTable.keyContext.getKeySerializer().duplicate()__		this.localNamespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer().duplicate()__		this.localStateSerializer = owningStateTable.metaInfo.getStateSerializer().duplicate()___		this.partitionedStateTableSnapshot = null___		this.stateSnapshotTransformer = owningStateTable.metaInfo._			getStateSnapshotTransformFactory().createForDeserializedState().orElse(null)__	};creates,a,new,link,copy,on,write,state,table,snapshot,param,owning,state,table,the,link,copy,on,write,state,table,for,which,this,object,represents,a,snapshot;copy,on,write,state,table,snapshot,copy,on,write,state,table,k,n,s,owning,state,table,super,owning,state,table,this,snapshot,data,owning,state,table,snapshot,table,arrays,this,snapshot,version,owning,state,table,get,state,table,version,this,number,of,entries,in,snapshot,data,owning,state,table,size,this,local,key,serializer,owning,state,table,key,context,get,key,serializer,duplicate,this,local,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,duplicate,this,local,state,serializer,owning,state,table,meta,info,get,state,serializer,duplicate,this,partitioned,state,table,snapshot,null,this,state,snapshot,transformer,owning,state,table,meta,info,get,state,snapshot,transform,factory,create,for,deserialized,state,or,else,null
