commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Returns the internal data structure.  */ ;// ------------------------------------------------------------------------ // access to maps // ------------------------------------------------------------------------ /**  * Returns the internal data structure.  */ @VisibleForTesting public Map<N, Map<K, S>>[] getState() {     return state. }
false;;1;9;;@VisibleForTesting Map<N, Map<K, S>> getMapForKeyGroup(int keyGroupIndex) {     final int pos = indexToOffset(keyGroupIndex).     if (pos >= 0 && pos < state.length) {         return state[pos].     } else {         return null.     } }
true;private;2;8;/**  * Sets the given map for the given key-group.  */ ;/**  * Sets the given map for the given key-group.  */ private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {     try {         state[indexToOffset(keyGroupId)] = map.     } catch (ArrayIndexOutOfBoundsException e) {         throw new IllegalArgumentException("Key group index " + keyGroupId + " is out of range of key group " + "range [" + keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").").     } }
true;private;1;3;/**  * Translates a key-group id to the internal array offset.  */ ;/**  * Translates a key-group id to the internal array offset.  */ private int indexToOffset(int index) {     return index - keyGroupOffset. }
false;public;0;14;;// ------------------------------------------------------------------------ @Override public int size() {     int count = 0.     for (Map<N, Map<K, S>> namespaceMap : state) {         if (null != namespaceMap) {             for (Map<K, S> keyMap : namespaceMap.values()) {                 if (null != keyMap) {                     count += keyMap.size().                 }             }         }     }     return count. }
false;public;1;4;;@Override public S get(N namespace) {     return get(keyContext.getCurrentKey(), keyContext.getCurrentKeyGroupIndex(), namespace). }
false;public;1;4;;@Override public boolean containsKey(N namespace) {     return containsKey(keyContext.getCurrentKey(), keyContext.getCurrentKeyGroupIndex(), namespace). }
false;public;2;4;;@Override public void put(N namespace, S state) {     put(keyContext.getCurrentKey(), keyContext.getCurrentKeyGroupIndex(), namespace, state). }
false;public;2;4;;@Override public S putAndGetOld(N namespace, S state) {     return putAndGetOld(keyContext.getCurrentKey(), keyContext.getCurrentKeyGroupIndex(), namespace, state). }
false;public;1;4;;@Override public void remove(N namespace) {     remove(keyContext.getCurrentKey(), keyContext.getCurrentKeyGroupIndex(), namespace). }
false;public;1;4;;@Override public S removeAndGetOld(N namespace) {     return removeAndGetOld(keyContext.getCurrentKey(), keyContext.getCurrentKeyGroupIndex(), namespace). }
false;public;2;5;;@Override public S get(K key, N namespace) {     int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(key, keyContext.getNumberOfKeyGroups()).     return get(key, keyGroup, namespace). }
false;public;1;7;;@Override public Stream<K> getKeys(N namespace) {     return Arrays.stream(state).filter(Objects::nonNull).map(namespaces -> namespaces.getOrDefault(namespace, Collections.emptyMap())).flatMap(namespaceSate -> namespaceSate.keySet().stream()). }
false;public;1;4;;@Override public StateIncrementalVisitor<K, N, S> getStateIncrementalVisitor(int recommendedMaxNumberOfReturnedRecords) {     return new StateEntryIterator(). }
false;private;3;14;;// ------------------------------------------------------------------------ private boolean containsKey(K key, int keyGroupIndex, N namespace) {     checkKeyNamespacePreconditions(key, namespace).     Map<N, Map<K, S>> namespaceMap = getMapForKeyGroup(keyGroupIndex).     if (namespaceMap == null) {         return false.     }     Map<K, S> keyedMap = namespaceMap.get(namespace).     return keyedMap != null && keyedMap.containsKey(key). }
false;;3;18;;S get(K key, int keyGroupIndex, N namespace) {     checkKeyNamespacePreconditions(key, namespace).     Map<N, Map<K, S>> namespaceMap = getMapForKeyGroup(keyGroupIndex).     if (namespaceMap == null) {         return null.     }     Map<K, S> keyedMap = namespaceMap.get(namespace).     if (keyedMap == null) {         return null.     }     return keyedMap.get(key). }
false;public;4;4;;@Override public void put(K key, int keyGroupIndex, N namespace, S value) {     putAndGetOld(key, keyGroupIndex, namespace, value). }
false;private;4;15;;private S putAndGetOld(K key, int keyGroupIndex, N namespace, S value) {     checkKeyNamespacePreconditions(key, namespace).     Map<N, Map<K, S>> namespaceMap = getMapForKeyGroup(keyGroupIndex).     if (namespaceMap == null) {         namespaceMap = new HashMap<>().         setMapForKeyGroup(keyGroupIndex, namespaceMap).     }     Map<K, S> keyedMap = namespaceMap.computeIfAbsent(namespace, k -> new HashMap<>()).     return keyedMap.put(key, value). }
false;private;3;3;;private void remove(K key, int keyGroupIndex, N namespace) {     removeAndGetOld(key, keyGroupIndex, namespace). }
false;private;3;24;;private S removeAndGetOld(K key, int keyGroupIndex, N namespace) {     checkKeyNamespacePreconditions(key, namespace).     Map<N, Map<K, S>> namespaceMap = getMapForKeyGroup(keyGroupIndex).     if (namespaceMap == null) {         return null.     }     Map<K, S> keyedMap = namespaceMap.get(namespace).     if (keyedMap == null) {         return null.     }     S removed = keyedMap.remove(key).     if (keyedMap.isEmpty()) {         namespaceMap.remove(namespace).     }     return removed. }
false;private;2;4;;private void checkKeyNamespacePreconditions(K key, N namespace) {     Preconditions.checkNotNull(key, "No key set. This method should not be called outside of a keyed context.").     Preconditions.checkNotNull(namespace, "Provided namespace is null."). }
false;public;1;12;;@Override public int sizeOfNamespace(Object namespace) {     int count = 0.     for (Map<N, Map<K, S>> namespaceMap : state) {         if (null != namespaceMap) {             Map<K, S> keyMap = namespaceMap.get(namespace).             count += keyMap != null ? keyMap.size() : 0.         }     }     return count. }
false;public;3;16;;@Override public <T> void transform(N namespace, T value, StateTransformationFunction<S, T> transformation) throws Exception {     final K key = keyContext.getCurrentKey().     checkKeyNamespacePreconditions(key, namespace).     final int keyGroupIndex = keyContext.getCurrentKeyGroupIndex().     Map<N, Map<K, S>> namespaceMap = getMapForKeyGroup(keyGroupIndex).     if (namespaceMap == null) {         namespaceMap = new HashMap<>().         setMapForKeyGroup(keyGroupIndex, namespaceMap).     }     Map<K, S> keyedMap = namespaceMap.computeIfAbsent(namespace, k -> new HashMap<>()).     keyedMap.put(key, transformation.apply(keyedMap.get(key), value)). }
false;private,static;1;8;;// snapshots --------------------------------------------------------------------------------------------------- private static <K, N, S> int countMappingsInKeyGroup(final Map<N, Map<K, S>> keyGroupMap) {     int count = 0.     for (Map<K, S> namespaceMap : keyGroupMap.values()) {         count += namespaceMap.size().     }     return count. }
false;public;0;5;;@Nonnull @Override public NestedMapsStateTableSnapshot<K, N, S> stateSnapshot() {     return new NestedMapsStateTableSnapshot<>(this, metaInfo.getStateSnapshotTransformFactory()). }
false;public;0;5;;@Nonnull @Override public StateKeyGroupWriter getKeyGroupWriter() {     return this. }
false;public;0;5;;@Nonnull @Override public StateMetaInfoSnapshot getMetaInfoSnapshot() {     return owningStateTable.metaInfo.snapshot(). }
true;public;2;17;/**  * Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and  * {@link CopyOnWriteStateTable}.  *  * <p>{@link NestedMapsStateTable} could naturally support a kind of  * prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each  * mapping). We might implement support for different formats later (tailored towards different state table  * implementations).  */ ;/**  * Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and  * {@link CopyOnWriteStateTable}.  *  * <p>{@link NestedMapsStateTable} could naturally support a kind of  * prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each  * mapping). We might implement support for different formats later (tailored towards different state table  * implementations).  */ @Override public void writeStateInKeyGroup(@Nonnull DataOutputView dov, int keyGroupId) throws IOException {     final Map<N, Map<K, S>> keyGroupMap = owningStateTable.getMapForKeyGroup(keyGroupId).     if (null != keyGroupMap) {         Map<N, Map<K, S>> filteredMappings = filterMappingsInKeyGroupIfNeeded(keyGroupMap).         dov.writeInt(countMappingsInKeyGroup(filteredMappings)).         for (Map.Entry<N, Map<K, S>> namespaceEntry : filteredMappings.entrySet()) {             final N namespace = namespaceEntry.getKey().             final Map<K, S> namespaceMap = namespaceEntry.getValue().             for (Map.Entry<K, S> keyEntry : namespaceMap.entrySet()) {                 writeElement(namespace, keyEntry, dov).             }         }     } else {         dov.writeInt(0).     } }
false;private;3;5;;private void writeElement(N namespace, Map.Entry<K, S> keyEntry, DataOutputView dov) throws IOException {     namespaceSerializer.serialize(namespace, dov).     keySerializer.serialize(keyEntry.getKey(), dov).     stateSerializer.serialize(keyEntry.getValue(), dov). }
false;private;1;4;;private Map<N, Map<K, S>> filterMappingsInKeyGroupIfNeeded(final Map<N, Map<K, S>> keyGroupMap) {     return snapshotFilter == null ? keyGroupMap : filterMappingsInKeyGroup(keyGroupMap). }
false;private;1;15;;private Map<N, Map<K, S>> filterMappingsInKeyGroup(final Map<N, Map<K, S>> keyGroupMap) {     Map<N, Map<K, S>> filtered = new HashMap<>().     for (Map.Entry<N, Map<K, S>> namespaceEntry : keyGroupMap.entrySet()) {         N namespace = namespaceEntry.getKey().         Map<K, S> filteredNamespaceMap = filtered.computeIfAbsent(namespace, n -> new HashMap<>()).         for (Map.Entry<K, S> keyEntry : namespaceEntry.getValue().entrySet()) {             K key = keyEntry.getKey().             S transformedvalue = snapshotFilter.filterOrTransform(keyEntry.getValue()).             if (transformedvalue != null) {                 filteredNamespaceMap.put(key, transformedvalue).             }         }     }     return filtered. }
false;public;0;5;;@Override public boolean hasNext() {     nextKeyIterator().     return keyIteratorHasNext(). }
false;public;0;5;;@Override public Collection<StateEntry<K, N, S>> nextEntries() {     StateEntry<K, N, S> nextEntry = next().     return nextEntry == null ? Collections.emptyList() : Collections.singletonList(nextEntry). }
false;public;0;10;;@Override public StateEntry<K, N, S> next() {     StateEntry<K, N, S> next = null.     if (hasNext()) {         next = nextEntry.     }     nextEntry = null.     lastReturnedEntry = next.     return next. }
false;private;0;11;;private void nextKeyIterator() {     while (!keyIteratorHasNext()) {         nextNamespaceIterator().         if (namespaceIteratorHasNext()) {             namespace = namespaceIterator.next().             keyValueIterator = new HashSet<>(namespace.getValue().entrySet()).iterator().         } else {             break.         }     } }
false;private;0;12;;private void nextNamespaceIterator() {     while (!namespaceIteratorHasNext()) {         while (keyGropuIndex < state.length && state[keyGropuIndex] == null) {             keyGropuIndex++.         }         if (keyGropuIndex < state.length && state[keyGropuIndex] != null) {             namespaceIterator = new HashSet<>(state[keyGropuIndex++].entrySet()).iterator().         } else {             break.         }     } }
false;private;0;12;;private boolean keyIteratorHasNext() {     while (nextEntry == null && keyValueIterator != null && keyValueIterator.hasNext()) {         Map.Entry<K, S> next = keyValueIterator.next().         Map<K, S> ns = state[keyGropuIndex - 1] == null ? null : state[keyGropuIndex - 1].getOrDefault(namespace.getKey(), null).         S upToDateValue = ns == null ? null : ns.getOrDefault(next.getKey(), null).         if (upToDateValue != null) {             nextEntry = new SimpleStateEntry<>(next.getKey(), namespace.getKey(), upToDateValue).         }     }     return nextEntry != null. }
false;private;0;3;;private boolean namespaceIteratorHasNext() {     return namespaceIterator != null && namespaceIterator.hasNext(). }
false;public;0;4;;@Override public void remove() {     remove(lastReturnedEntry). }
false;public;1;4;;@Override public void remove(StateEntry<K, N, S> stateEntry) {     state[keyGropuIndex - 1].get(stateEntry.getNamespace()).remove(stateEntry.getKey()). }
false;public;2;4;;@Override public void update(StateEntry<K, N, S> stateEntry, S newValue) {     state[keyGropuIndex - 1].get(stateEntry.getNamespace()).put(stateEntry.getKey(), newValue). }
