commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Nullable public MemorySegment requestMemorySegment() {     return availableMemorySegments.poll(). }
false;public;1;6;;public void recycle(MemorySegment segment) {     // Adds the segment back to the queue, which does not immediately free the memory     // however, since this happens when references to the global pool are also released,     // making the availableMemorySegments queue and its contained object reclaimable     availableMemorySegments.add(checkNotNull(segment)). }
false;public;1;61;;public List<MemorySegment> requestMemorySegments(int numRequiredBuffers) throws IOException {     checkArgument(numRequiredBuffers > 0, "The number of required buffers should be larger than 0.").     synchronized (factoryLock) {         if (isDestroyed) {             throw new IllegalStateException("Network buffer pool has already been destroyed.").         }         if (numTotalRequiredBuffers + numRequiredBuffers > totalNumberOfMemorySegments) {             throw new IOException(String.format("Insufficient number of network buffers: " + "required %d, but only %d available. The total number of network " + "buffers is currently set to %d of %d bytes each. You can increase this " + "number by setting the configuration keys '%s', '%s', and '%s'.", numRequiredBuffers, totalNumberOfMemorySegments - numTotalRequiredBuffers, totalNumberOfMemorySegments, memorySegmentSize, TaskManagerOptions.NETWORK_BUFFERS_MEMORY_FRACTION.key(), TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MIN.key(), TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX.key())).         }         this.numTotalRequiredBuffers += numRequiredBuffers.         try {             redistributeBuffers().         } catch (Throwable t) {             this.numTotalRequiredBuffers -= numRequiredBuffers.             try {                 redistributeBuffers().             } catch (IOException inner) {                 t.addSuppressed(inner).             }             ExceptionUtils.rethrowIOException(t).         }     }     final List<MemorySegment> segments = new ArrayList<>(numRequiredBuffers).     try {         while (segments.size() < numRequiredBuffers) {             if (isDestroyed) {                 throw new IllegalStateException("Buffer pool is destroyed.").             }             final MemorySegment segment = availableMemorySegments.poll(2, TimeUnit.SECONDS).             if (segment != null) {                 segments.add(segment).             }         }     } catch (Throwable e) {         try {             recycleMemorySegments(segments, numRequiredBuffers).         } catch (IOException inner) {             e.addSuppressed(inner).         }         ExceptionUtils.rethrowIOException(e).     }     return segments. }
false;public;1;3;;public void recycleMemorySegments(List<MemorySegment> segments) throws IOException {     recycleMemorySegments(segments, segments.size()). }
false;private;2;10;;private void recycleMemorySegments(List<MemorySegment> segments, int size) throws IOException {     synchronized (factoryLock) {         numTotalRequiredBuffers -= size.         availableMemorySegments.addAll(segments).         // note: if this fails, we're fine for the buffer pool since we already recycled the segments         redistributeBuffers().     } }
false;public;0;10;;public void destroy() {     synchronized (factoryLock) {         isDestroyed = true.         MemorySegment segment.         while ((segment = availableMemorySegments.poll()) != null) {             segment.free().         }     } }
false;public;0;3;;public boolean isDestroyed() {     return isDestroyed. }
false;public;0;3;;public int getMemorySegmentSize() {     return memorySegmentSize. }
false;public;0;3;;public int getTotalNumberOfMemorySegments() {     return totalNumberOfMemorySegments. }
false;public;0;3;;public int getNumberOfAvailableMemorySegments() {     return availableMemorySegments.size(). }
false;public;0;5;;public int getNumberOfRegisteredBufferPools() {     synchronized (factoryLock) {         return allBufferPools.size().     } }
false;public;0;11;;public int countBuffers() {     int buffers = 0.     synchronized (factoryLock) {         for (BufferPool bp : allBufferPools) {             buffers += bp.getNumBuffers().         }     }     return buffers. }
false;public;2;4;;// ------------------------------------------------------------------------ // BufferPoolFactory // ------------------------------------------------------------------------ @Override public BufferPool createBufferPool(int numRequiredBuffers, int maxUsedBuffers) throws IOException {     return createBufferPool(numRequiredBuffers, maxUsedBuffers, Optional.empty()). }
false;public;3;48;;@Override public BufferPool createBufferPool(int numRequiredBuffers, int maxUsedBuffers, Optional<BufferPoolOwner> owner) throws IOException {     // requests to ensure deadlock freedom for failure cases.     synchronized (factoryLock) {         if (isDestroyed) {             throw new IllegalStateException("Network buffer pool has already been destroyed.").         }         // With dynamic memory management this should become obsolete.         if (numTotalRequiredBuffers + numRequiredBuffers > totalNumberOfMemorySegments) {             throw new IOException(String.format("Insufficient number of network buffers: " + "required %d, but only %d available. The total number of network " + "buffers is currently set to %d of %d bytes each. You can increase this " + "number by setting the configuration keys '%s', '%s', and '%s'.", numRequiredBuffers, totalNumberOfMemorySegments - numTotalRequiredBuffers, totalNumberOfMemorySegments, memorySegmentSize, TaskManagerOptions.NETWORK_BUFFERS_MEMORY_FRACTION.key(), TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MIN.key(), TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX.key())).         }         this.numTotalRequiredBuffers += numRequiredBuffers.         // We are good to go, create a new buffer pool and redistribute         // non-fixed size buffers.         LocalBufferPool localBufferPool = new LocalBufferPool(this, numRequiredBuffers, maxUsedBuffers, owner).         allBufferPools.add(localBufferPool).         try {             redistributeBuffers().         } catch (IOException e) {             try {                 destroyBufferPool(localBufferPool).             } catch (IOException inner) {                 e.addSuppressed(inner).             }             ExceptionUtils.rethrowIOException(e).         }         return localBufferPool.     } }
false;public;1;14;;@Override public void destroyBufferPool(BufferPool bufferPool) throws IOException {     if (!(bufferPool instanceof LocalBufferPool)) {         throw new IllegalArgumentException("bufferPool is no LocalBufferPool").     }     synchronized (factoryLock) {         if (allBufferPools.remove(bufferPool)) {             numTotalRequiredBuffers -= bufferPool.getNumberOfRequiredMemorySegments().             redistributeBuffers().         }     } }
true;public;0;15;/**  * Destroys all buffer pools that allocate their buffers from this  * buffer pool (created via {@link #createBufferPool(int, int)}).  */ ;/**  * Destroys all buffer pools that allocate their buffers from this  * buffer pool (created via {@link #createBufferPool(int, int)}).  */ public void destroyAllBufferPools() {     synchronized (factoryLock) {         // create a copy to avoid concurrent modification exceptions         LocalBufferPool[] poolsCopy = allBufferPools.toArray(new LocalBufferPool[allBufferPools.size()]).         for (LocalBufferPool pool : poolsCopy) {             pool.lazyDestroy().         }         // some sanity checks         if (allBufferPools.size() > 0 || numTotalRequiredBuffers > 0) {             throw new IllegalStateException("NetworkBufferPool is not empty after destroying all LocalBufferPools").         }     } }
true;private;0;67;// Must be called from synchronized block ;// Must be called from synchronized block private void redistributeBuffers() throws IOException {     assert Thread.holdsLock(factoryLock).     // All buffers, which are not among the required ones     final int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers.     if (numAvailableMemorySegment == 0) {         // in this case, we need to redistribute buffers so that every pool gets its minimum         for (LocalBufferPool bufferPool : allBufferPools) {             bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments()).         }         return.     }     /* 		 * With buffer pools being potentially limited, let's distribute the available memory 		 * segments based on the capacity of each buffer pool, i.e. the maximum number of segments 		 * an unlimited buffer pool can take is numAvailableMemorySegment, for limited buffer pools 		 * it may be less. Based on this and the sum of all these values (totalCapacity), we build 		 * a ratio that we use to distribute the buffers. 		 */     // long to avoid int overflow     long totalCapacity = 0.     for (LocalBufferPool bufferPool : allBufferPools) {         int excessMax = bufferPool.getMaxNumberOfMemorySegments() - bufferPool.getNumberOfRequiredMemorySegments().         totalCapacity += Math.min(numAvailableMemorySegment, excessMax).     }     // no capacity to receive additional buffers?     if (totalCapacity == 0) {         // necessary to avoid div by zero when nothing to re-distribute         return.     }     // since one of the arguments of 'min(a,b)' is a positive int, this is actually     // guaranteed to be within the 'int' domain     // (we use a checked downCast to handle possible bugs more gracefully).     final int memorySegmentsToDistribute = MathUtils.checkedDownCast(Math.min(numAvailableMemorySegment, totalCapacity)).     // of totalCapacity     long totalPartsUsed = 0.     int numDistributedMemorySegment = 0.     for (LocalBufferPool bufferPool : allBufferPools) {         int excessMax = bufferPool.getMaxNumberOfMemorySegments() - bufferPool.getNumberOfRequiredMemorySegments().         // shortcut         if (excessMax == 0) {             continue.         }         totalPartsUsed += Math.min(numAvailableMemorySegment, excessMax).         // avoid remaining buffers by looking at the total capacity that should have been         // re-distributed up until here         // the downcast will always succeed, because both arguments of the subtraction are in the 'int' domain         final int mySize = MathUtils.checkedDownCast(memorySegmentsToDistribute * totalPartsUsed / totalCapacity - numDistributedMemorySegment).         numDistributedMemorySegment += mySize.         bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize).     }     assert (totalPartsUsed == totalCapacity).     assert (numDistributedMemorySegment == memorySegmentsToDistribute). }
