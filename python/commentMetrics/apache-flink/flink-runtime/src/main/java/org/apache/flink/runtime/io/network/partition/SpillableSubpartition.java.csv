commented;modifiers;parameterAmount;loc;comment;code
false;public,synchronized;1;4;;@Override public synchronized boolean add(BufferConsumer bufferConsumer) throws IOException {     return add(bufferConsumer, false). }
false;private;2;23;;private boolean add(BufferConsumer bufferConsumer, boolean forceFinishRemainingBuffers) throws IOException {     checkNotNull(bufferConsumer).     synchronized (buffers) {         if (isFinished || isReleased) {             bufferConsumer.close().             return false.         }         buffers.add(bufferConsumer).         // The number of buffers are needed later when creating         // the read views. If you ever remove this line here,         // make sure to still count the number of buffers.         updateStatistics(bufferConsumer).         increaseBuffersInBacklog(bufferConsumer).         if (spillWriter != null) {             spillFinishedBufferConsumers(forceFinishRemainingBuffers).         }     }     return true. }
false;public;0;8;;@Override public void flush() {     synchronized (buffers) {         if (readView != null) {             readView.notifyDataAvailable().         }     } }
false;public,synchronized;0;16;;@Override public synchronized void finish() throws IOException {     synchronized (buffers) {         if (add(EventSerializer.toBufferConsumer(EndOfPartitionEvent.INSTANCE), true)) {             isFinished = true.         }         flush().     }     // If we are spilling/have spilled, wait for the writer to finish     if (spillWriter != null) {         spillWriter.close().     }     LOG.debug("{}: Finished {}.", parent.getOwningTaskName(), this). }
false;public,synchronized;0;41;;@Override public synchronized void release() throws IOException {     // view reference accessible outside the lock, but assigned inside the locked scope     final ResultSubpartitionView view.     synchronized (buffers) {         if (isReleased) {             return.         }         // Release all available buffers         for (BufferConsumer buffer : buffers) {             buffer.close().         }         buffers.clear().         view = readView.         // below).         if (view == null) {             // which can bring down the network.             if (spillWriter != null) {                 spillWriter.closeAndDelete().             }         }         isReleased = true.     }     LOG.debug("{}: Released {}.", parent.getOwningTaskName(), this).     if (view != null) {         view.releaseAllResources().     } }
false;public;1;32;;@Override public ResultSubpartitionView createReadView(BufferAvailabilityListener availabilityListener) throws IOException {     synchronized (buffers) {         if (!isFinished) {             throw new IllegalStateException("Subpartition has not been finished yet, " + "but blocking subpartitions can only be consumed after they have " + "been finished.").         }         if (readView != null) {             throw new IllegalStateException("Subpartition is being or already has been " + "consumed, but we currently allow subpartitions to only be consumed once.").         }         if (spillWriter != null) {             readView = new SpilledSubpartitionView(this, parent.getBufferProvider().getMemorySegmentSize(), spillWriter, getTotalNumberOfBuffers(), availabilityListener).         } else {             readView = new SpillableSubpartitionView(this, buffers, ioManager, parent.getBufferProvider().getMemorySegmentSize(), availabilityListener).         }         return readView.     } }
false;public;0;28;;@Override public int releaseMemory() throws IOException {     synchronized (buffers) {         ResultSubpartitionView view = readView.         if (view != null && view.getClass() == SpillableSubpartitionView.class) {             // If there is a spillable view, it's the responsibility of the             // view to release memory.             SpillableSubpartitionView spillableView = (SpillableSubpartitionView) view.             return spillableView.releaseMemory().         } else if (spillWriter == null) {             // No view and in-memory => spill to disk             spillWriter = ioManager.createBufferFileWriter(ioManager.createChannel()).             int numberOfBuffers = buffers.size().             long spilledBytes = spillFinishedBufferConsumers(isFinished).             int spilledBuffers = numberOfBuffers - buffers.size().             LOG.debug("{}: Spilling {} bytes ({} buffers} for sub partition {} of {}.", parent.getOwningTaskName(), spilledBytes, spilledBuffers, index, parent.getPartitionId()).             return spilledBuffers.         }     }     // Else: We have already spilled and don't hold any buffers     return 0. }
false;;1;39;;@VisibleForTesting long spillFinishedBufferConsumers(boolean forceFinishRemainingBuffers) throws IOException {     long spilledBytes = 0.     while (!buffers.isEmpty()) {         BufferConsumer bufferConsumer = buffers.getFirst().         Buffer buffer = bufferConsumer.build().         updateStatistics(buffer).         int bufferSize = buffer.getSize().         spilledBytes += bufferSize.         // be treated as if it was finished!         if (bufferConsumer.isFinished() || forceFinishRemainingBuffers) {             if (bufferSize > 0) {                 spillWriter.writeBlock(buffer).             } else {                 // If we skip a buffer for the spill writer, we need to adapt the backlog accordingly                 decreaseBuffersInBacklog(buffer).                 buffer.recycleBuffer().             }             bufferConsumer.close().             buffers.poll().         } else {             // BEWARE: by doing so, we increase the actual number of buffers in the spill writer!             if (bufferSize > 0) {                 spillWriter.writeBlock(buffer).                 increaseBuffersInBacklog(bufferConsumer).             } else {                 buffer.recycleBuffer().             }             return spilledBytes.         }     }     return spilledBytes. }
false;public;0;4;;@Override public boolean isReleased() {     return isReleased. }
false;public;0;5;;@Override public int unsynchronizedGetNumberOfQueuedBuffers() {     // since we do not synchronize, the size may actually be lower than 0!     return Math.max(buffers.size(), 0). }
false;public;0;7;;@Override public String toString() {     return String.format("SpillableSubpartition#%d [%d number of buffers (%d bytes)," + "%d number of buffers in backlog, finished? %s, read view? %s, spilled? %s]", index, getTotalNumberOfBuffers(), getTotalNumberOfBytes(), getBuffersInBacklog(), isFinished, readView != null, spillWriter != null). }
