commented;modifiers;parameterAmount;loc;comment;code
true;private,static;5;9;/**  * Helper for toString.  */ ;// -------------------------------------------------------------------------- // Design decision: // We do not allow access to routers and anyMethodRouter, because we don't // want to expose MethodlessRouter, OrderlessRouter, and PathPattern. // Exposing those will complicate the use of this package. /**  * Helper for toString.  */ private static <T> void aggregateRoutes(String method, Map<PathPattern, T> routes, List<String> accMethods, List<String> accPatterns, List<String> accTargets) {     for (Map.Entry<PathPattern, T> entry : routes.entrySet()) {         accMethods.add(method).         accPatterns.add("/" + entry.getKey().pattern()).         accTargets.add(targetToString(entry.getValue())).     } }
true;private,static;1;10;/**  * Helper for toString.  */ ;/**  * Helper for toString.  */ private static int maxLength(List<String> coll) {     int max = 0.     for (String e : coll) {         int length = e.length().         if (length > max) {             max = length.         }     }     return max. }
true;private,static;1;7;/**  * Helper for toString.  *  * <p>For example, returns  * "io.netty.example.http.router.HttpRouterServerHandler" instead of  * "class io.netty.example.http.router.HttpRouterServerHandler"  */ ;/**  * Helper for toString.  *  * <p>For example, returns  * "io.netty.example.http.router.HttpRouterServerHandler" instead of  * "class io.netty.example.http.router.HttpRouterServerHandler"  */ private static String targetToString(Object target) {     if (target instanceof Class) {         return ((Class<?>) target).getName().     } else {         return target.toString().     } }
true;public;0;3;/**  * Returns the fallback target for use when there's no match at  * {@link #route(HttpMethod, String)}.  */ ;/**  * Returns the fallback target for use when there's no match at  * {@link #route(HttpMethod, String)}.  */ public T notFound() {     return notFound. }
true;public;0;9;/**  * Returns the number of routes in this router.  */ ;/**  * Returns the number of routes in this router.  */ public int size() {     int ret = anyMethodRouter.size().     for (MethodlessRouter<T> router : routers.values()) {         ret += router.size().     }     return ret. }
true;public;3;4;/**  * Add route.  *  * <p>A path pattern can only point to one target. This method does nothing if the pattern  * has already been added.  */ ;// -------------------------------------------------------------------------- /**  * Add route.  *  * <p>A path pattern can only point to one target. This method does nothing if the pattern  * has already been added.  */ public Router<T> addRoute(HttpMethod method, String pathPattern, T target) {     getMethodlessRouter(method).addRoute(pathPattern, target).     return this. }
true;public;1;4;/**  * Sets the fallback target for use when there's no match at  * {@link #route(HttpMethod, String)}.  */ ;// -------------------------------------------------------------------------- /**  * Sets the fallback target for use when there's no match at  * {@link #route(HttpMethod, String)}.  */ public Router<T> notFound(T target) {     this.notFound = target.     return this. }
false;private;1;13;;private MethodlessRouter<T> getMethodlessRouter(HttpMethod method) {     if (method == null) {         return anyMethodRouter.     }     MethodlessRouter<T> router = routers.get(method).     if (router == null) {         router = new MethodlessRouter<T>().         routers.put(method, router).     }     return router. }
true;public;1;6;/**  * Removes the route specified by the path pattern.  */ ;/**  * Removes the route specified by the path pattern.  */ public void removePathPattern(String pathPattern) {     for (MethodlessRouter<T> router : routers.values()) {         router.removePathPattern(pathPattern).     }     anyMethodRouter.removePathPattern(pathPattern). }
true;public;2;3;/**  * If there's no match, returns the result with {@link #notFound(Object) notFound}  * as the target if it is set, otherwise returns {@code null}.  */ ;/**  * If there's no match, returns the result with {@link #notFound(Object) notFound}  * as the target if it is set, otherwise returns {@code null}.  */ public RouteResult<T> route(HttpMethod method, String path) {     return route(method, path, Collections.emptyMap()). }
false;public;3;26;;public RouteResult<T> route(HttpMethod method, String path, Map<String, List<String>> queryParameters) {     MethodlessRouter<T> router = routers.get(method).     if (router == null) {         router = anyMethodRouter.     }     String[] tokens = decodePathTokens(path).     RouteResult<T> ret = router.route(path, path, queryParameters, tokens).     if (ret != null) {         return new RouteResult<T>(path, path, ret.pathParams(), queryParameters, ret.target()).     }     if (router != anyMethodRouter) {         ret = anyMethodRouter.route(path, path, queryParameters, tokens).         if (ret != null) {             return new RouteResult<T>(path, path, ret.pathParams(), queryParameters, ret.target()).         }     }     if (notFound != null) {         return new RouteResult<T>(path, path, Collections.<String, String>emptyMap(), queryParameters, notFound).     }     return null. }
false;private;1;17;;// -------------------------------------------------------------------------- private String[] decodePathTokens(String uri) {     // Need to split the original URI (instead of QueryStringDecoder#path) then decode the tokens (components),     // otherwise /test1/123%2F456 will not match /test1/:p1     int qPos = uri.indexOf("?").     String encodedPath = (qPos >= 0) ? uri.substring(0, qPos) : uri.     String[] encodedTokens = PathPattern.removeSlashesAtBothEnds(encodedPath).split("/").     String[] decodedTokens = new String[encodedTokens.length].     for (int i = 0. i < encodedTokens.length. i++) {         String encodedToken = encodedTokens[i].         decodedTokens[i] = QueryStringDecoder.decodeComponent(encodedToken).     }     return decodedTokens. }
true;public;1;19;/**  * Returns allowed methods for a specific URI.  *  * <p>For {@code OPTIONS *}, use {@link #allAllowedMethods()} instead of this method.  */ ;/**  * Returns allowed methods for a specific URI.  *  * <p>For {@code OPTIONS *}, use {@link #allAllowedMethods()} instead of this method.  */ public Set<HttpMethod> allowedMethods(String uri) {     QueryStringDecoder decoder = new QueryStringDecoder(uri).     String[] tokens = PathPattern.removeSlashesAtBothEnds(decoder.path()).split("/").     if (anyMethodRouter.anyMatched(tokens)) {         return allAllowedMethods().     }     Set<HttpMethod> ret = new HashSet<HttpMethod>(routers.size()).     for (Map.Entry<HttpMethod, MethodlessRouter<T>> entry : routers.entrySet()) {         MethodlessRouter<T> router = entry.getValue().         if (router.anyMatched(tokens)) {             HttpMethod method = entry.getKey().             ret.add(method).         }     }     return ret. }
true;public;0;17;/**  * Returns all methods that this router handles. For {@code OPTIONS *}.  */ ;/**  * Returns all methods that this router handles. For {@code OPTIONS *}.  */ public Set<HttpMethod> allAllowedMethods() {     if (anyMethodRouter.size() > 0) {         Set<HttpMethod> ret = new HashSet<HttpMethod>(9).         ret.add(HttpMethod.CONNECT).         ret.add(HttpMethod.DELETE).         ret.add(HttpMethod.GET).         ret.add(HttpMethod.HEAD).         ret.add(HttpMethod.OPTIONS).         ret.add(HttpMethod.PATCH).         ret.add(HttpMethod.POST).         ret.add(HttpMethod.PUT).         ret.add(HttpMethod.TRACE).         return ret.     } else {         return new HashSet<HttpMethod>(routers.keySet()).     } }
true;public;0;39;/**  * Returns visualized routing rules.  */ ;/**  * Returns visualized routing rules.  */ @Override public String toString() {     // Step 1/2: Dump routers and anyMethodRouter in order     int numRoutes = size().     List<String> methods = new ArrayList<String>(numRoutes).     List<String> patterns = new ArrayList<String>(numRoutes).     List<String> targets = new ArrayList<String>(numRoutes).     // For router     for (Entry<HttpMethod, MethodlessRouter<T>> e : routers.entrySet()) {         HttpMethod method = e.getKey().         MethodlessRouter<T> router = e.getValue().         aggregateRoutes(method.toString(), router.routes(), methods, patterns, targets).     }     // For anyMethodRouter     aggregateRoutes("*", anyMethodRouter.routes(), methods, patterns, targets).     // For notFound     if (notFound != null) {         methods.add("*").         patterns.add("*").         targets.add(targetToString(notFound)).     }     // Step 2/2: Format the List into aligned columns: <method> <patterns> <target>     int maxLengthMethod = maxLength(methods).     int maxLengthPattern = maxLength(patterns).     String format = "%-" + maxLengthMethod + "s  %-" + maxLengthPattern + "s  %s\n".     int initialCapacity = (maxLengthMethod + 1 + maxLengthPattern + 1 + 20) * methods.size().     StringBuilder b = new StringBuilder(initialCapacity).     for (int i = 0. i < methods.size(). i++) {         String method = methods.get(i).         String pattern = patterns.get(i).         String target = targets.get(i).         b.append(String.format(format, method, pattern, target)).     }     return b.toString(). }
false;public;2;3;;// -------------------------------------------------------------------------- public Router<T> addConnect(String path, T target) {     return addRoute(HttpMethod.CONNECT, path, target). }
false;public;2;3;;public Router<T> addDelete(String path, T target) {     return addRoute(HttpMethod.DELETE, path, target). }
false;public;2;3;;public Router<T> addGet(String path, T target) {     return addRoute(HttpMethod.GET, path, target). }
false;public;2;3;;public Router<T> addHead(String path, T target) {     return addRoute(HttpMethod.HEAD, path, target). }
false;public;2;3;;public Router<T> addOptions(String path, T target) {     return addRoute(HttpMethod.OPTIONS, path, target). }
false;public;2;3;;public Router<T> addPatch(String path, T target) {     return addRoute(HttpMethod.PATCH, path, target). }
false;public;2;3;;public Router<T> addPost(String path, T target) {     return addRoute(HttpMethod.POST, path, target). }
false;public;2;3;;public Router<T> addPut(String path, T target) {     return addRoute(HttpMethod.PUT, path, target). }
false;public;2;3;;public Router<T> addTrace(String path, T target) {     return addRoute(HttpMethod.TRACE, path, target). }
false;public;2;3;;public Router<T> addAny(String path, T target) {     return addRoute(null, path, target). }
