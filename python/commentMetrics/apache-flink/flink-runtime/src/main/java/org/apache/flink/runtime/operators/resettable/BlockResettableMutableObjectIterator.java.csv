commented;modifiers;parameterAmount;loc;comment;code
false;public;1;32;;// -------------------------------------------------------------------------------------------- @Override public T next(T target) throws IOException {     // check for the left over element     if (this.readPhase) {         return getNextRecord(target).     } else {         // writing phase. check for leftover first         if (this.leftOverReturned) {             // get next record             if ((target = this.input.next(target)) != null) {                 if (writeNextRecord(target)) {                     return target.                 } else {                     // did not fit into memory, keep as leftover                     this.leftOverRecord = this.serializer.copy(target, this.leftOverRecord).                     this.leftOverReturned = false.                     this.fullWriteBuffer = true.                     return null.                 }             } else {                 this.noMoreBlocks = true.                 return null.             }         } else if (this.fullWriteBuffer) {             return null.         } else {             this.leftOverReturned = true.             target = this.serializer.copy(this.leftOverRecord, target).             return target.         }     } }
false;public;0;32;;@Override public T next() throws IOException {     // check for the left over element     if (this.readPhase) {         return getNextRecord().     } else {         // writing phase. check for leftover first         T result = null.         if (this.leftOverReturned) {             // get next record             if ((result = this.input.next()) != null) {                 if (writeNextRecord(result)) {                     return result.                 } else {                     // did not fit into memory, keep as leftover                     this.leftOverRecord = this.serializer.copy(result).                     this.leftOverReturned = false.                     this.fullWriteBuffer = true.                     return null.                 }             } else {                 this.noMoreBlocks = true.                 return null.             }         } else if (this.fullWriteBuffer) {             return null.         } else {             this.leftOverReturned = true.             return this.leftOverRecord.         }     } }
false;public;0;5;;public void reset() {     // a reset always goes to the read phase     this.readPhase = true.     super.reset(). }
false;public;0;37;;@Override public boolean nextBlock() throws IOException {     // check the state     if (this.closed) {         throw new IllegalStateException("Iterator has been closed.").     }     // check whether more blocks are available     if (this.noMoreBlocks) {         return false.     }     // reset the views in the superclass     super.nextBlock().     // if there is no leftover record, get a record such that we guarantee to advance     if (this.leftOverReturned || !this.fullWriteBuffer) {         if ((this.leftOverRecord = this.input.next(this.leftOverRecord)) != null) {             this.leftOverReturned = false.         } else {             this.noMoreBlocks = true.             this.fullWriteBuffer = true.             this.readPhase = false.             return false.         }     }     // write the leftover record     if (!writeNextRecord(this.leftOverRecord)) {         throw new IOException("BlockResettableIterator could not serialize record into fresh memory block: " + "Record is too large.").     }     this.readPhase = false.     this.fullWriteBuffer = false.     return true. }
true;public;0;3;/**  * Checks, whether the input that is blocked by this iterator, has further elements  * available. This method may be used to forecast (for example at the point where a  * block is full) whether there will be more data (possibly in another block).  *  * @return True, if there will be more data, false otherwise.  */ ;/**  * Checks, whether the input that is blocked by this iterator, has further elements  * available. This method may be used to forecast (for example at the point where a  * block is full) whether there will be more data (possibly in another block).  *  * @return True, if there will be more data, false otherwise.  */ public boolean hasFurtherInput() {     return !this.noMoreBlocks. }
false;public;0;6;;public void close() {     // suggest that we are in the read phase. because nothing is in the current block,     // read requests will fail     this.readPhase = true.     super.close(). }
