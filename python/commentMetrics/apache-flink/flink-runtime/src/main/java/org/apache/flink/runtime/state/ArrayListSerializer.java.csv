commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public TypeSerializer<T> getElementSerializer() {     return elementSerializer. }
false;public;0;4;;@Override public boolean isImmutableType() {     return false. }
false;public;0;5;;@Override public TypeSerializer<ArrayList<T>> duplicate() {     TypeSerializer<T> duplicateElement = elementSerializer.duplicate().     return duplicateElement == elementSerializer ? this : new ArrayListSerializer<T>(duplicateElement). }
false;public;0;4;;@Override public ArrayList<T> createInstance() {     return new ArrayList<>(). }
false;public;1;14;;@Override public ArrayList<T> copy(ArrayList<T> from) {     if (elementSerializer.isImmutableType()) {         // fast track using memcopy for immutable types         return new ArrayList<>(from).     } else {         // element-wise deep copy for mutable types         ArrayList<T> newList = new ArrayList<>(from.size()).         for (int i = 0. i < from.size(). i++) {             newList.add(elementSerializer.copy(from.get(i))).         }         return newList.     } }
false;public;2;4;;@Override public ArrayList<T> copy(ArrayList<T> from, ArrayList<T> reuse) {     return copy(from). }
false;public;0;4;;@Override public int getLength() {     // var length     return -1. }
false;public;2;8;;@Override public void serialize(ArrayList<T> list, DataOutputView target) throws IOException {     final int size = list.size().     target.writeInt(size).     for (int i = 0. i < size. i++) {         elementSerializer.serialize(list.get(i), target).     } }
false;public;1;9;;@Override public ArrayList<T> deserialize(DataInputView source) throws IOException {     final int size = source.readInt().     final ArrayList<T> list = new ArrayList<>(size).     for (int i = 0. i < size. i++) {         list.add(elementSerializer.deserialize(source)).     }     return list. }
false;public;2;4;;@Override public ArrayList<T> deserialize(ArrayList<T> reuse, DataInputView source) throws IOException {     return deserialize(source). }
false;public;2;9;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     // copy number of elements     final int num = source.readInt().     target.writeInt(num).     for (int i = 0. i < num. i++) {         elementSerializer.copy(source, target).     } }
false;public;1;6;;// -------------------------------------------------------------------- @Override public boolean equals(Object obj) {     return obj == this || (obj != null && obj.getClass() == getClass() && elementSerializer.equals(((ArrayListSerializer<?>) obj).elementSerializer)). }
false;public;0;4;;@Override public int hashCode() {     return elementSerializer.hashCode(). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // Serializer snapshots // -------------------------------------------------------------------------------------------- @Override public TypeSerializerSnapshot<ArrayList<T>> snapshotConfiguration() {     return new ArrayListSerializerSnapshot<>(this). }
true;public;1;17;/**  * We need to implement this method as a {@link TypeSerializerConfigSnapshot.SelfResolvingTypeSerializer}  * because this serializer was previously returning a shared {@link CollectionSerializerConfigSnapshot}  * as its snapshot.  *  * <p>When the {@link CollectionSerializerConfigSnapshot} is restored, it is incapable of redirecting  * the compatibility check to {@link ArrayListSerializerSnapshot}, so we do it here.  */ ;/**  * We need to implement this method as a {@link TypeSerializerConfigSnapshot.SelfResolvingTypeSerializer}  * because this serializer was previously returning a shared {@link CollectionSerializerConfigSnapshot}  * as its snapshot.  *  * <p>When the {@link CollectionSerializerConfigSnapshot} is restored, it is incapable of redirecting  * the compatibility check to {@link ArrayListSerializerSnapshot}, so we do it here.  */ @Override public TypeSerializerSchemaCompatibility<ArrayList<T>> resolveSchemaCompatibilityViaRedirectingToNewSnapshotClass(TypeSerializerConfigSnapshot<ArrayList<T>> deprecatedConfigSnapshot) {     if (deprecatedConfigSnapshot instanceof CollectionSerializerConfigSnapshot) {         CollectionSerializerConfigSnapshot<ArrayList<T>, T> castedLegacySnapshot = (CollectionSerializerConfigSnapshot<ArrayList<T>, T>) deprecatedConfigSnapshot.         ArrayListSerializerSnapshot<T> newSnapshot = new ArrayListSerializerSnapshot<>().         return CompositeTypeSerializerUtil.delegateCompatibilityCheckToNewSnapshot(this, newSnapshot, castedLegacySnapshot.getNestedSerializerSnapshots()).     }     return TypeSerializerSchemaCompatibility.incompatible(). }
