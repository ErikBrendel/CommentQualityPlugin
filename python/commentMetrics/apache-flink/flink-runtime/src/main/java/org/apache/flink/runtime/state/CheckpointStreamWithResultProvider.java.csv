commented;modifiers;parameterAmount;loc;comment;code
true;;0;2;/**  * Closes the stream ans returns a snapshot result with the stream handle(s).  */ ;/**  * Closes the stream ans returns a snapshot result with the stream handle(s).  */ @Nonnull SnapshotResult<StreamStateHandle> closeAndFinalizeCheckpointStreamResult() throws IOException.
true;;0;2;/**  * Returns the encapsulated output stream.  */ ;/**  * Returns the encapsulated output stream.  */ @Nonnull CheckpointStreamFactory.CheckpointStateOutputStream getCheckpointOutputStream().
false;default;0;4;;@Override default void close() throws IOException {     getCheckpointOutputStream().close(). }
false;public;0;5;;@Nonnull @Override public SnapshotResult<StreamStateHandle> closeAndFinalizeCheckpointStreamResult() throws IOException {     return SnapshotResult.of(outputStream.closeAndGetHandle()). }
false;public;0;5;;@Nonnull @Override public CheckpointStreamFactory.CheckpointStateOutputStream getCheckpointOutputStream() {     return outputStream. }
false;public;0;35;;@Nonnull @Override public SnapshotResult<StreamStateHandle> closeAndFinalizeCheckpointStreamResult() throws IOException {     final StreamStateHandle primaryStreamStateHandle.     try {         primaryStreamStateHandle = outputStream.closeAndGetPrimaryHandle().     } catch (IOException primaryEx) {         try {             outputStream.close().         } catch (IOException closeEx) {             primaryEx = ExceptionUtils.firstOrSuppressed(closeEx, primaryEx).         }         throw primaryEx.     }     StreamStateHandle secondaryStreamStateHandle = null.     try {         secondaryStreamStateHandle = outputStream.closeAndGetSecondaryHandle().     } catch (IOException secondaryEx) {         LOG.warn("Exception from secondary/local checkpoint stream.", secondaryEx).     }     if (primaryStreamStateHandle != null) {         if (secondaryStreamStateHandle != null) {             return SnapshotResult.withLocalState(primaryStreamStateHandle, secondaryStreamStateHandle).         } else {             return SnapshotResult.of(primaryStreamStateHandle).         }     } else {         return SnapshotResult.empty().     } }
false;public;0;5;;@Nonnull @Override public DuplicatingCheckpointOutputStream getCheckpointOutputStream() {     return outputStream. }
false;static;2;10;;@Nonnull static CheckpointStreamWithResultProvider createSimpleStream(@Nonnull CheckpointedStateScope checkpointedStateScope, @Nonnull CheckpointStreamFactory primaryStreamFactory) throws IOException {     CheckpointStreamFactory.CheckpointStateOutputStream primaryOut = primaryStreamFactory.createCheckpointStateOutputStream(checkpointedStateScope).     return new CheckpointStreamWithResultProvider.PrimaryStreamOnly(primaryOut). }
false;static;4;27;;@Nonnull static CheckpointStreamWithResultProvider createDuplicatingStream(@Nonnegative long checkpointId, @Nonnull CheckpointedStateScope checkpointedStateScope, @Nonnull CheckpointStreamFactory primaryStreamFactory, @Nonnull LocalRecoveryDirectoryProvider secondaryStreamDirProvider) throws IOException {     CheckpointStreamFactory.CheckpointStateOutputStream primaryOut = primaryStreamFactory.createCheckpointStateOutputStream(checkpointedStateScope).     try {         File outFile = new File(secondaryStreamDirProvider.subtaskSpecificCheckpointDirectory(checkpointId), String.valueOf(UUID.randomUUID())).         Path outPath = new Path(outFile.toURI()).         CheckpointStreamFactory.CheckpointStateOutputStream secondaryOut = new FileBasedStateOutputStream(outPath.getFileSystem(), outPath).         return new CheckpointStreamWithResultProvider.PrimaryAndSecondaryStream(primaryOut, secondaryOut).     } catch (IOException secondaryEx) {         LOG.warn("Exception when opening secondary/local checkpoint output stream. " + "Continue only with the primary stream.", secondaryEx).     }     return new CheckpointStreamWithResultProvider.PrimaryStreamOnly(primaryOut). }
true;static;2;25;/**  * Helper method that takes a {@link SnapshotResult<StreamStateHandle>} and a {@link KeyGroupRangeOffsets} and  * creates a {@link SnapshotResult<KeyGroupsStateHandle>} by combining the key groups offsets with all the  * present stream state handles.  */ ;/**  * Helper method that takes a {@link SnapshotResult<StreamStateHandle>} and a {@link KeyGroupRangeOffsets} and  * creates a {@link SnapshotResult<KeyGroupsStateHandle>} by combining the key groups offsets with all the  * present stream state handles.  */ @Nonnull static SnapshotResult<KeyedStateHandle> toKeyedStateHandleSnapshotResult(@Nonnull SnapshotResult<StreamStateHandle> snapshotResult, @Nonnull KeyGroupRangeOffsets keyGroupRangeOffsets) {     StreamStateHandle jobManagerOwnedSnapshot = snapshotResult.getJobManagerOwnedSnapshot().     if (jobManagerOwnedSnapshot != null) {         KeyedStateHandle jmKeyedState = new KeyGroupsStateHandle(keyGroupRangeOffsets, jobManagerOwnedSnapshot).         StreamStateHandle taskLocalSnapshot = snapshotResult.getTaskLocalSnapshot().         if (taskLocalSnapshot != null) {             KeyedStateHandle localKeyedState = new KeyGroupsStateHandle(keyGroupRangeOffsets, taskLocalSnapshot).             return SnapshotResult.withLocalState(jmKeyedState, localKeyedState).         } else {             return SnapshotResult.of(jmKeyedState).         }     } else {         return SnapshotResult.empty().     } }
