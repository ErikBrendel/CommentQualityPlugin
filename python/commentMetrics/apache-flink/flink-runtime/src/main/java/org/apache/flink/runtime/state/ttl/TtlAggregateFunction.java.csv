commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public TtlValue<ACC> createAccumulator() {     return wrapWithTs(original.createAccumulator()). }
false;public;2;6;;@Override public TtlValue<ACC> add(IN value, TtlValue<ACC> accumulator) {     ACC userAcc = getUnexpired(accumulator).     userAcc = userAcc == null ? original.createAccumulator() : userAcc.     return wrapWithTs(original.add(value, userAcc)). }
false;public;1;12;;@Override public OUT getResult(TtlValue<ACC> accumulator) {     Preconditions.checkNotNull(updater, "State updater should be set in TtlAggregatingState").     Preconditions.checkNotNull(stateClear, "State clearing should be set in TtlAggregatingState").     ACC userAcc.     try {         userAcc = getWithTtlCheckAndUpdate(() -> accumulator, updater, stateClear).     } catch (Exception e) {         throw new FlinkRuntimeException("Failed to retrieve original internal aggregating state", e).     }     return userAcc == null ? null : original.getResult(userAcc). }
false;public;2;14;;@Override public TtlValue<ACC> merge(TtlValue<ACC> a, TtlValue<ACC> b) {     ACC userA = getUnexpired(a).     ACC userB = getUnexpired(b).     if (userA != null && userB != null) {         return wrapWithTs(original.merge(userA, userB)).     } else if (userA != null) {         return rewrapWithNewTs(a).     } else if (userB != null) {         return rewrapWithNewTs(b).     } else {         return null.     } }
