commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;// -------------------------------------------------------------------------------------------- @Override public void setup(TaskContext<FlatJoinFunction<IT1, IT2, OT>, OT> context) {     this.taskContext = context.     this.running = true. }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 1. }
false;public;0;6;;@Override public Class<FlatJoinFunction<IT1, IT2, OT>> getStubType() {     @SuppressWarnings("unchecked")     final Class<FlatJoinFunction<IT1, IT2, OT>> clazz = (Class<FlatJoinFunction<IT1, IT2, OT>>) (Class<?>) FlatJoinFunction.class.     return clazz. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 1. }
false;public;1;11;;@Override public boolean isInputResettable(int inputNum) {     if (inputNum < 0 || inputNum > 1) {         throw new IndexOutOfBoundsException().     }     // every iterations     return false. }
false;public;0;51;;// -------------------------------------------------------------------------------------------- @Override @SuppressWarnings("unchecked") public void initialize() throws Exception {     final TypeSerializer<IT2> solutionSetSerializer.     final TypeComparator<IT2> solutionSetComparator.     // grab a handle to the hash table from the iteration broker     if (taskContext instanceof AbstractIterativeTask) {         AbstractIterativeTask<?, ?> iterativeTaskContext = (AbstractIterativeTask<?, ?>) taskContext.         String identifier = iterativeTaskContext.brokerKey().         Object table = SolutionSetBroker.instance().get(identifier).         if (table instanceof CompactingHashTable) {             this.hashTable = (CompactingHashTable<IT2>) table.             solutionSetSerializer = this.hashTable.getBuildSideSerializer().             solutionSetComparator = this.hashTable.getBuildSideComparator().duplicate().         } else if (table instanceof JoinHashMap) {             this.objectMap = (JoinHashMap<IT2>) table.             solutionSetSerializer = this.objectMap.getBuildSerializer().             solutionSetComparator = this.objectMap.getBuildComparator().duplicate().         } else {             throw new RuntimeException("Unrecognized solution set index: " + table).         }     } else {         throw new Exception("The task context of this driver is no iterative task context.").     }     TaskConfig config = taskContext.getTaskConfig().     ClassLoader classLoader = taskContext.getUserCodeClassLoader().     TypeSerializer<IT1> probeSideSerializer = taskContext.<IT1>getInputSerializer(0).getSerializer().     TypeComparatorFactory<IT1> probeSideComparatorFactory = config.getDriverComparator(0, classLoader).     this.probeSideComparator = probeSideComparatorFactory.createComparator().     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     objectReuseEnabled = executionConfig.isObjectReuseEnabled().     if (objectReuseEnabled) {         solutionSideRecord = solutionSetSerializer.createInstance().         probeSideRecord = probeSideSerializer.createInstance().     }     TypePairComparatorFactory<IT1, IT2> factory = taskContext.getTaskConfig().getPairComparatorFactory(taskContext.getUserCodeClassLoader()).     pairComparator = factory.createComparator12(this.probeSideComparator, solutionSetComparator). }
false;public;0;6;;@Override public void prepare() { // nothing to prepare in each iteration // later, if we support out-of-core operation, we need to put the code in here // that brings the initial in-memory partitions into memory }
false;public;0;62;;@Override public void run() throws Exception {     final FlatJoinFunction<IT1, IT2, OT> joinFunction = taskContext.getStub().     final Collector<OT> collector = taskContext.getOutputCollector().     final MutableObjectIterator<IT1> probeSideInput = taskContext.getInput(0).     if (objectReuseEnabled) {         IT1 probeSideRecord = this.probeSideRecord.         if (hashTable != null) {             final CompactingHashTable<IT2> join = hashTable.             final CompactingHashTable<IT2>.HashTableProber<IT1> prober = join.getProber(probeSideComparator, pairComparator).             IT2 buildSideRecord = this.solutionSideRecord.             while (this.running && ((probeSideRecord = probeSideInput.next(probeSideRecord)) != null)) {                 IT2 matchedRecord = prober.getMatchFor(probeSideRecord, buildSideRecord).                 joinFunction.join(probeSideRecord, matchedRecord, collector).             }         } else if (objectMap != null) {             final JoinHashMap<IT2> hashTable = this.objectMap.             final JoinHashMap<IT2>.Prober<IT1> prober = this.objectMap.createProber(probeSideComparator, pairComparator).             final TypeSerializer<IT2> buildSerializer = hashTable.getBuildSerializer().             while (this.running && ((probeSideRecord = probeSideInput.next(probeSideRecord)) != null)) {                 IT2 match = prober.lookupMatch(probeSideRecord).                 joinFunction.join(probeSideRecord, buildSerializer.copy(match), collector).             }         } else {             throw new RuntimeException().         }     } else {         IT1 probeSideRecord.         if (hashTable != null) {             final CompactingHashTable<IT2> join = hashTable.             final CompactingHashTable<IT2>.HashTableProber<IT1> prober = join.getProber(probeSideComparator, pairComparator).             IT2 buildSideRecord.             while (this.running && ((probeSideRecord = probeSideInput.next()) != null)) {                 buildSideRecord = prober.getMatchFor(probeSideRecord).                 joinFunction.join(probeSideRecord, buildSideRecord, collector).             }         } else if (objectMap != null) {             final JoinHashMap<IT2> hashTable = this.objectMap.             final JoinHashMap<IT2>.Prober<IT1> prober = this.objectMap.createProber(probeSideComparator, pairComparator).             final TypeSerializer<IT2> buildSerializer = hashTable.getBuildSerializer().             while (this.running && ((probeSideRecord = probeSideInput.next()) != null)) {                 IT2 match = prober.lookupMatch(probeSideRecord).                 joinFunction.join(probeSideRecord, buildSerializer.copy(match), collector).             }         } else {             throw new RuntimeException().         }     } }
false;public;0;2;;@Override public void cleanup() { }
false;public;0;2;;@Override public void reset() { }
false;public;0;4;;@Override public void teardown() { // hash table is torn down by the iteration head task }
false;public;0;4;;@Override public void cancel() {     this.running = false. }
