commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the partition number of this partition.  *  * @return This partition's number.  */ ;// -------------------------------------------------------------------------------------------------- /**  * Gets the partition number of this partition.  *  * @return This partition's number.  */ public int getPartitionNumber() {     return this.partitionNumber. }
true;public;1;3;/**  * overwrites partition number and should only be used on compaction partition  * @param number new partition  */ ;/**  * overwrites partition number and should only be used on compaction partition  * @param number new partition  */ public void setPartitionNumber(int number) {     this.partitionNumber = number. }
true;public;0;3;/**  * @return number of segments owned by partition  */ ;/**  * @return number of segments owned by partition  */ public int getBlockCount() {     return this.partitionPages.size(). }
true;public;0;3;/**  * number of records in partition including garbage  *  * @return number record count  */ ;/**  * number of records in partition including garbage  *  * @return number record count  */ public long getRecordCount() {     return this.recordCounter. }
true;public;0;3;/**  * sets record counter to zero and should only be used on compaction partition  */ ;/**  * sets record counter to zero and should only be used on compaction partition  */ public void resetRecordCounter() {     this.recordCounter = 0L. }
true;public;0;4;/**  * resets read and write views and should only be used on compaction partition  */ ;/**  * resets read and write views and should only be used on compaction partition  */ public void resetRWViews() {     this.writeView.resetTo(0L).     this.readView.setReadPosition(0L). }
false;public;0;4;;public void pushDownPages() {     this.writeView = new WriteView(this.partitionPages, availableMemory, pageSize, pageSizeInBits).     this.readView = new ReadView(this.partitionPages, pageSize, pageSizeInBits). }
true;public;0;13;/**  * resets overflow bucket counters and returns freed memory and should only be used for resizing  *  * @return freed memory segments  */ ;/**  * resets overflow bucket counters and returns freed memory and should only be used for resizing  *  * @return freed memory segments  */ public ArrayList<MemorySegment> resetOverflowBuckets() {     this.numOverflowSegments = 0.     this.nextOverflowBucket = 0.     ArrayList<MemorySegment> result = new ArrayList<MemorySegment>(this.overflowSegments.length).     for (int i = 0. i < this.overflowSegments.length. i++) {         if (this.overflowSegments[i] != null) {             result.add(this.overflowSegments[i]).         }     }     this.overflowSegments = new MemorySegment[2].     return result. }
true;public;0;3;/**  * @return true if garbage exists in partition  */ ;/**  * @return true if garbage exists in partition  */ public boolean isCompacted() {     return this.compacted. }
true;public;1;3;/**  * sets compaction status (should only be set <code>true</code> directly after compaction and <code>false</code> when garbage was created)  *  * @param compacted compaction status  */ ;/**  * sets compaction status (should only be set <code>true</code> directly after compaction and <code>false</code> when garbage was created)  *  * @param compacted compaction status  */ public void setIsCompacted(boolean compacted) {     this.compacted = compacted. }
true;public,final;1;17;/**  * Inserts the given object into the current buffer. This method returns a pointer that  * can be used to address the written record in this partition.  *  * @param record The object to be written to the partition.  * @return A pointer to the object in the partition.  * @throws IOException Thrown when the write failed.  */ ;// -------------------------------------------------------------------------------------------------- /**  * Inserts the given object into the current buffer. This method returns a pointer that  * can be used to address the written record in this partition.  *  * @param record The object to be written to the partition.  * @return A pointer to the object in the partition.  * @throws IOException Thrown when the write failed.  */ public final long appendRecord(T record) throws IOException {     long pointer = this.writeView.getCurrentPointer().     try {         this.serializer.serialize(record, this.writeView).         this.recordCounter++.         return pointer.     } catch (EOFException e) {         // we ran out of pages.         // first, reset the pages and then we need to trigger a compaction         // int oldCurrentBuffer =         this.writeView.resetTo(pointer).         // }         throw e.     } }
false;public;2;4;;public T readRecordAt(long pointer, T reuse) throws IOException {     this.readView.setReadPosition(pointer).     return this.serializer.deserialize(reuse, this.readView). }
false;public;1;4;;public T readRecordAt(long pointer) throws IOException {     this.readView.setReadPosition(pointer).     return this.serializer.deserialize(this.readView). }
true;public;2;7;/**  * UNSAFE!! overwrites record  * causes inconsistency or data loss for overwriting everything but records of the exact same size  *  * @param pointer pointer to start of record  * @param record record to overwrite old one with  * @throws IOException  * @deprecated Don't use this, overwrites record and causes inconsistency or data loss for  * overwriting everything but records of the exact same size  */ ;/**  * UNSAFE!! overwrites record  * causes inconsistency or data loss for overwriting everything but records of the exact same size  *  * @param pointer pointer to start of record  * @param record record to overwrite old one with  * @throws IOException  * @deprecated Don't use this, overwrites record and causes inconsistency or data loss for  * overwriting everything but records of the exact same size  */ @Deprecated public void overwriteRecordAt(long pointer, T record) throws IOException {     long tmpPointer = this.writeView.getCurrentPointer().     this.writeView.resetTo(pointer).     this.serializer.serialize(record, this.writeView).     this.writeView.resetTo(tmpPointer). }
true;public;1;11;/**  * releases all of the partition's segments (pages and overflow buckets)  *  * @param target memory pool to release segments to  */ ;/**  * releases all of the partition's segments (pages and overflow buckets)  *  * @param target memory pool to release segments to  */ public void clearAllMemory(List<MemorySegment> target) {     // return the overflow segments     if (this.overflowSegments != null) {         for (int k = 0. k < this.numOverflowSegments. k++) {             target.add(this.overflowSegments[k]).         }     }     // return the partition buffers     target.addAll(this.partitionPages).     this.partitionPages.clear(). }
true;public;1;10;/**  * attempts to allocate specified number of segments and should only be used by compaction partition  * fails silently if not enough segments are available since next compaction could still succeed  *  * @param numberOfSegments allocation count  */ ;/**  * attempts to allocate specified number of segments and should only be used by compaction partition  * fails silently if not enough segments are available since next compaction could still succeed  *  * @param numberOfSegments allocation count  */ public void allocateSegments(int numberOfSegments) {     while (getBlockCount() < numberOfSegments) {         MemorySegment next = this.availableMemory.nextSegment().         if (next != null) {             this.partitionPages.add(next).         } else {             return.         }     } }
false;public;0;4;;@Override public String toString() {     return String.format("Partition %d - %d records, %d partition blocks, %d bucket overflow blocks", getPartitionNumber(), getRecordCount(), getBlockCount(), this.numOverflowSegments). }
false;protected;2;11;;@Override protected MemorySegment nextSegment(MemorySegment current, int bytesUsed) throws IOException {     MemorySegment next = this.memSource.nextSegment().     if (next == null) {         throw new EOFException().     }     this.pages.add(next).     this.currentPageNumber++.     return next. }
false;private;0;3;;private long getCurrentPointer() {     return (((long) this.currentPageNumber) << this.sizeBits) + getCurrentPositionInSegment(). }
false;private;1;11;;private int resetTo(long pointer) {     final int pageNum = (int) (pointer >>> this.sizeBits).     final int offset = (int) (pointer & this.sizeMask).     this.currentPageNumber = pageNum.     int posInArray = pageNum - this.segmentNumberOffset.     seekOutput(this.pages.get(posInArray), offset).     return posInArray. }
false;public;1;4;;@SuppressWarnings("unused") public void setSegmentNumberOffset(int offset) {     this.segmentNumberOffset = offset. }
false;protected;1;8;;@Override protected MemorySegment nextSegment(MemorySegment current) throws EOFException {     if (++this.currentSegmentIndex < this.segments.size()) {         return this.segments.get(this.currentSegmentIndex).     } else {         throw new EOFException().     } }
false;protected;1;4;;@Override protected int getLimitForSegment(MemorySegment segment) {     return this.segmentSizeMask + 1. }
false;public;1;8;;@Override public void setReadPosition(long position) {     final int bufferNum = ((int) (position >>> this.segmentSizeBits)) - this.segmentNumberOffset.     final int offset = (int) (position & this.segmentSizeMask).     this.currentSegmentIndex = bufferNum.     seekInput(this.segments.get(bufferNum), offset, this.segmentSizeMask + 1). }
false;public;1;4;;@SuppressWarnings("unused") public void setSegmentNumberOffset(int offset) {     this.segmentNumberOffset = offset. }
