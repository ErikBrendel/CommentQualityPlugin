commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void setup(TaskContext<AbstractRichFunction, T> context) {     this.taskContext = context.     this.running = true. }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 1. }
false;public;0;4;;@Override public Class<AbstractRichFunction> getStubType() {     return null. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 0. }
false;public;0;9;;@Override public void prepare() {     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     this.objectReuseEnabled = executionConfig.isObjectReuseEnabled().     if (LOG.isDebugEnabled()) {         LOG.debug("NoOpDriver object reuse: " + (this.objectReuseEnabled ? "ENABLED" : "DISABLED") + ".").     } }
false;public;0;24;;@Override public void run() throws Exception {     // cache references on the stack     final Counter numRecordsIn = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsInCounter().     final Counter numRecordsOut = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsOutCounter().     final MutableObjectIterator<T> input = this.taskContext.getInput(0).     final Collector<T> output = new CountingCollector<>(this.taskContext.getOutputCollector(), numRecordsOut).     if (objectReuseEnabled) {         T record = this.taskContext.<T>getInputSerializer(0).getSerializer().createInstance().         while (this.running && ((record = input.next(record)) != null)) {             numRecordsIn.inc().             output.collect(record).         }     } else {         T record.         while (this.running && ((record = input.next()) != null)) {             numRecordsIn.inc().             output.collect(record).         }     } }
false;public;0;2;;@Override public void cleanup() { }
false;public;0;4;;@Override public void cancel() {     this.running = false. }
