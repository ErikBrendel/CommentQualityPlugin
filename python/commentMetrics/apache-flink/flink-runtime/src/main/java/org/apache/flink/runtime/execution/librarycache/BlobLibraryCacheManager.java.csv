# id;timestamp;commentText;codeText;commentWords;codeWords
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1474717550;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1474719549;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1487441974;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1495001929;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1499173045;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1502201311;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1502692653;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1503041372;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1505998908;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1507212387;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1507212387;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1508939746;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> LibraryCacheEntry -> void releaseClassLoader();1526549506;Release the class loader to ensure any file descriptors are closed_and the cached libraries are deleted immediately.;void releaseClassLoader() {_			try {_				classLoader.close()__			} catch (IOException e) {_				LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray()))__			}_		};release,the,class,loader,to,ensure,any,file,descriptors,are,closed,and,the,cached,libraries,are,deleted,immediately;void,release,class,loader,try,class,loader,close,catch,ioexception,e,log,warn,failed,to,release,user,code,class,loader,for,arrays,to,string,libraries,to,array
BlobLibraryCacheManager -> @Override 	public ClassLoader getClassLoader(final JobID id);1412605211;Returns the class loader to the specified vertex.__@param id_the ID of the job to return the class loader for_@return the class loader of requested vertex or <code>null</code> if no class loader has been registered with the_given ID.;@Override_	public ClassLoader getClassLoader(final JobID id) {_		return this.classLoaders.get(id)__	};returns,the,class,loader,to,the,specified,vertex,param,id,the,id,of,the,job,to,return,the,class,loader,for,return,the,class,loader,of,requested,vertex,or,code,null,code,if,no,class,loader,has,been,registered,with,the,given,id;override,public,class,loader,get,class,loader,final,job,id,id,return,this,class,loaders,get,id
BlobLibraryCacheManager -> @Override 	public ClassLoader getClassLoader(final JobID id);1413208391;Returns the class loader to the specified vertex.__@param id_the ID of the job to return the class loader for_@return the class loader of requested vertex or <code>null</code> if no class loader has been registered with the_given ID.;@Override_	public ClassLoader getClassLoader(final JobID id) {_		return this.classLoaders.get(id)__	};returns,the,class,loader,to,the,specified,vertex,param,id,the,id,of,the,job,to,return,the,class,loader,for,return,the,class,loader,of,requested,vertex,or,code,null,code,if,no,class,loader,has,been,registered,with,the,given,id;override,public,class,loader,get,class,loader,final,job,id,id,return,this,class,loaders,get,id
BlobLibraryCacheManager -> @Override 	public ClassLoader getClassLoader(final JobID id);1413211710;Returns the class loader to the specified vertex.__@param id_the ID of the job to return the class loader for_@return the class loader of requested vertex or <code>null</code> if no class loader has been registered with the_given ID.;@Override_	public ClassLoader getClassLoader(final JobID id) {_		return this.classLoaders.get(id)__	};returns,the,class,loader,to,the,specified,vertex,param,id,the,id,of,the,job,to,return,the,class,loader,for,return,the,class,loader,of,requested,vertex,or,code,null,code,if,no,class,loader,has,been,registered,with,the,given,id;override,public,class,loader,get,class,loader,final,job,id,id,return,this,class,loaders,get,id
BlobLibraryCacheManager -> LibraryCacheEntry -> LibraryCacheEntry( 				Collection<BlobKey> requiredLibraries, 				Collection<URL> requiredClasspaths, 				URL[] libraryURLs, 				ExecutionAttemptID initialReference, 				FlinkUserCodeClassLoaders.ResolveOrder classLoaderResolveOrder);1505998908;Creates a cache entry for a flink class loader with the given <tt>libraryURLs</tt>.__@param requiredLibraries_BLOB keys required by the class loader (stored for ensuring consistency among different_job/task registrations)_@param requiredClasspaths_class paths required by the class loader (stored for ensuring consistency among_different job/task registrations)_@param libraryURLs_complete list of URLs to use for the class loader (includes references to the_<tt>requiredLibraries</tt> and <tt>requiredClasspaths</tt>)_@param initialReference_reference holder ID;LibraryCacheEntry(_				Collection<BlobKey> requiredLibraries,_				Collection<URL> requiredClasspaths,_				URL[] libraryURLs,_				ExecutionAttemptID initialReference,_				FlinkUserCodeClassLoaders.ResolveOrder classLoaderResolveOrder) {__			this.classLoader =_				FlinkUserCodeClassLoaders.create(_					classLoaderResolveOrder,_					libraryURLs,_					FlinkUserCodeClassLoaders.class.getClassLoader())___			_			_			_			this.classPaths = new HashSet<>(requiredClasspaths.size())__			for (URL url : requiredClasspaths) {_				classPaths.add(url.toString())__			}_			this.libraries = new HashSet<>(requiredLibraries)__			this.referenceHolders = new HashSet<>()__			this.referenceHolders.add(initialReference)__		};creates,a,cache,entry,for,a,flink,class,loader,with,the,given,tt,library,urls,tt,param,required,libraries,blob,keys,required,by,the,class,loader,stored,for,ensuring,consistency,among,different,job,task,registrations,param,required,classpaths,class,paths,required,by,the,class,loader,stored,for,ensuring,consistency,among,different,job,task,registrations,param,library,urls,complete,list,of,urls,to,use,for,the,class,loader,includes,references,to,the,tt,required,libraries,tt,and,tt,required,classpaths,tt,param,initial,reference,reference,holder,id;library,cache,entry,collection,blob,key,required,libraries,collection,url,required,classpaths,url,library,urls,execution,attempt,id,initial,reference,flink,user,code,class,loaders,resolve,order,class,loader,resolve,order,this,class,loader,flink,user,code,class,loaders,create,class,loader,resolve,order,library,urls,flink,user,code,class,loaders,class,get,class,loader,this,class,paths,new,hash,set,required,classpaths,size,for,url,url,required,classpaths,class,paths,add,url,to,string,this,libraries,new,hash,set,required,libraries,this,reference,holders,new,hash,set,this,reference,holders,add,initial,reference
BlobLibraryCacheManager -> LibraryCacheEntry -> LibraryCacheEntry( 				Collection<BlobKey> requiredLibraries, 				Collection<URL> requiredClasspaths, 				URL[] libraryURLs, 				ExecutionAttemptID initialReference, 				FlinkUserCodeClassLoaders.ResolveOrder classLoaderResolveOrder);1507212387;Creates a cache entry for a flink class loader with the given <tt>libraryURLs</tt>.__@param requiredLibraries_BLOB keys required by the class loader (stored for ensuring consistency among different_job/task registrations)_@param requiredClasspaths_class paths required by the class loader (stored for ensuring consistency among_different job/task registrations)_@param libraryURLs_complete list of URLs to use for the class loader (includes references to the_<tt>requiredLibraries</tt> and <tt>requiredClasspaths</tt>)_@param initialReference_reference holder ID;LibraryCacheEntry(_				Collection<BlobKey> requiredLibraries,_				Collection<URL> requiredClasspaths,_				URL[] libraryURLs,_				ExecutionAttemptID initialReference,_				FlinkUserCodeClassLoaders.ResolveOrder classLoaderResolveOrder) {__			this.classLoader =_				FlinkUserCodeClassLoaders.create(_					classLoaderResolveOrder,_					libraryURLs,_					FlinkUserCodeClassLoaders.class.getClassLoader())___			_			_			_			this.classPaths = new HashSet<>(requiredClasspaths.size())__			for (URL url : requiredClasspaths) {_				classPaths.add(url.toString())__			}_			this.libraries = new HashSet<>(requiredLibraries)__			this.referenceHolders = new HashSet<>()__			this.referenceHolders.add(initialReference)__		};creates,a,cache,entry,for,a,flink,class,loader,with,the,given,tt,library,urls,tt,param,required,libraries,blob,keys,required,by,the,class,loader,stored,for,ensuring,consistency,among,different,job,task,registrations,param,required,classpaths,class,paths,required,by,the,class,loader,stored,for,ensuring,consistency,among,different,job,task,registrations,param,library,urls,complete,list,of,urls,to,use,for,the,class,loader,includes,references,to,the,tt,required,libraries,tt,and,tt,required,classpaths,tt,param,initial,reference,reference,holder,id;library,cache,entry,collection,blob,key,required,libraries,collection,url,required,classpaths,url,library,urls,execution,attempt,id,initial,reference,flink,user,code,class,loaders,resolve,order,class,loader,resolve,order,this,class,loader,flink,user,code,class,loaders,create,class,loader,resolve,order,library,urls,flink,user,code,class,loaders,class,get,class,loader,this,class,paths,new,hash,set,required,classpaths,size,for,url,url,required,classpaths,class,paths,add,url,to,string,this,libraries,new,hash,set,required,libraries,this,reference,holders,new,hash,set,this,reference,holders,add,initial,reference
BlobLibraryCacheManager -> private <K> int decrementReferenceCounter(final K key, final Map<K, 			Integer> map);1412605211;Decrements the reference counter associated with the key__@param key_the key identifying the counter to decrement_@return the decremented reference counter;private <K> int decrementReferenceCounter(final K key, final Map<K,_			Integer> map) {__		if (!map.containsKey(key)) {_			throw new IllegalStateException("Cannot find reference counter entry for key " + key)__		}else{_			int counter = map.get(key) -1___			if(counter == 0){_				map.remove(key)__			}else{_				map.put(key, counter)__			}__			return counter__		}_	};decrements,the,reference,counter,associated,with,the,key,param,key,the,key,identifying,the,counter,to,decrement,return,the,decremented,reference,counter;private,k,int,decrement,reference,counter,final,k,key,final,map,k,integer,map,if,map,contains,key,key,throw,new,illegal,state,exception,cannot,find,reference,counter,entry,for,key,key,else,int,counter,map,get,key,1,if,counter,0,map,remove,key,else,map,put,key,counter,return,counter
BlobLibraryCacheManager -> private <K> int decrementReferenceCounter(final K key, final Map<K, 			Integer> map);1413208391;Decrements the reference counter associated with the key__@param key_the key identifying the counter to decrement_@return the decremented reference counter;private <K> int decrementReferenceCounter(final K key, final Map<K,_			Integer> map) {__		if (!map.containsKey(key)) {_			throw new IllegalStateException("Cannot find reference counter entry for key " + key)__		}else{_			int counter = map.get(key) -1___			if(counter == 0){_				map.remove(key)__			}else{_				map.put(key, counter)__			}__			return counter__		}_	};decrements,the,reference,counter,associated,with,the,key,param,key,the,key,identifying,the,counter,to,decrement,return,the,decremented,reference,counter;private,k,int,decrement,reference,counter,final,k,key,final,map,k,integer,map,if,map,contains,key,key,throw,new,illegal,state,exception,cannot,find,reference,counter,entry,for,key,key,else,int,counter,map,get,key,1,if,counter,0,map,remove,key,else,map,put,key,counter,return,counter
BlobLibraryCacheManager -> private <K> int decrementReferenceCounter(final K key, final Map<K, 			Integer> map);1413211710;Decrements the reference counter associated with the key__@param key_the key identifying the counter to decrement_@return the decremented reference counter;private <K> int decrementReferenceCounter(final K key, final Map<K,_			Integer> map) {__		if (!map.containsKey(key)) {_			throw new IllegalStateException("Cannot find reference counter entry for key " + key)__		}else{_			int counter = map.get(key) -1___			if(counter == 0){_				map.remove(key)__			}else{_				map.put(key, counter)__			}__			return counter__		}_	};decrements,the,reference,counter,associated,with,the,key,param,key,the,key,identifying,the,counter,to,decrement,return,the,decremented,reference,counter;private,k,int,decrement,reference,counter,final,k,key,final,map,k,integer,map,if,map,contains,key,key,throw,new,illegal,state,exception,cannot,find,reference,counter,entry,for,key,key,else,int,counter,map,get,key,1,if,counter,0,map,remove,key,else,map,put,key,counter,return,counter
BlobLibraryCacheManager -> public BlobLibraryCacheManager(BlobService blobService, long cleanupInterval);1499173045;Creates the blob library cache manager.__@param blobService blob file retrieval service to use_@param cleanupInterval cleanup interval in milliseconds;public BlobLibraryCacheManager(BlobService blobService, long cleanupInterval) {_		this.blobService = checkNotNull(blobService)___		_		this.cleanupTimer = new Timer(true)__		this.cleanupTimer.schedule(this, cleanupInterval, cleanupInterval)__	};creates,the,blob,library,cache,manager,param,blob,service,blob,file,retrieval,service,to,use,param,cleanup,interval,cleanup,interval,in,milliseconds;public,blob,library,cache,manager,blob,service,blob,service,long,cleanup,interval,this,blob,service,check,not,null,blob,service,this,cleanup,timer,new,timer,true,this,cleanup,timer,schedule,this,cleanup,interval,cleanup,interval
BlobLibraryCacheManager -> public BlobLibraryCacheManager(BlobService blobService, long cleanupInterval);1502201311;Creates the blob library cache manager.__@param blobService blob file retrieval service to use_@param cleanupInterval cleanup interval in milliseconds;public BlobLibraryCacheManager(BlobService blobService, long cleanupInterval) {_		this.blobService = checkNotNull(blobService)___		_		this.cleanupTimer = new Timer(true)__		this.cleanupTimer.schedule(this, cleanupInterval, cleanupInterval)__	};creates,the,blob,library,cache,manager,param,blob,service,blob,file,retrieval,service,to,use,param,cleanup,interval,cleanup,interval,in,milliseconds;public,blob,library,cache,manager,blob,service,blob,service,long,cleanup,interval,this,blob,service,check,not,null,blob,service,this,cleanup,timer,new,timer,true,this,cleanup,timer,schedule,this,cleanup,interval,cleanup,interval
BlobLibraryCacheManager -> public BlobLibraryCacheManager(BlobService blobService, long cleanupInterval);1502692653;Creates the blob library cache manager.__@param blobService blob file retrieval service to use_@param cleanupInterval cleanup interval in milliseconds;public BlobLibraryCacheManager(BlobService blobService, long cleanupInterval) {_		this.blobService = checkNotNull(blobService)___		_		this.cleanupTimer = new Timer(true)__		this.cleanupTimer.schedule(this, cleanupInterval, cleanupInterval)__	};creates,the,blob,library,cache,manager,param,blob,service,blob,file,retrieval,service,to,use,param,cleanup,interval,cleanup,interval,in,milliseconds;public,blob,library,cache,manager,blob,service,blob,service,long,cleanup,interval,this,blob,service,check,not,null,blob,service,this,cleanup,timer,new,timer,true,this,cleanup,timer,schedule,this,cleanup,interval,cleanup,interval
BlobLibraryCacheManager -> int getNumberOfReferenceHolders(JobID jobId);1503041372;Gets the number of tasks holding {@link ClassLoader} references for the given job.__@param jobId ID of a job__@return number of reference holders;int getNumberOfReferenceHolders(JobID jobId) {_		synchronized (lockObject) {_			LibraryCacheEntry entry = cacheEntries.get(jobId)__			return entry == null ? 0 : entry.getNumberOfReferenceHolders()__		}_	};gets,the,number,of,tasks,holding,link,class,loader,references,for,the,given,job,param,job,id,id,of,a,job,return,number,of,reference,holders;int,get,number,of,reference,holders,job,id,job,id,synchronized,lock,object,library,cache,entry,entry,cache,entries,get,job,id,return,entry,null,0,entry,get,number,of,reference,holders
BlobLibraryCacheManager -> int getNumberOfReferenceHolders(JobID jobId);1505998908;Gets the number of tasks holding {@link ClassLoader} references for the given job.__@param jobId ID of a job__@return number of reference holders;int getNumberOfReferenceHolders(JobID jobId) {_		synchronized (lockObject) {_			LibraryCacheEntry entry = cacheEntries.get(jobId)__			return entry == null ? 0 : entry.getNumberOfReferenceHolders()__		}_	};gets,the,number,of,tasks,holding,link,class,loader,references,for,the,given,job,param,job,id,id,of,a,job,return,number,of,reference,holders;int,get,number,of,reference,holders,job,id,job,id,synchronized,lock,object,library,cache,entry,entry,cache,entries,get,job,id,return,entry,null,0,entry,get,number,of,reference,holders
BlobLibraryCacheManager -> int getNumberOfReferenceHolders(JobID jobId);1507212387;Gets the number of tasks holding {@link ClassLoader} references for the given job.__@param jobId ID of a job__@return number of reference holders;int getNumberOfReferenceHolders(JobID jobId) {_		synchronized (lockObject) {_			LibraryCacheEntry entry = cacheEntries.get(jobId)__			return entry == null ? 0 : entry.getNumberOfReferenceHolders()__		}_	};gets,the,number,of,tasks,holding,link,class,loader,references,for,the,given,job,param,job,id,id,of,a,job,return,number,of,reference,holders;int,get,number,of,reference,holders,job,id,job,id,synchronized,lock,object,library,cache,entry,entry,cache,entries,get,job,id,return,entry,null,0,entry,get,number,of,reference,holders
BlobLibraryCacheManager -> int getNumberOfReferenceHolders(JobID jobId);1507212387;Gets the number of tasks holding {@link ClassLoader} references for the given job.__@param jobId ID of a job__@return number of reference holders;int getNumberOfReferenceHolders(JobID jobId) {_		synchronized (lockObject) {_			LibraryCacheEntry entry = cacheEntries.get(jobId)__			return entry == null ? 0 : entry.getNumberOfReferenceHolders()__		}_	};gets,the,number,of,tasks,holding,link,class,loader,references,for,the,given,job,param,job,id,id,of,a,job,return,number,of,reference,holders;int,get,number,of,reference,holders,job,id,job,id,synchronized,lock,object,library,cache,entry,entry,cache,entries,get,job,id,return,entry,null,0,entry,get,number,of,reference,holders
BlobLibraryCacheManager -> int getNumberOfReferenceHolders(JobID jobId);1508939746;Gets the number of tasks holding {@link ClassLoader} references for the given job.__@param jobId ID of a job__@return number of reference holders;int getNumberOfReferenceHolders(JobID jobId) {_		synchronized (lockObject) {_			LibraryCacheEntry entry = cacheEntries.get(jobId)__			return entry == null ? 0 : entry.getNumberOfReferenceHolders()__		}_	};gets,the,number,of,tasks,holding,link,class,loader,references,for,the,given,job,param,job,id,id,of,a,job,return,number,of,reference,holders;int,get,number,of,reference,holders,job,id,job,id,synchronized,lock,object,library,cache,entry,entry,cache,entries,get,job,id,return,entry,null,0,entry,get,number,of,reference,holders
BlobLibraryCacheManager -> int getNumberOfReferenceHolders(JobID jobId);1526549506;Gets the number of tasks holding {@link ClassLoader} references for the given job.__@param jobId ID of a job__@return number of reference holders;int getNumberOfReferenceHolders(JobID jobId) {_		synchronized (lockObject) {_			LibraryCacheEntry entry = cacheEntries.get(jobId)__			return entry == null ? 0 : entry.getNumberOfReferenceHolders()__		}_	};gets,the,number,of,tasks,holding,link,class,loader,references,for,the,given,job,param,job,id,id,of,a,job,return,number,of,reference,holders;int,get,number,of,reference,holders,job,id,job,id,synchronized,lock,object,library,cache,entry,entry,cache,entries,get,job,id,return,entry,null,0,entry,get,number,of,reference,holders
BlobLibraryCacheManager -> @Override 	public void run();1412605211;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<BlobKey> it = registeredBlobs.iterator()___			while (it.hasNext()) {_				BlobKey key = it.next()___				try {_					if (!blobKeyReferenceCounter.containsKey(key)) {_						blobService.delete(key)__						it.remove()__					}_				} catch (IOException ioe) {_					LOG.warn("Could not delete file with blob key" + key, ioe)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,blob,key,it,registered,blobs,iterator,while,it,has,next,blob,key,key,it,next,try,if,blob,key,reference,counter,contains,key,key,blob,service,delete,key,it,remove,catch,ioexception,ioe,log,warn,could,not,delete,file,with,blob,key,key,ioe
BlobLibraryCacheManager -> @Override 	public void run();1413208391;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<BlobKey> it = registeredBlobs.iterator()___			while (it.hasNext()) {_				BlobKey key = it.next()___				try {_					if (!blobKeyReferenceCounter.containsKey(key)) {_						blobService.delete(key)__						it.remove()__					}_				} catch (IOException ioe) {_					LOG.warn("Could not delete file with blob key" + key, ioe)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,blob,key,it,registered,blobs,iterator,while,it,has,next,blob,key,key,it,next,try,if,blob,key,reference,counter,contains,key,key,blob,service,delete,key,it,remove,catch,ioexception,ioe,log,warn,could,not,delete,file,with,blob,key,key,ioe
BlobLibraryCacheManager -> @Override 	public void run();1413211710;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<BlobKey> it = registeredBlobs.iterator()___			while (it.hasNext()) {_				BlobKey key = it.next()___				try {_					if (!blobKeyReferenceCounter.containsKey(key)) {_						blobService.delete(key)__						it.remove()__					}_				} catch (IOException ioe) {_					LOG.warn("Could not delete file with blob key" + key, ioe)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,blob,key,it,registered,blobs,iterator,while,it,has,next,blob,key,key,it,next,try,if,blob,key,reference,counter,contains,key,key,blob,service,delete,key,it,remove,catch,ioexception,ioe,log,warn,could,not,delete,file,with,blob,key,key,ioe
BlobLibraryCacheManager -> @Override 	public void run();1415043780;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1416257751;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1418925508;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1418925511;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1424732907;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1426795085;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1427713036;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1427784999;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1436966346;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1444312509;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1452854660;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1454947077;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1465991918;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1469452826;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1474717550;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1474719549;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1487441974;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1495001929;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1499173045;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1502201311;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> @Override 	public void run();1502692653;Cleans up blobs which are not referenced anymore;@Override_	public void run() {_		synchronized (lockObject) {_			Iterator<Map.Entry<BlobKey, Integer>> entryIter = blobKeyReferenceCounters.entrySet().iterator()__			_			while (entryIter.hasNext()) {_				Map.Entry<BlobKey, Integer> entry = entryIter.next()__				BlobKey key = entry.getKey()__				int references = entry.getValue()__				_				try {_					if (references <= 0) {_						blobService.delete(key)__						entryIter.remove()__					}_				} catch (Throwable t) {_					LOG.warn("Could not delete file with blob key" + key, t)__				}_			}_		}_	};cleans,up,blobs,which,are,not,referenced,anymore;override,public,void,run,synchronized,lock,object,iterator,map,entry,blob,key,integer,entry,iter,blob,key,reference,counters,entry,set,iterator,while,entry,iter,has,next,map,entry,blob,key,integer,entry,entry,iter,next,blob,key,key,entry,get,key,int,references,entry,get,value,try,if,references,0,blob,service,delete,key,entry,iter,remove,catch,throwable,t,log,warn,could,not,delete,file,with,blob,key,key,t
BlobLibraryCacheManager -> private <K> int incrementReferenceCounter(final K key, final Map<K, 	Integer> map);1412605211;Increments the reference counter of the corrsponding map__@param key_the key identifying the counter to increment_@return the increased reference counter;private <K> int incrementReferenceCounter(final K key, final Map<K,_	Integer> map) {__		if(!map.containsKey(key)){_			map.put(key, 1)___			return 1__		}else{_			int counter = map.get(key) + 1__			map.put(key, counter)___			return counter__		}_	};increments,the,reference,counter,of,the,corrsponding,map,param,key,the,key,identifying,the,counter,to,increment,return,the,increased,reference,counter;private,k,int,increment,reference,counter,final,k,key,final,map,k,integer,map,if,map,contains,key,key,map,put,key,1,return,1,else,int,counter,map,get,key,1,map,put,key,counter,return,counter
BlobLibraryCacheManager -> private <K> int incrementReferenceCounter(final K key, final Map<K, 	Integer> map);1413208391;Increments the reference counter of the corrsponding map__@param key_the key identifying the counter to increment_@return the increased reference counter;private <K> int incrementReferenceCounter(final K key, final Map<K,_	Integer> map) {__		if(!map.containsKey(key)){_			map.put(key, 1)___			return 1__		}else{_			int counter = map.get(key) + 1__			map.put(key, counter)___			return counter__		}_	};increments,the,reference,counter,of,the,corrsponding,map,param,key,the,key,identifying,the,counter,to,increment,return,the,increased,reference,counter;private,k,int,increment,reference,counter,final,k,key,final,map,k,integer,map,if,map,contains,key,key,map,put,key,1,return,1,else,int,counter,map,get,key,1,map,put,key,counter,return,counter
BlobLibraryCacheManager -> private <K> int incrementReferenceCounter(final K key, final Map<K, 	Integer> map);1413211710;Increments the reference counter of the corrsponding map__@param key_the key identifying the counter to increment_@return the increased reference counter;private <K> int incrementReferenceCounter(final K key, final Map<K,_	Integer> map) {__		if(!map.containsKey(key)){_			map.put(key, 1)___			return 1__		}else{_			int counter = map.get(key) + 1__			map.put(key, counter)___			return counter__		}_	};increments,the,reference,counter,of,the,corrsponding,map,param,key,the,key,identifying,the,counter,to,increment,return,the,increased,reference,counter;private,k,int,increment,reference,counter,final,k,key,final,map,k,integer,map,if,map,contains,key,key,map,put,key,1,return,1,else,int,counter,map,get,key,1,map,put,key,counter,return,counter
BlobLibraryCacheManager -> LibraryCacheEntry -> LibraryCacheEntry( 				Collection<PermanentBlobKey> requiredLibraries, 				Collection<URL> requiredClasspaths, 				URL[] libraryURLs, 				ExecutionAttemptID initialReference, 				FlinkUserCodeClassLoaders.ResolveOrder classLoaderResolveOrder, 				String[] alwaysParentFirstPatterns);1508939746;Creates a cache entry for a flink class loader with the given <tt>libraryURLs</tt>.__@param requiredLibraries_BLOB keys required by the class loader (stored for ensuring consistency among different_job/task registrations)_@param requiredClasspaths_class paths required by the class loader (stored for ensuring consistency among_different job/task registrations)_@param libraryURLs_complete list of URLs to use for the class loader (includes references to the_<tt>requiredLibraries</tt> and <tt>requiredClasspaths</tt>)_@param initialReference_reference holder ID_@param classLoaderResolveOrder Whether to resolve classes first in the child ClassLoader_or parent ClassLoader_@param alwaysParentFirstPatterns A list of patterns for classes that should always be_resolved from the parent ClassLoader (if possible).;LibraryCacheEntry(_				Collection<PermanentBlobKey> requiredLibraries,_				Collection<URL> requiredClasspaths,_				URL[] libraryURLs,_				ExecutionAttemptID initialReference,_				FlinkUserCodeClassLoaders.ResolveOrder classLoaderResolveOrder,_				String[] alwaysParentFirstPatterns) {__			this.classLoader =_				FlinkUserCodeClassLoaders.create(_					classLoaderResolveOrder,_					libraryURLs,_					FlinkUserCodeClassLoaders.class.getClassLoader(),_					alwaysParentFirstPatterns)___			_			_			_			this.classPaths = new HashSet<>(requiredClasspaths.size())__			for (URL url : requiredClasspaths) {_				classPaths.add(url.toString())__			}_			this.libraries = new HashSet<>(requiredLibraries)__			this.referenceHolders = new HashSet<>()__			this.referenceHolders.add(initialReference)__		};creates,a,cache,entry,for,a,flink,class,loader,with,the,given,tt,library,urls,tt,param,required,libraries,blob,keys,required,by,the,class,loader,stored,for,ensuring,consistency,among,different,job,task,registrations,param,required,classpaths,class,paths,required,by,the,class,loader,stored,for,ensuring,consistency,among,different,job,task,registrations,param,library,urls,complete,list,of,urls,to,use,for,the,class,loader,includes,references,to,the,tt,required,libraries,tt,and,tt,required,classpaths,tt,param,initial,reference,reference,holder,id,param,class,loader,resolve,order,whether,to,resolve,classes,first,in,the,child,class,loader,or,parent,class,loader,param,always,parent,first,patterns,a,list,of,patterns,for,classes,that,should,always,be,resolved,from,the,parent,class,loader,if,possible;library,cache,entry,collection,permanent,blob,key,required,libraries,collection,url,required,classpaths,url,library,urls,execution,attempt,id,initial,reference,flink,user,code,class,loaders,resolve,order,class,loader,resolve,order,string,always,parent,first,patterns,this,class,loader,flink,user,code,class,loaders,create,class,loader,resolve,order,library,urls,flink,user,code,class,loaders,class,get,class,loader,always,parent,first,patterns,this,class,paths,new,hash,set,required,classpaths,size,for,url,url,required,classpaths,class,paths,add,url,to,string,this,libraries,new,hash,set,required,libraries,this,reference,holders,new,hash,set,this,reference,holders,add,initial,reference
BlobLibraryCacheManager -> LibraryCacheEntry -> LibraryCacheEntry( 				Collection<PermanentBlobKey> requiredLibraries, 				Collection<URL> requiredClasspaths, 				URL[] libraryURLs, 				ExecutionAttemptID initialReference, 				FlinkUserCodeClassLoaders.ResolveOrder classLoaderResolveOrder, 				String[] alwaysParentFirstPatterns);1526549506;Creates a cache entry for a flink class loader with the given <tt>libraryURLs</tt>.__@param requiredLibraries_BLOB keys required by the class loader (stored for ensuring consistency among different_job/task registrations)_@param requiredClasspaths_class paths required by the class loader (stored for ensuring consistency among_different job/task registrations)_@param libraryURLs_complete list of URLs to use for the class loader (includes references to the_<tt>requiredLibraries</tt> and <tt>requiredClasspaths</tt>)_@param initialReference_reference holder ID_@param classLoaderResolveOrder Whether to resolve classes first in the child ClassLoader_or parent ClassLoader_@param alwaysParentFirstPatterns A list of patterns for classes that should always be_resolved from the parent ClassLoader (if possible).;LibraryCacheEntry(_				Collection<PermanentBlobKey> requiredLibraries,_				Collection<URL> requiredClasspaths,_				URL[] libraryURLs,_				ExecutionAttemptID initialReference,_				FlinkUserCodeClassLoaders.ResolveOrder classLoaderResolveOrder,_				String[] alwaysParentFirstPatterns) {__			this.classLoader =_				FlinkUserCodeClassLoaders.create(_					classLoaderResolveOrder,_					libraryURLs,_					FlinkUserCodeClassLoaders.class.getClassLoader(),_					alwaysParentFirstPatterns)___			_			_			_			this.classPaths = new HashSet<>(requiredClasspaths.size())__			for (URL url : requiredClasspaths) {_				classPaths.add(url.toString())__			}_			this.libraries = new HashSet<>(requiredLibraries)__			this.referenceHolders = new HashSet<>()__			this.referenceHolders.add(initialReference)__		};creates,a,cache,entry,for,a,flink,class,loader,with,the,given,tt,library,urls,tt,param,required,libraries,blob,keys,required,by,the,class,loader,stored,for,ensuring,consistency,among,different,job,task,registrations,param,required,classpaths,class,paths,required,by,the,class,loader,stored,for,ensuring,consistency,among,different,job,task,registrations,param,library,urls,complete,list,of,urls,to,use,for,the,class,loader,includes,references,to,the,tt,required,libraries,tt,and,tt,required,classpaths,tt,param,initial,reference,reference,holder,id,param,class,loader,resolve,order,whether,to,resolve,classes,first,in,the,child,class,loader,or,parent,class,loader,param,always,parent,first,patterns,a,list,of,patterns,for,classes,that,should,always,be,resolved,from,the,parent,class,loader,if,possible;library,cache,entry,collection,permanent,blob,key,required,libraries,collection,url,required,classpaths,url,library,urls,execution,attempt,id,initial,reference,flink,user,code,class,loaders,resolve,order,class,loader,resolve,order,string,always,parent,first,patterns,this,class,loader,flink,user,code,class,loaders,create,class,loader,resolve,order,library,urls,flink,user,code,class,loaders,class,get,class,loader,always,parent,first,patterns,this,class,paths,new,hash,set,required,classpaths,size,for,url,url,required,classpaths,class,paths,add,url,to,string,this,libraries,new,hash,set,required,libraries,this,reference,holders,new,hash,set,this,reference,holders,add,initial,reference
BlobLibraryCacheManager -> int getNumberOfManagedJobs();1503041372;Returns the number of registered jobs that this library cache manager handles.__@return number of jobs (irrespective of the actual number of tasks per job);int getNumberOfManagedJobs() {_		_		return cacheEntries.size()__	};returns,the,number,of,registered,jobs,that,this,library,cache,manager,handles,return,number,of,jobs,irrespective,of,the,actual,number,of,tasks,per,job;int,get,number,of,managed,jobs,return,cache,entries,size
BlobLibraryCacheManager -> int getNumberOfManagedJobs();1505998908;Returns the number of registered jobs that this library cache manager handles.__@return number of jobs (irrespective of the actual number of tasks per job);int getNumberOfManagedJobs() {_		_		return cacheEntries.size()__	};returns,the,number,of,registered,jobs,that,this,library,cache,manager,handles,return,number,of,jobs,irrespective,of,the,actual,number,of,tasks,per,job;int,get,number,of,managed,jobs,return,cache,entries,size
BlobLibraryCacheManager -> int getNumberOfManagedJobs();1507212387;Returns the number of registered jobs that this library cache manager handles.__@return number of jobs (irrespective of the actual number of tasks per job);int getNumberOfManagedJobs() {_		_		return cacheEntries.size()__	};returns,the,number,of,registered,jobs,that,this,library,cache,manager,handles,return,number,of,jobs,irrespective,of,the,actual,number,of,tasks,per,job;int,get,number,of,managed,jobs,return,cache,entries,size
BlobLibraryCacheManager -> int getNumberOfManagedJobs();1507212387;Returns the number of registered jobs that this library cache manager handles.__@return number of jobs (irrespective of the actual number of tasks per job);int getNumberOfManagedJobs() {_		_		return cacheEntries.size()__	};returns,the,number,of,registered,jobs,that,this,library,cache,manager,handles,return,number,of,jobs,irrespective,of,the,actual,number,of,tasks,per,job;int,get,number,of,managed,jobs,return,cache,entries,size
BlobLibraryCacheManager -> int getNumberOfManagedJobs();1508939746;Returns the number of registered jobs that this library cache manager handles.__@return number of jobs (irrespective of the actual number of tasks per job);int getNumberOfManagedJobs() {_		_		return cacheEntries.size()__	};returns,the,number,of,registered,jobs,that,this,library,cache,manager,handles,return,number,of,jobs,irrespective,of,the,actual,number,of,tasks,per,job;int,get,number,of,managed,jobs,return,cache,entries,size
BlobLibraryCacheManager -> int getNumberOfManagedJobs();1526549506;Returns the number of registered jobs that this library cache manager handles.__@return number of jobs (irrespective of the actual number of tasks per job);int getNumberOfManagedJobs() {_		_		return cacheEntries.size()__	};returns,the,number,of,registered,jobs,that,this,library,cache,manager,handles,return,number,of,jobs,irrespective,of,the,actual,number,of,tasks,per,job;int,get,number,of,managed,jobs,return,cache,entries,size
BlobLibraryCacheManager -> @Override 	public void unregister(final JobID id);1412605211;Unregisters a job ID and releases the resources associated with it.__@param id_the job ID to unregister;@Override_	public void unregister(final JobID id) {_		synchronized (lockObject) {_			if (decrementReferenceCounter(id, libraryReferenceCounter) == 0) {_				this.classLoaders.remove(id)___				Collection<BlobKey> keys = requiredJars.get(id)___				for (BlobKey key : keys) {_					decrementReferenceCounter(key, blobKeyReferenceCounter)__				}__				requiredJars.remove(id)__			}_		}__	};unregisters,a,job,id,and,releases,the,resources,associated,with,it,param,id,the,job,id,to,unregister;override,public,void,unregister,final,job,id,id,synchronized,lock,object,if,decrement,reference,counter,id,library,reference,counter,0,this,class,loaders,remove,id,collection,blob,key,keys,required,jars,get,id,for,blob,key,key,keys,decrement,reference,counter,key,blob,key,reference,counter,required,jars,remove,id
BlobLibraryCacheManager -> @Override 	public void unregister(final JobID id);1413208391;Unregisters a job ID and releases the resources associated with it.__@param id_the job ID to unregister;@Override_	public void unregister(final JobID id) {_		synchronized (lockObject) {_			if (decrementReferenceCounter(id, libraryReferenceCounter) == 0) {_				this.classLoaders.remove(id)___				Collection<BlobKey> keys = requiredJars.get(id)___				for (BlobKey key : keys) {_					decrementReferenceCounter(key, blobKeyReferenceCounter)__				}__				requiredJars.remove(id)__			}_		}__	};unregisters,a,job,id,and,releases,the,resources,associated,with,it,param,id,the,job,id,to,unregister;override,public,void,unregister,final,job,id,id,synchronized,lock,object,if,decrement,reference,counter,id,library,reference,counter,0,this,class,loaders,remove,id,collection,blob,key,keys,required,jars,get,id,for,blob,key,key,keys,decrement,reference,counter,key,blob,key,reference,counter,required,jars,remove,id
BlobLibraryCacheManager -> @Override 	public void unregister(final JobID id);1413211710;Unregisters a job ID and releases the resources associated with it.__@param id_the job ID to unregister;@Override_	public void unregister(final JobID id) {_		synchronized (lockObject) {_			if (decrementReferenceCounter(id, libraryReferenceCounter) == 0) {_				this.classLoaders.remove(id)___				Collection<BlobKey> keys = requiredJars.get(id)___				for (BlobKey key : keys) {_					decrementReferenceCounter(key, blobKeyReferenceCounter)__				}__				requiredJars.remove(id)__			}_		}__	};unregisters,a,job,id,and,releases,the,resources,associated,with,it,param,id,the,job,id,to,unregister;override,public,void,unregister,final,job,id,id,synchronized,lock,object,if,decrement,reference,counter,id,library,reference,counter,0,this,class,loaders,remove,id,collection,blob,key,keys,required,jars,get,id,for,blob,key,key,keys,decrement,reference,counter,key,blob,key,reference,counter,required,jars,remove,id
BlobLibraryCacheManager -> @Override 	public void register(final JobID id, final Collection<BlobKey> requiredJarFiles) throws 			IOException;1412605211;Registers a job ID with a set of library paths that are required to run the job. For every registered_job the library cache manager creates a class loader that is used to instantiate the vertex's environment later_on.__@param id_the ID of the job to be registered._@param requiredJarFiles_the client path's of the required libraries_@throws IOException_thrown if one of the requested libraries is not in the cache;@Override_	public void register(final JobID id, final Collection<BlobKey> requiredJarFiles) throws_			IOException {__		synchronized (lockObject) {_			if (incrementReferenceCounter(id, libraryReferenceCounter) > 1) {_				return__			}__			_			if (this.classLoaders.containsKey(id)) {_				throw new IllegalStateException("Library cache manager already contains " +_						"class loader entry for job ID " + id)__			}__			if (requiredJars.containsKey(id)) {_				throw new IllegalStateException("Library cache manager already contains blob keys" +_						" entry for job ID " + id)__			}__			requiredJars.put(id, requiredJarFiles)___			URL[] urls = new URL[requiredJarFiles.size()]__			int count = 0___			for (BlobKey blobKey : requiredJarFiles) {_				urls[count++] = registerBlobKeyAndGetURL(blobKey)__			}__			final URLClassLoader classLoader = new URLClassLoader(urls)__			this.classLoaders.put(id, classLoader)__		}_	};registers,a,job,id,with,a,set,of,library,paths,that,are,required,to,run,the,job,for,every,registered,job,the,library,cache,manager,creates,a,class,loader,that,is,used,to,instantiate,the,vertex,s,environment,later,on,param,id,the,id,of,the,job,to,be,registered,param,required,jar,files,the,client,path,s,of,the,required,libraries,throws,ioexception,thrown,if,one,of,the,requested,libraries,is,not,in,the,cache;override,public,void,register,final,job,id,id,final,collection,blob,key,required,jar,files,throws,ioexception,synchronized,lock,object,if,increment,reference,counter,id,library,reference,counter,1,return,if,this,class,loaders,contains,key,id,throw,new,illegal,state,exception,library,cache,manager,already,contains,class,loader,entry,for,job,id,id,if,required,jars,contains,key,id,throw,new,illegal,state,exception,library,cache,manager,already,contains,blob,keys,entry,for,job,id,id,required,jars,put,id,required,jar,files,url,urls,new,url,required,jar,files,size,int,count,0,for,blob,key,blob,key,required,jar,files,urls,count,register,blob,key,and,get,url,blob,key,final,urlclass,loader,class,loader,new,urlclass,loader,urls,this,class,loaders,put,id,class,loader
BlobLibraryCacheManager -> @Override 	public void register(final JobID id, final Collection<BlobKey> requiredJarFiles) throws 			IOException;1413208391;Registers a job ID with a set of library paths that are required to run the job. For every registered_job the library cache manager creates a class loader that is used to instantiate the vertex's environment later_on.__@param id_the ID of the job to be registered._@param requiredJarFiles_the client path's of the required libraries_@throws IOException_thrown if one of the requested libraries is not in the cache;@Override_	public void register(final JobID id, final Collection<BlobKey> requiredJarFiles) throws_			IOException {__		synchronized (lockObject) {_			if (incrementReferenceCounter(id, libraryReferenceCounter) > 1) {_				return__			}__			_			if (this.classLoaders.containsKey(id)) {_				throw new IllegalStateException("Library cache manager already contains " +_						"class loader entry for job ID " + id)__			}__			if (requiredJars.containsKey(id)) {_				throw new IllegalStateException("Library cache manager already contains blob keys" +_						" entry for job ID " + id)__			}__			requiredJars.put(id, requiredJarFiles)___			URL[] urls = new URL[requiredJarFiles.size()]__			int count = 0___			for (BlobKey blobKey : requiredJarFiles) {_				urls[count++] = registerBlobKeyAndGetURL(blobKey)__			}__			final URLClassLoader classLoader = new URLClassLoader(urls)__			this.classLoaders.put(id, classLoader)__		}_	};registers,a,job,id,with,a,set,of,library,paths,that,are,required,to,run,the,job,for,every,registered,job,the,library,cache,manager,creates,a,class,loader,that,is,used,to,instantiate,the,vertex,s,environment,later,on,param,id,the,id,of,the,job,to,be,registered,param,required,jar,files,the,client,path,s,of,the,required,libraries,throws,ioexception,thrown,if,one,of,the,requested,libraries,is,not,in,the,cache;override,public,void,register,final,job,id,id,final,collection,blob,key,required,jar,files,throws,ioexception,synchronized,lock,object,if,increment,reference,counter,id,library,reference,counter,1,return,if,this,class,loaders,contains,key,id,throw,new,illegal,state,exception,library,cache,manager,already,contains,class,loader,entry,for,job,id,id,if,required,jars,contains,key,id,throw,new,illegal,state,exception,library,cache,manager,already,contains,blob,keys,entry,for,job,id,id,required,jars,put,id,required,jar,files,url,urls,new,url,required,jar,files,size,int,count,0,for,blob,key,blob,key,required,jar,files,urls,count,register,blob,key,and,get,url,blob,key,final,urlclass,loader,class,loader,new,urlclass,loader,urls,this,class,loaders,put,id,class,loader
BlobLibraryCacheManager -> @Override 	public void register(final JobID id, final Collection<BlobKey> requiredJarFiles) throws 			IOException;1413211710;Registers a job ID with a set of library paths that are required to run the job. For every registered_job the library cache manager creates a class loader that is used to instantiate the vertex's environment later_on.__@param id_the ID of the job to be registered._@param requiredJarFiles_the client path's of the required libraries_@throws IOException_thrown if one of the requested libraries is not in the cache;@Override_	public void register(final JobID id, final Collection<BlobKey> requiredJarFiles) throws_			IOException {__		synchronized (lockObject) {_			if (incrementReferenceCounter(id, libraryReferenceCounter) > 1) {_				return__			}__			_			if (this.classLoaders.containsKey(id)) {_				throw new IllegalStateException("Library cache manager already contains " +_						"class loader entry for job ID " + id)__			}__			if (requiredJars.containsKey(id)) {_				throw new IllegalStateException("Library cache manager already contains blob keys" +_						" entry for job ID " + id)__			}__			requiredJars.put(id, requiredJarFiles)___			URL[] urls = new URL[requiredJarFiles.size()]__			int count = 0___			for (BlobKey blobKey : requiredJarFiles) {_				urls[count++] = registerBlobKeyAndGetURL(blobKey)__			}__			final URLClassLoader classLoader = new URLClassLoader(urls)__			this.classLoaders.put(id, classLoader)__		}_	};registers,a,job,id,with,a,set,of,library,paths,that,are,required,to,run,the,job,for,every,registered,job,the,library,cache,manager,creates,a,class,loader,that,is,used,to,instantiate,the,vertex,s,environment,later,on,param,id,the,id,of,the,job,to,be,registered,param,required,jar,files,the,client,path,s,of,the,required,libraries,throws,ioexception,thrown,if,one,of,the,requested,libraries,is,not,in,the,cache;override,public,void,register,final,job,id,id,final,collection,blob,key,required,jar,files,throws,ioexception,synchronized,lock,object,if,increment,reference,counter,id,library,reference,counter,1,return,if,this,class,loaders,contains,key,id,throw,new,illegal,state,exception,library,cache,manager,already,contains,class,loader,entry,for,job,id,id,if,required,jars,contains,key,id,throw,new,illegal,state,exception,library,cache,manager,already,contains,blob,keys,entry,for,job,id,id,required,jars,put,id,required,jar,files,url,urls,new,url,required,jar,files,size,int,count,0,for,blob,key,blob,key,required,jar,files,urls,count,register,blob,key,and,get,url,blob,key,final,urlclass,loader,class,loader,new,urlclass,loader,urls,this,class,loaders,put,id,class,loader
