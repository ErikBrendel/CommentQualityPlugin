commented;modifiers;parameterAmount;loc;comment;code
false;public;3;5;;@Override public void registerJob(JobID id, Collection<PermanentBlobKey> requiredJarFiles, Collection<URL> requiredClasspaths) throws IOException {     registerTask(id, JOB_ATTEMPT_ID, requiredJarFiles, requiredClasspaths). }
false;public;4;49;;@Override public void registerTask(JobID jobId, ExecutionAttemptID task, @Nullable Collection<PermanentBlobKey> requiredJarFiles, @Nullable Collection<URL> requiredClasspaths) throws IOException {     checkNotNull(jobId, "The JobId must not be null.").     checkNotNull(task, "The task execution id must not be null.").     if (requiredJarFiles == null) {         requiredJarFiles = Collections.emptySet().     }     if (requiredClasspaths == null) {         requiredClasspaths = Collections.emptySet().     }     synchronized (lockObject) {         LibraryCacheEntry entry = cacheEntries.get(jobId).         if (entry == null) {             URL[] urls = new URL[requiredJarFiles.size() + requiredClasspaths.size()].             int count = 0.             try {                 // add URLs to locally cached JAR files                 for (PermanentBlobKey key : requiredJarFiles) {                     urls[count] = blobService.getFile(jobId, key).toURI().toURL().                     ++count.                 }                 // add classpaths                 for (URL url : requiredClasspaths) {                     urls[count] = url.                     ++count.                 }                 cacheEntries.put(jobId, new LibraryCacheEntry(requiredJarFiles, requiredClasspaths, urls, task, classLoaderResolveOrder, alwaysParentFirstPatterns)).             } catch (Throwable t) {                 // rethrow or wrap                 ExceptionUtils.tryRethrowIOException(t).                 throw new IOException("Library cache could not register the user code libraries.", t).             }         } else {             entry.register(task, requiredJarFiles, requiredClasspaths).         }     } }
false;public;1;4;;@Override public void unregisterJob(JobID id) {     unregisterTask(id, JOB_ATTEMPT_ID). }
false;public;2;18;;@Override public void unregisterTask(JobID jobId, ExecutionAttemptID task) {     checkNotNull(jobId, "The JobId must not be null.").     checkNotNull(task, "The task execution id must not be null.").     synchronized (lockObject) {         LibraryCacheEntry entry = cacheEntries.get(jobId).         if (entry != null) {             if (entry.unregister(task)) {                 cacheEntries.remove(jobId).                 entry.releaseClassLoader().             }         }     // else has already been unregistered     } }
false;public;1;12;;@Override public ClassLoader getClassLoader(JobID jobId) {     checkNotNull(jobId, "The JobId must not be null.").     synchronized (lockObject) {         LibraryCacheEntry entry = cacheEntries.get(jobId).         if (entry == null) {             throw new IllegalStateException("No libraries are registered for job " + jobId).         }         return entry.getClassLoader().     } }
true;;1;6;/**  * Gets the number of tasks holding {@link ClassLoader} references for the given job.  *  * @param jobId ID of a job  *  * @return number of reference holders  */ ;/**  * Gets the number of tasks holding {@link ClassLoader} references for the given job.  *  * @param jobId ID of a job  *  * @return number of reference holders  */ int getNumberOfReferenceHolders(JobID jobId) {     synchronized (lockObject) {         LibraryCacheEntry entry = cacheEntries.get(jobId).         return entry == null ? 0 : entry.getNumberOfReferenceHolders().     } }
true;;0;4;/**  * Returns the number of registered jobs that this library cache manager handles.  *  * @return number of jobs (irrespective of the actual number of tasks per job)  */ ;/**  * Returns the number of registered jobs that this library cache manager handles.  *  * @return number of jobs (irrespective of the actual number of tasks per job)  */ int getNumberOfManagedJobs() {     // no synchronisation necessary     return cacheEntries.size(). }
false;public;0;8;;@Override public void shutdown() {     synchronized (lockObject) {         for (LibraryCacheEntry entry : cacheEntries.values()) {             entry.releaseClassLoader().         }     } }
false;public;1;6;;@Override public boolean hasClassLoader(@Nonnull JobID jobId) {     synchronized (lockObject) {         return cacheEntries.containsKey(jobId).     } }
false;public;0;3;;public ClassLoader getClassLoader() {     return classLoader. }
false;public;0;3;;public Set<PermanentBlobKey> getLibraries() {     return libraries. }
false;public;3;32;;public void register(ExecutionAttemptID task, Collection<PermanentBlobKey> requiredLibraries, Collection<URL> requiredClasspaths) {     // lazy construction of a new set for faster comparisons     if (libraries.size() != requiredLibraries.size() || !new HashSet<>(requiredLibraries).containsAll(libraries)) {         throw new IllegalStateException("The library registration references a different set of library BLOBs than" + " previous registrations for this job:\nold:" + libraries.toString() + "\nnew:" + requiredLibraries.toString()).     }     // lazy construction of a new set with String representations of the URLs     if (classPaths.size() != requiredClasspaths.size() || !requiredClasspaths.stream().map(URL::toString).collect(Collectors.toSet()).containsAll(classPaths)) {         throw new IllegalStateException("The library registration references a different set of library BLOBs than" + " previous registrations for this job:\nold:" + classPaths.toString() + "\nnew:" + requiredClasspaths.toString()).     }     this.referenceHolders.add(task). }
false;public;1;4;;public boolean unregister(ExecutionAttemptID task) {     referenceHolders.remove(task).     return referenceHolders.isEmpty(). }
false;;0;3;;int getNumberOfReferenceHolders() {     return referenceHolders.size(). }
true;;0;7;/**  * Release the class loader to ensure any file descriptors are closed  * and the cached libraries are deleted immediately.  */ ;/**  * Release the class loader to ensure any file descriptors are closed  * and the cached libraries are deleted immediately.  */ void releaseClassLoader() {     try {         classLoader.close().     } catch (IOException e) {         LOG.warn("Failed to release user code class loader for " + Arrays.toString(libraries.toArray())).     } }
