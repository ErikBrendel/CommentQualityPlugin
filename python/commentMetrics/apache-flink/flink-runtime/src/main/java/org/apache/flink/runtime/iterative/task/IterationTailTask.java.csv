commented;modifiers;parameterAmount;loc;comment;code
false;public;1;2;;@Override public void collect(OT record) { }
false;public;0;2;;@Override public void close() { }
false;protected;0;46;;// -------------------------------------------------------------------------------------------- @Override protected void initialize() throws Exception {     super.initialize().     // sanity check: the tail has to update either the workset or the solution set     if (!isWorksetUpdate && !isSolutionSetUpdate) {         throw new RuntimeException("The iteration tail doesn't update workset or the solution set.").     }     // set the last output collector of this task to reflect the iteration tail state update:     // a) workset update,     // b) solution set update, or     // c) merged workset and solution set update     Collector<OT> outputCollector = null.     if (isWorksetUpdate) {         outputCollector = createWorksetUpdateOutputCollector().         // we need the WorksetUpdateOutputCollector separately to count the collected elements         if (isWorksetIteration) {             worksetUpdateOutputCollector = (WorksetUpdateOutputCollector<OT>) outputCollector.         }     }     if (isSolutionSetUpdate) {         if (isWorksetIteration) {             outputCollector = createSolutionSetUpdateOutputCollector(outputCollector).         } else // Bulk iteration with termination criterion         {             outputCollector = new Collector<OT>() {                  @Override                 public void collect(OT record) {                 }                  @Override                 public void close() {                 }             }.         }         if (!isWorksetUpdate) {             solutionSetUpdateBarrier = SolutionSetUpdateBarrierBroker.instance().get(brokerKey()).         }     }     setLastOutputCollector(outputCollector). }
false;public;0;44;;@Override public void run() throws Exception {     SuperstepKickoffLatch nextSuperStepLatch = SuperstepKickoffLatchBroker.instance().get(brokerKey()).     while (this.running && !terminationRequested()) {         if (log.isInfoEnabled()) {             log.info(formatLogString("starting iteration [" + currentIteration() + "]")).         }         super.run().         // check if termination was requested         verifyEndOfSuperstepState().         if (isWorksetUpdate && isWorksetIteration) {             // aggregate workset update element count             long numCollected = worksetUpdateOutputCollector.getElementsCollectedAndReset().             worksetAggregator.aggregate(numCollected).         }         if (log.isInfoEnabled()) {             log.info(formatLogString("finishing iteration [" + currentIteration() + "]")).         }         if (isWorksetUpdate) {             // notify iteration head if responsible for workset update             worksetBackChannel.notifyOfEndOfSuperstep().         } else if (isSolutionSetUpdate) {             // notify iteration head if responsible for solution set update             solutionSetUpdateBarrier.notifySolutionSetUpdate().         }         boolean terminate = nextSuperStepLatch.awaitStartOfSuperstepOrTermination(currentIteration() + 1).         if (terminate) {             requestTermination().         } else {             incrementIterationCounter().         }     } }
