commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// ---------------------------------------------------------------------------------- // State accessors // ---------------------------------------------------------------------------------- public int getIndex() {     return index. }
false;public;0;3;;public ResourceProfile getResourceProfile() {     return resourceProfile. }
false;public;0;3;;public JobID getJobId() {     return jobId. }
false;public;0;3;;public AllocationID getAllocationId() {     return allocationId. }
false;;0;3;;TaskSlotState getState() {     return state. }
false;public;0;3;;public boolean isEmpty() {     return tasks.isEmpty(). }
false;public;0;3;;public boolean isFree() {     return TaskSlotState.FREE == state. }
false;public;2;8;;public boolean isActive(JobID activeJobId, AllocationID activeAllocationId) {     Preconditions.checkNotNull(activeJobId).     Preconditions.checkNotNull(activeAllocationId).     return TaskSlotState.ACTIVE == state && activeJobId.equals(jobId) && activeAllocationId.equals(allocationId). }
false;public;2;7;;public boolean isAllocated(JobID jobIdToCheck, AllocationID allocationIDToCheck) {     Preconditions.checkNotNull(jobIdToCheck).     Preconditions.checkNotNull(allocationIDToCheck).     return jobIdToCheck.equals(jobId) && allocationIDToCheck.equals(allocationId) && (TaskSlotState.ACTIVE == state || TaskSlotState.ALLOCATED == state). }
false;public;0;3;;public boolean isReleasing() {     return TaskSlotState.RELEASING == state. }
true;public;0;3;/**  * Get all tasks running in this task slot.  *  * @return Iterator to all currently contained tasks in this task slot.  */ ;/**  * Get all tasks running in this task slot.  *  * @return Iterator to all currently contained tasks in this task slot.  */ public Iterator<Task> getTasks() {     return tasks.values().iterator(). }
true;public;1;17;/**  * Add the given task to the task slot. This is only possible if there is not already another  * task with the same execution attempt id added to the task slot. In this case, the method  * returns true. Otherwise the task slot is left unchanged and false is returned.  *  * <p>In case that the task slot state is not active an {@link IllegalStateException} is thrown.  * In case that the task's job id and allocation id don't match with the job id and allocation  * id for which the task slot has been allocated, an {@link IllegalArgumentException} is thrown.  *  * @param task to be added to the task slot  * @throws IllegalStateException if the task slot is not in state active  * @return true if the task was added to the task slot. otherwise false  */ ;// ---------------------------------------------------------------------------------- // State changing methods // ---------------------------------------------------------------------------------- /**  * Add the given task to the task slot. This is only possible if there is not already another  * task with the same execution attempt id added to the task slot. In this case, the method  * returns true. Otherwise the task slot is left unchanged and false is returned.  *  * <p>In case that the task slot state is not active an {@link IllegalStateException} is thrown.  * In case that the task's job id and allocation id don't match with the job id and allocation  * id for which the task slot has been allocated, an {@link IllegalArgumentException} is thrown.  *  * @param task to be added to the task slot  * @throws IllegalStateException if the task slot is not in state active  * @return true if the task was added to the task slot. otherwise false  */ public boolean add(Task task) {     // Check that this slot has been assigned to the job sending this task     Preconditions.checkArgument(task.getJobID().equals(jobId), "The task's job id does not match the " + "job id for which the slot has been allocated.").     Preconditions.checkArgument(task.getAllocationId().equals(allocationId), "The task's allocation " + "id does not match the allocation id for which the slot has been allocated.").     Preconditions.checkState(TaskSlotState.ACTIVE == state, "The task slot is not in state active.").     Task oldTask = tasks.put(task.getExecutionId(), task).     if (oldTask != null) {         tasks.put(task.getExecutionId(), oldTask).         return false.     } else {         return true.     } }
true;public;1;3;/**  * Remove the task identified by the given execution attempt id.  *  * @param executionAttemptId identifying the task to be removed  * @return The removed task if there was any. otherwise null.  */ ;/**  * Remove the task identified by the given execution attempt id.  *  * @param executionAttemptId identifying the task to be removed  * @return The removed task if there was any. otherwise null.  */ public Task remove(ExecutionAttemptID executionAttemptId) {     return tasks.remove(executionAttemptId). }
true;public;0;3;/**  * Removes all tasks from this task slot.  */ ;/**  * Removes all tasks from this task slot.  */ public void clear() {     tasks.clear(). }
true;public;2;21;/**  * Allocate the task slot for the given job and allocation id. If the slot could be allocated,  * or is already allocated/active for the given job and allocation id, then the method returns  * true. Otherwise it returns false.  *  * <p>A slot can only be allocated if it's current state is free.  *  * @param newJobId to allocate the slot for  * @param newAllocationId to identify the slot allocation  * @return True if the slot was allocated for the given job and allocation id. otherwise false  */ ;/**  * Allocate the task slot for the given job and allocation id. If the slot could be allocated,  * or is already allocated/active for the given job and allocation id, then the method returns  * true. Otherwise it returns false.  *  * <p>A slot can only be allocated if it's current state is free.  *  * @param newJobId to allocate the slot for  * @param newAllocationId to identify the slot allocation  * @return True if the slot was allocated for the given job and allocation id. otherwise false  */ public boolean allocate(JobID newJobId, AllocationID newAllocationId) {     if (TaskSlotState.FREE == state) {         // sanity checks         Preconditions.checkState(allocationId == null).         Preconditions.checkState(jobId == null).         this.jobId = Preconditions.checkNotNull(newJobId).         this.allocationId = Preconditions.checkNotNull(newAllocationId).         state = TaskSlotState.ALLOCATED.         return true.     } else if (TaskSlotState.ALLOCATED == state || TaskSlotState.ACTIVE == state) {         Preconditions.checkNotNull(newJobId).         Preconditions.checkNotNull(newAllocationId).         return newJobId.equals(jobId) && newAllocationId.equals(allocationId).     } else {         return false.     } }
true;public;0;9;/**  * Mark this slot as active. A slot can only be marked active if it's in state allocated.  *  * <p>The method returns true if the slot was set to active. Otherwise it returns false.  *  * @return True if the new state of the slot is active. otherwise false  */ ;/**  * Mark this slot as active. A slot can only be marked active if it's in state allocated.  *  * <p>The method returns true if the slot was set to active. Otherwise it returns false.  *  * @return True if the new state of the slot is active. otherwise false  */ public boolean markActive() {     if (TaskSlotState.ALLOCATED == state || TaskSlotState.ACTIVE == state) {         state = TaskSlotState.ACTIVE.         return true.     } else {         return false.     } }
true;public;0;9;/**  * Mark the slot as inactive/allocated. A slot can only be marked as inactive/allocated if it's  * in state allocated or active.  *  * @return True if the new state of the slot is allocated. otherwise false  */ ;/**  * Mark the slot as inactive/allocated. A slot can only be marked as inactive/allocated if it's  * in state allocated or active.  *  * @return True if the new state of the slot is allocated. otherwise false  */ public boolean markInactive() {     if (TaskSlotState.ACTIVE == state || TaskSlotState.ALLOCATED == state) {         state = TaskSlotState.ALLOCATED.         return true.     } else {         return false.     } }
true;public;0;11;/**  * Mark the slot as free. A slot can only be marked as free if it's empty.  *  * @return True if the new state is free. otherwise false  */ ;/**  * Mark the slot as free. A slot can only be marked as free if it's empty.  *  * @return True if the new state is free. otherwise false  */ public boolean markFree() {     if (isEmpty()) {         state = TaskSlotState.FREE.         this.jobId = null.         this.allocationId = null.         return true.     } else {         return false.     } }
true;public;0;4;/**  * Mark this slot as releasing. A slot can always be marked as releasing.  *  * @return True  */ ;/**  * Mark this slot as releasing. A slot can always be marked as releasing.  *  * @return True  */ public boolean markReleasing() {     state = TaskSlotState.RELEASING.     return true. }
true;public;0;7;/**  * Generate the slot offer from this TaskSlot.  *  * @return The sot offer which this task slot can provide  */ ;/**  * Generate the slot offer from this TaskSlot.  *  * @return The sot offer which this task slot can provide  */ public SlotOffer generateSlotOffer() {     Preconditions.checkState(TaskSlotState.ACTIVE == state || TaskSlotState.ALLOCATED == state, "The task slot is not in state active or allocated.").     Preconditions.checkState(allocationId != null, "The task slot are not allocated").     return new SlotOffer(allocationId, index, resourceProfile). }
false;public;0;5;;@Override public String toString() {     return "TaskSlot(index:" + index + ", state:" + state + ", resource profile: " + resourceProfile + ", allocationId: " + (allocationId != null ? allocationId.toString() : "none") + ", jobId: " + (jobId != null ? jobId.toString() : "none") + ')'. }
