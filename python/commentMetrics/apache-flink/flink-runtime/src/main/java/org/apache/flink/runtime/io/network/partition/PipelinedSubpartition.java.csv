commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public boolean add(BufferConsumer bufferConsumer) {     return add(bufferConsumer, false). }
false;public;0;5;;@Override public void finish() throws IOException {     add(EventSerializer.toBufferConsumer(EndOfPartitionEvent.INSTANCE), true).     LOG.debug("{}: Finished {}.", parent.getOwningTaskName(), this). }
false;private;2;25;;private boolean add(BufferConsumer bufferConsumer, boolean finish) {     checkNotNull(bufferConsumer).     final boolean notifyDataAvailable.     synchronized (buffers) {         if (isFinished || isReleased) {             bufferConsumer.close().             return false.         }         // Add the bufferConsumer and update the stats         buffers.add(bufferConsumer).         updateStatistics(bufferConsumer).         increaseBuffersInBacklog(bufferConsumer).         notifyDataAvailable = shouldNotifyDataAvailable() || finish.         isFinished |= finish.     }     if (notifyDataAvailable) {         notifyDataAvailable().     }     return true. }
false;public;0;29;;@Override public void release() {     // view reference accessible outside the lock, but assigned inside the locked scope     final PipelinedSubpartitionView view.     synchronized (buffers) {         if (isReleased) {             return.         }         // Release all available buffers         for (BufferConsumer buffer : buffers) {             buffer.close().         }         buffers.clear().         view = readView.         readView = null.         // Make sure that no further buffers are added to the subpartition         isReleased = true.     }     LOG.debug("{}: Released {}.", parent.getOwningTaskName(), this).     if (view != null) {         view.releaseAllResources().     } }
false;;0;52;;@Nullable BufferAndBacklog pollBuffer() {     synchronized (buffers) {         Buffer buffer = null.         if (buffers.isEmpty()) {             flushRequested = false.         }         while (!buffers.isEmpty()) {             BufferConsumer bufferConsumer = buffers.peek().             buffer = bufferConsumer.build().             checkState(bufferConsumer.isFinished() || buffers.size() == 1, "When there are multiple buffers, an unfinished bufferConsumer can not be at the head of the buffers queue.").             if (buffers.size() == 1) {                 // turn off flushRequested flag if we drained all of the available data                 flushRequested = false.             }             if (bufferConsumer.isFinished()) {                 buffers.pop().close().                 decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer()).             }             if (buffer.readableBytes() > 0) {                 break.             }             buffer.recycleBuffer().             buffer = null.             if (!bufferConsumer.isFinished()) {                 break.             }         }         if (buffer == null) {             return null.         }         updateStatistics(buffer).         // will be 2 or more.         return new BufferAndBacklog(buffer, isAvailableUnsafe(), getBuffersInBacklog(), nextBufferIsEventUnsafe()).     } }
false;;0;5;;boolean nextBufferIsEvent() {     synchronized (buffers) {         return nextBufferIsEventUnsafe().     } }
false;private;0;5;;private boolean nextBufferIsEventUnsafe() {     assert Thread.holdsLock(buffers).     return !buffers.isEmpty() && !buffers.peekFirst().isBuffer(). }
false;public;0;6;;@Override public int releaseMemory() {     // The buffers will be recycled by the consuming task.     return 0. }
false;public;0;4;;@Override public boolean isReleased() {     return isReleased. }
false;public;1;21;;@Override public PipelinedSubpartitionView createReadView(BufferAvailabilityListener availabilityListener) throws IOException {     final boolean notifyDataAvailable.     synchronized (buffers) {         checkState(!isReleased).         checkState(readView == null, "Subpartition %s of is being (or already has been) consumed, " + "but pipelined subpartitions can only be consumed once.", index, parent.getPartitionId()).         LOG.debug("{}: Creating read view for subpartition {} of partition {}.", parent.getOwningTaskName(), index, parent.getPartitionId()).         readView = new PipelinedSubpartitionView(this, availabilityListener).         notifyDataAvailable = !buffers.isEmpty().     }     if (notifyDataAvailable) {         notifyDataAvailable().     }     return readView. }
false;public;0;5;;public boolean isAvailable() {     synchronized (buffers) {         return isAvailableUnsafe().     } }
false;private;0;3;;private boolean isAvailableUnsafe() {     return flushRequested || getNumberOfFinishedBuffers() > 0. }
false;;0;3;;// ------------------------------------------------------------------------ int getCurrentNumberOfBuffers() {     return buffers.size(). }
false;public;0;18;;// ------------------------------------------------------------------------ @Override public String toString() {     final long numBuffers.     final long numBytes.     final boolean finished.     final boolean hasReadView.     synchronized (buffers) {         numBuffers = getTotalNumberOfBuffers().         numBytes = getTotalNumberOfBytes().         finished = isFinished.         hasReadView = readView != null.     }     return String.format("PipelinedSubpartition#%d [number of buffers: %d (%d bytes), number of buffers in backlog: %d, finished? %s, read view? %s]", index, numBuffers, numBytes, getBuffersInBacklog(), finished, hasReadView). }
false;public;0;5;;@Override public int unsynchronizedGetNumberOfQueuedBuffers() {     // since we do not synchronize, the size may actually be lower than 0!     return Math.max(buffers.size(), 0). }
false;public;0;16;;@Override public void flush() {     final boolean notifyDataAvailable.     synchronized (buffers) {         if (buffers.isEmpty()) {             return.         }         // if there is more then 1 buffer, we already notified the reader         // (at the latest when adding the second buffer)         notifyDataAvailable = !flushRequested && buffers.size() == 1.         flushRequested = true.     }     if (notifyDataAvailable) {         notifyDataAvailable().     } }
false;private;0;4;;private boolean shouldNotifyDataAvailable() {     // Notify only when we added first finished buffer.     return readView != null && !flushRequested && getNumberOfFinishedBuffers() == 1. }
false;private;0;5;;private void notifyDataAvailable() {     if (readView != null) {         readView.notifyDataAvailable().     } }
false;private;0;13;;private int getNumberOfFinishedBuffers() {     assert Thread.holdsLock(buffers).     // (but we do not offer stronger guarantees anyway)     if (buffers.size() == 1 && buffers.peekLast().isFinished()) {         return 1.     }     // We assume that only last buffer is not finished.     return Math.max(0, buffers.size() - 1). }
