commented;modifiers;parameterAmount;loc;comment;code
false;public,final;1;4;;// ------------------------------------------------------------------------ // I/O // ------------------------------------------------------------------------ @Override public final void write(int b) throws IOException {     out.write(b). }
false;public,final;3;4;;@Override public final void write(@Nonnull byte[] b, int off, int len) throws IOException {     out.write(b, off, len). }
false;public;0;4;;@Override public long getPos() throws IOException {     return out.getPos(). }
false;public;0;4;;@Override public void flush() throws IOException {     out.flush(). }
false;public;0;4;;@Override public void sync() throws IOException {     out.sync(). }
false;public;0;3;;// ------------------------------------------------------------------------ // Closing // ------------------------------------------------------------------------ public boolean isClosed() {     return closed. }
false;public;0;14;;@Override public void close() {     if (!closed) {         closed = true.         try {             out.close().             fileSystem.delete(path, false).         } catch (Throwable t) {             LOG.warn("Could not close the state stream for {}.", path, t).         }     } }
false;public;0;38;;@Nullable @Override public FileStateHandle closeAndGetHandle() throws IOException {     synchronized (this) {         if (!closed) {             try {                 // make a best effort attempt to figure out the size                 long size = 0.                 try {                     size = out.getPos().                 } catch (Exception ignored) {                 }                 // close and return                 out.close().                 return new FileStateHandle(path, size).             } catch (Exception e) {                 try {                     fileSystem.delete(path, false).                 } catch (Exception deleteException) {                     LOG.warn("Could not delete the checkpoint stream file {}.", path, deleteException).                 }                 throw new IOException("Could not flush and close the file system " + "output stream to " + path + " in order to obtain the " + "stream state handle", e).             } finally {                 closed = true.             }         } else {             throw new IOException("Stream has already been closed and discarded.").         }     } }
