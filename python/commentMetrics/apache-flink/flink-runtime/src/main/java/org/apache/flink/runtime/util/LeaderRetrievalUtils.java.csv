commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;23;/**  * Retrieves the current leader gateway using the given {@link LeaderRetrievalService}. If the  * current leader could not be retrieved after the given timeout, then a  * {@link LeaderRetrievalException} is thrown.  *  * @param leaderRetrievalService {@link LeaderRetrievalService} which is used for the leader retrieval  * @param actorSystem ActorSystem which is used for the {@link LeaderRetrievalListener} implementation  * @param timeout Timeout value for the retrieval call  * @return The current leader gateway  * @throws LeaderRetrievalException If the actor gateway could not be retrieved or the timeout has been exceeded  */ ;/**  * Retrieves the current leader gateway using the given {@link LeaderRetrievalService}. If the  * current leader could not be retrieved after the given timeout, then a  * {@link LeaderRetrievalException} is thrown.  *  * @param leaderRetrievalService {@link LeaderRetrievalService} which is used for the leader retrieval  * @param actorSystem ActorSystem which is used for the {@link LeaderRetrievalListener} implementation  * @param timeout Timeout value for the retrieval call  * @return The current leader gateway  * @throws LeaderRetrievalException If the actor gateway could not be retrieved or the timeout has been exceeded  */ public static ActorGateway retrieveLeaderGateway(LeaderRetrievalService leaderRetrievalService, ActorSystem actorSystem, FiniteDuration timeout) throws LeaderRetrievalException {     LeaderGatewayListener listener = new LeaderGatewayListener(actorSystem, timeout).     try {         leaderRetrievalService.start(listener).         Future<ActorGateway> actorGatewayFuture = listener.getActorGatewayFuture().         return Await.result(actorGatewayFuture, timeout).     } catch (Exception e) {         throw new LeaderRetrievalException("Could not retrieve the leader gateway.", e).     } finally {         try {             leaderRetrievalService.stop().         } catch (Exception fe) {             LOG.warn("Could not stop the leader retrieval service.", fe).         }     } }
true;public,static;2;5;/**  * Retrieves the leader akka url and the current leader session ID. The values are stored in a  * {@link LeaderConnectionInfo} instance.  *  * @param leaderRetrievalService Leader retrieval service to retrieve the leader connection  *                               information  * @param timeout Timeout when to give up looking for the leader  * @return LeaderConnectionInfo containing the leader's akka URL and the current leader session  * ID  * @throws LeaderRetrievalException  */ ;/**  * Retrieves the leader akka url and the current leader session ID. The values are stored in a  * {@link LeaderConnectionInfo} instance.  *  * @param leaderRetrievalService Leader retrieval service to retrieve the leader connection  *                               information  * @param timeout Timeout when to give up looking for the leader  * @return LeaderConnectionInfo containing the leader's akka URL and the current leader session  * ID  * @throws LeaderRetrievalException  */ public static LeaderConnectionInfo retrieveLeaderConnectionInfo(LeaderRetrievalService leaderRetrievalService, Time timeout) throws LeaderRetrievalException {     return retrieveLeaderConnectionInfo(leaderRetrievalService, FutureUtils.toFiniteDuration(timeout)). }
true;public,static;2;23;/**  * Retrieves the leader akka url and the current leader session ID. The values are stored in a  * {@link LeaderConnectionInfo} instance.  *  * @param leaderRetrievalService Leader retrieval service to retrieve the leader connection  *                               information  * @param timeout Timeout when to give up looking for the leader  * @return LeaderConnectionInfo containing the leader's akka URL and the current leader session  * ID  * @throws LeaderRetrievalException  */ ;/**  * Retrieves the leader akka url and the current leader session ID. The values are stored in a  * {@link LeaderConnectionInfo} instance.  *  * @param leaderRetrievalService Leader retrieval service to retrieve the leader connection  *                               information  * @param timeout Timeout when to give up looking for the leader  * @return LeaderConnectionInfo containing the leader's akka URL and the current leader session  * ID  * @throws LeaderRetrievalException  */ public static LeaderConnectionInfo retrieveLeaderConnectionInfo(LeaderRetrievalService leaderRetrievalService, FiniteDuration timeout) throws LeaderRetrievalException {     LeaderConnectionInfoListener listener = new LeaderConnectionInfoListener().     try {         leaderRetrievalService.start(listener).         Future<LeaderConnectionInfo> connectionInfoFuture = listener.getLeaderConnectionInfoFuture().         return Await.result(connectionInfoFuture, timeout).     } catch (Exception e) {         throw new LeaderRetrievalException("Could not retrieve the leader address and leader " + "session ID.", e).     } finally {         try {             leaderRetrievalService.stop().         } catch (Exception fe) {             LOG.warn("Could not stop the leader retrieval service.", fe).         }     } }
true;public,static;2;5;/**  * Retrieves the current leader session id of the component identified by the given leader  * retrieval service.  *  * @param leaderRetrievalService Leader retrieval service to be used for the leader retrieval  * @param timeout Timeout for the leader retrieval  * @return The leader session id of the retrieved leader  * @throws LeaderRetrievalException if the leader retrieval operation fails (including a timeout)  */ ;/**  * Retrieves the current leader session id of the component identified by the given leader  * retrieval service.  *  * @param leaderRetrievalService Leader retrieval service to be used for the leader retrieval  * @param timeout Timeout for the leader retrieval  * @return The leader session id of the retrieved leader  * @throws LeaderRetrievalException if the leader retrieval operation fails (including a timeout)  */ public static UUID retrieveLeaderSessionId(LeaderRetrievalService leaderRetrievalService, FiniteDuration timeout) throws LeaderRetrievalException {     return retrieveLeaderConnectionInfo(leaderRetrievalService, timeout).getLeaderSessionID(). }
false;public,static;2;5;;public static InetAddress findConnectingAddress(LeaderRetrievalService leaderRetrievalService, Time timeout) throws LeaderRetrievalException {     return findConnectingAddress(leaderRetrievalService, new FiniteDuration(timeout.getSize(), timeout.getUnit())). }
false;public,static;2;26;;public static InetAddress findConnectingAddress(LeaderRetrievalService leaderRetrievalService, FiniteDuration timeout) throws LeaderRetrievalException {     ConnectionUtils.LeaderConnectingAddressListener listener = new ConnectionUtils.LeaderConnectingAddressListener().     try {         leaderRetrievalService.start(listener).         LOG.info("Trying to select the network interface and address to use " + "by connecting to the leading JobManager.").         LOG.info("TaskManager will try to connect for " + timeout + " before falling back to heuristics").         return listener.findConnectingAddress(timeout).     } catch (Exception e) {         throw new LeaderRetrievalException("Could not find the connecting address by " + "connecting to the current leader.", e).     } finally {         try {             leaderRetrievalService.stop().         } catch (Exception fe) {             LOG.warn("Could not stop the leader retrieval service.", fe).         }     } }
false;private;1;7;;private void completePromise(ActorGateway gateway) {     synchronized (lock) {         if (!futureActorGateway.isCompleted()) {             futureActorGateway.success(gateway).         }     } }
false;public;2;8;;@Override public void onComplete(Throwable failure, ActorGateway success) throws Throwable {     if (failure == null) {         completePromise(success).     } else {         LOG.debug("Could not retrieve the leader for address " + leaderAddress + ".", failure).     } }
false;public;1;3;;public ActorGateway apply(ActorRef ref) {     return new AkkaActorGateway(ref, leaderSessionID). }
false;public;2;21;;@Override public void notifyLeaderAddress(final String leaderAddress, final UUID leaderSessionID) {     if (leaderAddress != null && !leaderAddress.equals("") && !futureActorGateway.isCompleted()) {         AkkaUtils.getActorRefFuture(leaderAddress, actorSystem, timeout).map(new Mapper<ActorRef, ActorGateway>() {              public ActorGateway apply(ActorRef ref) {                 return new AkkaActorGateway(ref, leaderSessionID).             }         }, actorSystem.dispatcher()).onComplete(new OnComplete<ActorGateway>() {              @Override             public void onComplete(Throwable failure, ActorGateway success) throws Throwable {                 if (failure == null) {                     completePromise(success).                 } else {                     LOG.debug("Could not retrieve the leader for address " + leaderAddress + ".", failure).                 }             }         }, actorSystem.dispatcher()).     } }
false;public;1;6;;@Override public void handleError(Exception exception) {     if (!futureActorGateway.isCompleted()) {         futureActorGateway.failure(exception).     } }
false;public;0;3;;public Future<ActorGateway> getActorGatewayFuture() {     return futureActorGateway.future(). }
false;public;0;3;;public Future<LeaderConnectionInfo> getLeaderConnectionInfoFuture() {     return connectionInfo.future(). }
false;public;2;12;;@Override public void notifyLeaderAddress(String leaderAddress, UUID leaderSessionID) {     if (leaderAddress != null && !leaderAddress.equals("") && !connectionInfo.isCompleted()) {         try {             final LeaderConnectionInfo leaderConnectionInfo = new LeaderConnectionInfo(leaderAddress, leaderSessionID).             connectionInfo.success(leaderConnectionInfo).         } catch (FlinkException e) {             connectionInfo.failure(e).         }     } }
false;public;1;6;;@Override public void handleError(Exception exception) {     if (!connectionInfo.isCompleted()) {         connectionInfo.failure(exception).     } }
true;public,static;1;3;/**  * Gets the recovery mode as configured, based on {@link HighAvailabilityOptions#HA_MODE}.  *  * @param config The configuration to read the recovery mode from.  * @return The recovery mode.  *  * @throws IllegalConfigurationException Thrown, if the recovery mode does not correspond  *                                       to a known value.  */ ;/**  * Gets the recovery mode as configured, based on {@link HighAvailabilityOptions#HA_MODE}.  *  * @param config The configuration to read the recovery mode from.  * @return The recovery mode.  *  * @throws IllegalConfigurationException Thrown, if the recovery mode does not correspond  *                                       to a known value.  */ public static HighAvailabilityMode getRecoveryMode(Configuration config) {     return HighAvailabilityMode.fromConfig(config). }
