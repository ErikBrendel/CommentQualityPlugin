commented;modifiers;parameterAmount;loc;comment;code
false;;0;44;;int releaseMemory() throws IOException {     synchronized (buffers) {         if (spilledView != null || nextBuffer == null) {             // Already spilled or nothing in-memory             return 0.         } else {             // We don't touch next buffer, because a notification has             // already been sent for it. Only when it is consumed, will             // it be recycled.             // Create the spill writer and write all buffers to disk             BufferFileWriter spillWriter = ioManager.createBufferFileWriter(ioManager.createChannel()).             long spilledBytes = 0.             int numBuffers = buffers.size().             for (int i = 0. i < numBuffers. i++) {                 try (BufferConsumer bufferConsumer = buffers.remove()) {                     Buffer buffer = bufferConsumer.build().                     checkState(bufferConsumer.isFinished(), "BufferConsumer must be finished before " + "spilling. Otherwise we would not be able to simply remove it from the queue. This should " + "be guaranteed by creating ResultSubpartitionView only once Subpartition isFinished.").                     parent.updateStatistics(buffer).                     spilledBytes += buffer.getSize().                     spillWriter.writeBlock(buffer).                 }             }             spilledView = new SpilledSubpartitionView(parent, memorySegmentSize, spillWriter, numBuffers, listener).             LOG.debug("Spilling {} bytes for sub partition {} of {}.", spilledBytes, parent.index, parent.parent.getPartitionId()).             return numBuffers.         }     } }
false;public;0;45;;@Nullable @Override public BufferAndBacklog getNextBuffer() throws IOException, InterruptedException {     Buffer current = null.     boolean nextBufferIsEvent = false.     // this is always correct if current is non-null!     int newBacklog = 0.     boolean isMoreAvailable = false.     synchronized (buffers) {         if (isReleased.get()) {             return null.         } else if (nextBuffer != null) {             current = nextBuffer.build().             checkState(nextBuffer.isFinished(), "We can only read from SpillableSubpartition after it was finished").             newBacklog = parent.decreaseBuffersInBacklogUnsafe(nextBuffer.isBuffer()).             nextBuffer.close().             nextBuffer = buffers.poll().             if (nextBuffer != null) {                 nextBufferIsEvent = !nextBuffer.isBuffer().                 isMoreAvailable = true.             }             parent.updateStatistics(current).             // state of nextBufferIsEvent or whether more buffers are available             if (spilledView == null) {                 return new BufferAndBacklog(current, isMoreAvailable, newBacklog, nextBufferIsEvent).             }         }     }     // else: spilled     SpilledSubpartitionView spilled = spilledView.     if (spilled != null) {         if (current != null) {             return new BufferAndBacklog(current, spilled.isAvailable(), newBacklog, spilled.nextBufferIsEvent()).         } else {             return spilled.getNextBuffer().         }     } else {         throw new IllegalStateException("No in-memory buffers available, but also nothing spilled.").     } }
false;public;0;4;;@Override public void notifyDataAvailable() { // We do the availability listener notification one by one }
false;public;0;16;;@Override public void releaseAllResources() throws IOException {     if (isReleased.compareAndSet(false, true)) {         SpilledSubpartitionView spilled = spilledView.         if (spilled != null) {             spilled.releaseAllResources().         }         // we are never giving this buffer out in getNextBuffer(), so we need to clean it up         synchronized (buffers) {             if (nextBuffer != null) {                 nextBuffer.close().                 nextBuffer = null.             }         }     } }
false;public;0;9;;@Override public void notifySubpartitionConsumed() throws IOException {     SpilledSubpartitionView spilled = spilledView.     if (spilled != null) {         spilled.notifySubpartitionConsumed().     } else {         parent.onConsumedSubpartition().     } }
false;public;0;9;;@Override public boolean isReleased() {     SpilledSubpartitionView spilled = spilledView.     if (spilled != null) {         return spilled.isReleased().     } else {         return parent.isReleased() || isReleased.get().     } }
false;public;0;14;;@Override public boolean nextBufferIsEvent() {     synchronized (buffers) {         if (isReleased.get()) {             return false.         } else if (nextBuffer != null) {             return !nextBuffer.isBuffer().         }     }     // else: spilled     checkState(spilledView != null, "No in-memory buffers available, but also nothing spilled.").     return spilledView.nextBufferIsEvent(). }
false;public;0;13;;@Override public boolean isAvailable() {     synchronized (buffers) {         if (nextBuffer != null) {             return true.         } else if (spilledView == null) {             return false.         }     }     return spilledView.isAvailable(). }
false;public;0;9;;@Override public Throwable getFailureCause() {     SpilledSubpartitionView spilled = spilledView.     if (spilled != null) {         return spilled.getFailureCause().     } else {         return parent.getFailureCause().     } }
false;public;0;10;;@Override public String toString() {     boolean hasSpilled = spilledView != null.     return String.format("SpillableSubpartitionView(index: %d, buffers: %d, spilled? %b) of ResultPartition %s", parent.index, numBuffers, hasSpilled, parent.parent.getPartitionId()). }
