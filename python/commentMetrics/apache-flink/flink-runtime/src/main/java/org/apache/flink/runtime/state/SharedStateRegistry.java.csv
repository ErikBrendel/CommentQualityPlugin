commented;modifiers;parameterAmount;loc;comment;code
true;public;2;39;/**  * Register a reference to the given shared state in the registry.  * This does the following: We check if the state handle is actually new by the  * registrationKey. If it is new, we register it with a reference count of 1. If there is  * already a state handle registered under the given key, we dispose the given "new" state  * handle, uptick the reference count of the previously existing state handle and return it as  * a replacement with the result.  *  * <p>IMPORTANT: caller should check the state handle returned by the result, because the  * registry is performing de-duplication and could potentially return a handle that is supposed  * to replace the one from the registration request.  *  * @param state the shared state for which we register a reference.  * @return the result of this registration request, consisting of the state handle that is  * registered under the key by the end of the operation and its current reference count.  */ ;/**  * Register a reference to the given shared state in the registry.  * This does the following: We check if the state handle is actually new by the  * registrationKey. If it is new, we register it with a reference count of 1. If there is  * already a state handle registered under the given key, we dispose the given "new" state  * handle, uptick the reference count of the previously existing state handle and return it as  * a replacement with the result.  *  * <p>IMPORTANT: caller should check the state handle returned by the result, because the  * registry is performing de-duplication and could potentially return a handle that is supposed  * to replace the one from the registration request.  *  * @param state the shared state for which we register a reference.  * @return the result of this registration request, consisting of the state handle that is  * registered under the key by the end of the operation and its current reference count.  */ public Result registerReference(SharedStateRegistryKey registrationKey, StreamStateHandle state) {     Preconditions.checkNotNull(state).     StreamStateHandle scheduledStateDeletion = null.     SharedStateRegistry.SharedStateEntry entry.     synchronized (registeredStates) {         Preconditions.checkState(open, "Attempt to register state to closed SharedStateRegistry.").         entry = registeredStates.get(registrationKey).         if (entry == null) {             // Additional check that should never fail, because only state handles that are not placeholders should             // ever be inserted to the registry.             Preconditions.checkState(!isPlaceholder(state), "Attempt to reference unknown state: " + registrationKey).             entry = new SharedStateRegistry.SharedStateEntry(state).             registeredStates.put(registrationKey, entry).         } else {             // delete if this is a real duplicate             if (!Objects.equals(state, entry.stateHandle)) {                 scheduledStateDeletion = state.                 LOG.trace("Identified duplicate state registration under key {}. New state {} was determined to " + "be an unnecessary copy of existing state {} and will be dropped.", registrationKey, state, entry.stateHandle).             }             entry.increaseReferenceCount().         }     }     scheduleAsyncDelete(scheduledStateDeletion).     LOG.trace("Registered shared state {} under key {}.", entry, registrationKey).     return new Result(entry). }
true;public;1;32;/**  * Releases one reference to the given shared state in the registry. This decreases the  * reference count by one. Once the count reaches zero, the shared state is deleted.  *  * @param registrationKey the shared state for which we release a reference.  * @return the result of the request, consisting of the reference count after this operation  * and the state handle, or null if the state handle was deleted through this request. Returns null if the registry  * was previously closed.  */ ;/**  * Releases one reference to the given shared state in the registry. This decreases the  * reference count by one. Once the count reaches zero, the shared state is deleted.  *  * @param registrationKey the shared state for which we release a reference.  * @return the result of the request, consisting of the reference count after this operation  * and the state handle, or null if the state handle was deleted through this request. Returns null if the registry  * was previously closed.  */ public Result unregisterReference(SharedStateRegistryKey registrationKey) {     Preconditions.checkNotNull(registrationKey).     final Result result.     final StreamStateHandle scheduledStateDeletion.     SharedStateRegistry.SharedStateEntry entry.     synchronized (registeredStates) {         entry = registeredStates.get(registrationKey).         Preconditions.checkState(entry != null, "Cannot unregister a state that is not registered.").         entry.decreaseReferenceCount().         // Remove the state from the registry when it's not referenced any more.         if (entry.getReferenceCount() <= 0) {             registeredStates.remove(registrationKey).             scheduledStateDeletion = entry.getStateHandle().             result = new Result(null, 0).         } else {             scheduledStateDeletion = null.             result = new Result(entry).         }     }     LOG.trace("Unregistered shared state {} under key {}.", entry, registrationKey).     scheduleAsyncDelete(scheduledStateDeletion).     return result. }
true;public;1;12;/**  * Register given shared states in the registry.  *  * @param stateHandles The shared states to register.  */ ;/**  * Register given shared states in the registry.  *  * @param stateHandles The shared states to register.  */ public void registerAll(Iterable<? extends CompositeStateHandle> stateHandles) {     if (stateHandles == null) {         return.     }     synchronized (registeredStates) {         for (CompositeStateHandle stateHandle : stateHandles) {             stateHandle.registerSharedStates(this).         }     } }
false;public;0;8;;@Override public String toString() {     synchronized (registeredStates) {         return "SharedStateRegistry{" + "registeredStates=" + registeredStates + '}'.     } }
false;private;1;17;;private void scheduleAsyncDelete(StreamStateHandle streamStateHandle) {     // We do the small optimization to not issue discards for placeholders, which are NOPs.     if (streamStateHandle != null && !isPlaceholder(streamStateHandle)) {         LOG.trace("Scheduled delete of state handle {}.", streamStateHandle).         AsyncDisposalRunnable asyncDisposalRunnable = new AsyncDisposalRunnable(streamStateHandle).         try {             asyncDisposalExecutor.execute(asyncDisposalRunnable).         } catch (RejectedExecutionException ex) {             // TODO This is a temporary fix for a problem during ZooKeeperCompletedCheckpointStore#shutdown:             // Disposal is issued in another async thread and the shutdown proceeds to close the I/O Executor pool.             // This leads to RejectedExecutionException once the async deletes are triggered by ZK. We need to             // wait for all pending ZK deletes before closing the I/O Executor pool. We can simply call #run()             // because we are already in the async ZK thread that disposes the handles.             asyncDisposalRunnable.run().         }     } }
false;private;1;3;;private boolean isPlaceholder(StreamStateHandle stateHandle) {     return stateHandle instanceof PlaceholderStreamStateHandle. }
false;public;0;6;;@Override public void close() {     synchronized (registeredStates) {         open = false.     } }
false;;0;3;;StreamStateHandle getStateHandle() {     return stateHandle. }
false;;0;3;;int getReferenceCount() {     return referenceCount. }
false;;0;3;;void increaseReferenceCount() {     ++referenceCount. }
false;;0;3;;void decreaseReferenceCount() {     --referenceCount. }
false;public;0;7;;@Override public String toString() {     return "SharedStateEntry{" + "stateHandle=" + stateHandle + ", referenceCount=" + referenceCount + '}'. }
false;public;0;3;;public StreamStateHandle getReference() {     return reference. }
false;public;0;3;;public int getReferenceCount() {     return referenceCount. }
false;public;0;7;;@Override public String toString() {     return "Result{" + "reference=" + reference + ", referenceCount=" + referenceCount + '}'. }
false;public;0;8;;@Override public void run() {     try {         toDispose.discardState().     } catch (Exception e) {         LOG.warn("A problem occurred during asynchronous disposal of a shared state object: {}", toDispose, e).     } }
