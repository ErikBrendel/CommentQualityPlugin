commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public long getCheckpointId() {     return checkpointId. }
false;public;0;4;;@Override public long getCheckpointTimestamp() {     return checkpointTimestamp. }
false;private;0;7;;private CheckpointStreamFactory.CheckpointStateOutputStream openAndRegisterNewStream() throws Exception {     CheckpointStreamFactory.CheckpointStateOutputStream cout = streamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE).     closableRegistry.registerCloseable(cout).     return cout. }
false;public;0;8;;@Override public KeyedStateCheckpointOutputStream getRawKeyedOperatorStateOutput() throws Exception {     if (null == keyedStateCheckpointOutputStream) {         Preconditions.checkState(keyGroupRange != KeyGroupRange.EMPTY_KEY_GROUP_RANGE, "Not a keyed operator").         keyedStateCheckpointOutputStream = new KeyedStateCheckpointOutputStream(openAndRegisterNewStream(), keyGroupRange).     }     return keyedStateCheckpointOutputStream. }
false;public;0;7;;@Override public OperatorStateCheckpointOutputStream getRawOperatorStateOutput() throws Exception {     if (null == operatorStateCheckpointOutputStream) {         operatorStateCheckpointOutputStream = new OperatorStateCheckpointOutputStream(openAndRegisterNewStream()).     }     return operatorStateCheckpointOutputStream. }
false;public;0;6;;@Nonnull public RunnableFuture<SnapshotResult<KeyedStateHandle>> getKeyedStateStreamFuture() throws IOException {     KeyedStateHandle keyGroupsStateHandle = closeAndUnregisterStreamToObtainStateHandle(keyedStateCheckpointOutputStream).     return toDoneFutureOfSnapshotResult(keyGroupsStateHandle). }
false;public;0;6;;@Nonnull public RunnableFuture<SnapshotResult<OperatorStateHandle>> getOperatorStateStreamFuture() throws IOException {     OperatorStateHandle operatorStateHandle = closeAndUnregisterStreamToObtainStateHandle(operatorStateCheckpointOutputStream).     return toDoneFutureOfSnapshotResult(operatorStateHandle). }
false;private;1;4;;private <T extends StateObject> RunnableFuture<SnapshotResult<T>> toDoneFutureOfSnapshotResult(T handle) {     SnapshotResult<T> snapshotResult = SnapshotResult.of(handle).     return DoneFuture.of(snapshotResult). }
false;private;1;9;;private <T extends StreamStateHandle> T closeAndUnregisterStreamToObtainStateHandle(NonClosingCheckpointOutputStream<T> stream) throws IOException {     if (stream != null && closableRegistry.unregisterCloseable(stream.getDelegate())) {         return stream.closeAndGetHandle().     } else {         return null.     } }
false;private;1;11;;private <T extends StreamStateHandle> void closeAndUnregisterStream(NonClosingCheckpointOutputStream<? extends T> stream) throws IOException {     Preconditions.checkNotNull(stream).     CheckpointStreamFactory.CheckpointStateOutputStream delegate = stream.getDelegate().     if (closableRegistry.unregisterCloseable(delegate)) {         delegate.close().     } }
false;public;0;26;;@Override public void close() throws IOException {     IOException exception = null.     if (keyedStateCheckpointOutputStream != null) {         try {             closeAndUnregisterStream(keyedStateCheckpointOutputStream).         } catch (IOException e) {             exception = new IOException("Could not close the raw keyed state checkpoint output stream.", e).         }     }     if (operatorStateCheckpointOutputStream != null) {         try {             closeAndUnregisterStream(operatorStateCheckpointOutputStream).         } catch (IOException e) {             exception = ExceptionUtils.firstOrSuppressed(new IOException("Could not close the raw operator state checkpoint output stream.", e), exception).         }     }     if (exception != null) {         throw exception.     } }
