commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// ------------------------------------------------------------------------ // Properties // ------------------------------------------------------------------------ public JobID getJobId() {     return job. }
false;public;0;3;;public long getCheckpointID() {     return checkpointID. }
false;public;0;3;;public long getTimestamp() {     return timestamp. }
false;public;0;3;;public long getDuration() {     return duration. }
false;public;0;3;;public CheckpointProperties getProperties() {     return props. }
false;public;0;3;;public Map<OperatorID, OperatorState> getOperatorStates() {     return operatorStates. }
false;public;0;3;;public Collection<MasterState> getMasterHookStates() {     return Collections.unmodifiableCollection(masterHookStates). }
false;public;0;3;;public StreamStateHandle getMetadataHandle() {     return metadataHandle. }
false;public;0;3;;public String getExternalPointer() {     return externalPointer. }
false;public;0;9;;public long getStateSize() {     long result = 0L.     for (OperatorState operatorState : operatorStates.values()) {         result += operatorState.getStateSize().     }     return result. }
true;public;1;3;/**  * Register all shared states in the given registry. This is method is called  * before the checkpoint is added into the store.  *  * @param sharedStateRegistry The registry where shared states are registered  */ ;// ------------------------------------------------------------------------ // Shared State // ------------------------------------------------------------------------ /**  * Register all shared states in the given registry. This is method is called  * before the checkpoint is added into the store.  *  * @param sharedStateRegistry The registry where shared states are registered  */ public void registerSharedStatesAfterRestored(SharedStateRegistry sharedStateRegistry) {     sharedStateRegistry.registerAll(operatorStates.values()). }
false;public;0;3;;// ------------------------------------------------------------------------ // Discard and Dispose // ------------------------------------------------------------------------ public void discardOnFailedStoring() throws Exception {     doDiscard(). }
false;public;0;8;;public boolean discardOnSubsume() throws Exception {     if (props.discardOnSubsumed()) {         doDiscard().         return true.     }     return false. }
false;public;1;14;;public boolean discardOnShutdown(JobStatus jobStatus) throws Exception {     if (jobStatus == JobStatus.FINISHED && props.discardOnJobFinished() || jobStatus == JobStatus.CANCELED && props.discardOnJobCancelled() || jobStatus == JobStatus.FAILED && props.discardOnJobFailed() || jobStatus == JobStatus.SUSPENDED && props.discardOnJobSuspended()) {         doDiscard().         return true.     } else {         LOG.info("Checkpoint with ID {} at '{}' not discarded.", checkpointID, externalPointer).         return false.     } }
false;private;0;42;;private void doDiscard() throws Exception {     LOG.trace("Executing discard procedure for {}.", this).     try {         // collect exceptions and continue cleanup         Exception exception = null.         // drop the metadata         try {             metadataHandle.discardState().         } catch (Exception e) {             exception = e.         }         // discard private state objects         try {             StateUtil.bestEffortDiscardAllStateObjects(operatorStates.values()).         } catch (Exception e) {             exception = ExceptionUtils.firstOrSuppressed(e, exception).         }         // discard location as a whole         try {             storageLocation.disposeStorageLocation().         } catch (Exception e) {             exception = ExceptionUtils.firstOrSuppressed(e, exception).         }         if (exception != null) {             throw exception.         }     } finally {         operatorStates.clear().         // to be null-pointer safe, copy reference to stack         CompletedCheckpointStats.DiscardCallback discardCallback = this.discardCallback.         if (discardCallback != null) {             discardCallback.notifyDiscardedCheckpoint().         }     } }
false;public,static;2;23;;// ------------------------------------------------------------------------ // Miscellaneous // ------------------------------------------------------------------------ public static boolean checkpointsMatch(Collection<CompletedCheckpoint> first, Collection<CompletedCheckpoint> second) {     if (first.size() != second.size()) {         return false.     }     List<Tuple2<Long, JobID>> firstInterestingFields = new ArrayList<>(first.size()).     for (CompletedCheckpoint checkpoint : first) {         firstInterestingFields.add(new Tuple2<>(checkpoint.getCheckpointID(), checkpoint.getJobId())).     }     List<Tuple2<Long, JobID>> secondInterestingFields = new ArrayList<>(second.size()).     for (CompletedCheckpoint checkpoint : second) {         secondInterestingFields.add(new Tuple2<>(checkpoint.getCheckpointID(), checkpoint.getJobId())).     }     return firstInterestingFields.equals(secondInterestingFields). }
true;;1;3;/**  * Sets the callback for tracking when this checkpoint is discarded.  *  * @param discardCallback Callback to call when the checkpoint is discarded.  */ ;/**  * Sets the callback for tracking when this checkpoint is discarded.  *  * @param discardCallback Callback to call when the checkpoint is discarded.  */ void setDiscardCallback(@Nullable CompletedCheckpointStats.DiscardCallback discardCallback) {     this.discardCallback = discardCallback. }
false;public;0;4;;@Override public String toString() {     return String.format("Checkpoint %d @ %d for %s", checkpointID, timestamp, job). }
