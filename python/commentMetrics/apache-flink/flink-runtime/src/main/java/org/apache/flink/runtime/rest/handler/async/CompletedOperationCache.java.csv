commented;modifiers;parameterAmount;loc;comment;code
true;public;2;14;/**  * Registers an ongoing operation with the cache.  *  * @param operationResultFuture A future containing the operation result.  */ ;/**  * Registers an ongoing operation with the cache.  *  * @param operationResultFuture A future containing the operation result.  */ public void registerOngoingOperation(final K operationKey, final CompletableFuture<R> operationResultFuture) {     final ResultAccessTracker<R> inProgress = ResultAccessTracker.inProgress().     registeredOperationTriggers.put(operationKey, inProgress).     operationResultFuture.whenComplete((result, error) -> {         if (error == null) {             completedOperations.put(operationKey, inProgress.finishOperation(Either.Right(result))).         } else {             completedOperations.put(operationKey, inProgress.finishOperation(Either.Left(error))).         }         registeredOperationTriggers.remove(operationKey).     }). }
true;public;1;11;/**  * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}  * finished, otherwise {@code null}.  *  * @throws UnknownOperationKeyException If the operation is not found, and there is no ongoing  *                                      operation under the provided key.  */ ;/**  * Returns the operation result or a {@code Throwable} if the {@code CompletableFuture}  * finished, otherwise {@code null}.  *  * @throws UnknownOperationKeyException If the operation is not found, and there is no ongoing  *                                      operation under the provided key.  */ @Nullable public Either<Throwable, R> get(final K operationKey) throws UnknownOperationKeyException {     ResultAccessTracker<R> resultAccessTracker.     if ((resultAccessTracker = registeredOperationTriggers.get(operationKey)) == null && (resultAccessTracker = completedOperations.getIfPresent(operationKey)) == null) {         throw new UnknownOperationKeyException(operationKey).     }     return resultAccessTracker.accessOperationResultOrError(). }
false;public;0;7;;@Override public CompletableFuture<Void> closeAsync() {     return FutureUtils.orTimeout(asyncWaitForResultsToBeAccessed(), COMPLETED_OPERATION_RESULT_CACHE_DURATION_SECONDS, TimeUnit.SECONDS). }
false;private;0;6;;private CompletableFuture<Void> asyncWaitForResultsToBeAccessed() {     return FutureUtils.waitForAll(Stream.concat(registeredOperationTriggers.values().stream(), completedOperations.asMap().values().stream()).map(ResultAccessTracker::getAccessedFuture).collect(Collectors.toList())). }
false;;0;4;;@VisibleForTesting void cleanUp() {     completedOperations.cleanUp(). }
false;private,static;0;3;;private static <R> ResultAccessTracker<R> inProgress() {     return new ResultAccessTracker<>(). }
true;public;1;5;/**  * Creates a new instance of the tracker with the result of the asynchronous operation set.  */ ;/**  * Creates a new instance of the tracker with the result of the asynchronous operation set.  */ public ResultAccessTracker<R> finishOperation(final Either<Throwable, R> operationResultOrError) {     checkState(this.operationResultOrError == null).     return new ResultAccessTracker<>(checkNotNull(operationResultOrError), this.accessed). }
true;public;0;7;/**  * If present, returns the result of the asynchronous operation, and marks the result as  * accessed. If the result is not present, this method returns null.  */ ;/**  * If present, returns the result of the asynchronous operation, and marks the result as  * accessed. If the result is not present, this method returns null.  */ @Nullable public Either<Throwable, R> accessOperationResultOrError() {     if (operationResultOrError != null) {         markAccessed().     }     return operationResultOrError. }
false;public;0;3;;public CompletableFuture<Void> getAccessedFuture() {     return accessed. }
false;private;0;3;;private void markAccessed() {     accessed.complete(null). }
