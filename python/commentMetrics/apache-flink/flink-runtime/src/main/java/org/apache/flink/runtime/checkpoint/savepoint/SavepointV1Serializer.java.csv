commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public void serialize(SavepointV2 savepoint, DataOutputStream dos) throws IOException {     throw new UnsupportedOperationException("This serializer is read-only and only exists for backwards compatibility"). }
false;public;2;30;;@Override public SavepointV2 deserialize(DataInputStream dis, ClassLoader cl) throws IOException {     long checkpointId = dis.readLong().     // Task states     int numTaskStates = dis.readInt().     List<TaskState> taskStates = new ArrayList<>(numTaskStates).     for (int i = 0. i < numTaskStates. i++) {         JobVertexID jobVertexId = new JobVertexID(dis.readLong(), dis.readLong()).         int parallelism = dis.readInt().         int maxParallelism = dis.readInt().         int chainLength = dis.readInt().         // Add task state         TaskState taskState = new TaskState(jobVertexId, parallelism, maxParallelism, chainLength).         taskStates.add(taskState).         // Sub task states         int numSubTaskStates = dis.readInt().         for (int j = 0. j < numSubTaskStates. j++) {             int subtaskIndex = dis.readInt().             SubtaskState subtaskState = deserializeSubtaskState(dis).             taskState.putState(subtaskIndex, subtaskState).         }     }     return new SavepointV2(checkpointId, taskStates). }
false;public;2;26;;public void serializeOld(SavepointV1 savepoint, DataOutputStream dos) throws IOException {     dos.writeLong(savepoint.getCheckpointId()).     Collection<TaskState> taskStates = savepoint.getTaskStates().     dos.writeInt(taskStates.size()).     for (TaskState taskState : savepoint.getTaskStates()) {         // Vertex ID         dos.writeLong(taskState.getJobVertexID().getLowerPart()).         dos.writeLong(taskState.getJobVertexID().getUpperPart()).         // Parallelism         int parallelism = taskState.getParallelism().         dos.writeInt(parallelism).         dos.writeInt(taskState.getMaxParallelism()).         dos.writeInt(taskState.getChainLength()).         // Sub task states         Map<Integer, SubtaskState> subtaskStateMap = taskState.getSubtaskStates().         dos.writeInt(subtaskStateMap.size()).         for (Map.Entry<Integer, SubtaskState> entry : subtaskStateMap.entrySet()) {             dos.writeInt(entry.getKey()).             serializeSubtaskState(entry.getValue(), dos).         }     } }
false;private,static;2;32;;private static void serializeSubtaskState(SubtaskState subtaskState, DataOutputStream dos) throws IOException {     // backwards compatibility, do not remove     dos.writeLong(-1L).     // backwards compatibility (number of legacy state handles), do not remove     dos.writeInt(0).     ChainedStateHandle<OperatorStateHandle> operatorStateBackend = subtaskState.getManagedOperatorState().     int len = operatorStateBackend != null ? operatorStateBackend.getLength() : 0.     dos.writeInt(len).     for (int i = 0. i < len. ++i) {         OperatorStateHandle stateHandle = operatorStateBackend.get(i).         serializeOperatorStateHandle(stateHandle, dos).     }     ChainedStateHandle<OperatorStateHandle> operatorStateFromStream = subtaskState.getRawOperatorState().     len = operatorStateFromStream != null ? operatorStateFromStream.getLength() : 0.     dos.writeInt(len).     for (int i = 0. i < len. ++i) {         OperatorStateHandle stateHandle = operatorStateFromStream.get(i).         serializeOperatorStateHandle(stateHandle, dos).     }     KeyedStateHandle keyedStateBackend = subtaskState.getManagedKeyedState().     serializeKeyedStateHandle(keyedStateBackend, dos).     KeyedStateHandle keyedStateStream = subtaskState.getRawKeyedState().     serializeKeyedStateHandle(keyedStateStream, dos). }
false;private,static;1;49;;private static SubtaskState deserializeSubtaskState(DataInputStream dis) throws IOException {     // Duration field has been removed from SubtaskState     long ignoredDuration = dis.readLong().     int len = dis.readInt().     if (SavepointSerializers.FAIL_WHEN_LEGACY_STATE_DETECTED) {         Preconditions.checkState(len == 0, "Legacy state (from Flink <= 1.1, created through the 'Checkpointed' interface) is " + "no longer supported starting from Flink 1.4. Please rewrite your job to use " + "'CheckpointedFunction' instead!").     } else {         for (int i = 0. i < len. ++i) {             // absorb bytes from stream and ignore result             deserializeStreamStateHandle(dis).         }     }     len = dis.readInt().     List<OperatorStateHandle> operatorStateBackend = new ArrayList<>(len).     for (int i = 0. i < len. ++i) {         OperatorStateHandle streamStateHandle = deserializeOperatorStateHandle(dis).         operatorStateBackend.add(streamStateHandle).     }     len = dis.readInt().     List<OperatorStateHandle> operatorStateStream = new ArrayList<>(len).     for (int i = 0. i < len. ++i) {         OperatorStateHandle streamStateHandle = deserializeOperatorStateHandle(dis).         operatorStateStream.add(streamStateHandle).     }     KeyedStateHandle keyedStateBackend = deserializeKeyedStateHandle(dis).     KeyedStateHandle keyedStateStream = deserializeKeyedStateHandle(dis).     ChainedStateHandle<OperatorStateHandle> operatorStateBackendChain = new ChainedStateHandle<>(operatorStateBackend).     ChainedStateHandle<OperatorStateHandle> operatorStateStreamChain = new ChainedStateHandle<>(operatorStateStream).     return new SubtaskState(operatorStateBackendChain, operatorStateStreamChain, keyedStateBackend, keyedStateStream). }
false;public,static;2;20;;@VisibleForTesting public static void serializeKeyedStateHandle(KeyedStateHandle stateHandle, DataOutputStream dos) throws IOException {     if (stateHandle == null) {         dos.writeByte(NULL_HANDLE).     } else if (stateHandle instanceof KeyGroupsStateHandle) {         KeyGroupsStateHandle keyGroupsStateHandle = (KeyGroupsStateHandle) stateHandle.         dos.writeByte(KEY_GROUPS_HANDLE).         dos.writeInt(keyGroupsStateHandle.getKeyGroupRange().getStartKeyGroup()).         dos.writeInt(keyGroupsStateHandle.getKeyGroupRange().getNumberOfKeyGroups()).         for (int keyGroup : keyGroupsStateHandle.getKeyGroupRange()) {             dos.writeLong(keyGroupsStateHandle.getOffsetForKeyGroup(keyGroup)).         }         serializeStreamStateHandle(keyGroupsStateHandle.getDelegateStateHandle(), dos).     } else {         throw new IllegalStateException("Unknown KeyedStateHandle type: " + stateHandle.getClass()).     } }
false;public,static;1;21;;@VisibleForTesting public static KeyedStateHandle deserializeKeyedStateHandle(DataInputStream dis) throws IOException {     final int type = dis.readByte().     if (NULL_HANDLE == type) {         return null.     } else if (KEY_GROUPS_HANDLE == type) {         int startKeyGroup = dis.readInt().         int numKeyGroups = dis.readInt().         KeyGroupRange keyGroupRange = KeyGroupRange.of(startKeyGroup, startKeyGroup + numKeyGroups - 1).         long[] offsets = new long[numKeyGroups].         for (int i = 0. i < numKeyGroups. ++i) {             offsets[i] = dis.readLong().         }         KeyGroupRangeOffsets keyGroupRangeOffsets = new KeyGroupRangeOffsets(keyGroupRange, offsets).         StreamStateHandle stateHandle = deserializeStreamStateHandle(dis).         return new KeyGroupsStateHandle(keyGroupRangeOffsets, stateHandle).     } else {         throw new IllegalStateException("Reading invalid KeyedStateHandle, type: " + type).     } }
false;public,static;2;28;;@VisibleForTesting public static void serializeOperatorStateHandle(OperatorStateHandle stateHandle, DataOutputStream dos) throws IOException {     if (stateHandle != null) {         dos.writeByte(PARTITIONABLE_OPERATOR_STATE_HANDLE).         Map<String, OperatorStateHandle.StateMetaInfo> partitionOffsetsMap = stateHandle.getStateNameToPartitionOffsets().         dos.writeInt(partitionOffsetsMap.size()).         for (Map.Entry<String, OperatorStateHandle.StateMetaInfo> entry : partitionOffsetsMap.entrySet()) {             dos.writeUTF(entry.getKey()).             OperatorStateHandle.StateMetaInfo stateMetaInfo = entry.getValue().             int mode = stateMetaInfo.getDistributionMode().ordinal().             dos.writeByte(mode).             long[] offsets = stateMetaInfo.getOffsets().             dos.writeInt(offsets.length).             for (long offset : offsets) {                 dos.writeLong(offset).             }         }         serializeStreamStateHandle(stateHandle.getDelegateStateHandle(), dos).     } else {         dos.writeByte(NULL_HANDLE).     } }
false;public,static;1;31;;@VisibleForTesting public static OperatorStateHandle deserializeOperatorStateHandle(DataInputStream dis) throws IOException {     final int type = dis.readByte().     if (NULL_HANDLE == type) {         return null.     } else if (PARTITIONABLE_OPERATOR_STATE_HANDLE == type) {         int mapSize = dis.readInt().         Map<String, OperatorStateHandle.StateMetaInfo> offsetsMap = new HashMap<>(mapSize).         for (int i = 0. i < mapSize. ++i) {             String key = dis.readUTF().             int modeOrdinal = dis.readByte().             OperatorStateHandle.Mode mode = OperatorStateHandle.Mode.values()[modeOrdinal].             long[] offsets = new long[dis.readInt()].             for (int j = 0. j < offsets.length. ++j) {                 offsets[j] = dis.readLong().             }             OperatorStateHandle.StateMetaInfo metaInfo = new OperatorStateHandle.StateMetaInfo(offsets, mode).             offsetsMap.put(key, metaInfo).         }         StreamStateHandle stateHandle = deserializeStreamStateHandle(dis).         return new OperatorStreamStateHandle(offsetsMap, stateHandle).     } else {         throw new IllegalStateException("Reading invalid OperatorStateHandle, type: " + type).     } }
false;public,static;2;27;;@VisibleForTesting public static void serializeStreamStateHandle(StreamStateHandle stateHandle, DataOutputStream dos) throws IOException {     if (stateHandle == null) {         dos.writeByte(NULL_HANDLE).     } else if (stateHandle instanceof FileStateHandle) {         dos.writeByte(FILE_STREAM_STATE_HANDLE).         FileStateHandle fileStateHandle = (FileStateHandle) stateHandle.         dos.writeLong(stateHandle.getStateSize()).         dos.writeUTF(fileStateHandle.getFilePath().toString()).     } else if (stateHandle instanceof ByteStreamStateHandle) {         dos.writeByte(BYTE_STREAM_STATE_HANDLE).         ByteStreamStateHandle byteStreamStateHandle = (ByteStreamStateHandle) stateHandle.         dos.writeUTF(byteStreamStateHandle.getHandleName()).         byte[] internalData = byteStreamStateHandle.getData().         dos.writeInt(internalData.length).         dos.write(byteStreamStateHandle.getData()).     } else {         throw new IOException("Unknown implementation of StreamStateHandle: " + stateHandle.getClass()).     }     dos.flush(). }
false;public,static;1;19;;@VisibleForTesting public static StreamStateHandle deserializeStreamStateHandle(DataInputStream dis) throws IOException {     int type = dis.read().     if (NULL_HANDLE == type) {         return null.     } else if (FILE_STREAM_STATE_HANDLE == type) {         long size = dis.readLong().         String pathString = dis.readUTF().         return new FileStateHandle(new Path(pathString), size).     } else if (BYTE_STREAM_STATE_HANDLE == type) {         String handleName = dis.readUTF().         int numBytes = dis.readInt().         byte[] data = new byte[numBytes].         dis.readFully(data).         return new ByteStreamStateHandle(handleName, data).     } else {         throw new IOException("Unknown implementation of StreamStateHandle, code: " + type).     } }
