commented;modifiers;parameterAmount;loc;comment;code
false;public,final;1;4;;// ------------------------------------------------------------------------ // I/O // ------------------------------------------------------------------------ @Override public final void write(int b) throws IOException {     out.write(b). }
false;public,final;3;4;;@Override public final void write(@Nonnull byte[] b, int off, int len) throws IOException {     out.write(b, off, len). }
false;public;0;4;;@Override public long getPos() throws IOException {     return out.getPos(). }
false;public;0;4;;@Override public void flush() throws IOException {     out.flush(). }
false;public;0;4;;@Override public void sync() throws IOException {     out.sync(). }
false;public;0;3;;// ------------------------------------------------------------------------ // Closing // ------------------------------------------------------------------------ public boolean isClosed() {     return closed. }
false;public;0;14;;@Override public void close() {     if (!closed) {         closed = true.         try {             out.close().             fileSystem.delete(metadataFilePath, false).         } catch (Throwable t) {             LOG.warn("Could not close the state stream for {}.", metadataFilePath, t).         }     } }
false;public;0;40;;@Override public FsCompletedCheckpointStorageLocation closeAndFinalizeCheckpoint() throws IOException {     synchronized (this) {         if (!closed) {             try {                 // make a best effort attempt to figure out the size                 long size = 0.                 try {                     size = out.getPos().                 } catch (Exception ignored) {                 }                 out.close().                 FileStateHandle metaDataHandle = new FileStateHandle(metadataFilePath, size).                 return new FsCompletedCheckpointStorageLocation(fileSystem, exclusiveCheckpointDir, metaDataHandle, metaDataHandle.getFilePath().getParent().toString()).             } catch (Exception e) {                 try {                     fileSystem.delete(metadataFilePath, false).                 } catch (Exception deleteException) {                     LOG.warn("Could not delete the checkpoint stream file {}.", metadataFilePath, deleteException).                 }                 throw new IOException("Could not flush and close the file system " + "output stream to " + metadataFilePath + " in order to obtain the " + "stream state handle", e).             } finally {                 closed = true.             }         } else {             throw new IOException("Stream has already been closed and discarded.").         }     } }
