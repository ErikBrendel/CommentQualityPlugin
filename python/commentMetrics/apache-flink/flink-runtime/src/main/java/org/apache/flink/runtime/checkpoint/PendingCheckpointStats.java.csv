commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public CheckpointStatsStatus getStatus() {     return CheckpointStatsStatus.IN_PROGRESS. }
false;public;0;4;;@Override public int getNumberOfAcknowledgedSubtasks() {     return currentNumAcknowledgedSubtasks. }
false;public;0;4;;@Override public long getStateSize() {     return currentStateSize. }
false;public;0;4;;@Override public long getAlignmentBuffered() {     return currentAlignmentBuffered. }
false;public;0;4;;@Override public SubtaskStateStats getLatestAcknowledgedSubtaskStats() {     return latestAcknowledgedSubtask. }
true;;2;19;/**  * Reports statistics for a single subtask.  *  * @param jobVertexId ID of the task/operator the subtask belongs to.  * @param subtask The statistics for the subtask.  * @return <code>true</code> if successfully reported or <code>false</code> otherwise.  */ ;// ------------------------------------------------------------------------ // Callbacks from the PendingCheckpoint instance // ------------------------------------------------------------------------ /**  * Reports statistics for a single subtask.  *  * @param jobVertexId ID of the task/operator the subtask belongs to.  * @param subtask The statistics for the subtask.  * @return <code>true</code> if successfully reported or <code>false</code> otherwise.  */ boolean reportSubtaskStats(JobVertexID jobVertexId, SubtaskStateStats subtask) {     TaskStateStats taskStateStats = taskStats.get(jobVertexId).     if (taskStateStats != null && taskStateStats.reportSubtaskStats(subtask)) {         currentNumAcknowledgedSubtasks++.         latestAcknowledgedSubtask = subtask.         currentStateSize += subtask.getStateSize().         long alignmentBuffered = subtask.getAlignmentBuffered().         if (alignmentBuffered > 0) {             currentAlignmentBuffered += alignmentBuffered.         }         return true.     } else {         return false.     } }
true;;1;17;/**  * Reports a successfully completed pending checkpoint.  *  * @param externalPointer Optional external storage path if checkpoint was externalized.  * @return Callback for the {@link CompletedCheckpoint} instance to notify about disposal.  */ ;/**  * Reports a successfully completed pending checkpoint.  *  * @param externalPointer Optional external storage path if checkpoint was externalized.  * @return Callback for the {@link CompletedCheckpoint} instance to notify about disposal.  */ CompletedCheckpointStats.DiscardCallback reportCompletedCheckpoint(String externalPointer) {     CompletedCheckpointStats completed = new CompletedCheckpointStats(checkpointId, triggerTimestamp, props, numberOfSubtasks, new HashMap<>(taskStats), currentNumAcknowledgedSubtasks, currentStateSize, currentAlignmentBuffered, latestAcknowledgedSubtask, externalPointer).     trackerCallback.reportCompletedCheckpoint(completed).     return completed.getDiscardCallback(). }
true;;2;16;/**  * Reports a failed pending checkpoint.  *  * @param failureTimestamp Timestamp of the failure.  * @param cause Optional cause of the failure.  */ ;/**  * Reports a failed pending checkpoint.  *  * @param failureTimestamp Timestamp of the failure.  * @param cause Optional cause of the failure.  */ void reportFailedCheckpoint(long failureTimestamp, @Nullable Throwable cause) {     FailedCheckpointStats failed = new FailedCheckpointStats(checkpointId, triggerTimestamp, props, numberOfSubtasks, new HashMap<>(taskStats), currentNumAcknowledgedSubtasks, currentStateSize, currentAlignmentBuffered, failureTimestamp, latestAcknowledgedSubtask, cause).     trackerCallback.reportFailedCheckpoint(failed). }
false;public;0;4;;@Override public String toString() {     return "PendingCheckpoint(id=" + getCheckpointId() + ")". }
