commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;// -------------------------------------------------------------------------------------------- @Override public void setup(AbstractInvokable parent) {     this.parent = parent.     @SuppressWarnings("unchecked")     final GroupCombineFunction<IN, OUT> combiner = BatchTask.instantiateUserCode(this.config, userCodeClassLoader, GroupCombineFunction.class).     this.combiner = combiner.     FunctionUtils.setFunctionRuntimeContext(combiner, getUdfRuntimeContext()). }
false;public;0;35;;@Override public void openTask() throws Exception {     // open the stub first     final Configuration stubConfig = this.config.getStubParameters().     BatchTask.openUserCode(this.combiner, stubConfig).     // ----------------- Set up the sorter -------------------------     // instantiate the serializer / comparator     final TypeSerializerFactory<IN> serializerFactory = this.config.getInputSerializer(0, this.userCodeClassLoader).     final TypeComparatorFactory<IN> sortingComparatorFactory = this.config.getDriverComparator(0, this.userCodeClassLoader).     final TypeComparatorFactory<IN> groupingComparatorFactory = this.config.getDriverComparator(1, this.userCodeClassLoader).     this.serializer = serializerFactory.getSerializer().     TypeComparator<IN> sortingComparator = sortingComparatorFactory.createComparator().     this.groupingComparator = groupingComparatorFactory.createComparator().     MemoryManager memManager = this.parent.getEnvironment().getMemoryManager().     final int numMemoryPages = memManager.computeNumberOfPages(this.config.getRelativeMemoryDriver()).     this.memory = memManager.allocatePages(this.parent, numMemoryPages).     // instantiate a fix-length in-place sorter, if possible, otherwise the out-of-place sorter     if (sortingComparator.supportsSerializationWithKeyNormalization() && this.serializer.getLength() > 0 && this.serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING) {         this.sorter = new FixedLengthRecordSorter<IN>(this.serializer, sortingComparator.duplicate(), this.memory).     } else {         this.sorter = new NormalizedKeySorter<IN>(this.serializer, sortingComparator.duplicate(), this.memory).     }     if (LOG.isDebugEnabled()) {         LOG.debug("SynchronousChainedCombineDriver object reuse: " + (this.objectReuseEnabled ? "ENABLED" : "DISABLED") + ".").     } }
false;public;0;9;;@Override public void closeTask() throws Exception {     this.sorter.dispose().     this.parent.getEnvironment().getMemoryManager().release(this.memory).     if (this.running) {         BatchTask.closeUserCode(this.combiner).     } }
false;public;0;12;;@Override public void cancelTask() {     this.running = false.     try {         this.sorter.dispose().     } catch (Exception e) {     // may happen during concurrent modification when canceling     }     this.parent.getEnvironment().getMemoryManager().release(this.memory). }
false;public;0;3;;// -------------------------------------------------------------------------------------------- public Function getStub() {     return this.combiner. }
false;public;0;3;;public String getTaskName() {     return this.taskName. }
false;public;1;28;;@Override public void collect(IN record) {     this.numRecordsIn.inc().     // try writing to the sorter first     try {         if (this.sorter.write(record)) {             return.         }     } catch (IOException e) {         throw new ExceptionInChainedStubException(this.taskName, e).     }     // do the actual sorting     try {         sortAndCombine().     } catch (Exception e) {         throw new ExceptionInChainedStubException(this.taskName, e).     }     this.sorter.reset().     try {         if (!this.sorter.write(record)) {             throw new IOException("Cannot write record to fresh sort buffer. Record too large.").         }     } catch (IOException e) {         throw new ExceptionInChainedStubException(this.taskName, e).     } }
false;public;0;10;;// -------------------------------------------------------------------------------------------- @Override public void close() {     try {         sortAndCombine().     } catch (Exception e) {         throw new ExceptionInChainedStubException(this.taskName, e).     }     this.outputCollector.close(). }
false;private;0;37;;private void sortAndCombine() throws Exception {     final InMemorySorter<IN> sorter = this.sorter.     if (objectReuseEnabled) {         if (!sorter.isEmpty()) {             this.sortAlgo.sort(sorter).             // run the combiner             final ReusingKeyGroupedIterator<IN> keyIter = new ReusingKeyGroupedIterator<IN>(sorter.getIterator(), this.serializer, this.groupingComparator).             // cache references on the stack             final GroupCombineFunction<IN, OUT> stub = this.combiner.             final Collector<OUT> output = this.outputCollector.             // run stub implementation             while (this.running && keyIter.nextKey()) {                 stub.combine(keyIter.getValues(), output).             }         }     } else {         if (!sorter.isEmpty()) {             this.sortAlgo.sort(sorter).             // run the combiner             final NonReusingKeyGroupedIterator<IN> keyIter = new NonReusingKeyGroupedIterator<IN>(sorter.getIterator(), this.groupingComparator).             // cache references on the stack             final GroupCombineFunction<IN, OUT> stub = this.combiner.             final Collector<OUT> output = this.outputCollector.             // run stub implementation             while (this.running && keyIter.nextKey()) {                 stub.combine(keyIter.getValues(), output).             }         }     } }
