commented;modifiers;parameterAmount;loc;comment;code
true;private,final;2;3;/**  * Determines the ordering of objects in this priority queue.  *  * @param a  *        The first element.  * @param b  *        The second element.  * @return True, if a &lt. b, false otherwise.  */ ;/**  * Determines the ordering of objects in this priority queue.  *  * @param a  *        The first element.  * @param b  *        The second element.  * @return True, if a &lt. b, false otherwise.  */ private final boolean lessThan(T a, T b) {     return comparator.compare(a, b) < 0. }
true;public;0;3;/**  * Returns the remaining capacity of the backing array.  *  * @return The remaining capacity of the backing array.  */ ;/**  * Returns the remaining capacity of the backing array.  *  * @return The remaining capacity of the backing array.  */ public int remainingCapacity() {     return capacity - size. }
true;public,final;1;5;/**  * Adds a buffer to a PriorityQueue in log(size) time. If one tries to  * add more objects than maxSize from initialize a RuntimeException  * (ArrayIndexOutOfBound) is thrown.  */ ;/**  * Adds a buffer to a PriorityQueue in log(size) time. If one tries to  * add more objects than maxSize from initialize a RuntimeException  * (ArrayIndexOutOfBound) is thrown.  */ public final void put(T element) {     size++.     heap[size] = element.     upHeap(). }
true;public;1;12;/**  * Adds element to the PriorityQueue in log(size) time if either the  * PriorityQueue is not full, or not lessThan(element, top()).  *  * @param element  *        The element to insert,  * @return True, if element is added, false otherwise.  */ ;/**  * Adds element to the PriorityQueue in log(size) time if either the  * PriorityQueue is not full, or not lessThan(element, top()).  *  * @param element  *        The element to insert,  * @return True, if element is added, false otherwise.  */ public boolean offer(T element) {     if (size < capacity) {         put(element).         return true.     } else if (size > 0 && !lessThan(element, peek())) {         heap[1] = element.         adjustTop().         return true.     } else {         return false.     } }
true;public,final;0;7;/**  * Returns the least element of the PriorityQueue in constant time, but  * does not remove it from the priority queue.  *  * @return The least element.  */ ;/**  * Returns the least element of the PriorityQueue in constant time, but  * does not remove it from the priority queue.  *  * @return The least element.  */ public final T peek() {     if (size > 0) {         return heap[1].     } else {         return null.     } }
true;public,final;0;12;/**  * Removes and returns the least element of the PriorityQueue in  * log(size) time.  *  * @return The least element.  */ ;/**  * Removes and returns the least element of the PriorityQueue in  * log(size) time.  *  * @return The least element.  */ public final T poll() {     if (size > 0) {         // save first value         T result = heap[1].         // move last to first         heap[1] = heap[size].         // permit GC of objects         heap[size] = null.         size--.         // adjust heap         downHeap().         return result.     } else {         return null.     } }
true;public,final;0;3;/**  * Should be called when the Object at top changes values. Still log(n)  * worst case, but it's at least twice as fast to  *  * <pre>  * {  * 	pq.top().change().  * 	pq.adjustTop().  * }  * </pre>  *  * instead of  *  * <pre>  * {  * 	o = pq.pop().  * 	o.change().  * 	pq.push(o).  * }  * </pre>  */ ;/**  * Should be called when the Object at top changes values. Still log(n)  * worst case, but it's at least twice as fast to  *  * <pre>  * {  * 	pq.top().change().  * 	pq.adjustTop().  * }  * </pre>  *  * instead of  *  * <pre>  * {  * 	o = pq.pop().  * 	o.change().  * 	pq.push(o).  * }  * </pre>  */ public final void adjustTop() {     downHeap(). }
true;public,final;0;3;/**  * Returns the number of elements currently stored in the PriorityQueue.  *  * @return The number of elements in the queue.  */ ;/**  * Returns the number of elements currently stored in the PriorityQueue.  *  * @return The number of elements in the queue.  */ public final int size() {     return size. }
true;public,final;0;6;/**  * Removes all entries from the PriorityQueue.  */ ;/**  * Removes all entries from the PriorityQueue.  */ public final void clear() {     for (int i = 0. i <= size. i++) {         heap[i] = null.     }     size = 0. }
false;private;0;11;;private void upHeap() {     int i = size.     // save bottom node     T node = heap[i].     int j = i >>> 1.     while (j > 0 && lessThan(node, heap[j])) {         // shift parents down         heap[i] = heap[j].         i = j.         j = j >>> 1.     }     // install saved node     heap[i] = node. }
false;private;0;21;;private void downHeap() {     int i = 1.     // save top node     T node = heap[i].     // find smaller child     int j = i << 1.     int k = j + 1.     if (k <= size && lessThan(heap[k], heap[j])) {         j = k.     }     while (j <= size && lessThan(heap[j], node)) {         // shift up child         heap[i] = heap[j].         i = j.         j = i << 1.         k = j + 1.         if (k <= size && lessThan(heap[k], heap[j])) {             j = k.         }     }     // install saved node     heap[i] = node. }
false;public;0;4;;@Override public Iterator<T> iterator() {     return Arrays.asList(heap).iterator(). }
