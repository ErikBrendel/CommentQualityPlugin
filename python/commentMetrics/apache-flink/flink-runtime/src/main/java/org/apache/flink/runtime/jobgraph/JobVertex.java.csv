commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the ID of this job vertex.  *  * @return The ID of this job vertex  */ ;// -------------------------------------------------------------------------------------------- /**  * Returns the ID of this job vertex.  *  * @return The ID of this job vertex  */ public JobVertexID getID() {     return this.id. }
true;public;0;3;/**  * Returns a list of all alternative IDs of this job vertex.  *  * @return List of all alternative IDs for this job vertex  */ ;/**  * Returns a list of all alternative IDs of this job vertex.  *  * @return List of all alternative IDs for this job vertex  */ public List<JobVertexID> getIdAlternatives() {     return idAlternatives. }
true;public;0;3;/**  * Returns the name of the vertex.  *  * @return The name of the vertex.  */ ;/**  * Returns the name of the vertex.  *  * @return The name of the vertex.  */ public String getName() {     return this.name. }
true;public;1;3;/**  * Sets the name of the vertex  *  * @param name The new name.  */ ;/**  * Sets the name of the vertex  *  * @param name The new name.  */ public void setName(String name) {     this.name = name == null ? DEFAULT_NAME : name. }
true;public;0;3;/**  * Returns the number of produced intermediate data sets.  *  * @return The number of produced intermediate data sets.  */ ;/**  * Returns the number of produced intermediate data sets.  *  * @return The number of produced intermediate data sets.  */ public int getNumberOfProducedIntermediateDataSets() {     return this.results.size(). }
true;public;0;3;/**  * Returns the number of inputs.  *  * @return The number of inputs.  */ ;/**  * Returns the number of inputs.  *  * @return The number of inputs.  */ public int getNumberOfInputs() {     return this.inputs.size(). }
false;public;0;3;;public List<OperatorID> getOperatorIDs() {     return operatorIDs. }
false;public;0;3;;public List<OperatorID> getUserDefinedOperatorIDs() {     return operatorIdsAlternatives. }
true;public;0;6;/**  * Returns the vertex's configuration object which can be used to pass custom settings to the task at runtime.  *  * @return the vertex's configuration object  */ ;/**  * Returns the vertex's configuration object which can be used to pass custom settings to the task at runtime.  *  * @return the vertex's configuration object  */ public Configuration getConfiguration() {     if (this.configuration == null) {         this.configuration = new Configuration().     }     return this.configuration. }
false;public;1;5;;public void setInvokableClass(Class<? extends AbstractInvokable> invokable) {     Preconditions.checkNotNull(invokable).     this.invokableClassName = invokable.getName().     this.isStoppable = StoppableTask.class.isAssignableFrom(invokable). }
true;public;0;3;/**  * Returns the name of the invokable class which represents the task of this vertex.  *  * @return The name of the invokable class, <code>null</code> if not set.  */ ;/**  * Returns the name of the invokable class which represents the task of this vertex.  *  * @return The name of the invokable class, <code>null</code> if not set.  */ public String getInvokableClassName() {     return this.invokableClassName. }
true;public;1;18;/**  * Returns the invokable class which represents the task of this vertex  *  * @param cl The classloader used to resolve user-defined classes  * @return The invokable class, <code>null</code> if it is not set  */ ;/**  * Returns the invokable class which represents the task of this vertex  *  * @param cl The classloader used to resolve user-defined classes  * @return The invokable class, <code>null</code> if it is not set  */ public Class<? extends AbstractInvokable> getInvokableClass(ClassLoader cl) {     if (cl == null) {         throw new NullPointerException("The classloader must not be null.").     }     if (invokableClassName == null) {         return null.     }     try {         return Class.forName(invokableClassName, true, cl).asSubclass(AbstractInvokable.class).     } catch (ClassNotFoundException e) {         throw new RuntimeException("The user-code class could not be resolved.", e).     } catch (ClassCastException e) {         throw new RuntimeException("The user-code class is no subclass of " + AbstractInvokable.class.getName(), e).     } }
true;public;0;3;/**  * Gets the parallelism of the task.  *  * @return The parallelism of the task.  */ ;/**  * Gets the parallelism of the task.  *  * @return The parallelism of the task.  */ public int getParallelism() {     return parallelism. }
true;public;1;6;/**  * Sets the parallelism for the task.  *  * @param parallelism The parallelism for the task.  */ ;/**  * Sets the parallelism for the task.  *  * @param parallelism The parallelism for the task.  */ public void setParallelism(int parallelism) {     if (parallelism < 1) {         throw new IllegalArgumentException("The parallelism must be at least one.").     }     this.parallelism = parallelism. }
true;public;0;3;/**  * Gets the maximum parallelism for the task.  *  * @return The maximum parallelism for the task.  */ ;/**  * Gets the maximum parallelism for the task.  *  * @return The maximum parallelism for the task.  */ public int getMaxParallelism() {     return maxParallelism. }
true;public;1;3;/**  * Sets the maximum parallelism for the task.  *  * @param maxParallelism The maximum parallelism to be set. must be between 1 and Short.MAX_VALUE.  */ ;/**  * Sets the maximum parallelism for the task.  *  * @param maxParallelism The maximum parallelism to be set. must be between 1 and Short.MAX_VALUE.  */ public void setMaxParallelism(int maxParallelism) {     this.maxParallelism = maxParallelism. }
true;public;0;3;/**  * Gets the minimum resource for the task.  *  * @return The minimum resource for the task.  */ ;/**  * Gets the minimum resource for the task.  *  * @return The minimum resource for the task.  */ public ResourceSpec getMinResources() {     return minResources. }
true;public;0;3;/**  * Gets the preferred resource for the task.  *  * @return The preferred resource for the task.  */ ;/**  * Gets the preferred resource for the task.  *  * @return The preferred resource for the task.  */ public ResourceSpec getPreferredResources() {     return preferredResources. }
true;public;2;4;/**  * Sets the minimum and preferred resources for the task.  *  * @param minResources The minimum resource for the task.  * @param preferredResources The preferred resource for the task.  */ ;/**  * Sets the minimum and preferred resources for the task.  *  * @param minResources The minimum resource for the task.  * @param preferredResources The preferred resource for the task.  */ public void setResources(ResourceSpec minResources, ResourceSpec preferredResources) {     this.minResources = checkNotNull(minResources).     this.preferredResources = checkNotNull(preferredResources). }
false;public;0;3;;public InputSplitSource<?> getInputSplitSource() {     return inputSplitSource. }
false;public;1;3;;public void setInputSplitSource(InputSplitSource<?> inputSplitSource) {     this.inputSplitSource = inputSplitSource. }
false;public;0;3;;public List<IntermediateDataSet> getProducedDataSets() {     return this.results. }
false;public;0;3;;public List<JobEdge> getInputs() {     return this.inputs. }
true;public;1;10;/**  * Associates this vertex with a slot sharing group for scheduling. Different vertices in the same  * slot sharing group can run one subtask each in the same slot.  *  * @param grp The slot sharing group to associate the vertex with.  */ ;/**  * Associates this vertex with a slot sharing group for scheduling. Different vertices in the same  * slot sharing group can run one subtask each in the same slot.  *  * @param grp The slot sharing group to associate the vertex with.  */ public void setSlotSharingGroup(SlotSharingGroup grp) {     if (this.slotSharingGroup != null) {         this.slotSharingGroup.removeVertexFromGroup(id).     }     this.slotSharingGroup = grp.     if (grp != null) {         grp.addVertexToGroup(id).     } }
true;public;0;3;/**  * Gets the slot sharing group that this vertex is associated with. Different vertices in the same  * slot sharing group can run one subtask each in the same slot. If the vertex is not associated with  * a slot sharing group, this method returns {@code null}.  *  * @return The slot sharing group to associate the vertex with, or {@code null}, if not associated with one.  */ ;/**  * Gets the slot sharing group that this vertex is associated with. Different vertices in the same  * slot sharing group can run one subtask each in the same slot. If the vertex is not associated with  * a slot sharing group, this method returns {@code null}.  *  * @return The slot sharing group to associate the vertex with, or {@code null}, if not associated with one.  */ public SlotSharingGroup getSlotSharingGroup() {     return slotSharingGroup. }
true;public;1;30;/**  * Tells this vertex to strictly co locate its subtasks with the subtasks of the given vertex.  * Strict co-location implies that the n'th subtask of this vertex will run on the same parallel computing  * instance (TaskManager) as the n'th subtask of the given vertex.  *  * NOTE: Co-location is only possible between vertices in a slot sharing group.  *  * NOTE: This vertex must (transitively) depend on the vertex to be co-located with. That means that the  * respective vertex must be a (transitive) input of this vertex.  *  * @param strictlyCoLocatedWith The vertex whose subtasks to co-locate this vertex's subtasks with.  *  * @throws IllegalArgumentException Thrown, if this vertex and the vertex to co-locate with are not in a common  *                                  slot sharing group.  *  * @see #setSlotSharingGroup(SlotSharingGroup)  */ ;/**  * Tells this vertex to strictly co locate its subtasks with the subtasks of the given vertex.  * Strict co-location implies that the n'th subtask of this vertex will run on the same parallel computing  * instance (TaskManager) as the n'th subtask of the given vertex.  *  * NOTE: Co-location is only possible between vertices in a slot sharing group.  *  * NOTE: This vertex must (transitively) depend on the vertex to be co-located with. That means that the  * respective vertex must be a (transitive) input of this vertex.  *  * @param strictlyCoLocatedWith The vertex whose subtasks to co-locate this vertex's subtasks with.  *  * @throws IllegalArgumentException Thrown, if this vertex and the vertex to co-locate with are not in a common  *                                  slot sharing group.  *  * @see #setSlotSharingGroup(SlotSharingGroup)  */ public void setStrictlyCoLocatedWith(JobVertex strictlyCoLocatedWith) {     if (this.slotSharingGroup == null || this.slotSharingGroup != strictlyCoLocatedWith.slotSharingGroup) {         throw new IllegalArgumentException("Strict co-location requires that both vertices are in the same slot sharing group.").     }     CoLocationGroup thisGroup = this.coLocationGroup.     CoLocationGroup otherGroup = strictlyCoLocatedWith.coLocationGroup.     if (otherGroup == null) {         if (thisGroup == null) {             CoLocationGroup group = new CoLocationGroup(this, strictlyCoLocatedWith).             this.coLocationGroup = group.             strictlyCoLocatedWith.coLocationGroup = group.         } else {             thisGroup.addVertex(strictlyCoLocatedWith).             strictlyCoLocatedWith.coLocationGroup = thisGroup.         }     } else {         if (thisGroup == null) {             otherGroup.addVertex(this).             this.coLocationGroup = otherGroup.         } else {             // both had yet distinct groups, we need to merge them             thisGroup.mergeInto(otherGroup).         }     } }
false;public;0;3;;public CoLocationGroup getCoLocationGroup() {     return coLocationGroup. }
false;public;1;3;;public void updateCoLocationGroup(CoLocationGroup group) {     this.coLocationGroup = group. }
false;public;1;3;;// -------------------------------------------------------------------------------------------- public IntermediateDataSet createAndAddResultDataSet(ResultPartitionType partitionType) {     return createAndAddResultDataSet(new IntermediateDataSetID(), partitionType). }
false;public;2;8;;public IntermediateDataSet createAndAddResultDataSet(IntermediateDataSetID id, ResultPartitionType partitionType) {     IntermediateDataSet result = new IntermediateDataSet(id, partitionType, this).     this.results.add(result).     return result. }
false;public;2;6;;public JobEdge connectDataSetAsInput(IntermediateDataSet dataSet, DistributionPattern distPattern) {     JobEdge edge = new JobEdge(dataSet, this, distPattern).     this.inputs.add(edge).     dataSet.addConsumer(edge).     return edge. }
false;public;3;12;;public JobEdge connectNewDataSetAsInput(JobVertex input, DistributionPattern distPattern, ResultPartitionType partitionType) {     IntermediateDataSet dataSet = input.createAndAddResultDataSet(partitionType).     JobEdge edge = new JobEdge(dataSet, this, distPattern).     this.inputs.add(edge).     dataSet.addConsumer(edge).     return edge. }
false;public;2;4;;public void connectIdInput(IntermediateDataSetID dataSetId, DistributionPattern distPattern) {     JobEdge edge = new JobEdge(dataSetId, this, distPattern).     this.inputs.add(edge). }
false;public;0;3;;// -------------------------------------------------------------------------------------------- public boolean isInputVertex() {     return this.inputs.isEmpty(). }
false;public;0;3;;public boolean isStoppable() {     return this.isStoppable. }
false;public;0;3;;public boolean isOutputVertex() {     return this.results.isEmpty(). }
false;public;0;9;;public boolean hasNoConnectedInputs() {     for (JobEdge edge : inputs) {         if (!edge.isIdReference()) {             return false.         }     }     return true. }
true;public;1;1;/**  * A hook that can be overwritten by sub classes to implement logic that is called by the  * master when the job starts.  *  * @param loader The class loader for user defined code.  * @throws Exception The method may throw exceptions which cause the job to fail immediately.  */ ;// -------------------------------------------------------------------------------------------- /**  * A hook that can be overwritten by sub classes to implement logic that is called by the  * master when the job starts.  *  * @param loader The class loader for user defined code.  * @throws Exception The method may throw exceptions which cause the job to fail immediately.  */ public void initializeOnMaster(ClassLoader loader) throws Exception { }
true;public;1;1;/**  * A hook that can be overwritten by sub classes to implement logic that is called by the  * master after the job completed.  *  * @param loader The class loader for user defined code.  * @throws Exception The method may throw exceptions which cause the job to fail immediately.  */ ;/**  * A hook that can be overwritten by sub classes to implement logic that is called by the  * master after the job completed.  *  * @param loader The class loader for user defined code.  * @throws Exception The method may throw exceptions which cause the job to fail immediately.  */ public void finalizeOnMaster(ClassLoader loader) throws Exception { }
false;public;0;3;;// -------------------------------------------------------------------------------------------- public String getOperatorName() {     return operatorName. }
false;public;1;3;;public void setOperatorName(String operatorName) {     this.operatorName = operatorName. }
false;public;0;3;;public String getOperatorDescription() {     return operatorDescription. }
false;public;1;3;;public void setOperatorDescription(String operatorDescription) {     this.operatorDescription = operatorDescription. }
false;public;1;3;;public void setOperatorPrettyName(String operatorPrettyName) {     this.operatorPrettyName = operatorPrettyName. }
false;public;0;3;;public String getOperatorPrettyName() {     return operatorPrettyName. }
false;public;0;3;;public String getResultOptimizerProperties() {     return resultOptimizerProperties. }
false;public;1;3;;public void setResultOptimizerProperties(String resultOptimizerProperties) {     this.resultOptimizerProperties = resultOptimizerProperties. }
false;public;0;3;;public InputDependencyConstraint getInputDependencyConstraint() {     return inputDependencyConstraint. }
false;public;1;3;;public void setInputDependencyConstraint(InputDependencyConstraint inputDependencyConstraint) {     this.inputDependencyConstraint = inputDependencyConstraint. }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public String toString() {     return this.name + " (" + this.invokableClassName + ')'. }
