commented;modifiers;parameterAmount;loc;comment;code
true;;0;13;/**  * Iterates over all input channels and collects the total number of queued buffers in a  * best-effort way.  *  * @return total number of queued buffers  */ ;// ------------------------------------------------------------------------ // these methods are package private to make access from the nested classes faster /**  * Iterates over all input channels and collects the total number of queued buffers in a  * best-effort way.  *  * @return total number of queued buffers  */ long refreshAndGetTotal() {     long total = 0.     for (InputChannel channel : inputGate.getInputChannels().values()) {         if (channel instanceof RemoteInputChannel) {             RemoteInputChannel rc = (RemoteInputChannel) channel.             total += rc.unsynchronizedGetNumberOfQueuedBuffers().         }     }     return total. }
true;;0;19;/**  * Iterates over all input channels and collects the minimum number of queued buffers in a  * channel in a best-effort way.  *  * @return minimum number of queued buffers per channel (<tt>0</tt> if no channels exist)  */ ;/**  * Iterates over all input channels and collects the minimum number of queued buffers in a  * channel in a best-effort way.  *  * @return minimum number of queued buffers per channel (<tt>0</tt> if no channels exist)  */ int refreshAndGetMin() {     int min = Integer.MAX_VALUE.     Collection<InputChannel> channels = inputGate.getInputChannels().values().     for (InputChannel channel : channels) {         if (channel instanceof RemoteInputChannel) {             RemoteInputChannel rc = (RemoteInputChannel) channel.             int size = rc.unsynchronizedGetNumberOfQueuedBuffers().             min = Math.min(min, size).         }     }     if (min == Integer.MAX_VALUE) {         // in case all channels are local, or the channel collection was empty         return 0.     }     return min. }
true;;0;14;/**  * Iterates over all input channels and collects the maximum number of queued buffers in a  * channel in a best-effort way.  *  * @return maximum number of queued buffers per channel  */ ;/**  * Iterates over all input channels and collects the maximum number of queued buffers in a  * channel in a best-effort way.  *  * @return maximum number of queued buffers per channel  */ int refreshAndGetMax() {     int max = 0.     for (InputChannel channel : inputGate.getInputChannels().values()) {         if (channel instanceof RemoteInputChannel) {             RemoteInputChannel rc = (RemoteInputChannel) channel.             int size = rc.unsynchronizedGetNumberOfQueuedBuffers().             max = Math.max(max, size).         }     }     return max. }
true;;0;16;/**  * Iterates over all input channels and collects the average number of queued buffers in a  * channel in a best-effort way.  *  * @return average number of queued buffers per channel  */ ;/**  * Iterates over all input channels and collects the average number of queued buffers in a  * channel in a best-effort way.  *  * @return average number of queued buffers per channel  */ float refreshAndGetAvg() {     long total = 0.     int count = 0.     for (InputChannel channel : inputGate.getInputChannels().values()) {         if (channel instanceof RemoteInputChannel) {             RemoteInputChannel rc = (RemoteInputChannel) channel.             int size = rc.unsynchronizedGetNumberOfQueuedBuffers().             total += size.             ++count.         }     }     return count == 0 ? 0 : total / (float) count. }
false;public;0;4;;@Override public Long getValue() {     return refreshAndGetTotal(). }
false;private;0;8;;// ------------------------------------------------------------------------ // Gauges to access the stats // ------------------------------------------------------------------------ private Gauge<Long> getTotalQueueLenGauge() {     return new Gauge<Long>() {          @Override         public Long getValue() {             return refreshAndGetTotal().         }     }. }
false;public;0;4;;@Override public Integer getValue() {     return refreshAndGetMin(). }
false;private;0;8;;private Gauge<Integer> getMinQueueLenGauge() {     return new Gauge<Integer>() {          @Override         public Integer getValue() {             return refreshAndGetMin().         }     }. }
false;public;0;4;;@Override public Integer getValue() {     return refreshAndGetMax(). }
false;private;0;8;;private Gauge<Integer> getMaxQueueLenGauge() {     return new Gauge<Integer>() {          @Override         public Integer getValue() {             return refreshAndGetMax().         }     }. }
false;public;0;4;;@Override public Float getValue() {     return refreshAndGetAvg(). }
false;private;0;8;;private Gauge<Float> getAvgQueueLenGauge() {     return new Gauge<Float>() {          @Override         public Float getValue() {             return refreshAndGetAvg().         }     }. }
false;public,static;2;8;;// ------------------------------------------------------------------------ // Static access // ------------------------------------------------------------------------ public static void registerQueueLengthMetrics(MetricGroup group, SingleInputGate gate) {     InputGateMetrics metrics = new InputGateMetrics(gate).     group.gauge("totalQueueLen", metrics.getTotalQueueLenGauge()).     group.gauge("minQueueLen", metrics.getMinQueueLenGauge()).     group.gauge("maxQueueLen", metrics.getMaxQueueLenGauge()).     group.gauge("avgQueueLen", metrics.getAvgQueueLenGauge()). }
