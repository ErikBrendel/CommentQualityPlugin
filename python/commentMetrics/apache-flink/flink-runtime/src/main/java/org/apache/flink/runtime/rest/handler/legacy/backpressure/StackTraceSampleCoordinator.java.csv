commented;modifiers;parameterAmount;loc;comment;code
true;public;4;79;/**  * Triggers a stack trace sample to all tasks.  *  * @param tasksToSample       Tasks to sample.  * @param numSamples          Number of stack trace samples to collect.  * @param delayBetweenSamples Delay between consecutive samples.  * @param maxStackTraceDepth  Maximum depth of the stack trace. 0 indicates  *                            no maximum and keeps the complete stack trace.  * @return A future of the completed stack trace sample  */ ;/**  * Triggers a stack trace sample to all tasks.  *  * @param tasksToSample       Tasks to sample.  * @param numSamples          Number of stack trace samples to collect.  * @param delayBetweenSamples Delay between consecutive samples.  * @param maxStackTraceDepth  Maximum depth of the stack trace. 0 indicates  *                            no maximum and keeps the complete stack trace.  * @return A future of the completed stack trace sample  */ @SuppressWarnings("unchecked") public CompletableFuture<StackTraceSample> triggerStackTraceSample(ExecutionVertex[] tasksToSample, int numSamples, Time delayBetweenSamples, int maxStackTraceDepth) {     checkNotNull(tasksToSample, "Tasks to sample").     checkArgument(tasksToSample.length >= 1, "No tasks to sample").     checkArgument(numSamples >= 1, "No number of samples").     checkArgument(maxStackTraceDepth >= 0, "Negative maximum stack trace depth").     // Execution IDs of running tasks     ExecutionAttemptID[] triggerIds = new ExecutionAttemptID[tasksToSample.length].     Execution[] executions = new Execution[tasksToSample.length].     // triggering can still fail.     for (int i = 0. i < triggerIds.length. i++) {         Execution execution = tasksToSample[i].getCurrentExecutionAttempt().         if (execution != null && execution.getState() == ExecutionState.RUNNING) {             executions[i] = execution.             triggerIds[i] = execution.getAttemptId().         } else {             return FutureUtils.completedExceptionally(new IllegalStateException("Task " + tasksToSample[i].getTaskNameWithSubtaskIndex() + " is not running.")).         }     }     synchronized (lock) {         if (isShutDown) {             return FutureUtils.completedExceptionally(new IllegalStateException("Shut down")).         }         final int sampleId = sampleIdCounter++.         LOG.debug("Triggering stack trace sample {}", sampleId).         final PendingStackTraceSample pending = new PendingStackTraceSample(sampleId, triggerIds).         // Discard the sample if it takes too long. We don't send cancel         // messages to the task managers, but only wait for the responses         // and then ignore them.         long expectedDuration = numSamples * delayBetweenSamples.toMilliseconds().         Time timeout = Time.milliseconds(expectedDuration + sampleTimeout).         // Add the pending sample before scheduling the discard task to         // prevent races with removing it again.         pendingSamples.put(sampleId, pending).         // Trigger all samples         for (Execution execution : executions) {             final CompletableFuture<StackTraceSampleResponse> stackTraceSampleFuture = execution.requestStackTraceSample(sampleId, numSamples, delayBetweenSamples, maxStackTraceDepth, timeout).             stackTraceSampleFuture.handleAsync((StackTraceSampleResponse stackTraceSampleResponse, Throwable throwable) -> {                 if (stackTraceSampleResponse != null) {                     collectStackTraces(stackTraceSampleResponse.getSampleId(), stackTraceSampleResponse.getExecutionAttemptID(), stackTraceSampleResponse.getSamples()).                 } else {                     cancelStackTraceSample(sampleId, throwable).                 }                 return null.             }, executor).         }         return pending.getStackTraceSampleFuture().     } }
true;public;2;19;/**  * Cancels a pending sample.  *  * @param sampleId ID of the sample to cancel.  * @param cause Cause of the cancelling (can be <code>null</code>).  */ ;/**  * Cancels a pending sample.  *  * @param sampleId ID of the sample to cancel.  * @param cause Cause of the cancelling (can be <code>null</code>).  */ public void cancelStackTraceSample(int sampleId, Throwable cause) {     synchronized (lock) {         if (isShutDown) {             return.         }         PendingStackTraceSample sample = pendingSamples.remove(sampleId).         if (sample != null) {             if (cause != null) {                 LOG.info("Cancelling sample " + sampleId, cause).             } else {                 LOG.info("Cancelling sample {}", sampleId).             }             sample.discard(cause).             rememberRecentSampleId(sampleId).         }     } }
true;public;0;15;/**  * Shuts down the coordinator.  *  * <p>After shut down, no further operations are executed.  */ ;/**  * Shuts down the coordinator.  *  * <p>After shut down, no further operations are executed.  */ public void shutDown() {     synchronized (lock) {         if (!isShutDown) {             LOG.info("Shutting down stack trace sample coordinator.").             for (PendingStackTraceSample pending : pendingSamples.values()) {                 pending.discard(new RuntimeException("Shut down")).             }             pendingSamples.clear().             isShutDown = true.         }     } }
true;public;3;38;/**  * Collects stack traces of a task.  *  * @param sampleId    ID of the sample.  * @param executionId ID of the sampled task.  * @param stackTraces Stack traces of the sampled task.  *  * @throws IllegalStateException If unknown sample ID and not recently  *                               finished or cancelled sample.  */ ;/**  * Collects stack traces of a task.  *  * @param sampleId    ID of the sample.  * @param executionId ID of the sampled task.  * @param stackTraces Stack traces of the sampled task.  *  * @throws IllegalStateException If unknown sample ID and not recently  *                               finished or cancelled sample.  */ public void collectStackTraces(int sampleId, ExecutionAttemptID executionId, List<StackTraceElement[]> stackTraces) {     synchronized (lock) {         if (isShutDown) {             return.         }         if (LOG.isDebugEnabled()) {             LOG.debug("Collecting stack trace sample {} of task {}", sampleId, executionId).         }         PendingStackTraceSample pending = pendingSamples.get(sampleId).         if (pending != null) {             pending.collectStackTraces(executionId, stackTraces).             // Publish the sample             if (pending.isComplete()) {                 pendingSamples.remove(sampleId).                 rememberRecentSampleId(sampleId).                 pending.completePromiseAndDiscard().             }         } else if (recentPendingSamples.contains(sampleId)) {             if (LOG.isDebugEnabled()) {                 LOG.debug("Received late stack trace sample {} of task {}", sampleId, executionId).             }         } else {             if (LOG.isDebugEnabled()) {                 LOG.debug("Unknown sample ID " + sampleId).             }         }     } }
false;private;1;6;;private void rememberRecentSampleId(int sampleId) {     if (recentPendingSamples.size() >= NUM_GHOST_SAMPLE_IDS) {         recentPendingSamples.removeFirst().     }     recentPendingSamples.addLast(sampleId). }
false;;0;5;;int getNumberOfPendingSamples() {     synchronized (lock) {         return pendingSamples.size().     } }
false;;0;3;;int getSampleId() {     return sampleId. }
false;;0;3;;long getStartTime() {     return startTime. }
false;;0;3;;boolean isDiscarded() {     return isDiscarded. }
false;;0;7;;boolean isComplete() {     if (isDiscarded) {         throw new IllegalStateException("Discarded").     }     return pendingTasks.isEmpty(). }
false;;1;10;;void discard(Throwable cause) {     if (!isDiscarded) {         pendingTasks.clear().         stackTracesByTask.clear().         stackTraceFuture.completeExceptionally(new RuntimeException("Discarded", cause)).         isDiscarded = true.     } }
false;;2;13;;void collectStackTraces(ExecutionAttemptID executionId, List<StackTraceElement[]> stackTraces) {     if (isDiscarded) {         throw new IllegalStateException("Discarded").     }     if (pendingTasks.remove(executionId)) {         stackTracesByTask.put(executionId, Collections.unmodifiableList(stackTraces)).     } else if (isComplete()) {         throw new IllegalStateException("Completed").     } else {         throw new IllegalArgumentException("Unknown task " + executionId).     } }
false;;0;17;;void completePromiseAndDiscard() {     if (isComplete()) {         isDiscarded = true.         long endTime = System.currentTimeMillis().         StackTraceSample stackTraceSample = new StackTraceSample(sampleId, startTime, endTime, stackTracesByTask).         stackTraceFuture.complete(stackTraceSample).     } else {         throw new IllegalStateException("Not completed yet").     } }
false;;0;4;;@SuppressWarnings("unchecked") CompletableFuture<StackTraceSample> getStackTraceSampleFuture() {     return stackTraceFuture. }
