commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;// ------------------------------------------------------------------------ @Override public void setup(TaskContext<ReduceFunction<T>, T> context) {     this.taskContext = context.     this.running = true. }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 1. }
false;public;0;6;;@Override public Class<ReduceFunction<T>> getStubType() {     @SuppressWarnings("unchecked")     final Class<ReduceFunction<T>> clazz = (Class<ReduceFunction<T>>) (Class<?>) ReduceFunction.class.     return clazz. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 1. }
false;public;0;17;;// -------------------------------------------------------------------------------------------- @Override public void prepare() throws Exception {     TaskConfig config = this.taskContext.getTaskConfig().     if (config.getDriverStrategy() != DriverStrategy.SORTED_REDUCE) {         throw new Exception("Unrecognized driver strategy for Reduce driver: " + config.getDriverStrategy().name()).     }     this.serializer = this.taskContext.<T>getInputSerializer(0).getSerializer().     this.comparator = this.taskContext.getDriverComparator(0).     this.input = this.taskContext.getInput(0).     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     this.objectReuseEnabled = executionConfig.isObjectReuseEnabled().     if (LOG.isDebugEnabled()) {         LOG.debug("ReduceDriver object reuse: " + (this.objectReuseEnabled ? "ENABLED" : "DISABLED") + ".").     } }
false;public;0;88;;@Override public void run() throws Exception {     if (LOG.isDebugEnabled()) {         LOG.debug(this.taskContext.formatLogString("Reducer preprocessing done. Running Reducer code.")).     }     final Counter numRecordsIn = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsInCounter().     final Counter numRecordsOut = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsOutCounter().     // cache references on the stack     final MutableObjectIterator<T> input = this.input.     final TypeSerializer<T> serializer = this.serializer.     final TypeComparator<T> comparator = this.comparator.     final ReduceFunction<T> function = this.taskContext.getStub().     final Collector<T> output = new CountingCollector<>(this.taskContext.getOutputCollector(), numRecordsOut).     if (objectReuseEnabled) {         // We only need two objects. The first reference stores results and is         // eventually collected. New values are read into the second.         //          // The output value must have the same key fields as the input values.         T reuse1 = input.next().         T reuse2 = serializer.createInstance().         T value = reuse1.         // iterate over key groups         while (this.running && value != null) {             numRecordsIn.inc().             comparator.setReference(value).             // iterate within a key group             while ((reuse2 = input.next(reuse2)) != null) {                 numRecordsIn.inc().                 if (comparator.equalToReference(reuse2)) {                     // same group, reduce                     value = function.reduce(value, reuse2).                     // by the user, so swap the reuse objects                     if (value == reuse2) {                         T tmp = reuse1.                         reuse1 = reuse2.                         reuse2 = tmp.                     }                 } else {                     // new key group                     break.                 }             }             output.collect(value).             // swap the value from the new key group into the first object             T tmp = reuse1.             reuse1 = reuse2.             reuse2 = tmp.             value = reuse1.         }     } else {         T value = input.next().         // iterate over key groups         while (this.running && value != null) {             numRecordsIn.inc().             comparator.setReference(value).             T res = value.             // iterate within a key group             while ((value = input.next()) != null) {                 numRecordsIn.inc().                 if (comparator.equalToReference(value)) {                     // same group, reduce                     res = function.reduce(res, value).                 } else {                     // new key group                     break.                 }             }             output.collect(res).         }     } }
false;public;0;2;;@Override public void cleanup() { }
false;public;0;4;;@Override public void cancel() {     this.running = false. }
