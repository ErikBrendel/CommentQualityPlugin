commented;modifiers;parameterAmount;loc;comment;code
false;;0;6;;int getInitialPartitionBuffersCount() {     if (initialPartitionBuffersCount == -1) {         throw new RuntimeException("Hash Join: Bug: This partition is most likely a spilled partition that is not restorable").     }     return initialPartitionBuffersCount. }
false;public;3;33;;@Override public int finalizeProbePhase(List<MemorySegment> freeMemory, List<HashPartition<BT, PT>> spilledPartitions, boolean keepUnprobedSpilledPartitions) throws IOException {     if (furtherPartitioning || recursionLevel != 0 || isRestored) {         if (isInMemory() && initialBuildSideChannel != null && !isRestored) {             // return the overflow segments             for (int k = 0. k < this.numOverflowSegments. k++) {                 freeMemory.add(this.overflowSegments[k]).             }             this.overflowSegments = null.             this.numOverflowSegments = 0.             this.nextOverflowBucket = 0.             // we already returned the partitionBuffers via the returnQueue.             return 0.         }         return super.finalizeProbePhase(freeMemory, spilledPartitions, keepUnprobedSpilledPartitions).     }     if (isInMemory()) {         return 0.     } else if (this.probeSideRecordCounter == 0 && !keepUnprobedSpilledPartitions) {         freeMemory.add(this.probeSideBuffer.getCurrentSegment()).         // delete the spill files         this.probeSideChannel.close().         this.probeSideChannel.deleteChannel().         return 0.     } else {         this.probeSideBuffer.close().         // finish pending write requests.         this.probeSideChannel.close().         spilledPartitions.add(this).         return 1.     } }
true;;3;16;/**  * Spills this partition to disk. This method is invoked once after the initial open() method  *  * @return Number of memorySegments in the writeBehindBuffers!  */ ;/**  * Spills this partition to disk. This method is invoked once after the initial open() method  *  * @return Number of memorySegments in the writeBehindBuffers!  */ int spillInMemoryPartition(FileIOChannel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException {     // for ReOpenableHashMap     this.initialPartitionBuffersCount = partitionBuffers.length.     this.initialBuildSideChannel = targetChannel.     initialBuildSideWriter = ioManager.createBlockChannelWriter(targetChannel, writeBehindBuffers).     final int numSegments = this.partitionBuffers.length.     for (int i = 0. i < numSegments. i++) {         initialBuildSideWriter.writeBlock(partitionBuffers[i]).     }     this.partitionBuffers = null.     initialBuildSideWriter.close().     // num partitions are now in the writeBehindBuffers. We propagate this information back     return numSegments. }
true;;2;12;/**  * This method is called every time a multi-match hash map is opened again for a new probe input.  * @param ioManager  * @param availableMemory  * @throws IOException  */ ;/**  * This method is called every time a multi-match hash map is opened again for a new probe input.  * @param ioManager  * @param availableMemory  * @throws IOException  */ void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException {     final BulkBlockChannelReader reader = ioManager.createBulkBlockChannelReader(this.initialBuildSideChannel, availableMemory, this.initialPartitionBuffersCount).     reader.close().     final List<MemorySegment> partitionBuffersFromDisk = reader.getFullSegments().     this.partitionBuffers = (MemorySegment[]) partitionBuffersFromDisk.toArray(new MemorySegment[partitionBuffersFromDisk.size()]).     this.overflowSegments = new MemorySegment[2].     this.numOverflowSegments = 0.     this.nextOverflowBucket = 0.     this.isRestored = true. }
false;public;1;11;;@Override public void clearAllMemory(List<MemorySegment> target) {     if (initialBuildSideChannel != null) {         try {             this.initialBuildSideWriter.closeAndDelete().         } catch (IOException ioex) {             throw new RuntimeException("Error deleting the partition files. Some temporary files might not be removed.").         }     }     super.clearAllMemory(target). }
