# id;timestamp;commentText;codeText;commentWords;codeWords
ReOpenableHashPartition -> @Override 	public int finalizeProbePhase(List<MemorySegment> freeMemory, 			List<HashPartition<BT, PT>> spilledPartitions) throws IOException;1405024514;This method is used if the HashTable is setup for multiple probe phases._We can drop probe related files but not build files (or memory)_@param furtherPartitioning Set to true if additional partitioning steps are required -> release as much memory as possible! (Memory contents are stored on disk)_@throws IOException;@Override_	public int finalizeProbePhase(List<MemorySegment> freeMemory,_			List<HashPartition<BT, PT>> spilledPartitions) throws IOException {_		if ( furtherPartitioning || recursionLevel != 0 || isRestored) {_			if (isInMemory() && initialBuildSideChannel != null && !isRestored) {_				_				for (int k = 0_ k < this.numOverflowSegments_ k++) {_					freeMemory.add(this.overflowSegments[k])__				}_				this.overflowSegments = null__				this.numOverflowSegments = 0__				this.nextOverflowBucket = 0__				_				return 0_ _			}_			return super.finalizeProbePhase(freeMemory, spilledPartitions)__		}_		if (!isInMemory() && this.probeSideRecordCounter == 0) { _			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			this.probeSideChannel.close()__			this.probeSideChannel.deleteChannel()__			return 0__		}_		if (isInMemory()) {_			return 0__		}_		this.probeSideBuffer.close()__		this.probeSideChannel.close()_ _		spilledPartitions.add(this)__		return 1__	};this,method,is,used,if,the,hash,table,is,setup,for,multiple,probe,phases,we,can,drop,probe,related,files,but,not,build,files,or,memory,param,further,partitioning,set,to,true,if,additional,partitioning,steps,are,required,release,as,much,memory,as,possible,memory,contents,are,stored,on,disk,throws,ioexception;override,public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,further,partitioning,recursion,level,0,is,restored,if,is,in,memory,initial,build,side,channel,null,is,restored,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,return,0,return,super,finalize,probe,phase,free,memory,spilled,partitions,if,is,in,memory,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,probe,side,channel,delete,channel,return,0,if,is,in,memory,return,0,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
ReOpenableHashPartition -> @Override 	public int finalizeProbePhase(List<MemorySegment> freeMemory, 			List<HashPartition<BT, PT>> spilledPartitions) throws IOException;1405090423;This method is used if the HashTable is setup for multiple probe phases._We can drop probe related files but not build files (or memory)_@param furtherPartitioning Set to true if additional partitioning steps are required -> release as much memory as possible! (Memory contents are stored on disk)_@throws IOException;@Override_	public int finalizeProbePhase(List<MemorySegment> freeMemory,_			List<HashPartition<BT, PT>> spilledPartitions) throws IOException {_		if ( furtherPartitioning || recursionLevel != 0 || isRestored) {_			if (isInMemory() && initialBuildSideChannel != null && !isRestored) {_				_				for (int k = 0_ k < this.numOverflowSegments_ k++) {_					freeMemory.add(this.overflowSegments[k])__				}_				this.overflowSegments = null__				this.numOverflowSegments = 0__				this.nextOverflowBucket = 0__				_				return 0_ _			}_			return super.finalizeProbePhase(freeMemory, spilledPartitions)__		}_		if (!isInMemory() && this.probeSideRecordCounter == 0) { _			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			this.probeSideChannel.close()__			this.probeSideChannel.deleteChannel()__			return 0__		}_		if (isInMemory()) {_			return 0__		}_		this.probeSideBuffer.close()__		this.probeSideChannel.close()_ _		spilledPartitions.add(this)__		return 1__	};this,method,is,used,if,the,hash,table,is,setup,for,multiple,probe,phases,we,can,drop,probe,related,files,but,not,build,files,or,memory,param,further,partitioning,set,to,true,if,additional,partitioning,steps,are,required,release,as,much,memory,as,possible,memory,contents,are,stored,on,disk,throws,ioexception;override,public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,further,partitioning,recursion,level,0,is,restored,if,is,in,memory,initial,build,side,channel,null,is,restored,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,return,0,return,super,finalize,probe,phase,free,memory,spilled,partitions,if,is,in,memory,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,probe,side,channel,delete,channel,return,0,if,is,in,memory,return,0,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
ReOpenableHashPartition -> @Override 	public int finalizeProbePhase(List<MemorySegment> freeMemory, 			List<HashPartition<BT, PT>> spilledPartitions) throws IOException;1411473593;This method is used if the HashTable is setup for multiple probe phases._We can drop probe related files but not build files (or memory)_@param furtherPartitioning Set to true if additional partitioning steps are required -> release as much memory as possible! (Memory contents are stored on disk)_@throws IOException;@Override_	public int finalizeProbePhase(List<MemorySegment> freeMemory,_			List<HashPartition<BT, PT>> spilledPartitions) throws IOException {_		if ( furtherPartitioning || recursionLevel != 0 || isRestored) {_			if (isInMemory() && initialBuildSideChannel != null && !isRestored) {_				_				for (int k = 0_ k < this.numOverflowSegments_ k++) {_					freeMemory.add(this.overflowSegments[k])__				}_				this.overflowSegments = null__				this.numOverflowSegments = 0__				this.nextOverflowBucket = 0__				_				return 0_ _			}_			return super.finalizeProbePhase(freeMemory, spilledPartitions)__		}_		if (!isInMemory() && this.probeSideRecordCounter == 0) { _			freeMemory.add(this.probeSideBuffer.getCurrentSegment())__			_			this.probeSideChannel.close()__			this.probeSideChannel.deleteChannel()__			return 0__		}_		if (isInMemory()) {_			return 0__		}_		this.probeSideBuffer.close()__		this.probeSideChannel.close()_ _		spilledPartitions.add(this)__		return 1__	};this,method,is,used,if,the,hash,table,is,setup,for,multiple,probe,phases,we,can,drop,probe,related,files,but,not,build,files,or,memory,param,further,partitioning,set,to,true,if,additional,partitioning,steps,are,required,release,as,much,memory,as,possible,memory,contents,are,stored,on,disk,throws,ioexception;override,public,int,finalize,probe,phase,list,memory,segment,free,memory,list,hash,partition,bt,pt,spilled,partitions,throws,ioexception,if,further,partitioning,recursion,level,0,is,restored,if,is,in,memory,initial,build,side,channel,null,is,restored,for,int,k,0,k,this,num,overflow,segments,k,free,memory,add,this,overflow,segments,k,this,overflow,segments,null,this,num,overflow,segments,0,this,next,overflow,bucket,0,return,0,return,super,finalize,probe,phase,free,memory,spilled,partitions,if,is,in,memory,this,probe,side,record,counter,0,free,memory,add,this,probe,side,buffer,get,current,segment,this,probe,side,channel,close,this,probe,side,channel,delete,channel,return,0,if,is,in,memory,return,0,this,probe,side,buffer,close,this,probe,side,channel,close,spilled,partitions,add,this,return,1
ReOpenableHashPartition -> int spillInMemoryPartition(FileIOChannel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException;1415702894;Spills this partition to disk. This method is invoked once after the initial open() method__@return Number of memorySegments in the writeBehindBuffers!;int spillInMemoryPartition(FileIOChannel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException {_		this.initialPartitionBuffersCount = partitionBuffers.length_ _		this.initialBuildSideChannel = targetChannel__		_		initialBuildSideWriter = ioManager.createBlockChannelWriter(targetChannel, writeBehindBuffers)__		_		final int numSegments = this.partitionBuffers.length__		for (int i = 0_ i < numSegments_ i++) {_			initialBuildSideWriter.writeBlock(partitionBuffers[i])__		}_		this.partitionBuffers = null__		initialBuildSideWriter.close()__		_		return numSegments__		_	};spills,this,partition,to,disk,this,method,is,invoked,once,after,the,initial,open,method,return,number,of,memory,segments,in,the,write,behind,buffers;int,spill,in,memory,partition,file,iochannel,id,target,channel,iomanager,io,manager,linked,blocking,queue,memory,segment,write,behind,buffers,throws,ioexception,this,initial,partition,buffers,count,partition,buffers,length,this,initial,build,side,channel,target,channel,initial,build,side,writer,io,manager,create,block,channel,writer,target,channel,write,behind,buffers,final,int,num,segments,this,partition,buffers,length,for,int,i,0,i,num,segments,i,initial,build,side,writer,write,block,partition,buffers,i,this,partition,buffers,null,initial,build,side,writer,close,return,num,segments
ReOpenableHashPartition -> int spillInMemoryPartition(FileIOChannel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException;1426697080;Spills this partition to disk. This method is invoked once after the initial open() method__@return Number of memorySegments in the writeBehindBuffers!;int spillInMemoryPartition(FileIOChannel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException {_		this.initialPartitionBuffersCount = partitionBuffers.length_ _		this.initialBuildSideChannel = targetChannel__		_		initialBuildSideWriter = ioManager.createBlockChannelWriter(targetChannel, writeBehindBuffers)__		_		final int numSegments = this.partitionBuffers.length__		for (int i = 0_ i < numSegments_ i++) {_			initialBuildSideWriter.writeBlock(partitionBuffers[i])__		}_		this.partitionBuffers = null__		initialBuildSideWriter.close()__		_		return numSegments__		_	};spills,this,partition,to,disk,this,method,is,invoked,once,after,the,initial,open,method,return,number,of,memory,segments,in,the,write,behind,buffers;int,spill,in,memory,partition,file,iochannel,id,target,channel,iomanager,io,manager,linked,blocking,queue,memory,segment,write,behind,buffers,throws,ioexception,this,initial,partition,buffers,count,partition,buffers,length,this,initial,build,side,channel,target,channel,initial,build,side,writer,io,manager,create,block,channel,writer,target,channel,write,behind,buffers,final,int,num,segments,this,partition,buffers,length,for,int,i,0,i,num,segments,i,initial,build,side,writer,write,block,partition,buffers,i,this,partition,buffers,null,initial,build,side,writer,close,return,num,segments
ReOpenableHashPartition -> int spillInMemoryPartition(FileIOChannel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException;1456186722;Spills this partition to disk. This method is invoked once after the initial open() method__@return Number of memorySegments in the writeBehindBuffers!;int spillInMemoryPartition(FileIOChannel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException {_		this.initialPartitionBuffersCount = partitionBuffers.length_ _		this.initialBuildSideChannel = targetChannel__		_		initialBuildSideWriter = ioManager.createBlockChannelWriter(targetChannel, writeBehindBuffers)__		_		final int numSegments = this.partitionBuffers.length__		for (int i = 0_ i < numSegments_ i++) {_			initialBuildSideWriter.writeBlock(partitionBuffers[i])__		}_		this.partitionBuffers = null__		initialBuildSideWriter.close()__		_		return numSegments__		_	};spills,this,partition,to,disk,this,method,is,invoked,once,after,the,initial,open,method,return,number,of,memory,segments,in,the,write,behind,buffers;int,spill,in,memory,partition,file,iochannel,id,target,channel,iomanager,io,manager,linked,blocking,queue,memory,segment,write,behind,buffers,throws,ioexception,this,initial,partition,buffers,count,partition,buffers,length,this,initial,build,side,channel,target,channel,initial,build,side,writer,io,manager,create,block,channel,writer,target,channel,write,behind,buffers,final,int,num,segments,this,partition,buffers,length,for,int,i,0,i,num,segments,i,initial,build,side,writer,write,block,partition,buffers,i,this,partition,buffers,null,initial,build,side,writer,close,return,num,segments
ReOpenableHashPartition -> int spillInMemoryPartition(Channel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException;1405024514;Spills this partition to disk. This method is invoked once after the initial open() method__@return Number of memorySegments in the writeBehindBuffers!;int spillInMemoryPartition(Channel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException {_		this.initialPartitionBuffersCount = partitionBuffers.length_ _		this.initialBuildSideChannel = targetChannel__		_		initialBuildSideWriter = ioManager.createBlockChannelWriter(targetChannel, writeBehindBuffers)__		_		final int numSegments = this.partitionBuffers.length__		for (int i = 0_ i < numSegments_ i++) {_			initialBuildSideWriter.writeBlock(partitionBuffers[i])__		}_		this.partitionBuffers = null__		initialBuildSideWriter.close()__		_		return numSegments__		_	};spills,this,partition,to,disk,this,method,is,invoked,once,after,the,initial,open,method,return,number,of,memory,segments,in,the,write,behind,buffers;int,spill,in,memory,partition,channel,id,target,channel,iomanager,io,manager,linked,blocking,queue,memory,segment,write,behind,buffers,throws,ioexception,this,initial,partition,buffers,count,partition,buffers,length,this,initial,build,side,channel,target,channel,initial,build,side,writer,io,manager,create,block,channel,writer,target,channel,write,behind,buffers,final,int,num,segments,this,partition,buffers,length,for,int,i,0,i,num,segments,i,initial,build,side,writer,write,block,partition,buffers,i,this,partition,buffers,null,initial,build,side,writer,close,return,num,segments
ReOpenableHashPartition -> int spillInMemoryPartition(Channel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException;1405090423;Spills this partition to disk. This method is invoked once after the initial open() method__@return Number of memorySegments in the writeBehindBuffers!;int spillInMemoryPartition(Channel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException {_		this.initialPartitionBuffersCount = partitionBuffers.length_ _		this.initialBuildSideChannel = targetChannel__		_		initialBuildSideWriter = ioManager.createBlockChannelWriter(targetChannel, writeBehindBuffers)__		_		final int numSegments = this.partitionBuffers.length__		for (int i = 0_ i < numSegments_ i++) {_			initialBuildSideWriter.writeBlock(partitionBuffers[i])__		}_		this.partitionBuffers = null__		initialBuildSideWriter.close()__		_		return numSegments__		_	};spills,this,partition,to,disk,this,method,is,invoked,once,after,the,initial,open,method,return,number,of,memory,segments,in,the,write,behind,buffers;int,spill,in,memory,partition,channel,id,target,channel,iomanager,io,manager,linked,blocking,queue,memory,segment,write,behind,buffers,throws,ioexception,this,initial,partition,buffers,count,partition,buffers,length,this,initial,build,side,channel,target,channel,initial,build,side,writer,io,manager,create,block,channel,writer,target,channel,write,behind,buffers,final,int,num,segments,this,partition,buffers,length,for,int,i,0,i,num,segments,i,initial,build,side,writer,write,block,partition,buffers,i,this,partition,buffers,null,initial,build,side,writer,close,return,num,segments
ReOpenableHashPartition -> int spillInMemoryPartition(Channel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException;1411473593;Spills this partition to disk. This method is invoked once after the initial open() method__@return Number of memorySegments in the writeBehindBuffers!;int spillInMemoryPartition(Channel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException {_		this.initialPartitionBuffersCount = partitionBuffers.length_ _		this.initialBuildSideChannel = targetChannel__		_		initialBuildSideWriter = ioManager.createBlockChannelWriter(targetChannel, writeBehindBuffers)__		_		final int numSegments = this.partitionBuffers.length__		for (int i = 0_ i < numSegments_ i++) {_			initialBuildSideWriter.writeBlock(partitionBuffers[i])__		}_		this.partitionBuffers = null__		initialBuildSideWriter.close()__		_		return numSegments__		_	};spills,this,partition,to,disk,this,method,is,invoked,once,after,the,initial,open,method,return,number,of,memory,segments,in,the,write,behind,buffers;int,spill,in,memory,partition,channel,id,target,channel,iomanager,io,manager,linked,blocking,queue,memory,segment,write,behind,buffers,throws,ioexception,this,initial,partition,buffers,count,partition,buffers,length,this,initial,build,side,channel,target,channel,initial,build,side,writer,io,manager,create,block,channel,writer,target,channel,write,behind,buffers,final,int,num,segments,this,partition,buffers,length,for,int,i,0,i,num,segments,i,initial,build,side,writer,write,block,partition,buffers,i,this,partition,buffers,null,initial,build,side,writer,close,return,num,segments
ReOpenableHashPartition -> int spillInMemoryPartition(Channel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException;1412164980;Spills this partition to disk. This method is invoked once after the initial open() method__@return Number of memorySegments in the writeBehindBuffers!;int spillInMemoryPartition(Channel.ID targetChannel, IOManager ioManager, LinkedBlockingQueue<MemorySegment> writeBehindBuffers) throws IOException {_		this.initialPartitionBuffersCount = partitionBuffers.length_ _		this.initialBuildSideChannel = targetChannel__		_		initialBuildSideWriter = ioManager.createBlockChannelWriter(targetChannel, writeBehindBuffers)__		_		final int numSegments = this.partitionBuffers.length__		for (int i = 0_ i < numSegments_ i++) {_			initialBuildSideWriter.writeBlock(partitionBuffers[i])__		}_		this.partitionBuffers = null__		initialBuildSideWriter.close()__		_		return numSegments__		_	};spills,this,partition,to,disk,this,method,is,invoked,once,after,the,initial,open,method,return,number,of,memory,segments,in,the,write,behind,buffers;int,spill,in,memory,partition,channel,id,target,channel,iomanager,io,manager,linked,blocking,queue,memory,segment,write,behind,buffers,throws,ioexception,this,initial,partition,buffers,count,partition,buffers,length,this,initial,build,side,channel,target,channel,initial,build,side,writer,io,manager,create,block,channel,writer,target,channel,write,behind,buffers,final,int,num,segments,this,partition,buffers,length,for,int,i,0,i,num,segments,i,initial,build,side,writer,write,block,partition,buffers,i,this,partition,buffers,null,initial,build,side,writer,close,return,num,segments
ReOpenableHashPartition -> void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException;1405024514;This method is called every time a multi-match hash map is opened again for a new probe input._@param ioManager_@param availableMemory_@throws IOException;void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException {_		final BulkBlockChannelReader reader = ioManager.createBulkBlockChannelReader(this.initialBuildSideChannel, _			availableMemory, this.initialPartitionBuffersCount)__		reader.close()__		final List<MemorySegment> partitionBuffersFromDisk = reader.getFullSegments()__		this.partitionBuffers = (MemorySegment[]) partitionBuffersFromDisk.toArray(new MemorySegment[partitionBuffersFromDisk.size()])__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		this.isRestored = true__	};this,method,is,called,every,time,a,multi,match,hash,map,is,opened,again,for,a,new,probe,input,param,io,manager,param,available,memory,throws,ioexception;void,restore,partition,buffers,iomanager,io,manager,list,memory,segment,available,memory,throws,ioexception,final,bulk,block,channel,reader,reader,io,manager,create,bulk,block,channel,reader,this,initial,build,side,channel,available,memory,this,initial,partition,buffers,count,reader,close,final,list,memory,segment,partition,buffers,from,disk,reader,get,full,segments,this,partition,buffers,memory,segment,partition,buffers,from,disk,to,array,new,memory,segment,partition,buffers,from,disk,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,is,restored,true
ReOpenableHashPartition -> void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException;1405090423;This method is called every time a multi-match hash map is opened again for a new probe input._@param ioManager_@param availableMemory_@throws IOException;void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException {_		final BulkBlockChannelReader reader = ioManager.createBulkBlockChannelReader(this.initialBuildSideChannel, _			availableMemory, this.initialPartitionBuffersCount)__		reader.close()__		final List<MemorySegment> partitionBuffersFromDisk = reader.getFullSegments()__		this.partitionBuffers = (MemorySegment[]) partitionBuffersFromDisk.toArray(new MemorySegment[partitionBuffersFromDisk.size()])__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		this.isRestored = true__	};this,method,is,called,every,time,a,multi,match,hash,map,is,opened,again,for,a,new,probe,input,param,io,manager,param,available,memory,throws,ioexception;void,restore,partition,buffers,iomanager,io,manager,list,memory,segment,available,memory,throws,ioexception,final,bulk,block,channel,reader,reader,io,manager,create,bulk,block,channel,reader,this,initial,build,side,channel,available,memory,this,initial,partition,buffers,count,reader,close,final,list,memory,segment,partition,buffers,from,disk,reader,get,full,segments,this,partition,buffers,memory,segment,partition,buffers,from,disk,to,array,new,memory,segment,partition,buffers,from,disk,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,is,restored,true
ReOpenableHashPartition -> void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException;1411473593;This method is called every time a multi-match hash map is opened again for a new probe input._@param ioManager_@param availableMemory_@throws IOException;void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException {_		final BulkBlockChannelReader reader = ioManager.createBulkBlockChannelReader(this.initialBuildSideChannel, _			availableMemory, this.initialPartitionBuffersCount)__		reader.close()__		final List<MemorySegment> partitionBuffersFromDisk = reader.getFullSegments()__		this.partitionBuffers = (MemorySegment[]) partitionBuffersFromDisk.toArray(new MemorySegment[partitionBuffersFromDisk.size()])__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		this.isRestored = true__	};this,method,is,called,every,time,a,multi,match,hash,map,is,opened,again,for,a,new,probe,input,param,io,manager,param,available,memory,throws,ioexception;void,restore,partition,buffers,iomanager,io,manager,list,memory,segment,available,memory,throws,ioexception,final,bulk,block,channel,reader,reader,io,manager,create,bulk,block,channel,reader,this,initial,build,side,channel,available,memory,this,initial,partition,buffers,count,reader,close,final,list,memory,segment,partition,buffers,from,disk,reader,get,full,segments,this,partition,buffers,memory,segment,partition,buffers,from,disk,to,array,new,memory,segment,partition,buffers,from,disk,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,is,restored,true
ReOpenableHashPartition -> void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException;1412164980;This method is called every time a multi-match hash map is opened again for a new probe input._@param ioManager_@param availableMemory_@throws IOException;void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException {_		final BulkBlockChannelReader reader = ioManager.createBulkBlockChannelReader(this.initialBuildSideChannel, _			availableMemory, this.initialPartitionBuffersCount)__		reader.close()__		final List<MemorySegment> partitionBuffersFromDisk = reader.getFullSegments()__		this.partitionBuffers = (MemorySegment[]) partitionBuffersFromDisk.toArray(new MemorySegment[partitionBuffersFromDisk.size()])__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		this.isRestored = true__	};this,method,is,called,every,time,a,multi,match,hash,map,is,opened,again,for,a,new,probe,input,param,io,manager,param,available,memory,throws,ioexception;void,restore,partition,buffers,iomanager,io,manager,list,memory,segment,available,memory,throws,ioexception,final,bulk,block,channel,reader,reader,io,manager,create,bulk,block,channel,reader,this,initial,build,side,channel,available,memory,this,initial,partition,buffers,count,reader,close,final,list,memory,segment,partition,buffers,from,disk,reader,get,full,segments,this,partition,buffers,memory,segment,partition,buffers,from,disk,to,array,new,memory,segment,partition,buffers,from,disk,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,is,restored,true
ReOpenableHashPartition -> void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException;1415702894;This method is called every time a multi-match hash map is opened again for a new probe input._@param ioManager_@param availableMemory_@throws IOException;void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException {_		final BulkBlockChannelReader reader = ioManager.createBulkBlockChannelReader(this.initialBuildSideChannel, _			availableMemory, this.initialPartitionBuffersCount)__		reader.close()__		final List<MemorySegment> partitionBuffersFromDisk = reader.getFullSegments()__		this.partitionBuffers = (MemorySegment[]) partitionBuffersFromDisk.toArray(new MemorySegment[partitionBuffersFromDisk.size()])__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		this.isRestored = true__	};this,method,is,called,every,time,a,multi,match,hash,map,is,opened,again,for,a,new,probe,input,param,io,manager,param,available,memory,throws,ioexception;void,restore,partition,buffers,iomanager,io,manager,list,memory,segment,available,memory,throws,ioexception,final,bulk,block,channel,reader,reader,io,manager,create,bulk,block,channel,reader,this,initial,build,side,channel,available,memory,this,initial,partition,buffers,count,reader,close,final,list,memory,segment,partition,buffers,from,disk,reader,get,full,segments,this,partition,buffers,memory,segment,partition,buffers,from,disk,to,array,new,memory,segment,partition,buffers,from,disk,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,is,restored,true
ReOpenableHashPartition -> void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException;1426697080;This method is called every time a multi-match hash map is opened again for a new probe input._@param ioManager_@param availableMemory_@throws IOException;void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException {_		final BulkBlockChannelReader reader = ioManager.createBulkBlockChannelReader(this.initialBuildSideChannel, _			availableMemory, this.initialPartitionBuffersCount)__		reader.close()__		final List<MemorySegment> partitionBuffersFromDisk = reader.getFullSegments()__		this.partitionBuffers = (MemorySegment[]) partitionBuffersFromDisk.toArray(new MemorySegment[partitionBuffersFromDisk.size()])__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		this.isRestored = true__	};this,method,is,called,every,time,a,multi,match,hash,map,is,opened,again,for,a,new,probe,input,param,io,manager,param,available,memory,throws,ioexception;void,restore,partition,buffers,iomanager,io,manager,list,memory,segment,available,memory,throws,ioexception,final,bulk,block,channel,reader,reader,io,manager,create,bulk,block,channel,reader,this,initial,build,side,channel,available,memory,this,initial,partition,buffers,count,reader,close,final,list,memory,segment,partition,buffers,from,disk,reader,get,full,segments,this,partition,buffers,memory,segment,partition,buffers,from,disk,to,array,new,memory,segment,partition,buffers,from,disk,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,is,restored,true
ReOpenableHashPartition -> void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException;1456186722;This method is called every time a multi-match hash map is opened again for a new probe input._@param ioManager_@param availableMemory_@throws IOException;void restorePartitionBuffers(IOManager ioManager, List<MemorySegment> availableMemory) throws IOException {_		final BulkBlockChannelReader reader = ioManager.createBulkBlockChannelReader(this.initialBuildSideChannel, _			availableMemory, this.initialPartitionBuffersCount)__		reader.close()__		final List<MemorySegment> partitionBuffersFromDisk = reader.getFullSegments()__		this.partitionBuffers = (MemorySegment[]) partitionBuffersFromDisk.toArray(new MemorySegment[partitionBuffersFromDisk.size()])__		_		this.overflowSegments = new MemorySegment[2]__		this.numOverflowSegments = 0__		this.nextOverflowBucket = 0__		this.isRestored = true__	};this,method,is,called,every,time,a,multi,match,hash,map,is,opened,again,for,a,new,probe,input,param,io,manager,param,available,memory,throws,ioexception;void,restore,partition,buffers,iomanager,io,manager,list,memory,segment,available,memory,throws,ioexception,final,bulk,block,channel,reader,reader,io,manager,create,bulk,block,channel,reader,this,initial,build,side,channel,available,memory,this,initial,partition,buffers,count,reader,close,final,list,memory,segment,partition,buffers,from,disk,reader,get,full,segments,this,partition,buffers,memory,segment,partition,buffers,from,disk,to,array,new,memory,segment,partition,buffers,from,disk,size,this,overflow,segments,new,memory,segment,2,this,num,overflow,segments,0,this,next,overflow,bucket,0,this,is,restored,true
