commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;3;/**  * Assigns the given key to a parallel operator index.  *  * @param key the key to assign  * @param maxParallelism the maximum supported parallelism, aka the number of key-groups.  * @param parallelism the current parallelism of the operator  * @return the index of the parallel operator to which the given key should be routed.  */ ;/**  * Assigns the given key to a parallel operator index.  *  * @param key the key to assign  * @param maxParallelism the maximum supported parallelism, aka the number of key-groups.  * @param parallelism the current parallelism of the operator  * @return the index of the parallel operator to which the given key should be routed.  */ public static int assignKeyToParallelOperator(Object key, int maxParallelism, int parallelism) {     return computeOperatorIndexForKeyGroup(maxParallelism, parallelism, assignToKeyGroup(key, maxParallelism)). }
true;public,static;2;3;/**  * Assigns the given key to a key-group index.  *  * @param key the key to assign  * @param maxParallelism the maximum supported parallelism, aka the number of key-groups.  * @return the key-group to which the given key is assigned  */ ;/**  * Assigns the given key to a key-group index.  *  * @param key the key to assign  * @param maxParallelism the maximum supported parallelism, aka the number of key-groups.  * @return the key-group to which the given key is assigned  */ public static int assignToKeyGroup(Object key, int maxParallelism) {     return computeKeyGroupForKeyHash(key.hashCode(), maxParallelism). }
true;public,static;2;3;/**  * Assigns the given key to a key-group index.  *  * @param keyHash the hash of the key to assign  * @param maxParallelism the maximum supported parallelism, aka the number of key-groups.  * @return the key-group to which the given key is assigned  */ ;/**  * Assigns the given key to a key-group index.  *  * @param keyHash the hash of the key to assign  * @param maxParallelism the maximum supported parallelism, aka the number of key-groups.  * @return the key-group to which the given key is assigned  */ public static int computeKeyGroupForKeyHash(int keyHash, int maxParallelism) {     return MathUtils.murmurHash(keyHash) % maxParallelism. }
true;public,static;3;15;/**  * Computes the range of key-groups that are assigned to a given operator under the given parallelism and maximum  * parallelism.  *  * IMPORTANT: maxParallelism must be <= Short.MAX_VALUE to avoid rounding problems in this method. If we ever want  * to go beyond this boundary, this method must perform arithmetic on long values.  *  * @param maxParallelism Maximal parallelism that the job was initially created with.  * @param parallelism    The current parallelism under which the job runs. Must be <= maxParallelism.  * @param operatorIndex  Id of a key-group. 0 <= keyGroupID < maxParallelism.  * @return the computed key-group range for the operator.  */ ;/**  * Computes the range of key-groups that are assigned to a given operator under the given parallelism and maximum  * parallelism.  *  * IMPORTANT: maxParallelism must be <= Short.MAX_VALUE to avoid rounding problems in this method. If we ever want  * to go beyond this boundary, this method must perform arithmetic on long values.  *  * @param maxParallelism Maximal parallelism that the job was initially created with.  * @param parallelism    The current parallelism under which the job runs. Must be <= maxParallelism.  * @param operatorIndex  Id of a key-group. 0 <= keyGroupID < maxParallelism.  * @return the computed key-group range for the operator.  */ public static KeyGroupRange computeKeyGroupRangeForOperatorIndex(int maxParallelism, int parallelism, int operatorIndex) {     checkParallelismPreconditions(parallelism).     checkParallelismPreconditions(maxParallelism).     Preconditions.checkArgument(maxParallelism >= parallelism, "Maximum parallelism must not be smaller than parallelism.").     int start = ((operatorIndex * maxParallelism + parallelism - 1) / parallelism).     int end = ((operatorIndex + 1) * maxParallelism - 1) / parallelism.     return new KeyGroupRange(start, end). }
true;public,static;3;3;/**  * Computes the index of the operator to which a key-group belongs under the given parallelism and maximum  * parallelism.  *  * IMPORTANT: maxParallelism must be <= Short.MAX_VALUE to avoid rounding problems in this method. If we ever want  * to go beyond this boundary, this method must perform arithmetic on long values.  *  * @param maxParallelism Maximal parallelism that the job was initially created with.  *                       0 < parallelism <= maxParallelism <= Short.MAX_VALUE must hold.  * @param parallelism    The current parallelism under which the job runs. Must be <= maxParallelism.  * @param keyGroupId     Id of a key-group. 0 <= keyGroupID < maxParallelism.  * @return The index of the operator to which elements from the given key-group should be routed under the given  * parallelism and maxParallelism.  */ ;/**  * Computes the index of the operator to which a key-group belongs under the given parallelism and maximum  * parallelism.  *  * IMPORTANT: maxParallelism must be <= Short.MAX_VALUE to avoid rounding problems in this method. If we ever want  * to go beyond this boundary, this method must perform arithmetic on long values.  *  * @param maxParallelism Maximal parallelism that the job was initially created with.  *                       0 < parallelism <= maxParallelism <= Short.MAX_VALUE must hold.  * @param parallelism    The current parallelism under which the job runs. Must be <= maxParallelism.  * @param keyGroupId     Id of a key-group. 0 <= keyGroupID < maxParallelism.  * @return The index of the operator to which elements from the given key-group should be routed under the given  * parallelism and maxParallelism.  */ public static int computeOperatorIndexForKeyGroup(int maxParallelism, int parallelism, int keyGroupId) {     return keyGroupId * parallelism / maxParallelism. }
true;public,static;1;10;/**  * Computes a default maximum parallelism from the operator parallelism. This is used in case the user has not  * explicitly configured a maximum parallelism to still allow a certain degree of scale-up.  *  * @param operatorParallelism the operator parallelism as basis for computation.  * @return the computed default maximum parallelism.  */ ;/**  * Computes a default maximum parallelism from the operator parallelism. This is used in case the user has not  * explicitly configured a maximum parallelism to still allow a certain degree of scale-up.  *  * @param operatorParallelism the operator parallelism as basis for computation.  * @return the computed default maximum parallelism.  */ public static int computeDefaultMaxParallelism(int operatorParallelism) {     checkParallelismPreconditions(operatorParallelism).     return Math.min(Math.max(MathUtils.roundUpToPowerOfTwo(operatorParallelism + (operatorParallelism / 2)), DEFAULT_LOWER_BOUND_MAX_PARALLELISM), UPPER_BOUND_MAX_PARALLELISM). }
false;public,static;1;5;;public static void checkParallelismPreconditions(int parallelism) {     Preconditions.checkArgument(parallelism > 0 && parallelism <= UPPER_BOUND_MAX_PARALLELISM, "Operator parallelism not within bounds: " + parallelism). }
