commented;modifiers;parameterAmount;loc;comment;code
true;public;0;5;/**  * Shuts down this leader election service.  *  * <p>This method does not perform a clean revocation of the leader status and  * no notification to any leader listeners. It simply notifies all contenders  * and listeners that the service is no longer available.  */ ;// ------------------------------------------------------------------------ // shutdown and errors // ------------------------------------------------------------------------ /**  * Shuts down this leader election service.  *  * <p>This method does not perform a clean revocation of the leader status and  * no notification to any leader listeners. It simply notifies all contenders  * and listeners that the service is no longer available.  */ public void shutdown() {     synchronized (lock) {         shutdownInternally(new Exception("Leader election service is shutting down")).     } }
false;private;1;7;;private void fatalError(Throwable error) {     LOG.error("Embedded leader election service encountered a fatal error. Shutting down service.", error).     synchronized (lock) {         shutdownInternally(new Exception("Leader election service is shutting down after a fatal error", error)).     } }
false;private;1;26;;@GuardedBy("lock") private void shutdownInternally(Exception exceptionForHandlers) {     assert Thread.holdsLock(lock).     if (!shutdown) {         // clear all leader status         currentLeaderProposed = null.         currentLeaderConfirmed = null.         currentLeaderSessionId = null.         currentLeaderAddress = null.         // fail all registered listeners         for (EmbeddedLeaderElectionService service : allLeaderContenders) {             service.shutdown(exceptionForHandlers).         }         allLeaderContenders.clear().         // fail all registered listeners         for (EmbeddedLeaderRetrievalService service : listeners) {             service.shutdown(exceptionForHandlers).         }         listeners.clear().         shutdown = true.     } }
false;public;0;4;;// ------------------------------------------------------------------------ // creating contenders and listeners // ------------------------------------------------------------------------ public LeaderElectionService createLeaderElectionService() {     checkState(!shutdown, "leader election service is shut down").     return new EmbeddedLeaderElectionService(). }
false;public;0;4;;public LeaderRetrievalService createLeaderRetrievalService() {     checkState(!shutdown, "leader election service is shut down").     return new EmbeddedLeaderRetrievalService(). }
true;private;2;20;/**  * Callback from leader contenders when they start their service.  */ ;// ------------------------------------------------------------------------ // adding and removing contenders & listeners // ------------------------------------------------------------------------ /**  * Callback from leader contenders when they start their service.  */ private void addContender(EmbeddedLeaderElectionService service, LeaderContender contender) {     synchronized (lock) {         checkState(!shutdown, "leader election service is shut down").         checkState(!service.running, "leader election service is already started").         try {             if (!allLeaderContenders.add(service)) {                 throw new IllegalStateException("leader election service was added to this service multiple times").             }             service.contender = contender.             service.running = true.             updateLeader().         } catch (Throwable t) {             fatalError(t).         }     } }
true;private;1;35;/**  * Callback from leader contenders when they stop their service.  */ ;/**  * Callback from leader contenders when they stop their service.  */ private void removeContender(EmbeddedLeaderElectionService service) {     synchronized (lock) {         // if the service was not even started, simply do nothing         if (!service.running || shutdown) {             return.         }         try {             if (!allLeaderContenders.remove(service)) {                 throw new IllegalStateException("leader election service does not belong to this service").             }             // stop the service             service.contender = null.             service.running = false.             service.isLeader = false.             // if that was the current leader, unset its status             if (currentLeaderConfirmed == service) {                 currentLeaderConfirmed = null.                 currentLeaderSessionId = null.                 currentLeaderAddress = null.             }             if (currentLeaderProposed == service) {                 currentLeaderProposed = null.                 currentLeaderSessionId = null.             }             updateLeader().         } catch (Throwable t) {             fatalError(t).         }     } }
true;private;2;30;/**  * Callback from leader contenders when they confirm a leader grant.  */ ;/**  * Callback from leader contenders when they confirm a leader grant.  */ private void confirmLeader(final EmbeddedLeaderElectionService service, final UUID leaderSessionId) {     synchronized (lock) {         // if the service was shut down in the meantime, ignore this confirmation         if (!service.running || shutdown) {             return.         }         try {             // check if the confirmation is for the same grant, or whether it is a stale grant             if (service == currentLeaderProposed && currentLeaderSessionId.equals(leaderSessionId)) {                 final String address = service.contender.getAddress().                 LOG.info("Received confirmation of leadership for leader {} , session={}", address, leaderSessionId).                 // mark leadership                 currentLeaderConfirmed = service.                 currentLeaderAddress = address.                 currentLeaderProposed = null.                 // notify all listeners                 notifyAllListeners(address, leaderSessionId).             } else {                 LOG.debug("Received confirmation of leadership for a stale leadership grant. Ignoring.").             }         } catch (Throwable t) {             fatalError(t).         }     } }
false;private;2;9;;private CompletableFuture<Void> notifyAllListeners(String address, UUID leaderSessionId) {     final List<CompletableFuture<Void>> notifyListenerFutures = new ArrayList<>(listeners.size()).     for (EmbeddedLeaderRetrievalService listener : listeners) {         notifyListenerFutures.add(notifyListener(address, leaderSessionId, listener.listener)).     }     return FutureUtils.waitForAll(notifyListenerFutures). }
false;private;0;28;;@GuardedBy("lock") private CompletableFuture<Void> updateLeader() {     // this must be called under the lock     assert Thread.holdsLock(lock).     if (currentLeaderConfirmed == null && currentLeaderProposed == null) {         // we need a new leader         if (allLeaderContenders.isEmpty()) {             // no new leader available, tell everyone that there is no leader currently             return notifyAllListeners(null, null).         } else {             // propose a leader and ask it             final UUID leaderSessionId = UUID.randomUUID().             EmbeddedLeaderElectionService leaderService = allLeaderContenders.iterator().next().             currentLeaderSessionId = leaderSessionId.             currentLeaderProposed = leaderService.             LOG.info("Proposing leadership to contender {} @ {}", leaderService.contender, leaderService.contender.getAddress()).             return execute(new GrantLeadershipCall(leaderService, leaderSessionId, LOG)).         }     } else {         return CompletableFuture.completedFuture(null).     } }
false;private;3;3;;private CompletableFuture<Void> notifyListener(@Nullable String address, @Nullable UUID leaderSessionId, LeaderRetrievalListener listener) {     return CompletableFuture.runAsync(new NotifyOfLeaderCall(address, leaderSessionId, listener, LOG), notificationExecutor). }
false;private;2;23;;private void addListener(EmbeddedLeaderRetrievalService service, LeaderRetrievalListener listener) {     synchronized (lock) {         checkState(!shutdown, "leader election service is shut down").         checkState(!service.running, "leader retrieval service is already started").         try {             if (!listeners.add(service)) {                 throw new IllegalStateException("leader retrieval service was added to this service multiple times").             }             service.listener = listener.             service.running = true.             // if we already have a leader, immediately notify this new listener             if (currentLeaderConfirmed != null) {                 notifyListener(currentLeaderAddress, currentLeaderSessionId, listener).             }         } catch (Throwable t) {             fatalError(t).         }     } }
false;private;1;21;;private void removeListener(EmbeddedLeaderRetrievalService service) {     synchronized (lock) {         // if the service was not even started, simply do nothing         if (!service.running || shutdown) {             return.         }         try {             if (!listeners.remove(service)) {                 throw new IllegalStateException("leader retrieval service does not belong to this service").             }             // stop the service             service.listener = null.             service.running = false.         } catch (Throwable t) {             fatalError(t).         }     } }
false;;0;10;;@VisibleForTesting CompletableFuture<Void> grantLeadership() {     synchronized (lock) {         if (shutdown) {             return getShutDownFuture().         }         return updateLeader().     } }
false;private;0;3;;private CompletableFuture<Void> getShutDownFuture() {     return FutureUtils.completedExceptionally(new FlinkException("EmbeddedLeaderService has been shut down.")). }
false;;0;32;;@VisibleForTesting CompletableFuture<Void> revokeLeadership() {     synchronized (lock) {         if (shutdown) {             return getShutDownFuture().         }         if (currentLeaderProposed != null || currentLeaderConfirmed != null) {             final EmbeddedLeaderElectionService leaderService.             if (currentLeaderConfirmed != null) {                 leaderService = currentLeaderConfirmed.             } else {                 leaderService = currentLeaderProposed.             }             LOG.info("Revoking leadership of {}.", leaderService.contender).             CompletableFuture<Void> revokeLeadershipCallFuture = execute(new RevokeLeadershipCall(leaderService)).             CompletableFuture<Void> notifyAllListenersFuture = notifyAllListeners(null, null).             currentLeaderProposed = null.             currentLeaderConfirmed = null.             currentLeaderAddress = null.             currentLeaderSessionId = null.             return CompletableFuture.allOf(revokeLeadershipCallFuture, notifyAllListenersFuture).         } else {             return CompletableFuture.completedFuture(null).         }     } }
false;private;1;3;;private CompletableFuture<Void> execute(Runnable runnable) {     return CompletableFuture.runAsync(runnable, notificationExecutor). }
false;public;1;5;;@Override public void start(LeaderContender contender) throws Exception {     checkNotNull(contender).     addContender(this, contender). }
false;public;0;4;;@Override public void stop() throws Exception {     removeContender(this). }
false;public;1;5;;@Override public void confirmLeaderSessionID(UUID leaderSessionID) {     checkNotNull(leaderSessionID).     confirmLeader(this, leaderSessionID). }
false;public;1;4;;@Override public boolean hasLeadership(@Nonnull UUID leaderSessionId) {     return isLeader && leaderSessionId.equals(currentLeaderSessionId). }
false;;1;8;;void shutdown(Exception cause) {     if (running) {         running = false.         isLeader = false.         contender.revokeLeadership().         contender = null.     } }
false;public;1;5;;@Override public void start(LeaderRetrievalListener listener) throws Exception {     checkNotNull(listener).     addListener(this, listener). }
false;public;0;4;;@Override public void stop() throws Exception {     removeListener(this). }
false;public;1;6;;public void shutdown(Exception cause) {     if (running) {         running = false.         listener = null.     } }
false;public;0;10;;@Override public void run() {     try {         listener.notifyLeaderAddress(address, leaderSessionId).     } catch (Throwable t) {         logger.warn("Error notifying leader listener about new leader", t).         listener.handleError(t instanceof Exception ? (Exception) t : new Exception(t)).     } }
false;public;0;15;;@Override public void run() {     leaderElectionService.isLeader = true.     final LeaderContender contender = leaderElectionService.contender.     try {         contender.grantLeadership(leaderSessionId).     } catch (Throwable t) {         logger.warn("Error granting leadership to contender", t).         contender.handleError(t instanceof Exception ? (Exception) t : new Exception(t)).         leaderElectionService.isLeader = false.     } }
false;public;0;6;;@Override public void run() {     leaderElectionService.isLeader = false.     leaderElectionService.contender.revokeLeadership(). }
