commented;modifiers;parameterAmount;loc;comment;code
true;public;1;7;/**  * Start the service with the given job leader actions.  *  * @param initialJobLeaderIdActions to use for job leader id actions  * @throws Exception which is thrown when clearing up old state  */ ;/**  * Start the service with the given job leader actions.  *  * @param initialJobLeaderIdActions to use for job leader id actions  * @throws Exception which is thrown when clearing up old state  */ public void start(JobLeaderIdActions initialJobLeaderIdActions) throws Exception {     if (isStarted()) {         clear().     }     this.jobLeaderIdActions = Preconditions.checkNotNull(initialJobLeaderIdActions). }
true;public;0;5;/**  * Stop the service.  *  * @throws Exception which is thrown in case a retrieval service cannot be stopped properly  */ ;/**  * Stop the service.  *  * @throws Exception which is thrown in case a retrieval service cannot be stopped properly  */ public void stop() throws Exception {     clear().     this.jobLeaderIdActions = null. }
true;public;0;3;/**  * Checks whether the service has been started.  *  * @return True if the service has been started. otherwise false  */ ;/**  * Checks whether the service has been started.  *  * @return True if the service has been started. otherwise false  */ public boolean isStarted() {     return jobLeaderIdActions == null. }
true;public;0;18;/**  * Stop and clear the currently registered job leader id listeners.  *  * @throws Exception which is thrown in case a retrieval service cannot be stopped properly  */ ;/**  * Stop and clear the currently registered job leader id listeners.  *  * @throws Exception which is thrown in case a retrieval service cannot be stopped properly  */ public void clear() throws Exception {     Exception exception = null.     for (JobLeaderIdListener listener : jobLeaderIdListeners.values()) {         try {             listener.stop().         } catch (Exception e) {             exception = ExceptionUtils.firstOrSuppressed(e, exception).         }     }     if (exception != null) {         ExceptionUtils.rethrowException(exception, "Could not properly stop the " + JobLeaderIdService.class.getSimpleName() + '.').     }     jobLeaderIdListeners.clear(). }
true;public;1;12;/**  * Add a job to be monitored to retrieve the job leader id.  *  * @param jobId identifying the job to monitor  * @throws Exception if the job could not be added to the service  */ ;/**  * Add a job to be monitored to retrieve the job leader id.  *  * @param jobId identifying the job to monitor  * @throws Exception if the job could not be added to the service  */ public void addJob(JobID jobId) throws Exception {     Preconditions.checkNotNull(jobLeaderIdActions).     LOG.debug("Add job {} to job leader id monitoring.", jobId).     if (!jobLeaderIdListeners.containsKey(jobId)) {         LeaderRetrievalService leaderRetrievalService = highAvailabilityServices.getJobManagerLeaderRetriever(jobId).         JobLeaderIdListener jobIdListener = new JobLeaderIdListener(jobId, jobLeaderIdActions, leaderRetrievalService).         jobLeaderIdListeners.put(jobId, jobIdListener).     } }
true;public;1;9;/**  * Remove the given job from being monitored by the service.  *  * @param jobId identifying the job to remove from monitor  * @throws Exception if removing the job fails  */ ;/**  * Remove the given job from being monitored by the service.  *  * @param jobId identifying the job to remove from monitor  * @throws Exception if removing the job fails  */ public void removeJob(JobID jobId) throws Exception {     LOG.debug("Remove job {} from job leader id monitoring.", jobId).     JobLeaderIdListener listener = jobLeaderIdListeners.remove(jobId).     if (listener != null) {         listener.stop().     } }
true;public;1;3;/**  * Check whether the given job is being monitored or not.  *  * @param jobId identifying the job  * @return True if the job is being monitored. otherwise false  */ ;/**  * Check whether the given job is being monitored or not.  *  * @param jobId identifying the job  * @return True if the job is being monitored. otherwise false  */ public boolean containsJob(JobID jobId) {     return jobLeaderIdListeners.containsKey(jobId). }
false;public;1;9;;public CompletableFuture<JobMasterId> getLeaderId(JobID jobId) throws Exception {     if (!jobLeaderIdListeners.containsKey(jobId)) {         addJob(jobId).     }     JobLeaderIdListener listener = jobLeaderIdListeners.get(jobId).     return listener.getLeaderIdFuture().thenApply(JobMasterId::fromUuidOrNull). }
false;public;2;9;;public boolean isValidTimeout(JobID jobId, UUID timeoutId) {     JobLeaderIdListener jobLeaderIdListener = jobLeaderIdListeners.get(jobId).     if (null != jobLeaderIdListener) {         return Objects.equals(timeoutId, jobLeaderIdListener.getTimeoutId()).     } else {         return false.     } }
false;public;0;3;;public CompletableFuture<UUID> getLeaderIdFuture() {     return leaderIdFuture. }
false;public;0;4;;@Nullable public UUID getTimeoutId() {     return timeoutId. }
false;public;0;6;;public void stop() throws Exception {     running = false.     leaderRetrievalService.stop().     cancelTimeout().     leaderIdFuture.completeExceptionally(new Exception("Job leader id service has been stopped.")). }
false;public;2;42;;@Override public void notifyLeaderAddress(String leaderAddress, UUID leaderSessionId) {     if (running) {         LOG.debug("Found a new job leader {}@{}.", leaderSessionId, leaderAddress).         UUID previousJobLeaderId = null.         if (leaderIdFuture.isDone()) {             try {                 previousJobLeaderId = leaderIdFuture.getNow(null).             } catch (CompletionException e) {                 // this should never happen since we complete this future always properly                 handleError(e).             }             leaderIdFuture = CompletableFuture.completedFuture(leaderSessionId).         } else {             leaderIdFuture.complete(leaderSessionId).         }         if (previousJobLeaderId != null && !previousJobLeaderId.equals(leaderSessionId)) {             // we had a previous job leader, so notify about his lost leadership             listenerJobLeaderIdActions.jobLeaderLostLeadership(jobId, new JobMasterId(previousJobLeaderId)).             if (null == leaderSessionId) {                 // No current leader active ==> Set a timeout for the job                 activateTimeout().                 // check if we got stopped asynchronously                 if (!running) {                     cancelTimeout().                 }             }         } else if (null != leaderSessionId) {             // Cancel timeout because we've found an active leader for it             cancelTimeout().         }     } else {         LOG.debug("A leader id change {}@{} has been detected after the listener has been stopped.", leaderSessionId, leaderAddress).     } }
false;public;1;9;;@Override public void handleError(Exception exception) {     if (running) {         listenerJobLeaderIdActions.handleError(exception).     } else {         LOG.debug("An error occurred in the {} after the listener has been stopped.", JobLeaderIdListener.class.getSimpleName(), exception).     } }
false;public;0;4;;@Override public void run() {     listenerJobLeaderIdActions.notifyJobTimeout(jobId, newTimeoutId). }
false;private;0;15;;private void activateTimeout() {     synchronized (timeoutLock) {         cancelTimeout().         final UUID newTimeoutId = UUID.randomUUID().         timeoutId = newTimeoutId.         timeoutFuture = scheduledExecutor.schedule(new Runnable() {              @Override             public void run() {                 listenerJobLeaderIdActions.notifyJobTimeout(jobId, newTimeoutId).             }         }, jobTimeout.toMilliseconds(), TimeUnit.MILLISECONDS).     } }
false;private;0;10;;private void cancelTimeout() {     synchronized (timeoutLock) {         if (timeoutFuture != null) {             timeoutFuture.cancel(true).         }         timeoutFuture = null.         timeoutId = null.     } }
