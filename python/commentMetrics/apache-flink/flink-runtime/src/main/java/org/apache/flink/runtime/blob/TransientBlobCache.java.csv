commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public File getFile(TransientBlobKey key) throws IOException {     return getFileInternal(null, key). }
false;public;2;5;;@Override public File getFile(JobID jobId, TransientBlobKey key) throws IOException {     checkNotNull(jobId).     return getFileInternal(jobId, key). }
false;protected;2;17;;@Override protected File getFileInternal(@Nullable JobID jobId, BlobKey blobKey) throws IOException {     File file = super.getFileInternal(jobId, blobKey).     readWriteLock.readLock().lock().     try {         // regarding concurrent operations, it is not really important which timestamp makes         // it into the map as they are close to each other anyway, also we can simply         // overwrite old values as long as we are in the read (or write) lock         blobExpiryTimes.put(Tuple2.of(jobId, (TransientBlobKey) blobKey), System.currentTimeMillis() + cleanupInterval).     } finally {         readWriteLock.readLock().unlock().     }     return file. }
false;public;1;6;;@Override public TransientBlobKey putTransient(byte[] value) throws IOException {     try (BlobClient bc = createClient()) {         return (TransientBlobKey) bc.putBuffer(null, value, 0, value.length, TRANSIENT_BLOB).     } }
false;public;2;7;;@Override public TransientBlobKey putTransient(JobID jobId, byte[] value) throws IOException {     checkNotNull(jobId).     try (BlobClient bc = createClient()) {         return (TransientBlobKey) bc.putBuffer(jobId, value, 0, value.length, TRANSIENT_BLOB).     } }
false;public;1;6;;@Override public TransientBlobKey putTransient(InputStream inputStream) throws IOException {     try (BlobClient bc = createClient()) {         return (TransientBlobKey) bc.putInputStream(null, inputStream, TRANSIENT_BLOB).     } }
false;public;2;7;;@Override public TransientBlobKey putTransient(JobID jobId, InputStream inputStream) throws IOException {     checkNotNull(jobId).     try (BlobClient bc = createClient()) {         return (TransientBlobKey) bc.putInputStream(jobId, inputStream, TRANSIENT_BLOB).     } }
false;public;1;4;;@Override public boolean deleteFromCache(TransientBlobKey key) {     return deleteInternal(null, key). }
false;public;2;5;;@Override public boolean deleteFromCache(JobID jobId, TransientBlobKey key) {     checkNotNull(jobId).     return deleteInternal(jobId, key). }
true;private;2;19;/**  * Deletes the file associated with the blob key in this BLOB cache.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param key  * 		blob key associated with the file to be deleted  *  * @return  <tt>true</tt> if the given blob is successfully deleted or non-existing.  *          <tt>false</tt> otherwise  */ ;/**  * Deletes the file associated with the blob key in this BLOB cache.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param key  * 		blob key associated with the file to be deleted  *  * @return  <tt>true</tt> if the given blob is successfully deleted or non-existing.  *          <tt>false</tt> otherwise  */ private boolean deleteInternal(@Nullable JobID jobId, TransientBlobKey key) {     final File localFile = new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId, key)).     readWriteLock.writeLock().lock().     try {         if (!localFile.delete() && localFile.exists()) {             log.warn("Failed to delete locally cached BLOB {} at {}", key, localFile.getAbsolutePath()).             return false.         } else {             // this needs to happen inside the write lock in case of concurrent getFile() calls             blobExpiryTimes.remove(Tuple2.of(jobId, key)).         }     } finally {         readWriteLock.writeLock().unlock().     }     return true. }
true;;0;4;/**  * Returns the blob expiry times - for testing purposes only!  *  * @return blob expiry times (internal state!)  */ ;/**  * Returns the blob expiry times - for testing purposes only!  *  * @return blob expiry times (internal state!)  */ @VisibleForTesting ConcurrentMap<Tuple2<JobID, TransientBlobKey>, Long> getBlobExpiryTimes() {     return blobExpiryTimes. }
true;public;2;4;/**  * Returns a file handle to the file associated with the given blob key on the blob  * server.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param key  * 		identifying the file  *  * @return file handle to the file  *  * @throws IOException  * 		if creating the directory fails  */ ;/**  * Returns a file handle to the file associated with the given blob key on the blob  * server.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param key  * 		identifying the file  *  * @return file handle to the file  *  * @throws IOException  * 		if creating the directory fails  */ @VisibleForTesting public File getStorageLocation(@Nullable JobID jobId, BlobKey key) throws IOException {     return BlobUtils.getStorageLocation(storageDir, jobId, key). }
false;private;0;9;;private BlobClient createClient() throws IOException {     final InetSocketAddress currentServerAddress = serverAddress.     if (currentServerAddress != null) {         return new BlobClient(currentServerAddress, blobClientConfig).     } else {         throw new IOException("Could not create BlobClient because the BlobServer address is unknown.").     } }
false;protected;0;4;;@Override protected void cancelCleanupTask() {     cleanupTimer.cancel(). }
