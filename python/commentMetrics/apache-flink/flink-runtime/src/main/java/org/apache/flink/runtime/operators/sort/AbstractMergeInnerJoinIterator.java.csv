commented;modifiers;parameterAmount;loc;comment;code
true;public;2;47;/**  * Calls the <code>JoinFunction#join()</code> method for all two key-value pairs that share the same key and come  * from different inputs. The output of the <code>join()</code> method is forwarded.  * <p>  * This method first zig-zags between the two sorted inputs in order to find a common  * key, and then calls the join stub with the cross product of the values.  *  * @throws Exception Forwards all exceptions from the user code and the I/O system.  * @see org.apache.flink.runtime.operators.util.JoinTaskIterator#callWithNextKey(org.apache.flink.api.common.functions.FlatJoinFunction, org.apache.flink.util.Collector)  */ ;/**  * Calls the <code>JoinFunction#join()</code> method for all two key-value pairs that share the same key and come  * from different inputs. The output of the <code>join()</code> method is forwarded.  * <p>  * This method first zig-zags between the two sorted inputs in order to find a common  * key, and then calls the join stub with the cross product of the values.  *  * @throws Exception Forwards all exceptions from the user code and the I/O system.  * @see org.apache.flink.runtime.operators.util.JoinTaskIterator#callWithNextKey(org.apache.flink.api.common.functions.FlatJoinFunction, org.apache.flink.util.Collector)  */ @Override public boolean callWithNextKey(final FlatJoinFunction<T1, T2, O> joinFunction, final Collector<O> collector) throws Exception {     if (!this.iterator1.nextKey() || !this.iterator2.nextKey()) {         // consume all remaining keys (hack to prevent remaining inputs during iterations, lets get rid of this soon)         while (this.iterator1.nextKey()) {         }         while (this.iterator2.nextKey()) {         }         return false.     }     final TypePairComparator<T1, T2> comparator = this.pairComparator.     comparator.setReference(this.iterator1.getCurrent()).     T2 current2 = this.iterator2.getCurrent().     // zig zag     while (true) {         // determine the relation between the (possibly composite) keys         final int comp = comparator.compareToReference(current2).         if (comp == 0) {             break.         }         if (comp < 0) {             if (!this.iterator2.nextKey()) {                 return false.             }             current2 = this.iterator2.getCurrent().         } else {             if (!this.iterator1.nextKey()) {                 return false.             }             comparator.setReference(this.iterator1.getCurrent()).         }     }     // here, we have a common key! call the join function with the cross product of the     // values     final Iterator<T1> values1 = this.iterator1.getValues().     final Iterator<T2> values2 = this.iterator2.getValues().     crossMatchingGroup(values1, values2, joinFunction, collector).     return true. }
