commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;// -------------------------------------------------------------------------------------------- @Override public void setup(AbstractInvokable parent) {     this.parent = parent.     @SuppressWarnings("unchecked")     final GroupReduceFunction<IN, OUT> combiner = BatchTask.instantiateUserCode(this.config, userCodeClassLoader, GroupReduceFunction.class).     this.reducer = combiner.     FunctionUtils.setFunctionRuntimeContext(combiner, getUdfRuntimeContext()). }
false;public;0;34;;@Override public void openTask() throws Exception {     // open the stub first     final Configuration stubConfig = this.config.getStubParameters().     BatchTask.openUserCode(this.reducer, stubConfig).     // ----------------- Set up the sorter -------------------------     // instantiate the serializer / comparator     final TypeSerializerFactory<IN> serializerFactory = this.config.getInputSerializer(0, this.userCodeClassLoader).     final TypeComparatorFactory<IN> sortingComparatorFactory = this.config.getDriverComparator(0, this.userCodeClassLoader).     final TypeComparatorFactory<IN> groupingComparatorFactory = this.config.getDriverComparator(1, this.userCodeClassLoader).     this.serializer = serializerFactory.getSerializer().     TypeComparator<IN> sortingComparator = sortingComparatorFactory.createComparator().     this.groupingComparator = groupingComparatorFactory.createComparator().     MemoryManager memManager = this.parent.getEnvironment().getMemoryManager().     final int numMemoryPages = memManager.computeNumberOfPages(this.config.getRelativeMemoryDriver()).     this.memory = memManager.allocatePages(this.parent, numMemoryPages).     // instantiate a fix-length in-place sorter, if possible, otherwise the out-of-place sorter     if (sortingComparator.supportsSerializationWithKeyNormalization() && this.serializer.getLength() > 0 && this.serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING) {         this.sorter = new FixedLengthRecordSorter<IN>(this.serializer, sortingComparator.duplicate(), memory).     } else {         this.sorter = new NormalizedKeySorter<IN>(this.serializer, sortingComparator.duplicate(), memory).     }     if (LOG.isDebugEnabled()) {         LOG.debug("SynchronousChainedCombineDriver object reuse: " + (this.objectReuseEnabled ? "ENABLED" : "DISABLED") + ".").     } }
false;public;0;11;;@Override public void closeTask() throws Exception {     if (this.sorter != null) {         this.sorter.dispose().     }     this.parent.getEnvironment().getMemoryManager().release(this.memory).     if (this.running) {         BatchTask.closeUserCode(this.reducer).     } }
false;public;0;15;;@Override public void cancelTask() {     this.running = false.     if (this.sorter != null) {         try {             this.sorter.dispose().         } catch (Exception e) {         // may happen during concurrent modification         }     }     this.parent.getEnvironment().getMemoryManager().release(this.memory). }
false;public;0;3;;// -------------------------------------------------------------------------------------------- public Function getStub() {     return this.reducer. }
false;public;0;3;;public String getTaskName() {     return this.taskName. }
false;public;1;21;;@Override public void collect(IN record) {     numRecordsIn.inc().     // try writing to the sorter first     try {         if (this.sorter.write(record)) {             return.         }         // do the actual sorting         sortAndReduce().         this.sorter.reset().         if (!this.sorter.write(record)) {             throw new IOException("Cannot write record to fresh sort buffer. Record too large.").         }     } catch (Exception e) {         throw new ExceptionInChainedStubException(this.taskName, e).     } }
false;public;0;10;;// -------------------------------------------------------------------------------------------- @Override public void close() {     try {         sortAndReduce().     } catch (Exception e) {         throw new ExceptionInChainedStubException(this.taskName, e).     }     this.outputCollector.close(). }
false;private;0;38;;private void sortAndReduce() throws Exception {     final InMemorySorter<IN> sorter = this.sorter.     if (objectReuseEnabled) {         if (!sorter.isEmpty()) {             this.sortAlgo.sort(sorter).             // run the reducer             final ReusingKeyGroupedIterator<IN> keyIter = new ReusingKeyGroupedIterator<IN>(sorter.getIterator(), this.serializer, this.groupingComparator).             // cache references on the stack             final GroupReduceFunction<IN, OUT> stub = this.reducer.             final Collector<OUT> output = this.outputCollector.             // run stub implementation             while (this.running && keyIter.nextKey()) {                 stub.reduce(keyIter.getValues(), output).             }         }     } else {         if (!sorter.isEmpty()) {             this.sortAlgo.sort(sorter).             // run the reducer             final NonReusingKeyGroupedIterator<IN> keyIter = new NonReusingKeyGroupedIterator<IN>(sorter.getIterator(), this.groupingComparator).             // cache references on the stack             final GroupReduceFunction<IN, OUT> stub = this.reducer.             final Collector<OUT> output = this.outputCollector.             // run stub implementation             while (this.running && keyIter.nextKey()) {                 stub.reduce(keyIter.getValues(), output).             }         }     } }
