commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setup(TaskContext<CoGroupFunction<IT1, IT2, OT>, OT> context) {     this.taskContext = context. }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 2. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 0. }
false;public;0;6;;@Override public Class<CoGroupFunction<IT1, IT2, OT>> getStubType() {     @SuppressWarnings("unchecked")     final Class<CoGroupFunction<IT1, IT2, OT>> clazz = (Class<CoGroupFunction<IT1, IT2, OT>>) (Class<?>) CoGroupFunction.class.     return clazz. }
false;public;0;20;;@Override public void prepare() throws Exception {     final TaskConfig config = this.taskContext.getTaskConfig().     if (config.getDriverStrategy() != DriverStrategy.CO_GROUP_RAW) {         throw new Exception("Unrecognized driver strategy for CoGoup Python driver: " + config.getDriverStrategy().name()).     }     final MutableObjectIterator<IT1> in1 = this.taskContext.getInput(0).     final MutableObjectIterator<IT2> in2 = this.taskContext.getInput(1).     IT1 reuse1 = this.taskContext.<IT1>getInputSerializer(0).getSerializer().createInstance().     IT2 reuse2 = this.taskContext.<IT2>getInputSerializer(1).getSerializer().createInstance().     this.coGroupIterator1 = new SimpleIterable<IT1>(reuse1, in1).     this.coGroupIterator2 = new SimpleIterable<IT2>(reuse2, in2).     if (LOG.isDebugEnabled()) {         LOG.debug(this.taskContext.formatLogString("CoGroup task iterator ready.")).     } }
false;public;0;9;;@Override public void run() throws Exception {     final CoGroupFunction<IT1, IT2, OT> coGroupStub = this.taskContext.getStub().     final Collector<OT> collector = this.taskContext.getOutputCollector().     final SimpleIterable<IT1> i1 = this.coGroupIterator1.     final SimpleIterable<IT2> i2 = this.coGroupIterator2.     coGroupStub.coGroup(i1, i2, collector). }
false;public;0;3;;@Override public void cleanup() throws Exception { }
false;public;0;4;;@Override public void cancel() throws Exception {     cleanup(). }
false;public;0;4;;@Override public Iterator<IN> iterator() {     return new SimpleIterator<IN>(reuse, iterator). }
false;public;0;14;;@Override public boolean hasNext() {     try {         if (!consumed) {             return true.         }         IN result = iterator.next(reuse).         consumed = result == null.         return !consumed.     } catch (IOException ioex) {         throw new RuntimeException("An error occurred while reading the next record: " + ioex.getMessage(), ioex).     } }
false;public;0;5;;@Override public IN next() {     consumed = true.     return reuse. }
false;public;0;3;;@Override public void remove() { // unused }
