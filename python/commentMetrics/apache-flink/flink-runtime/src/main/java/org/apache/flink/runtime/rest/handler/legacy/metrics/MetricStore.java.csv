commented;modifiers;parameterAmount;loc;comment;code
true;synchronized;1;3;/**  * Remove inactive task managers.  *  * @param activeTaskManagers to retain.  */ ;/**  * Remove inactive task managers.  *  * @param activeTaskManagers to retain.  */ synchronized void retainTaskManagers(List<String> activeTaskManagers) {     taskManagers.keySet().retainAll(activeTaskManagers). }
true;synchronized;1;3;/**  * Remove inactive jobs..  *  * @param activeJobs to retain.  */ ;/**  * Remove inactive jobs..  *  * @param activeJobs to retain.  */ synchronized void retainJobs(List<String> activeJobs) {     jobs.keySet().retainAll(activeJobs). }
true;synchronized;1;5;/**  * Add metric dumps to the store.  *  * @param metricDumps to add.  */ ;/**  * Add metric dumps to the store.  *  * @param metricDumps to add.  */ synchronized void addAll(List<MetricDump> metricDumps) {     for (MetricDump metric : metricDumps) {         add(metric).     } }
true;public,synchronized;0;3;/**  * Returns the {@link ComponentMetricStore} for the JobManager.  *  * @return ComponentMetricStore for the JobManager  */ ;// ----------------------------------------------------------------------------------------------------------------- // Accessors for sub MetricStores // ----------------------------------------------------------------------------------------------------------------- /**  * Returns the {@link ComponentMetricStore} for the JobManager.  *  * @return ComponentMetricStore for the JobManager  */ public synchronized ComponentMetricStore getJobManagerMetricStore() {     return ComponentMetricStore.unmodifiable(jobManager). }
true;public,synchronized;1;3;/**  * Returns the {@link TaskManagerMetricStore} for the given taskmanager ID.  *  * @param tmID taskmanager ID  * @return TaskManagerMetricStore for the given ID, or null if no store for the given argument exists  */ ;/**  * Returns the {@link TaskManagerMetricStore} for the given taskmanager ID.  *  * @param tmID taskmanager ID  * @return TaskManagerMetricStore for the given ID, or null if no store for the given argument exists  */ public synchronized TaskManagerMetricStore getTaskManagerMetricStore(String tmID) {     return tmID == null ? null : TaskManagerMetricStore.unmodifiable(taskManagers.get(tmID)). }
true;public,synchronized;1;3;/**  * Returns the {@link ComponentMetricStore} for the given job ID.  *  * @param jobID job ID  * @return ComponentMetricStore for the given ID, or null if no store for the given argument exists  */ ;/**  * Returns the {@link ComponentMetricStore} for the given job ID.  *  * @param jobID job ID  * @return ComponentMetricStore for the given ID, or null if no store for the given argument exists  */ public synchronized ComponentMetricStore getJobMetricStore(String jobID) {     return jobID == null ? null : ComponentMetricStore.unmodifiable(jobs.get(jobID)). }
true;public,synchronized;2;7;/**  * Returns the {@link ComponentMetricStore} for the given job/task ID.  *  * @param jobID  job ID  * @param taskID task ID  * @return ComponentMetricStore for given IDs, or null if no store for the given arguments exists  */ ;/**  * Returns the {@link ComponentMetricStore} for the given job/task ID.  *  * @param jobID  job ID  * @param taskID task ID  * @return ComponentMetricStore for given IDs, or null if no store for the given arguments exists  */ public synchronized TaskMetricStore getTaskMetricStore(String jobID, String taskID) {     JobMetricStore job = jobID == null ? null : jobs.get(jobID).     if (job == null || taskID == null) {         return null.     }     return TaskMetricStore.unmodifiable(job.getTaskMetricStore(taskID)). }
true;public,synchronized;3;11;/**  * Returns the {@link ComponentMetricStore} for the given job/task ID and subtask index.  *  * @param jobID        job ID  * @param taskID       task ID  * @param subtaskIndex subtask index  * @return SubtaskMetricStore for the given IDs and index, or null if no store for the given arguments exists  */ ;/**  * Returns the {@link ComponentMetricStore} for the given job/task ID and subtask index.  *  * @param jobID        job ID  * @param taskID       task ID  * @param subtaskIndex subtask index  * @return SubtaskMetricStore for the given IDs and index, or null if no store for the given arguments exists  */ public synchronized ComponentMetricStore getSubtaskMetricStore(String jobID, String taskID, int subtaskIndex) {     JobMetricStore job = jobID == null ? null : jobs.get(jobID).     if (job == null) {         return null.     }     TaskMetricStore task = job.getTaskMetricStore(taskID).     if (task == null) {         return null.     }     return ComponentMetricStore.unmodifiable(task.getSubtaskMetricStore(subtaskIndex)). }
false;public,synchronized;0;3;;public synchronized Map<String, JobMetricStore> getJobs() {     return unmodifiableMap(jobs). }
false;public,synchronized;0;3;;public synchronized Map<String, TaskManagerMetricStore> getTaskManagers() {     return unmodifiableMap(taskManagers). }
true;public,synchronized;0;4;/**  * @deprecated Use semantically equivalent {@link #getJobManagerMetricStore()}.  */ ;/**  * @deprecated Use semantically equivalent {@link #getJobManagerMetricStore()}.  */ @Deprecated public synchronized ComponentMetricStore getJobManager() {     return ComponentMetricStore.unmodifiable(jobManager). }
false;public;1;69;;@VisibleForTesting public void add(MetricDump metric) {     try {         QueryScopeInfo info = metric.scopeInfo.         TaskManagerMetricStore tm.         JobMetricStore job.         TaskMetricStore task.         ComponentMetricStore subtask.         String name = info.scope.isEmpty() ? metric.name : info.scope + "." + metric.name.         if (name.isEmpty()) {             // malformed transmission             return.         }         switch(info.getCategory()) {             case INFO_CATEGORY_JM:                 addMetric(jobManager.metrics, name, metric).                 break.             case INFO_CATEGORY_TM:                 String tmID = ((QueryScopeInfo.TaskManagerQueryScopeInfo) info).taskManagerID.                 tm = taskManagers.computeIfAbsent(tmID, k -> new TaskManagerMetricStore()).                 if (name.contains("GarbageCollector")) {                     String gcName = name.substring("Status.JVM.GarbageCollector.".length(), name.lastIndexOf('.')).                     tm.addGarbageCollectorName(gcName).                 }                 addMetric(tm.metrics, name, metric).                 break.             case INFO_CATEGORY_JOB:                 QueryScopeInfo.JobQueryScopeInfo jobInfo = (QueryScopeInfo.JobQueryScopeInfo) info.                 job = jobs.computeIfAbsent(jobInfo.jobID, k -> new JobMetricStore()).                 addMetric(job.metrics, name, metric).                 break.             case INFO_CATEGORY_TASK:                 QueryScopeInfo.TaskQueryScopeInfo taskInfo = (QueryScopeInfo.TaskQueryScopeInfo) info.                 job = jobs.computeIfAbsent(taskInfo.jobID, k -> new JobMetricStore()).                 task = job.tasks.computeIfAbsent(taskInfo.vertexID, k -> new TaskMetricStore()).                 subtask = task.subtasks.computeIfAbsent(taskInfo.subtaskIndex, k -> new ComponentMetricStore()).                 /**                  * The duplication is intended. Metrics scoped by subtask are useful for several job/task handlers,                  * while the WebInterface task metric queries currently do not account for subtasks, so we don't                  * divide by subtask and instead use the concatenation of subtask index and metric name as the name                  * for those.                  */                 addMetric(subtask.metrics, name, metric).                 addMetric(task.metrics, taskInfo.subtaskIndex + "." + name, metric).                 break.             case INFO_CATEGORY_OPERATOR:                 QueryScopeInfo.OperatorQueryScopeInfo operatorInfo = (QueryScopeInfo.OperatorQueryScopeInfo) info.                 job = jobs.computeIfAbsent(operatorInfo.jobID, k -> new JobMetricStore()).                 task = job.tasks.computeIfAbsent(operatorInfo.vertexID, k -> new TaskMetricStore()).                 subtask = task.subtasks.computeIfAbsent(operatorInfo.subtaskIndex, k -> new ComponentMetricStore()).                 /**                  * As the WebInterface does not account for operators (because it can't) we don't                  * divide by operator and instead use the concatenation of subtask index, operator name and metric name                  * as the name.                  */                 addMetric(subtask.metrics, operatorInfo.operatorName + "." + name, metric).                 addMetric(task.metrics, operatorInfo.subtaskIndex + "." + operatorInfo.operatorName + "." + name, metric).                 break.             default:                 LOG.debug("Invalid metric dump category: " + info.getCategory()).         }     } catch (Exception e) {         LOG.debug("Malformed metric dump.", e).     } }
false;private;3;30;;private void addMetric(Map<String, String> target, String name, MetricDump metric) {     switch(metric.getCategory()) {         case METRIC_CATEGORY_COUNTER:             MetricDump.CounterDump counter = (MetricDump.CounterDump) metric.             target.put(name, String.valueOf(counter.count)).             break.         case METRIC_CATEGORY_GAUGE:             MetricDump.GaugeDump gauge = (MetricDump.GaugeDump) metric.             target.put(name, gauge.value).             break.         case METRIC_CATEGORY_HISTOGRAM:             MetricDump.HistogramDump histogram = (MetricDump.HistogramDump) metric.             target.put(name + "_min", String.valueOf(histogram.min)).             target.put(name + "_max", String.valueOf(histogram.max)).             target.put(name + "_mean", String.valueOf(histogram.mean)).             target.put(name + "_median", String.valueOf(histogram.median)).             target.put(name + "_stddev", String.valueOf(histogram.stddev)).             target.put(name + "_p75", String.valueOf(histogram.p75)).             target.put(name + "_p90", String.valueOf(histogram.p90)).             target.put(name + "_p95", String.valueOf(histogram.p95)).             target.put(name + "_p98", String.valueOf(histogram.p98)).             target.put(name + "_p99", String.valueOf(histogram.p99)).             target.put(name + "_p999", String.valueOf(histogram.p999)).             break.         case METRIC_CATEGORY_METER:             MetricDump.MeterDump meter = (MetricDump.MeterDump) metric.             target.put(name, String.valueOf(meter.rate)).             break.     } }
false;public;1;3;;public String getMetric(String name) {     return this.metrics.get(name). }
false;public;2;6;;public String getMetric(String name, String defaultValue) {     String value = this.metrics.get(name).     return value != null ? value : defaultValue. }
false;private,static;1;6;;private static ComponentMetricStore unmodifiable(ComponentMetricStore source) {     if (source == null) {         return null.     }     return new ComponentMetricStore(unmodifiableMap(source.metrics)). }
false;private;1;3;;private void addGarbageCollectorName(String name) {     garbageCollectorNames.add(name). }
false;private,static;1;8;;private static TaskManagerMetricStore unmodifiable(TaskManagerMetricStore source) {     if (source == null) {         return null.     }     return new TaskManagerMetricStore(unmodifiableMap(source.metrics), unmodifiableSet(source.garbageCollectorNames)). }
false;public;1;3;;public TaskMetricStore getTaskMetricStore(String taskID) {     return taskID == null ? null : tasks.get(taskID). }
false;public;1;3;;public ComponentMetricStore getSubtaskMetricStore(int subtaskIndex) {     return subtasks.get(subtaskIndex). }
false;public;0;3;;public Collection<ComponentMetricStore> getAllSubtaskMetricStores() {     return subtasks.values(). }
false;private,static;1;8;;private static TaskMetricStore unmodifiable(TaskMetricStore source) {     if (source == null) {         return null.     }     return new TaskMetricStore(unmodifiableMap(source.metrics), unmodifiableMap(source.subtasks)). }
