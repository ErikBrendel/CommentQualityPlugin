commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void setup(TaskContext<MapFunction<IT, OT>, OT> context) {     this.taskContext = context.     this.running = true.     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     this.objectReuseEnabled = executionConfig.isObjectReuseEnabled(). }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 1. }
false;public;0;6;;@Override public Class<MapFunction<IT, OT>> getStubType() {     @SuppressWarnings("unchecked")     final Class<MapFunction<IT, OT>> clazz = (Class<MapFunction<IT, OT>>) (Class<?>) MapFunction.class.     return clazz. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 0. }
false;public;0;4;;@Override public void prepare() { // nothing, since a mapper does not need any preparation }
false;public;0;26;;@Override public void run() throws Exception {     final Counter numRecordsIn = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsInCounter().     final Counter numRecordsOut = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsOutCounter().     // cache references on the stack     final MutableObjectIterator<IT> input = this.taskContext.getInput(0).     final MapFunction<IT, OT> function = this.taskContext.getStub().     final Collector<OT> output = new CountingCollector<>(this.taskContext.getOutputCollector(), numRecordsOut).     if (objectReuseEnabled) {         IT record = this.taskContext.<IT>getInputSerializer(0).getSerializer().createInstance().         while (this.running && ((record = input.next(record)) != null)) {             numRecordsIn.inc().             output.collect(function.map(record)).         }     } else {         IT record = null.         while (this.running && ((record = input.next()) != null)) {             numRecordsIn.inc().             output.collect(function.map(record)).         }     } }
false;public;0;4;;@Override public void cleanup() { // mappers need no cleanup, since no strategies are used. }
false;public;0;4;;@Override public void cancel() {     this.running = false. }
