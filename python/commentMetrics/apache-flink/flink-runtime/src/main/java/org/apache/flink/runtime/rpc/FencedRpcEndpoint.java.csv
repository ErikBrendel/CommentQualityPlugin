commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public F getFencingToken() {     return fencingToken. }
false;protected;1;14;;protected void setFencingToken(@Nullable F newFencingToken) {     // this method should only be called from within the main thread     validateRunsInMainThread().     this.fencingToken = newFencingToken.     // setting a new fencing token entails that we need a new MainThreadExecutor     // which is bound to the new fencing token     MainThreadExecutable mainThreadExecutable = getRpcService().fenceRpcServer(rpcServer, newFencingToken).     this.fencedMainThreadExecutor = new MainThreadExecutor(mainThreadExecutable, this::validateRunsInMainThread). }
true;protected;0;4;/**  * Returns a main thread executor which is bound to the currently valid fencing token.  * This means that runnables which are executed with this executor fail after the fencing  * token has changed. This allows to scope operations by the fencing token.  *  * @return MainThreadExecutor bound to the current fencing token  */ ;/**  * Returns a main thread executor which is bound to the currently valid fencing token.  * This means that runnables which are executed with this executor fail after the fencing  * token has changed. This allows to scope operations by the fencing token.  *  * @return MainThreadExecutor bound to the current fencing token  */ @Override protected MainThreadExecutor getMainThreadExecutor() {     return fencedMainThreadExecutor. }
true;protected;0;3;/**  * Returns a main thread executor which is not bound to the fencing token.  * This means that {@link Runnable} which are executed with this executor will always  * be executed.  *  * @return MainThreadExecutor which is not bound to the fencing token  */ ;/**  * Returns a main thread executor which is not bound to the fencing token.  * This means that {@link Runnable} which are executed with this executor will always  * be executed.  *  * @return MainThreadExecutor which is not bound to the fencing token  */ protected Executor getUnfencedMainThreadExecutor() {     return unfencedMainThreadExecutor. }
true;protected;1;7;/**  * Run the given runnable in the main thread of the RpcEndpoint without checking the fencing  * token. This allows to run operations outside of the fencing token scope.  *  * @param runnable to execute in the main thread of the rpc endpoint without checking the fencing token.  */ ;/**  * Run the given runnable in the main thread of the RpcEndpoint without checking the fencing  * token. This allows to run operations outside of the fencing token scope.  *  * @param runnable to execute in the main thread of the rpc endpoint without checking the fencing token.  */ protected void runAsyncWithoutFencing(Runnable runnable) {     if (rpcServer instanceof FencedMainThreadExecutable) {         ((FencedMainThreadExecutable) rpcServer).runAsyncWithoutFencing(runnable).     } else {         throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.").     } }
true;protected;2;7;/**  * Run the given callable in the main thread of the RpcEndpoint without checking the fencing  * token. This allows to run operations outside of the fencing token scope.  *  * @param callable to run in the main thread of the rpc endpoint without checkint the fencing token.  * @param timeout for the operation.  * @return Future containing the callable result.  */ ;/**  * Run the given callable in the main thread of the RpcEndpoint without checking the fencing  * token. This allows to run operations outside of the fencing token scope.  *  * @param callable to run in the main thread of the rpc endpoint without checkint the fencing token.  * @param timeout for the operation.  * @return Future containing the callable result.  */ protected <V> CompletableFuture<V> callAsyncWithoutFencing(Callable<V> callable, Time timeout) {     if (rpcServer instanceof FencedMainThreadExecutable) {         return ((FencedMainThreadExecutable) rpcServer).callAsyncWithoutFencing(callable, timeout).     } else {         throw new RuntimeException("FencedRpcEndpoint has not been started with a FencedMainThreadExecutable RpcServer.").     } }
false;public;1;4;;@Override public void execute(@Nonnull Runnable runnable) {     gateway.runAsyncWithoutFencing(runnable). }
