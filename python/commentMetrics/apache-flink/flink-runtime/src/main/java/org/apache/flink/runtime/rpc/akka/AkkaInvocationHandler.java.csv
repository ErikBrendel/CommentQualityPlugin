commented;modifiers;parameterAmount;loc;comment;code
false;public;3;24;;@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     Class<?> declaringClass = method.getDeclaringClass().     Object result.     if (declaringClass.equals(AkkaBasedEndpoint.class) || declaringClass.equals(Object.class) || declaringClass.equals(RpcGateway.class) || declaringClass.equals(StartStoppable.class) || declaringClass.equals(MainThreadExecutable.class) || declaringClass.equals(RpcServer.class)) {         result = method.invoke(this, args).     } else if (declaringClass.equals(FencedRpcGateway.class)) {         throw new UnsupportedOperationException("AkkaInvocationHandler does not support the call FencedRpcGateway#" + method.getName() + ". This indicates that you retrieved a FencedRpcGateway without specifying a " + "fencing token. Please use RpcService#connect(RpcService, F, Time) with F being the fencing token to " + "retrieve a properly FencedRpcGateway.").     } else {         result = invokeRpc(method, args).     }     return result. }
false;public;0;4;;@Override public ActorRef getActorRef() {     return rpcEndpoint. }
false;public;1;4;;@Override public void runAsync(Runnable runnable) {     scheduleRunAsync(runnable, 0L). }
false;public;2;13;;@Override public void scheduleRunAsync(Runnable runnable, long delayMillis) {     checkNotNull(runnable, "runnable").     checkArgument(delayMillis >= 0, "delay must be zero or greater").     if (isLocal) {         long atTimeNanos = delayMillis == 0 ? 0 : System.nanoTime() + (delayMillis * 1_000_000).         tell(new RunAsync(runnable, atTimeNanos)).     } else {         throw new RuntimeException("Trying to send a Runnable to a remote actor at " + rpcEndpoint.path() + ". This is not supported.").     } }
false;public;2;12;;@Override public <V> CompletableFuture<V> callAsync(Callable<V> callable, Time callTimeout) {     if (isLocal) {         @SuppressWarnings("unchecked")         CompletableFuture<V> resultFuture = (CompletableFuture<V>) ask(new CallAsync(callable), callTimeout).         return resultFuture.     } else {         throw new RuntimeException("Trying to send a Callable to a remote actor at " + rpcEndpoint.path() + ". This is not supported.").     } }
false;public;0;4;;@Override public void start() {     rpcEndpoint.tell(ControlMessages.START, ActorRef.noSender()). }
false;public;0;4;;@Override public void stop() {     rpcEndpoint.tell(ControlMessages.STOP, ActorRef.noSender()). }
true;private;2;47;/**  * Invokes a RPC method by sending the RPC invocation details to the rpc endpoint.  *  * @param method to call  * @param args of the method call  * @return result of the RPC  * @throws Exception if the RPC invocation fails  */ ;// ------------------------------------------------------------------------ // Private methods // ------------------------------------------------------------------------ /**  * Invokes a RPC method by sending the RPC invocation details to the rpc endpoint.  *  * @param method to call  * @param args of the method call  * @return result of the RPC  * @throws Exception if the RPC invocation fails  */ private Object invokeRpc(Method method, Object[] args) throws Exception {     String methodName = method.getName().     Class<?>[] parameterTypes = method.getParameterTypes().     Annotation[][] parameterAnnotations = method.getParameterAnnotations().     Time futureTimeout = extractRpcTimeout(parameterAnnotations, args, timeout).     final RpcInvocation rpcInvocation = createRpcInvocationMessage(methodName, parameterTypes, args).     Class<?> returnType = method.getReturnType().     final Object result.     if (Objects.equals(returnType, Void.TYPE)) {         tell(rpcInvocation).         result = null.     } else {         // execute an asynchronous call         CompletableFuture<?> resultFuture = ask(rpcInvocation, futureTimeout).         CompletableFuture<?> completableFuture = resultFuture.thenApply((Object o) -> {             if (o instanceof SerializedValue) {                 try {                     return ((SerializedValue<?>) o).deserializeValue(getClass().getClassLoader()).                 } catch (IOException | ClassNotFoundException e) {                     throw new CompletionException(new RpcException("Could not deserialize the serialized payload of RPC method : " + methodName, e)).                 }             } else {                 return o.             }         }).         if (Objects.equals(returnType, CompletableFuture.class)) {             result = completableFuture.         } else {             try {                 result = completableFuture.get(futureTimeout.getSize(), futureTimeout.getUnit()).             } catch (ExecutionException ee) {                 throw new RpcException("Failure while obtaining synchronous RPC result.", ExceptionUtils.stripExecutionException(ee)).             }         }     }     return result. }
true;protected;3;31;/**  * Create the RpcInvocation message for the given RPC.  *  * @param methodName of the RPC  * @param parameterTypes of the RPC  * @param args of the RPC  * @return RpcInvocation message which encapsulates the RPC details  * @throws IOException if we cannot serialize the RPC invocation parameters  */ ;/**  * Create the RpcInvocation message for the given RPC.  *  * @param methodName of the RPC  * @param parameterTypes of the RPC  * @param args of the RPC  * @return RpcInvocation message which encapsulates the RPC details  * @throws IOException if we cannot serialize the RPC invocation parameters  */ protected RpcInvocation createRpcInvocationMessage(final String methodName, final Class<?>[] parameterTypes, final Object[] args) throws IOException {     final RpcInvocation rpcInvocation.     if (isLocal) {         rpcInvocation = new LocalRpcInvocation(methodName, parameterTypes, args).     } else {         try {             RemoteRpcInvocation remoteRpcInvocation = new RemoteRpcInvocation(methodName, parameterTypes, args).             if (remoteRpcInvocation.getSize() > maximumFramesize) {                 throw new IOException("The rpc invocation size exceeds the maximum akka framesize.").             } else {                 rpcInvocation = remoteRpcInvocation.             }         } catch (IOException e) {             LOG.warn("Could not create remote rpc invocation message. Failing rpc invocation because...", e).             throw e.         }     }     return rpcInvocation. }
true;private,static;3;19;/**  * Extracts the {@link RpcTimeout} annotated rpc timeout value from the list of given method  * arguments. If no {@link RpcTimeout} annotated parameter could be found, then the default  * timeout is returned.  *  * @param parameterAnnotations Parameter annotations  * @param args Array of arguments  * @param defaultTimeout Default timeout to return if no {@link RpcTimeout} annotated parameter  *                       has been found  * @return Timeout extracted from the array of arguments or the default timeout  */ ;// ------------------------------------------------------------------------ // Helper methods // ------------------------------------------------------------------------ /**  * Extracts the {@link RpcTimeout} annotated rpc timeout value from the list of given method  * arguments. If no {@link RpcTimeout} annotated parameter could be found, then the default  * timeout is returned.  *  * @param parameterAnnotations Parameter annotations  * @param args Array of arguments  * @param defaultTimeout Default timeout to return if no {@link RpcTimeout} annotated parameter  *                       has been found  * @return Timeout extracted from the array of arguments or the default timeout  */ private static Time extractRpcTimeout(Annotation[][] parameterAnnotations, Object[] args, Time defaultTimeout) {     if (args != null) {         Preconditions.checkArgument(parameterAnnotations.length == args.length).         for (int i = 0. i < parameterAnnotations.length. i++) {             if (isRpcTimeout(parameterAnnotations[i])) {                 if (args[i] instanceof Time) {                     return (Time) args[i].                 } else {                     throw new RuntimeException("The rpc timeout parameter must be of type " + Time.class.getName() + ". The type " + args[i].getClass().getName() + " is not supported.").                 }             }         }     }     return defaultTimeout. }
true;private,static;1;9;/**  * Checks whether any of the annotations is of type {@link RpcTimeout}.  *  * @param annotations Array of annotations  * @return True if {@link RpcTimeout} was found. otherwise false  */ ;/**  * Checks whether any of the annotations is of type {@link RpcTimeout}.  *  * @param annotations Array of annotations  * @return True if {@link RpcTimeout} was found. otherwise false  */ private static boolean isRpcTimeout(Annotation[] annotations) {     for (Annotation annotation : annotations) {         if (annotation.annotationType().equals(RpcTimeout.class)) {             return true.         }     }     return false. }
true;protected;1;3;/**  * Sends the message to the RPC endpoint.  *  * @param message to send to the RPC endpoint.  */ ;/**  * Sends the message to the RPC endpoint.  *  * @param message to send to the RPC endpoint.  */ protected void tell(Object message) {     rpcEndpoint.tell(message, ActorRef.noSender()). }
true;protected;2;4;/**  * Sends the message to the RPC endpoint and returns a future containing  * its response.  *  * @param message to send to the RPC endpoint  * @param timeout time to wait until the response future is failed with a {@link TimeoutException}  * @return Response future  */ ;/**  * Sends the message to the RPC endpoint and returns a future containing  * its response.  *  * @param message to send to the RPC endpoint  * @param timeout time to wait until the response future is failed with a {@link TimeoutException}  * @return Response future  */ protected CompletableFuture<?> ask(Object message, Time timeout) {     return FutureUtils.toJava(Patterns.ask(rpcEndpoint, message, timeout.toMilliseconds())). }
false;public;0;4;;@Override public String getAddress() {     return address. }
false;public;0;4;;@Override public String getHostname() {     return hostname. }
false;public;0;4;;@Override public CompletableFuture<Void> getTerminationFuture() {     return terminationFuture. }
