commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isBuffer() {     return isBuffer. }
false;public;0;6;;@Override public void tagAsEvent() {     ensureAccessible().     isBuffer = false. }
false;public;0;6;;@Override public MemorySegment getMemorySegment() {     ensureAccessible().     return memorySegment. }
false;public;0;4;;@Override public int getMemorySegmentOffset() {     return 0. }
false;public;0;4;;@Override public BufferRecycler getRecycler() {     return recycler. }
false;public;0;4;;@Override public void recycleBuffer() {     release(). }
false;public;0;4;;@Override public boolean isRecycled() {     return refCnt() == 0. }
false;public;0;4;;@Override public NetworkBuffer retainBuffer() {     return (NetworkBuffer) super.retain(). }
false;public;0;4;;@Override public ReadOnlySlicedNetworkBuffer readOnlySlice() {     return readOnlySlice(readerIndex(), readableBytes()). }
false;public;2;4;;@Override public ReadOnlySlicedNetworkBuffer readOnlySlice(int index, int length) {     return new ReadOnlySlicedNetworkBuffer(this, index, length). }
false;protected;0;4;;@Override protected void deallocate() {     recycler.recycle(memorySegment). }
false;protected;1;4;;@Override protected byte _getByte(int index) {     return memorySegment.get(index). }
false;protected;1;4;;@Override protected short _getShort(int index) {     return memorySegment.getShortBigEndian(index). }
false;protected;1;4;;@Override protected short _getShortLE(int index) {     return memorySegment.getShortLittleEndian(index). }
false;protected;1;5;;@Override protected int _getUnsignedMedium(int index) {     // from UnpooledDirectByteBuf:     return (getByte(index) & 0xff) << 16 | (getByte(index + 1) & 0xff) << 8 | getByte(index + 2) & 0xff. }
false;protected;1;5;;@Override protected int _getUnsignedMediumLE(int index) {     // from UnpooledDirectByteBuf:     return getByte(index) & 255 | (getByte(index + 1) & 255) << 8 | (getByte(index + 2) & 255) << 16. }
false;protected;1;4;;@Override protected int _getInt(int index) {     return memorySegment.getIntBigEndian(index). }
false;protected;1;4;;@Override protected int _getIntLE(int index) {     return memorySegment.getIntLittleEndian(index). }
false;protected;1;4;;@Override protected long _getLong(int index) {     return memorySegment.getLongBigEndian(index). }
false;protected;1;4;;@Override protected long _getLongLE(int index) {     return memorySegment.getLongLittleEndian(index). }
false;protected;2;4;;@Override protected void _setByte(int index, int value) {     memorySegment.put(index, (byte) value). }
false;protected;2;4;;@Override protected void _setShort(int index, int value) {     memorySegment.putShortBigEndian(index, (short) value). }
false;protected;2;4;;@Override protected void _setShortLE(int index, int value) {     memorySegment.putShortLittleEndian(index, (short) value). }
false;protected;2;7;;@Override protected void _setMedium(int index, int value) {     // from UnpooledDirectByteBuf:     setByte(index, (byte) (value >>> 16)).     setByte(index + 1, (byte) (value >>> 8)).     setByte(index + 2, (byte) value). }
false;protected;2;7;;@Override protected void _setMediumLE(int index, int value) {     // from UnpooledDirectByteBuf:     setByte(index, (byte) value).     setByte(index + 1, (byte) (value >>> 8)).     setByte(index + 2, (byte) (value >>> 16)). }
false;protected;2;4;;@Override protected void _setInt(int index, int value) {     memorySegment.putIntBigEndian(index, value). }
false;protected;2;4;;@Override protected void _setIntLE(int index, int value) {     memorySegment.putIntLittleEndian(index, value). }
false;protected;2;4;;@Override protected void _setLong(int index, long value) {     memorySegment.putLongBigEndian(index, value). }
false;protected;2;4;;@Override protected void _setLongLE(int index, long value) {     memorySegment.putLongLittleEndian(index, value). }
false;public;0;4;;@Override public int capacity() {     return currentSize. }
false;public;0;4;;@Override public int getMaxCapacity() {     return maxCapacity(). }
false;public;0;4;;@Override public int getReaderIndex() {     return readerIndex(). }
false;public;1;4;;@Override public void setReaderIndex(int readerIndex) throws IndexOutOfBoundsException {     readerIndex(readerIndex). }
false;public;0;4;;@Override public int getSizeUnsafe() {     return writerIndex(). }
false;public;0;4;;@Override public int getSize() {     return writerIndex(). }
false;public;1;4;;@Override public void setSize(int writerIndex) {     writerIndex(writerIndex). }
false;public;1;12;;@Override public ByteBuf capacity(int newCapacity) {     ensureAccessible().     if (newCapacity < 0 || newCapacity > maxCapacity()) {         throw new IllegalArgumentException("Size of buffer must be >= 0 and <= " + memorySegment.size() + ", but was " + newCapacity + ".").     }     this.currentSize = newCapacity.     return this. }
false;public;0;4;;@Override public ByteOrder order() {     return ByteOrder.BIG_ENDIAN. }
false;public;0;5;;@Override public ByteBuf unwrap() {     // not a wrapper of another buffer     return null. }
false;public;0;4;;@Override public boolean isDirect() {     return memorySegment.isOffHeap(). }
false;public;4;18;;@Override public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {     // from UnpooledDirectByteBuf:     checkDstIndex(index, length, dstIndex, dst.capacity()).     if (dst.hasArray()) {         getBytes(index, dst.array(), dst.arrayOffset() + dstIndex, length).     } else if (dst.nioBufferCount() > 0) {         for (ByteBuffer bb : dst.nioBuffers(dstIndex, length)) {             int bbLen = bb.remaining().             getBytes(index, bb).             index += bbLen.         }     } else {         dst.setBytes(dstIndex, this, index, length).     }     return this. }
false;public;4;7;;@Override public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {     checkDstIndex(index, length, dstIndex, dst.length).     memorySegment.get(index, dst, dstIndex, length).     return this. }
false;public;2;7;;@Override public ByteBuf getBytes(int index, ByteBuffer dst) {     checkIndex(index, dst.remaining()).     memorySegment.get(index, dst, dst.remaining()).     return this. }
false;public;3;19;;@Override public ByteBuf getBytes(int index, OutputStream out, int length) throws IOException {     // adapted from UnpooledDirectByteBuf:     checkIndex(index, length).     if (length == 0) {         return this.     }     if (memorySegment.isOffHeap()) {         byte[] tmp = new byte[length].         ByteBuffer tmpBuf = memorySegment.wrap(index, length).         tmpBuf.get(tmp).         out.write(tmp).     } else {         out.write(memorySegment.getArray(), index, length).     }     return this. }
false;public;3;11;;@Override public int getBytes(int index, GatheringByteChannel out, int length) throws IOException {     // adapted from UnpooledDirectByteBuf:     checkIndex(index, length).     if (length == 0) {         return 0.     }     ByteBuffer tmpBuf = memorySegment.wrap(index, length).     return out.write(tmpBuf). }
false;public;4;11;;@Override public int getBytes(int index, FileChannel out, long position, int length) throws IOException {     // adapted from UnpooledDirectByteBuf:     checkIndex(index, length).     if (length == 0) {         return 0.     }     ByteBuffer tmpBuf = memorySegment.wrap(index, length).     return out.write(tmpBuf, position). }
false;public;4;15;;@Override public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {     // from UnpooledDirectByteBuf:     checkSrcIndex(index, length, srcIndex, src.capacity()).     if (src.nioBufferCount() > 0) {         for (ByteBuffer bb : src.nioBuffers(srcIndex, length)) {             int bbLen = bb.remaining().             setBytes(index, bb).             index += bbLen.         }     } else {         src.getBytes(srcIndex, this, index, length).     }     return this. }
false;public;4;9;;@Override public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {     // adapted from UnpooledDirectByteBuf:     checkSrcIndex(index, length, srcIndex, src.length).     ByteBuffer tmpBuf = memorySegment.wrap(index, length).     tmpBuf.put(src, srcIndex, length).     return this. }
false;public;2;9;;@Override public ByteBuf setBytes(int index, ByteBuffer src) {     // adapted from UnpooledDirectByteBuf:     checkIndex(index, src.remaining()).     ByteBuffer tmpBuf = memorySegment.wrap(index, src.remaining()).     tmpBuf.put(src).     return this. }
false;public;3;18;;@Override public int setBytes(int index, InputStream in, int length) throws IOException {     // adapted from UnpooledDirectByteBuf:     checkIndex(index, length).     if (memorySegment.isOffHeap()) {         byte[] tmp = new byte[length].         int readBytes = in.read(tmp).         if (readBytes <= 0) {             return readBytes.         }         ByteBuffer tmpBuf = memorySegment.wrap(index, length).         tmpBuf.put(tmp, 0, readBytes).         return readBytes.     } else {         return in.read(memorySegment.getArray(), index, length).     } }
false;public;3;12;;@Override public int setBytes(int index, ScatteringByteChannel in, int length) throws IOException {     // adapted from UnpooledDirectByteBuf:     checkIndex(index, length).     ByteBuffer tmpBuf = memorySegment.wrap(index, length).     try {         return in.read(tmpBuf).     } catch (ClosedChannelException ignored) {         return -1.     } }
false;public;4;12;;@Override public int setBytes(int index, FileChannel in, long position, int length) throws IOException {     // adapted from UnpooledDirectByteBuf:     checkIndex(index, length).     ByteBuffer tmpBuf = memorySegment.wrap(index, length).     try {         return in.read(tmpBuf, position).     } catch (ClosedChannelException ignored) {         return -1.     } }
false;public;0;4;;@Override public ByteBufAllocator alloc() {     return checkNotNull(allocator). }
false;public;1;4;;@Override public void setAllocator(ByteBufAllocator allocator) {     this.allocator = allocator. }
false;public;2;8;;@Override public ByteBuf copy(int index, int length) {     checkIndex(index, length).     ByteBuf copy = alloc().buffer(length, maxCapacity()).     copy.writeBytes(this, index, length).     return copy. }
false;public;1;14;;@Override public ByteBuf readBytes(int length) {     // copied from the one in netty 4.0.50 fixing the wrong allocator being used     checkReadableBytes(length).     if (length == 0) {         return Unpooled.EMPTY_BUFFER.     }     ByteBuf buf = alloc().buffer(length, maxCapacity()).     int readerIndex = readerIndex().     buf.writeBytes(this, readerIndex, length).     readerIndex(readerIndex + length).     return buf. }
false;public;0;4;;@Override public int nioBufferCount() {     return 1. }
false;public;0;4;;@Override public ByteBuffer getNioBufferReadable() {     return nioBuffer(). }
false;public;2;4;;@Override public ByteBuffer getNioBuffer(int index, int length) {     return nioBuffer(index, length). }
false;public;2;5;;@Override public ByteBuffer nioBuffer(int index, int length) {     checkIndex(index, length).     return memorySegment.wrap(index, length).slice(). }
false;public;2;4;;@Override public ByteBuffer internalNioBuffer(int index, int length) {     return nioBuffer(index, length). }
false;public;2;4;;@Override public ByteBuffer[] nioBuffers(int index, int length) {     return new ByteBuffer[] { nioBuffer(index, length) }. }
false;public;0;4;;@Override public boolean hasArray() {     return !memorySegment.isOffHeap(). }
false;public;0;6;;@Override public byte[] array() {     ensureAccessible().     return memorySegment.getArray(). }
false;public;0;4;;@Override public int arrayOffset() {     return 0. }
false;public;0;4;;@Override public boolean hasMemoryAddress() {     return memorySegment.isOffHeap(). }
false;public;0;4;;@Override public long memoryAddress() {     return memorySegment.getAddress(). }
false;public;0;18;;@Override public String toString() {     if (refCnt() == 0) {         return String.format("Buffer %s (freed)", hashCode()).     }     StringBuilder buf = new StringBuilder().append("Buffer ").append(hashCode()).append(" (ridx: ").append(readerIndex()).append(", widx: ").append(writerIndex()).append(", cap: ").append(capacity()).     if (maxCapacity() != Integer.MAX_VALUE) {         buf.append('/').append(maxCapacity()).     }     buf.append(", ref count: ").append(refCnt()).append(')').     return buf.toString(). }
false;public;0;4;;@Override public ByteBuf asByteBuf() {     return this. }
