commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;// ------------------------------------------------------------------------ public void reopen(Iterator<T> input) throws IOException {     this.input = input.     this.noMoreBlocks = false.     this.closed = false.     nextBlock(). }
false;public;0;35;;@Override public boolean hasNext() {     try {         if (this.nextElement == null) {             if (this.readPhase) {                 // read phase, get next element from buffer                 T tmp = getNextRecord().                 if (tmp != null) {                     this.nextElement = tmp.                     return true.                 } else {                     return false.                 }             } else {                 if (this.input.hasNext()) {                     final T next = this.input.next().                     if (writeNextRecord(next)) {                         this.nextElement = next.                         return true.                     } else {                         this.leftOverElement = next.                         return false.                     }                 } else {                     this.noMoreBlocks = true.                     return false.                 }             }         } else {             return true.         }     } catch (IOException ioex) {         throw new RuntimeException("Error (de)serializing record in block resettable iterator.", ioex).     } }
false;public;0;12;;@Override public T next() {     if (this.nextElement == null) {         if (!hasNext()) {             throw new NoSuchElementException().         }     }     T out = this.nextElement.     this.nextElement = null.     return out. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;5;;public void reset() {     // a reset always goes to the read phase     this.readPhase = true.     super.reset(). }
false;public;0;38;;@Override public boolean nextBlock() throws IOException {     // check the state     if (this.closed) {         throw new IllegalStateException("Iterator has been closed.").     }     // check whether more blocks are available     if (this.noMoreBlocks) {         return false.     }     // reset the views in the superclass     super.nextBlock().     T next = this.leftOverElement.     this.leftOverElement = null.     if (next == null) {         if (this.input.hasNext()) {             next = this.input.next().         } else {             this.noMoreBlocks = true.             return false.         }     }     // write the leftover record     if (!writeNextRecord(next)) {         throw new IOException("BlockResettableIterator could not serialize record into fresh memory block: " + "Record is too large.").     }     this.nextElement = next.     this.readPhase = false.     return true. }
true;public;0;3;/**  * Checks, whether the input that is blocked by this iterator, has further elements  * available. This method may be used to forecast (for example at the point where a  * block is full) whether there will be more data (possibly in another block).  *  * @return True, if there will be more data, false otherwise.  */ ;/**  * Checks, whether the input that is blocked by this iterator, has further elements  * available. This method may be used to forecast (for example at the point where a  * block is full) whether there will be more data (possibly in another block).  *  * @return True, if there will be more data, false otherwise.  */ public boolean hasFurtherInput() {     return !this.noMoreBlocks. }
false;public;0;6;;public void close() {     // suggest that we are in the read phase. because nothing is in the current block,     // read requests will fail     this.readPhase = true.     super.close(). }
