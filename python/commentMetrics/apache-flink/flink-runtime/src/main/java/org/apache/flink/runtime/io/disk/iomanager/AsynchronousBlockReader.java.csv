commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Issues a read request, which will asynchronously fill the given segment with the next block in the  * underlying file channel. Once the read request is fulfilled, the segment will be added to this reader's  * return queue.  *  * @param segment The segment to read the block into.  * @throws IOException Thrown, when the reader encounters an I/O error. Due to the asynchronous nature of the  *                     reader, the exception thrown here may have been caused by an earlier read request.  */ ;/**  * Issues a read request, which will asynchronously fill the given segment with the next block in the  * underlying file channel. Once the read request is fulfilled, the segment will be added to this reader's  * return queue.  *  * @param segment The segment to read the block into.  * @throws IOException Thrown, when the reader encounters an I/O error. Due to the asynchronous nature of the  *                     reader, the exception thrown here may have been caused by an earlier read request.  */ @Override public void readBlock(MemorySegment segment) throws IOException {     addRequest(new SegmentReadRequest(this, segment)). }
false;public;1;4;;@Override public void seekToPosition(long position) throws IOException {     requestQueue.add(new SeekRequest(this, position)). }
true;public;0;18;/**  * Gets the next memory segment that has been filled with data by the reader. This method blocks until  * such a segment is available, or until an error occurs in the reader, or the reader is closed.  * <p>  * WARNING: If this method is invoked without any segment ever returning (for example, because the  * {@link #readBlock(MemorySegment)} method has not been invoked appropriately), the method may block  * forever.  *  * @return The next memory segment from the reader's return queue.  * @throws IOException Thrown, if an I/O error occurs in the reader while waiting for the request to return.  */ ;/**  * Gets the next memory segment that has been filled with data by the reader. This method blocks until  * such a segment is available, or until an error occurs in the reader, or the reader is closed.  * <p>  * WARNING: If this method is invoked without any segment ever returning (for example, because the  * {@link #readBlock(MemorySegment)} method has not been invoked appropriately), the method may block  * forever.  *  * @return The next memory segment from the reader's return queue.  * @throws IOException Thrown, if an I/O error occurs in the reader while waiting for the request to return.  */ @Override public MemorySegment getNextReturnedBlock() throws IOException {     try {         while (true) {             final MemorySegment next = this.returnSegments.poll(1000, TimeUnit.MILLISECONDS).             if (next != null) {                 return next.             } else {                 if (this.closed) {                     throw new IOException("The reader has been asynchronously closed.").                 }                 checkErroneous().             }         }     } catch (InterruptedException iex) {         throw new IOException("Reader was interrupted while waiting for the next returning segment.").     } }
true;public;0;4;/**  * Gets the queue in which the full memory segments are queued after the asynchronous read  * is complete.  *  * @return The queue with the full memory segments.  */ ;/**  * Gets the queue in which the full memory segments are queued after the asynchronous read  * is complete.  *  * @return The queue with the full memory segments.  */ @Override public LinkedBlockingQueue<MemorySegment> getReturnQueue() {     return this.returnSegments. }
