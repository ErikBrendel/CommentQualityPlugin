commented;modifiers;parameterAmount;loc;comment;code
true;public;4;18;/**  * Start the job leader service with the given services.  *  * @param initialOwnerAddress to be used for establishing connections (source address)  * @param initialRpcService to be used to create rpc connections  * @param initialHighAvailabilityServices to create leader retrieval services for the different jobs  * @param initialJobLeaderListener listening for job leader changes  */ ;// ------------------------------------------------------------------------------- // Methods // ------------------------------------------------------------------------------- /**  * Start the job leader service with the given services.  *  * @param initialOwnerAddress to be used for establishing connections (source address)  * @param initialRpcService to be used to create rpc connections  * @param initialHighAvailabilityServices to create leader retrieval services for the different jobs  * @param initialJobLeaderListener listening for job leader changes  */ public void start(final String initialOwnerAddress, final RpcService initialRpcService, final HighAvailabilityServices initialHighAvailabilityServices, final JobLeaderListener initialJobLeaderListener) {     if (JobLeaderService.State.CREATED != state) {         throw new IllegalStateException("The service has already been started.").     } else {         LOG.info("Start job leader service.").         this.ownerAddress = Preconditions.checkNotNull(initialOwnerAddress).         this.rpcService = Preconditions.checkNotNull(initialRpcService).         this.highAvailabilityServices = Preconditions.checkNotNull(initialHighAvailabilityServices).         this.jobLeaderListener = Preconditions.checkNotNull(initialJobLeaderListener).         state = JobLeaderService.State.STARTED.     } }
true;public;0;18;/**  * Stop the job leader services. This implies stopping all leader retrieval services for the  * different jobs and their leader retrieval listeners.  *  * @throws Exception if an error occurs while stopping the service  */ ;/**  * Stop the job leader services. This implies stopping all leader retrieval services for the  * different jobs and their leader retrieval listeners.  *  * @throws Exception if an error occurs while stopping the service  */ public void stop() throws Exception {     LOG.info("Stop job leader service.").     if (JobLeaderService.State.STARTED == state) {         for (Tuple2<LeaderRetrievalService, JobLeaderService.JobManagerLeaderListener> leaderRetrievalServiceEntry : jobLeaderServices.values()) {             LeaderRetrievalService leaderRetrievalService = leaderRetrievalServiceEntry.f0.             JobLeaderService.JobManagerLeaderListener jobManagerLeaderListener = leaderRetrievalServiceEntry.f1.             jobManagerLeaderListener.stop().             leaderRetrievalService.stop().         }         jobLeaderServices.clear().     }     state = JobLeaderService.State.STOPPED. }
true;public;1;15;/**  * Remove the given job from being monitored by the job leader service.  *  * @param jobId identifying the job to remove from monitoring  * @throws Exception if an error occurred while stopping the leader retrieval service and listener  */ ;/**  * Remove the given job from being monitored by the job leader service.  *  * @param jobId identifying the job to remove from monitoring  * @throws Exception if an error occurred while stopping the leader retrieval service and listener  */ public void removeJob(JobID jobId) throws Exception {     Preconditions.checkState(JobLeaderService.State.STARTED == state, "The service is currently not running.").     Tuple2<LeaderRetrievalService, JobLeaderService.JobManagerLeaderListener> entry = jobLeaderServices.remove(jobId).     if (entry != null) {         LOG.info("Remove job {} from job leader monitoring.", jobId).         LeaderRetrievalService leaderRetrievalService = entry.f0.         JobLeaderService.JobManagerLeaderListener jobManagerLeaderListener = entry.f1.         leaderRetrievalService.stop().         jobManagerLeaderListener.stop().     } }
true;public;2;20;/**  * Add the given job to be monitored. This means that the service tries to detect leaders for  * this job and then tries to establish a connection to it.  *  * @param jobId identifying the job to monitor  * @param defaultTargetAddress of the job leader  * @throws Exception if an error occurs while starting the leader retrieval service  */ ;/**  * Add the given job to be monitored. This means that the service tries to detect leaders for  * this job and then tries to establish a connection to it.  *  * @param jobId identifying the job to monitor  * @param defaultTargetAddress of the job leader  * @throws Exception if an error occurs while starting the leader retrieval service  */ public void addJob(final JobID jobId, final String defaultTargetAddress) throws Exception {     Preconditions.checkState(JobLeaderService.State.STARTED == state, "The service is currently not running.").     LOG.info("Add job {} for job leader monitoring.", jobId).     final LeaderRetrievalService leaderRetrievalService = highAvailabilityServices.getJobManagerLeaderRetriever(jobId, defaultTargetAddress).     JobLeaderService.JobManagerLeaderListener jobManagerLeaderListener = new JobManagerLeaderListener(jobId).     final Tuple2<LeaderRetrievalService, JobManagerLeaderListener> oldEntry = jobLeaderServices.put(jobId, Tuple2.of(leaderRetrievalService, jobManagerLeaderListener)).     if (oldEntry != null) {         oldEntry.f0.stop().         oldEntry.f1.stop().     }     leaderRetrievalService.start(jobManagerLeaderListener). }
true;public;1;11;/**  * Triggers reconnection to the last known leader of the given job.  *  * @param jobId specifying the job for which to trigger reconnection  */ ;/**  * Triggers reconnection to the last known leader of the given job.  *  * @param jobId specifying the job for which to trigger reconnection  */ public void reconnect(final JobID jobId) {     Preconditions.checkNotNull(jobId, "JobID must not be null.").     final Tuple2<LeaderRetrievalService, JobManagerLeaderListener> jobLeaderService = jobLeaderServices.get(jobId).     if (jobLeaderService != null) {         jobLeaderService.f1.reconnect().     } else {         LOG.info("Cannot reconnect to job {} because it is not registered.", jobId).     } }
false;public;0;7;;public void stop() {     stopped = true.     if (rpcConnection != null) {         rpcConnection.close().     } }
false;public;0;25;;public void reconnect() {     if (stopped) {         LOG.debug("Cannot reconnect because the JobManagerLeaderListener has already been stopped.").     } else {         final RegisteredRpcConnection<JobMasterId, JobMasterGateway, JMTMRegistrationSuccess> currentRpcConnection = rpcConnection.         if (currentRpcConnection != null) {             if (currentRpcConnection.isConnected()) {                 if (currentRpcConnection.tryReconnect()) {                     // double check for concurrent stop operation                     if (stopped) {                         currentRpcConnection.close().                     }                 } else {                     LOG.debug("Could not reconnect to the JobMaster {}.", currentRpcConnection.getTargetAddress()).                 }             } else {                 LOG.debug("Ongoing registration to JobMaster {}.", currentRpcConnection.getTargetAddress()).             }         } else {             LOG.debug("Cannot reconnect to an unknown JobMaster.").         }     } }
false;public;2;52;;@Override public void notifyLeaderAddress(@Nullable final String leaderAddress, @Nullable final UUID leaderId) {     if (stopped) {         LOG.debug("{}'s leader retrieval listener reported a new leader for job {}. " + "However, the service is no longer running.", JobLeaderService.class.getSimpleName(), jobId).     } else {         final JobMasterId jobMasterId = JobMasterId.fromUuidOrNull(leaderId).         LOG.debug("New leader information for job {}. Address: {}, leader id: {}.", jobId, leaderAddress, jobMasterId).         if (leaderAddress == null || leaderAddress.isEmpty()) {             // the leader lost leadership but there is no other leader yet.             if (rpcConnection != null) {                 rpcConnection.close().             }             jobLeaderListener.jobManagerLostLeadership(jobId, currentJobMasterId).             currentJobMasterId = jobMasterId.         } else {             currentJobMasterId = jobMasterId.             if (rpcConnection != null) {                 // check if we are already trying to connect to this leader                 if (!Objects.equals(jobMasterId, rpcConnection.getTargetLeaderId())) {                     rpcConnection.close().                     rpcConnection = new JobManagerRegisteredRpcConnection(LOG, leaderAddress, jobMasterId, rpcService.getExecutor()).                 }             } else {                 rpcConnection = new JobManagerRegisteredRpcConnection(LOG, leaderAddress, jobMasterId, rpcService.getExecutor()).             }             // double check for a concurrent stop operation             if (stopped) {                 rpcConnection.close().             } else {                 LOG.info("Try to register at job manager {} with leader id {}.", leaderAddress, leaderId).                 rpcConnection.start().             }         }     } }
false;public;1;10;;@Override public void handleError(Exception exception) {     if (stopped) {         LOG.debug("{}'s leader retrieval listener reported an exception for job {}. " + "However, the service is no longer running.", JobLeaderService.class.getSimpleName(), jobId, exception).     } else {         jobLeaderListener.handleError(exception).     } }
false;protected;0;13;;@Override protected RetryingRegistration<JobMasterId, JobMasterGateway, JMTMRegistrationSuccess> generateRegistration() {     return new JobLeaderService.JobManagerRetryingRegistration(LOG, rpcService, "JobManager", JobMasterGateway.class, getTargetAddress(), getTargetLeaderId(), retryingRegistrationConfiguration, ownerAddress, ownLocation). }
false;protected;1;11;;@Override protected void onRegistrationSuccess(JMTMRegistrationSuccess success) {     // filter out old registration attempts     if (Objects.equals(getTargetLeaderId(), currentJobMasterId)) {         log.info("Successful registration at job manager {} for job {}.", getTargetAddress(), jobId).         jobLeaderListener.jobManagerGainedLeadership(jobId, getTargetGateway(), success).     } else {         log.debug("Encountered obsolete JobManager registration success from {} with leader session ID {}.", getTargetAddress(), getTargetLeaderId()).     } }
false;protected;1;10;;@Override protected void onRegistrationFailure(Throwable failure) {     // filter out old registration attempts     if (Objects.equals(getTargetLeaderId(), currentJobMasterId)) {         log.info("Failed to register at job  manager {} for job {}.", getTargetAddress(), jobId).         jobLeaderListener.handleError(failure).     } else {         log.debug("Obsolete JobManager registration failure from {} with leader session ID {}.", getTargetAddress(), getTargetLeaderId(), failure).     } }
false;protected;3;7;;@Override protected CompletableFuture<RegistrationResponse> invokeRegistration(JobMasterGateway gateway, JobMasterId jobMasterId, long timeoutMillis) throws Exception {     return gateway.registerTaskManager(taskManagerRpcAddress, taskManagerLocation, Time.milliseconds(timeoutMillis)). }
true;public;1;6;/**  * Check whether the service monitors the given job.  *  * @param jobId identifying the job  * @return True if the given job is monitored. otherwise false  */ ;// ----------------------------------------------------------- // Testing methods // ----------------------------------------------------------- /**  * Check whether the service monitors the given job.  *  * @param jobId identifying the job  * @return True if the given job is monitored. otherwise false  */ @VisibleForTesting public boolean containsJob(JobID jobId) {     Preconditions.checkState(JobLeaderService.State.STARTED == state, "The service is currently not running.").     return jobLeaderServices.containsKey(jobId). }
