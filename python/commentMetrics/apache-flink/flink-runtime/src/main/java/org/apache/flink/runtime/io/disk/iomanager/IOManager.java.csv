commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isSynchronous() {     return isSynchronous. }
true;public;0;15;/**  * Close method, marks the I/O manager as closed  * and removed all temporary files.  */ ;/**  * Close method, marks the I/O manager as closed  * and removed all temporary files.  */ public void shutdown() {     // remove all of our temp directories     for (File path : paths) {         try {             if (path != null) {                 if (path.exists()) {                     FileUtils.deleteDirectory(path).                     LOG.info("I/O manager removed spill file directory {}", path.getAbsolutePath()).                 }             }         } catch (Throwable t) {             LOG.error("IOManager failed to properly clean up temp file directory: " + path, t).         }     } }
true;public;0;8;/**  * Utility method to check whether the IO manager has been properly shut down.  * For this base implementation, this means that all files have been removed.  *  * @return True, if the IO manager has properly shut down, false otherwise.  */ ;/**  * Utility method to check whether the IO manager has been properly shut down.  * For this base implementation, this means that all files have been removed.  *  * @return True, if the IO manager has properly shut down, false otherwise.  */ public boolean isProperlyShutDown() {     for (File path : paths) {         if (path != null && path.exists()) {             return false.         }     }     return true. }
true;public;0;4;/**  * Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple  * invocations of this method spread the channels evenly across the different directories.  *  * @return A channel to a temporary directory.  */ ;// ------------------------------------------------------------------------ // Channel Instantiations // ------------------------------------------------------------------------ /**  * Creates a new {@link FileIOChannel.ID} in one of the temp directories. Multiple  * invocations of this method spread the channels evenly across the different directories.  *  * @return A channel to a temporary directory.  */ public FileIOChannel.ID createChannel() {     final int num = getNextPathNum().     return new FileIOChannel.ID(this.paths[num], num, this.random). }
true;public;0;3;/**  * Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion  * across the temporary file directories.  *  * @return An enumerator for channels.  */ ;/**  * Creates a new {@link FileIOChannel.Enumerator}, spreading the channels in a round-robin fashion  * across the temporary file directories.  *  * @return An enumerator for channels.  */ public FileIOChannel.Enumerator createChannelEnumerator() {     return new FileIOChannel.Enumerator(this.paths, this.random). }
true;public;1;7;/**  * Deletes the file underlying the given channel. If the channel is still open, this  * call may fail.  *  * @param channel The channel to be deleted.  * @throws IOException Thrown if the deletion fails.  */ ;/**  * Deletes the file underlying the given channel. If the channel is still open, this  * call may fail.  *  * @param channel The channel to be deleted.  * @throws IOException Thrown if the deletion fails.  */ public void deleteChannel(FileIOChannel.ID channel) throws IOException {     if (channel != null) {         if (channel.getPathFile().exists() && !channel.getPathFile().delete()) {             LOG.warn("IOManager failed to delete temporary file {}", channel.getPath()).         }     } }
true;public;1;3;/**  * Creates a block channel writer that writes to the given channel. The writer adds the  * written segment to its return-queue afterwards (to allow for asynchronous implementations).  *  * @param channelID The descriptor for the channel to write to.  * @return A block channel writer that writes to the given channel.  * @throws IOException Thrown, if the channel for the writer could not be opened.  */ ;// ------------------------------------------------------------------------ // Reader / Writer instantiations // ------------------------------------------------------------------------ /**  * Creates a block channel writer that writes to the given channel. The writer adds the  * written segment to its return-queue afterwards (to allow for asynchronous implementations).  *  * @param channelID The descriptor for the channel to write to.  * @return A block channel writer that writes to the given channel.  * @throws IOException Thrown, if the channel for the writer could not be opened.  */ public BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID) throws IOException {     return createBlockChannelWriter(channelID, new LinkedBlockingQueue<MemorySegment>()). }
true;public,abstract;2;2;/**  * Creates a block channel writer that writes to the given channel. The writer adds the  * written segment to the given queue (to allow for asynchronous implementations).  *  * @param channelID The descriptor for the channel to write to.  * @param returnQueue The queue to put the written buffers into.  * @return A block channel writer that writes to the given channel.  * @throws IOException Thrown, if the channel for the writer could not be opened.  */ ;/**  * Creates a block channel writer that writes to the given channel. The writer adds the  * written segment to the given queue (to allow for asynchronous implementations).  *  * @param channelID The descriptor for the channel to write to.  * @param returnQueue The queue to put the written buffers into.  * @return A block channel writer that writes to the given channel.  * @throws IOException Thrown, if the channel for the writer could not be opened.  */ public abstract BlockChannelWriter<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException.
true;public,abstract;2;1;/**  * Creates a block channel writer that writes to the given channel. The writer calls the given callback  * after the I/O operation has been performed (successfully or unsuccessfully), to allow  * for asynchronous implementations.  *  * @param channelID The descriptor for the channel to write to.  * @param callback The callback to be called for  * @return A block channel writer that writes to the given channel.  * @throws IOException Thrown, if the channel for the writer could not be opened.  */ ;/**  * Creates a block channel writer that writes to the given channel. The writer calls the given callback  * after the I/O operation has been performed (successfully or unsuccessfully), to allow  * for asynchronous implementations.  *  * @param channelID The descriptor for the channel to write to.  * @param callback The callback to be called for  * @return A block channel writer that writes to the given channel.  * @throws IOException Thrown, if the channel for the writer could not be opened.  */ public abstract BlockChannelWriterWithCallback<MemorySegment> createBlockChannelWriter(FileIOChannel.ID channelID, RequestDoneCallback<MemorySegment> callback) throws IOException.
true;public;1;3;/**  * Creates a block channel reader that reads blocks from the given channel. The reader pushed  * full memory segments (with the read data) to its "return queue", to allow for asynchronous read  * implementations.  *  * @param channelID The descriptor for the channel to write to.  * @return A block channel reader that reads from the given channel.  * @throws IOException Thrown, if the channel for the reader could not be opened.  */ ;/**  * Creates a block channel reader that reads blocks from the given channel. The reader pushed  * full memory segments (with the read data) to its "return queue", to allow for asynchronous read  * implementations.  *  * @param channelID The descriptor for the channel to write to.  * @return A block channel reader that reads from the given channel.  * @throws IOException Thrown, if the channel for the reader could not be opened.  */ public BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID) throws IOException {     return createBlockChannelReader(channelID, new LinkedBlockingQueue<MemorySegment>()). }
true;public,abstract;2;2;/**  * Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments  * to the given queue, to allow for asynchronous implementations.  *  * @param channelID The descriptor for the channel to write to.  * @param returnQueue The queue to put the full buffers into.  * @return A block channel reader that reads from the given channel.  * @throws IOException Thrown, if the channel for the reader could not be opened.  */ ;/**  * Creates a block channel reader that reads blocks from the given channel. The reader pushes the full segments  * to the given queue, to allow for asynchronous implementations.  *  * @param channelID The descriptor for the channel to write to.  * @param returnQueue The queue to put the full buffers into.  * @return A block channel reader that reads from the given channel.  * @throws IOException Thrown, if the channel for the reader could not be opened.  */ public abstract BlockChannelReader<MemorySegment> createBlockChannelReader(FileIOChannel.ID channelID, LinkedBlockingQueue<MemorySegment> returnQueue) throws IOException.
false;public,abstract;1;1;;public abstract BufferFileWriter createBufferFileWriter(FileIOChannel.ID channelID) throws IOException.
false;public,abstract;2;1;;public abstract BufferFileReader createBufferFileReader(FileIOChannel.ID channelID, RequestDoneCallback<Buffer> callback) throws IOException.
false;public,abstract;2;1;;public abstract BufferFileSegmentReader createBufferFileSegmentReader(FileIOChannel.ID channelID, RequestDoneCallback<FileSegment> callback) throws IOException.
true;public,abstract;3;2;/**  * Creates a block channel reader that reads all blocks from the given channel directly in one bulk.  * The reader draws segments to read the blocks into from a supplied list, which must contain as many  * segments as the channel has blocks. After the reader is done, the list with the full segments can be  * obtained from the reader.  * <p>  * If a channel is not to be read in one bulk, but in multiple smaller batches, a  * {@link BlockChannelReader} should be used.  *  * @param channelID The descriptor for the channel to write to.  * @param targetSegments The list to take the segments from into which to read the data.  * @param numBlocks The number of blocks in the channel to read.  * @return A block channel reader that reads from the given channel.  * @throws IOException Thrown, if the channel for the reader could not be opened.  */ ;/**  * Creates a block channel reader that reads all blocks from the given channel directly in one bulk.  * The reader draws segments to read the blocks into from a supplied list, which must contain as many  * segments as the channel has blocks. After the reader is done, the list with the full segments can be  * obtained from the reader.  * <p>  * If a channel is not to be read in one bulk, but in multiple smaller batches, a  * {@link BlockChannelReader} should be used.  *  * @param channelID The descriptor for the channel to write to.  * @param targetSegments The list to take the segments from into which to read the data.  * @param numBlocks The number of blocks in the channel to read.  * @return A block channel reader that reads from the given channel.  * @throws IOException Thrown, if the channel for the reader could not be opened.  */ public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChannel.ID channelID, List<MemorySegment> targetSegments, int numBlocks) throws IOException.
true;public;0;3;/**  * Gets the number of directories across which the I/O manager rotates its files.  *  * @return The number of temporary file directories.  */ ;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ /**  * Gets the number of directories across which the I/O manager rotates its files.  *  * @return The number of temporary file directories.  */ public int getNumberOfSpillingDirectories() {     return this.paths.length. }
true;public;0;3;/**  * Gets the directories that the I/O manager spills to.  *  * @return The directories that the I/O manager spills to.  */ ;/**  * Gets the directories that the I/O manager spills to.  *  * @return The directories that the I/O manager spills to.  */ public File[] getSpillingDirectories() {     return this.paths. }
true;public;0;7;/**  * Gets the directories that the I/O manager spills to, as path strings.  *  * @return The directories that the I/O manager spills to, as path strings.  */ ;/**  * Gets the directories that the I/O manager spills to, as path strings.  *  * @return The directories that the I/O manager spills to, as path strings.  */ public String[] getSpillingDirectoriesPaths() {     String[] strings = new String[this.paths.length].     for (int i = 0. i < strings.length. i++) {         strings[i] = paths[i].getAbsolutePath().     }     return strings. }
false;protected;0;6;;protected int getNextPathNum() {     final int next = this.nextPath.     final int newNext = next + 1.     this.nextPath = newNext >= this.paths.length ? 0 : newNext.     return next. }
