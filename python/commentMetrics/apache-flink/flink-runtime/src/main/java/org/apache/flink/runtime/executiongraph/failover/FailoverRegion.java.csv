commented;modifiers;parameterAmount;loc;comment;code
false;public;2;10;;public void onExecutionFail(Execution taskExecution, Throwable cause) {     // TODO: check if need to failover the preceding region     if (!executionGraph.getRestartStrategy().canRestart()) {         // delegate the failure to a global fail that will check the restart strategy and not restart         executionGraph.failGlobal(cause).     } else {         cancel(taskExecution.getGlobalModVersion()).     } }
false;private;1;15;;private void allVerticesInTerminalState(long globalModVersionOfFailover) {     while (true) {         JobStatus curStatus = this.state.         if (curStatus.equals(JobStatus.CANCELLING)) {             if (transitionState(curStatus, JobStatus.CANCELED)) {                 reset(globalModVersionOfFailover).                 break.             }         } else {             LOG.info("FailoverRegion {} is {} when allVerticesInTerminalState.", id, state).             break.         }     } }
false;public;0;3;;public JobStatus getState() {     return state. }
true;public;0;3;/**  * get all execution vertexes contained in this region  */ ;/**  * get all execution vertexes contained in this region  */ public List<ExecutionVertex> getAllExecutionVertexes() {     return connectedExecutionVertexes. }
true;private;1;17;// Notice the region to failover, ;// Notice the region to failover, private void failover(long globalModVersionOfFailover) {     if (!executionGraph.getRestartStrategy().canRestart()) {         executionGraph.failGlobal(new FlinkException("RestartStrategy validate fail")).     } else {         JobStatus curStatus = this.state.         if (curStatus.equals(JobStatus.RUNNING)) {             cancel(globalModVersionOfFailover).         } else if (curStatus.equals(JobStatus.CANCELED)) {             reset(globalModVersionOfFailover).         } else {             LOG.info("FailoverRegion {} is {} when notified to failover.", id, state).         }     } }
true;private;1;17;// cancel all executions in this sub graph ;// cancel all executions in this sub graph private void cancel(final long globalModVersionOfFailover) {     executionGraph.getJobMasterMainThreadExecutor().assertRunningInMainThread().     while (true) {         JobStatus curStatus = this.state.         if (curStatus.equals(JobStatus.RUNNING)) {             if (transitionState(curStatus, JobStatus.CANCELLING)) {                 createTerminationFutureOverAllConnectedVertexes().thenAccept((nullptr) -> allVerticesInTerminalState(globalModVersionOfFailover)).                 break.             }         } else {             LOG.info("FailoverRegion {} is {} when cancel.", id, state).             break.         }     } }
false;protected;0;12;;@VisibleForTesting protected CompletableFuture<Void> createTerminationFutureOverAllConnectedVertexes() {     // we build a future that is complete once all vertices have reached a terminal state     final ArrayList<CompletableFuture<?>> futures = new ArrayList<>(connectedExecutionVertexes.size()).     // cancel all tasks (that still need cancelling)     for (ExecutionVertex vertex : connectedExecutionVertexes) {         futures.add(vertex.cancel()).     }     return FutureUtils.waitForAll(futures). }
true;private;1;33;// reset all executions in this sub graph ;// reset all executions in this sub graph private void reset(long globalModVersionOfFailover) {     try {         // reset all connected ExecutionVertexes         final Collection<CoLocationGroup> colGroups = new HashSet<>().         final long restartTimestamp = System.currentTimeMillis().         for (ExecutionVertex ev : connectedExecutionVertexes) {             CoLocationGroup cgroup = ev.getJobVertex().getCoLocationGroup().             if (cgroup != null && !colGroups.contains(cgroup)) {                 cgroup.resetConstraints().                 colGroups.add(cgroup).             }             ev.resetForNewExecution(restartTimestamp, globalModVersionOfFailover).         }         if (transitionState(JobStatus.CANCELED, JobStatus.CREATED)) {             restart(globalModVersionOfFailover).         } else {             LOG.info("FailoverRegion {} switched from CANCELLING to CREATED fail, will fail this region again.", id).             failover(globalModVersionOfFailover).         }     } catch (GlobalModVersionMismatch e) {         // happens when a global recovery happens concurrently to the regional recovery         // go back to a clean state         state = JobStatus.RUNNING.     } catch (Throwable e) {         LOG.info("FailoverRegion {} reset fail, will failover again.", id).         failover(globalModVersionOfFailover).     } }
true;private;1;44;// restart all executions in this sub graph ;// restart all executions in this sub graph private void restart(long globalModVersionOfFailover) {     try {         if (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) {             // if we have checkpointed state, reload it into the executions             // TODO: checkpoint support restore part ExecutionVertex cp             /**              * 				if (executionGraph.getCheckpointCoordinator() != null) {              * 					executionGraph.getCheckpointCoordinator().restoreLatestCheckpointedState(              * 							connectedExecutionVertexes, false, false).              * 				}              */             HashSet<AllocationID> previousAllocationsInRegion = new HashSet<>(connectedExecutionVertexes.size()).             for (ExecutionVertex connectedExecutionVertex : connectedExecutionVertexes) {                 AllocationID latestPriorAllocation = connectedExecutionVertex.getLatestPriorAllocation().                 if (latestPriorAllocation != null) {                     previousAllocationsInRegion.add(latestPriorAllocation).                 }             }             // restart all connected ExecutionVertexes             for (ExecutionVertex ev : connectedExecutionVertexes) {                 try {                     ev.scheduleForExecution(executionGraph.getSlotProvider(), executionGraph.isQueuedSchedulingAllowed(), LocationPreferenceConstraint.ANY, // some inputs not belonging to the failover region might have failed concurrently                     previousAllocationsInRegion).                 } catch (Throwable e) {                     failover(globalModVersionOfFailover).                 }             }         } else {             LOG.info("FailoverRegion {} switched from CREATED to RUNNING fail, will fail this region again.", id).             failover(globalModVersionOfFailover).         }     } catch (Exception e) {         LOG.info("FailoverRegion {} restart failed, failover again.", id, e).         failover(globalModVersionOfFailover).     } }
false;private;2;9;;private boolean transitionState(JobStatus current, JobStatus newState) {     if (STATE_UPDATER.compareAndSet(this, current, newState)) {         LOG.info("FailoverRegion {} switched from state {} to {}.", id, current, newState).         return true.     } else {         return false.     } }
