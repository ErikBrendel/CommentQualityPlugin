commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public void open() throws IOException, MemoryAllocationException, InterruptedException {     this.hashJoin.open(this.firstInput, this.secondInput, this.buildSideOuterJoin). }
false;public;0;9;;@Override public void close() {     // close the join     this.hashJoin.close().     // free the memory     final List<MemorySegment> segments = this.hashJoin.getFreedMemory().     this.memManager.release(segments). }
false;public,final;2;62;;@Override public final boolean callWithNextKey(FlatJoinFunction<V1, V2, O> matchFunction, Collector<O> collector) throws Exception {     if (this.hashJoin.nextRecord()) {         // we have a next record, get the iterators to the probe and build side values         final MutableObjectIterator<V1> buildSideIterator = this.hashJoin.getBuildSideIterator().         final V2 probeRecord = this.hashJoin.getCurrentProbeRecord().         V1 nextBuildSideRecord = buildSideIterator.next().         // get the first build side value         if (probeRecord != null && nextBuildSideRecord != null) {             V1 tmpRec.             // check if there is another build-side value             if ((tmpRec = buildSideIterator.next()) != null) {                 // more than one build-side value --> copy the probe side                 V2 probeCopy.                 probeCopy = this.probeSideSerializer.copy(probeRecord).                 // call match on the first pair                 matchFunction.join(nextBuildSideRecord, probeCopy, collector).                 // call match on the second pair                 probeCopy = this.probeSideSerializer.copy(probeRecord).                 matchFunction.join(tmpRec, probeCopy, collector).                 while (this.running && ((nextBuildSideRecord = buildSideIterator.next()) != null)) {                     // call match on the next pair                     // make sure we restore the value of the probe side record                     probeCopy = this.probeSideSerializer.copy(probeRecord).                     matchFunction.join(nextBuildSideRecord, probeCopy, collector).                 }             } else {                 // only single pair matches                 matchFunction.join(nextBuildSideRecord, probeRecord, collector).             }         } else {             // while probe side outer join, join current probe record with null.             if (probeSideOuterJoin && probeRecord != null && nextBuildSideRecord == null) {                 matchFunction.join(null, probeRecord, collector).             }             // and join with null.             if (buildSideOuterJoin && probeRecord == null && nextBuildSideRecord != null) {                 matchFunction.join(nextBuildSideRecord, null, collector).                 while (this.running && ((nextBuildSideRecord = buildSideIterator.next()) != null)) {                     matchFunction.join(nextBuildSideRecord, null, collector).                 }             }         }         return true.     } else {         return false.     } }
false;public;0;5;;@Override public void abort() {     this.running = false.     this.hashJoin.abort(). }
