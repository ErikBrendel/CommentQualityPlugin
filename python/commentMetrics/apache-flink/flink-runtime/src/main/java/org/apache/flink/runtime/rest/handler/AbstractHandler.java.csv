commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;84;;@Override protected void respondAsLeader(ChannelHandlerContext ctx, RoutedRequest routedRequest, T gateway) {     HttpRequest httpRequest = routedRequest.getRequest().     if (log.isTraceEnabled()) {         log.trace("Received request " + httpRequest.uri() + '.').     }     FileUploads uploadedFiles = null.     try {         inFlightRequestTracker.registerRequest().         if (!(httpRequest instanceof FullHttpRequest)) {             // The RestServerEndpoint defines a HttpObjectAggregator in the pipeline that always returns             // FullHttpRequests.             log.error("Implementation error: Received a request that wasn't a FullHttpRequest.").             throw new RestHandlerException("Bad request received.", HttpResponseStatus.BAD_REQUEST).         }         final ByteBuf msgContent = ((FullHttpRequest) httpRequest).content().         uploadedFiles = FileUploadHandler.getMultipartFileUploads(ctx).         if (!untypedResponseMessageHeaders.acceptsFileUploads() && !uploadedFiles.getUploadedFiles().isEmpty()) {             throw new RestHandlerException("File uploads not allowed.", HttpResponseStatus.BAD_REQUEST).         }         R request.         if (msgContent.capacity() == 0) {             try {                 request = MAPPER.readValue("{}", untypedResponseMessageHeaders.getRequestClass()).             } catch (JsonParseException | JsonMappingException je) {                 throw new RestHandlerException("Bad request received. Request did not conform to expected format.", HttpResponseStatus.BAD_REQUEST, je).             }         } else {             try {                 ByteBufInputStream in = new ByteBufInputStream(msgContent).                 request = MAPPER.readValue(in, untypedResponseMessageHeaders.getRequestClass()).             } catch (JsonParseException | JsonMappingException je) {                 throw new RestHandlerException(String.format("Request did not match expected format %s.", untypedResponseMessageHeaders.getRequestClass().getSimpleName()), HttpResponseStatus.BAD_REQUEST, je).             }         }         final HandlerRequest<R, M> handlerRequest.         try {             handlerRequest = new HandlerRequest<R, M>(request, untypedResponseMessageHeaders.getUnresolvedMessageParameters(), routedRequest.getRouteResult().pathParams(), routedRequest.getRouteResult().queryParams(), uploadedFiles.getUploadedFiles()).         } catch (HandlerRequestException hre) {             log.error("Could not create the handler request.", hre).             throw new RestHandlerException(String.format("Bad request, could not parse parameters: %s", hre.getMessage()), HttpResponseStatus.BAD_REQUEST, hre).         }         log.trace("Starting request processing.").         CompletableFuture<Void> requestProcessingFuture = respondToRequest(ctx, httpRequest, handlerRequest, gateway).         final FileUploads finalUploadedFiles = uploadedFiles.         requestProcessingFuture.whenComplete((Void ignored, Throwable throwable) -> {             if (throwable != null) {                 handleException(ExceptionUtils.stripCompletionException(throwable), ctx, httpRequest).whenComplete((Void ignored2, Throwable throwable2) -> finalizeRequestProcessing(finalUploadedFiles)).             } else {                 finalizeRequestProcessing(finalUploadedFiles).             }         }).     } catch (Throwable e) {         final FileUploads finalUploadedFiles = uploadedFiles.         handleException(e, ctx, httpRequest).whenComplete((Void ignored, Throwable throwable) -> finalizeRequestProcessing(finalUploadedFiles)).     } }
false;private;1;4;;private void finalizeRequestProcessing(FileUploads uploadedFiles) {     inFlightRequestTracker.deregisterRequest().     cleanupFileUploads(uploadedFiles). }
false;private;3;26;;private CompletableFuture<Void> handleException(Throwable throwable, ChannelHandlerContext ctx, HttpRequest httpRequest) {     if (throwable instanceof RestHandlerException) {         RestHandlerException rhe = (RestHandlerException) throwable.         if (log.isDebugEnabled()) {             log.error("Exception occurred in REST handler.", rhe).         } else {             log.error("Exception occurred in REST handler: {}", rhe.getMessage()).         }         return HandlerUtils.sendErrorResponse(ctx, httpRequest, new ErrorResponseBody(rhe.getMessage()), rhe.getHttpResponseStatus(), responseHeaders).     } else {         log.error("Implementation error: Unhandled exception.", throwable).         String stackTrace = String.format("<Exception on server side:%n%s%nEnd of exception on server side>", ExceptionUtils.stringifyException(throwable)).         return HandlerUtils.sendErrorResponse(ctx, httpRequest, new ErrorResponseBody(Arrays.asList("Internal server error.", stackTrace)), HttpResponseStatus.INTERNAL_SERVER_ERROR, responseHeaders).     } }
false;public,final;0;4;;@Override public final CompletableFuture<Void> closeAsync() {     return FutureUtils.composeAfterwards(closeHandlerAsync(), inFlightRequestTracker::awaitAsync). }
false;protected;0;3;;protected CompletableFuture<Void> closeHandlerAsync() {     return CompletableFuture.completedFuture(null). }
false;private;1;9;;private void cleanupFileUploads(@Nullable FileUploads uploadedFiles) {     if (uploadedFiles != null) {         try {             uploadedFiles.close().         } catch (IOException e) {             log.warn("Could not cleanup uploaded files.", e).         }     } }
true;protected,abstract;4;5;/**  * Respond to the given {@link HandlerRequest}.  *  * @param ctx channel handler context to write the response  * @param httpRequest original http request  * @param handlerRequest typed handler request  * @param gateway leader gateway  * @return Future which is completed once the request has been processed  * @throws RestHandlerException if an exception occurred while responding  */ ;/**  * Respond to the given {@link HandlerRequest}.  *  * @param ctx channel handler context to write the response  * @param httpRequest original http request  * @param handlerRequest typed handler request  * @param gateway leader gateway  * @return Future which is completed once the request has been processed  * @throws RestHandlerException if an exception occurred while responding  */ protected abstract CompletableFuture<Void> respondToRequest(ChannelHandlerContext ctx, HttpRequest httpRequest, HandlerRequest<R, M> handlerRequest, T gateway) throws RestHandlerException.
