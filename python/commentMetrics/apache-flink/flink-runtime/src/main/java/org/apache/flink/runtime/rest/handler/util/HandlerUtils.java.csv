commented;modifiers;parameterAmount;loc;comment;code
true;public,static;5;25;/**  * Sends the given response and status code to the given channel.  *  * @param channelHandlerContext identifying the open channel  * @param httpRequest originating http request  * @param response which should be sent  * @param statusCode of the message to send  * @param headers additional header values  * @param <P> type of the response  */ ;/**  * Sends the given response and status code to the given channel.  *  * @param channelHandlerContext identifying the open channel  * @param httpRequest originating http request  * @param response which should be sent  * @param statusCode of the message to send  * @param headers additional header values  * @param <P> type of the response  */ public static <P extends ResponseBody> CompletableFuture<Void> sendResponse(ChannelHandlerContext channelHandlerContext, HttpRequest httpRequest, P response, HttpResponseStatus statusCode, Map<String, String> headers) {     StringWriter sw = new StringWriter().     try {         mapper.writeValue(sw, response).     } catch (IOException ioe) {         LOG.error("Internal server error. Could not map response to JSON.", ioe).         return sendErrorResponse(channelHandlerContext, httpRequest, new ErrorResponseBody("Internal server error. Could not map response to JSON."), HttpResponseStatus.INTERNAL_SERVER_ERROR, headers).     }     return sendResponse(channelHandlerContext, httpRequest, sw.toString(), statusCode, headers). }
true;public,static;5;14;/**  * Sends the given error response and status code to the given channel.  *  * @param channelHandlerContext identifying the open channel  * @param httpRequest originating http request  * @param errorMessage which should be sent  * @param statusCode of the message to send  * @param headers additional header values  */ ;/**  * Sends the given error response and status code to the given channel.  *  * @param channelHandlerContext identifying the open channel  * @param httpRequest originating http request  * @param errorMessage which should be sent  * @param statusCode of the message to send  * @param headers additional header values  */ public static CompletableFuture<Void> sendErrorResponse(ChannelHandlerContext channelHandlerContext, HttpRequest httpRequest, ErrorResponseBody errorMessage, HttpResponseStatus statusCode, Map<String, String> headers) {     return sendErrorResponse(channelHandlerContext, HttpHeaders.isKeepAlive(httpRequest), errorMessage, statusCode, headers). }
true;public,static;5;27;/**  * Sends the given error response and status code to the given channel.  *  * @param channelHandlerContext identifying the open channel  * @param keepAlive If the connection should be kept alive.  * @param errorMessage which should be sent  * @param statusCode of the message to send  * @param headers additional header values  */ ;/**  * Sends the given error response and status code to the given channel.  *  * @param channelHandlerContext identifying the open channel  * @param keepAlive If the connection should be kept alive.  * @param errorMessage which should be sent  * @param statusCode of the message to send  * @param headers additional header values  */ public static CompletableFuture<Void> sendErrorResponse(ChannelHandlerContext channelHandlerContext, boolean keepAlive, ErrorResponseBody errorMessage, HttpResponseStatus statusCode, Map<String, String> headers) {     StringWriter sw = new StringWriter().     try {         mapper.writeValue(sw, errorMessage).     } catch (IOException e) {         // this should never happen         LOG.error("Internal server error. Could not map error response to JSON.", e).         return sendResponse(channelHandlerContext, keepAlive, "Internal server error. Could not map error response to JSON.", HttpResponseStatus.INTERNAL_SERVER_ERROR, headers).     }     return sendResponse(channelHandlerContext, keepAlive, sw.toString(), statusCode, headers). }
true;public,static;5;14;/**  * Sends the given response and status code to the given channel.  *  * @param channelHandlerContext identifying the open channel  * @param httpRequest originating http request  * @param message which should be sent  * @param statusCode of the message to send  * @param headers additional header values  */ ;/**  * Sends the given response and status code to the given channel.  *  * @param channelHandlerContext identifying the open channel  * @param httpRequest originating http request  * @param message which should be sent  * @param statusCode of the message to send  * @param headers additional header values  */ public static CompletableFuture<Void> sendResponse(@Nonnull ChannelHandlerContext channelHandlerContext, @Nonnull HttpRequest httpRequest, @Nonnull String message, @Nonnull HttpResponseStatus statusCode, @Nonnull Map<String, String> headers) {     return sendResponse(channelHandlerContext, HttpHeaders.isKeepAlive(httpRequest), message, statusCode, headers). }
true;public,static;5;36;/**  * Sends the given response and status code to the given channel.  *  * @param channelHandlerContext identifying the open channel  * @param keepAlive If the connection should be kept alive.  * @param message which should be sent  * @param statusCode of the message to send  * @param headers additional header values  */ ;/**  * Sends the given response and status code to the given channel.  *  * @param channelHandlerContext identifying the open channel  * @param keepAlive If the connection should be kept alive.  * @param message which should be sent  * @param statusCode of the message to send  * @param headers additional header values  */ public static CompletableFuture<Void> sendResponse(@Nonnull ChannelHandlerContext channelHandlerContext, boolean keepAlive, @Nonnull String message, @Nonnull HttpResponseStatus statusCode, @Nonnull Map<String, String> headers) {     HttpResponse response = new DefaultHttpResponse(HTTP_1_1, statusCode).     response.headers().set(CONTENT_TYPE, RestConstants.REST_CONTENT_TYPE).     for (Map.Entry<String, String> headerEntry : headers.entrySet()) {         response.headers().set(headerEntry.getKey(), headerEntry.getValue()).     }     if (keepAlive) {         response.headers().set(CONNECTION, HttpHeaders.Values.KEEP_ALIVE).     }     byte[] buf = message.getBytes(ConfigConstants.DEFAULT_CHARSET).     ByteBuf b = Unpooled.copiedBuffer(buf).     HttpHeaders.setContentLength(response, buf.length).     // write the initial line and the header.     channelHandlerContext.write(response).     channelHandlerContext.write(b).     ChannelFuture lastContentFuture = channelHandlerContext.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).     // close the connection, if no keep-alive is needed     if (!keepAlive) {         lastContentFuture.addListener(ChannelFutureListener.CLOSE).     }     return toCompletableFuture(lastContentFuture). }
false;private,static;1;11;;private static CompletableFuture<Void> toCompletableFuture(final ChannelFuture channelFuture) {     final CompletableFuture<Void> completableFuture = new CompletableFuture<>().     channelFuture.addListener(future -> {         if (future.isSuccess()) {             completableFuture.complete(null).         } else {             completableFuture.completeExceptionally(future.cause()).         }     }).     return completableFuture. }
