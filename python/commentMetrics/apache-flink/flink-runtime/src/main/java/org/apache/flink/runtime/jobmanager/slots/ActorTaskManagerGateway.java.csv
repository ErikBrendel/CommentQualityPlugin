commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public ActorGateway getActorGateway() {     return actorGateway. }
false;public;0;4;;// ------------------------------------------------------------------------------- // Task manager rpc methods // ------------------------------------------------------------------------------- @Override public String getAddress() {     return actorGateway.path(). }
false;public;6;26;;@Override public CompletableFuture<StackTraceSampleResponse> requestStackTraceSample(ExecutionAttemptID executionAttemptID, int sampleId, int numSamples, Time delayBetweenSamples, int maxStackTraceDepth, Time timeout) {     Preconditions.checkNotNull(executionAttemptID).     Preconditions.checkArgument(numSamples > 0, "The number of samples must be greater than 0.").     Preconditions.checkNotNull(delayBetweenSamples).     Preconditions.checkArgument(maxStackTraceDepth >= 0, "The max stack trace depth must be greater or equal than 0.").     Preconditions.checkNotNull(timeout).     scala.concurrent.Future<StackTraceSampleResponse> stackTraceSampleResponseFuture = actorGateway.ask(new StackTraceSampleMessages.TriggerStackTraceSample(sampleId, executionAttemptID, numSamples, delayBetweenSamples, maxStackTraceDepth), new FiniteDuration(timeout.getSize(), timeout.getUnit())).mapTo(ClassTag$.MODULE$.<StackTraceSampleResponse>apply(StackTraceSampleResponse.class)).     return FutureUtils.toJava(stackTraceSampleResponseFuture). }
false;public;2;12;;@Override public CompletableFuture<Acknowledge> submitTask(TaskDeploymentDescriptor tdd, Time timeout) {     Preconditions.checkNotNull(tdd).     Preconditions.checkNotNull(timeout).     scala.concurrent.Future<Acknowledge> submitResult = actorGateway.ask(new TaskMessages.SubmitTask(tdd), new FiniteDuration(timeout.getSize(), timeout.getUnit())).mapTo(ClassTag$.MODULE$.<Acknowledge>apply(Acknowledge.class)).     return FutureUtils.toJava(submitResult). }
false;public;2;12;;@Override public CompletableFuture<Acknowledge> stopTask(ExecutionAttemptID executionAttemptID, Time timeout) {     Preconditions.checkNotNull(executionAttemptID).     Preconditions.checkNotNull(timeout).     scala.concurrent.Future<Acknowledge> stopResult = actorGateway.ask(new TaskMessages.StopTask(executionAttemptID), new FiniteDuration(timeout.getSize(), timeout.getUnit())).mapTo(ClassTag$.MODULE$.<Acknowledge>apply(Acknowledge.class)).     return FutureUtils.toJava(stopResult). }
false;public;2;12;;@Override public CompletableFuture<Acknowledge> cancelTask(ExecutionAttemptID executionAttemptID, Time timeout) {     Preconditions.checkNotNull(executionAttemptID).     Preconditions.checkNotNull(timeout).     scala.concurrent.Future<Acknowledge> cancelResult = actorGateway.ask(new TaskMessages.CancelTask(executionAttemptID), new FiniteDuration(timeout.getSize(), timeout.getUnit())).mapTo(ClassTag$.MODULE$.<Acknowledge>apply(Acknowledge.class)).     return FutureUtils.toJava(cancelResult). }
false;public;3;16;;@Override public CompletableFuture<Acknowledge> updatePartitions(ExecutionAttemptID executionAttemptID, Iterable<PartitionInfo> partitionInfos, Time timeout) {     Preconditions.checkNotNull(executionAttemptID).     Preconditions.checkNotNull(partitionInfos).     TaskMessages.UpdatePartitionInfo updatePartitionInfoMessage = new TaskMessages.UpdateTaskMultiplePartitionInfos(executionAttemptID, partitionInfos).     scala.concurrent.Future<Acknowledge> updatePartitionsResult = actorGateway.ask(updatePartitionInfoMessage, new FiniteDuration(timeout.getSize(), timeout.getUnit())).mapTo(ClassTag$.MODULE$.<Acknowledge>apply(Acknowledge.class)).     return FutureUtils.toJava(updatePartitionsResult). }
false;public;1;6;;@Override public void failPartition(ExecutionAttemptID executionAttemptID) {     Preconditions.checkNotNull(executionAttemptID).     actorGateway.tell(new TaskMessages.FailIntermediateResultPartitions(executionAttemptID)). }
false;public;4;12;;@Override public void notifyCheckpointComplete(ExecutionAttemptID executionAttemptID, JobID jobId, long checkpointId, long timestamp) {     Preconditions.checkNotNull(executionAttemptID).     Preconditions.checkNotNull(jobId).     actorGateway.tell(new NotifyCheckpointComplete(jobId, executionAttemptID, checkpointId, timestamp)). }
false;public;5;13;;@Override public void triggerCheckpoint(ExecutionAttemptID executionAttemptID, JobID jobId, long checkpointId, long timestamp, CheckpointOptions checkpointOptions) {     Preconditions.checkNotNull(executionAttemptID).     Preconditions.checkNotNull(jobId).     actorGateway.tell(new TriggerCheckpoint(jobId, executionAttemptID, checkpointId, timestamp, checkpointOptions)). }
false;public;3;4;;@Override public CompletableFuture<Acknowledge> freeSlot(AllocationID allocationId, Throwable cause, Time timeout) {     throw new UnsupportedOperationException("The old TaskManager does not support freeing slots"). }
false;private;2;12;;private CompletableFuture<TransientBlobKey> requestTaskManagerLog(TaskManagerMessages.RequestTaskManagerLog request, Time timeout) {     Preconditions.checkNotNull(request).     Preconditions.checkNotNull(timeout).     scala.concurrent.Future<TransientBlobKey> blobKeyFuture = actorGateway.ask(request, new FiniteDuration(timeout.getSize(), timeout.getUnit())).mapTo(ClassTag$.MODULE$.<TransientBlobKey>apply(TransientBlobKey.class)).     return FutureUtils.toJava(blobKeyFuture). }
