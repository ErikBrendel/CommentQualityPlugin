commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Returns whether this buffer represents a buffer or an event.  *  * @return <tt>true</tt> if this is a real buffer, <tt>false</tt> if this is an event  */ ;/**  * Returns whether this buffer represents a buffer or an event.  *  * @return <tt>true</tt> if this is a real buffer, <tt>false</tt> if this is an event  */ boolean isBuffer().
true;;0;1;/**  * Tags this buffer to represent an event.  */ ;/**  * Tags this buffer to represent an event.  */ void tagAsEvent().
true;;0;2;/**  * Returns the underlying memory segment. This method is dangerous since it ignores read only protections and omits  * slices. Use it only along the {@link #getMemorySegmentOffset()}.  *  * <p>This method will be removed in the future. For writing use {@link BufferBuilder}.  *  * @return the memory segment backing this buffer  */ ;/**  * Returns the underlying memory segment. This method is dangerous since it ignores read only protections and omits  * slices. Use it only along the {@link #getMemorySegmentOffset()}.  *  * <p>This method will be removed in the future. For writing use {@link BufferBuilder}.  *  * @return the memory segment backing this buffer  */ @Deprecated MemorySegment getMemorySegment().
true;;0;2;/**  * This method will be removed in the future. For writing use {@link BufferBuilder}.  *  * @return the offset where this (potential slice) {@link Buffer}'s data start in the underlying memory segment.  */ ;/**  * This method will be removed in the future. For writing use {@link BufferBuilder}.  *  * @return the offset where this (potential slice) {@link Buffer}'s data start in the underlying memory segment.  */ @Deprecated int getMemorySegmentOffset().
true;;0;1;/**  * Gets the buffer's recycler.  *  * @return buffer recycler  */ ;/**  * Gets the buffer's recycler.  *  * @return buffer recycler  */ BufferRecycler getRecycler().
true;;0;1;/**  * Releases this buffer once, i.e. reduces the reference count and recycles the buffer if the  * reference count reaches <tt>0</tt>.  *  * @see #retainBuffer()  */ ;/**  * Releases this buffer once, i.e. reduces the reference count and recycles the buffer if the  * reference count reaches <tt>0</tt>.  *  * @see #retainBuffer()  */ void recycleBuffer().
true;;0;1;/**  * Returns whether this buffer has been recycled or not.  *  * @return <tt>true</tt> if already recycled, <tt>false</tt> otherwise  */ ;/**  * Returns whether this buffer has been recycled or not.  *  * @return <tt>true</tt> if already recycled, <tt>false</tt> otherwise  */ boolean isRecycled().
true;;0;1;/**  * Retains this buffer for further use, increasing the reference counter by <tt>1</tt>.  *  * @return <tt>this</tt> instance (for chained calls)  *  * @see #recycleBuffer()  */ ;/**  * Retains this buffer for further use, increasing the reference counter by <tt>1</tt>.  *  * @return <tt>this</tt> instance (for chained calls)  *  * @see #recycleBuffer()  */ Buffer retainBuffer().
true;;0;1;/**  * Returns a read-only slice of this buffer's readable bytes, i.e. between  * {@link #getReaderIndex()} and {@link #getSize()}.  *  * <p>Reader and writer indices as well as markers are not shared. Reference counters are  * shared but the slice is not {@link #retainBuffer() retained} automatically.  *  * @return a read-only sliced buffer  */ ;/**  * Returns a read-only slice of this buffer's readable bytes, i.e. between  * {@link #getReaderIndex()} and {@link #getSize()}.  *  * <p>Reader and writer indices as well as markers are not shared. Reference counters are  * shared but the slice is not {@link #retainBuffer() retained} automatically.  *  * @return a read-only sliced buffer  */ Buffer readOnlySlice().
true;;2;1;/**  * Returns a read-only slice of this buffer.  *  * <p>Reader and writer indices as well as markers are not shared. Reference counters are  * shared but the slice is not {@link #retainBuffer() retained} automatically.  *  * @param index the index to start from  * @param length the length of the slice  *  * @return a read-only sliced buffer  */ ;/**  * Returns a read-only slice of this buffer.  *  * <p>Reader and writer indices as well as markers are not shared. Reference counters are  * shared but the slice is not {@link #retainBuffer() retained} automatically.  *  * @param index the index to start from  * @param length the length of the slice  *  * @return a read-only sliced buffer  */ Buffer readOnlySlice(int index, int length).
true;;0;1;/**  * Returns the maximum size of the buffer, i.e. the capacity of the underlying {@link MemorySegment}.  *  * @return size of the buffer  */ ;/**  * Returns the maximum size of the buffer, i.e. the capacity of the underlying {@link MemorySegment}.  *  * @return size of the buffer  */ int getMaxCapacity().
true;;0;1;/**  * Returns the <tt>reader index</tt> of this buffer.  *  * <p>This is where readable (unconsumed) bytes start in the backing memory segment.  *  * @return reader index (from 0 (inclusive) to the size of the backing {@link MemorySegment}  * (inclusive))  */ ;/**  * Returns the <tt>reader index</tt> of this buffer.  *  * <p>This is where readable (unconsumed) bytes start in the backing memory segment.  *  * @return reader index (from 0 (inclusive) to the size of the backing {@link MemorySegment}  * (inclusive))  */ int getReaderIndex().
true;;1;1;/**  * Sets the <tt>reader index</tt> of this buffer.  *  * @throws IndexOutOfBoundsException  * 		if the index is less than <tt>0</tt> or greater than {@link #getSize()}  */ ;/**  * Sets the <tt>reader index</tt> of this buffer.  *  * @throws IndexOutOfBoundsException  * 		if the index is less than <tt>0</tt> or greater than {@link #getSize()}  */ void setReaderIndex(int readerIndex) throws IndexOutOfBoundsException.
true;;0;1;/**  * Returns the size of the written data, i.e. the <tt>writer index</tt>, of this buffer in an  * non-synchronized fashion.  *  * <p>This is where writable bytes start in the backing memory segment.  *  * @return writer index (from 0 (inclusive) to the size of the backing {@link MemorySegment}  * (inclusive))  */ ;/**  * Returns the size of the written data, i.e. the <tt>writer index</tt>, of this buffer in an  * non-synchronized fashion.  *  * <p>This is where writable bytes start in the backing memory segment.  *  * @return writer index (from 0 (inclusive) to the size of the backing {@link MemorySegment}  * (inclusive))  */ int getSizeUnsafe().
true;;0;1;/**  * Returns the size of the written data, i.e. the <tt>writer index</tt>, of this buffer.  *  * <p>This is where writable bytes start in the backing memory segment.  *  * @return writer index (from 0 (inclusive) to the size of the backing {@link MemorySegment}  * (inclusive))  */ ;/**  * Returns the size of the written data, i.e. the <tt>writer index</tt>, of this buffer.  *  * <p>This is where writable bytes start in the backing memory segment.  *  * @return writer index (from 0 (inclusive) to the size of the backing {@link MemorySegment}  * (inclusive))  */ int getSize().
true;;1;1;/**  * Sets the size of the written data, i.e. the <tt>writer index</tt>, of this buffer.  *  * @throws IndexOutOfBoundsException  * 		if the index is less than {@link #getReaderIndex()} or greater than {@link #getMaxCapacity()}  */ ;/**  * Sets the size of the written data, i.e. the <tt>writer index</tt>, of this buffer.  *  * @throws IndexOutOfBoundsException  * 		if the index is less than {@link #getReaderIndex()} or greater than {@link #getMaxCapacity()}  */ void setSize(int writerIndex).
true;;0;1;/**  * Returns the number of readable bytes (same as <tt>{@link #getSize()} -  * {@link #getReaderIndex()}</tt>).  */ ;/**  * Returns the number of readable bytes (same as <tt>{@link #getSize()} -  * {@link #getReaderIndex()}</tt>).  */ int readableBytes().
true;;0;1;/**  * Gets a new {@link ByteBuffer} instance wrapping this buffer's readable bytes, i.e. between  * {@link #getReaderIndex()} and {@link #getSize()}.  *  * <p>Please note that neither index is updated by the returned buffer.  *  * @return byte buffer sharing the contents of the underlying memory segment  */ ;/**  * Gets a new {@link ByteBuffer} instance wrapping this buffer's readable bytes, i.e. between  * {@link #getReaderIndex()} and {@link #getSize()}.  *  * <p>Please note that neither index is updated by the returned buffer.  *  * @return byte buffer sharing the contents of the underlying memory segment  */ ByteBuffer getNioBufferReadable().
true;;2;1;/**  * Gets a new {@link ByteBuffer} instance wrapping this buffer's bytes.  *  * <p>Please note that neither <tt>read</tt> nor <tt>write</tt> index are updated by the  * returned buffer.  *  * @return byte buffer sharing the contents of the underlying memory segment  *  * @throws IndexOutOfBoundsException  * 		if the indexes are not without the buffer's bounds  * @see #getNioBufferReadable()  */ ;/**  * Gets a new {@link ByteBuffer} instance wrapping this buffer's bytes.  *  * <p>Please note that neither <tt>read</tt> nor <tt>write</tt> index are updated by the  * returned buffer.  *  * @return byte buffer sharing the contents of the underlying memory segment  *  * @throws IndexOutOfBoundsException  * 		if the indexes are not without the buffer's bounds  * @see #getNioBufferReadable()  */ ByteBuffer getNioBuffer(int index, int length) throws IndexOutOfBoundsException.
true;;1;1;/**  * Sets the buffer allocator for use in netty.  *  * @param allocator netty buffer allocator  */ ;/**  * Sets the buffer allocator for use in netty.  *  * @param allocator netty buffer allocator  */ void setAllocator(ByteBufAllocator allocator).
true;;0;1;/**  * @return self as ByteBuf implementation.  */ ;/**  * @return self as ByteBuf implementation.  */ ByteBuf asByteBuf().
