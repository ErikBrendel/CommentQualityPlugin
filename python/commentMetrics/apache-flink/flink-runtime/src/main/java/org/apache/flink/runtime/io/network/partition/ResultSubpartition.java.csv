commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;3;;protected void updateStatistics(BufferConsumer buffer) {     totalNumberOfBuffers++. }
false;protected;1;3;;protected void updateStatistics(Buffer buffer) {     totalNumberOfBytes += buffer.getSize(). }
false;protected;0;3;;protected long getTotalNumberOfBuffers() {     return totalNumberOfBuffers. }
false;protected;0;3;;protected long getTotalNumberOfBytes() {     return totalNumberOfBytes. }
true;protected;0;3;/**  * Notifies the parent partition about a consumed {@link ResultSubpartitionView}.  */ ;/**  * Notifies the parent partition about a consumed {@link ResultSubpartitionView}.  */ protected void onConsumedSubpartition() {     parent.onConsumedSubpartition(index). }
false;protected;0;3;;protected Throwable getFailureCause() {     return parent.getFailureCause(). }
true;public,abstract;1;1;/**  * Adds the given buffer.  *  * <p>The request may be executed synchronously, or asynchronously, depending on the  * implementation.  *  * <p><strong>IMPORTANT:</strong> Before adding new {@link BufferConsumer} previously added must be in finished  * state. Because of the performance reasons, this is only enforced during the data reading.  *  * @param bufferConsumer  * 		the buffer to add (transferring ownership to this writer)  * @return true if operation succeeded and bufferConsumer was enqueued for consumption.  * @throws IOException  * 		thrown in case of errors while adding the buffer  */ ;/**  * Adds the given buffer.  *  * <p>The request may be executed synchronously, or asynchronously, depending on the  * implementation.  *  * <p><strong>IMPORTANT:</strong> Before adding new {@link BufferConsumer} previously added must be in finished  * state. Because of the performance reasons, this is only enforced during the data reading.  *  * @param bufferConsumer  * 		the buffer to add (transferring ownership to this writer)  * @return true if operation succeeded and bufferConsumer was enqueued for consumption.  * @throws IOException  * 		thrown in case of errors while adding the buffer  */ public abstract boolean add(BufferConsumer bufferConsumer) throws IOException.
false;public,abstract;0;1;;public abstract void flush().
false;public,abstract;0;1;;public abstract void finish() throws IOException.
false;public,abstract;0;1;;public abstract void release() throws IOException.
false;public,abstract;1;1;;public abstract ResultSubpartitionView createReadView(BufferAvailabilityListener availabilityListener) throws IOException.
false;abstract;0;1;;abstract int releaseMemory() throws IOException.
false;public,abstract;0;1;;public abstract boolean isReleased().
true;public;0;4;/**  * Gets the number of non-event buffers in this subpartition.  *  * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access  * scenarios since it does not make any concurrency guarantees.  */ ;/**  * Gets the number of non-event buffers in this subpartition.  *  * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access  * scenarios since it does not make any concurrency guarantees.  */ @VisibleForTesting public int getBuffersInBacklog() {     return buffersInBacklog. }
true;public,abstract;0;1;/**  * Makes a best effort to get the current size of the queue.  * This method must not acquire locks or interfere with the task and network threads in  * any way.  */ ;/**  * Makes a best effort to get the current size of the queue.  * This method must not acquire locks or interfere with the task and network threads in  * any way.  */ public abstract int unsynchronizedGetNumberOfQueuedBuffers().
true;public;1;5;/**  * Decreases the number of non-event buffers by one after fetching a non-event  * buffer from this subpartition (for access by the subpartition views).  *  * @return backlog after the operation  */ ;/**  * Decreases the number of non-event buffers by one after fetching a non-event  * buffer from this subpartition (for access by the subpartition views).  *  * @return backlog after the operation  */ public int decreaseBuffersInBacklog(Buffer buffer) {     synchronized (buffers) {         return decreaseBuffersInBacklogUnsafe(buffer != null && buffer.isBuffer()).     } }
false;protected;1;7;;protected int decreaseBuffersInBacklogUnsafe(boolean isBuffer) {     assert Thread.holdsLock(buffers).     if (isBuffer) {         buffersInBacklog--.     }     return buffersInBacklog. }
true;protected;1;7;/**  * Increases the number of non-event buffers by one after adding a non-event  * buffer into this subpartition.  */ ;/**  * Increases the number of non-event buffers by one after adding a non-event  * buffer into this subpartition.  */ protected void increaseBuffersInBacklog(BufferConsumer buffer) {     assert Thread.holdsLock(buffers).     if (buffer != null && buffer.isBuffer()) {         buffersInBacklog++.     } }
false;public;0;3;;public Buffer buffer() {     return buffer. }
false;public;0;3;;public boolean isMoreAvailable() {     return isMoreAvailable. }
false;public;0;3;;public int buffersInBacklog() {     return buffersInBacklog. }
false;public;0;3;;public boolean nextBufferIsEvent() {     return nextBufferIsEvent. }
