commented;modifiers;parameterAmount;loc;comment;code
true;public;2;99;/**  * Calls the <code>JoinFunction#join()</code> method for all two key-value pairs that share the same key and come  * from different inputs. Furthermore, depending on the outer join type (LEFT, RIGHT, FULL), all key-value pairs where no  * matching partner from the other input exists are joined with null.  * The output of the <code>join()</code> method is forwarded.  *  * @throws Exception Forwards all exceptions from the user code and the I/O system.  * @see org.apache.flink.runtime.operators.util.JoinTaskIterator#callWithNextKey(org.apache.flink.api.common.functions.FlatJoinFunction, org.apache.flink.util.Collector)  */ ;/**  * Calls the <code>JoinFunction#join()</code> method for all two key-value pairs that share the same key and come  * from different inputs. Furthermore, depending on the outer join type (LEFT, RIGHT, FULL), all key-value pairs where no  * matching partner from the other input exists are joined with null.  * The output of the <code>join()</code> method is forwarded.  *  * @throws Exception Forwards all exceptions from the user code and the I/O system.  * @see org.apache.flink.runtime.operators.util.JoinTaskIterator#callWithNextKey(org.apache.flink.api.common.functions.FlatJoinFunction, org.apache.flink.util.Collector)  */ @Override public boolean callWithNextKey(final FlatJoinFunction<T1, T2, O> joinFunction, final Collector<O> collector) throws Exception {     if (!initialized) {         // first run, set iterators to first elements         it1Empty = !this.iterator1.nextKey().         it2Empty = !this.iterator2.nextKey().         initialized = true.     }     if (it1Empty && it2Empty) {         return false.     } else if (it2Empty) {         if (outerJoinType == OuterJoinType.LEFT || outerJoinType == OuterJoinType.FULL) {             joinLeftKeyValuesWithNull(iterator1.getValues(), joinFunction, collector).             it1Empty = !iterator1.nextKey().             return true.         } else {             // consume rest of left side             while (iterator1.nextKey()) {             }             it1Empty = true.             return false.         }     } else if (it1Empty) {         if (outerJoinType == OuterJoinType.RIGHT || outerJoinType == OuterJoinType.FULL) {             joinRightKeyValuesWithNull(iterator2.getValues(), joinFunction, collector).             it2Empty = !iterator2.nextKey().             return true.         } else {             // consume rest of right side             while (iterator2.nextKey()) {             }             it2Empty = true.             return false.         }     } else {         final TypePairComparator<T1, T2> comparator = super.pairComparator.         comparator.setReference(this.iterator1.getCurrent()).         T2 current2 = this.iterator2.getCurrent().         // zig zag         while (true) {             // determine the relation between the (possibly composite) keys             final int comp = comparator.compareToReference(current2).             if (comp == 0) {                 break.             }             if (comp < 0) {                 // right key < left key                 if (outerJoinType == OuterJoinType.RIGHT || outerJoinType == OuterJoinType.FULL) {                     // join right key values with null in case of right or full outer join                     joinRightKeyValuesWithNull(iterator2.getValues(), joinFunction, collector).                     it2Empty = !iterator2.nextKey().                     return true.                 } else {                     // skip this right key if it is a left outer join                     if (!this.iterator2.nextKey()) {                         // if right side is empty, join current left key values with null                         joinLeftKeyValuesWithNull(iterator1.getValues(), joinFunction, collector).                         it1Empty = !iterator1.nextKey().                         it2Empty = true.                         return true.                     }                     current2 = this.iterator2.getCurrent().                 }             } else {                 // right key > left key                 if (outerJoinType == OuterJoinType.LEFT || outerJoinType == OuterJoinType.FULL) {                     // join left key values with null in case of left or full outer join                     joinLeftKeyValuesWithNull(iterator1.getValues(), joinFunction, collector).                     it1Empty = !iterator1.nextKey().                     return true.                 } else {                     // skip this left key if it is a right outer join                     if (!this.iterator1.nextKey()) {                         // if right side is empty, join current right key values with null                         joinRightKeyValuesWithNull(iterator2.getValues(), joinFunction, collector).                         it1Empty = true.                         it2Empty = !iterator2.nextKey().                         return true.                     }                     comparator.setReference(this.iterator1.getCurrent()).                 }             }         }         // here, we have a common key! call the join function with the cross product of the         // values         final Iterator<T1> values1 = this.iterator1.getValues().         final Iterator<T2> values2 = this.iterator2.getValues().         crossMatchingGroup(values1, values2, joinFunction, collector).         it1Empty = !iterator1.nextKey().         it2Empty = !iterator2.nextKey().         return true.     } }
false;private;3;7;;private void joinLeftKeyValuesWithNull(Iterator<T1> values, FlatJoinFunction<T1, T2, O> joinFunction, Collector<O> collector) throws Exception {     while (values.hasNext()) {         T1 next = values.next().         this.copy1 = createCopy(serializer1, next, copy1).         joinFunction.join(copy1, null, collector).     } }
false;private;3;7;;private void joinRightKeyValuesWithNull(Iterator<T2> values, FlatJoinFunction<T1, T2, O> joinFunction, Collector<O> collector) throws Exception {     while (values.hasNext()) {         T2 next = values.next().         this.copy2 = createCopy(serializer2, next, copy2).         joinFunction.join(null, copy2, collector).     } }
