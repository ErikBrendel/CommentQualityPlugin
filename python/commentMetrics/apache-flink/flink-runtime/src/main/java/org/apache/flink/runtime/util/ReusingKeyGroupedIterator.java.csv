commented;modifiers;parameterAmount;loc;comment;code
true;public;0;57;/**  * Moves the iterator to the next key. This method may skip any values that have not yet been returned by the  * iterator created by the {@link #getValues()} method. Hence, if called multiple times it "removes" pairs.  *  * @return true if the input iterator has an other group of key-value pairs that share the same key.  */ ;/**  * Moves the iterator to the next key. This method may skip any values that have not yet been returned by the  * iterator created by the {@link #getValues()} method. Hence, if called multiple times it "removes" pairs.  *  * @return true if the input iterator has an other group of key-value pairs that share the same key.  */ @Override public boolean nextKey() throws IOException {     // first element (or empty)     if (this.current == null) {         if (this.done) {             this.valuesIterator = null.             return false.         }         this.current = this.reuse.         if ((this.current = this.iterator.next(this.current)) != null) {             this.comparator.setReference(this.current).             this.lookAheadHasNext = false.             this.valuesIterator = new ValuesIterator().             this.valuesIterator.currentIsUnconsumed = true.             return true.         } else {             // empty input, set everything null             this.valuesIterator = null.             this.current = null.             this.done = true.             return false.         }     }     this.valuesIterator.iteratorAvailable = true.     // Whole value-iterator was read and a new key is available.     if (this.lookAheadHasNext) {         this.lookAheadHasNext = false.         this.current = this.lookahead.         this.lookahead = null.         this.comparator.setReference(this.current).         this.valuesIterator.currentIsUnconsumed = true.         return true.     }     // Required if user code / reduce() method did not read the whole value iterator.     while (true) {         if (!this.done && ((this.current = this.iterator.next(this.current)) != null)) {             if (!this.comparator.equalToReference(this.current)) {                 // the keys do not match, so we have a new group. store the current keys                 this.comparator.setReference(this.current).                 this.lookAheadHasNext = false.                 this.valuesIterator.currentIsUnconsumed = true.                 return true.             }         } else {             this.valuesIterator = null.             this.current = null.             this.done = true.             return false.         }     } }
false;public;0;3;;public TypeComparator<E> getComparatorWithCurrentReference() {     return this.comparator. }
false;public;0;4;;@Override public E getCurrent() {     return this.current. }
true;public;0;4;/**  * Returns an iterator over all values that belong to the current key. The iterator is initially <code>null</code>  * (before the first call to {@link #nextKey()} and after all keys are consumed. In general, this method returns  * always a non-null value, if a previous call to {@link #nextKey()} return <code>true</code>.  *  * @return Iterator over all values that belong to the current key.  */ ;/**  * Returns an iterator over all values that belong to the current key. The iterator is initially <code>null</code>  * (before the first call to {@link #nextKey()} and after all keys are consumed. In general, this method returns  * always a non-null value, if a previous call to {@link #nextKey()} return <code>true</code>.  *  * @return Iterator over all values that belong to the current key.  */ @Override public ValuesIterator getValues() {     return this.valuesIterator. }
false;public;0;41;;@Override public boolean hasNext() {     if (ReusingKeyGroupedIterator.this.current == null || ReusingKeyGroupedIterator.this.lookAheadHasNext) {         return false.     }     if (this.currentIsUnconsumed) {         return true.     }     try {         // read the next value into the staging record to make sure we keep the         // current as it is in case the key changed         E stagingStaging = ReusingKeyGroupedIterator.this.iterator.next(this.staging).         if (stagingStaging != null) {             this.staging = stagingStaging.             if (this.comparator.equalToReference(this.staging)) {                 // same key, next value is in staging, so exchange staging with current                 final E tmp = this.staging.                 this.staging = ReusingKeyGroupedIterator.this.current.                 ReusingKeyGroupedIterator.this.current = tmp.                 this.currentIsUnconsumed = true.                 return true.             } else {                 // moved to the next key, no more values here                 ReusingKeyGroupedIterator.this.lookAheadHasNext = true.                 ReusingKeyGroupedIterator.this.lookahead = this.staging.                 this.staging = ReusingKeyGroupedIterator.this.current.                 return false.             }         } else {             // backing iterator is consumed             ReusingKeyGroupedIterator.this.done = true.             return false.         }     } catch (IOException ioex) {         throw new RuntimeException("An error occurred while reading the next record: " + ioex.getMessage(), ioex).     } }
true;public;0;9;/**  * Prior to call this method, call hasNext() once!  */ ;/**  * Prior to call this method, call hasNext() once!  */ @Override public E next() {     if (this.currentIsUnconsumed || hasNext()) {         this.currentIsUnconsumed = false.         return ReusingKeyGroupedIterator.this.current.     } else {         throw new NoSuchElementException().     } }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;10;;@Override public Iterator<E> iterator() {     if (iteratorAvailable) {         iteratorAvailable = false.         return this.     } else {         throw new TraversableOnceException().     } }
