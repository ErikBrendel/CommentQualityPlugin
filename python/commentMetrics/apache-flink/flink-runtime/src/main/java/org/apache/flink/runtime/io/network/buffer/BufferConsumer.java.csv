commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Checks whether the {@link BufferBuilder} has already been finished.  *  * <p>BEWARE: this method accesses the cached value of the position marker which is only updated  * after calls to {@link #build()}!  *  * @return <tt>true</tt> if the buffer was finished, <tt>false</tt> otherwise  */ ;/**  * Checks whether the {@link BufferBuilder} has already been finished.  *  * <p>BEWARE: this method accesses the cached value of the position marker which is only updated  * after calls to {@link #build()}!  *  * @return <tt>true</tt> if the buffer was finished, <tt>false</tt> otherwise  */ public boolean isFinished() {     return writerPosition.isFinished(). }
true;public;0;7;/**  * @return sliced {@link Buffer} containing the not yet consumed data. Returned {@link Buffer} shares the reference  * counter with the parent {@link BufferConsumer} - in order to recycle memory both of them must be recycled/closed.  */ ;/**  * @return sliced {@link Buffer} containing the not yet consumed data. Returned {@link Buffer} shares the reference  * counter with the parent {@link BufferConsumer} - in order to recycle memory both of them must be recycled/closed.  */ public Buffer build() {     writerPosition.update().     int cachedWriterPosition = writerPosition.getCached().     Buffer slice = buffer.readOnlySlice(currentReaderPosition, cachedWriterPosition - currentReaderPosition).     currentReaderPosition = cachedWriterPosition.     return slice.retainBuffer(). }
true;public;0;3;/**  * Returns a retained copy with separate indexes. This allows to read from the same {@link MemorySegment} twice.  *  * <p>WARNING: the newly returned {@link BufferConsumer} will have its reader index copied from the original buffer.  * In other words, data already consumed before copying will not be visible to the returned copies.  *  * @return a retained copy of self with separate indexes  */ ;/**  * Returns a retained copy with separate indexes. This allows to read from the same {@link MemorySegment} twice.  *  * <p>WARNING: the newly returned {@link BufferConsumer} will have its reader index copied from the original buffer.  * In other words, data already consumed before copying will not be visible to the returned copies.  *  * @return a retained copy of self with separate indexes  */ public BufferConsumer copy() {     return new BufferConsumer(buffer.retainBuffer(), writerPosition.positionMarker, currentReaderPosition). }
false;public;0;3;;public boolean isBuffer() {     return buffer.isBuffer(). }
false;public;0;6;;@Override public void close() {     if (!buffer.isRecycled()) {         buffer.recycleBuffer().     } }
false;public;0;3;;public boolean isRecycled() {     return buffer.isRecycled(). }
false;public;0;3;;public int getWrittenBytes() {     return writerPosition.getCached(). }
false;public;0;3;;public boolean isFinished() {     return PositionMarker.isFinished(cachedPosition). }
false;public;0;3;;public int getCached() {     return PositionMarker.getAbsolute(cachedPosition). }
false;private;0;3;;private void update() {     this.cachedPosition = positionMarker.get(). }
