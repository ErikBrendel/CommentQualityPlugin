commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isFinished() {     return inputGate.isFinished(). }
false;public;2;4;;// ------------------------------------------------------------------------ // Events // ------------------------------------------------------------------------ @Override public void registerTaskEventListener(EventListener<TaskEvent> listener, Class<? extends TaskEvent> eventType) {     taskEventHandler.subscribe(listener, eventType). }
false;public;1;4;;@Override public void sendTaskEvent(TaskEvent event) throws IOException {     inputGate.sendTaskEvent(event). }
true;protected;1;33;/**  * Handles the event and returns whether the reader reached an end-of-stream event (either the  * end of the whole stream or the end of an superstep).  */ ;/**  * Handles the event and returns whether the reader reached an end-of-stream event (either the  * end of the whole stream or the end of an superstep).  */ protected boolean handleEvent(AbstractEvent event) throws IOException {     final Class<?> eventType = event.getClass().     try {         // channel, at which it was received.         if (eventType == EndOfPartitionEvent.class) {             return true.         } else if (eventType == EndOfSuperstepEvent.class) {             return incrementEndOfSuperstepEventAndCheck().         } else // ------------------------------------------------------------         if (event instanceof TaskEvent) {             taskEventHandler.publish((TaskEvent) event).             return false.         } else {             throw new IllegalStateException("Received unexpected event of type " + eventType + " at reader.").         }     } catch (Throwable t) {         throw new IOException("Error while handling event of type " + eventType + ": " + t.getMessage(), t).     } }
false;public;1;3;;public void publish(TaskEvent event) {     taskEventHandler.publish(event). }
false;public;0;4;;// ------------------------------------------------------------------------ // Iterations // ------------------------------------------------------------------------ @Override public void setIterativeReader() {     isIterative = true. }
false;public;0;7;;@Override public void startNextSuperstep() {     checkState(isIterative, "Tried to start next superstep in a non-iterative reader.").     checkState(currentNumberOfEndOfSuperstepEvents == inputGate.getNumberOfInputChannels(), "Tried to start next superstep before reaching end of previous superstep.").     currentNumberOfEndOfSuperstepEvents = 0. }
false;public;0;5;;@Override public boolean hasReachedEndOfSuperstep() {     return isIterative && currentNumberOfEndOfSuperstepEvents == inputGate.getNumberOfInputChannels(). }
false;private;0;6;;private boolean incrementEndOfSuperstepEventAndCheck() {     checkState(isIterative, "Tried to increment superstep count in a non-iterative reader.").     checkState(currentNumberOfEndOfSuperstepEvents + 1 <= inputGate.getNumberOfInputChannels(), "Received too many (" + currentNumberOfEndOfSuperstepEvents + ") end of superstep events.").     return ++currentNumberOfEndOfSuperstepEvents == inputGate.getNumberOfInputChannels(). }
