commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int recordSize() {     return recordSize. }
false;public;0;4;;@Override public int recordsPerSegment() {     return recordsPerSegment. }
true;public;0;16;/**  * Resets the sort buffer back to the state where it is empty. All contained data is discarded.  */ ;// ------------------------------------------------------------------------- // Memory Segment // ------------------------------------------------------------------------- /**  * Resets the sort buffer back to the state where it is empty. All contained data is discarded.  */ @Override public void reset() {     // reset all offsets     this.numRecords = 0.     this.currentSortBufferOffset = 0.     this.sortBufferBytes = 0.     // return all memory     this.freeMemory.addAll(this.sortBuffer).     this.sortBuffer.clear().     // grab first buffers     this.currentSortBufferSegment = nextMemorySegment().     this.sortBuffer.add(this.currentSortBufferSegment).     this.outView.set(this.currentSortBufferSegment). }
true;public;0;4;/**  * Checks whether the buffer is empty.  *  * @return True, if no record is contained, false otherwise.  */ ;/**  * Checks whether the buffer is empty.  *  * @return True, if no record is contained, false otherwise.  */ @Override public boolean isEmpty() {     return this.numRecords == 0. }
false;public;0;5;;@Override public void dispose() {     this.freeMemory.clear().     this.sortBuffer.clear(). }
false;public;0;4;;@Override public long getCapacity() {     return ((long) this.totalNumBuffers) * this.segmentSize. }
false;public;0;4;;@Override public long getOccupancy() {     return this.sortBufferBytes. }
false;public;1;4;;// ------------------------------------------------------------------------- // Retrieving and Writing // ------------------------------------------------------------------------- @Override public T getRecord(int logicalPosition) throws IOException {     return getRecord(serializer.createInstance(), logicalPosition). }
false;public;2;7;;@Override public T getRecord(T reuse, int logicalPosition) throws IOException {     final int buffer = logicalPosition / this.recordsPerSegment.     final int inBuffer = (logicalPosition % this.recordsPerSegment) * this.recordSize.     this.inView.set(this.sortBuffer.get(buffer), inBuffer).     return this.comparator.readWithKeyDenormalization(reuse, this.inView). }
true;public;1;26;/**  * Writes a given record to this sort buffer. The written record will be appended and take  * the last logical position.  *  * @param record The record to be written.  * @return True, if the record was successfully written, false, if the sort buffer was full.  * @throws IOException Thrown, if an error occurred while serializing the record into the buffers.  */ ;/**  * Writes a given record to this sort buffer. The written record will be appended and take  * the last logical position.  *  * @param record The record to be written.  * @return True, if the record was successfully written, false, if the sort buffer was full.  * @throws IOException Thrown, if an error occurred while serializing the record into the buffers.  */ @Override public boolean write(T record) throws IOException {     // check whether we need a new memory segment for the sort index     if (this.currentSortBufferOffset > this.lastEntryOffset) {         if (memoryAvailable()) {             this.currentSortBufferSegment = nextMemorySegment().             this.sortBuffer.add(this.currentSortBufferSegment).             this.outView.set(this.currentSortBufferSegment).             this.currentSortBufferOffset = 0.             this.sortBufferBytes += this.segmentSize.         } else {             return false.         }     }     // serialize the record into the data buffers     try {         this.comparator.writeWithKeyNormalization(record, this.outView).         this.numRecords++.         this.currentSortBufferOffset += this.recordSize.         return true.     } catch (EOFException eofex) {         throw new IOException("Error: Serialization consumes more bytes than announced by the serializer.").     } }
false;private;0;3;;// ------------------------------------------------------------------------ // Access Utilities // ------------------------------------------------------------------------ private boolean memoryAvailable() {     return !this.freeMemory.isEmpty(). }
false;private;0;3;;private MemorySegment nextMemorySegment() {     return this.freeMemory.remove(this.freeMemory.size() - 1). }
false;public;2;10;;// ------------------------------------------------------------------------- // Sorting // ------------------------------------------------------------------------- @Override public int compare(int i, int j) {     final int segmentNumberI = i / this.recordsPerSegment.     final int segmentOffsetI = (i % this.recordsPerSegment) * this.recordSize.     final int segmentNumberJ = j / this.recordsPerSegment.     final int segmentOffsetJ = (j % this.recordsPerSegment) * this.recordSize.     return compare(segmentNumberI, segmentOffsetI, segmentNumberJ, segmentOffsetJ). }
false;public;4;8;;@Override public int compare(int segmentNumberI, int segmentOffsetI, int segmentNumberJ, int segmentOffsetJ) {     final MemorySegment segI = this.sortBuffer.get(segmentNumberI).     final MemorySegment segJ = this.sortBuffer.get(segmentNumberJ).     int val = segI.compare(segJ, segmentOffsetI, segmentOffsetJ, this.numKeyBytes).     return this.useNormKeyUninverted ? val : -val. }
false;public;2;10;;@Override public void swap(int i, int j) {     final int segmentNumberI = i / this.recordsPerSegment.     final int segmentOffsetI = (i % this.recordsPerSegment) * this.recordSize.     final int segmentNumberJ = j / this.recordsPerSegment.     final int segmentOffsetJ = (j % this.recordsPerSegment) * this.recordSize.     swap(segmentNumberI, segmentOffsetI, segmentNumberJ, segmentOffsetJ). }
false;public;4;7;;@Override public void swap(int segmentNumberI, int segmentOffsetI, int segmentNumberJ, int segmentOffsetJ) {     final MemorySegment segI = this.sortBuffer.get(segmentNumberI).     final MemorySegment segJ = this.sortBuffer.get(segmentNumberJ).     segI.swapBytes(this.swapBuffer, segJ, segmentOffsetI, segmentOffsetJ, this.recordSize). }
false;public;0;4;;@Override public int size() {     return this.numRecords. }
false;public;1;24;;@Override public T next(T reuse) {     if (this.currentTotal < this.numTotal) {         if (this.currentInSegment >= this.numPerSegment) {             this.currentInSegment = 0.             this.currentSegmentIndex++.             this.in.set(sortBuffer.get(this.currentSegmentIndex), 0).         }         this.currentTotal++.         this.currentInSegment++.         try {             return this.comp.readWithKeyDenormalization(reuse, this.in).         } catch (IOException ioe) {             throw new RuntimeException(ioe).         }     } else {         return null.     } }
false;public;0;24;;@Override public T next() {     if (this.currentTotal < this.numTotal) {         if (this.currentInSegment >= this.numPerSegment) {             this.currentInSegment = 0.             this.currentSegmentIndex++.             this.in.set(sortBuffer.get(this.currentSegmentIndex), 0).         }         this.currentTotal++.         this.currentInSegment++.         try {             return this.comp.readWithKeyDenormalization(serializer.createInstance(), this.in).         } catch (IOException ioe) {             throw new RuntimeException(ioe).         }     } else {         return null.     } }
true;public,final;0;68;/**  * Gets an iterator over all records in this buffer in their logical order.  *  * @return An iterator returning the records in their logical order.  */ ;// ------------------------------------------------------------------------- /**  * Gets an iterator over all records in this buffer in their logical order.  *  * @return An iterator returning the records in their logical order.  */ @Override public final MutableObjectIterator<T> getIterator() {     final SingleSegmentInputView startIn = new SingleSegmentInputView(this.recordsPerSegment * this.recordSize).     startIn.set(this.sortBuffer.get(0), 0).     return new MutableObjectIterator<T>() {          private final SingleSegmentInputView in = startIn.          private final TypeComparator<T> comp = comparator.          private final int numTotal = size().          private final int numPerSegment = recordsPerSegment.          private int currentTotal = 0.          private int currentInSegment = 0.          private int currentSegmentIndex = 0.          @Override         public T next(T reuse) {             if (this.currentTotal < this.numTotal) {                 if (this.currentInSegment >= this.numPerSegment) {                     this.currentInSegment = 0.                     this.currentSegmentIndex++.                     this.in.set(sortBuffer.get(this.currentSegmentIndex), 0).                 }                 this.currentTotal++.                 this.currentInSegment++.                 try {                     return this.comp.readWithKeyDenormalization(reuse, this.in).                 } catch (IOException ioe) {                     throw new RuntimeException(ioe).                 }             } else {                 return null.             }         }          @Override         public T next() {             if (this.currentTotal < this.numTotal) {                 if (this.currentInSegment >= this.numPerSegment) {                     this.currentInSegment = 0.                     this.currentSegmentIndex++.                     this.in.set(sortBuffer.get(this.currentSegmentIndex), 0).                 }                 this.currentTotal++.                 this.currentInSegment++.                 try {                     return this.comp.readWithKeyDenormalization(serializer.createInstance(), this.in).                 } catch (IOException ioe) {                     throw new RuntimeException(ioe).                 }             } else {                 return null.             }         }     }. }
true;public;1;33;/**  * Writes the records in this buffer in their logical order to the given output.  *  * @param output The output view to write the records to.  * @throws IOException Thrown, if an I/O exception occurred writing to the output view.  */ ;// ------------------------------------------------------------------------ // Writing to a DataOutputView // ------------------------------------------------------------------------ /**  * Writes the records in this buffer in their logical order to the given output.  *  * @param output The output view to write the records to.  * @throws IOException Thrown, if an I/O exception occurred writing to the output view.  */ @Override public void writeToOutput(final ChannelWriterOutputView output) throws IOException {     final TypeComparator<T> comparator = this.comparator.     final TypeSerializer<T> serializer = this.serializer.     T record = this.recordInstance.     final SingleSegmentInputView inView = this.inView.     final int recordsPerSegment = this.recordsPerSegment.     int recordsLeft = this.numRecords.     int currentMemSeg = 0.     while (recordsLeft > 0) {         final MemorySegment currentIndexSegment = this.sortBuffer.get(currentMemSeg++).         inView.set(currentIndexSegment, 0).         // check whether we have a full or partially full segment         if (recordsLeft >= recordsPerSegment) {             // full segment             for (int numInMemSeg = 0. numInMemSeg < recordsPerSegment. numInMemSeg++) {                 record = comparator.readWithKeyDenormalization(record, inView).                 serializer.serialize(record, output).             }             recordsLeft -= recordsPerSegment.         } else {             // partially filled segment             for (. recordsLeft > 0. recordsLeft--) {                 record = comparator.readWithKeyDenormalization(record, inView).                 serializer.serialize(record, output).             }         }     } }
false;public;2;6;;@Override public void writeToOutput(ChannelWriterOutputView output, LargeRecordHandler<T> largeRecordsOutput) throws IOException {     writeToOutput(output). }
true;public;3;35;/**  * Writes a subset of the records in this buffer in their logical order to the given output.  *  * @param output The output view to write the records to.  * @param start The logical start position of the subset.  * @param num The number of elements to write.  * @throws IOException Thrown, if an I/O exception occurred writing to the output view.  */ ;/**  * Writes a subset of the records in this buffer in their logical order to the given output.  *  * @param output The output view to write the records to.  * @param start The logical start position of the subset.  * @param num The number of elements to write.  * @throws IOException Thrown, if an I/O exception occurred writing to the output view.  */ @Override public void writeToOutput(final ChannelWriterOutputView output, final int start, int num) throws IOException {     final TypeComparator<T> comparator = this.comparator.     final TypeSerializer<T> serializer = this.serializer.     T record = this.recordInstance.     final SingleSegmentInputView inView = this.inView.     final int recordsPerSegment = this.recordsPerSegment.     int currentMemSeg = start / recordsPerSegment.     int offset = (start % recordsPerSegment) * this.recordSize.     while (num > 0) {         final MemorySegment currentIndexSegment = this.sortBuffer.get(currentMemSeg++).         inView.set(currentIndexSegment, offset).         // check whether we have a full or partially full segment         if (num >= recordsPerSegment && offset == 0) {             // full segment             for (int numInMemSeg = 0. numInMemSeg < recordsPerSegment. numInMemSeg++) {                 record = comparator.readWithKeyDenormalization(record, inView).                 serializer.serialize(record, output).             }             num -= recordsPerSegment.         } else {             // partially filled segment             for (. num > 0 && offset <= this.lastEntryOffset. num--, offset += this.recordSize) {                 record = comparator.readWithKeyDenormalization(record, inView).                 serializer.serialize(record, output).             }         }         offset = 0.     } }
false;;1;3;;void set(MemorySegment segment) {     seekOutput(segment, 0). }
false;protected;2;4;;@Override protected MemorySegment nextSegment(MemorySegment current, int positionInCurrent) throws IOException {     throw new EOFException(). }
false;protected;2;3;;protected void set(MemorySegment segment, int offset) {     seekInput(segment, offset, this.limit). }
false;protected;1;4;;@Override protected MemorySegment nextSegment(MemorySegment current) throws EOFException {     throw new EOFException(). }
false;protected;1;4;;@Override protected int getLimitForSegment(MemorySegment segment) {     return this.limit. }
