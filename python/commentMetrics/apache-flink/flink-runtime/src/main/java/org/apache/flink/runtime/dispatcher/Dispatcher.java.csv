commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;// ------------------------------------------------------ // Lifecycle methods // ------------------------------------------------------ @Override public void onStart() throws Exception {     try {         startDispatcherServices().     } catch (Exception e) {         final DispatcherException exception = new DispatcherException(String.format("Could not start the Dispatcher %s", getAddress()), e).         onFatalError(exception).         throw exception.     } }
false;private;0;10;;private void startDispatcherServices() throws Exception {     try {         submittedJobGraphStore.start(this).         leaderElectionService.start(this).         registerDispatcherMetrics(jobManagerMetricGroup).     } catch (Exception e) {         handleStartDispatcherServicesException(e).     } }
false;private;1;9;;private void handleStartDispatcherServicesException(Exception e) throws Exception {     try {         stopDispatcherServices().     } catch (Exception exception) {         e.addSuppressed(exception).     }     throw e. }
false;public;0;14;;@Override public CompletableFuture<Void> onStop() {     log.info("Stopping dispatcher {}.", getAddress()).     final CompletableFuture<Void> allJobManagerRunnersTerminationFuture = terminateJobManagerRunnersAndGetTerminationFuture().     return FutureUtils.runAfterwards(allJobManagerRunnersTerminationFuture, () -> {         stopDispatcherServices().         log.info("Stopped dispatcher {}.", getAddress()).     }). }
false;private;0;24;;private void stopDispatcherServices() throws Exception {     Exception exception = null.     try {         jobManagerSharedServices.shutdown().     } catch (Exception e) {         exception = ExceptionUtils.firstOrSuppressed(e, exception).     }     try {         submittedJobGraphStore.stop().     } catch (Exception e) {         exception = ExceptionUtils.firstOrSuppressed(e, exception).     }     try {         leaderElectionService.stop().     } catch (Exception e) {         exception = ExceptionUtils.firstOrSuppressed(e, exception).     }     jobManagerMetricGroup.close().     ExceptionUtils.tryRethrowException(exception). }
false;public;2;8;;// ------------------------------------------------------ // RPCs // ------------------------------------------------------ @Override public CompletableFuture<Acknowledge> submitJob(JobGraph jobGraph, Time timeout) {     return internalSubmitJob(jobGraph).whenCompleteAsync((acknowledge, throwable) -> {         if (throwable != null) {             cleanUpJobData(jobGraph.getJobID(), true).         }     }, getRpcService().getExecutor()). }
false;private;1;28;;private CompletableFuture<Acknowledge> internalSubmitJob(JobGraph jobGraph) {     final JobID jobId = jobGraph.getJobID().     log.info("Submitting job {} ({}).", jobId, jobGraph.getName()).     final RunningJobsRegistry.JobSchedulingStatus jobSchedulingStatus.     try {         jobSchedulingStatus = runningJobsRegistry.getJobSchedulingStatus(jobId).     } catch (IOException e) {         return FutureUtils.completedExceptionally(new FlinkException(String.format("Failed to retrieve job scheduling status for job %s.", jobId), e)).     }     if (jobSchedulingStatus == RunningJobsRegistry.JobSchedulingStatus.DONE || jobManagerRunnerFutures.containsKey(jobId)) {         return FutureUtils.completedExceptionally(new JobSubmissionException(jobId, String.format("Job has already been submitted and is in state %s.", jobSchedulingStatus))).     } else {         final CompletableFuture<Acknowledge> persistAndRunFuture = waitForTerminatingJobManager(jobId, jobGraph, this::persistAndRunJob).thenApply(ignored -> Acknowledge.get()).         return persistAndRunFuture.exceptionally((Throwable throwable) -> {             final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable).             log.error("Failed to submit job {}.", jobId, strippedThrowable).             throw new CompletionException(new JobSubmissionException(jobId, "Failed to submit job.", strippedThrowable)).         }).     } }
false;private;1;11;;private CompletableFuture<Void> persistAndRunJob(JobGraph jobGraph) throws Exception {     submittedJobGraphStore.putJobGraph(new SubmittedJobGraph(jobGraph)).     final CompletableFuture<Void> runJobFuture = runJob(jobGraph).     return runJobFuture.whenComplete(BiConsumerWithException.unchecked((Object ignored, Throwable throwable) -> {         if (throwable != null) {             submittedJobGraphStore.removeJobGraph(jobGraph.getJobID()).         }     })). }
false;private;1;17;;private CompletableFuture<Void> runJob(JobGraph jobGraph) {     Preconditions.checkState(!jobManagerRunnerFutures.containsKey(jobGraph.getJobID())).     final CompletableFuture<JobManagerRunner> jobManagerRunnerFuture = createJobManagerRunner(jobGraph).     jobManagerRunnerFutures.put(jobGraph.getJobID(), jobManagerRunnerFuture).     return jobManagerRunnerFuture.thenApply(FunctionUtils.nullFn()).whenCompleteAsync((ignored, throwable) -> {         if (throwable != null) {             jobManagerRunnerFutures.remove(jobGraph.getJobID()).         }     }, getMainThreadExecutor()). }
false;private;1;18;;private CompletableFuture<JobManagerRunner> createJobManagerRunner(JobGraph jobGraph) {     final RpcService rpcService = getRpcService().     final CompletableFuture<JobManagerRunner> jobManagerRunnerFuture = CompletableFuture.supplyAsync(CheckedSupplier.unchecked(() -> jobManagerRunnerFactory.createJobManagerRunner(jobGraph, configuration, rpcService, highAvailabilityServices, heartbeatServices, jobManagerSharedServices, new DefaultJobManagerJobMetricGroupFactory(jobManagerMetricGroup), fatalErrorHandler)), rpcService.getExecutor()).     return jobManagerRunnerFuture.thenApply(FunctionUtils.uncheckedFunction(this::startJobManagerRunner)). }
false;private;1;27;;private JobManagerRunner startJobManagerRunner(JobManagerRunner jobManagerRunner) throws Exception {     final JobID jobId = jobManagerRunner.getJobGraph().getJobID().     jobManagerRunner.getResultFuture().whenCompleteAsync((ArchivedExecutionGraph archivedExecutionGraph, Throwable throwable) -> {         // noinspection ObjectEquality         if (jobManagerRunner == jobManagerRunnerFutures.get(jobId).getNow(null)) {             if (archivedExecutionGraph != null) {                 jobReachedGloballyTerminalState(archivedExecutionGraph).             } else {                 final Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable).                 if (strippedThrowable instanceof JobNotFinishedException) {                     jobNotFinished(jobId).                 } else {                     jobMasterFailed(jobId, strippedThrowable).                 }             }         } else {             log.debug("There is a newer JobManagerRunner for the job {}.", jobId).         }     }, getMainThreadExecutor()).     jobManagerRunner.start().     return jobManagerRunner. }
false;public;1;5;;@Override public CompletableFuture<Collection<JobID>> listJobs(Time timeout) {     return CompletableFuture.completedFuture(Collections.unmodifiableSet(new HashSet<>(jobManagerRunnerFutures.keySet()))). }
false;public;2;18;;@Override public CompletableFuture<Acknowledge> disposeSavepoint(String savepointPath, Time timeout) {     final ClassLoader classLoader = Thread.currentThread().getContextClassLoader().     return CompletableFuture.supplyAsync(() -> {         log.info("Disposing savepoint {}.", savepointPath).         try {             Checkpoints.disposeSavepoint(savepointPath, configuration, classLoader, log).         } catch (IOException | FlinkException e) {             throw new CompletionException(new FlinkException(String.format("Could not dispose savepoint %s.", savepointPath), e)).         }         return Acknowledge.get().     }, jobManagerSharedServices.getScheduledExecutorService()). }
false;public;2;6;;@Override public CompletableFuture<Acknowledge> cancelJob(JobID jobId, Time timeout) {     final CompletableFuture<JobMasterGateway> jobMasterGatewayFuture = getJobMasterGatewayFuture(jobId).     return jobMasterGatewayFuture.thenCompose((JobMasterGateway jobMasterGateway) -> jobMasterGateway.cancel(timeout)). }
false;public;2;6;;@Override public CompletableFuture<Acknowledge> stopJob(JobID jobId, Time timeout) {     final CompletableFuture<JobMasterGateway> jobMasterGatewayFuture = getJobMasterGatewayFuture(jobId).     return jobMasterGatewayFuture.thenCompose((JobMasterGateway jobMasterGateway) -> jobMasterGateway.stop(timeout)). }
false;public;4;8;;@Override public CompletableFuture<Acknowledge> rescaleJob(JobID jobId, int newParallelism, RescalingBehaviour rescalingBehaviour, Time timeout) {     final CompletableFuture<JobMasterGateway> jobMasterGatewayFuture = getJobMasterGatewayFuture(jobId).     return jobMasterGatewayFuture.thenCompose((JobMasterGateway jobMasterGateway) -> jobMasterGateway.rescaleJob(newParallelism, rescalingBehaviour, timeout)). }
false;public;1;20;;@Override public CompletableFuture<ClusterOverview> requestClusterOverview(Time timeout) {     CompletableFuture<ResourceOverview> taskManagerOverviewFuture = runResourceManagerCommand(resourceManagerGateway -> resourceManagerGateway.requestResourceOverview(timeout)).     final List<CompletableFuture<Optional<JobStatus>>> optionalJobInformation = queryJobMastersForInformation((JobMasterGateway jobMasterGateway) -> jobMasterGateway.requestJobStatus(timeout)).     CompletableFuture<Collection<Optional<JobStatus>>> allOptionalJobsFuture = FutureUtils.combineAll(optionalJobInformation).     CompletableFuture<Collection<JobStatus>> allJobsFuture = allOptionalJobsFuture.thenApply(this::flattenOptionalCollection).     final JobsOverview completedJobsOverview = archivedExecutionGraphStore.getStoredJobsOverview().     return allJobsFuture.thenCombine(taskManagerOverviewFuture, (Collection<JobStatus> runningJobsStatus, ResourceOverview resourceOverview) -> {         final JobsOverview allJobsOverview = JobsOverview.create(runningJobsStatus).combine(completedJobsOverview).         return new ClusterOverview(resourceOverview, allJobsOverview).     }). }
false;public;1;22;;@Override public CompletableFuture<MultipleJobsDetails> requestMultipleJobDetails(Time timeout) {     List<CompletableFuture<Optional<JobDetails>>> individualOptionalJobDetails = queryJobMastersForInformation((JobMasterGateway jobMasterGateway) -> jobMasterGateway.requestJobDetails(timeout)).     CompletableFuture<Collection<Optional<JobDetails>>> optionalCombinedJobDetails = FutureUtils.combineAll(individualOptionalJobDetails).     CompletableFuture<Collection<JobDetails>> combinedJobDetails = optionalCombinedJobDetails.thenApply(this::flattenOptionalCollection).     final Collection<JobDetails> completedJobDetails = archivedExecutionGraphStore.getAvailableJobDetails().     return combinedJobDetails.thenApply((Collection<JobDetails> runningJobDetails) -> {         final Collection<JobDetails> allJobDetails = new ArrayList<>(completedJobDetails.size() + runningJobDetails.size()).         allJobDetails.addAll(runningJobDetails).         allJobDetails.addAll(completedJobDetails).         return new MultipleJobsDetails(allJobDetails).     }). }
false;public;2;20;;@Override public CompletableFuture<JobStatus> requestJobStatus(JobID jobId, Time timeout) {     final CompletableFuture<JobMasterGateway> jobMasterGatewayFuture = getJobMasterGatewayFuture(jobId).     final CompletableFuture<JobStatus> jobStatusFuture = jobMasterGatewayFuture.thenCompose((JobMasterGateway jobMasterGateway) -> jobMasterGateway.requestJobStatus(timeout)).     return jobStatusFuture.exceptionally((Throwable throwable) -> {         final JobDetails jobDetails = archivedExecutionGraphStore.getAvailableJobDetails(jobId).         // check whether it is a completed job         if (jobDetails == null) {             throw new CompletionException(ExceptionUtils.stripCompletionException(throwable)).         } else {             return jobDetails.getStatus().         }     }). }
false;public;2;8;;@Override public CompletableFuture<OperatorBackPressureStatsResponse> requestOperatorBackPressureStats(final JobID jobId, final JobVertexID jobVertexId) {     final CompletableFuture<JobMasterGateway> jobMasterGatewayFuture = getJobMasterGatewayFuture(jobId).     return jobMasterGatewayFuture.thenCompose((JobMasterGateway jobMasterGateway) -> jobMasterGateway.requestOperatorBackPressureStats(jobVertexId)). }
false;public;2;19;;@Override public CompletableFuture<ArchivedExecutionGraph> requestJob(JobID jobId, Time timeout) {     final CompletableFuture<JobMasterGateway> jobMasterGatewayFuture = getJobMasterGatewayFuture(jobId).     final CompletableFuture<ArchivedExecutionGraph> archivedExecutionGraphFuture = jobMasterGatewayFuture.thenCompose((JobMasterGateway jobMasterGateway) -> jobMasterGateway.requestJob(timeout)).     return archivedExecutionGraphFuture.exceptionally((Throwable throwable) -> {         final ArchivedExecutionGraph serializableExecutionGraph = archivedExecutionGraphStore.get(jobId).         // check whether it is a completed job         if (serializableExecutionGraph == null) {             throw new CompletionException(ExceptionUtils.stripCompletionException(throwable)).         } else {             return serializableExecutionGraph.         }     }). }
false;public;2;16;;@Override public CompletableFuture<JobResult> requestJobResult(JobID jobId, Time timeout) {     final CompletableFuture<JobManagerRunner> jobManagerRunnerFuture = jobManagerRunnerFutures.get(jobId).     if (jobManagerRunnerFuture == null) {         final ArchivedExecutionGraph archivedExecutionGraph = archivedExecutionGraphStore.get(jobId).         if (archivedExecutionGraph == null) {             return FutureUtils.completedExceptionally(new FlinkJobNotFoundException(jobId)).         } else {             return CompletableFuture.completedFuture(JobResult.createFrom(archivedExecutionGraph)).         }     } else {         return jobManagerRunnerFuture.thenCompose(JobManagerRunner::getResultFuture).thenApply(JobResult::createFrom).     } }
false;public;1;8;;@Override public CompletableFuture<Collection<String>> requestMetricQueryServicePaths(Time timeout) {     if (metricQueryServicePath != null) {         return CompletableFuture.completedFuture(Collections.singleton(metricQueryServicePath)).     } else {         return CompletableFuture.completedFuture(Collections.emptyList()).     } }
false;public;1;4;;@Override public CompletableFuture<Collection<Tuple2<ResourceID, String>>> requestTaskManagerMetricQueryServicePaths(Time timeout) {     return runResourceManagerCommand(resourceManagerGateway -> resourceManagerGateway.requestTaskManagerMetricQueryServicePaths(timeout)). }
false;public;1;4;;@Override public CompletableFuture<Integer> getBlobServerPort(Time timeout) {     return CompletableFuture.completedFuture(blobServer.getPort()). }
false;public;4;12;;@Override public CompletableFuture<String> triggerSavepoint(final JobID jobId, final String targetDirectory, final boolean cancelJob, final Time timeout) {     final CompletableFuture<JobMasterGateway> jobMasterGatewayFuture = getJobMasterGatewayFuture(jobId).     return jobMasterGatewayFuture.thenCompose((JobMasterGateway jobMasterGateway) -> jobMasterGateway.triggerSavepoint(targetDirectory, cancelJob, timeout)). }
false;public;0;5;;@Override public CompletableFuture<Acknowledge> shutDownCluster() {     closeAsync().     return CompletableFuture.completedFuture(Acknowledge.get()). }
true;private;2;5;/**  * Cleans up the job related data from the dispatcher. If cleanupHA is true, then  * the data will also be removed from HA.  *  * @param jobId JobID identifying the job to clean up  * @param cleanupHA True iff HA data shall also be cleaned up  */ ;/**  * Cleans up the job related data from the dispatcher. If cleanupHA is true, then  * the data will also be removed from HA.  *  * @param jobId JobID identifying the job to clean up  * @param cleanupHA True iff HA data shall also be cleaned up  */ private void removeJobAndRegisterTerminationFuture(JobID jobId, boolean cleanupHA) {     final CompletableFuture<Void> cleanupFuture = removeJob(jobId, cleanupHA).     registerJobManagerRunnerTerminationFuture(jobId, cleanupFuture). }
false;private;2;17;;private void registerJobManagerRunnerTerminationFuture(JobID jobId, CompletableFuture<Void> jobManagerRunnerTerminationFuture) {     Preconditions.checkState(!jobManagerTerminationFutures.containsKey(jobId)).     jobManagerTerminationFutures.put(jobId, jobManagerRunnerTerminationFuture).     // clean up the pending termination future     jobManagerRunnerTerminationFuture.thenRunAsync(() -> {         final CompletableFuture<Void> terminationFuture = jobManagerTerminationFutures.remove(jobId).         // noinspection ObjectEquality         if (terminationFuture != null && terminationFuture != jobManagerRunnerTerminationFuture) {             jobManagerTerminationFutures.put(jobId, terminationFuture).         }     }, getUnfencedMainThreadExecutor()). }
false;private;2;14;;private CompletableFuture<Void> removeJob(JobID jobId, boolean cleanupHA) {     CompletableFuture<JobManagerRunner> jobManagerRunnerFuture = jobManagerRunnerFutures.remove(jobId).     final CompletableFuture<Void> jobManagerRunnerTerminationFuture.     if (jobManagerRunnerFuture != null) {         jobManagerRunnerTerminationFuture = jobManagerRunnerFuture.thenCompose(JobManagerRunner::closeAsync).     } else {         jobManagerRunnerTerminationFuture = CompletableFuture.completedFuture(null).     }     return jobManagerRunnerTerminationFuture.thenRunAsync(() -> cleanUpJobData(jobId, cleanupHA), getRpcService().getExecutor()). }
false;private;2;29;;private void cleanUpJobData(JobID jobId, boolean cleanupHA) {     jobManagerMetricGroup.removeJob(jobId).     boolean cleanupHABlobs = false.     if (cleanupHA) {         try {             submittedJobGraphStore.removeJobGraph(jobId).             // only clean up the HA blobs if we could remove the job from HA storage             cleanupHABlobs = true.         } catch (Exception e) {             log.warn("Could not properly remove job {} from submitted job graph store.", jobId, e).         }         try {             runningJobsRegistry.clearJob(jobId).         } catch (IOException e) {             log.warn("Could not properly remove job {} from the running jobs registry.", jobId, e).         }     } else {         try {             submittedJobGraphStore.releaseJobGraph(jobId).         } catch (Exception e) {             log.warn("Could not properly release job {} from submitted job graph store.", jobId, e).         }     }     blobServer.cleanupJob(jobId, cleanupHABlobs). }
true;private;0;9;/**  * Terminate all currently running {@link JobManagerRunner}.  */ ;/**  * Terminate all currently running {@link JobManagerRunner}.  */ private void terminateJobManagerRunners() {     log.info("Stopping all currently running jobs of dispatcher {}.", getAddress()).     final HashSet<JobID> jobsToRemove = new HashSet<>(jobManagerRunnerFutures.keySet()).     for (JobID jobId : jobsToRemove) {         removeJobAndRegisterTerminationFuture(jobId, false).     } }
false;private;0;5;;private CompletableFuture<Void> terminateJobManagerRunnersAndGetTerminationFuture() {     terminateJobManagerRunners().     final Collection<CompletableFuture<Void>> values = jobManagerTerminationFutures.values().     return FutureUtils.completeAll(values). }
true;;0;19;/**  * Recovers all jobs persisted via the submitted job graph store.  */ ;/**  * Recovers all jobs persisted via the submitted job graph store.  */ @VisibleForTesting Collection<JobGraph> recoverJobs() throws Exception {     log.info("Recovering all persisted jobs.").     final Collection<JobID> jobIds = submittedJobGraphStore.getJobIds().     try {         return recoverJobGraphs(jobIds).     } catch (Exception e) {         // release all recovered job graphs         for (JobID jobId : jobIds) {             try {                 submittedJobGraphStore.releaseJobGraph(jobId).             } catch (Exception ie) {                 e.addSuppressed(ie).             }         }         throw e.     } }
false;private;1;16;;@Nonnull private Collection<JobGraph> recoverJobGraphs(Collection<JobID> jobIds) throws Exception {     final List<JobGraph> jobGraphs = new ArrayList<>(jobIds.size()).     for (JobID jobId : jobIds) {         final JobGraph jobGraph = recoverJob(jobId).         if (jobGraph == null) {             throw new FlinkJobNotFoundException(jobId).         }         jobGraphs.add(jobGraph).     }     return jobGraphs. }
false;private;1;11;;@Nullable private JobGraph recoverJob(JobID jobId) throws Exception {     log.debug("Recover job {}.", jobId).     final SubmittedJobGraph submittedJobGraph = submittedJobGraphStore.recoverJobGraph(jobId).     if (submittedJobGraph != null) {         return submittedJobGraph.getJobGraph().     } else {         return null.     } }
false;protected;1;3;;protected void onFatalError(Throwable throwable) {     fatalErrorHandler.onFatalError(throwable). }
false;protected;1;15;;protected void jobReachedGloballyTerminalState(ArchivedExecutionGraph archivedExecutionGraph) {     Preconditions.checkArgument(archivedExecutionGraph.getState().isGloballyTerminalState(), "Job %s is in state %s which is not globally terminal.", archivedExecutionGraph.getJobID(), archivedExecutionGraph.getState()).     log.info("Job {} reached globally terminal state {}.", archivedExecutionGraph.getJobID(), archivedExecutionGraph.getState()).     archiveExecutionGraph(archivedExecutionGraph).     final JobID jobId = archivedExecutionGraph.getJobID().     removeJobAndRegisterTerminationFuture(jobId, true). }
false;private;1;24;;private void archiveExecutionGraph(ArchivedExecutionGraph archivedExecutionGraph) {     try {         archivedExecutionGraphStore.put(archivedExecutionGraph).     } catch (IOException e) {         log.info("Could not store completed job {}({}).", archivedExecutionGraph.getJobName(), archivedExecutionGraph.getJobID(), e).     }     final CompletableFuture<Acknowledge> executionGraphFuture = historyServerArchivist.archiveExecutionGraph(archivedExecutionGraph).     executionGraphFuture.whenComplete((Acknowledge ignored, Throwable throwable) -> {         if (throwable != null) {             log.info("Could not archive completed job {}({}) to the history server.", archivedExecutionGraph.getJobName(), archivedExecutionGraph.getJobID(), throwable).         }     }). }
false;protected;1;5;;protected void jobNotFinished(JobID jobId) {     log.info("Job {} was not finished by JobManager.", jobId).     removeJobAndRegisterTerminationFuture(jobId, false). }
false;private;2;5;;private void jobMasterFailed(JobID jobId, Throwable cause) {     // we fail fatally in case of a JobMaster failure in order to restart the     // dispatcher to recover the jobs again. This only works in HA mode, though     onFatalError(new FlinkException(String.format("JobMaster for job %s failed.", jobId), cause)). }
false;private;1;19;;private CompletableFuture<JobMasterGateway> getJobMasterGatewayFuture(JobID jobId) {     final CompletableFuture<JobManagerRunner> jobManagerRunnerFuture = jobManagerRunnerFutures.get(jobId).     if (jobManagerRunnerFuture == null) {         return FutureUtils.completedExceptionally(new FlinkJobNotFoundException(jobId)).     } else {         final CompletableFuture<JobMasterGateway> leaderGatewayFuture = jobManagerRunnerFuture.thenCompose(JobManagerRunner::getLeaderGatewayFuture).         return leaderGatewayFuture.thenApplyAsync((JobMasterGateway jobMasterGateway) -> {             // check whether the retrieved JobMasterGateway belongs still to a running JobMaster             if (jobManagerRunnerFutures.containsKey(jobId)) {                 return jobMasterGateway.             } else {                 throw new CompletionException(new FlinkJobNotFoundException(jobId)).             }         }, getMainThreadExecutor()).     } }
false;private;0;3;;private CompletableFuture<ResourceManagerGateway> getResourceManagerGateway() {     return resourceManagerGatewayRetriever.getFuture(). }
false;private;1;3;;private <T> CompletableFuture<T> runResourceManagerCommand(Function<ResourceManagerGateway, CompletableFuture<T>> resourceManagerCommand) {     return getResourceManagerGateway().thenApply(resourceManagerCommand).thenCompose(Function.identity()). }
false;private;1;3;;private <T> List<T> flattenOptionalCollection(Collection<Optional<T>> optionalCollection) {     return optionalCollection.stream().filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList()). }
false;private;1;18;;@Nonnull private <T> List<CompletableFuture<Optional<T>>> queryJobMastersForInformation(Function<JobMasterGateway, CompletableFuture<T>> queryFunction) {     final int numberJobsRunning = jobManagerRunnerFutures.size().     ArrayList<CompletableFuture<Optional<T>>> optionalJobInformation = new ArrayList<>(numberJobsRunning).     for (JobID jobId : jobManagerRunnerFutures.keySet()) {         final CompletableFuture<JobMasterGateway> jobMasterGatewayFuture = getJobMasterGatewayFuture(jobId).         final CompletableFuture<Optional<T>> optionalRequest = jobMasterGatewayFuture.thenCompose(queryFunction::apply).handle((T value, Throwable throwable) -> Optional.ofNullable(value)).         optionalJobInformation.add(optionalRequest).     }     return optionalJobInformation. }
true;public;1;41;/**  * Callback method when current resourceManager is granted leadership.  *  * @param newLeaderSessionID unique leadershipID  */ ;// ------------------------------------------------------ // Leader contender // ------------------------------------------------------ /**  * Callback method when current resourceManager is granted leadership.  *  * @param newLeaderSessionID unique leadershipID  */ @Override public void grantLeadership(final UUID newLeaderSessionID) {     runAsyncWithoutFencing(() -> {         log.info("Dispatcher {} was granted leadership with fencing token {}", getAddress(), newLeaderSessionID).         final CompletableFuture<Collection<JobGraph>> recoveredJobsFuture = recoveryOperation.thenApplyAsync(FunctionUtils.uncheckedFunction(ignored -> recoverJobs()), getRpcService().getExecutor()).         final CompletableFuture<Boolean> fencingTokenFuture = recoveredJobsFuture.thenComposeAsync((Collection<JobGraph> recoveredJobs) -> tryAcceptLeadershipAndRunJobs(newLeaderSessionID, recoveredJobs), getUnfencedMainThreadExecutor()).         final CompletableFuture<Void> confirmationFuture = fencingTokenFuture.thenCombineAsync(recoveredJobsFuture, BiFunctionWithException.unchecked((Boolean confirmLeadership, Collection<JobGraph> recoveredJobs) -> {             if (confirmLeadership) {                 leaderElectionService.confirmLeaderSessionID(newLeaderSessionID).             } else {                 for (JobGraph recoveredJob : recoveredJobs) {                     submittedJobGraphStore.releaseJobGraph(recoveredJob.getJobID()).                 }             }             return null.         }), getRpcService().getExecutor()).         confirmationFuture.whenComplete((Void ignored, Throwable throwable) -> {             if (throwable != null) {                 onFatalError(new DispatcherException(String.format("Failed to take leadership with session id %s.", newLeaderSessionID), (ExceptionUtils.stripCompletionException(throwable)))).             }         }).         recoveryOperation = confirmationFuture.     }). }
false;private;2;20;;private CompletableFuture<Boolean> tryAcceptLeadershipAndRunJobs(UUID newLeaderSessionID, Collection<JobGraph> recoveredJobs) {     final DispatcherId dispatcherId = DispatcherId.fromUuid(newLeaderSessionID).     if (leaderElectionService.hasLeadership(newLeaderSessionID)) {         log.debug("Dispatcher {} accepted leadership with fencing token {}. Start recovered jobs.", getAddress(), dispatcherId).         setNewFencingToken(dispatcherId).         Collection<CompletableFuture<?>> runFutures = new ArrayList<>(recoveredJobs.size()).         for (JobGraph recoveredJob : recoveredJobs) {             final CompletableFuture<?> runFuture = waitForTerminatingJobManager(recoveredJob.getJobID(), recoveredJob, this::runJob).             runFutures.add(runFuture).         }         return FutureUtils.waitForAll(runFutures).thenApply(ignored -> true).     } else {         log.debug("Dispatcher {} lost leadership before accepting it. Stop recovering jobs for fencing token {}.", getAddress(), dispatcherId).         return CompletableFuture.completedFuture(false).     } }
false;private;3;15;;private CompletableFuture<Void> waitForTerminatingJobManager(JobID jobId, JobGraph jobGraph, FunctionWithException<JobGraph, CompletableFuture<Void>, ?> action) {     final CompletableFuture<Void> jobManagerTerminationFuture = getJobTerminationFuture(jobId).exceptionally((Throwable throwable) -> {         throw new CompletionException(new DispatcherException(String.format("Termination of previous JobManager for job %s failed. Cannot submit job under the same job id.", jobId), throwable)).     }).     return jobManagerTerminationFuture.thenComposeAsync(FunctionUtils.uncheckedFunction((ignored) -> {         jobManagerTerminationFutures.remove(jobId).         return action.apply(jobGraph).     }), getMainThreadExecutor()). }
false;;1;7;;CompletableFuture<Void> getJobTerminationFuture(JobID jobId) {     if (jobManagerRunnerFutures.containsKey(jobId)) {         return FutureUtils.completedExceptionally(new DispatcherException(String.format("Job with job id %s is still running.", jobId))).     } else {         return jobManagerTerminationFutures.getOrDefault(jobId, CompletableFuture.completedFuture(null)).     } }
false;;0;4;;@VisibleForTesting CompletableFuture<Void> getRecoveryOperation() {     return recoveryOperation. }
false;private;1;8;;private void setNewFencingToken(@Nullable DispatcherId dispatcherId) {     // clear the state if we've been the leader before     if (getFencingToken() != null) {         clearDispatcherState().     }     setFencingToken(dispatcherId). }
false;private;0;3;;private void clearDispatcherState() {     terminateJobManagerRunners(). }
false;private;1;4;;private void registerDispatcherMetrics(MetricGroup jobManagerMetricGroup) {     jobManagerMetricGroup.gauge(MetricNames.NUM_RUNNING_JOBS, () -> (long) jobManagerRunnerFutures.size()). }
true;public;0;9;/**  * Callback method when current resourceManager loses leadership.  */ ;/**  * Callback method when current resourceManager loses leadership.  */ @Override public void revokeLeadership() {     runAsyncWithoutFencing(() -> {         log.info("Dispatcher {} was revoked leadership.", getAddress()).         setNewFencingToken(null).     }). }
true;public;1;4;/**  * Handles error occurring in the leader election service.  *  * @param exception Exception being thrown in the leader election service  */ ;/**  * Handles error occurring in the leader election service.  *  * @param exception Exception being thrown in the leader election service  */ @Override public void handleError(final Exception exception) {     onFatalError(new DispatcherException("Received an error from the LeaderElectionService.", exception)). }
false;public;1;39;;// ------------------------------------------------------ // SubmittedJobGraphListener // ------------------------------------------------------ @Override public void onAddedJobGraph(final JobID jobId) {     runAsync(() -> {         if (!jobManagerRunnerFutures.containsKey(jobId)) {             // IMPORTANT: onAddedJobGraph can generate false positives and, thus, we must expect that             // the specified job is already removed from the SubmittedJobGraphStore. In this case,             // SubmittedJobGraphStore.recoverJob returns null.             final CompletableFuture<Optional<JobGraph>> recoveredJob = recoveryOperation.thenApplyAsync(FunctionUtils.uncheckedFunction(ignored -> Optional.ofNullable(recoverJob(jobId))), getRpcService().getExecutor()).             final DispatcherId dispatcherId = getFencingToken().             final CompletableFuture<Void> submissionFuture = recoveredJob.thenComposeAsync((Optional<JobGraph> jobGraphOptional) -> jobGraphOptional.map(FunctionUtils.uncheckedFunction(jobGraph -> tryRunRecoveredJobGraph(jobGraph, dispatcherId).thenAcceptAsync(FunctionUtils.uncheckedConsumer((Boolean isRecoveredJobRunning) -> {                 if (!isRecoveredJobRunning) {                     submittedJobGraphStore.releaseJobGraph(jobId).                 }             }), getRpcService().getExecutor()))).orElse(CompletableFuture.completedFuture(null)), getUnfencedMainThreadExecutor()).             submissionFuture.whenComplete((Void ignored, Throwable throwable) -> {                 if (throwable != null) {                     onFatalError(new DispatcherException(String.format("Could not start the added job %s", jobId), ExceptionUtils.stripCompletionException(throwable))).                 }             }).             recoveryOperation = submissionFuture.         }     }). }
false;private;2;18;;private CompletableFuture<Boolean> tryRunRecoveredJobGraph(JobGraph jobGraph, DispatcherId dispatcherId) throws Exception {     if (leaderElectionService.hasLeadership(dispatcherId.toUUID())) {         final JobID jobId = jobGraph.getJobID().         if (jobManagerRunnerFutures.containsKey(jobId)) {             // we must not release the job graph lock since it can only be locked once and             // is currently being executed. Once we support multiple locks, we must release             // the JobGraph here             log.debug("Ignore added JobGraph because the job {} is already running.", jobId).             return CompletableFuture.completedFuture(true).         } else if (runningJobsRegistry.getJobSchedulingStatus(jobId) != RunningJobsRegistry.JobSchedulingStatus.DONE) {             return waitForTerminatingJobManager(jobId, jobGraph, this::runJob).thenApply(ignored -> true).         } else {             log.debug("Ignore added JobGraph because the job {} has already been completed.", jobId).         }     }     return CompletableFuture.completedFuture(false). }
false;public;1;10;;@Override public void onRemovedJobGraph(final JobID jobId) {     runAsync(() -> {         try {             removeJobAndRegisterTerminationFuture(jobId, false).         } catch (final Exception e) {             onFatalError(new DispatcherException(String.format("Could not remove job %s.", jobId), e)).         }     }). }
