# id;timestamp;commentText;codeText;commentWords;codeWords
RoundRobinOperatorStateRepartitioner -> private List<Map<StreamStateHandle, OperatorStateHandle>> repartition( 			Map<String, List<Tuple2<StreamStateHandle, long[]>>> nameToState, int parallelism);1475231926;Repartition all named states.;private List<Map<StreamStateHandle, OperatorStateHandle>> repartition(_			Map<String, List<Tuple2<StreamStateHandle, long[]>>> nameToState, int parallelism) {__		_		List<Map<StreamStateHandle, OperatorStateHandle>> mergeMapList = new ArrayList<>(parallelism)__		_		for (int i = 0_ i < parallelism_ ++i) {_			mergeMapList.add(new HashMap<StreamStateHandle, OperatorStateHandle>())__		}__		int startParallelOP = 0__		_		for (Map.Entry<String, List<Tuple2<StreamStateHandle, long[]>>> e : nameToState.entrySet()) {__			List<Tuple2<StreamStateHandle, long[]>> current = e.getValue()___			_			int totalPartitions = 0__			for (Tuple2<StreamStateHandle, long[]> offsets : current) {_				totalPartitions += offsets.f1.length__			}__			_			int lstIdx = 0__			int offsetIdx = 0__			int baseFraction = totalPartitions / parallelism__			int remainder = totalPartitions % parallelism___			int newStartParallelOp = startParallelOP___			for (int i = 0_ i < parallelism_ ++i) {__				_				int parallelOpIdx = (i + startParallelOP) % parallelism___				_				int numberOfPartitionsToAssign = baseFraction___				_				if (remainder > 0) {_					++numberOfPartitionsToAssign__					--remainder__				} else if (remainder == 0) {_					_					_					newStartParallelOp = parallelOpIdx__					--remainder__				}__				_				List<Tuple2<StreamStateHandle, long[]>> parallelOperatorState = new ArrayList<>()___				while (numberOfPartitionsToAssign > 0) {_					Tuple2<StreamStateHandle, long[]> handleWithOffsets = current.get(lstIdx)__					long[] offsets = handleWithOffsets.f1__					int remaining = offsets.length - offsetIdx__					_					long[] offs__					if (remaining > numberOfPartitionsToAssign) {_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsetIdx + numberOfPartitionsToAssign)__						offsetIdx += numberOfPartitionsToAssign__					} else {_						if (OPTIMIZE_MEMORY_USE) {_							handleWithOffsets.f1 = null_ _						}_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsets.length)__						offsetIdx = 0__						++lstIdx__					}__					parallelOperatorState.add(_							new Tuple2<>(handleWithOffsets.f0, offs))___					numberOfPartitionsToAssign -= remaining___					_					_					Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(parallelOpIdx)__					OperatorStateHandle psh = mergeMap.get(handleWithOffsets.f0)__					if (psh == null) {_						psh = new OperatorStateHandle(handleWithOffsets.f0, new HashMap<String, long[]>())__						mergeMap.put(handleWithOffsets.f0, psh)__					}_					psh.getStateNameToPartitionOffsets().put(e.getKey(), offs)__				}_			}_			startParallelOP = newStartParallelOp__			e.setValue(null)__		}_		return mergeMapList__	};repartition,all,named,states;private,list,map,stream,state,handle,operator,state,handle,repartition,map,string,list,tuple2,stream,state,handle,long,name,to,state,int,parallelism,list,map,stream,state,handle,operator,state,handle,merge,map,list,new,array,list,parallelism,for,int,i,0,i,parallelism,i,merge,map,list,add,new,hash,map,stream,state,handle,operator,state,handle,int,start,parallel,op,0,for,map,entry,string,list,tuple2,stream,state,handle,long,e,name,to,state,entry,set,list,tuple2,stream,state,handle,long,current,e,get,value,int,total,partitions,0,for,tuple2,stream,state,handle,long,offsets,current,total,partitions,offsets,f1,length,int,lst,idx,0,int,offset,idx,0,int,base,fraction,total,partitions,parallelism,int,remainder,total,partitions,parallelism,int,new,start,parallel,op,start,parallel,op,for,int,i,0,i,parallelism,i,int,parallel,op,idx,i,start,parallel,op,parallelism,int,number,of,partitions,to,assign,base,fraction,if,remainder,0,number,of,partitions,to,assign,remainder,else,if,remainder,0,new,start,parallel,op,parallel,op,idx,remainder,list,tuple2,stream,state,handle,long,parallel,operator,state,new,array,list,while,number,of,partitions,to,assign,0,tuple2,stream,state,handle,long,handle,with,offsets,current,get,lst,idx,long,offsets,handle,with,offsets,f1,int,remaining,offsets,length,offset,idx,long,offs,if,remaining,number,of,partitions,to,assign,offs,arrays,copy,of,range,offsets,offset,idx,offset,idx,number,of,partitions,to,assign,offset,idx,number,of,partitions,to,assign,else,if,handle,with,offsets,f1,null,offs,arrays,copy,of,range,offsets,offset,idx,offsets,length,offset,idx,0,lst,idx,parallel,operator,state,add,new,tuple2,handle,with,offsets,f0,offs,number,of,partitions,to,assign,remaining,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,parallel,op,idx,operator,state,handle,psh,merge,map,get,handle,with,offsets,f0,if,psh,null,psh,new,operator,state,handle,handle,with,offsets,f0,new,hash,map,string,long,merge,map,put,handle,with,offsets,f0,psh,psh,get,state,name,to,partition,offsets,put,e,get,key,offs,start,parallel,op,new,start,parallel,op,e,set,value,null,return,merge,map,list
RoundRobinOperatorStateRepartitioner -> private List<Map<StreamStateHandle, OperatorStateHandle>> repartition( 			Map<String, List<Tuple2<StreamStateHandle, long[]>>> nameToState, int parallelism);1476972861;Repartition all named states.;private List<Map<StreamStateHandle, OperatorStateHandle>> repartition(_			Map<String, List<Tuple2<StreamStateHandle, long[]>>> nameToState, int parallelism) {__		_		List<Map<StreamStateHandle, OperatorStateHandle>> mergeMapList = new ArrayList<>(parallelism)__		_		for (int i = 0_ i < parallelism_ ++i) {_			mergeMapList.add(new HashMap<StreamStateHandle, OperatorStateHandle>())__		}__		int startParallelOP = 0__		_		for (Map.Entry<String, List<Tuple2<StreamStateHandle, long[]>>> e : nameToState.entrySet()) {__			List<Tuple2<StreamStateHandle, long[]>> current = e.getValue()___			_			int totalPartitions = 0__			for (Tuple2<StreamStateHandle, long[]> offsets : current) {_				totalPartitions += offsets.f1.length__			}__			_			int lstIdx = 0__			int offsetIdx = 0__			int baseFraction = totalPartitions / parallelism__			int remainder = totalPartitions % parallelism___			int newStartParallelOp = startParallelOP___			for (int i = 0_ i < parallelism_ ++i) {__				_				int parallelOpIdx = (i + startParallelOP) % parallelism___				_				int numberOfPartitionsToAssign = baseFraction___				_				if (remainder > 0) {_					++numberOfPartitionsToAssign__					--remainder__				} else if (remainder == 0) {_					_					_					newStartParallelOp = parallelOpIdx__					--remainder__				}__				_				List<Tuple2<StreamStateHandle, long[]>> parallelOperatorState = new ArrayList<>()___				while (numberOfPartitionsToAssign > 0) {_					Tuple2<StreamStateHandle, long[]> handleWithOffsets = current.get(lstIdx)__					long[] offsets = handleWithOffsets.f1__					int remaining = offsets.length - offsetIdx__					_					long[] offs__					if (remaining > numberOfPartitionsToAssign) {_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsetIdx + numberOfPartitionsToAssign)__						offsetIdx += numberOfPartitionsToAssign__					} else {_						if (OPTIMIZE_MEMORY_USE) {_							handleWithOffsets.f1 = null_ _						}_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsets.length)__						offsetIdx = 0__						++lstIdx__					}__					parallelOperatorState.add(_							new Tuple2<>(handleWithOffsets.f0, offs))___					numberOfPartitionsToAssign -= remaining___					_					_					Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(parallelOpIdx)__					OperatorStateHandle psh = mergeMap.get(handleWithOffsets.f0)__					if (psh == null) {_						psh = new OperatorStateHandle(new HashMap<String, long[]>(), handleWithOffsets.f0)__						mergeMap.put(handleWithOffsets.f0, psh)__					}_					psh.getStateNameToPartitionOffsets().put(e.getKey(), offs)__				}_			}_			startParallelOP = newStartParallelOp__			e.setValue(null)__		}_		return mergeMapList__	};repartition,all,named,states;private,list,map,stream,state,handle,operator,state,handle,repartition,map,string,list,tuple2,stream,state,handle,long,name,to,state,int,parallelism,list,map,stream,state,handle,operator,state,handle,merge,map,list,new,array,list,parallelism,for,int,i,0,i,parallelism,i,merge,map,list,add,new,hash,map,stream,state,handle,operator,state,handle,int,start,parallel,op,0,for,map,entry,string,list,tuple2,stream,state,handle,long,e,name,to,state,entry,set,list,tuple2,stream,state,handle,long,current,e,get,value,int,total,partitions,0,for,tuple2,stream,state,handle,long,offsets,current,total,partitions,offsets,f1,length,int,lst,idx,0,int,offset,idx,0,int,base,fraction,total,partitions,parallelism,int,remainder,total,partitions,parallelism,int,new,start,parallel,op,start,parallel,op,for,int,i,0,i,parallelism,i,int,parallel,op,idx,i,start,parallel,op,parallelism,int,number,of,partitions,to,assign,base,fraction,if,remainder,0,number,of,partitions,to,assign,remainder,else,if,remainder,0,new,start,parallel,op,parallel,op,idx,remainder,list,tuple2,stream,state,handle,long,parallel,operator,state,new,array,list,while,number,of,partitions,to,assign,0,tuple2,stream,state,handle,long,handle,with,offsets,current,get,lst,idx,long,offsets,handle,with,offsets,f1,int,remaining,offsets,length,offset,idx,long,offs,if,remaining,number,of,partitions,to,assign,offs,arrays,copy,of,range,offsets,offset,idx,offset,idx,number,of,partitions,to,assign,offset,idx,number,of,partitions,to,assign,else,if,handle,with,offsets,f1,null,offs,arrays,copy,of,range,offsets,offset,idx,offsets,length,offset,idx,0,lst,idx,parallel,operator,state,add,new,tuple2,handle,with,offsets,f0,offs,number,of,partitions,to,assign,remaining,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,parallel,op,idx,operator,state,handle,psh,merge,map,get,handle,with,offsets,f0,if,psh,null,psh,new,operator,state,handle,new,hash,map,string,long,handle,with,offsets,f0,merge,map,put,handle,with,offsets,f0,psh,psh,get,state,name,to,partition,offsets,put,e,get,key,offs,start,parallel,op,new,start,parallel,op,e,set,value,null,return,merge,map,list
RoundRobinOperatorStateRepartitioner -> @SuppressWarnings("unchecked, rawtype") 	private GroupByStateNameResults groupByStateName( 			List<OperatorStateHandle> previousParallelSubtaskStates);1484339359;Group by the different named states.;@SuppressWarnings("unchecked, rawtype")_	private GroupByStateNameResults groupByStateName(_			List<OperatorStateHandle> previousParallelSubtaskStates) {__		_		EnumMap<OperatorStateHandle.Mode,_				Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>>> nameToStateByMode =_				new EnumMap<>(OperatorStateHandle.Mode.class)___		for (OperatorStateHandle.Mode mode : OperatorStateHandle.Mode.values()) {_			Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> map = new HashMap<>()__			nameToStateByMode.put(_					mode,_					new HashMap<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>>())__		}__		for (OperatorStateHandle psh : previousParallelSubtaskStates) {__			for (Map.Entry<String, OperatorStateHandle.StateMetaInfo> e :_					psh.getStateNameToPartitionOffsets().entrySet()) {_				OperatorStateHandle.StateMetaInfo metaInfo = e.getValue()___				Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> nameToState =_						nameToStateByMode.get(metaInfo.getDistributionMode())___				List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> stateLocations =_						nameToState.get(e.getKey())___				if (stateLocations == null) {_					stateLocations = new ArrayList<>()__					nameToState.put(e.getKey(), stateLocations)__				}__				stateLocations.add(new Tuple2<>(psh.getDelegateStateHandle(), e.getValue()))__			}_		}__		return new GroupByStateNameResults(nameToStateByMode)__	};group,by,the,different,named,states;suppress,warnings,unchecked,rawtype,private,group,by,state,name,results,group,by,state,name,list,operator,state,handle,previous,parallel,subtask,states,enum,map,operator,state,handle,mode,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,state,by,mode,new,enum,map,operator,state,handle,mode,class,for,operator,state,handle,mode,mode,operator,state,handle,mode,values,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,map,new,hash,map,name,to,state,by,mode,put,mode,new,hash,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,for,operator,state,handle,psh,previous,parallel,subtask,states,for,map,entry,string,operator,state,handle,state,meta,info,e,psh,get,state,name,to,partition,offsets,entry,set,operator,state,handle,state,meta,info,meta,info,e,get,value,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,state,name,to,state,by,mode,get,meta,info,get,distribution,mode,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,state,locations,name,to,state,get,e,get,key,if,state,locations,null,state,locations,new,array,list,name,to,state,put,e,get,key,state,locations,state,locations,add,new,tuple2,psh,get,delegate,state,handle,e,get,value,return,new,group,by,state,name,results,name,to,state,by,mode
RoundRobinOperatorStateRepartitioner -> @SuppressWarnings("unchecked, rawtype") 	private GroupByStateNameResults groupByStateName( 			List<OperatorStateHandle> previousParallelSubtaskStates);1502801814;Group by the different named states.;@SuppressWarnings("unchecked, rawtype")_	private GroupByStateNameResults groupByStateName(_			List<OperatorStateHandle> previousParallelSubtaskStates) {__		_		EnumMap<OperatorStateHandle.Mode,_				Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>>> nameToStateByMode =_				new EnumMap<>(OperatorStateHandle.Mode.class)___		for (OperatorStateHandle.Mode mode : OperatorStateHandle.Mode.values()) {_			Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> map = new HashMap<>()__			nameToStateByMode.put(_					mode,_					new HashMap<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>>())__		}__		for (OperatorStateHandle psh : previousParallelSubtaskStates) {__			if (psh == null) {_				continue__			}__			for (Map.Entry<String, OperatorStateHandle.StateMetaInfo> e :_					psh.getStateNameToPartitionOffsets().entrySet()) {_				OperatorStateHandle.StateMetaInfo metaInfo = e.getValue()___				Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> nameToState =_						nameToStateByMode.get(metaInfo.getDistributionMode())___				List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> stateLocations =_						nameToState.get(e.getKey())___				if (stateLocations == null) {_					stateLocations = new ArrayList<>()__					nameToState.put(e.getKey(), stateLocations)__				}__				stateLocations.add(new Tuple2<>(psh.getDelegateStateHandle(), e.getValue()))__			}_		}__		return new GroupByStateNameResults(nameToStateByMode)__	};group,by,the,different,named,states;suppress,warnings,unchecked,rawtype,private,group,by,state,name,results,group,by,state,name,list,operator,state,handle,previous,parallel,subtask,states,enum,map,operator,state,handle,mode,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,state,by,mode,new,enum,map,operator,state,handle,mode,class,for,operator,state,handle,mode,mode,operator,state,handle,mode,values,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,map,new,hash,map,name,to,state,by,mode,put,mode,new,hash,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,for,operator,state,handle,psh,previous,parallel,subtask,states,if,psh,null,continue,for,map,entry,string,operator,state,handle,state,meta,info,e,psh,get,state,name,to,partition,offsets,entry,set,operator,state,handle,state,meta,info,meta,info,e,get,value,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,state,name,to,state,by,mode,get,meta,info,get,distribution,mode,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,state,locations,name,to,state,get,e,get,key,if,state,locations,null,state,locations,new,array,list,name,to,state,put,e,get,key,state,locations,state,locations,add,new,tuple2,psh,get,delegate,state,handle,e,get,value,return,new,group,by,state,name,results,name,to,state,by,mode
RoundRobinOperatorStateRepartitioner -> private List<Map<StreamStateHandle, OperatorStateHandle>> repartition( 			GroupByStateNameResults nameToStateByMode, 			int newParallelism);1518008821;Repartition all named states.;private List<Map<StreamStateHandle, OperatorStateHandle>> repartition(_			GroupByStateNameResults nameToStateByMode,_			int newParallelism) {__		_		List<Map<StreamStateHandle, OperatorStateHandle>> mergeMapList = new ArrayList<>(newParallelism)___		_		for (int i = 0_ i < newParallelism_ ++i) {_			mergeMapList.add(new HashMap<>())__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> distributeNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)___		int startParallelOp = 0__		_		for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_				distributeNameToState.entrySet()) {__			List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> current = e.getValue()___			_			int totalPartitions = 0__			for (Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> offsets : current) {_				totalPartitions += offsets.f1.getOffsets().length__			}__			_			int lstIdx = 0__			int offsetIdx = 0__			int baseFraction = totalPartitions / newParallelism__			int remainder = totalPartitions % newParallelism___			int newStartParallelOp = startParallelOp___			for (int i = 0_ i < newParallelism_ ++i) {__				_				int parallelOpIdx = (i + startParallelOp) % newParallelism___				_				int numberOfPartitionsToAssign = baseFraction___				_				if (remainder > 0) {_					++numberOfPartitionsToAssign__					--remainder__				} else if (remainder == 0) {_					_					_					newStartParallelOp = parallelOpIdx__					--remainder__				}__				_				List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> parallelOperatorState =_						new ArrayList<>()___				while (numberOfPartitionsToAssign > 0) {_					Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithOffsets =_							current.get(lstIdx)___					long[] offsets = handleWithOffsets.f1.getOffsets()__					int remaining = offsets.length - offsetIdx__					_					long[] offs__					if (remaining > numberOfPartitionsToAssign) {_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsetIdx + numberOfPartitionsToAssign)__						offsetIdx += numberOfPartitionsToAssign__					} else {_						if (OPTIMIZE_MEMORY_USE) {_							handleWithOffsets.f1 = null_ _						}_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsets.length)__						offsetIdx = 0__						++lstIdx__					}__					parallelOperatorState.add(new Tuple2<>(_							handleWithOffsets.f0,_							new OperatorStateHandle.StateMetaInfo(offs, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)))___					numberOfPartitionsToAssign -= remaining___					_					_					Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(parallelOpIdx)__					OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithOffsets.f0)__					if (operatorStateHandle == null) {_						operatorStateHandle = new OperatorStateHandle(new HashMap<>(), handleWithOffsets.f0)__						mergeMap.put(handleWithOffsets.f0, operatorStateHandle)__					}_					operatorStateHandle.getStateNameToPartitionOffsets().put(_							e.getKey(),_							new OperatorStateHandle.StateMetaInfo(offs, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				}_			}_			startParallelOp = newStartParallelOp__			e.setValue(null)__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> broadcastNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.UNION)___		for (int i = 0_ i < newParallelism_ ++i) {__			Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(i)___			for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_					broadcastNameToState.entrySet()) {__				for (Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithMetaInfo : e.getValue()) {_					OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithMetaInfo.f0)__					if (operatorStateHandle == null) {_						operatorStateHandle = new OperatorStateHandle(new HashMap<>(), handleWithMetaInfo.f0)__						mergeMap.put(handleWithMetaInfo.f0, operatorStateHandle)__					}_					operatorStateHandle.getStateNameToPartitionOffsets().put(e.getKey(), handleWithMetaInfo.f1)__				}_			}_		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> uniformBroadcastNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.BROADCAST)___		for (int i = 0_ i < newParallelism_ ++i) {__			final Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(i)___			_			for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_					uniformBroadcastNameToState.entrySet()) {__				int oldParallelism = e.getValue().size()__				_				Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithMetaInfo =_							e.getValue().get(i % oldParallelism)___				OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithMetaInfo.f0)__				if (operatorStateHandle == null) {_					operatorStateHandle = new OperatorStateHandle(new HashMap<>(), handleWithMetaInfo.f0)__					mergeMap.put(handleWithMetaInfo.f0, operatorStateHandle)__				}_				operatorStateHandle.getStateNameToPartitionOffsets().put(e.getKey(), handleWithMetaInfo.f1)__			}_		}_		return mergeMapList__	};repartition,all,named,states;private,list,map,stream,state,handle,operator,state,handle,repartition,group,by,state,name,results,name,to,state,by,mode,int,new,parallelism,list,map,stream,state,handle,operator,state,handle,merge,map,list,new,array,list,new,parallelism,for,int,i,0,i,new,parallelism,i,merge,map,list,add,new,hash,map,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,distribute,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,int,start,parallel,op,0,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,distribute,name,to,state,entry,set,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,current,e,get,value,int,total,partitions,0,for,tuple2,stream,state,handle,operator,state,handle,state,meta,info,offsets,current,total,partitions,offsets,f1,get,offsets,length,int,lst,idx,0,int,offset,idx,0,int,base,fraction,total,partitions,new,parallelism,int,remainder,total,partitions,new,parallelism,int,new,start,parallel,op,start,parallel,op,for,int,i,0,i,new,parallelism,i,int,parallel,op,idx,i,start,parallel,op,new,parallelism,int,number,of,partitions,to,assign,base,fraction,if,remainder,0,number,of,partitions,to,assign,remainder,else,if,remainder,0,new,start,parallel,op,parallel,op,idx,remainder,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,parallel,operator,state,new,array,list,while,number,of,partitions,to,assign,0,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,offsets,current,get,lst,idx,long,offsets,handle,with,offsets,f1,get,offsets,int,remaining,offsets,length,offset,idx,long,offs,if,remaining,number,of,partitions,to,assign,offs,arrays,copy,of,range,offsets,offset,idx,offset,idx,number,of,partitions,to,assign,offset,idx,number,of,partitions,to,assign,else,if,handle,with,offsets,f1,null,offs,arrays,copy,of,range,offsets,offset,idx,offsets,length,offset,idx,0,lst,idx,parallel,operator,state,add,new,tuple2,handle,with,offsets,f0,new,operator,state,handle,state,meta,info,offs,operator,state,handle,mode,number,of,partitions,to,assign,remaining,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,parallel,op,idx,operator,state,handle,operator,state,handle,merge,map,get,handle,with,offsets,f0,if,operator,state,handle,null,operator,state,handle,new,operator,state,handle,new,hash,map,handle,with,offsets,f0,merge,map,put,handle,with,offsets,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,new,operator,state,handle,state,meta,info,offs,operator,state,handle,mode,start,parallel,op,new,start,parallel,op,e,set,value,null,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,broadcast,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,union,for,int,i,0,i,new,parallelism,i,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,i,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,broadcast,name,to,state,entry,set,for,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,meta,info,e,get,value,operator,state,handle,operator,state,handle,merge,map,get,handle,with,meta,info,f0,if,operator,state,handle,null,operator,state,handle,new,operator,state,handle,new,hash,map,handle,with,meta,info,f0,merge,map,put,handle,with,meta,info,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,handle,with,meta,info,f1,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,uniform,broadcast,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,broadcast,for,int,i,0,i,new,parallelism,i,final,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,i,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,uniform,broadcast,name,to,state,entry,set,int,old,parallelism,e,get,value,size,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,meta,info,e,get,value,get,i,old,parallelism,operator,state,handle,operator,state,handle,merge,map,get,handle,with,meta,info,f0,if,operator,state,handle,null,operator,state,handle,new,operator,state,handle,new,hash,map,handle,with,meta,info,f0,merge,map,put,handle,with,meta,info,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,handle,with,meta,info,f1,return,merge,map,list
RoundRobinOperatorStateRepartitioner -> private List<Map<StreamStateHandle, OperatorStateHandle>> repartition( 			GroupByStateNameResults nameToStateByMode, 			int newParallelism);1519568061;Repartition all named states.;private List<Map<StreamStateHandle, OperatorStateHandle>> repartition(_			GroupByStateNameResults nameToStateByMode,_			int newParallelism) {__		_		List<Map<StreamStateHandle, OperatorStateHandle>> mergeMapList = new ArrayList<>(newParallelism)___		_		for (int i = 0_ i < newParallelism_ ++i) {_			mergeMapList.add(new HashMap<>())__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> distributeNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)___		int startParallelOp = 0__		_		for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_				distributeNameToState.entrySet()) {__			List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> current = e.getValue()___			_			int totalPartitions = 0__			for (Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> offsets : current) {_				totalPartitions += offsets.f1.getOffsets().length__			}__			_			int lstIdx = 0__			int offsetIdx = 0__			int baseFraction = totalPartitions / newParallelism__			int remainder = totalPartitions % newParallelism___			int newStartParallelOp = startParallelOp___			for (int i = 0_ i < newParallelism_ ++i) {__				_				int parallelOpIdx = (i + startParallelOp) % newParallelism___				_				int numberOfPartitionsToAssign = baseFraction___				_				if (remainder > 0) {_					++numberOfPartitionsToAssign__					--remainder__				} else if (remainder == 0) {_					_					_					newStartParallelOp = parallelOpIdx__					--remainder__				}__				__				while (numberOfPartitionsToAssign > 0) {_					Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithOffsets =_							current.get(lstIdx)___					long[] offsets = handleWithOffsets.f1.getOffsets()__					int remaining = offsets.length - offsetIdx__					_					long[] offs__					if (remaining > numberOfPartitionsToAssign) {_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsetIdx + numberOfPartitionsToAssign)__						offsetIdx += numberOfPartitionsToAssign__					} else {_						if (OPTIMIZE_MEMORY_USE) {_							handleWithOffsets.f1 = null_ _						}_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsets.length)__						offsetIdx = 0__						++lstIdx__					}__					numberOfPartitionsToAssign -= remaining___					_					_					Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(parallelOpIdx)__					OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithOffsets.f0)__					if (operatorStateHandle == null) {_						operatorStateHandle = new OperatorStreamStateHandle(new HashMap<>(), handleWithOffsets.f0)__						mergeMap.put(handleWithOffsets.f0, operatorStateHandle)__					}_					operatorStateHandle.getStateNameToPartitionOffsets().put(_							e.getKey(),_							new OperatorStateHandle.StateMetaInfo(offs, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				}_			}_			startParallelOp = newStartParallelOp__			e.setValue(null)__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> broadcastNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.UNION)___		for (int i = 0_ i < newParallelism_ ++i) {__			Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(i)___			for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_					broadcastNameToState.entrySet()) {__				for (Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithMetaInfo : e.getValue()) {_					OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithMetaInfo.f0)__					if (operatorStateHandle == null) {_						operatorStateHandle = new OperatorStreamStateHandle(new HashMap<>(), handleWithMetaInfo.f0)__						mergeMap.put(handleWithMetaInfo.f0, operatorStateHandle)__					}_					operatorStateHandle.getStateNameToPartitionOffsets().put(e.getKey(), handleWithMetaInfo.f1)__				}_			}_		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> uniformBroadcastNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.BROADCAST)___		for (int i = 0_ i < newParallelism_ ++i) {__			final Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(i)___			_			for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_					uniformBroadcastNameToState.entrySet()) {__				int oldParallelism = e.getValue().size()___				Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithMetaInfo =_							e.getValue().get(i % oldParallelism)___				OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithMetaInfo.f0)__				if (operatorStateHandle == null) {_					operatorStateHandle = new OperatorStreamStateHandle(new HashMap<>(), handleWithMetaInfo.f0)__					mergeMap.put(handleWithMetaInfo.f0, operatorStateHandle)__				}_				operatorStateHandle.getStateNameToPartitionOffsets().put(e.getKey(), handleWithMetaInfo.f1)__			}_		}_		return mergeMapList__	};repartition,all,named,states;private,list,map,stream,state,handle,operator,state,handle,repartition,group,by,state,name,results,name,to,state,by,mode,int,new,parallelism,list,map,stream,state,handle,operator,state,handle,merge,map,list,new,array,list,new,parallelism,for,int,i,0,i,new,parallelism,i,merge,map,list,add,new,hash,map,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,distribute,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,int,start,parallel,op,0,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,distribute,name,to,state,entry,set,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,current,e,get,value,int,total,partitions,0,for,tuple2,stream,state,handle,operator,state,handle,state,meta,info,offsets,current,total,partitions,offsets,f1,get,offsets,length,int,lst,idx,0,int,offset,idx,0,int,base,fraction,total,partitions,new,parallelism,int,remainder,total,partitions,new,parallelism,int,new,start,parallel,op,start,parallel,op,for,int,i,0,i,new,parallelism,i,int,parallel,op,idx,i,start,parallel,op,new,parallelism,int,number,of,partitions,to,assign,base,fraction,if,remainder,0,number,of,partitions,to,assign,remainder,else,if,remainder,0,new,start,parallel,op,parallel,op,idx,remainder,while,number,of,partitions,to,assign,0,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,offsets,current,get,lst,idx,long,offsets,handle,with,offsets,f1,get,offsets,int,remaining,offsets,length,offset,idx,long,offs,if,remaining,number,of,partitions,to,assign,offs,arrays,copy,of,range,offsets,offset,idx,offset,idx,number,of,partitions,to,assign,offset,idx,number,of,partitions,to,assign,else,if,handle,with,offsets,f1,null,offs,arrays,copy,of,range,offsets,offset,idx,offsets,length,offset,idx,0,lst,idx,number,of,partitions,to,assign,remaining,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,parallel,op,idx,operator,state,handle,operator,state,handle,merge,map,get,handle,with,offsets,f0,if,operator,state,handle,null,operator,state,handle,new,operator,stream,state,handle,new,hash,map,handle,with,offsets,f0,merge,map,put,handle,with,offsets,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,new,operator,state,handle,state,meta,info,offs,operator,state,handle,mode,start,parallel,op,new,start,parallel,op,e,set,value,null,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,broadcast,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,union,for,int,i,0,i,new,parallelism,i,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,i,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,broadcast,name,to,state,entry,set,for,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,meta,info,e,get,value,operator,state,handle,operator,state,handle,merge,map,get,handle,with,meta,info,f0,if,operator,state,handle,null,operator,state,handle,new,operator,stream,state,handle,new,hash,map,handle,with,meta,info,f0,merge,map,put,handle,with,meta,info,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,handle,with,meta,info,f1,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,uniform,broadcast,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,broadcast,for,int,i,0,i,new,parallelism,i,final,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,i,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,uniform,broadcast,name,to,state,entry,set,int,old,parallelism,e,get,value,size,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,meta,info,e,get,value,get,i,old,parallelism,operator,state,handle,operator,state,handle,merge,map,get,handle,with,meta,info,f0,if,operator,state,handle,null,operator,state,handle,new,operator,stream,state,handle,new,hash,map,handle,with,meta,info,f0,merge,map,put,handle,with,meta,info,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,handle,with,meta,info,f1,return,merge,map,list
RoundRobinOperatorStateRepartitioner -> private List<Map<StreamStateHandle, OperatorStateHandle>> repartition( 			GroupByStateNameResults nameToStateByMode, 			int newParallelism);1534408794;Repartition all named states.;private List<Map<StreamStateHandle, OperatorStateHandle>> repartition(_			GroupByStateNameResults nameToStateByMode,_			int newParallelism) {__		_		List<Map<StreamStateHandle, OperatorStateHandle>> mergeMapList = new ArrayList<>(newParallelism)___		_		for (int i = 0_ i < newParallelism_ ++i) {_			mergeMapList.add(new HashMap<>())__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> distributeNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)___		int startParallelOp = 0__		_		for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_				distributeNameToState.entrySet()) {__			List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> current = e.getValue()___			_			int totalPartitions = 0__			for (Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> offsets : current) {_				totalPartitions += offsets.f1.getOffsets().length__			}__			_			int lstIdx = 0__			int offsetIdx = 0__			int baseFraction = totalPartitions / newParallelism__			int remainder = totalPartitions % newParallelism___			int newStartParallelOp = startParallelOp___			for (int i = 0_ i < newParallelism_ ++i) {__				_				int parallelOpIdx = (i + startParallelOp) % newParallelism___				_				int numberOfPartitionsToAssign = baseFraction___				_				if (remainder > 0) {_					++numberOfPartitionsToAssign__					--remainder__				} else if (remainder == 0) {_					_					_					newStartParallelOp = parallelOpIdx__					--remainder__				}__				__				while (numberOfPartitionsToAssign > 0) {_					Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithOffsets =_							current.get(lstIdx)___					long[] offsets = handleWithOffsets.f1.getOffsets()__					int remaining = offsets.length - offsetIdx__					_					long[] offs__					if (remaining > numberOfPartitionsToAssign) {_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsetIdx + numberOfPartitionsToAssign)__						offsetIdx += numberOfPartitionsToAssign__					} else {_						if (OPTIMIZE_MEMORY_USE) {_							handleWithOffsets.f1 = null_ _						}_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsets.length)__						offsetIdx = 0__						++lstIdx__					}__					numberOfPartitionsToAssign -= remaining___					_					_					Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(parallelOpIdx)__					OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithOffsets.f0)__					if (operatorStateHandle == null) {_						operatorStateHandle = new OperatorStreamStateHandle(_							new HashMap<>(distributeNameToState.size()),_							handleWithOffsets.f0)__						mergeMap.put(handleWithOffsets.f0, operatorStateHandle)__					}_					operatorStateHandle.getStateNameToPartitionOffsets().put(_							e.getKey(),_							new OperatorStateHandle.StateMetaInfo(offs, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				}_			}_			startParallelOp = newStartParallelOp__			e.setValue(null)__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> broadcastNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.UNION)___		for (int i = 0_ i < newParallelism_ ++i) {__			Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(i)___			for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_					broadcastNameToState.entrySet()) {__				for (Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithMetaInfo : e.getValue()) {_					OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithMetaInfo.f0)__					if (operatorStateHandle == null) {_						operatorStateHandle = new OperatorStreamStateHandle(_							new HashMap<>(broadcastNameToState.size()),_							handleWithMetaInfo.f0)__						mergeMap.put(handleWithMetaInfo.f0, operatorStateHandle)__					}_					operatorStateHandle.getStateNameToPartitionOffsets().put(e.getKey(), handleWithMetaInfo.f1)__				}_			}_		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> uniformBroadcastNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.BROADCAST)___		for (int i = 0_ i < newParallelism_ ++i) {__			final Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(i)___			_			for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_					uniformBroadcastNameToState.entrySet()) {__				int oldParallelism = e.getValue().size()___				Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithMetaInfo =_							e.getValue().get(i % oldParallelism)___				OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithMetaInfo.f0)__				if (operatorStateHandle == null) {_					operatorStateHandle = new OperatorStreamStateHandle(_						new HashMap<>(uniformBroadcastNameToState.size()),_						handleWithMetaInfo.f0)__					mergeMap.put(handleWithMetaInfo.f0, operatorStateHandle)__				}_				operatorStateHandle.getStateNameToPartitionOffsets().put(e.getKey(), handleWithMetaInfo.f1)__			}_		}_		return mergeMapList__	};repartition,all,named,states;private,list,map,stream,state,handle,operator,state,handle,repartition,group,by,state,name,results,name,to,state,by,mode,int,new,parallelism,list,map,stream,state,handle,operator,state,handle,merge,map,list,new,array,list,new,parallelism,for,int,i,0,i,new,parallelism,i,merge,map,list,add,new,hash,map,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,distribute,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,int,start,parallel,op,0,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,distribute,name,to,state,entry,set,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,current,e,get,value,int,total,partitions,0,for,tuple2,stream,state,handle,operator,state,handle,state,meta,info,offsets,current,total,partitions,offsets,f1,get,offsets,length,int,lst,idx,0,int,offset,idx,0,int,base,fraction,total,partitions,new,parallelism,int,remainder,total,partitions,new,parallelism,int,new,start,parallel,op,start,parallel,op,for,int,i,0,i,new,parallelism,i,int,parallel,op,idx,i,start,parallel,op,new,parallelism,int,number,of,partitions,to,assign,base,fraction,if,remainder,0,number,of,partitions,to,assign,remainder,else,if,remainder,0,new,start,parallel,op,parallel,op,idx,remainder,while,number,of,partitions,to,assign,0,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,offsets,current,get,lst,idx,long,offsets,handle,with,offsets,f1,get,offsets,int,remaining,offsets,length,offset,idx,long,offs,if,remaining,number,of,partitions,to,assign,offs,arrays,copy,of,range,offsets,offset,idx,offset,idx,number,of,partitions,to,assign,offset,idx,number,of,partitions,to,assign,else,if,handle,with,offsets,f1,null,offs,arrays,copy,of,range,offsets,offset,idx,offsets,length,offset,idx,0,lst,idx,number,of,partitions,to,assign,remaining,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,parallel,op,idx,operator,state,handle,operator,state,handle,merge,map,get,handle,with,offsets,f0,if,operator,state,handle,null,operator,state,handle,new,operator,stream,state,handle,new,hash,map,distribute,name,to,state,size,handle,with,offsets,f0,merge,map,put,handle,with,offsets,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,new,operator,state,handle,state,meta,info,offs,operator,state,handle,mode,start,parallel,op,new,start,parallel,op,e,set,value,null,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,broadcast,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,union,for,int,i,0,i,new,parallelism,i,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,i,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,broadcast,name,to,state,entry,set,for,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,meta,info,e,get,value,operator,state,handle,operator,state,handle,merge,map,get,handle,with,meta,info,f0,if,operator,state,handle,null,operator,state,handle,new,operator,stream,state,handle,new,hash,map,broadcast,name,to,state,size,handle,with,meta,info,f0,merge,map,put,handle,with,meta,info,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,handle,with,meta,info,f1,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,uniform,broadcast,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,broadcast,for,int,i,0,i,new,parallelism,i,final,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,i,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,uniform,broadcast,name,to,state,entry,set,int,old,parallelism,e,get,value,size,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,meta,info,e,get,value,get,i,old,parallelism,operator,state,handle,operator,state,handle,merge,map,get,handle,with,meta,info,f0,if,operator,state,handle,null,operator,state,handle,new,operator,stream,state,handle,new,hash,map,uniform,broadcast,name,to,state,size,handle,with,meta,info,f0,merge,map,put,handle,with,meta,info,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,handle,with,meta,info,f1,return,merge,map,list
RoundRobinOperatorStateRepartitioner -> private List<Map<StreamStateHandle, OperatorStateHandle>> repartition( 			GroupByStateNameResults nameToStateByMode, 			int newParallelism);1550863152;Repartition all named states.;private List<Map<StreamStateHandle, OperatorStateHandle>> repartition(_			GroupByStateNameResults nameToStateByMode,_			int newParallelism) {__		_		List<Map<StreamStateHandle, OperatorStateHandle>> mergeMapList = new ArrayList<>(newParallelism)___		_		for (int i = 0_ i < newParallelism_ ++i) {_			mergeMapList.add(new HashMap<>())__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> nameToDistributeState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)___		repartitionSplitState(nameToDistributeState, newParallelism, mergeMapList)___		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> nameToUnionState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.UNION)___		repartitionUnionState(nameToUnionState, mergeMapList)___		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> nameToBroadcastState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.BROADCAST)___		repartitionBroadcastState(nameToBroadcastState, mergeMapList)___		return mergeMapList__	};repartition,all,named,states;private,list,map,stream,state,handle,operator,state,handle,repartition,group,by,state,name,results,name,to,state,by,mode,int,new,parallelism,list,map,stream,state,handle,operator,state,handle,merge,map,list,new,array,list,new,parallelism,for,int,i,0,i,new,parallelism,i,merge,map,list,add,new,hash,map,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,distribute,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,repartition,split,state,name,to,distribute,state,new,parallelism,merge,map,list,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,union,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,union,repartition,union,state,name,to,union,state,merge,map,list,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,broadcast,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,broadcast,repartition,broadcast,state,name,to,broadcast,state,merge,map,list,return,merge,map,list
RoundRobinOperatorStateRepartitioner -> private List<Map<StreamStateHandle, OperatorStateHandle>> repartition( 			GroupByStateNameResults nameToStateByMode, 			int parallelism);1484339359;Repartition all named states.;private List<Map<StreamStateHandle, OperatorStateHandle>> repartition(_			GroupByStateNameResults nameToStateByMode,_			int parallelism) {__		_		List<Map<StreamStateHandle, OperatorStateHandle>> mergeMapList = new ArrayList<>(parallelism)___		_		for (int i = 0_ i < parallelism_ ++i) {_			mergeMapList.add(new HashMap<StreamStateHandle, OperatorStateHandle>())__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> distributeNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)___		int startParallelOp = 0__		_		for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_				distributeNameToState.entrySet()) {__			List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> current = e.getValue()___			_			int totalPartitions = 0__			for (Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> offsets : current) {_				totalPartitions += offsets.f1.getOffsets().length__			}__			_			int lstIdx = 0__			int offsetIdx = 0__			int baseFraction = totalPartitions / parallelism__			int remainder = totalPartitions % parallelism___			int newStartParallelOp = startParallelOp___			for (int i = 0_ i < parallelism_ ++i) {__				_				int parallelOpIdx = (i + startParallelOp) % parallelism___				_				int numberOfPartitionsToAssign = baseFraction___				_				if (remainder > 0) {_					++numberOfPartitionsToAssign__					--remainder__				} else if (remainder == 0) {_					_					_					newStartParallelOp = parallelOpIdx__					--remainder__				}__				_				List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> parallelOperatorState =_						new ArrayList<>()___				while (numberOfPartitionsToAssign > 0) {_					Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithOffsets =_							current.get(lstIdx)___					long[] offsets = handleWithOffsets.f1.getOffsets()__					int remaining = offsets.length - offsetIdx__					_					long[] offs__					if (remaining > numberOfPartitionsToAssign) {_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsetIdx + numberOfPartitionsToAssign)__						offsetIdx += numberOfPartitionsToAssign__					} else {_						if (OPTIMIZE_MEMORY_USE) {_							handleWithOffsets.f1 = null_ _						}_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsets.length)__						offsetIdx = 0__						++lstIdx__					}__					parallelOperatorState.add(new Tuple2<>(_							handleWithOffsets.f0,_							new OperatorStateHandle.StateMetaInfo(offs, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)))___					numberOfPartitionsToAssign -= remaining___					_					_					Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(parallelOpIdx)__					OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithOffsets.f0)__					if (operatorStateHandle == null) {_						operatorStateHandle = new OperatorStateHandle(_								new HashMap<String, OperatorStateHandle.StateMetaInfo>(),_								handleWithOffsets.f0)___						mergeMap.put(handleWithOffsets.f0, operatorStateHandle)__					}_					operatorStateHandle.getStateNameToPartitionOffsets().put(_							e.getKey(),_							new OperatorStateHandle.StateMetaInfo(offs, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				}_			}_			startParallelOp = newStartParallelOp__			e.setValue(null)__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> broadcastNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.BROADCAST)___		for (int i = 0_ i < parallelism_ ++i) {__			Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(i)___			for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_					broadcastNameToState.entrySet()) {__				List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> current = e.getValue()___				for (Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithMetaInfo : current) {_					OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithMetaInfo.f0)__					if (operatorStateHandle == null) {_						operatorStateHandle = new OperatorStateHandle(_								new HashMap<String, OperatorStateHandle.StateMetaInfo>(),_								handleWithMetaInfo.f0)___						mergeMap.put(handleWithMetaInfo.f0, operatorStateHandle)__					}_					operatorStateHandle.getStateNameToPartitionOffsets().put(e.getKey(), handleWithMetaInfo.f1)__				}_			}_		}_		return mergeMapList__	};repartition,all,named,states;private,list,map,stream,state,handle,operator,state,handle,repartition,group,by,state,name,results,name,to,state,by,mode,int,parallelism,list,map,stream,state,handle,operator,state,handle,merge,map,list,new,array,list,parallelism,for,int,i,0,i,parallelism,i,merge,map,list,add,new,hash,map,stream,state,handle,operator,state,handle,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,distribute,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,int,start,parallel,op,0,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,distribute,name,to,state,entry,set,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,current,e,get,value,int,total,partitions,0,for,tuple2,stream,state,handle,operator,state,handle,state,meta,info,offsets,current,total,partitions,offsets,f1,get,offsets,length,int,lst,idx,0,int,offset,idx,0,int,base,fraction,total,partitions,parallelism,int,remainder,total,partitions,parallelism,int,new,start,parallel,op,start,parallel,op,for,int,i,0,i,parallelism,i,int,parallel,op,idx,i,start,parallel,op,parallelism,int,number,of,partitions,to,assign,base,fraction,if,remainder,0,number,of,partitions,to,assign,remainder,else,if,remainder,0,new,start,parallel,op,parallel,op,idx,remainder,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,parallel,operator,state,new,array,list,while,number,of,partitions,to,assign,0,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,offsets,current,get,lst,idx,long,offsets,handle,with,offsets,f1,get,offsets,int,remaining,offsets,length,offset,idx,long,offs,if,remaining,number,of,partitions,to,assign,offs,arrays,copy,of,range,offsets,offset,idx,offset,idx,number,of,partitions,to,assign,offset,idx,number,of,partitions,to,assign,else,if,handle,with,offsets,f1,null,offs,arrays,copy,of,range,offsets,offset,idx,offsets,length,offset,idx,0,lst,idx,parallel,operator,state,add,new,tuple2,handle,with,offsets,f0,new,operator,state,handle,state,meta,info,offs,operator,state,handle,mode,number,of,partitions,to,assign,remaining,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,parallel,op,idx,operator,state,handle,operator,state,handle,merge,map,get,handle,with,offsets,f0,if,operator,state,handle,null,operator,state,handle,new,operator,state,handle,new,hash,map,string,operator,state,handle,state,meta,info,handle,with,offsets,f0,merge,map,put,handle,with,offsets,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,new,operator,state,handle,state,meta,info,offs,operator,state,handle,mode,start,parallel,op,new,start,parallel,op,e,set,value,null,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,broadcast,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,broadcast,for,int,i,0,i,parallelism,i,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,i,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,broadcast,name,to,state,entry,set,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,current,e,get,value,for,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,meta,info,current,operator,state,handle,operator,state,handle,merge,map,get,handle,with,meta,info,f0,if,operator,state,handle,null,operator,state,handle,new,operator,state,handle,new,hash,map,string,operator,state,handle,state,meta,info,handle,with,meta,info,f0,merge,map,put,handle,with,meta,info,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,handle,with,meta,info,f1,return,merge,map,list
RoundRobinOperatorStateRepartitioner -> private List<Map<StreamStateHandle, OperatorStateHandle>> repartition( 			GroupByStateNameResults nameToStateByMode, 			int parallelism);1502801814;Repartition all named states.;private List<Map<StreamStateHandle, OperatorStateHandle>> repartition(_			GroupByStateNameResults nameToStateByMode,_			int parallelism) {__		_		List<Map<StreamStateHandle, OperatorStateHandle>> mergeMapList = new ArrayList<>(parallelism)___		_		for (int i = 0_ i < parallelism_ ++i) {_			mergeMapList.add(new HashMap<StreamStateHandle, OperatorStateHandle>())__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> distributeNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)___		int startParallelOp = 0__		_		for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_				distributeNameToState.entrySet()) {__			List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> current = e.getValue()___			_			int totalPartitions = 0__			for (Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> offsets : current) {_				totalPartitions += offsets.f1.getOffsets().length__			}__			_			int lstIdx = 0__			int offsetIdx = 0__			int baseFraction = totalPartitions / parallelism__			int remainder = totalPartitions % parallelism___			int newStartParallelOp = startParallelOp___			for (int i = 0_ i < parallelism_ ++i) {__				_				int parallelOpIdx = (i + startParallelOp) % parallelism___				_				int numberOfPartitionsToAssign = baseFraction___				_				if (remainder > 0) {_					++numberOfPartitionsToAssign__					--remainder__				} else if (remainder == 0) {_					_					_					newStartParallelOp = parallelOpIdx__					--remainder__				}__				_				List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> parallelOperatorState =_						new ArrayList<>()___				while (numberOfPartitionsToAssign > 0) {_					Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithOffsets =_							current.get(lstIdx)___					long[] offsets = handleWithOffsets.f1.getOffsets()__					int remaining = offsets.length - offsetIdx__					_					long[] offs__					if (remaining > numberOfPartitionsToAssign) {_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsetIdx + numberOfPartitionsToAssign)__						offsetIdx += numberOfPartitionsToAssign__					} else {_						if (OPTIMIZE_MEMORY_USE) {_							handleWithOffsets.f1 = null_ _						}_						offs = Arrays.copyOfRange(offsets, offsetIdx, offsets.length)__						offsetIdx = 0__						++lstIdx__					}__					parallelOperatorState.add(new Tuple2<>(_							handleWithOffsets.f0,_							new OperatorStateHandle.StateMetaInfo(offs, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE)))___					numberOfPartitionsToAssign -= remaining___					_					_					Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(parallelOpIdx)__					OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithOffsets.f0)__					if (operatorStateHandle == null) {_						operatorStateHandle = new OperatorStateHandle(_								new HashMap<String, OperatorStateHandle.StateMetaInfo>(),_								handleWithOffsets.f0)___						mergeMap.put(handleWithOffsets.f0, operatorStateHandle)__					}_					operatorStateHandle.getStateNameToPartitionOffsets().put(_							e.getKey(),_							new OperatorStateHandle.StateMetaInfo(offs, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				}_			}_			startParallelOp = newStartParallelOp__			e.setValue(null)__		}__		_		Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> broadcastNameToState =_				nameToStateByMode.getByMode(OperatorStateHandle.Mode.BROADCAST)___		for (int i = 0_ i < parallelism_ ++i) {__			Map<StreamStateHandle, OperatorStateHandle> mergeMap = mergeMapList.get(i)___			for (Map.Entry<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> e :_					broadcastNameToState.entrySet()) {__				List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> current = e.getValue()___				for (Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo> handleWithMetaInfo : current) {_					OperatorStateHandle operatorStateHandle = mergeMap.get(handleWithMetaInfo.f0)__					if (operatorStateHandle == null) {_						operatorStateHandle = new OperatorStateHandle(_								new HashMap<String, OperatorStateHandle.StateMetaInfo>(),_								handleWithMetaInfo.f0)___						mergeMap.put(handleWithMetaInfo.f0, operatorStateHandle)__					}_					operatorStateHandle.getStateNameToPartitionOffsets().put(e.getKey(), handleWithMetaInfo.f1)__				}_			}_		}_		return mergeMapList__	};repartition,all,named,states;private,list,map,stream,state,handle,operator,state,handle,repartition,group,by,state,name,results,name,to,state,by,mode,int,parallelism,list,map,stream,state,handle,operator,state,handle,merge,map,list,new,array,list,parallelism,for,int,i,0,i,parallelism,i,merge,map,list,add,new,hash,map,stream,state,handle,operator,state,handle,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,distribute,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,int,start,parallel,op,0,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,distribute,name,to,state,entry,set,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,current,e,get,value,int,total,partitions,0,for,tuple2,stream,state,handle,operator,state,handle,state,meta,info,offsets,current,total,partitions,offsets,f1,get,offsets,length,int,lst,idx,0,int,offset,idx,0,int,base,fraction,total,partitions,parallelism,int,remainder,total,partitions,parallelism,int,new,start,parallel,op,start,parallel,op,for,int,i,0,i,parallelism,i,int,parallel,op,idx,i,start,parallel,op,parallelism,int,number,of,partitions,to,assign,base,fraction,if,remainder,0,number,of,partitions,to,assign,remainder,else,if,remainder,0,new,start,parallel,op,parallel,op,idx,remainder,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,parallel,operator,state,new,array,list,while,number,of,partitions,to,assign,0,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,offsets,current,get,lst,idx,long,offsets,handle,with,offsets,f1,get,offsets,int,remaining,offsets,length,offset,idx,long,offs,if,remaining,number,of,partitions,to,assign,offs,arrays,copy,of,range,offsets,offset,idx,offset,idx,number,of,partitions,to,assign,offset,idx,number,of,partitions,to,assign,else,if,handle,with,offsets,f1,null,offs,arrays,copy,of,range,offsets,offset,idx,offsets,length,offset,idx,0,lst,idx,parallel,operator,state,add,new,tuple2,handle,with,offsets,f0,new,operator,state,handle,state,meta,info,offs,operator,state,handle,mode,number,of,partitions,to,assign,remaining,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,parallel,op,idx,operator,state,handle,operator,state,handle,merge,map,get,handle,with,offsets,f0,if,operator,state,handle,null,operator,state,handle,new,operator,state,handle,new,hash,map,string,operator,state,handle,state,meta,info,handle,with,offsets,f0,merge,map,put,handle,with,offsets,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,new,operator,state,handle,state,meta,info,offs,operator,state,handle,mode,start,parallel,op,new,start,parallel,op,e,set,value,null,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,broadcast,name,to,state,name,to,state,by,mode,get,by,mode,operator,state,handle,mode,broadcast,for,int,i,0,i,parallelism,i,map,stream,state,handle,operator,state,handle,merge,map,merge,map,list,get,i,for,map,entry,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,e,broadcast,name,to,state,entry,set,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,current,e,get,value,for,tuple2,stream,state,handle,operator,state,handle,state,meta,info,handle,with,meta,info,current,operator,state,handle,operator,state,handle,merge,map,get,handle,with,meta,info,f0,if,operator,state,handle,null,operator,state,handle,new,operator,state,handle,new,hash,map,string,operator,state,handle,state,meta,info,handle,with,meta,info,f0,merge,map,put,handle,with,meta,info,f0,operator,state,handle,operator,state,handle,get,state,name,to,partition,offsets,put,e,get,key,handle,with,meta,info,f1,return,merge,map,list
RoundRobinOperatorStateRepartitioner -> private Map<String, List<Tuple2<StreamStateHandle, long[]>>> groupByStateName( 			List<OperatorStateHandle> previousParallelSubtaskStates);1475231926;Group by the different named states.;private Map<String, List<Tuple2<StreamStateHandle, long[]>>> groupByStateName(_			List<OperatorStateHandle> previousParallelSubtaskStates) {__		_		Map<String, List<Tuple2<StreamStateHandle, long[]>>> nameToState = new HashMap<>()__		for (OperatorStateHandle psh : previousParallelSubtaskStates) {__			for (Map.Entry<String, long[]> e : psh.getStateNameToPartitionOffsets().entrySet()) {__				List<Tuple2<StreamStateHandle, long[]>> stateLocations = nameToState.get(e.getKey())___				if (stateLocations == null) {_					stateLocations = new ArrayList<>()__					nameToState.put(e.getKey(), stateLocations)__				}__				stateLocations.add(new Tuple2<>(psh.getDelegateStateHandle(), e.getValue()))__			}_		}_		return nameToState__	};group,by,the,different,named,states;private,map,string,list,tuple2,stream,state,handle,long,group,by,state,name,list,operator,state,handle,previous,parallel,subtask,states,map,string,list,tuple2,stream,state,handle,long,name,to,state,new,hash,map,for,operator,state,handle,psh,previous,parallel,subtask,states,for,map,entry,string,long,e,psh,get,state,name,to,partition,offsets,entry,set,list,tuple2,stream,state,handle,long,state,locations,name,to,state,get,e,get,key,if,state,locations,null,state,locations,new,array,list,name,to,state,put,e,get,key,state,locations,state,locations,add,new,tuple2,psh,get,delegate,state,handle,e,get,value,return,name,to,state
RoundRobinOperatorStateRepartitioner -> private Map<String, List<Tuple2<StreamStateHandle, long[]>>> groupByStateName( 			List<OperatorStateHandle> previousParallelSubtaskStates);1476972861;Group by the different named states.;private Map<String, List<Tuple2<StreamStateHandle, long[]>>> groupByStateName(_			List<OperatorStateHandle> previousParallelSubtaskStates) {__		_		Map<String, List<Tuple2<StreamStateHandle, long[]>>> nameToState = new HashMap<>()__		for (OperatorStateHandle psh : previousParallelSubtaskStates) {__			for (Map.Entry<String, long[]> e : psh.getStateNameToPartitionOffsets().entrySet()) {__				List<Tuple2<StreamStateHandle, long[]>> stateLocations = nameToState.get(e.getKey())___				if (stateLocations == null) {_					stateLocations = new ArrayList<>()__					nameToState.put(e.getKey(), stateLocations)__				}__				stateLocations.add(new Tuple2<>(psh.getDelegateStateHandle(), e.getValue()))__			}_		}_		return nameToState__	};group,by,the,different,named,states;private,map,string,list,tuple2,stream,state,handle,long,group,by,state,name,list,operator,state,handle,previous,parallel,subtask,states,map,string,list,tuple2,stream,state,handle,long,name,to,state,new,hash,map,for,operator,state,handle,psh,previous,parallel,subtask,states,for,map,entry,string,long,e,psh,get,state,name,to,partition,offsets,entry,set,list,tuple2,stream,state,handle,long,state,locations,name,to,state,get,e,get,key,if,state,locations,null,state,locations,new,array,list,name,to,state,put,e,get,key,state,locations,state,locations,add,new,tuple2,psh,get,delegate,state,handle,e,get,value,return,name,to,state
RoundRobinOperatorStateRepartitioner -> @SuppressWarnings("unchecked, rawtype") 	private GroupByStateNameResults groupByStateName(List<OperatorStateHandle> previousParallelSubtaskStates);1518008821;Group by the different named states.;@SuppressWarnings("unchecked, rawtype")_	private GroupByStateNameResults groupByStateName(List<OperatorStateHandle> previousParallelSubtaskStates) {__		_		EnumMap<OperatorStateHandle.Mode,_				Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>>> nameToStateByMode =_				new EnumMap<>(OperatorStateHandle.Mode.class)___		for (OperatorStateHandle.Mode mode : OperatorStateHandle.Mode.values()) {_			nameToStateByMode.put(mode, new HashMap<>())__		}__		for (OperatorStateHandle psh : previousParallelSubtaskStates) {__			if (psh == null) {_				continue__			}__			for (Map.Entry<String, OperatorStateHandle.StateMetaInfo> e :_					psh.getStateNameToPartitionOffsets().entrySet()) {_				OperatorStateHandle.StateMetaInfo metaInfo = e.getValue()___				Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> nameToState =_						nameToStateByMode.get(metaInfo.getDistributionMode())___				List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> stateLocations =_						nameToState.get(e.getKey())___				if (stateLocations == null) {_					stateLocations = new ArrayList<>()__					nameToState.put(e.getKey(), stateLocations)__				}__				stateLocations.add(new Tuple2<>(psh.getDelegateStateHandle(), e.getValue()))__			}_		}__		return new GroupByStateNameResults(nameToStateByMode)__	};group,by,the,different,named,states;suppress,warnings,unchecked,rawtype,private,group,by,state,name,results,group,by,state,name,list,operator,state,handle,previous,parallel,subtask,states,enum,map,operator,state,handle,mode,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,state,by,mode,new,enum,map,operator,state,handle,mode,class,for,operator,state,handle,mode,mode,operator,state,handle,mode,values,name,to,state,by,mode,put,mode,new,hash,map,for,operator,state,handle,psh,previous,parallel,subtask,states,if,psh,null,continue,for,map,entry,string,operator,state,handle,state,meta,info,e,psh,get,state,name,to,partition,offsets,entry,set,operator,state,handle,state,meta,info,meta,info,e,get,value,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,state,name,to,state,by,mode,get,meta,info,get,distribution,mode,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,state,locations,name,to,state,get,e,get,key,if,state,locations,null,state,locations,new,array,list,name,to,state,put,e,get,key,state,locations,state,locations,add,new,tuple2,psh,get,delegate,state,handle,e,get,value,return,new,group,by,state,name,results,name,to,state,by,mode
RoundRobinOperatorStateRepartitioner -> @SuppressWarnings("unchecked, rawtype") 	private GroupByStateNameResults groupByStateName(List<OperatorStateHandle> previousParallelSubtaskStates);1519568061;Group by the different named states.;@SuppressWarnings("unchecked, rawtype")_	private GroupByStateNameResults groupByStateName(List<OperatorStateHandle> previousParallelSubtaskStates) {__		_		EnumMap<OperatorStateHandle.Mode,_				Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>>> nameToStateByMode =_				new EnumMap<>(OperatorStateHandle.Mode.class)___		for (OperatorStateHandle.Mode mode : OperatorStateHandle.Mode.values()) {__			nameToStateByMode.put(_					mode,_					new HashMap<>())__		}__		for (OperatorStateHandle psh : previousParallelSubtaskStates) {__			if (psh == null) {_				continue__			}__			for (Map.Entry<String, OperatorStateHandle.StateMetaInfo> e :_					psh.getStateNameToPartitionOffsets().entrySet()) {_				OperatorStateHandle.StateMetaInfo metaInfo = e.getValue()___				Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> nameToState =_						nameToStateByMode.get(metaInfo.getDistributionMode())___				List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> stateLocations =_						nameToState.get(e.getKey())___				if (stateLocations == null) {_					stateLocations = new ArrayList<>()__					nameToState.put(e.getKey(), stateLocations)__				}__				stateLocations.add(new Tuple2<>(psh.getDelegateStateHandle(), e.getValue()))__			}_		}__		return new GroupByStateNameResults(nameToStateByMode)__	};group,by,the,different,named,states;suppress,warnings,unchecked,rawtype,private,group,by,state,name,results,group,by,state,name,list,operator,state,handle,previous,parallel,subtask,states,enum,map,operator,state,handle,mode,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,state,by,mode,new,enum,map,operator,state,handle,mode,class,for,operator,state,handle,mode,mode,operator,state,handle,mode,values,name,to,state,by,mode,put,mode,new,hash,map,for,operator,state,handle,psh,previous,parallel,subtask,states,if,psh,null,continue,for,map,entry,string,operator,state,handle,state,meta,info,e,psh,get,state,name,to,partition,offsets,entry,set,operator,state,handle,state,meta,info,meta,info,e,get,value,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,state,name,to,state,by,mode,get,meta,info,get,distribution,mode,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,state,locations,name,to,state,get,e,get,key,if,state,locations,null,state,locations,new,array,list,name,to,state,put,e,get,key,state,locations,state,locations,add,new,tuple2,psh,get,delegate,state,handle,e,get,value,return,new,group,by,state,name,results,name,to,state,by,mode
RoundRobinOperatorStateRepartitioner -> @SuppressWarnings("unchecked, rawtype") 	private GroupByStateNameResults groupByStateName(List<OperatorStateHandle> previousParallelSubtaskStates);1534408794;Group by the different named states.;@SuppressWarnings("unchecked, rawtype")_	private GroupByStateNameResults groupByStateName(List<OperatorStateHandle> previousParallelSubtaskStates) {__		_		EnumMap<OperatorStateHandle.Mode,_				Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>>> nameToStateByMode =_				new EnumMap<>(OperatorStateHandle.Mode.class)___		for (OperatorStateHandle.Mode mode : OperatorStateHandle.Mode.values()) {__			nameToStateByMode.put(_					mode,_					new HashMap<>())__		}__		for (OperatorStateHandle psh : previousParallelSubtaskStates) {__			if (psh == null) {_				continue__			}__			final Set<Map.Entry<String, OperatorStateHandle.StateMetaInfo>> partitionOffsetEntries =_				psh.getStateNameToPartitionOffsets().entrySet()___			for (Map.Entry<String, OperatorStateHandle.StateMetaInfo> e : partitionOffsetEntries) {_				OperatorStateHandle.StateMetaInfo metaInfo = e.getValue()___				Map<String, List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>>> nameToState =_						nameToStateByMode.get(metaInfo.getDistributionMode())___				List<Tuple2<StreamStateHandle, OperatorStateHandle.StateMetaInfo>> stateLocations =_					nameToState.computeIfAbsent(_						e.getKey(),_						k -> new ArrayList<>(previousParallelSubtaskStates.size() * partitionOffsetEntries.size()))___				stateLocations.add(new Tuple2<>(psh.getDelegateStateHandle(), e.getValue()))__			}_		}__		return new GroupByStateNameResults(nameToStateByMode)__	};group,by,the,different,named,states;suppress,warnings,unchecked,rawtype,private,group,by,state,name,results,group,by,state,name,list,operator,state,handle,previous,parallel,subtask,states,enum,map,operator,state,handle,mode,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,state,by,mode,new,enum,map,operator,state,handle,mode,class,for,operator,state,handle,mode,mode,operator,state,handle,mode,values,name,to,state,by,mode,put,mode,new,hash,map,for,operator,state,handle,psh,previous,parallel,subtask,states,if,psh,null,continue,final,set,map,entry,string,operator,state,handle,state,meta,info,partition,offset,entries,psh,get,state,name,to,partition,offsets,entry,set,for,map,entry,string,operator,state,handle,state,meta,info,e,partition,offset,entries,operator,state,handle,state,meta,info,meta,info,e,get,value,map,string,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,name,to,state,name,to,state,by,mode,get,meta,info,get,distribution,mode,list,tuple2,stream,state,handle,operator,state,handle,state,meta,info,state,locations,name,to,state,compute,if,absent,e,get,key,k,new,array,list,previous,parallel,subtask,states,size,partition,offset,entries,size,state,locations,add,new,tuple2,psh,get,delegate,state,handle,e,get,value,return,new,group,by,state,name,results,name,to,state,by,mode
