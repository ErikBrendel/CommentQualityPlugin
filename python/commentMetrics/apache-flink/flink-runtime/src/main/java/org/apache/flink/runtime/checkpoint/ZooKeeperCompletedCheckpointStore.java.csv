commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean requiresExternalizedCheckpoints() {     return true. }
true;public;0;77;/**  * Gets the latest checkpoint from ZooKeeper and removes all others.  *  * <p><strong>Important</strong>: Even if there are more than one checkpoint in ZooKeeper,  * this will only recover the latest and discard the others. Otherwise, there is no guarantee  * that the history of checkpoints is consistent.  */ ;/**  * Gets the latest checkpoint from ZooKeeper and removes all others.  *  * <p><strong>Important</strong>: Even if there are more than one checkpoint in ZooKeeper,  * this will only recover the latest and discard the others. Otherwise, there is no guarantee  * that the history of checkpoints is consistent.  */ @Override public void recover() throws Exception {     LOG.info("Recovering checkpoints from ZooKeeper.").     // Get all there is first     List<Tuple2<RetrievableStateHandle<CompletedCheckpoint>, String>> initialCheckpoints.     while (true) {         try {             initialCheckpoints = checkpointsInZooKeeper.getAllAndLock().             break.         } catch (ConcurrentModificationException e) {             LOG.warn("Concurrent modification while reading from ZooKeeper. Retrying.").         }     }     Collections.sort(initialCheckpoints, STRING_COMPARATOR).     int numberOfInitialCheckpoints = initialCheckpoints.size().     LOG.info("Found {} checkpoints in ZooKeeper.", numberOfInitialCheckpoints).     // Try and read the state handles from storage. We try until we either successfully read     // all of them or when we reach a stable state, i.e. when we successfully read the same set     // of checkpoints in two tries. We do it like this to protect against transient outages     // of the checkpoint store (for example a DFS): if the DFS comes online midway through     // reading a set of checkpoints we would run the risk of reading only a partial set     // of checkpoints while we could in fact read the other checkpoints as well if we retried.     // Waiting until a stable state protects against this while also being resilient against     // checkpoints being actually unreadable.     //      // These considerations are also important in the scope of incremental checkpoints, where     // we use ref-counting for shared state handles and might accidentally delete shared state     // of checkpoints that we don't read due to transient storage outages.     List<CompletedCheckpoint> lastTryRetrievedCheckpoints = new ArrayList<>(numberOfInitialCheckpoints).     List<CompletedCheckpoint> retrievedCheckpoints = new ArrayList<>(numberOfInitialCheckpoints).     do {         LOG.info("Trying to fetch {} checkpoints from storage.", numberOfInitialCheckpoints).         lastTryRetrievedCheckpoints.clear().         lastTryRetrievedCheckpoints.addAll(retrievedCheckpoints).         retrievedCheckpoints.clear().         for (Tuple2<RetrievableStateHandle<CompletedCheckpoint>, String> checkpointStateHandle : initialCheckpoints) {             CompletedCheckpoint completedCheckpoint = null.             try {                 completedCheckpoint = retrieveCompletedCheckpoint(checkpointStateHandle).                 if (completedCheckpoint != null) {                     retrievedCheckpoints.add(completedCheckpoint).                 }             } catch (Exception e) {                 LOG.warn("Could not retrieve checkpoint, not adding to list of recovered checkpoints.", e).             }         }     } while (retrievedCheckpoints.size() != numberOfInitialCheckpoints && !CompletedCheckpoint.checkpointsMatch(lastTryRetrievedCheckpoints, retrievedCheckpoints)).     // Clear local handles in order to prevent duplicates on     // recovery. The local handles should reflect the state     // of ZooKeeper.     completedCheckpoints.clear().     completedCheckpoints.addAll(retrievedCheckpoints).     if (completedCheckpoints.isEmpty() && numberOfInitialCheckpoints > 0) {         throw new FlinkException("Could not read any of the " + numberOfInitialCheckpoints + " checkpoints from storage.").     } else if (completedCheckpoints.size() != numberOfInitialCheckpoints) {         LOG.warn("Could only fetch {} of {} checkpoints from storage.", completedCheckpoints.size(), numberOfInitialCheckpoints).     } }
true;public;1;19;/**  * Synchronously writes the new checkpoints to ZooKeeper and asynchronously removes older ones.  *  * @param checkpoint Completed checkpoint to add.  */ ;/**  * Synchronously writes the new checkpoints to ZooKeeper and asynchronously removes older ones.  *  * @param checkpoint Completed checkpoint to add.  */ @Override public void addCheckpoint(final CompletedCheckpoint checkpoint) throws Exception {     checkNotNull(checkpoint, "Checkpoint").     final String path = checkpointIdToPath(checkpoint.getCheckpointID()).     // Now add the new one. If it fails, we don't want to loose existing data.     checkpointsInZooKeeper.addAndLock(path, checkpoint).     completedCheckpoints.addLast(checkpoint).     // Everything worked, let's remove a previous checkpoint if necessary.     while (completedCheckpoints.size() > maxNumberOfCheckpointsToRetain) {         final CompletedCheckpoint completedCheckpoint = completedCheckpoints.removeFirst().         tryRemoveCompletedCheckpoint(completedCheckpoint, CompletedCheckpoint::discardOnSubsume).     }     LOG.debug("Added {} to {}.", checkpoint, path). }
false;private;2;16;;private void tryRemoveCompletedCheckpoint(CompletedCheckpoint completedCheckpoint, ThrowingConsumer<CompletedCheckpoint, Exception> discardCallback) {     try {         if (tryRemove(completedCheckpoint.getCheckpointID())) {             executor.execute(() -> {                 try {                     discardCallback.accept(completedCheckpoint).                 } catch (Exception e) {                     LOG.warn("Could not discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), e).                 }             }).         }     } catch (Exception e) {         LOG.warn("Failed to subsume the old checkpoint", e).     } }
false;public;0;9;;@Override public CompletedCheckpoint getLatestCheckpoint() {     if (completedCheckpoints.isEmpty()) {         return null.     } else {         return completedCheckpoints.peekLast().     } }
false;public;0;5;;@Override public List<CompletedCheckpoint> getAllCheckpoints() throws Exception {     List<CompletedCheckpoint> checkpoints = new ArrayList<>(completedCheckpoints).     return checkpoints. }
false;public;0;4;;@Override public int getNumberOfRetainedCheckpoints() {     return completedCheckpoints.size(). }
false;public;0;4;;@Override public int getMaxNumberOfRetainedCheckpoints() {     return maxNumberOfCheckpointsToRetain. }
false;public;1;23;;@Override public void shutdown(JobStatus jobStatus) throws Exception {     if (jobStatus.isGloballyTerminalState()) {         LOG.info("Shutting down").         for (CompletedCheckpoint checkpoint : completedCheckpoints) {             tryRemoveCompletedCheckpoint(checkpoint, completedCheckpoint -> completedCheckpoint.discardOnShutdown(jobStatus)).         }         completedCheckpoints.clear().         checkpointsInZooKeeper.deleteChildren().     } else {         LOG.info("Suspending").         // Clear the local handles, but don't remove any state         completedCheckpoints.clear().         // Release the state handle locks in ZooKeeper such that they can be deleted         checkpointsInZooKeeper.releaseAll().     } }
true;private;1;3;/**  * Tries to remove the checkpoint identified by the given checkpoint id.  *  * @param checkpointId identifying the checkpoint to remove  * @return true if the checkpoint could be removed  */ ;// ------------------------------------------------------------------------ /**  * Tries to remove the checkpoint identified by the given checkpoint id.  *  * @param checkpointId identifying the checkpoint to remove  * @return true if the checkpoint could be removed  */ private boolean tryRemove(long checkpointId) throws Exception {     return checkpointsInZooKeeper.releaseAndTryRemove(checkpointIdToPath(checkpointId)). }
true;public,static;1;3;/**  * Convert a checkpoint id into a ZooKeeper path.  *  * @param checkpointId to convert to the path  * @return Path created from the given checkpoint id  */ ;/**  * Convert a checkpoint id into a ZooKeeper path.  *  * @param checkpointId to convert to the path  * @return Path created from the given checkpoint id  */ public static String checkpointIdToPath(long checkpointId) {     return String.format("/%019d", checkpointId). }
true;public,static;1;18;/**  * Converts a path to the checkpoint id.  *  * @param path in ZooKeeper  * @return Checkpoint id parsed from the path  */ ;/**  * Converts a path to the checkpoint id.  *  * @param path in ZooKeeper  * @return Checkpoint id parsed from the path  */ public static long pathToCheckpointId(String path) {     try {         String numberString.         // check if we have a leading slash         if ('/' == path.charAt(0)) {             numberString = path.substring(1).         } else {             numberString = path.         }         return Long.parseLong(numberString).     } catch (NumberFormatException e) {         LOG.warn("Could not parse checkpoint id from {}. This indicates that the " + "checkpoint id to path conversion has changed.", path).         return -1L.     } }
false;private,static;1;17;;private static CompletedCheckpoint retrieveCompletedCheckpoint(Tuple2<RetrievableStateHandle<CompletedCheckpoint>, String> stateHandlePath) throws FlinkException {     long checkpointId = pathToCheckpointId(stateHandlePath.f1).     LOG.info("Trying to retrieve checkpoint {}.", checkpointId).     try {         return stateHandlePath.f0.retrieveState().     } catch (ClassNotFoundException cnfe) {         throw new FlinkException("Could not retrieve checkpoint " + checkpointId + " from state handle under " + stateHandlePath.f1 + ". This indicates that you are trying to recover from state written by an " + "older Flink version which is not compatible. Try cleaning the state handle store.", cnfe).     } catch (IOException ioe) {         throw new FlinkException("Could not retrieve checkpoint " + checkpointId + " from state handle under " + stateHandlePath.f1 + ". This indicates that the retrieved state handle is broken. Try cleaning the " + "state handle store.", ioe).     } }
