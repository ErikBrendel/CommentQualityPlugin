commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;public void handleException(IOException exception) {     // forward exception     if (!closed) {         setResultIteratorException(exception).         close().     } }
true;protected;0;11;/**  * Starts all the threads that are used by this sort-merger.  */ ;/**  * Starts all the threads that are used by this sort-merger.  */ protected void startThreads() {     if (this.readThread != null) {         this.readThread.start().     }     if (this.sortThread != null) {         this.sortThread.start().     }     if (this.spillThread != null) {         this.spillThread.start().     } }
true;public;0;125;/**  * Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated  * memory, if it has not yet been released by the threads, and closes and deletes all channels (removing  * the temporary files).  * <p>  * The threads are set to exit directly, but depending on their operation, it may take a while to actually happen.  * The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait  * for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed  * how long the threads continue to exist and occupy resources afterwards.  *  * @see java.io.Closeable#close()  */ ;/**  * Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated  * memory, if it has not yet been released by the threads, and closes and deletes all channels (removing  * the temporary files).  * <p>  * The threads are set to exit directly, but depending on their operation, it may take a while to actually happen.  * The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait  * for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed  * how long the threads continue to exist and occupy resources afterwards.  *  * @see java.io.Closeable#close()  */ @Override public void close() {     // check if the sorter has been closed before     synchronized (this) {         if (this.closed) {             return.         }         // mark as closed         this.closed = true.     }     // we need to make sure that all the memory is released.     try {         // if the result iterator has not been obtained yet, set the exception         synchronized (this.iteratorLock) {             if (this.iteratorException == null) {                 this.iteratorException = new IOException("The sorter has been closed.").                 this.iteratorLock.notifyAll().             }         }         // stop all the threads         if (this.readThread != null) {             try {                 this.readThread.shutdown().             } catch (Throwable t) {                 LOG.error("Error shutting down reader thread: " + t.getMessage(), t).             }         }         if (this.sortThread != null) {             try {                 this.sortThread.shutdown().             } catch (Throwable t) {                 LOG.error("Error shutting down sorter thread: " + t.getMessage(), t).             }         }         if (this.spillThread != null) {             try {                 this.spillThread.shutdown().             } catch (Throwable t) {                 LOG.error("Error shutting down spilling thread: " + t.getMessage(), t).             }         }         try {             if (this.readThread != null) {                 this.readThread.join().             }             if (this.sortThread != null) {                 this.sortThread.join().             }             if (this.spillThread != null) {                 this.spillThread.join().             }         } catch (InterruptedException iex) {             LOG.debug("Closing of sort/merger was interrupted. " + "The reading/sorting/spilling threads may still be working.", iex).         }     } finally {         // Dispose all in memory sorter in order to clear memory references         for (InMemorySorter<?> inMemorySorter : inMemorySorters) {             inMemorySorter.dispose().         }         // exceptions, because their memory segments are freed         try {             if (!this.writeMemory.isEmpty()) {                 this.memoryManager.release(this.writeMemory).             }             this.writeMemory.clear().         } catch (Throwable t) {         }         try {             if (!this.sortReadMemory.isEmpty()) {                 this.memoryManager.release(this.sortReadMemory).             }             this.sortReadMemory.clear().         } catch (Throwable t) {         }         // we have to loop this, because it may fail with a concurrent modification exception         while (!this.openChannels.isEmpty()) {             try {                 for (Iterator<FileIOChannel> channels = this.openChannels.iterator(). channels.hasNext(). ) {                     final FileIOChannel channel = channels.next().                     channels.remove().                     channel.closeAndDelete().                 }             } catch (Throwable t) {             }         }         // we have to loop this, because it may fail with a concurrent modification exception         while (!this.channelsToDeleteAtShutdown.isEmpty()) {             try {                 for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator(). channels.hasNext(). ) {                     final FileIOChannel.ID channel = channels.next().                     channels.remove().                     try {                         final File f = new File(channel.getPath()).                         if (f.exists()) {                             f.delete().                         }                     } catch (Throwable t) {                     }                 }             } catch (Throwable t) {             }         }         try {             if (this.largeRecordHandler != null) {                 this.largeRecordHandler.close().             }         } catch (Throwable t) {         }     } }
true;protected;7;8;/**  * Creates the reading thread. The reading thread simply reads the data off the input and puts it  * into the buffer where it will be sorted.  * <p>  * The returned thread is not yet started.  *  * @param exceptionHandler  *        The handler for exceptions in the thread.  * @param reader  *        The reader from which the thread reads.  * @param queues  *        The queues through which the thread communicates with the other threads.  * @param parentTask  *        The task at which the thread registers itself (for profiling purposes).  * @param serializer  *        The serializer used to serialize records.  * @param startSpillingBytes  *        The number of bytes after which the reader thread will send the notification to  *        start the spilling.  *  * @return The thread that reads data from an input, writes it into sort buffers and puts  *         them into a queue.  */ ;// ------------------------------------------------------------------------ // Factory Methods // ------------------------------------------------------------------------ /**  * Creates the reading thread. The reading thread simply reads the data off the input and puts it  * into the buffer where it will be sorted.  * <p>  * The returned thread is not yet started.  *  * @param exceptionHandler  *        The handler for exceptions in the thread.  * @param reader  *        The reader from which the thread reads.  * @param queues  *        The queues through which the thread communicates with the other threads.  * @param parentTask  *        The task at which the thread registers itself (for profiling purposes).  * @param serializer  *        The serializer used to serialize records.  * @param startSpillingBytes  *        The number of bytes after which the reader thread will send the notification to  *        start the spilling.  *  * @return The thread that reads data from an input, writes it into sort buffers and puts  *         them into a queue.  */ protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, MutableObjectIterator<E> reader, CircularQueues<E> queues, LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, TypeSerializer<E> serializer, long startSpillingBytes) {     return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, serializer.createInstance(), parentTask, startSpillingBytes). }
false;protected;3;5;;protected ThreadBase<E> getSortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, AbstractInvokable parentTask) {     return new SortingThread<E>(exceptionHandler, queues, parentTask). }
false;protected;10;8;;protected ThreadBase<E> getSpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, AbstractInvokable parentTask, MemoryManager memoryManager, IOManager ioManager, TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxFileHandles) {     return new SpillingThread(exceptionHandler, queues, parentTask, memoryManager, ioManager, serializerFactory.getSerializer(), comparator, sortReadMemory, writeMemory, maxFileHandles). }
false;public;0;17;;// ------------------------------------------------------------------------ // Result Iterator // ------------------------------------------------------------------------ @Override public MutableObjectIterator<E> getIterator() throws InterruptedException {     synchronized (this.iteratorLock) {         // wait while both the iterator and the exception are not set         while (this.iterator == null && this.iteratorException == null) {             this.iteratorLock.wait().         }         if (this.iteratorException != null) {             throw new RuntimeException("Error obtaining the sorted input: " + this.iteratorException.getMessage(), this.iteratorException).         } else {             return this.iterator.         }     } }
true;protected,final;1;9;/**  * Sets the result iterator. By setting the result iterator, all threads that are waiting for the result  * iterator are notified and will obtain it.  *  * @param iterator The result iterator to set.  */ ;/**  * Sets the result iterator. By setting the result iterator, all threads that are waiting for the result  * iterator are notified and will obtain it.  *  * @param iterator The result iterator to set.  */ protected final void setResultIterator(MutableObjectIterator<E> iterator) {     synchronized (this.iteratorLock) {         // set the result iterator only, if no exception has occurred         if (this.iteratorException == null) {             this.iterator = iterator.             this.iteratorLock.notifyAll().         }     } }
true;protected,final;1;8;/**  * Reports an exception to all threads that are waiting for the result iterator.  *  * @param ioex The exception to be reported to the threads that wait for the result iterator.  */ ;/**  * Reports an exception to all threads that are waiting for the result iterator.  *  * @param ioex The exception to be reported to the threads that wait for the result iterator.  */ protected final void setResultIteratorException(IOException ioex) {     synchronized (this.iteratorLock) {         if (this.iteratorException == null) {             this.iteratorException = ioex.             this.iteratorLock.notifyAll().         }     } }
true;protected,static;0;5;/**  * Gets the element that is passed as marker for the end of data.  *  * @return The element that is passed as marker for the end of data.  */ ;/**  * Gets the element that is passed as marker for the end of data.  *  * @return The element that is passed as marker for the end of data.  */ protected static <T> CircularElement<T> endMarker() {     @SuppressWarnings("unchecked")     CircularElement<T> c = (CircularElement<T>) EOF_MARKER.     return c. }
true;protected,static;0;5;/**  * Gets the element that is passed as marker for signal beginning of spilling.  *  * @return The element that is passed as marker for signal beginning of spilling.  */ ;/**  * Gets the element that is passed as marker for signal beginning of spilling.  *  * @return The element that is passed as marker for signal beginning of spilling.  */ protected static <T> CircularElement<T> spillingMarker() {     @SuppressWarnings("unchecked")     CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER.     return c. }
true;public;0;9;/**  * Implements exception handling and delegates to go().  */ ;/**  * Implements exception handling and delegates to go().  */ public void run() {     try {         go().     } catch (Throwable t) {         internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: " + t.getMessage(), t)).     } }
true;protected,abstract;0;1;/**  * Equivalent to the run() method.  *  * @throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.  */ ;/**  * Equivalent to the run() method.  *  * @throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.  */ protected abstract void go() throws IOException.
true;public;0;3;/**  * Checks whether this thread is still alive.  *  * @return true, if the thread is alive, false otherwise.  */ ;/**  * Checks whether this thread is still alive.  *  * @return true, if the thread is alive, false otherwise.  */ public boolean isRunning() {     return this.alive. }
true;public;0;4;/**  * Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently  * working on. This terminates cleanly for the JVM, but looses intermediate results.  */ ;/**  * Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently  * working on. This terminates cleanly for the JVM, but looses intermediate results.  */ public void shutdown() {     this.alive = false.     this.interrupt(). }
true;protected,final;1;12;/**  * Internally handles an exception and makes sure that this method returns without a problem.  *  * @param ioex  *        The exception to handle.  */ ;/**  * Internally handles an exception and makes sure that this method returns without a problem.  *  * @param ioex  *        The exception to handle.  */ protected final void internalHandleException(IOException ioex) {     if (!isRunning()) {         // discard any exception that occurs when after the thread is killed.         return.     }     if (this.exceptionHandler != null) {         try {             this.exceptionHandler.handleException(ioex).         } catch (Throwable t) {         }     } }
true;public;2;5;/* (non-Javadoc) 		 * @see java.lang.Thread.UncaughtExceptionHandler#uncaughtException(java.lang.Thread, java.lang.Throwable) 		 */ ;/* (non-Javadoc) 		 * @see java.lang.Thread.UncaughtExceptionHandler#uncaughtException(java.lang.Thread, java.lang.Throwable) 		 */ @Override public void uncaughtException(Thread t, Throwable e) {     internalHandleException(new IOException("Thread '" + t.getName() + "' terminated due to an uncaught exception: " + e.getMessage(), e)). }
true;public;0;180;/**  * The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input  * available.  */ ;/**  * The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input  * available.  */ public void go() throws IOException {     final MutableObjectIterator<E> reader = this.reader.     E current = this.readTarget.     E leftoverRecord = null.     CircularElement<E> element = null.     long bytesUntilSpilling = this.startSpillingBytes.     boolean done = false.     // check if we should directly spill     if (bytesUntilSpilling < 1) {         bytesUntilSpilling = 0.         // add the spilling marker         this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker()).     }     // now loop until all channels have no more input data     while (!done && isRunning()) {         // grab the next buffer         while (element == null) {             try {                 element = this.queues.empty.take().             } catch (InterruptedException iex) {                 throw new IOException(iex).             }         }         // get the new buffer and check it         final InMemorySorter<E> buffer = element.buffer.         if (!buffer.isEmpty()) {             throw new IOException("New buffer is not empty.").         }         if (LOG.isDebugEnabled()) {             LOG.debug("Retrieved empty read buffer " + element.id + ".").         }         // write the last leftover pair, if we have one         if (leftoverRecord != null) {             if (!buffer.write(leftoverRecord)) {                 // did not fit in a fresh buffer, must be large...                 if (this.largeRecords != null) {                     if (LOG.isDebugEnabled()) {                         LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.").                     }                     this.largeRecords.addRecord(leftoverRecord).                 } else {                     throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: " + buffer.getCapacity() + " bytes).").                 }                 buffer.reset().             }             leftoverRecord = null.         }         // we have two distinct code paths, depending on whether the spilling         // threshold will be crossed in the current buffer, or not.         boolean available = true.         if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling) {             boolean fullBuffer = false.             // spilling will be triggered while this buffer is filled             // loop until the buffer is full or the reader is exhausted             E newCurrent.             while (isRunning() && (available = (newCurrent = reader.next(current)) != null)) {                 current = newCurrent.                 if (!buffer.write(current)) {                     leftoverRecord = current.                     fullBuffer = true.                     break.                 }                 if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {                     bytesUntilSpilling = 0.                     // send the spilling marker                     final CircularElement<E> SPILLING_MARKER = spillingMarker().                     this.queues.sort.add(SPILLING_MARKER).                     // does not have the check                     break.                 }             }             if (fullBuffer) {                 // spilling threshold, so check it                 if (bytesUntilSpilling > 0) {                     bytesUntilSpilling -= buffer.getCapacity().                     if (bytesUntilSpilling <= 0) {                         bytesUntilSpilling = 0.                         // send the spilling marker                         final CircularElement<E> SPILLING_MARKER = spillingMarker().                         this.queues.sort.add(SPILLING_MARKER).                     }                 }                 // send the buffer                 if (LOG.isDebugEnabled()) {                     LOG.debug("Emitting full buffer from reader thread: " + element.id + ".").                 }                 this.queues.sort.add(element).                 element = null.                 continue.             }         } else if (bytesUntilSpilling > 0) {             // this block must not be entered, if the last loop dropped out because             // the input is exhausted.             bytesUntilSpilling -= buffer.getCapacity().             if (bytesUntilSpilling <= 0) {                 bytesUntilSpilling = 0.                 // send the spilling marker                 final CircularElement<E> SPILLING_MARKER = spillingMarker().                 this.queues.sort.add(SPILLING_MARKER).             }         }         // loop until the buffer is full or the reader is exhausted         if (available) {             E newCurrent.             while (isRunning() && ((newCurrent = reader.next(current)) != null)) {                 current = newCurrent.                 if (!buffer.write(current)) {                     leftoverRecord = current.                     break.                 }             }         }         // check whether the buffer is exhausted or the reader is         if (leftoverRecord != null) {             if (LOG.isDebugEnabled()) {                 LOG.debug("Emitting full buffer from reader thread: " + element.id + ".").             }         } else {             done = true.             if (LOG.isDebugEnabled()) {                 LOG.debug("Emitting final buffer from reader thread: " + element.id + ".").             }         }         // we can use add to add the element because we have no capacity restriction         if (!buffer.isEmpty()) {             this.queues.sort.add(element).         } else {             buffer.reset().             this.queues.empty.add(element).         }         element = null.     }     // we read all there is to read, or we are no longer running     if (!isRunning()) {         return.     }     // add the sentinel to notify the receivers that the work is done     // send the EOF marker     final CircularElement<E> EOF_MARKER = endMarker().     this.queues.sort.add(EOF_MARKER).     LOG.debug("Reading thread done."). }
true;public;0;50;/**  * Entry point of the thread.  */ ;/**  * Entry point of the thread.  */ public void go() throws IOException {     boolean alive = true.     // loop as long as the thread is marked alive     while (isRunning() && alive) {         CircularElement<E> element = null.         try {             element = this.queues.sort.take().         } catch (InterruptedException iex) {             if (isRunning()) {                 if (LOG.isErrorEnabled()) {                     LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " + "Retrying to grab buffer...").                 }                 continue.             } else {                 return.             }         }         if (element != EOF_MARKER && element != SPILLING_MARKER) {             if (element.buffer.size() == 0) {                 element.buffer.reset().                 this.queues.empty.add(element).                 continue.             }             if (LOG.isDebugEnabled()) {                 LOG.debug("Sorting buffer " + element.id + ".").             }             this.sorter.sort(element.buffer).             if (LOG.isDebugEnabled()) {                 LOG.debug("Sorted buffer " + element.id + ".").             }         } else if (element == EOF_MARKER) {             if (LOG.isDebugEnabled()) {                 LOG.debug("Sorting thread done.").             }             alive = false.         }         this.queues.spill.add(element).     } }
true;public;0;238;/**  * Entry point of the thread.  */ ;/**  * Entry point of the thread.  */ public void go() throws IOException {     final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>().     CircularElement<E> element.     boolean cacheOnly = false.     // fill cache     while (isRunning()) {         // take next element from queue         try {             element = this.queues.spill.take().         } catch (InterruptedException iex) {             throw new IOException("The spilling thread was interrupted.").         }         if (element == SPILLING_MARKER) {             break.         } else if (element == EOF_MARKER) {             cacheOnly = true.             break.         }         cache.add(element).     }     // check whether the thread was canceled     if (!isRunning()) {         return.     }     MutableObjectIterator<E> largeRecords = null.     // check if we can stay in memory with the large record handler     if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {         List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>().         CircularElement<E> circElement.         while ((circElement = this.queues.empty.poll()) != null) {             circElement.buffer.dispose().             memoryForLargeRecordSorting.addAll(circElement.memory).         }         if (memoryForLargeRecordSorting.isEmpty()) {             cacheOnly = false.             LOG.debug("Going to disk-based merge because of large records.").         } else {             LOG.debug("Sorting large records, to add them to in-memory merge.").             largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting).         }     }     // ------------------- In-Memory Merge ------------------------     if (cacheOnly) {         // operates on in-memory buffers only         if (LOG.isDebugEnabled()) {             LOG.debug("Initiating in memory merge.").         }         List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1).         // iterate buffers and collect a set of iterators         for (CircularElement<E> cached : cache) {             // note: the yielded iterator only operates on the buffer heap (and disregards the stack)             iterators.add(cached.buffer.getIterator()).         }         if (largeRecords != null) {             iterators.add(largeRecords).         }         // release the remaining sort-buffers         if (LOG.isDebugEnabled()) {             LOG.debug("Releasing unused sort-buffer memory.").         }         disposeSortBuffers(true).         // set lazy iterator         setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() : iterators.size() == 1 ? iterators.get(0) : new MergeIterator<E>(iterators, this.comparator)).         return.     }     // ------------------- Spilling Phase ------------------------     final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator().     List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>().     // loop as long as the thread is marked alive and we do not see the final element     while (isRunning()) {         try {             element = takeNext(this.queues.spill, cache).         } catch (InterruptedException iex) {             if (isRunning()) {                 LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " + "Retrying to grab buffer...").                 continue.             } else {                 return.             }         }         // check if we are still running         if (!isRunning()) {             return.         }         // check if this is the end-of-work buffer         if (element == EOF_MARKER) {             break.         }         // open next channel         FileIOChannel.ID channel = enumerator.next().         registerChannelToBeRemovedAtShudown(channel).         // create writer         final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel).         registerOpenChannelToBeRemovedAtShudown(writer).         final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory, this.memManager.getPageSize()).         // write sort-buffer to channel         if (LOG.isDebugEnabled()) {             LOG.debug("Spilling buffer " + element.id + ".").         }         element.buffer.writeToOutput(output, largeRecordHandler).         if (LOG.isDebugEnabled()) {             LOG.debug("Spilled buffer " + element.id + ".").         }         output.close().         unregisterOpenChannelToBeRemovedAtShudown(writer).         if (output.getBytesWritten() > 0) {             channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount())).         }         // pass empty sort-buffer to reading thread         element.buffer.reset().         this.queues.empty.add(element).     }     // done with the spilling     if (LOG.isDebugEnabled()) {         LOG.debug("Spilling done.").         LOG.debug("Releasing sort-buffer memory.").     }     // clear the sort buffers, but do not return the memory to the manager, as we use it for merging     disposeSortBuffers(false).     // ------------------- Merging Phase ------------------------     // make sure we have enough memory to merge and for large record handling     List<MemorySegment> mergeReadMemory.     if (largeRecordHandler != null && largeRecordHandler.hasData()) {         List<MemorySegment> longRecMem.         if (channelIDs.isEmpty()) {             // only long records             longRecMem = this.mergeReadMemory.             mergeReadMemory = Collections.emptyList().         } else {             int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size()).             int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS, Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams)).             int totalMergeReadMemory = maxMergedStreams * pagesPerStream.             // grab the merge memory             mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory).             for (int i = 0. i < totalMergeReadMemory. i++) {                 mergeReadMemory.add(this.mergeReadMemory.get(i)).             }             // the remainder of the memory goes to the long record sorter             longRecMem = new ArrayList<MemorySegment>().             for (int i = totalMergeReadMemory. i < this.mergeReadMemory.size(). i++) {                 longRecMem.add(this.mergeReadMemory.get(i)).             }         }         if (LOG.isDebugEnabled()) {             LOG.debug("Sorting keys for large records.").         }         largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem).     } else {         mergeReadMemory = this.mergeReadMemory.     }     // merge channels until sufficient file handles are available     while (isRunning() && channelIDs.size() > this.maxFanIn) {         channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory).     }     // from here on, we won't write again     this.memManager.release(this.writeMemory).     this.writeMemory.clear().     // check if we have spilled some data at all     if (channelIDs.isEmpty()) {         if (largeRecords == null) {             setResultIterator(EmptyMutableObjectIterator.<E>get()).         } else {             setResultIterator(largeRecords).         }     } else {         if (LOG.isDebugEnabled()) {             LOG.debug("Beginning final merge.").         }         // allocate the memory for the final merging step         List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size()).         // allocate the read memory and register it to be released         getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size()).         // get the readers and register them to be released         setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords)).     }     // done     if (LOG.isDebugEnabled()) {         LOG.debug("Spilling and merging thread done.").     } }
true;protected,final;1;20;/**  * Releases the memory that is registered for in-memory sorted run generation.  */ ;/**  * Releases the memory that is registered for in-memory sorted run generation.  */ protected final void disposeSortBuffers(boolean releaseMemory) {     while (!this.queues.empty.isEmpty()) {         try {             CircularElement<E> element = this.queues.empty.take().             element.buffer.dispose().             if (releaseMemory) {                 this.memManager.release(element.memory).             }         } catch (InterruptedException iex) {             if (isRunning()) {                 LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " + "Retrying to collect buffers...").             } else {                 return.             }         }     } }
false;protected,final;2;4;;protected final CircularElement<E> takeNext(BlockingQueue<CircularElement<E>> queue, Queue<CircularElement<E>> cache) throws InterruptedException {     return cache.isEmpty() ? queue.take() : cache.poll(). }
true;protected,final;4;34;/**  * Returns an iterator that iterates over the merged result from all given channels.  *  * @param channelIDs The channels that are to be merged and returned.  * @param inputSegments The buffers to be used for reading. The list contains for each channel one  *                      list of input segments. The size of the <code>inputSegments</code> list must be equal to  *                      that of the <code>channelIDs</code> list.  * @return An iterator over the merged records of the input channels.  * @throws IOException Thrown, if the readers encounter an I/O problem.  */ ;// ------------------------------------------------------------------------ // Result Merging // ------------------------------------------------------------------------ /**  * Returns an iterator that iterates over the merged result from all given channels.  *  * @param channelIDs The channels that are to be merged and returned.  * @param inputSegments The buffers to be used for reading. The list contains for each channel one  *                      list of input segments. The size of the <code>inputSegments</code> list must be equal to  *                      that of the <code>channelIDs</code> list.  * @return An iterator over the merged records of the input channels.  * @throws IOException Thrown, if the readers encounter an I/O problem.  */ protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) throws IOException {     // create one iterator per channel id     if (LOG.isDebugEnabled()) {         LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.").     }     final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1).     for (int i = 0. i < channelIDs.size(). i++) {         final ChannelWithBlockCount channel = channelIDs.get(i).         final List<MemorySegment> segsForChannel = inputSegments.get(i).         // create a reader. if there are multiple segments for the reader, issue multiple together per I/O request         final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channel.getChannel()).         readerList.add(reader).         registerOpenChannelToBeRemovedAtShudown(reader).         unregisterChannelToBeRemovedAtShudown(channel.getChannel()).         // wrap channel reader as a view, to get block spanning record deserialization         final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, channel.getBlockCount(), false).         iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer)).     }     if (largeRecords != null) {         iterators.add(largeRecords).     }     return new MergeIterator<E>(iterators, this.comparator). }
true;protected,final;3;41;/**  * Merges the given sorted runs to a smaller number of sorted runs.  *  * @param channelIDs The IDs of the sorted runs that need to be merged.  * @param allReadBuffers  * @param writeBuffers The buffers to be used by the writers.  * @return A list of the IDs of the merged channels.  * @throws IOException Thrown, if the readers or writers encountered an I/O problem.  */ ;/**  * Merges the given sorted runs to a smaller number of sorted runs.  *  * @param channelIDs The IDs of the sorted runs that need to be merged.  * @param allReadBuffers  * @param writeBuffers The buffers to be used by the writers.  * @return A list of the IDs of the merged channels.  * @throws IOException Thrown, if the readers or writers encountered an I/O problem.  */ protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) throws IOException {     // A channel list with length maxFanIn<sup>i</sup> can be merged to maxFanIn files in i-1 rounds where every merge     // is a full merge with maxFanIn input channels. A partial round includes merges with fewer than maxFanIn     // inputs. It is most efficient to perform the partial round first.     final double scale = Math.ceil(Math.log(channelIDs.size()) / Math.log(this.maxFanIn)) - 1.     final int numStart = channelIDs.size().     final int numEnd = (int) Math.pow(this.maxFanIn, scale).     final int numMerges = (int) Math.ceil((numStart - numEnd) / (double) (this.maxFanIn - 1)).     final int numNotMerged = numEnd - numMerges.     final int numToMerge = numStart - numNotMerged.     // unmerged channel IDs are copied directly to the result list     final List<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>(numEnd).     mergedChannelIDs.addAll(channelIDs.subList(0, numNotMerged)).     final int channelsToMergePerStep = (int) Math.ceil(numToMerge / (double) numMerges).     // allocate the memory for the merging step     final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep).     getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep).     final List<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep).     int channelNum = numNotMerged.     while (isRunning() && channelNum < channelIDs.size()) {         channelsToMergeThisStep.clear().         for (int i = 0. i < channelsToMergePerStep && channelNum < channelIDs.size(). i++, channelNum++) {             channelsToMergeThisStep.add(channelIDs.get(channelNum)).         }         mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers)).     }     return mergedChannelIDs. }
true;protected;3;46;/**  * Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process  * uses the given read and write buffers.  *  * @param channelIDs The IDs of the runs' channels.  * @param readBuffers The buffers for the readers that read the sorted runs.  * @param writeBuffers The buffers for the writer that writes the merged channel.  * @return The ID and number of blocks of the channel that describes the merged run.  */ ;/**  * Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process  * uses the given read and write buffers.  *  * @param channelIDs The IDs of the runs' channels.  * @param readBuffers The buffers for the readers that read the sorted runs.  * @param writeBuffers The buffers for the writer that writes the merged channel.  * @return The ID and number of blocks of the channel that describes the merged run.  */ protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, List<MemorySegment> writeBuffers) throws IOException {     // the list with the readers, to be closed at shutdown     final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size()).     // the list with the target iterators     final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null).     // create a new channel writer     final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel().     registerChannelToBeRemovedAtShudown(mergedChannelID).     final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(mergedChannelID).     registerOpenChannelToBeRemovedAtShudown(writer).     final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, this.memManager.getPageSize()).     // read the merged stream and write the data back     if (objectReuseEnabled) {         final TypeSerializer<E> serializer = this.serializer.         E rec = serializer.createInstance().         while ((rec = mergeIterator.next(rec)) != null) {             serializer.serialize(rec, output).         }     } else {         E rec.         while ((rec = mergeIterator.next()) != null) {             serializer.serialize(rec, output).         }     }     output.close().     final int numBlocksWritten = output.getBlockCount().     // register merged result to be removed at shutdown     unregisterOpenChannelToBeRemovedAtShudown(writer).     // remove the merged channel readers from the clear-at-shutdown list     for (int i = 0. i < channelAccesses.size(). i++) {         FileIOChannel access = channelAccesses.get(i).         access.closeAndDelete().         unregisterOpenChannelToBeRemovedAtShudown(access).     }     return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten). }
true;protected,final;3;28;/**  * Divides the given collection of memory buffers among {@code numChannels} sublists.  *  * @param target The list into which the lists with buffers for the channels are put.  * @param memory A list containing the memory buffers to be distributed. The buffers are not  *               removed from this list.  * @param numChannels The number of channels for which to allocate buffers. Must not be zero.  */ ;/**  * Divides the given collection of memory buffers among {@code numChannels} sublists.  *  * @param target The list into which the lists with buffers for the channels are put.  * @param memory A list containing the memory buffers to be distributed. The buffers are not  *               removed from this list.  * @param numChannels The number of channels for which to allocate buffers. Must not be zero.  */ protected final void getSegmentsForReaders(List<List<MemorySegment>> target, List<MemorySegment> memory, int numChannels) {     // determine the memory to use per channel and the number of buffers     final int numBuffers = memory.size().     final int buffersPerChannelLowerBound = numBuffers / numChannels.     final int numChannelsWithOneMore = numBuffers % numChannels.     final Iterator<MemorySegment> segments = memory.iterator().     // collect memory for the channels that get one segment more     for (int i = 0. i < numChannelsWithOneMore. i++) {         final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1).         target.add(segs).         for (int k = buffersPerChannelLowerBound. k >= 0. k--) {             segs.add(segments.next()).         }     }     // collect memory for the remaining channels     for (int i = numChannelsWithOneMore. i < numChannels. i++) {         final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound).         target.add(segs).         for (int k = buffersPerChannelLowerBound. k > 0. k--) {             segs.add(segments.next()).         }     } }
true;protected;1;3;/**  * Adds a channel to the list of channels that are to be removed at shutdown.  *  * @param channel The channel id.  */ ;// ------------------------------------------------------------------------ // Cleanup of Temp Files and Allocated Memory // ------------------------------------------------------------------------ /**  * Adds a channel to the list of channels that are to be removed at shutdown.  *  * @param channel The channel id.  */ protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {     UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel). }
true;protected;1;3;/**  * Removes a channel from the list of channels that are to be removed at shutdown.  *  * @param channel The channel id.  */ ;/**  * Removes a channel from the list of channels that are to be removed at shutdown.  *  * @param channel The channel id.  */ protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {     UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel). }
true;protected;1;3;/**  * Adds a channel reader/writer to the list of channels that are to be removed at shutdown.  *  * @param channel The channel reader/writer.  */ ;/**  * Adds a channel reader/writer to the list of channels that are to be removed at shutdown.  *  * @param channel The channel reader/writer.  */ protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {     UnilateralSortMerger.this.openChannels.add(channel). }
true;protected;1;3;/**  * Removes a channel reader/writer from the list of channels that are to be removed at shutdown.  *  * @param channel The channel reader/writer.  */ ;/**  * Removes a channel reader/writer from the list of channels that are to be removed at shutdown.  *  * @param channel The channel reader/writer.  */ protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {     UnilateralSortMerger.this.openChannels.remove(channel). }
false;public;0;3;;public FileIOChannel.ID getChannel() {     return channel. }
false;public;0;3;;public int getBlockCount() {     return blockCount. }
