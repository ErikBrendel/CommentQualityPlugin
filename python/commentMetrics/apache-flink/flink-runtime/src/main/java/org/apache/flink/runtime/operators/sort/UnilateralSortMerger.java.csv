# id;timestamp;commentText;codeText;commentWords;codeWords
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1415702894;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1420663430;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1421838095;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1421838095;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1421838096;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1421838096;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1423142112;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1426697080;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1441738685;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1442312401;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1442870284;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1443522094;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1466529056;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1530185676;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1533306679;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int maxNumFileHandles, float startSpillingFraction) 	throws IOException, MemoryAllocationException;1405024514;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int maxNumFileHandles, float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, -1, maxNumFileHandles, startSpillingFraction)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,1,max,num,file,handles,start,spilling,fraction
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int maxNumFileHandles, float startSpillingFraction) 	throws IOException, MemoryAllocationException;1405090423;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int maxNumFileHandles, float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, -1, maxNumFileHandles, startSpillingFraction)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,1,max,num,file,handles,start,spilling,fraction
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int maxNumFileHandles, float startSpillingFraction) 	throws IOException, MemoryAllocationException;1409911022;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int maxNumFileHandles, float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, -1, maxNumFileHandles, startSpillingFraction)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,1,max,num,file,handles,start,spilling,fraction
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int maxNumFileHandles, float startSpillingFraction) 	throws IOException, MemoryAllocationException;1411236168;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int maxNumFileHandles, float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, -1, maxNumFileHandles, startSpillingFraction)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,1,max,num,file,handles,start,spilling,fraction
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int maxNumFileHandles, float startSpillingFraction) 	throws IOException, MemoryAllocationException;1411236169;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int maxNumFileHandles, float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, -1, maxNumFileHandles, startSpillingFraction)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,1,max,num,file,handles,start,spilling,fraction
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int maxNumFileHandles, float startSpillingFraction) 	throws IOException, MemoryAllocationException;1411473593;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int maxNumFileHandles, float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, -1, maxNumFileHandles, startSpillingFraction)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,1,max,num,file,handles,start,spilling,fraction
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int maxNumFileHandles, float startSpillingFraction) 	throws IOException, MemoryAllocationException;1415702894;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int maxNumFileHandles, float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, -1, maxNumFileHandles, startSpillingFraction)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,1,max,num,file,handles,start,spilling,fraction
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int maxNumFileHandles, float startSpillingFraction) 	throws IOException, MemoryAllocationException;1420663430;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int maxNumFileHandles, float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, -1, maxNumFileHandles, startSpillingFraction)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,1,max,num,file,handles,start,spilling,fraction
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1405024514;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param s The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1405090423;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param s The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1409911022;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param s The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1411236168;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param s The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1411236169;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1411473593;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1405024514;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size())__								_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators,	this.serializer, this.comparator))__				return__			}			_			_			_			_			final Channel.Enumerator enumerator = this.ioManager.createChannelEnumerator()_			_			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()___			_			_			while (isRunning())	{_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				Channel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_																channel, this.numWriteBuffersToCluster)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				element.buffer.writeToOutput(output)__				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			while (isRunning() && channelIDs.size() > this.maxNumFileHandles) {_				channelIDs = mergeChannelList(channelIDs, this.sortReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				setResultIterator(EmptyMutableObjectIterator.<E>get())__			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, this.sortReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,serializer,this,comparator,return,final,channel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,channel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,while,is,running,channel,ids,size,this,max,num,file,handles,channel,ids,merge,channel,list,channel,ids,this,sort,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,set,result,iterator,empty,mutable,object,iterator,e,get,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,this,sort,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,block,channel,access,channel,ids,size,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1405090423;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size())__								_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators,	this.serializer, this.comparator))__				return__			}			_			_			_			_			final Channel.Enumerator enumerator = this.ioManager.createChannelEnumerator()_			_			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()___			_			_			while (isRunning())	{_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				Channel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_																channel, this.numWriteBuffersToCluster)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				element.buffer.writeToOutput(output)__				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			while (isRunning() && channelIDs.size() > this.maxNumFileHandles) {_				channelIDs = mergeChannelList(channelIDs, this.sortReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				setResultIterator(EmptyMutableObjectIterator.<E>get())__			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, this.sortReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,serializer,this,comparator,return,final,channel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,channel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,while,is,running,channel,ids,size,this,max,num,file,handles,channel,ids,merge,channel,list,channel,ids,this,sort,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,set,result,iterator,empty,mutable,object,iterator,e,get,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,this,sort,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,block,channel,access,channel,ids,size,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1409911022;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size())__								_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators,	this.serializer, this.comparator))__				return__			}			_			_			_			_			final Channel.Enumerator enumerator = this.ioManager.createChannelEnumerator()_			_			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()___			_			_			while (isRunning())	{_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				Channel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_																channel, this.numWriteBuffersToCluster)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				element.buffer.writeToOutput(output)__				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			while (isRunning() && channelIDs.size() > this.maxNumFileHandles) {_				channelIDs = mergeChannelList(channelIDs, this.sortReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				setResultIterator(EmptyMutableObjectIterator.<E>get())__			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, this.sortReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,serializer,this,comparator,return,final,channel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,channel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,while,is,running,channel,ids,size,this,max,num,file,handles,channel,ids,merge,channel,list,channel,ids,this,sort,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,set,result,iterator,empty,mutable,object,iterator,e,get,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,this,sort,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,block,channel,access,channel,ids,size,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1411236168;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size())__								_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators,	this.serializer, this.comparator))__				return__			}			_			_			_			_			final Channel.Enumerator enumerator = this.ioManager.createChannelEnumerator()_			_			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()___			_			_			while (isRunning())	{_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				Channel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_																channel, this.numWriteBuffersToCluster)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				element.buffer.writeToOutput(output)__				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			while (isRunning() && channelIDs.size() > this.maxNumFileHandles) {_				channelIDs = mergeChannelList(channelIDs, this.sortReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				setResultIterator(EmptyMutableObjectIterator.<E>get())__			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, this.sortReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,serializer,this,comparator,return,final,channel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,channel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,while,is,running,channel,ids,size,this,max,num,file,handles,channel,ids,merge,channel,list,channel,ids,this,sort,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,set,result,iterator,empty,mutable,object,iterator,e,get,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,this,sort,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,block,channel,access,channel,ids,size,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1411236169;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size())__								_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators,	this.serializer, this.comparator))__				return__			}			_			_			_			_			final Channel.Enumerator enumerator = this.ioManager.createChannelEnumerator()_			_			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()___			_			_			while (isRunning())	{_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				Channel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_																channel, this.numWriteBuffersToCluster)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				element.buffer.writeToOutput(output)__				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			while (isRunning() && channelIDs.size() > this.maxNumFileHandles) {_				channelIDs = mergeChannelList(channelIDs, this.sortReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				setResultIterator(EmptyMutableObjectIterator.<E>get())__			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, this.sortReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,serializer,this,comparator,return,final,channel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,channel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,while,is,running,channel,ids,size,this,max,num,file,handles,channel,ids,merge,channel,list,channel,ids,this,sort,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,set,result,iterator,empty,mutable,object,iterator,e,get,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,this,sort,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,block,channel,access,channel,ids,size,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1411473593;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size())__								_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators,	this.serializer, this.comparator))__				return__			}			_			_			_			_			final Channel.Enumerator enumerator = this.ioManager.createChannelEnumerator()_			_			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()___			_			_			while (isRunning())	{_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				Channel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_																channel, this.numWriteBuffersToCluster)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				element.buffer.writeToOutput(output)__				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			while (isRunning() && channelIDs.size() > this.maxNumFileHandles) {_				channelIDs = mergeChannelList(channelIDs, this.sortReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				setResultIterator(EmptyMutableObjectIterator.<E>get())__			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, this.sortReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,serializer,this,comparator,return,final,channel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,channel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,while,is,running,channel,ids,size,this,max,num,file,handles,channel,ids,merge,channel,list,channel,ids,this,sort,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,set,result,iterator,empty,mutable,object,iterator,e,get,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,this,sort,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,block,channel,access,channel,ids,size,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1415702894;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size())__								_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators,	this.serializer, this.comparator))__				return__			}			_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()_			_			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()___			_			_			while (isRunning())	{_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				element.buffer.writeToOutput(output)__				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			while (isRunning() && channelIDs.size() > this.maxNumFileHandles) {_				channelIDs = mergeChannelList(channelIDs, this.sortReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				setResultIterator(EmptyMutableObjectIterator.<E>get())__			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, this.sortReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size())))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,serializer,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,while,is,running,channel,ids,size,this,max,num,file,handles,channel,ids,merge,channel,list,channel,ids,this,sort,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,set,result,iterator,empty,mutable,object,iterator,e,get,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,this,sort,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1420663430;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size())__								_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}			_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()___			_			_			while (isRunning())	{_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				element.buffer.writeToOutput(output)__				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			while (isRunning() && channelIDs.size() > this.maxNumFileHandles) {_				channelIDs = mergeChannelList(channelIDs, this.sortReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				setResultIterator(EmptyMutableObjectIterator.<E>get())__			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, this.sortReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size())))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,while,is,running,channel,ids,size,this,max,num,file,handles,channel,ids,merge,channel,list,channel,ids,this,sort,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,set,result,iterator,empty,mutable,object,iterator,e,get,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,this,sort,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1421838095;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					memoryForLargeRecordSorting.addAll(circElement.buffer.dispose())__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()___			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				element.buffer.writeToOutput(output)__				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,memory,for,large,record,sorting,add,all,circ,element,buffer,dispose,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1421838095;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					memoryForLargeRecordSorting.addAll(circElement.buffer.dispose())__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()___			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,memory,for,large,record,sorting,add,all,circ,element,buffer,dispose,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1421838096;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					memoryForLargeRecordSorting.addAll(circElement.buffer.dispose())__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))___				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,memory,for,large,record,sorting,add,all,circ,element,buffer,dispose,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1421838096;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					memoryForLargeRecordSorting.addAll(circElement.buffer.dispose())__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				if (output.getBytesWritten() > 0) {_					channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))__				}__				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,memory,for,large,record,sorting,add,all,circ,element,buffer,dispose,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,if,output,get,bytes,written,0,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1423142112;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					memoryForLargeRecordSorting.addAll(circElement.buffer.dispose())__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				if (output.getBytesWritten() > 0) {_					channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))__				}__				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,memory,for,large,record,sorting,add,all,circ,element,buffer,dispose,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,if,output,get,bytes,written,0,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1426697080;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					memoryForLargeRecordSorting.addAll(circElement.buffer.dispose())__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				if (output.getBytesWritten() > 0) {_					channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))__				}__				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,memory,for,large,record,sorting,add,all,circ,element,buffer,dispose,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,if,output,get,bytes,written,0,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1441738685;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					memoryForLargeRecordSorting.addAll(circElement.buffer.dispose())__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				if (output.getBytesWritten() > 0) {_					channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))__				}__				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,memory,for,large,record,sorting,add,all,circ,element,buffer,dispose,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,if,output,get,bytes,written,0,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1442312401;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element = null__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					memoryForLargeRecordSorting.addAll(circElement.buffer.dispose())__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				if (output.getBytesWritten() > 0) {_					channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))__				}__				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,null,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,memory,for,large,record,sorting,add,all,circ,element,buffer,dispose,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,if,output,get,bytes,written,0,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1442870284;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					circElement.buffer.dispose()__					memoryForLargeRecordSorting.addAll(circElement.memory)__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				if (output.getBytesWritten() > 0) {_					channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))__				}__				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,circ,element,buffer,dispose,memory,for,large,record,sorting,add,all,circ,element,memory,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,if,output,get,bytes,written,0,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1443522094;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					circElement.buffer.dispose()__					memoryForLargeRecordSorting.addAll(circElement.memory)__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				if (output.getBytesWritten() > 0) {_					channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))__				}__				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,circ,element,buffer,dispose,memory,for,large,record,sorting,add,all,circ,element,memory,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,if,output,get,bytes,written,0,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1466529056;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					circElement.buffer.dispose()__					memoryForLargeRecordSorting.addAll(circElement.memory)__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				if (output.getBytesWritten() > 0) {_					channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))__				}__				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,circ,element,buffer,dispose,memory,for,large,record,sorting,add,all,circ,element,memory,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,if,output,get,bytes,written,0,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1530185676;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					circElement.buffer.dispose()__					memoryForLargeRecordSorting.addAll(circElement.memory)__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				if (output.getBytesWritten() > 0) {_					channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))__				}__				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,circ,element,buffer,dispose,memory,for,large,record,sorting,add,all,circ,element,memory,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,if,output,get,bytes,written,0,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> SpillingThread -> public void go() throws IOException;1533306679;Entry point of the thread.;public void go() throws IOException {_			_			final Queue<CircularElement<E>> cache = new ArrayDeque<CircularElement<E>>()__			CircularElement<E> element__			boolean cacheOnly = false__			_			_			_			while (isRunning()) {_				_				try {_					element = this.queues.spill.take()__				}_				catch (InterruptedException iex) {_					throw new IOException("The spilling thread was interrupted.")__				}__				if (element == SPILLING_MARKER) {_					break__				}_				else if (element == EOF_MARKER) {_					cacheOnly = true__					break__				}_				cache.add(element)__			}_			_			_			if (!isRunning()) {_				return__			}_			_			MutableObjectIterator<E> largeRecords = null__			_			_			if (cacheOnly && largeRecordHandler != null && largeRecordHandler.hasData()) {_				List<MemorySegment> memoryForLargeRecordSorting = new ArrayList<MemorySegment>()__				_				CircularElement<E> circElement__				while ((circElement = this.queues.empty.poll()) != null) {_					circElement.buffer.dispose()__					memoryForLargeRecordSorting.addAll(circElement.memory)__				}_				_				if (memoryForLargeRecordSorting.isEmpty()) {_					cacheOnly = false__					LOG.debug("Going to disk-based merge because of large records.")__					_				} else {_					LOG.debug("Sorting large records, to add them to in-memory merge.")__					largeRecords = largeRecordHandler.finishWriteAndSortKeys(memoryForLargeRecordSorting)__				}_			}_			_			_			if (cacheOnly) {_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Initiating in memory merge.")__				}_				_				List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(cache.size() + 1)__				_				_				for (CircularElement<E> cached : cache) {_					_					iterators.add(cached.buffer.getIterator())__				}_				_				if (largeRecords != null) {_					iterators.add(largeRecords)__				}_				_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Releasing unused sort-buffer memory.")__				}_				disposeSortBuffers(true)__				_				_				setResultIterator(iterators.isEmpty() ? EmptyMutableObjectIterator.<E>get() :_						iterators.size() == 1 ? iterators.get(0) : _						new MergeIterator<E>(iterators, this.comparator))__				return__			}_			_			_			_			final FileIOChannel.Enumerator enumerator = this.ioManager.createChannelEnumerator()__			List<ChannelWithBlockCount> channelIDs = new ArrayList<ChannelWithBlockCount>()__			_			_			while (isRunning()) {_				try {_					element = takeNext(this.queues.spill, cache)__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						continue__					} else {_						return__					}_				}_				_				_				if (!isRunning()) {_					return__				}_				_				if (element == EOF_MARKER) {_					break__				}_				_				_				FileIOChannel.ID channel = enumerator.next()__				registerChannelToBeRemovedAtShudown(channel)___				_				final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel)__				registerOpenChannelToBeRemovedAtShudown(writer)__				final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, this.writeMemory,_																			this.memManager.getPageSize())___				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilling buffer " + element.id + ".")__				}_				_				element.buffer.writeToOutput(output, largeRecordHandler)__				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Spilled buffer " + element.id + ".")__				}__				output.close()__				unregisterOpenChannelToBeRemovedAtShudown(writer)__				_				if (output.getBytesWritten() > 0) {_					channelIDs.add(new ChannelWithBlockCount(channel, output.getBlockCount()))__				}__				_				element.buffer.reset()__				this.queues.empty.add(element)__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling done.")__				LOG.debug("Releasing sort-buffer memory.")__			}_			_			_			disposeSortBuffers(false)___			_			_			_			_			List<MemorySegment> mergeReadMemory__			_			if (largeRecordHandler != null && largeRecordHandler.hasData()) {_				_				List<MemorySegment> longRecMem__				if (channelIDs.isEmpty()) {_					_					longRecMem = this.mergeReadMemory__					mergeReadMemory = Collections.emptyList()__				}_				else {_					int maxMergedStreams = Math.min(this.maxFanIn, channelIDs.size())__					_					int pagesPerStream = Math.max(MIN_NUM_WRITE_BUFFERS,_							Math.min(MAX_NUM_WRITE_BUFFERS, this.mergeReadMemory.size() / 2 / maxMergedStreams))__					_					int totalMergeReadMemory = maxMergedStreams * pagesPerStream__					_					_					mergeReadMemory = new ArrayList<MemorySegment>(totalMergeReadMemory)__					for (int i = 0_ i < totalMergeReadMemory_ i++) {_						mergeReadMemory.add(this.mergeReadMemory.get(i))__					}_					_					_					longRecMem = new ArrayList<MemorySegment>()__					for (int i = totalMergeReadMemory_ i < this.mergeReadMemory.size()_ i++) {_						longRecMem.add(this.mergeReadMemory.get(i))__					}_				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Sorting keys for large records.")__				}_				largeRecords = largeRecordHandler.finishWriteAndSortKeys(longRecMem)__			}_			else {_				mergeReadMemory = this.mergeReadMemory__			}_			_			_			while (isRunning() && channelIDs.size() > this.maxFanIn) {_				channelIDs = mergeChannelList(channelIDs, mergeReadMemory, this.writeMemory)__			}_			_			_			this.memManager.release(this.writeMemory)__			this.writeMemory.clear()__			_			_			if (channelIDs.isEmpty()) {_				if (largeRecords == null) {_					setResultIterator(EmptyMutableObjectIterator.<E>get())__				} else {_					setResultIterator(largeRecords)__				}_			}_			else {_				if (LOG.isDebugEnabled()) {_					LOG.debug("Beginning final merge.")__				}_				_				_				List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelIDs.size())__				_				_				getSegmentsForReaders(readBuffers, mergeReadMemory, channelIDs.size())__				_				_				setResultIterator(getMergingIterator(channelIDs, readBuffers, new ArrayList<FileIOChannel>(channelIDs.size()), largeRecords))__			}__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Spilling and merging thread done.")__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,final,queue,circular,element,e,cache,new,array,deque,circular,element,e,circular,element,e,element,boolean,cache,only,false,while,is,running,try,element,this,queues,spill,take,catch,interrupted,exception,iex,throw,new,ioexception,the,spilling,thread,was,interrupted,if,element,break,else,if,element,cache,only,true,break,cache,add,element,if,is,running,return,mutable,object,iterator,e,large,records,null,if,cache,only,large,record,handler,null,large,record,handler,has,data,list,memory,segment,memory,for,large,record,sorting,new,array,list,memory,segment,circular,element,e,circ,element,while,circ,element,this,queues,empty,poll,null,circ,element,buffer,dispose,memory,for,large,record,sorting,add,all,circ,element,memory,if,memory,for,large,record,sorting,is,empty,cache,only,false,log,debug,going,to,disk,based,merge,because,of,large,records,else,log,debug,sorting,large,records,to,add,them,to,in,memory,merge,large,records,large,record,handler,finish,write,and,sort,keys,memory,for,large,record,sorting,if,cache,only,if,log,is,debug,enabled,log,debug,initiating,in,memory,merge,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,cache,size,1,for,circular,element,e,cached,cache,iterators,add,cached,buffer,get,iterator,if,large,records,null,iterators,add,large,records,if,log,is,debug,enabled,log,debug,releasing,unused,sort,buffer,memory,dispose,sort,buffers,true,set,result,iterator,iterators,is,empty,empty,mutable,object,iterator,e,get,iterators,size,1,iterators,get,0,new,merge,iterator,e,iterators,this,comparator,return,final,file,iochannel,enumerator,enumerator,this,io,manager,create,channel,enumerator,list,channel,with,block,count,channel,ids,new,array,list,channel,with,block,count,while,is,running,try,element,take,next,this,queues,spill,cache,catch,interrupted,exception,iex,if,is,running,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,is,running,return,if,element,break,file,iochannel,id,channel,enumerator,next,register,channel,to,be,removed,at,shudown,channel,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,channel,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,this,write,memory,this,mem,manager,get,page,size,if,log,is,debug,enabled,log,debug,spilling,buffer,element,id,element,buffer,write,to,output,output,large,record,handler,if,log,is,debug,enabled,log,debug,spilled,buffer,element,id,output,close,unregister,open,channel,to,be,removed,at,shudown,writer,if,output,get,bytes,written,0,channel,ids,add,new,channel,with,block,count,channel,output,get,block,count,element,buffer,reset,this,queues,empty,add,element,if,log,is,debug,enabled,log,debug,spilling,done,log,debug,releasing,sort,buffer,memory,dispose,sort,buffers,false,list,memory,segment,merge,read,memory,if,large,record,handler,null,large,record,handler,has,data,list,memory,segment,long,rec,mem,if,channel,ids,is,empty,long,rec,mem,this,merge,read,memory,merge,read,memory,collections,empty,list,else,int,max,merged,streams,math,min,this,max,fan,in,channel,ids,size,int,pages,per,stream,math,max,math,min,this,merge,read,memory,size,2,max,merged,streams,int,total,merge,read,memory,max,merged,streams,pages,per,stream,merge,read,memory,new,array,list,memory,segment,total,merge,read,memory,for,int,i,0,i,total,merge,read,memory,i,merge,read,memory,add,this,merge,read,memory,get,i,long,rec,mem,new,array,list,memory,segment,for,int,i,total,merge,read,memory,i,this,merge,read,memory,size,i,long,rec,mem,add,this,merge,read,memory,get,i,if,log,is,debug,enabled,log,debug,sorting,keys,for,large,records,large,records,large,record,handler,finish,write,and,sort,keys,long,rec,mem,else,merge,read,memory,this,merge,read,memory,while,is,running,channel,ids,size,this,max,fan,in,channel,ids,merge,channel,list,channel,ids,merge,read,memory,this,write,memory,this,mem,manager,release,this,write,memory,this,write,memory,clear,if,channel,ids,is,empty,if,large,records,null,set,result,iterator,empty,mutable,object,iterator,e,get,else,set,result,iterator,large,records,else,if,log,is,debug,enabled,log,debug,beginning,final,merge,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channel,ids,size,get,segments,for,readers,read,buffers,merge,read,memory,channel,ids,size,set,result,iterator,get,merging,iterator,channel,ids,read,buffers,new,array,list,file,iochannel,channel,ids,size,large,records,if,log,is,debug,enabled,log,debug,spilling,and,merging,thread,done
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1405024514;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1405090423;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1409911022;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1411236168;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1411236169;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1411473593;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1415702894;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1420663430;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1405024514;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1405090423;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1409911022;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1411236168;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1411236169;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1411473593;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1415702894;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1420663430;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1421838095;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1421838095;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1421838096;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1421838096;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1423142112;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1426697080;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1441738685;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1442312401;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1442870284;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1443522094;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1466529056;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1530185676;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> protected final void internalHandleException(IOException ioex);1533306679;Internally handles an exception and makes sure that this method returns without a problem.__@param ioex_The exception to handle.;protected final void internalHandleException(IOException ioex) {_			if (!isRunning()) {_				_				return__			}_			if (this.exceptionHandler != null) {_				try {_					this.exceptionHandler.handleException(ioex)__				}_				catch (Throwable t) {}_			}_		};internally,handles,an,exception,and,makes,sure,that,this,method,returns,without,a,problem,param,ioex,the,exception,to,handle;protected,final,void,internal,handle,exception,ioexception,ioex,if,is,running,return,if,this,exception,handler,null,try,this,exception,handler,handle,exception,ioex,catch,throwable,t
UnilateralSortMerger -> ThreadBase -> public void shutdown();1405024514;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1405090423;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1409911022;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1411236168;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1411236169;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1411473593;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1415702894;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1420663430;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1421838095;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1421838095;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1421838096;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1421838096;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1423142112;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1426697080;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1441738685;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1442312401;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1442870284;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1443522094;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1466529056;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1530185676;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> ThreadBase -> public void shutdown();1533306679;Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently_working on. This terminates cleanly for the JVM, but looses intermediate results.;public void shutdown() {_			this.alive = false__			this.interrupt()__		};forces,an,immediate,shutdown,of,the,thread,looses,any,state,and,all,buffers,that,the,thread,is,currently,working,on,this,terminates,cleanly,for,the,jvm,but,looses,intermediate,results;public,void,shutdown,this,alive,false,this,interrupt
UnilateralSortMerger -> protected void startThreads();1405024514;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1405090423;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1409911022;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1411236168;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1411236169;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1411473593;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1415702894;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1420663430;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1421838095;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1421838095;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1421838096;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1421838096;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1423142112;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1426697080;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1441738685;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1442312401;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1442870284;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1443522094;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1466529056;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1530185676;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> protected void startThreads();1533306679;Starts all the threads that are used by this sort-merger.;protected void startThreads() {_		if (this.readThread != null) {_			this.readThread.start()__		}_		if (this.sortThread != null) {_			this.sortThread.start()__		}_		if (this.spillThread != null) {_			this.spillThread.start()__		}_	};starts,all,the,threads,that,are,used,by,this,sort,merger;protected,void,start,threads,if,this,read,thread,null,this,read,thread,start,if,this,sort,thread,null,this,sort,thread,start,if,this,spill,thread,null,this,spill,thread,start
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList) 			throws IOException;1415702894;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size())__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}__			return new MergeIterator<E>(iterators, this.serializer, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,return,new,merge,iterator,e,iterators,this,serializer,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList) 			throws IOException;1420663430;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size())__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction, boolean noSpillingMemory) 	throws IOException, MemoryAllocationException;1405024514;Internal constructor and constructor for subclasses that want to circumvent the spilling.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk._@param noSpillingMemory When set to true, no memory will be allocated for writing and no spilling thread_will be spawned.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction, boolean noSpillingMemory)_	throws IOException, MemoryAllocationException_	{_		_		if (memoryManager == null | (ioManager == null && !noSpillingMemory) | serializerFactory == null | comparator == null) {_			throw new NullPointerException()__		}_		if (parentTask == null) {_			throw new NullPointerException("Parent Task must not be null.")__		}_		if (maxNumFileHandles < 2) {_			throw new IllegalArgumentException("Merger cannot work with less than two file handles.")__		}_		_		this.memoryManager = memoryManager__		_		_		final int numPagesTotal = memoryManager.computeNumberOfPages(memoryFraction)___		if (numPagesTotal < MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) {_			throw new IllegalArgumentException("Too little memory provided to sorter to perform task. " +_				"Required are at least " + (MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) + _				" pages. Current page size is " + memoryManager.getPageSize() + " bytes.")__		}_		_		_		final int numWriteBuffers__		if (noSpillingMemory) {_			numWriteBuffers = 0__		} else {_			_			final int minBuffers = MIN_NUM_WRITE_BUFFERS + maxNumFileHandles__			final int desiredBuffers = MIN_NUM_WRITE_BUFFERS + 2 * maxNumFileHandles__			_			if (desiredBuffers > numPagesTotal) {_				numWriteBuffers = MIN_NUM_WRITE_BUFFERS__				if (minBuffers > numPagesTotal) {_					maxNumFileHandles = numPagesTotal - MIN_NUM_WRITE_BUFFERS__					if (LOG.isDebugEnabled()) {_						LOG.debug("Reducing maximal merge fan-in to " + maxNumFileHandles + " due to limited memory availability during merge")__					}_				}_			}_			else {_				_				final int designatedWriteBuffers = numPagesTotal / (maxNumFileHandles + 1)__				final int fractional = numPagesTotal / 64__				final int maximal = numPagesTotal - MIN_NUM_SORT_MEM_SEGMENTS__				_				numWriteBuffers = Math.max(MIN_NUM_WRITE_BUFFERS,	_					Math.min(Math.min(MAX_NUM_WRITE_BUFFERS, maximal), 		_					Math.min(designatedWriteBuffers, fractional)))_			_			}_		}_		_		final int sortMemPages = numPagesTotal - numWriteBuffers__		final long sortMemory = ((long) sortMemPages) * memoryManager.getPageSize()__		_		_		if (numSortBuffers < 1) {_			if (sortMemory > 96 * 1024 * 1024) {_				numSortBuffers = 3__			}_			else if (sortMemPages >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {_				numSortBuffers = 2__			}_			else {_				numSortBuffers = 1__			}_		}_		final int numSegmentsPerSortBuffer = sortMemPages / numSortBuffers__		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Instantiating sorter with " + sortMemPages + " pages of sorting memory (=" +_				sortMemory + " bytes total) divided over " + numSortBuffers + " sort buffers (" + _				numSegmentsPerSortBuffer + " pages per buffer). Using " + numWriteBuffers + _				" buffers for writing sorted results and merging maximally " + maxNumFileHandles +_				" streams at once.")__		}_		_		this.writeMemory = new ArrayList<MemorySegment>(numWriteBuffers)__		this.sortReadMemory = new ArrayList<MemorySegment>(sortMemPages)__		_		_		memoryManager.allocatePages(parentTask, this.sortReadMemory, sortMemPages)__		if (numWriteBuffers > 0) {_			memoryManager.allocatePages(parentTask, this.writeMemory, numWriteBuffers)__		}_		_		_		final CircularQueues<E> circularQueues = new CircularQueues<E>()__		_		final TypeSerializer<E> serializer = serializerFactory.getSerializer()__		_		_		final Iterator<MemorySegment> segments = this.sortReadMemory.iterator()__		for (int i = 0_ i < numSortBuffers_ i++)_		{_			_			final List<MemorySegment> sortSegments = new ArrayList<MemorySegment>(numSegmentsPerSortBuffer)__			for (int k = (i == numSortBuffers - 1 ? Integer.MAX_VALUE : numSegmentsPerSortBuffer)_ k > 0 && segments.hasNext()_ k--) {_				sortSegments.add(segments.next())__			}_			_			final TypeComparator<E> comp = comparator.duplicate()__			final InMemorySorter<E> buffer__			_			_			if (comp.supportsSerializationWithKeyNormalization() &&_					serializer.getLength() > 0 && serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING)_			{_				buffer = new FixedLengthRecordSorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			} else {_				buffer = new NormalizedKeySorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			}__			_			CircularElement<E> element = new CircularElement<E>(i, buffer)__			circularQueues.empty.add(element)__		}__		_		ExceptionHandler<IOException> exceptionHandler = new ExceptionHandler<IOException>() {_			public void handleException(IOException exception) {_				_				if (!closed) {_					setResultIteratorException(exception)__					close()__				}_			}_		}__		_		_		this.channelsToDeleteAtShutdown = new HashSet<Channel.ID>(64)__		this.openChannels = new HashSet<BlockChannelAccess<?,?>>(64)___		_		this.readThread = getReadingThread(exceptionHandler, input, circularQueues, parentTask,_			serializer, ((long) (startSpillingFraction * sortMemory)))___		_		this.sortThread = getSortingThread(exceptionHandler, circularQueues, parentTask)___		_		this.spillThread = getSpillingThread(exceptionHandler, circularQueues, parentTask, _				memoryManager, ioManager, serializerFactory, comparator, this.sortReadMemory, this.writeMemory, _				maxNumFileHandles)__		_		startThreads()__	};internal,constructor,and,constructor,for,subclasses,that,want,to,circumvent,the,spilling,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,param,no,spilling,memory,when,set,to,true,no,memory,will,be,allocated,for,writing,and,no,spilling,thread,will,be,spawned,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;protected,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,boolean,no,spilling,memory,throws,ioexception,memory,allocation,exception,if,memory,manager,null,io,manager,null,no,spilling,memory,serializer,factory,null,comparator,null,throw,new,null,pointer,exception,if,parent,task,null,throw,new,null,pointer,exception,parent,task,must,not,be,null,if,max,num,file,handles,2,throw,new,illegal,argument,exception,merger,cannot,work,with,less,than,two,file,handles,this,memory,manager,memory,manager,final,int,num,pages,total,memory,manager,compute,number,of,pages,memory,fraction,if,num,pages,total,throw,new,illegal,argument,exception,too,little,memory,provided,to,sorter,to,perform,task,required,are,at,least,pages,current,page,size,is,memory,manager,get,page,size,bytes,final,int,num,write,buffers,if,no,spilling,memory,num,write,buffers,0,else,final,int,min,buffers,max,num,file,handles,final,int,desired,buffers,2,max,num,file,handles,if,desired,buffers,num,pages,total,num,write,buffers,if,min,buffers,num,pages,total,max,num,file,handles,num,pages,total,if,log,is,debug,enabled,log,debug,reducing,maximal,merge,fan,in,to,max,num,file,handles,due,to,limited,memory,availability,during,merge,else,final,int,designated,write,buffers,num,pages,total,max,num,file,handles,1,final,int,fractional,num,pages,total,64,final,int,maximal,num,pages,total,num,write,buffers,math,max,math,min,math,min,maximal,math,min,designated,write,buffers,fractional,final,int,sort,mem,pages,num,pages,total,num,write,buffers,final,long,sort,memory,long,sort,mem,pages,memory,manager,get,page,size,if,num,sort,buffers,1,if,sort,memory,96,1024,1024,num,sort,buffers,3,else,if,sort,mem,pages,2,num,sort,buffers,2,else,num,sort,buffers,1,final,int,num,segments,per,sort,buffer,sort,mem,pages,num,sort,buffers,if,log,is,debug,enabled,log,debug,instantiating,sorter,with,sort,mem,pages,pages,of,sorting,memory,sort,memory,bytes,total,divided,over,num,sort,buffers,sort,buffers,num,segments,per,sort,buffer,pages,per,buffer,using,num,write,buffers,buffers,for,writing,sorted,results,and,merging,maximally,max,num,file,handles,streams,at,once,this,write,memory,new,array,list,memory,segment,num,write,buffers,this,sort,read,memory,new,array,list,memory,segment,sort,mem,pages,memory,manager,allocate,pages,parent,task,this,sort,read,memory,sort,mem,pages,if,num,write,buffers,0,memory,manager,allocate,pages,parent,task,this,write,memory,num,write,buffers,final,circular,queues,e,circular,queues,new,circular,queues,e,final,type,serializer,e,serializer,serializer,factory,get,serializer,final,iterator,memory,segment,segments,this,sort,read,memory,iterator,for,int,i,0,i,num,sort,buffers,i,final,list,memory,segment,sort,segments,new,array,list,memory,segment,num,segments,per,sort,buffer,for,int,k,i,num,sort,buffers,1,integer,num,segments,per,sort,buffer,k,0,segments,has,next,k,sort,segments,add,segments,next,final,type,comparator,e,comp,comparator,duplicate,final,in,memory,sorter,e,buffer,if,comp,supports,serialization,with,key,normalization,serializer,get,length,0,serializer,get,length,buffer,new,fixed,length,record,sorter,e,serializer,factory,get,serializer,comp,sort,segments,else,buffer,new,normalized,key,sorter,e,serializer,factory,get,serializer,comp,sort,segments,circular,element,e,element,new,circular,element,e,i,buffer,circular,queues,empty,add,element,exception,handler,ioexception,exception,handler,new,exception,handler,ioexception,public,void,handle,exception,ioexception,exception,if,closed,set,result,iterator,exception,exception,close,this,channels,to,delete,at,shutdown,new,hash,set,channel,id,64,this,open,channels,new,hash,set,block,channel,access,64,this,read,thread,get,reading,thread,exception,handler,input,circular,queues,parent,task,serializer,long,start,spilling,fraction,sort,memory,this,sort,thread,get,sorting,thread,exception,handler,circular,queues,parent,task,this,spill,thread,get,spilling,thread,exception,handler,circular,queues,parent,task,memory,manager,io,manager,serializer,factory,comparator,this,sort,read,memory,this,write,memory,max,num,file,handles,start,threads
UnilateralSortMerger -> protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction, boolean noSpillingMemory) 	throws IOException, MemoryAllocationException;1405090423;Internal constructor and constructor for subclasses that want to circumvent the spilling.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk._@param noSpillingMemory When set to true, no memory will be allocated for writing and no spilling thread_will be spawned.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction, boolean noSpillingMemory)_	throws IOException, MemoryAllocationException_	{_		_		if (memoryManager == null | (ioManager == null && !noSpillingMemory) | serializerFactory == null | comparator == null) {_			throw new NullPointerException()__		}_		if (parentTask == null) {_			throw new NullPointerException("Parent Task must not be null.")__		}_		if (maxNumFileHandles < 2) {_			throw new IllegalArgumentException("Merger cannot work with less than two file handles.")__		}_		_		this.memoryManager = memoryManager__		_		_		final int numPagesTotal = memoryManager.computeNumberOfPages(memoryFraction)___		if (numPagesTotal < MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) {_			throw new IllegalArgumentException("Too little memory provided to sorter to perform task. " +_				"Required are at least " + (MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) + _				" pages. Current page size is " + memoryManager.getPageSize() + " bytes.")__		}_		_		_		final int numWriteBuffers__		if (noSpillingMemory) {_			numWriteBuffers = 0__		} else {_			_			final int minBuffers = MIN_NUM_WRITE_BUFFERS + maxNumFileHandles__			final int desiredBuffers = MIN_NUM_WRITE_BUFFERS + 2 * maxNumFileHandles__			_			if (desiredBuffers > numPagesTotal) {_				numWriteBuffers = MIN_NUM_WRITE_BUFFERS__				if (minBuffers > numPagesTotal) {_					maxNumFileHandles = numPagesTotal - MIN_NUM_WRITE_BUFFERS__					if (LOG.isDebugEnabled()) {_						LOG.debug("Reducing maximal merge fan-in to " + maxNumFileHandles + " due to limited memory availability during merge")__					}_				}_			}_			else {_				_				final int designatedWriteBuffers = numPagesTotal / (maxNumFileHandles + 1)__				final int fractional = numPagesTotal / 64__				final int maximal = numPagesTotal - MIN_NUM_SORT_MEM_SEGMENTS__				_				numWriteBuffers = Math.max(MIN_NUM_WRITE_BUFFERS,	_					Math.min(Math.min(MAX_NUM_WRITE_BUFFERS, maximal), 		_					Math.min(designatedWriteBuffers, fractional)))_			_			}_		}_		_		final int sortMemPages = numPagesTotal - numWriteBuffers__		final long sortMemory = ((long) sortMemPages) * memoryManager.getPageSize()__		_		_		if (numSortBuffers < 1) {_			if (sortMemory > 96 * 1024 * 1024) {_				numSortBuffers = 3__			}_			else if (sortMemPages >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {_				numSortBuffers = 2__			}_			else {_				numSortBuffers = 1__			}_		}_		final int numSegmentsPerSortBuffer = sortMemPages / numSortBuffers__		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Instantiating sorter with " + sortMemPages + " pages of sorting memory (=" +_				sortMemory + " bytes total) divided over " + numSortBuffers + " sort buffers (" + _				numSegmentsPerSortBuffer + " pages per buffer). Using " + numWriteBuffers + _				" buffers for writing sorted results and merging maximally " + maxNumFileHandles +_				" streams at once.")__		}_		_		this.writeMemory = new ArrayList<MemorySegment>(numWriteBuffers)__		this.sortReadMemory = new ArrayList<MemorySegment>(sortMemPages)__		_		_		memoryManager.allocatePages(parentTask, this.sortReadMemory, sortMemPages)__		if (numWriteBuffers > 0) {_			memoryManager.allocatePages(parentTask, this.writeMemory, numWriteBuffers)__		}_		_		_		final CircularQueues<E> circularQueues = new CircularQueues<E>()__		_		final TypeSerializer<E> serializer = serializerFactory.getSerializer()__		_		_		final Iterator<MemorySegment> segments = this.sortReadMemory.iterator()__		for (int i = 0_ i < numSortBuffers_ i++)_		{_			_			final List<MemorySegment> sortSegments = new ArrayList<MemorySegment>(numSegmentsPerSortBuffer)__			for (int k = (i == numSortBuffers - 1 ? Integer.MAX_VALUE : numSegmentsPerSortBuffer)_ k > 0 && segments.hasNext()_ k--) {_				sortSegments.add(segments.next())__			}_			_			final TypeComparator<E> comp = comparator.duplicate()__			final InMemorySorter<E> buffer__			_			_			if (comp.supportsSerializationWithKeyNormalization() &&_					serializer.getLength() > 0 && serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING)_			{_				buffer = new FixedLengthRecordSorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			} else {_				buffer = new NormalizedKeySorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			}__			_			CircularElement<E> element = new CircularElement<E>(i, buffer)__			circularQueues.empty.add(element)__		}__		_		ExceptionHandler<IOException> exceptionHandler = new ExceptionHandler<IOException>() {_			public void handleException(IOException exception) {_				_				if (!closed) {_					setResultIteratorException(exception)__					close()__				}_			}_		}__		_		_		this.channelsToDeleteAtShutdown = new HashSet<Channel.ID>(64)__		this.openChannels = new HashSet<BlockChannelAccess<?,?>>(64)___		_		this.readThread = getReadingThread(exceptionHandler, input, circularQueues, parentTask,_			serializer, ((long) (startSpillingFraction * sortMemory)))___		_		this.sortThread = getSortingThread(exceptionHandler, circularQueues, parentTask)___		_		this.spillThread = getSpillingThread(exceptionHandler, circularQueues, parentTask, _				memoryManager, ioManager, serializerFactory, comparator, this.sortReadMemory, this.writeMemory, _				maxNumFileHandles)__		_		startThreads()__	};internal,constructor,and,constructor,for,subclasses,that,want,to,circumvent,the,spilling,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,param,no,spilling,memory,when,set,to,true,no,memory,will,be,allocated,for,writing,and,no,spilling,thread,will,be,spawned,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;protected,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,boolean,no,spilling,memory,throws,ioexception,memory,allocation,exception,if,memory,manager,null,io,manager,null,no,spilling,memory,serializer,factory,null,comparator,null,throw,new,null,pointer,exception,if,parent,task,null,throw,new,null,pointer,exception,parent,task,must,not,be,null,if,max,num,file,handles,2,throw,new,illegal,argument,exception,merger,cannot,work,with,less,than,two,file,handles,this,memory,manager,memory,manager,final,int,num,pages,total,memory,manager,compute,number,of,pages,memory,fraction,if,num,pages,total,throw,new,illegal,argument,exception,too,little,memory,provided,to,sorter,to,perform,task,required,are,at,least,pages,current,page,size,is,memory,manager,get,page,size,bytes,final,int,num,write,buffers,if,no,spilling,memory,num,write,buffers,0,else,final,int,min,buffers,max,num,file,handles,final,int,desired,buffers,2,max,num,file,handles,if,desired,buffers,num,pages,total,num,write,buffers,if,min,buffers,num,pages,total,max,num,file,handles,num,pages,total,if,log,is,debug,enabled,log,debug,reducing,maximal,merge,fan,in,to,max,num,file,handles,due,to,limited,memory,availability,during,merge,else,final,int,designated,write,buffers,num,pages,total,max,num,file,handles,1,final,int,fractional,num,pages,total,64,final,int,maximal,num,pages,total,num,write,buffers,math,max,math,min,math,min,maximal,math,min,designated,write,buffers,fractional,final,int,sort,mem,pages,num,pages,total,num,write,buffers,final,long,sort,memory,long,sort,mem,pages,memory,manager,get,page,size,if,num,sort,buffers,1,if,sort,memory,96,1024,1024,num,sort,buffers,3,else,if,sort,mem,pages,2,num,sort,buffers,2,else,num,sort,buffers,1,final,int,num,segments,per,sort,buffer,sort,mem,pages,num,sort,buffers,if,log,is,debug,enabled,log,debug,instantiating,sorter,with,sort,mem,pages,pages,of,sorting,memory,sort,memory,bytes,total,divided,over,num,sort,buffers,sort,buffers,num,segments,per,sort,buffer,pages,per,buffer,using,num,write,buffers,buffers,for,writing,sorted,results,and,merging,maximally,max,num,file,handles,streams,at,once,this,write,memory,new,array,list,memory,segment,num,write,buffers,this,sort,read,memory,new,array,list,memory,segment,sort,mem,pages,memory,manager,allocate,pages,parent,task,this,sort,read,memory,sort,mem,pages,if,num,write,buffers,0,memory,manager,allocate,pages,parent,task,this,write,memory,num,write,buffers,final,circular,queues,e,circular,queues,new,circular,queues,e,final,type,serializer,e,serializer,serializer,factory,get,serializer,final,iterator,memory,segment,segments,this,sort,read,memory,iterator,for,int,i,0,i,num,sort,buffers,i,final,list,memory,segment,sort,segments,new,array,list,memory,segment,num,segments,per,sort,buffer,for,int,k,i,num,sort,buffers,1,integer,num,segments,per,sort,buffer,k,0,segments,has,next,k,sort,segments,add,segments,next,final,type,comparator,e,comp,comparator,duplicate,final,in,memory,sorter,e,buffer,if,comp,supports,serialization,with,key,normalization,serializer,get,length,0,serializer,get,length,buffer,new,fixed,length,record,sorter,e,serializer,factory,get,serializer,comp,sort,segments,else,buffer,new,normalized,key,sorter,e,serializer,factory,get,serializer,comp,sort,segments,circular,element,e,element,new,circular,element,e,i,buffer,circular,queues,empty,add,element,exception,handler,ioexception,exception,handler,new,exception,handler,ioexception,public,void,handle,exception,ioexception,exception,if,closed,set,result,iterator,exception,exception,close,this,channels,to,delete,at,shutdown,new,hash,set,channel,id,64,this,open,channels,new,hash,set,block,channel,access,64,this,read,thread,get,reading,thread,exception,handler,input,circular,queues,parent,task,serializer,long,start,spilling,fraction,sort,memory,this,sort,thread,get,sorting,thread,exception,handler,circular,queues,parent,task,this,spill,thread,get,spilling,thread,exception,handler,circular,queues,parent,task,memory,manager,io,manager,serializer,factory,comparator,this,sort,read,memory,this,write,memory,max,num,file,handles,start,threads
UnilateralSortMerger -> protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction, boolean noSpillingMemory) 	throws IOException, MemoryAllocationException;1409911022;Internal constructor and constructor for subclasses that want to circumvent the spilling.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk._@param noSpillingMemory When set to true, no memory will be allocated for writing and no spilling thread_will be spawned.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction, boolean noSpillingMemory)_	throws IOException, MemoryAllocationException_	{_		_		if (memoryManager == null | (ioManager == null && !noSpillingMemory) | serializerFactory == null | comparator == null) {_			throw new NullPointerException()__		}_		if (parentTask == null) {_			throw new NullPointerException("Parent Task must not be null.")__		}_		if (maxNumFileHandles < 2) {_			throw new IllegalArgumentException("Merger cannot work with less than two file handles.")__		}_		_		this.memoryManager = memoryManager__		_		_		final int numPagesTotal = memoryManager.computeNumberOfPages(memoryFraction)___		if (numPagesTotal < MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) {_			throw new IllegalArgumentException("Too little memory provided to sorter to perform task. " +_				"Required are at least " + (MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) + _				" pages. Current page size is " + memoryManager.getPageSize() + " bytes.")__		}_		_		_		final int numWriteBuffers__		if (noSpillingMemory) {_			numWriteBuffers = 0__		} else {_			_			final int minBuffers = MIN_NUM_WRITE_BUFFERS + maxNumFileHandles__			final int desiredBuffers = MIN_NUM_WRITE_BUFFERS + 2 * maxNumFileHandles__			_			if (desiredBuffers > numPagesTotal) {_				numWriteBuffers = MIN_NUM_WRITE_BUFFERS__				if (minBuffers > numPagesTotal) {_					maxNumFileHandles = numPagesTotal - MIN_NUM_WRITE_BUFFERS__					if (LOG.isDebugEnabled()) {_						LOG.debug("Reducing maximal merge fan-in to " + maxNumFileHandles + " due to limited memory availability during merge")__					}_				}_			}_			else {_				_				final int designatedWriteBuffers = numPagesTotal / (maxNumFileHandles + 1)__				final int fractional = numPagesTotal / 64__				final int maximal = numPagesTotal - MIN_NUM_SORT_MEM_SEGMENTS__				_				numWriteBuffers = Math.max(MIN_NUM_WRITE_BUFFERS,	_					Math.min(Math.min(MAX_NUM_WRITE_BUFFERS, maximal), 		_					Math.min(designatedWriteBuffers, fractional)))_			_			}_		}_		_		final int sortMemPages = numPagesTotal - numWriteBuffers__		final long sortMemory = ((long) sortMemPages) * memoryManager.getPageSize()__		_		_		if (numSortBuffers < 1) {_			if (sortMemory > 96 * 1024 * 1024) {_				numSortBuffers = 3__			}_			else if (sortMemPages >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {_				numSortBuffers = 2__			}_			else {_				numSortBuffers = 1__			}_		}_		final int numSegmentsPerSortBuffer = sortMemPages / numSortBuffers__		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Instantiating sorter with " + sortMemPages + " pages of sorting memory (=" +_				sortMemory + " bytes total) divided over " + numSortBuffers + " sort buffers (" + _				numSegmentsPerSortBuffer + " pages per buffer). Using " + numWriteBuffers + _				" buffers for writing sorted results and merging maximally " + maxNumFileHandles +_				" streams at once.")__		}_		_		this.writeMemory = new ArrayList<MemorySegment>(numWriteBuffers)__		this.sortReadMemory = new ArrayList<MemorySegment>(sortMemPages)__		_		_		memoryManager.allocatePages(parentTask, this.sortReadMemory, sortMemPages)__		if (numWriteBuffers > 0) {_			memoryManager.allocatePages(parentTask, this.writeMemory, numWriteBuffers)__		}_		_		_		final CircularQueues<E> circularQueues = new CircularQueues<E>()__		_		final TypeSerializer<E> serializer = serializerFactory.getSerializer()__		_		_		final Iterator<MemorySegment> segments = this.sortReadMemory.iterator()__		for (int i = 0_ i < numSortBuffers_ i++)_		{_			_			final List<MemorySegment> sortSegments = new ArrayList<MemorySegment>(numSegmentsPerSortBuffer)__			for (int k = (i == numSortBuffers - 1 ? Integer.MAX_VALUE : numSegmentsPerSortBuffer)_ k > 0 && segments.hasNext()_ k--) {_				sortSegments.add(segments.next())__			}_			_			final TypeComparator<E> comp = comparator.duplicate()__			final InMemorySorter<E> buffer__			_			_			if (comp.supportsSerializationWithKeyNormalization() &&_					serializer.getLength() > 0 && serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING)_			{_				buffer = new FixedLengthRecordSorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			} else {_				buffer = new NormalizedKeySorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			}__			_			CircularElement<E> element = new CircularElement<E>(i, buffer)__			circularQueues.empty.add(element)__		}__		_		ExceptionHandler<IOException> exceptionHandler = new ExceptionHandler<IOException>() {_			public void handleException(IOException exception) {_				_				if (!closed) {_					setResultIteratorException(exception)__					close()__				}_			}_		}__		_		_		this.channelsToDeleteAtShutdown = new HashSet<Channel.ID>(64)__		this.openChannels = new HashSet<BlockChannelAccess<?,?>>(64)___		_		this.readThread = getReadingThread(exceptionHandler, input, circularQueues, parentTask,_			serializer, ((long) (startSpillingFraction * sortMemory)))___		_		this.sortThread = getSortingThread(exceptionHandler, circularQueues, parentTask)___		_		this.spillThread = getSpillingThread(exceptionHandler, circularQueues, parentTask, _				memoryManager, ioManager, serializerFactory, comparator, this.sortReadMemory, this.writeMemory, _				maxNumFileHandles)__		_		startThreads()__	};internal,constructor,and,constructor,for,subclasses,that,want,to,circumvent,the,spilling,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,param,no,spilling,memory,when,set,to,true,no,memory,will,be,allocated,for,writing,and,no,spilling,thread,will,be,spawned,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;protected,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,boolean,no,spilling,memory,throws,ioexception,memory,allocation,exception,if,memory,manager,null,io,manager,null,no,spilling,memory,serializer,factory,null,comparator,null,throw,new,null,pointer,exception,if,parent,task,null,throw,new,null,pointer,exception,parent,task,must,not,be,null,if,max,num,file,handles,2,throw,new,illegal,argument,exception,merger,cannot,work,with,less,than,two,file,handles,this,memory,manager,memory,manager,final,int,num,pages,total,memory,manager,compute,number,of,pages,memory,fraction,if,num,pages,total,throw,new,illegal,argument,exception,too,little,memory,provided,to,sorter,to,perform,task,required,are,at,least,pages,current,page,size,is,memory,manager,get,page,size,bytes,final,int,num,write,buffers,if,no,spilling,memory,num,write,buffers,0,else,final,int,min,buffers,max,num,file,handles,final,int,desired,buffers,2,max,num,file,handles,if,desired,buffers,num,pages,total,num,write,buffers,if,min,buffers,num,pages,total,max,num,file,handles,num,pages,total,if,log,is,debug,enabled,log,debug,reducing,maximal,merge,fan,in,to,max,num,file,handles,due,to,limited,memory,availability,during,merge,else,final,int,designated,write,buffers,num,pages,total,max,num,file,handles,1,final,int,fractional,num,pages,total,64,final,int,maximal,num,pages,total,num,write,buffers,math,max,math,min,math,min,maximal,math,min,designated,write,buffers,fractional,final,int,sort,mem,pages,num,pages,total,num,write,buffers,final,long,sort,memory,long,sort,mem,pages,memory,manager,get,page,size,if,num,sort,buffers,1,if,sort,memory,96,1024,1024,num,sort,buffers,3,else,if,sort,mem,pages,2,num,sort,buffers,2,else,num,sort,buffers,1,final,int,num,segments,per,sort,buffer,sort,mem,pages,num,sort,buffers,if,log,is,debug,enabled,log,debug,instantiating,sorter,with,sort,mem,pages,pages,of,sorting,memory,sort,memory,bytes,total,divided,over,num,sort,buffers,sort,buffers,num,segments,per,sort,buffer,pages,per,buffer,using,num,write,buffers,buffers,for,writing,sorted,results,and,merging,maximally,max,num,file,handles,streams,at,once,this,write,memory,new,array,list,memory,segment,num,write,buffers,this,sort,read,memory,new,array,list,memory,segment,sort,mem,pages,memory,manager,allocate,pages,parent,task,this,sort,read,memory,sort,mem,pages,if,num,write,buffers,0,memory,manager,allocate,pages,parent,task,this,write,memory,num,write,buffers,final,circular,queues,e,circular,queues,new,circular,queues,e,final,type,serializer,e,serializer,serializer,factory,get,serializer,final,iterator,memory,segment,segments,this,sort,read,memory,iterator,for,int,i,0,i,num,sort,buffers,i,final,list,memory,segment,sort,segments,new,array,list,memory,segment,num,segments,per,sort,buffer,for,int,k,i,num,sort,buffers,1,integer,num,segments,per,sort,buffer,k,0,segments,has,next,k,sort,segments,add,segments,next,final,type,comparator,e,comp,comparator,duplicate,final,in,memory,sorter,e,buffer,if,comp,supports,serialization,with,key,normalization,serializer,get,length,0,serializer,get,length,buffer,new,fixed,length,record,sorter,e,serializer,factory,get,serializer,comp,sort,segments,else,buffer,new,normalized,key,sorter,e,serializer,factory,get,serializer,comp,sort,segments,circular,element,e,element,new,circular,element,e,i,buffer,circular,queues,empty,add,element,exception,handler,ioexception,exception,handler,new,exception,handler,ioexception,public,void,handle,exception,ioexception,exception,if,closed,set,result,iterator,exception,exception,close,this,channels,to,delete,at,shutdown,new,hash,set,channel,id,64,this,open,channels,new,hash,set,block,channel,access,64,this,read,thread,get,reading,thread,exception,handler,input,circular,queues,parent,task,serializer,long,start,spilling,fraction,sort,memory,this,sort,thread,get,sorting,thread,exception,handler,circular,queues,parent,task,this,spill,thread,get,spilling,thread,exception,handler,circular,queues,parent,task,memory,manager,io,manager,serializer,factory,comparator,this,sort,read,memory,this,write,memory,max,num,file,handles,start,threads
UnilateralSortMerger -> protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction, boolean noSpillingMemory) 	throws IOException, MemoryAllocationException;1411236168;Internal constructor and constructor for subclasses that want to circumvent the spilling.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk._@param noSpillingMemory When set to true, no memory will be allocated for writing and no spilling thread_will be spawned.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction, boolean noSpillingMemory)_	throws IOException, MemoryAllocationException_	{_		_		if (memoryManager == null | (ioManager == null && !noSpillingMemory) | serializerFactory == null | comparator == null) {_			throw new NullPointerException()__		}_		if (parentTask == null) {_			throw new NullPointerException("Parent Task must not be null.")__		}_		if (maxNumFileHandles < 2) {_			throw new IllegalArgumentException("Merger cannot work with less than two file handles.")__		}_		_		this.memoryManager = memoryManager__		_		_		final int numPagesTotal = memoryManager.computeNumberOfPages(memoryFraction)___		if (numPagesTotal < MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) {_			throw new IllegalArgumentException("Too little memory provided to sorter to perform task. " +_				"Required are at least " + (MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) + _				" pages. Current page size is " + memoryManager.getPageSize() + " bytes.")__		}_		_		_		final int numWriteBuffers__		if (noSpillingMemory) {_			numWriteBuffers = 0__		} else {_			_			final int minBuffers = MIN_NUM_WRITE_BUFFERS + maxNumFileHandles__			final int desiredBuffers = MIN_NUM_WRITE_BUFFERS + 2 * maxNumFileHandles__			_			if (desiredBuffers > numPagesTotal) {_				numWriteBuffers = MIN_NUM_WRITE_BUFFERS__				if (minBuffers > numPagesTotal) {_					maxNumFileHandles = numPagesTotal - MIN_NUM_WRITE_BUFFERS__					if (LOG.isDebugEnabled()) {_						LOG.debug("Reducing maximal merge fan-in to " + maxNumFileHandles + " due to limited memory availability during merge")__					}_				}_			}_			else {_				_				final int designatedWriteBuffers = numPagesTotal / (maxNumFileHandles + 1)__				final int fractional = numPagesTotal / 64__				final int maximal = numPagesTotal - MIN_NUM_SORT_MEM_SEGMENTS__				_				numWriteBuffers = Math.max(MIN_NUM_WRITE_BUFFERS,	_					Math.min(Math.min(MAX_NUM_WRITE_BUFFERS, maximal), 		_					Math.min(designatedWriteBuffers, fractional)))_			_			}_		}_		_		final int sortMemPages = numPagesTotal - numWriteBuffers__		final long sortMemory = ((long) sortMemPages) * memoryManager.getPageSize()__		_		_		if (numSortBuffers < 1) {_			if (sortMemory > 96 * 1024 * 1024) {_				numSortBuffers = 3__			}_			else if (sortMemPages >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {_				numSortBuffers = 2__			}_			else {_				numSortBuffers = 1__			}_		}_		final int numSegmentsPerSortBuffer = sortMemPages / numSortBuffers__		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Instantiating sorter with " + sortMemPages + " pages of sorting memory (=" +_				sortMemory + " bytes total) divided over " + numSortBuffers + " sort buffers (" + _				numSegmentsPerSortBuffer + " pages per buffer). Using " + numWriteBuffers + _				" buffers for writing sorted results and merging maximally " + maxNumFileHandles +_				" streams at once.")__		}_		_		this.writeMemory = new ArrayList<MemorySegment>(numWriteBuffers)__		this.sortReadMemory = new ArrayList<MemorySegment>(sortMemPages)__		_		_		memoryManager.allocatePages(parentTask, this.sortReadMemory, sortMemPages)__		if (numWriteBuffers > 0) {_			memoryManager.allocatePages(parentTask, this.writeMemory, numWriteBuffers)__		}_		_		_		final CircularQueues<E> circularQueues = new CircularQueues<E>()__		_		final TypeSerializer<E> serializer = serializerFactory.getSerializer()__		_		_		final Iterator<MemorySegment> segments = this.sortReadMemory.iterator()__		for (int i = 0_ i < numSortBuffers_ i++)_		{_			_			final List<MemorySegment> sortSegments = new ArrayList<MemorySegment>(numSegmentsPerSortBuffer)__			for (int k = (i == numSortBuffers - 1 ? Integer.MAX_VALUE : numSegmentsPerSortBuffer)_ k > 0 && segments.hasNext()_ k--) {_				sortSegments.add(segments.next())__			}_			_			final TypeComparator<E> comp = comparator.duplicate()__			final InMemorySorter<E> buffer__			_			_			if (comp.supportsSerializationWithKeyNormalization() &&_					serializer.getLength() > 0 && serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING)_			{_				buffer = new FixedLengthRecordSorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			} else {_				buffer = new NormalizedKeySorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			}__			_			CircularElement<E> element = new CircularElement<E>(i, buffer)__			circularQueues.empty.add(element)__		}__		_		ExceptionHandler<IOException> exceptionHandler = new ExceptionHandler<IOException>() {_			public void handleException(IOException exception) {_				_				if (!closed) {_					setResultIteratorException(exception)__					close()__				}_			}_		}__		_		_		this.channelsToDeleteAtShutdown = new HashSet<Channel.ID>(64)__		this.openChannels = new HashSet<BlockChannelAccess<?,?>>(64)___		_		this.readThread = getReadingThread(exceptionHandler, input, circularQueues, parentTask,_			serializer, ((long) (startSpillingFraction * sortMemory)))___		_		this.sortThread = getSortingThread(exceptionHandler, circularQueues, parentTask)___		_		this.spillThread = getSpillingThread(exceptionHandler, circularQueues, parentTask, _				memoryManager, ioManager, serializerFactory, comparator, this.sortReadMemory, this.writeMemory, _				maxNumFileHandles)__		_		startThreads()__	};internal,constructor,and,constructor,for,subclasses,that,want,to,circumvent,the,spilling,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,param,no,spilling,memory,when,set,to,true,no,memory,will,be,allocated,for,writing,and,no,spilling,thread,will,be,spawned,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;protected,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,boolean,no,spilling,memory,throws,ioexception,memory,allocation,exception,if,memory,manager,null,io,manager,null,no,spilling,memory,serializer,factory,null,comparator,null,throw,new,null,pointer,exception,if,parent,task,null,throw,new,null,pointer,exception,parent,task,must,not,be,null,if,max,num,file,handles,2,throw,new,illegal,argument,exception,merger,cannot,work,with,less,than,two,file,handles,this,memory,manager,memory,manager,final,int,num,pages,total,memory,manager,compute,number,of,pages,memory,fraction,if,num,pages,total,throw,new,illegal,argument,exception,too,little,memory,provided,to,sorter,to,perform,task,required,are,at,least,pages,current,page,size,is,memory,manager,get,page,size,bytes,final,int,num,write,buffers,if,no,spilling,memory,num,write,buffers,0,else,final,int,min,buffers,max,num,file,handles,final,int,desired,buffers,2,max,num,file,handles,if,desired,buffers,num,pages,total,num,write,buffers,if,min,buffers,num,pages,total,max,num,file,handles,num,pages,total,if,log,is,debug,enabled,log,debug,reducing,maximal,merge,fan,in,to,max,num,file,handles,due,to,limited,memory,availability,during,merge,else,final,int,designated,write,buffers,num,pages,total,max,num,file,handles,1,final,int,fractional,num,pages,total,64,final,int,maximal,num,pages,total,num,write,buffers,math,max,math,min,math,min,maximal,math,min,designated,write,buffers,fractional,final,int,sort,mem,pages,num,pages,total,num,write,buffers,final,long,sort,memory,long,sort,mem,pages,memory,manager,get,page,size,if,num,sort,buffers,1,if,sort,memory,96,1024,1024,num,sort,buffers,3,else,if,sort,mem,pages,2,num,sort,buffers,2,else,num,sort,buffers,1,final,int,num,segments,per,sort,buffer,sort,mem,pages,num,sort,buffers,if,log,is,debug,enabled,log,debug,instantiating,sorter,with,sort,mem,pages,pages,of,sorting,memory,sort,memory,bytes,total,divided,over,num,sort,buffers,sort,buffers,num,segments,per,sort,buffer,pages,per,buffer,using,num,write,buffers,buffers,for,writing,sorted,results,and,merging,maximally,max,num,file,handles,streams,at,once,this,write,memory,new,array,list,memory,segment,num,write,buffers,this,sort,read,memory,new,array,list,memory,segment,sort,mem,pages,memory,manager,allocate,pages,parent,task,this,sort,read,memory,sort,mem,pages,if,num,write,buffers,0,memory,manager,allocate,pages,parent,task,this,write,memory,num,write,buffers,final,circular,queues,e,circular,queues,new,circular,queues,e,final,type,serializer,e,serializer,serializer,factory,get,serializer,final,iterator,memory,segment,segments,this,sort,read,memory,iterator,for,int,i,0,i,num,sort,buffers,i,final,list,memory,segment,sort,segments,new,array,list,memory,segment,num,segments,per,sort,buffer,for,int,k,i,num,sort,buffers,1,integer,num,segments,per,sort,buffer,k,0,segments,has,next,k,sort,segments,add,segments,next,final,type,comparator,e,comp,comparator,duplicate,final,in,memory,sorter,e,buffer,if,comp,supports,serialization,with,key,normalization,serializer,get,length,0,serializer,get,length,buffer,new,fixed,length,record,sorter,e,serializer,factory,get,serializer,comp,sort,segments,else,buffer,new,normalized,key,sorter,e,serializer,factory,get,serializer,comp,sort,segments,circular,element,e,element,new,circular,element,e,i,buffer,circular,queues,empty,add,element,exception,handler,ioexception,exception,handler,new,exception,handler,ioexception,public,void,handle,exception,ioexception,exception,if,closed,set,result,iterator,exception,exception,close,this,channels,to,delete,at,shutdown,new,hash,set,channel,id,64,this,open,channels,new,hash,set,block,channel,access,64,this,read,thread,get,reading,thread,exception,handler,input,circular,queues,parent,task,serializer,long,start,spilling,fraction,sort,memory,this,sort,thread,get,sorting,thread,exception,handler,circular,queues,parent,task,this,spill,thread,get,spilling,thread,exception,handler,circular,queues,parent,task,memory,manager,io,manager,serializer,factory,comparator,this,sort,read,memory,this,write,memory,max,num,file,handles,start,threads
UnilateralSortMerger -> protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction, boolean noSpillingMemory) 	throws IOException, MemoryAllocationException;1411236169;Internal constructor and constructor for subclasses that want to circumvent the spilling.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk._@param noSpillingMemory When set to true, no memory will be allocated for writing and no spilling thread_will be spawned.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction, boolean noSpillingMemory)_	throws IOException, MemoryAllocationException_	{_		_		if (memoryManager == null | (ioManager == null && !noSpillingMemory) | serializerFactory == null | comparator == null) {_			throw new NullPointerException()__		}_		if (parentTask == null) {_			throw new NullPointerException("Parent Task must not be null.")__		}_		if (maxNumFileHandles < 2) {_			throw new IllegalArgumentException("Merger cannot work with less than two file handles.")__		}_		_		this.memoryManager = memoryManager__		_		_		final int numPagesTotal = memoryManager.computeNumberOfPages(memoryFraction)___		if (numPagesTotal < MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) {_			throw new IllegalArgumentException("Too little memory provided to sorter to perform task. " +_				"Required are at least " + (MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) + _				" pages. Current page size is " + memoryManager.getPageSize() + " bytes.")__		}_		_		_		final int numWriteBuffers__		if (noSpillingMemory) {_			numWriteBuffers = 0__		} else {_			_			final int minBuffers = MIN_NUM_WRITE_BUFFERS + maxNumFileHandles__			final int desiredBuffers = MIN_NUM_WRITE_BUFFERS + 2 * maxNumFileHandles__			_			if (desiredBuffers > numPagesTotal) {_				numWriteBuffers = MIN_NUM_WRITE_BUFFERS__				if (minBuffers > numPagesTotal) {_					maxNumFileHandles = numPagesTotal - MIN_NUM_WRITE_BUFFERS__					if (LOG.isDebugEnabled()) {_						LOG.debug("Reducing maximal merge fan-in to " + maxNumFileHandles + " due to limited memory availability during merge")__					}_				}_			}_			else {_				_				final int designatedWriteBuffers = numPagesTotal / (maxNumFileHandles + 1)__				final int fractional = numPagesTotal / 64__				final int maximal = numPagesTotal - MIN_NUM_SORT_MEM_SEGMENTS__				_				numWriteBuffers = Math.max(MIN_NUM_WRITE_BUFFERS,	_					Math.min(Math.min(MAX_NUM_WRITE_BUFFERS, maximal), 		_					Math.min(designatedWriteBuffers, fractional)))_			_			}_		}_		_		final int sortMemPages = numPagesTotal - numWriteBuffers__		final long sortMemory = ((long) sortMemPages) * memoryManager.getPageSize()__		_		_		if (numSortBuffers < 1) {_			if (sortMemory > 96 * 1024 * 1024) {_				numSortBuffers = 3__			}_			else if (sortMemPages >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {_				numSortBuffers = 2__			}_			else {_				numSortBuffers = 1__			}_		}_		final int numSegmentsPerSortBuffer = sortMemPages / numSortBuffers__		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Instantiating sorter with " + sortMemPages + " pages of sorting memory (=" +_				sortMemory + " bytes total) divided over " + numSortBuffers + " sort buffers (" + _				numSegmentsPerSortBuffer + " pages per buffer). Using " + numWriteBuffers + _				" buffers for writing sorted results and merging maximally " + maxNumFileHandles +_				" streams at once.")__		}_		_		this.writeMemory = new ArrayList<MemorySegment>(numWriteBuffers)__		this.sortReadMemory = new ArrayList<MemorySegment>(sortMemPages)__		_		_		memoryManager.allocatePages(parentTask, this.sortReadMemory, sortMemPages)__		if (numWriteBuffers > 0) {_			memoryManager.allocatePages(parentTask, this.writeMemory, numWriteBuffers)__		}_		_		_		final CircularQueues<E> circularQueues = new CircularQueues<E>()__		_		final TypeSerializer<E> serializer = serializerFactory.getSerializer()__		_		_		final Iterator<MemorySegment> segments = this.sortReadMemory.iterator()__		for (int i = 0_ i < numSortBuffers_ i++)_		{_			_			final List<MemorySegment> sortSegments = new ArrayList<MemorySegment>(numSegmentsPerSortBuffer)__			for (int k = (i == numSortBuffers - 1 ? Integer.MAX_VALUE : numSegmentsPerSortBuffer)_ k > 0 && segments.hasNext()_ k--) {_				sortSegments.add(segments.next())__			}_			_			final TypeComparator<E> comp = comparator.duplicate()__			final InMemorySorter<E> buffer__			_			_			if (comp.supportsSerializationWithKeyNormalization() &&_					serializer.getLength() > 0 && serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING)_			{_				buffer = new FixedLengthRecordSorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			} else {_				buffer = new NormalizedKeySorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			}__			_			CircularElement<E> element = new CircularElement<E>(i, buffer)__			circularQueues.empty.add(element)__		}__		_		ExceptionHandler<IOException> exceptionHandler = new ExceptionHandler<IOException>() {_			public void handleException(IOException exception) {_				_				if (!closed) {_					setResultIteratorException(exception)__					close()__				}_			}_		}__		_		_		this.channelsToDeleteAtShutdown = new HashSet<Channel.ID>(64)__		this.openChannels = new HashSet<BlockChannelAccess<?,?>>(64)___		_		this.readThread = getReadingThread(exceptionHandler, input, circularQueues, parentTask,_			serializer, ((long) (startSpillingFraction * sortMemory)))___		_		this.sortThread = getSortingThread(exceptionHandler, circularQueues, parentTask)___		_		this.spillThread = getSpillingThread(exceptionHandler, circularQueues, parentTask, _				memoryManager, ioManager, serializerFactory, comparator, this.sortReadMemory, this.writeMemory, _				maxNumFileHandles)__		_		startThreads()__	};internal,constructor,and,constructor,for,subclasses,that,want,to,circumvent,the,spilling,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,param,no,spilling,memory,when,set,to,true,no,memory,will,be,allocated,for,writing,and,no,spilling,thread,will,be,spawned,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;protected,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,boolean,no,spilling,memory,throws,ioexception,memory,allocation,exception,if,memory,manager,null,io,manager,null,no,spilling,memory,serializer,factory,null,comparator,null,throw,new,null,pointer,exception,if,parent,task,null,throw,new,null,pointer,exception,parent,task,must,not,be,null,if,max,num,file,handles,2,throw,new,illegal,argument,exception,merger,cannot,work,with,less,than,two,file,handles,this,memory,manager,memory,manager,final,int,num,pages,total,memory,manager,compute,number,of,pages,memory,fraction,if,num,pages,total,throw,new,illegal,argument,exception,too,little,memory,provided,to,sorter,to,perform,task,required,are,at,least,pages,current,page,size,is,memory,manager,get,page,size,bytes,final,int,num,write,buffers,if,no,spilling,memory,num,write,buffers,0,else,final,int,min,buffers,max,num,file,handles,final,int,desired,buffers,2,max,num,file,handles,if,desired,buffers,num,pages,total,num,write,buffers,if,min,buffers,num,pages,total,max,num,file,handles,num,pages,total,if,log,is,debug,enabled,log,debug,reducing,maximal,merge,fan,in,to,max,num,file,handles,due,to,limited,memory,availability,during,merge,else,final,int,designated,write,buffers,num,pages,total,max,num,file,handles,1,final,int,fractional,num,pages,total,64,final,int,maximal,num,pages,total,num,write,buffers,math,max,math,min,math,min,maximal,math,min,designated,write,buffers,fractional,final,int,sort,mem,pages,num,pages,total,num,write,buffers,final,long,sort,memory,long,sort,mem,pages,memory,manager,get,page,size,if,num,sort,buffers,1,if,sort,memory,96,1024,1024,num,sort,buffers,3,else,if,sort,mem,pages,2,num,sort,buffers,2,else,num,sort,buffers,1,final,int,num,segments,per,sort,buffer,sort,mem,pages,num,sort,buffers,if,log,is,debug,enabled,log,debug,instantiating,sorter,with,sort,mem,pages,pages,of,sorting,memory,sort,memory,bytes,total,divided,over,num,sort,buffers,sort,buffers,num,segments,per,sort,buffer,pages,per,buffer,using,num,write,buffers,buffers,for,writing,sorted,results,and,merging,maximally,max,num,file,handles,streams,at,once,this,write,memory,new,array,list,memory,segment,num,write,buffers,this,sort,read,memory,new,array,list,memory,segment,sort,mem,pages,memory,manager,allocate,pages,parent,task,this,sort,read,memory,sort,mem,pages,if,num,write,buffers,0,memory,manager,allocate,pages,parent,task,this,write,memory,num,write,buffers,final,circular,queues,e,circular,queues,new,circular,queues,e,final,type,serializer,e,serializer,serializer,factory,get,serializer,final,iterator,memory,segment,segments,this,sort,read,memory,iterator,for,int,i,0,i,num,sort,buffers,i,final,list,memory,segment,sort,segments,new,array,list,memory,segment,num,segments,per,sort,buffer,for,int,k,i,num,sort,buffers,1,integer,num,segments,per,sort,buffer,k,0,segments,has,next,k,sort,segments,add,segments,next,final,type,comparator,e,comp,comparator,duplicate,final,in,memory,sorter,e,buffer,if,comp,supports,serialization,with,key,normalization,serializer,get,length,0,serializer,get,length,buffer,new,fixed,length,record,sorter,e,serializer,factory,get,serializer,comp,sort,segments,else,buffer,new,normalized,key,sorter,e,serializer,factory,get,serializer,comp,sort,segments,circular,element,e,element,new,circular,element,e,i,buffer,circular,queues,empty,add,element,exception,handler,ioexception,exception,handler,new,exception,handler,ioexception,public,void,handle,exception,ioexception,exception,if,closed,set,result,iterator,exception,exception,close,this,channels,to,delete,at,shutdown,new,hash,set,channel,id,64,this,open,channels,new,hash,set,block,channel,access,64,this,read,thread,get,reading,thread,exception,handler,input,circular,queues,parent,task,serializer,long,start,spilling,fraction,sort,memory,this,sort,thread,get,sorting,thread,exception,handler,circular,queues,parent,task,this,spill,thread,get,spilling,thread,exception,handler,circular,queues,parent,task,memory,manager,io,manager,serializer,factory,comparator,this,sort,read,memory,this,write,memory,max,num,file,handles,start,threads
UnilateralSortMerger -> protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction, boolean noSpillingMemory) 	throws IOException, MemoryAllocationException;1411473593;Internal constructor and constructor for subclasses that want to circumvent the spilling.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk._@param noSpillingMemory When set to true, no memory will be allocated for writing and no spilling thread_will be spawned.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction, boolean noSpillingMemory)_	throws IOException, MemoryAllocationException_	{_		_		if (memoryManager == null | (ioManager == null && !noSpillingMemory) | serializerFactory == null | comparator == null) {_			throw new NullPointerException()__		}_		if (parentTask == null) {_			throw new NullPointerException("Parent Task must not be null.")__		}_		if (maxNumFileHandles < 2) {_			throw new IllegalArgumentException("Merger cannot work with less than two file handles.")__		}_		_		this.memoryManager = memoryManager__		_		_		final int numPagesTotal = memoryManager.computeNumberOfPages(memoryFraction)___		if (numPagesTotal < MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) {_			throw new IllegalArgumentException("Too little memory provided to sorter to perform task. " +_				"Required are at least " + (MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) + _				" pages. Current page size is " + memoryManager.getPageSize() + " bytes.")__		}_		_		_		final int numWriteBuffers__		if (noSpillingMemory) {_			numWriteBuffers = 0__		} else {_			_			final int minBuffers = MIN_NUM_WRITE_BUFFERS + maxNumFileHandles__			final int desiredBuffers = MIN_NUM_WRITE_BUFFERS + 2 * maxNumFileHandles__			_			if (desiredBuffers > numPagesTotal) {_				numWriteBuffers = MIN_NUM_WRITE_BUFFERS__				if (minBuffers > numPagesTotal) {_					maxNumFileHandles = numPagesTotal - MIN_NUM_WRITE_BUFFERS__					if (LOG.isDebugEnabled()) {_						LOG.debug("Reducing maximal merge fan-in to " + maxNumFileHandles + " due to limited memory availability during merge")__					}_				}_			}_			else {_				_				final int designatedWriteBuffers = numPagesTotal / (maxNumFileHandles + 1)__				final int fractional = numPagesTotal / 64__				final int maximal = numPagesTotal - MIN_NUM_SORT_MEM_SEGMENTS__				_				numWriteBuffers = Math.max(MIN_NUM_WRITE_BUFFERS,	_					Math.min(Math.min(MAX_NUM_WRITE_BUFFERS, maximal), 		_					Math.min(designatedWriteBuffers, fractional)))_			_			}_		}_		_		final int sortMemPages = numPagesTotal - numWriteBuffers__		final long sortMemory = ((long) sortMemPages) * memoryManager.getPageSize()__		_		_		if (numSortBuffers < 1) {_			if (sortMemory > 96 * 1024 * 1024) {_				numSortBuffers = 3__			}_			else if (sortMemPages >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {_				numSortBuffers = 2__			}_			else {_				numSortBuffers = 1__			}_		}_		final int numSegmentsPerSortBuffer = sortMemPages / numSortBuffers__		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Instantiating sorter with " + sortMemPages + " pages of sorting memory (=" +_				sortMemory + " bytes total) divided over " + numSortBuffers + " sort buffers (" + _				numSegmentsPerSortBuffer + " pages per buffer). Using " + numWriteBuffers + _				" buffers for writing sorted results and merging maximally " + maxNumFileHandles +_				" streams at once.")__		}_		_		this.writeMemory = new ArrayList<MemorySegment>(numWriteBuffers)__		this.sortReadMemory = new ArrayList<MemorySegment>(sortMemPages)__		_		_		memoryManager.allocatePages(parentTask, this.sortReadMemory, sortMemPages)__		if (numWriteBuffers > 0) {_			memoryManager.allocatePages(parentTask, this.writeMemory, numWriteBuffers)__		}_		_		_		final CircularQueues<E> circularQueues = new CircularQueues<E>()__		_		final TypeSerializer<E> serializer = serializerFactory.getSerializer()__		_		_		final Iterator<MemorySegment> segments = this.sortReadMemory.iterator()__		for (int i = 0_ i < numSortBuffers_ i++)_		{_			_			final List<MemorySegment> sortSegments = new ArrayList<MemorySegment>(numSegmentsPerSortBuffer)__			for (int k = (i == numSortBuffers - 1 ? Integer.MAX_VALUE : numSegmentsPerSortBuffer)_ k > 0 && segments.hasNext()_ k--) {_				sortSegments.add(segments.next())__			}_			_			final TypeComparator<E> comp = comparator.duplicate()__			final InMemorySorter<E> buffer__			_			_			if (comp.supportsSerializationWithKeyNormalization() &&_					serializer.getLength() > 0 && serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING)_			{_				buffer = new FixedLengthRecordSorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			} else {_				buffer = new NormalizedKeySorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			}__			_			CircularElement<E> element = new CircularElement<E>(i, buffer)__			circularQueues.empty.add(element)__		}__		_		ExceptionHandler<IOException> exceptionHandler = new ExceptionHandler<IOException>() {_			public void handleException(IOException exception) {_				_				if (!closed) {_					setResultIteratorException(exception)__					close()__				}_			}_		}__		_		_		this.channelsToDeleteAtShutdown = new HashSet<Channel.ID>(64)__		this.openChannels = new HashSet<BlockChannelAccess<?,?>>(64)___		_		this.readThread = getReadingThread(exceptionHandler, input, circularQueues, parentTask,_			serializer, ((long) (startSpillingFraction * sortMemory)))___		_		this.sortThread = getSortingThread(exceptionHandler, circularQueues, parentTask)___		_		this.spillThread = getSpillingThread(exceptionHandler, circularQueues, parentTask, _				memoryManager, ioManager, serializerFactory, comparator, this.sortReadMemory, this.writeMemory, _				maxNumFileHandles)__		_		startThreads()__	};internal,constructor,and,constructor,for,subclasses,that,want,to,circumvent,the,spilling,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,param,no,spilling,memory,when,set,to,true,no,memory,will,be,allocated,for,writing,and,no,spilling,thread,will,be,spawned,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;protected,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,boolean,no,spilling,memory,throws,ioexception,memory,allocation,exception,if,memory,manager,null,io,manager,null,no,spilling,memory,serializer,factory,null,comparator,null,throw,new,null,pointer,exception,if,parent,task,null,throw,new,null,pointer,exception,parent,task,must,not,be,null,if,max,num,file,handles,2,throw,new,illegal,argument,exception,merger,cannot,work,with,less,than,two,file,handles,this,memory,manager,memory,manager,final,int,num,pages,total,memory,manager,compute,number,of,pages,memory,fraction,if,num,pages,total,throw,new,illegal,argument,exception,too,little,memory,provided,to,sorter,to,perform,task,required,are,at,least,pages,current,page,size,is,memory,manager,get,page,size,bytes,final,int,num,write,buffers,if,no,spilling,memory,num,write,buffers,0,else,final,int,min,buffers,max,num,file,handles,final,int,desired,buffers,2,max,num,file,handles,if,desired,buffers,num,pages,total,num,write,buffers,if,min,buffers,num,pages,total,max,num,file,handles,num,pages,total,if,log,is,debug,enabled,log,debug,reducing,maximal,merge,fan,in,to,max,num,file,handles,due,to,limited,memory,availability,during,merge,else,final,int,designated,write,buffers,num,pages,total,max,num,file,handles,1,final,int,fractional,num,pages,total,64,final,int,maximal,num,pages,total,num,write,buffers,math,max,math,min,math,min,maximal,math,min,designated,write,buffers,fractional,final,int,sort,mem,pages,num,pages,total,num,write,buffers,final,long,sort,memory,long,sort,mem,pages,memory,manager,get,page,size,if,num,sort,buffers,1,if,sort,memory,96,1024,1024,num,sort,buffers,3,else,if,sort,mem,pages,2,num,sort,buffers,2,else,num,sort,buffers,1,final,int,num,segments,per,sort,buffer,sort,mem,pages,num,sort,buffers,if,log,is,debug,enabled,log,debug,instantiating,sorter,with,sort,mem,pages,pages,of,sorting,memory,sort,memory,bytes,total,divided,over,num,sort,buffers,sort,buffers,num,segments,per,sort,buffer,pages,per,buffer,using,num,write,buffers,buffers,for,writing,sorted,results,and,merging,maximally,max,num,file,handles,streams,at,once,this,write,memory,new,array,list,memory,segment,num,write,buffers,this,sort,read,memory,new,array,list,memory,segment,sort,mem,pages,memory,manager,allocate,pages,parent,task,this,sort,read,memory,sort,mem,pages,if,num,write,buffers,0,memory,manager,allocate,pages,parent,task,this,write,memory,num,write,buffers,final,circular,queues,e,circular,queues,new,circular,queues,e,final,type,serializer,e,serializer,serializer,factory,get,serializer,final,iterator,memory,segment,segments,this,sort,read,memory,iterator,for,int,i,0,i,num,sort,buffers,i,final,list,memory,segment,sort,segments,new,array,list,memory,segment,num,segments,per,sort,buffer,for,int,k,i,num,sort,buffers,1,integer,num,segments,per,sort,buffer,k,0,segments,has,next,k,sort,segments,add,segments,next,final,type,comparator,e,comp,comparator,duplicate,final,in,memory,sorter,e,buffer,if,comp,supports,serialization,with,key,normalization,serializer,get,length,0,serializer,get,length,buffer,new,fixed,length,record,sorter,e,serializer,factory,get,serializer,comp,sort,segments,else,buffer,new,normalized,key,sorter,e,serializer,factory,get,serializer,comp,sort,segments,circular,element,e,element,new,circular,element,e,i,buffer,circular,queues,empty,add,element,exception,handler,ioexception,exception,handler,new,exception,handler,ioexception,public,void,handle,exception,ioexception,exception,if,closed,set,result,iterator,exception,exception,close,this,channels,to,delete,at,shutdown,new,hash,set,channel,id,64,this,open,channels,new,hash,set,block,channel,access,64,this,read,thread,get,reading,thread,exception,handler,input,circular,queues,parent,task,serializer,long,start,spilling,fraction,sort,memory,this,sort,thread,get,sorting,thread,exception,handler,circular,queues,parent,task,this,spill,thread,get,spilling,thread,exception,handler,circular,queues,parent,task,memory,manager,io,manager,serializer,factory,comparator,this,sort,read,memory,this,write,memory,max,num,file,handles,start,threads
UnilateralSortMerger -> protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction, boolean noSpillingMemory) 	throws IOException, MemoryAllocationException;1415702894;Internal constructor and constructor for subclasses that want to circumvent the spilling.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk._@param noSpillingMemory When set to true, no memory will be allocated for writing and no spilling thread_will be spawned.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction, boolean noSpillingMemory)_	throws IOException, MemoryAllocationException_	{_		_		if (memoryManager == null | (ioManager == null && !noSpillingMemory) | serializerFactory == null | comparator == null) {_			throw new NullPointerException()__		}_		if (parentTask == null) {_			throw new NullPointerException("Parent Task must not be null.")__		}_		if (maxNumFileHandles < 2) {_			throw new IllegalArgumentException("Merger cannot work with less than two file handles.")__		}_		_		this.memoryManager = memoryManager__		_		_		final int numPagesTotal = memoryManager.computeNumberOfPages(memoryFraction)___		if (numPagesTotal < MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) {_			throw new IllegalArgumentException("Too little memory provided to sorter to perform task. " +_				"Required are at least " + (MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) + _				" pages. Current page size is " + memoryManager.getPageSize() + " bytes.")__		}_		_		_		final int numWriteBuffers__		if (noSpillingMemory) {_			numWriteBuffers = 0__		} else {_			_			final int minBuffers = MIN_NUM_WRITE_BUFFERS + maxNumFileHandles__			final int desiredBuffers = MIN_NUM_WRITE_BUFFERS + 2 * maxNumFileHandles__			_			if (desiredBuffers > numPagesTotal) {_				numWriteBuffers = MIN_NUM_WRITE_BUFFERS__				if (minBuffers > numPagesTotal) {_					maxNumFileHandles = numPagesTotal - MIN_NUM_WRITE_BUFFERS__					if (LOG.isDebugEnabled()) {_						LOG.debug("Reducing maximal merge fan-in to " + maxNumFileHandles + " due to limited memory availability during merge")__					}_				}_			}_			else {_				_				final int designatedWriteBuffers = numPagesTotal / (maxNumFileHandles + 1)__				final int fractional = numPagesTotal / 64__				final int maximal = numPagesTotal - MIN_NUM_SORT_MEM_SEGMENTS__				_				numWriteBuffers = Math.max(MIN_NUM_WRITE_BUFFERS,	_					Math.min(Math.min(MAX_NUM_WRITE_BUFFERS, maximal), 		_					Math.min(designatedWriteBuffers, fractional)))_			_			}_		}_		_		final int sortMemPages = numPagesTotal - numWriteBuffers__		final long sortMemory = ((long) sortMemPages) * memoryManager.getPageSize()__		_		_		if (numSortBuffers < 1) {_			if (sortMemory > 96 * 1024 * 1024) {_				numSortBuffers = 3__			}_			else if (sortMemPages >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {_				numSortBuffers = 2__			}_			else {_				numSortBuffers = 1__			}_		}_		final int numSegmentsPerSortBuffer = sortMemPages / numSortBuffers__		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Instantiating sorter with " + sortMemPages + " pages of sorting memory (=" +_				sortMemory + " bytes total) divided over " + numSortBuffers + " sort buffers (" + _				numSegmentsPerSortBuffer + " pages per buffer). Using " + numWriteBuffers + _				" buffers for writing sorted results and merging maximally " + maxNumFileHandles +_				" streams at once.")__		}_		_		this.writeMemory = new ArrayList<MemorySegment>(numWriteBuffers)__		this.sortReadMemory = new ArrayList<MemorySegment>(sortMemPages)__		_		_		memoryManager.allocatePages(parentTask, this.sortReadMemory, sortMemPages)__		if (numWriteBuffers > 0) {_			memoryManager.allocatePages(parentTask, this.writeMemory, numWriteBuffers)__		}_		_		_		final CircularQueues<E> circularQueues = new CircularQueues<E>()__		_		final TypeSerializer<E> serializer = serializerFactory.getSerializer()__		_		_		final Iterator<MemorySegment> segments = this.sortReadMemory.iterator()__		for (int i = 0_ i < numSortBuffers_ i++)_		{_			_			final List<MemorySegment> sortSegments = new ArrayList<MemorySegment>(numSegmentsPerSortBuffer)__			for (int k = (i == numSortBuffers - 1 ? Integer.MAX_VALUE : numSegmentsPerSortBuffer)_ k > 0 && segments.hasNext()_ k--) {_				sortSegments.add(segments.next())__			}_			_			final TypeComparator<E> comp = comparator.duplicate()__			final InMemorySorter<E> buffer__			_			_			if (comp.supportsSerializationWithKeyNormalization() &&_					serializer.getLength() > 0 && serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING)_			{_				buffer = new FixedLengthRecordSorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			} else {_				buffer = new NormalizedKeySorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			}__			_			CircularElement<E> element = new CircularElement<E>(i, buffer)__			circularQueues.empty.add(element)__		}__		_		ExceptionHandler<IOException> exceptionHandler = new ExceptionHandler<IOException>() {_			public void handleException(IOException exception) {_				_				if (!closed) {_					setResultIteratorException(exception)__					close()__				}_			}_		}__		_		_		this.channelsToDeleteAtShutdown = new HashSet<FileIOChannel.ID>(64)__		this.openChannels = new HashSet<FileIOChannel>(64)___		_		this.readThread = getReadingThread(exceptionHandler, input, circularQueues, parentTask,_			serializer, ((long) (startSpillingFraction * sortMemory)))___		_		this.sortThread = getSortingThread(exceptionHandler, circularQueues, parentTask)___		_		this.spillThread = getSpillingThread(exceptionHandler, circularQueues, parentTask, _				memoryManager, ioManager, serializerFactory, comparator, this.sortReadMemory, this.writeMemory, _				maxNumFileHandles)__		_		startThreads()__	};internal,constructor,and,constructor,for,subclasses,that,want,to,circumvent,the,spilling,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,param,no,spilling,memory,when,set,to,true,no,memory,will,be,allocated,for,writing,and,no,spilling,thread,will,be,spawned,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;protected,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,boolean,no,spilling,memory,throws,ioexception,memory,allocation,exception,if,memory,manager,null,io,manager,null,no,spilling,memory,serializer,factory,null,comparator,null,throw,new,null,pointer,exception,if,parent,task,null,throw,new,null,pointer,exception,parent,task,must,not,be,null,if,max,num,file,handles,2,throw,new,illegal,argument,exception,merger,cannot,work,with,less,than,two,file,handles,this,memory,manager,memory,manager,final,int,num,pages,total,memory,manager,compute,number,of,pages,memory,fraction,if,num,pages,total,throw,new,illegal,argument,exception,too,little,memory,provided,to,sorter,to,perform,task,required,are,at,least,pages,current,page,size,is,memory,manager,get,page,size,bytes,final,int,num,write,buffers,if,no,spilling,memory,num,write,buffers,0,else,final,int,min,buffers,max,num,file,handles,final,int,desired,buffers,2,max,num,file,handles,if,desired,buffers,num,pages,total,num,write,buffers,if,min,buffers,num,pages,total,max,num,file,handles,num,pages,total,if,log,is,debug,enabled,log,debug,reducing,maximal,merge,fan,in,to,max,num,file,handles,due,to,limited,memory,availability,during,merge,else,final,int,designated,write,buffers,num,pages,total,max,num,file,handles,1,final,int,fractional,num,pages,total,64,final,int,maximal,num,pages,total,num,write,buffers,math,max,math,min,math,min,maximal,math,min,designated,write,buffers,fractional,final,int,sort,mem,pages,num,pages,total,num,write,buffers,final,long,sort,memory,long,sort,mem,pages,memory,manager,get,page,size,if,num,sort,buffers,1,if,sort,memory,96,1024,1024,num,sort,buffers,3,else,if,sort,mem,pages,2,num,sort,buffers,2,else,num,sort,buffers,1,final,int,num,segments,per,sort,buffer,sort,mem,pages,num,sort,buffers,if,log,is,debug,enabled,log,debug,instantiating,sorter,with,sort,mem,pages,pages,of,sorting,memory,sort,memory,bytes,total,divided,over,num,sort,buffers,sort,buffers,num,segments,per,sort,buffer,pages,per,buffer,using,num,write,buffers,buffers,for,writing,sorted,results,and,merging,maximally,max,num,file,handles,streams,at,once,this,write,memory,new,array,list,memory,segment,num,write,buffers,this,sort,read,memory,new,array,list,memory,segment,sort,mem,pages,memory,manager,allocate,pages,parent,task,this,sort,read,memory,sort,mem,pages,if,num,write,buffers,0,memory,manager,allocate,pages,parent,task,this,write,memory,num,write,buffers,final,circular,queues,e,circular,queues,new,circular,queues,e,final,type,serializer,e,serializer,serializer,factory,get,serializer,final,iterator,memory,segment,segments,this,sort,read,memory,iterator,for,int,i,0,i,num,sort,buffers,i,final,list,memory,segment,sort,segments,new,array,list,memory,segment,num,segments,per,sort,buffer,for,int,k,i,num,sort,buffers,1,integer,num,segments,per,sort,buffer,k,0,segments,has,next,k,sort,segments,add,segments,next,final,type,comparator,e,comp,comparator,duplicate,final,in,memory,sorter,e,buffer,if,comp,supports,serialization,with,key,normalization,serializer,get,length,0,serializer,get,length,buffer,new,fixed,length,record,sorter,e,serializer,factory,get,serializer,comp,sort,segments,else,buffer,new,normalized,key,sorter,e,serializer,factory,get,serializer,comp,sort,segments,circular,element,e,element,new,circular,element,e,i,buffer,circular,queues,empty,add,element,exception,handler,ioexception,exception,handler,new,exception,handler,ioexception,public,void,handle,exception,ioexception,exception,if,closed,set,result,iterator,exception,exception,close,this,channels,to,delete,at,shutdown,new,hash,set,file,iochannel,id,64,this,open,channels,new,hash,set,file,iochannel,64,this,read,thread,get,reading,thread,exception,handler,input,circular,queues,parent,task,serializer,long,start,spilling,fraction,sort,memory,this,sort,thread,get,sorting,thread,exception,handler,circular,queues,parent,task,this,spill,thread,get,spilling,thread,exception,handler,circular,queues,parent,task,memory,manager,io,manager,serializer,factory,comparator,this,sort,read,memory,this,write,memory,max,num,file,handles,start,threads
UnilateralSortMerger -> protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction, boolean noSpillingMemory) 	throws IOException, MemoryAllocationException;1420663430;Internal constructor and constructor for subclasses that want to circumvent the spilling.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk._@param noSpillingMemory When set to true, no memory will be allocated for writing and no spilling thread_will be spawned.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;protected UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction, boolean noSpillingMemory)_	throws IOException, MemoryAllocationException_	{_		_		if (memoryManager == null | (ioManager == null && !noSpillingMemory) | serializerFactory == null | comparator == null) {_			throw new NullPointerException()__		}_		if (parentTask == null) {_			throw new NullPointerException("Parent Task must not be null.")__		}_		if (maxNumFileHandles < 2) {_			throw new IllegalArgumentException("Merger cannot work with less than two file handles.")__		}_		_		this.memoryManager = memoryManager__		_		_		final int numPagesTotal = memoryManager.computeNumberOfPages(memoryFraction)___		if (numPagesTotal < MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) {_			throw new IllegalArgumentException("Too little memory provided to sorter to perform task. " +_				"Required are at least " + (MIN_NUM_WRITE_BUFFERS + MIN_NUM_SORT_MEM_SEGMENTS) + _				" pages. Current page size is " + memoryManager.getPageSize() + " bytes.")__		}_		_		_		final int numWriteBuffers__		if (noSpillingMemory) {_			numWriteBuffers = 0__		} else {_			_			final int minBuffers = MIN_NUM_WRITE_BUFFERS + maxNumFileHandles__			final int desiredBuffers = MIN_NUM_WRITE_BUFFERS + 2 * maxNumFileHandles__			_			if (desiredBuffers > numPagesTotal) {_				numWriteBuffers = MIN_NUM_WRITE_BUFFERS__				if (minBuffers > numPagesTotal) {_					maxNumFileHandles = numPagesTotal - MIN_NUM_WRITE_BUFFERS__					if (LOG.isDebugEnabled()) {_						LOG.debug("Reducing maximal merge fan-in to " + maxNumFileHandles + " due to limited memory availability during merge")__					}_				}_			}_			else {_				_				final int designatedWriteBuffers = numPagesTotal / (maxNumFileHandles + 1)__				final int fractional = numPagesTotal / 64__				final int maximal = numPagesTotal - MIN_NUM_SORT_MEM_SEGMENTS__				_				numWriteBuffers = Math.max(MIN_NUM_WRITE_BUFFERS,	_					Math.min(Math.min(MAX_NUM_WRITE_BUFFERS, maximal), 		_					Math.min(designatedWriteBuffers, fractional)))_			_			}_		}_		_		final int sortMemPages = numPagesTotal - numWriteBuffers__		final long sortMemory = ((long) sortMemPages) * memoryManager.getPageSize()__		_		_		if (numSortBuffers < 1) {_			if (sortMemory > 96 * 1024 * 1024) {_				numSortBuffers = 3__			}_			else if (sortMemPages >= 2 * MIN_NUM_SORT_MEM_SEGMENTS) {_				numSortBuffers = 2__			}_			else {_				numSortBuffers = 1__			}_		}_		final int numSegmentsPerSortBuffer = sortMemPages / numSortBuffers__		_		if (LOG.isDebugEnabled()) {_			LOG.debug("Instantiating sorter with " + sortMemPages + " pages of sorting memory (=" +_				sortMemory + " bytes total) divided over " + numSortBuffers + " sort buffers (" + _				numSegmentsPerSortBuffer + " pages per buffer). Using " + numWriteBuffers + _				" buffers for writing sorted results and merging maximally " + maxNumFileHandles +_				" streams at once.")__		}_		_		this.writeMemory = new ArrayList<MemorySegment>(numWriteBuffers)__		this.sortReadMemory = new ArrayList<MemorySegment>(sortMemPages)__		_		_		memoryManager.allocatePages(parentTask, this.sortReadMemory, sortMemPages)__		if (numWriteBuffers > 0) {_			memoryManager.allocatePages(parentTask, this.writeMemory, numWriteBuffers)__		}_		_		_		final CircularQueues<E> circularQueues = new CircularQueues<E>()__		_		final TypeSerializer<E> serializer = serializerFactory.getSerializer()__		_		_		final Iterator<MemorySegment> segments = this.sortReadMemory.iterator()__		for (int i = 0_ i < numSortBuffers_ i++)_		{_			_			final List<MemorySegment> sortSegments = new ArrayList<MemorySegment>(numSegmentsPerSortBuffer)__			for (int k = (i == numSortBuffers - 1 ? Integer.MAX_VALUE : numSegmentsPerSortBuffer)_ k > 0 && segments.hasNext()_ k--) {_				sortSegments.add(segments.next())__			}_			_			final TypeComparator<E> comp = comparator.duplicate()__			final InMemorySorter<E> buffer__			_			_			if (comp.supportsSerializationWithKeyNormalization() &&_					serializer.getLength() > 0 && serializer.getLength() <= THRESHOLD_FOR_IN_PLACE_SORTING)_			{_				buffer = new FixedLengthRecordSorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			} else {_				buffer = new NormalizedKeySorter<E>(serializerFactory.getSerializer(), comp, sortSegments)__			}__			_			CircularElement<E> element = new CircularElement<E>(i, buffer)__			circularQueues.empty.add(element)__		}__		_		ExceptionHandler<IOException> exceptionHandler = new ExceptionHandler<IOException>() {_			public void handleException(IOException exception) {_				_				if (!closed) {_					setResultIteratorException(exception)__					close()__				}_			}_		}__		_		_		this.channelsToDeleteAtShutdown = new HashSet<FileIOChannel.ID>(64)__		this.openChannels = new HashSet<FileIOChannel>(64)___		_		this.readThread = getReadingThread(exceptionHandler, input, circularQueues, parentTask,_			serializer, ((long) (startSpillingFraction * sortMemory)))___		_		this.sortThread = getSortingThread(exceptionHandler, circularQueues, parentTask)___		_		this.spillThread = getSpillingThread(exceptionHandler, circularQueues, parentTask, _				memoryManager, ioManager, serializerFactory, comparator, this.sortReadMemory, this.writeMemory, _				maxNumFileHandles)__		_		startThreads()__	};internal,constructor,and,constructor,for,subclasses,that,want,to,circumvent,the,spilling,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,param,no,spilling,memory,when,set,to,true,no,memory,will,be,allocated,for,writing,and,no,spilling,thread,will,be,spawned,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;protected,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,boolean,no,spilling,memory,throws,ioexception,memory,allocation,exception,if,memory,manager,null,io,manager,null,no,spilling,memory,serializer,factory,null,comparator,null,throw,new,null,pointer,exception,if,parent,task,null,throw,new,null,pointer,exception,parent,task,must,not,be,null,if,max,num,file,handles,2,throw,new,illegal,argument,exception,merger,cannot,work,with,less,than,two,file,handles,this,memory,manager,memory,manager,final,int,num,pages,total,memory,manager,compute,number,of,pages,memory,fraction,if,num,pages,total,throw,new,illegal,argument,exception,too,little,memory,provided,to,sorter,to,perform,task,required,are,at,least,pages,current,page,size,is,memory,manager,get,page,size,bytes,final,int,num,write,buffers,if,no,spilling,memory,num,write,buffers,0,else,final,int,min,buffers,max,num,file,handles,final,int,desired,buffers,2,max,num,file,handles,if,desired,buffers,num,pages,total,num,write,buffers,if,min,buffers,num,pages,total,max,num,file,handles,num,pages,total,if,log,is,debug,enabled,log,debug,reducing,maximal,merge,fan,in,to,max,num,file,handles,due,to,limited,memory,availability,during,merge,else,final,int,designated,write,buffers,num,pages,total,max,num,file,handles,1,final,int,fractional,num,pages,total,64,final,int,maximal,num,pages,total,num,write,buffers,math,max,math,min,math,min,maximal,math,min,designated,write,buffers,fractional,final,int,sort,mem,pages,num,pages,total,num,write,buffers,final,long,sort,memory,long,sort,mem,pages,memory,manager,get,page,size,if,num,sort,buffers,1,if,sort,memory,96,1024,1024,num,sort,buffers,3,else,if,sort,mem,pages,2,num,sort,buffers,2,else,num,sort,buffers,1,final,int,num,segments,per,sort,buffer,sort,mem,pages,num,sort,buffers,if,log,is,debug,enabled,log,debug,instantiating,sorter,with,sort,mem,pages,pages,of,sorting,memory,sort,memory,bytes,total,divided,over,num,sort,buffers,sort,buffers,num,segments,per,sort,buffer,pages,per,buffer,using,num,write,buffers,buffers,for,writing,sorted,results,and,merging,maximally,max,num,file,handles,streams,at,once,this,write,memory,new,array,list,memory,segment,num,write,buffers,this,sort,read,memory,new,array,list,memory,segment,sort,mem,pages,memory,manager,allocate,pages,parent,task,this,sort,read,memory,sort,mem,pages,if,num,write,buffers,0,memory,manager,allocate,pages,parent,task,this,write,memory,num,write,buffers,final,circular,queues,e,circular,queues,new,circular,queues,e,final,type,serializer,e,serializer,serializer,factory,get,serializer,final,iterator,memory,segment,segments,this,sort,read,memory,iterator,for,int,i,0,i,num,sort,buffers,i,final,list,memory,segment,sort,segments,new,array,list,memory,segment,num,segments,per,sort,buffer,for,int,k,i,num,sort,buffers,1,integer,num,segments,per,sort,buffer,k,0,segments,has,next,k,sort,segments,add,segments,next,final,type,comparator,e,comp,comparator,duplicate,final,in,memory,sorter,e,buffer,if,comp,supports,serialization,with,key,normalization,serializer,get,length,0,serializer,get,length,buffer,new,fixed,length,record,sorter,e,serializer,factory,get,serializer,comp,sort,segments,else,buffer,new,normalized,key,sorter,e,serializer,factory,get,serializer,comp,sort,segments,circular,element,e,element,new,circular,element,e,i,buffer,circular,queues,empty,add,element,exception,handler,ioexception,exception,handler,new,exception,handler,ioexception,public,void,handle,exception,ioexception,exception,if,closed,set,result,iterator,exception,exception,close,this,channels,to,delete,at,shutdown,new,hash,set,file,iochannel,id,64,this,open,channels,new,hash,set,file,iochannel,64,this,read,thread,get,reading,thread,exception,handler,input,circular,queues,parent,task,serializer,long,start,spilling,fraction,sort,memory,this,sort,thread,get,sorting,thread,exception,handler,circular,queues,parent,task,this,spill,thread,get,spilling,thread,exception,handler,circular,queues,parent,task,memory,manager,io,manager,serializer,factory,comparator,this,sort,read,memory,this,write,memory,max,num,file,handles,start,threads
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1405024514;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memoryManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.sortReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxNumFileHandles = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,memory,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,sort,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,num,file,handles,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1405090423;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memoryManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.sortReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxNumFileHandles = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,memory,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,sort,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,num,file,handles,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1409911022;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memoryManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.sortReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxNumFileHandles = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,memory,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,sort,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,num,file,handles,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1411236168;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memoryManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.sortReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxNumFileHandles = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,memory,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,sort,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,num,file,handles,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1411236169;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.sortReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxNumFileHandles = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,sort,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,num,file,handles,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1411473593;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.sortReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxNumFileHandles = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,sort,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,num,file,handles,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1415702894;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.sortReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxNumFileHandles = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,sort,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,num,file,handles,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1420663430;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.sortReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxNumFileHandles = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,sort,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,num,file,handles,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1421838095;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1421838095;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1421838096;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1421838096;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1423142112;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1426697080;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1441738685;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1442312401;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1442870284;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1443522094;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1466529056;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1530185676;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> SpillingThread -> public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager,  				TypeSerializer<E> serializer, TypeComparator<E> comparator,  				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles);1533306679;Creates the spilling thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread._@param memManager The memory manager used to allocate buffers for the readers and writers._@param ioManager The I/I manager used to instantiate readers and writers from._@param serializer_@param comparator_@param sortReadMemory_@param writeMemory_@param maxNumFileHandles;public SpillingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask, MemoryManager memManager, IOManager ioManager, _				TypeSerializer<E> serializer, TypeComparator<E> comparator, _				List<MemorySegment> sortReadMemory, List<MemorySegment> writeMemory, int maxNumFileHandles)_		{_			super(exceptionHandler, "SortMerger spilling thread", queues, parentTask)__			this.memManager = memManager__			this.ioManager = ioManager__			this.serializer = serializer__			this.comparator = comparator__			this.mergeReadMemory = sortReadMemory__			this.writeMemory = writeMemory__			this.maxFanIn = maxNumFileHandles__			this.numWriteBuffersToCluster = writeMemory.size() >= 4 ? writeMemory.size() / 2 : 1__		};creates,the,spilling,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread,param,mem,manager,the,memory,manager,used,to,allocate,buffers,for,the,readers,and,writers,param,io,manager,the,i,i,manager,used,to,instantiate,readers,and,writers,from,param,serializer,param,comparator,param,sort,read,memory,param,write,memory,param,max,num,file,handles;public,spilling,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,memory,manager,mem,manager,iomanager,io,manager,type,serializer,e,serializer,type,comparator,e,comparator,list,memory,segment,sort,read,memory,list,memory,segment,write,memory,int,max,num,file,handles,super,exception,handler,sort,merger,spilling,thread,queues,parent,task,this,mem,manager,mem,manager,this,io,manager,io,manager,this,serializer,serializer,this,comparator,comparator,this,merge,read,memory,sort,read,memory,this,write,memory,write,memory,this,max,fan,in,max,num,file,handles,this,num,write,buffers,to,cluster,write,memory,size,4,write,memory,size,2,1
UnilateralSortMerger -> ThreadBase -> public void run();1405024514;Implements exception handling and delegates to go().;public void run() {_			try {_				if (this.parentTask != null) {_					this.parentTask.userThreadStarted(this)__				}_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_			finally {_				if (this.parentTask != null) {_					this.parentTask.userThreadFinished(this)__				}_			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,if,this,parent,task,null,this,parent,task,user,thread,started,this,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t,finally,if,this,parent,task,null,this,parent,task,user,thread,finished,this
UnilateralSortMerger -> ThreadBase -> public void run();1405090423;Implements exception handling and delegates to go().;public void run() {_			try {_				if (this.parentTask != null) {_					this.parentTask.userThreadStarted(this)__				}_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_			finally {_				if (this.parentTask != null) {_					this.parentTask.userThreadFinished(this)__				}_			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,if,this,parent,task,null,this,parent,task,user,thread,started,this,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t,finally,if,this,parent,task,null,this,parent,task,user,thread,finished,this
UnilateralSortMerger -> ThreadBase -> public void run();1409911022;Implements exception handling and delegates to go().;public void run() {_			try {_				if (this.parentTask != null) {_					this.parentTask.userThreadStarted(this)__				}_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_			finally {_				if (this.parentTask != null) {_					this.parentTask.userThreadFinished(this)__				}_			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,if,this,parent,task,null,this,parent,task,user,thread,started,this,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t,finally,if,this,parent,task,null,this,parent,task,user,thread,finished,this
UnilateralSortMerger -> ThreadBase -> public void run();1411236168;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_			finally {_			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t,finally
UnilateralSortMerger -> ThreadBase -> public void run();1411236169;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_			finally {_			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t,finally
UnilateralSortMerger -> ThreadBase -> public void run();1411473593;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_			finally {_			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t,finally
UnilateralSortMerger -> ThreadBase -> public void run();1415702894;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_			finally {_			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t,finally
UnilateralSortMerger -> ThreadBase -> public void run();1420663430;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_			finally {_			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t,finally
UnilateralSortMerger -> ThreadBase -> public void run();1421838095;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_			finally {_			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t,finally
UnilateralSortMerger -> ThreadBase -> public void run();1421838095;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1421838096;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1421838096;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1423142112;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1426697080;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1441738685;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1442312401;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1442870284;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1443522094;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1466529056;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1530185676;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> ThreadBase -> public void run();1533306679;Implements exception handling and delegates to go().;public void run() {_			try {_				go()__			}_			catch (Throwable t) {_				internalHandleException(new IOException("Thread '" + getName() + "' terminated due to an exception: "_					+ t.getMessage(), t))__			}_		};implements,exception,handling,and,delegates,to,go;public,void,run,try,go,catch,throwable,t,internal,handle,exception,new,ioexception,thread,get,name,terminated,due,to,an,exception,t,get,message,t
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1405024514;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory)_		{_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1405090423;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory)_		{_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1409911022;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory)_		{_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1411236168;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory)_		{_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1411236169;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory)_		{_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1411473593;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory)_		{_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1415702894;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory)_		{_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1420663430;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory)_		{_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1421838095;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1421838095;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1421838096;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1421838096;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1423142112;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1426697080;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1441738685;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1442312401;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					final InMemorySorter<?> sorter = this.queues.empty.take().buffer__					final List<MemorySegment> sorterMem = sorter.dispose()__					if (releaseMemory) {_						this.memManager.release(sorterMem)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,final,in,memory,sorter,sorter,this,queues,empty,take,buffer,final,list,memory,segment,sorter,mem,sorter,dispose,if,release,memory,this,mem,manager,release,sorter,mem,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1442870284;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					CircularElement<E> element = this.queues.empty.take()__					element.buffer.dispose()__					if (releaseMemory) {_						this.memManager.release(element.memory)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,circular,element,e,element,this,queues,empty,take,element,buffer,dispose,if,release,memory,this,mem,manager,release,element,memory,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1443522094;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					CircularElement<E> element = this.queues.empty.take()__					element.buffer.dispose()__					if (releaseMemory) {_						this.memManager.release(element.memory)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,circular,element,e,element,this,queues,empty,take,element,buffer,dispose,if,release,memory,this,mem,manager,release,element,memory,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1466529056;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					CircularElement<E> element = this.queues.empty.take()__					element.buffer.dispose()__					if (releaseMemory) {_						this.memManager.release(element.memory)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,circular,element,e,element,this,queues,empty,take,element,buffer,dispose,if,release,memory,this,mem,manager,release,element,memory,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1530185676;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					CircularElement<E> element = this.queues.empty.take()__					element.buffer.dispose()__					if (releaseMemory) {_						this.memManager.release(element.memory)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,circular,element,e,element,this,queues,empty,take,element,buffer,dispose,if,release,memory,this,mem,manager,release,element,memory,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected final void disposeSortBuffers(boolean releaseMemory);1533306679;Releases the memory that is registered for in-memory sorted run generation.;protected final void disposeSortBuffers(boolean releaseMemory) {_			while (!this.queues.empty.isEmpty()) {_				try {_					CircularElement<E> element = this.queues.empty.take()__					element.buffer.dispose()__					if (releaseMemory) {_						this.memManager.release(element.memory)__					}_				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						LOG.error("Spilling thread was interrupted (without being shut down) while collecting empty buffers to release them. " +_								"Retrying to collect buffers...")__					}_					else {_						return__					}_				}_			}_		};releases,the,memory,that,is,registered,for,in,memory,sorted,run,generation;protected,final,void,dispose,sort,buffers,boolean,release,memory,while,this,queues,empty,is,empty,try,circular,element,e,element,this,queues,empty,take,element,buffer,dispose,if,release,memory,this,mem,manager,release,element,memory,catch,interrupted,exception,iex,if,is,running,log,error,spilling,thread,was,interrupted,without,being,shut,down,while,collecting,empty,buffers,to,release,them,retrying,to,collect,buffers,else,return
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1405024514;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<BlockChannelAccess<?, ?>> channelAccesses = new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses)___			_			final Channel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_															mergedChannelID, this.numWriteBuffersToCluster)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				BlockChannelAccess<?, ?> access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,block,channel,access,channel,accesses,new,array,list,block,channel,access,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,final,channel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,block,channel,access,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1405090423;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<BlockChannelAccess<?, ?>> channelAccesses = new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses)___			_			final Channel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_															mergedChannelID, this.numWriteBuffersToCluster)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				BlockChannelAccess<?, ?> access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,block,channel,access,channel,accesses,new,array,list,block,channel,access,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,final,channel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,block,channel,access,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1409911022;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<BlockChannelAccess<?, ?>> channelAccesses = new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses)___			_			final Channel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_															mergedChannelID, this.numWriteBuffersToCluster)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				BlockChannelAccess<?, ?> access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,block,channel,access,channel,accesses,new,array,list,block,channel,access,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,final,channel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,block,channel,access,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1411236168;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<BlockChannelAccess<?, ?>> channelAccesses = new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses)___			_			final Channel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_															mergedChannelID, this.numWriteBuffersToCluster)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				BlockChannelAccess<?, ?> access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,block,channel,access,channel,accesses,new,array,list,block,channel,access,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,final,channel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,block,channel,access,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1411236169;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<BlockChannelAccess<?, ?>> channelAccesses = new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses)___			_			final Channel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_															mergedChannelID, this.numWriteBuffersToCluster)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				BlockChannelAccess<?, ?> access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,block,channel,access,channel,accesses,new,array,list,block,channel,access,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,final,channel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,block,channel,access,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1411473593;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<BlockChannelAccess<?, ?>> channelAccesses = new ArrayList<BlockChannelAccess<?, ?>>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses)___			_			final Channel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(_															mergedChannelID, this.numWriteBuffersToCluster)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				BlockChannelAccess<?, ?> access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,block,channel,access,channel,accesses,new,array,list,block,channel,access,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,final,channel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,this,num,write,buffers,to,cluster,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,block,channel,access,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1415702894;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1420663430;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1421838095;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1421838095;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1421838096;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1421838096;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1423142112;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1426697080;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1441738685;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1442312401;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1442870284;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			final TypeSerializer<E> serializer = this.serializer__			E rec = serializer.createInstance()__			while ((rec = mergeIterator.next(rec)) != null) {_				serializer.serialize(rec, output)__			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1443522094;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			if (objectReuseEnabled) {_				final TypeSerializer<E> serializer = this.serializer__				E rec = serializer.createInstance()__				while ((rec = mergeIterator.next(rec)) != null) {_					serializer.serialize(rec, output)__				}_			} else {_				E rec__				while ((rec = mergeIterator.next()) != null) {_					serializer.serialize(rec, output)__				}_			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,if,object,reuse,enabled,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,else,e,rec,while,rec,merge,iterator,next,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1466529056;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			if (objectReuseEnabled) {_				final TypeSerializer<E> serializer = this.serializer__				E rec = serializer.createInstance()__				while ((rec = mergeIterator.next(rec)) != null) {_					serializer.serialize(rec, output)__				}_			} else {_				E rec__				while ((rec = mergeIterator.next()) != null) {_					serializer.serialize(rec, output)__				}_			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,if,object,reuse,enabled,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,else,e,rec,while,rec,merge,iterator,next,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1530185676;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			if (objectReuseEnabled) {_				final TypeSerializer<E> serializer = this.serializer__				E rec = serializer.createInstance()__				while ((rec = mergeIterator.next(rec)) != null) {_					serializer.serialize(rec, output)__				}_			} else {_				E rec__				while ((rec = mergeIterator.next()) != null) {_					serializer.serialize(rec, output)__				}_			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,if,object,reuse,enabled,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,else,e,rec,while,rec,merge,iterator,next,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> SpillingThread -> protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers, 				List<MemorySegment> writeBuffers) 		throws IOException;1533306679;Merges the sorted runs described by the given Channel IDs into a single sorted run. The merging process_uses the given read and write buffers.__@param channelIDs The IDs of the runs' channels._@param readBuffers The buffers for the readers that read the sorted runs._@param writeBuffers The buffers for the writer that writes the merged channel._@return The ID and number of blocks of the channel that describes the merged run.;protected ChannelWithBlockCount mergeChannels(List<ChannelWithBlockCount> channelIDs, List<List<MemorySegment>> readBuffers,_				List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			final List<FileIOChannel> channelAccesses = new ArrayList<FileIOChannel>(channelIDs.size())___			_			final MergeIterator<E> mergeIterator = getMergingIterator(channelIDs, readBuffers, channelAccesses, null)___			_			final FileIOChannel.ID mergedChannelID = this.ioManager.createChannel()__			registerChannelToBeRemovedAtShudown(mergedChannelID)__			final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(mergedChannelID)__			registerOpenChannelToBeRemovedAtShudown(writer)__			final ChannelWriterOutputView output = new ChannelWriterOutputView(writer, writeBuffers, _																			this.memManager.getPageSize())___			_			if (objectReuseEnabled) {_				final TypeSerializer<E> serializer = this.serializer__				E rec = serializer.createInstance()__				while ((rec = mergeIterator.next(rec)) != null) {_					serializer.serialize(rec, output)__				}_			} else {_				E rec__				while ((rec = mergeIterator.next()) != null) {_					serializer.serialize(rec, output)__				}_			}_			output.close()__			final int numBlocksWritten = output.getBlockCount()__			_			_			unregisterOpenChannelToBeRemovedAtShudown(writer)__			_			_			for (int i = 0_ i < channelAccesses.size()_ i++) {_				FileIOChannel access = channelAccesses.get(i)__				access.closeAndDelete()__				unregisterOpenChannelToBeRemovedAtShudown(access)__			}__			return new ChannelWithBlockCount(mergedChannelID, numBlocksWritten)__		};merges,the,sorted,runs,described,by,the,given,channel,ids,into,a,single,sorted,run,the,merging,process,uses,the,given,read,and,write,buffers,param,channel,ids,the,ids,of,the,runs,channels,param,read,buffers,the,buffers,for,the,readers,that,read,the,sorted,runs,param,write,buffers,the,buffers,for,the,writer,that,writes,the,merged,channel,return,the,id,and,number,of,blocks,of,the,channel,that,describes,the,merged,run;protected,channel,with,block,count,merge,channels,list,channel,with,block,count,channel,ids,list,list,memory,segment,read,buffers,list,memory,segment,write,buffers,throws,ioexception,final,list,file,iochannel,channel,accesses,new,array,list,file,iochannel,channel,ids,size,final,merge,iterator,e,merge,iterator,get,merging,iterator,channel,ids,read,buffers,channel,accesses,null,final,file,iochannel,id,merged,channel,id,this,io,manager,create,channel,register,channel,to,be,removed,at,shudown,merged,channel,id,final,block,channel,writer,memory,segment,writer,this,io,manager,create,block,channel,writer,merged,channel,id,register,open,channel,to,be,removed,at,shudown,writer,final,channel,writer,output,view,output,new,channel,writer,output,view,writer,write,buffers,this,mem,manager,get,page,size,if,object,reuse,enabled,final,type,serializer,e,serializer,this,serializer,e,rec,serializer,create,instance,while,rec,merge,iterator,next,rec,null,serializer,serialize,rec,output,else,e,rec,while,rec,merge,iterator,next,null,serializer,serialize,rec,output,output,close,final,int,num,blocks,written,output,get,block,count,unregister,open,channel,to,be,removed,at,shudown,writer,for,int,i,0,i,channel,accesses,size,i,file,iochannel,access,channel,accesses,get,i,access,close,and,delete,unregister,open,channel,to,be,removed,at,shudown,access,return,new,channel,with,block,count,merged,channel,id,num,blocks,written
UnilateralSortMerger -> @Override 	public void close();1405024514;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<BlockChannelAccess<?, ?>> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final BlockChannelAccess<?, ?> channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<Channel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final Channel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,block,channel,access,channels,this,open,channels,iterator,channels,has,next,final,block,channel,access,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,channel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,channel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1405090423;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<BlockChannelAccess<?, ?>> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final BlockChannelAccess<?, ?> channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<Channel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final Channel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,block,channel,access,channels,this,open,channels,iterator,channels,has,next,final,block,channel,access,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,channel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,channel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1409911022;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<BlockChannelAccess<?, ?>> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final BlockChannelAccess<?, ?> channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<Channel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final Channel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,block,channel,access,channels,this,open,channels,iterator,channels,has,next,final,block,channel,access,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,channel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,channel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1411236168;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<BlockChannelAccess<?, ?>> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final BlockChannelAccess<?, ?> channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<Channel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final Channel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,block,channel,access,channels,this,open,channels,iterator,channels,has,next,final,block,channel,access,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,channel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,channel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1411236169;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<BlockChannelAccess<?, ?>> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final BlockChannelAccess<?, ?> channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<Channel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final Channel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,block,channel,access,channels,this,open,channels,iterator,channels,has,next,final,block,channel,access,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,channel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,channel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1411473593;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<BlockChannelAccess<?, ?>> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final BlockChannelAccess<?, ?> channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<Channel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final Channel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,block,channel,access,channels,this,open,channels,iterator,channels,has,next,final,block,channel,access,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,channel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,channel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1415702894;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1420663430;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1421838095;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1421838095;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1421838096;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1421838096;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1423142112;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1426697080;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1441738685;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1442312401;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1442870284;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1443522094;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1466529056;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1530185676;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {_			_			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> @Override 	public void close();1533306679;Shuts down all the threads initiated by this sort/merger. Also releases all previously allocated_memory, if it has not yet been released by the threads, and closes and deletes all channels (removing_the temporary files)._<p>_The threads are set to exit directly, but depending on their operation, it may take a while to actually happen._The sorting thread will for example not finish before the current batch is sorted. This method attempts to wait_for the working thread to exit. If it is however interrupted, the method exits immediately and is not guaranteed_how long the threads continue to exist and occupy resources afterwards.__@see java.io.Closeable#close();@Override_	public void close() {_		_		synchronized (this) {_			if (this.closed) {_				return__			}_			_			_			this.closed = true__		}_		_		_		_		try {_			_			synchronized (this.iteratorLock) {_				if (this.iteratorException == null) {_					this.iteratorException = new IOException("The sorter has been closed.")__					this.iteratorLock.notifyAll()__				}_			}_			_			_			if (this.readThread != null) {_				try {_					this.readThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down reader thread: " + t.getMessage(), t)__				}_			}_			if (this.sortThread != null) {_				try {_					this.sortThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down sorter thread: " + t.getMessage(), t)__				}_			}_			if (this.spillThread != null) {_				try {_					this.spillThread.shutdown()__				} catch (Throwable t) {_					LOG.error("Error shutting down spilling thread: " + t.getMessage(), t)__				}_			}__			try {_				if (this.readThread != null) {_					this.readThread.join()__				}_				_				if (this.sortThread != null) {_					this.sortThread.join()__				}_				_				if (this.spillThread != null) {_					this.spillThread.join()__				}_			}_			catch (InterruptedException iex) {_				LOG.debug("Closing of sort/merger was interrupted. " +_						"The reading/sorting/spilling threads may still be working.", iex)__			}_		}_		finally {__			_			for (InMemorySorter<?> inMemorySorter : inMemorySorters) {_				inMemorySorter.dispose()__			}__			_			_			try {_				if (!this.writeMemory.isEmpty()) {_					this.memoryManager.release(this.writeMemory)__				}_				this.writeMemory.clear()__			}_			catch (Throwable t) {}_			_			try {_				if (!this.sortReadMemory.isEmpty()) {_					this.memoryManager.release(this.sortReadMemory)__				}_				this.sortReadMemory.clear()__			}_			catch (Throwable t) {}_			_			_			while (!this.openChannels.isEmpty()) {_				try {_					for (Iterator<FileIOChannel> channels = this.openChannels.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel channel = channels.next()__						channels.remove()__						channel.closeAndDelete()__					}_				}_				catch (Throwable t) {}_			}_			_			_			while (!this.channelsToDeleteAtShutdown.isEmpty()) {_				try {_					for (Iterator<FileIOChannel.ID> channels = this.channelsToDeleteAtShutdown.iterator()_ channels.hasNext()_ ) {_						final FileIOChannel.ID channel = channels.next()__						channels.remove()__						try {_							final File f = new File(channel.getPath())__							if (f.exists()) {_								f.delete()__							}_						} catch (Throwable t) {}_					}_				}_				catch (Throwable t) {}_			}_			_			try {_				if (this.largeRecordHandler != null) {_					this.largeRecordHandler.close()__				}_			} catch (Throwable t) {}_		}_	};shuts,down,all,the,threads,initiated,by,this,sort,merger,also,releases,all,previously,allocated,memory,if,it,has,not,yet,been,released,by,the,threads,and,closes,and,deletes,all,channels,removing,the,temporary,files,p,the,threads,are,set,to,exit,directly,but,depending,on,their,operation,it,may,take,a,while,to,actually,happen,the,sorting,thread,will,for,example,not,finish,before,the,current,batch,is,sorted,this,method,attempts,to,wait,for,the,working,thread,to,exit,if,it,is,however,interrupted,the,method,exits,immediately,and,is,not,guaranteed,how,long,the,threads,continue,to,exist,and,occupy,resources,afterwards,see,java,io,closeable,close;override,public,void,close,synchronized,this,if,this,closed,return,this,closed,true,try,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,new,ioexception,the,sorter,has,been,closed,this,iterator,lock,notify,all,if,this,read,thread,null,try,this,read,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,reader,thread,t,get,message,t,if,this,sort,thread,null,try,this,sort,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,sorter,thread,t,get,message,t,if,this,spill,thread,null,try,this,spill,thread,shutdown,catch,throwable,t,log,error,error,shutting,down,spilling,thread,t,get,message,t,try,if,this,read,thread,null,this,read,thread,join,if,this,sort,thread,null,this,sort,thread,join,if,this,spill,thread,null,this,spill,thread,join,catch,interrupted,exception,iex,log,debug,closing,of,sort,merger,was,interrupted,the,reading,sorting,spilling,threads,may,still,be,working,iex,finally,for,in,memory,sorter,in,memory,sorter,in,memory,sorters,in,memory,sorter,dispose,try,if,this,write,memory,is,empty,this,memory,manager,release,this,write,memory,this,write,memory,clear,catch,throwable,t,try,if,this,sort,read,memory,is,empty,this,memory,manager,release,this,sort,read,memory,this,sort,read,memory,clear,catch,throwable,t,while,this,open,channels,is,empty,try,for,iterator,file,iochannel,channels,this,open,channels,iterator,channels,has,next,final,file,iochannel,channel,channels,next,channels,remove,channel,close,and,delete,catch,throwable,t,while,this,channels,to,delete,at,shutdown,is,empty,try,for,iterator,file,iochannel,id,channels,this,channels,to,delete,at,shutdown,iterator,channels,has,next,final,file,iochannel,id,channel,channels,next,channels,remove,try,final,file,f,new,file,channel,get,path,if,f,exists,f,delete,catch,throwable,t,catch,throwable,t,try,if,this,large,record,handler,null,this,large,record,handler,close,catch,throwable,t
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1415702894;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1420663430;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1421838095;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1421838095;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1421838096;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1421838096;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1423142112;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1426697080;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1441738685;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1442312401;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1442870284;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1443522094;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1466529056;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1530185676;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel);1533306679;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(FileIOChannel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,file,iochannel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1405024514;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.parentTask = parentTask__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,parent,task,parent,task,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1405090423;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.parentTask = parentTask__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,parent,task,parent,task,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1409911022;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.parentTask = parentTask__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,parent,task,parent,task,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1411236168;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.parentTask = parentTask__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,parent,task,parent,task,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1411236169;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1411473593;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1415702894;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1420663430;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1421838095;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1421838095;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1421838096;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1421838096;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1423142112;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1426697080;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1441738685;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1442312401;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1442870284;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1443522094;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1466529056;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1530185676;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> ThreadBase -> protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues, 				AbstractInvokable parentTask);1533306679;Creates a new thread.__@param exceptionHandler The exception handler to call for all exceptions._@param name The name of the thread._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;protected ThreadBase(ExceptionHandler<IOException> exceptionHandler, String name, CircularQueues<E> queues,_				AbstractInvokable parentTask)_		{_			_			super(name)__			this.setDaemon(true)___			_			this.exceptionHandler = exceptionHandler__			this.setUncaughtExceptionHandler(this)___			this.queues = queues__			this.alive = true__		};creates,a,new,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,name,the,name,of,the,thread,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;protected,thread,base,exception,handler,ioexception,exception,handler,string,name,circular,queues,e,queues,abstract,invokable,parent,task,super,name,this,set,daemon,true,this,exception,handler,exception,handler,this,set,uncaught,exception,handler,this,this,queues,queues,this,alive,true
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1405024514;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param s The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1405090423;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param s The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1409911022;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param s The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1411236168;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param s The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1411236169;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel);1411473593;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(BlockChannelAccess<?, ?> channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,block,channel,access,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1415702894;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1420663430;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1421838095;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1421838095;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1421838096;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1421838096;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1423142112;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1426697080;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1441738685;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1442312401;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1442870284;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1443522094;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1466529056;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1530185676;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1533306679;Adds a channel reader/writer to the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void registerOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.add(channel)__		};adds,a,channel,reader,writer,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,register,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,add,channel
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction) 	throws IOException, MemoryAllocationException;1405024514;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, numSortBuffers, maxNumFileHandles, startSpillingFraction, false)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,num,sort,buffers,max,num,file,handles,start,spilling,fraction,false
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction) 	throws IOException, MemoryAllocationException;1405090423;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, numSortBuffers, maxNumFileHandles, startSpillingFraction, false)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,num,sort,buffers,max,num,file,handles,start,spilling,fraction,false
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction) 	throws IOException, MemoryAllocationException;1409911022;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, numSortBuffers, maxNumFileHandles, startSpillingFraction, false)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,num,sort,buffers,max,num,file,handles,start,spilling,fraction,false
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction) 	throws IOException, MemoryAllocationException;1411236168;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, numSortBuffers, maxNumFileHandles, startSpillingFraction, false)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,num,sort,buffers,max,num,file,handles,start,spilling,fraction,false
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction) 	throws IOException, MemoryAllocationException;1411236169;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, numSortBuffers, maxNumFileHandles, startSpillingFraction, false)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,num,sort,buffers,max,num,file,handles,start,spilling,fraction,false
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction) 	throws IOException, MemoryAllocationException;1411473593;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, numSortBuffers, maxNumFileHandles, startSpillingFraction, false)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,num,sort,buffers,max,num,file,handles,start,spilling,fraction,false
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction) 	throws IOException, MemoryAllocationException;1415702894;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, numSortBuffers, maxNumFileHandles, startSpillingFraction, false)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,num,sort,buffers,max,num,file,handles,start,spilling,fraction,false
UnilateralSortMerger -> public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager, 			MutableObjectIterator<E> input, AbstractInvokable parentTask,  			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator, 			double memoryFraction, int numSortBuffers, int maxNumFileHandles, 			float startSpillingFraction) 	throws IOException, MemoryAllocationException;1420663430;Creates a new sorter that reads the data from a given reader and provides an iterator returning that_data in a sorted manner. The memory is divided among sort buffers, write buffers and read buffers_automatically.__@param memoryManager The memory manager from which to allocate the memory._@param ioManager The I/O manager, which is used to write temporary files to disk._@param input The input that is sorted by this sorter._@param parentTask The parent task, which owns all resources used by this sorter._@param serializerFactory The type serializer._@param comparator The type comparator establishing the order relation._@param memoryFraction The fraction of memory dedicated to sorting, merging and I/O._@param numSortBuffers The number of distinct buffers to use creation of the initial runs._@param maxNumFileHandles The maximum number of files to be merged at once._@param startSpillingFraction The faction of the buffers that have to be filled before the spilling thread_actually begins spilling data to disk.__@throws IOException Thrown, if an error occurs initializing the resources for external sorting._@throws MemoryAllocationException Thrown, if not enough memory can be obtained from the memory manager to_perform the sort.;public UnilateralSortMerger(MemoryManager memoryManager, IOManager ioManager,_			MutableObjectIterator<E> input, AbstractInvokable parentTask, _			TypeSerializerFactory<E> serializerFactory, TypeComparator<E> comparator,_			double memoryFraction, int numSortBuffers, int maxNumFileHandles,_			float startSpillingFraction)_	throws IOException, MemoryAllocationException_	{_		this(memoryManager, ioManager, input, parentTask, serializerFactory, comparator,_			memoryFraction, numSortBuffers, maxNumFileHandles, startSpillingFraction, false)__	};creates,a,new,sorter,that,reads,the,data,from,a,given,reader,and,provides,an,iterator,returning,that,data,in,a,sorted,manner,the,memory,is,divided,among,sort,buffers,write,buffers,and,read,buffers,automatically,param,memory,manager,the,memory,manager,from,which,to,allocate,the,memory,param,io,manager,the,i,o,manager,which,is,used,to,write,temporary,files,to,disk,param,input,the,input,that,is,sorted,by,this,sorter,param,parent,task,the,parent,task,which,owns,all,resources,used,by,this,sorter,param,serializer,factory,the,type,serializer,param,comparator,the,type,comparator,establishing,the,order,relation,param,memory,fraction,the,fraction,of,memory,dedicated,to,sorting,merging,and,i,o,param,num,sort,buffers,the,number,of,distinct,buffers,to,use,creation,of,the,initial,runs,param,max,num,file,handles,the,maximum,number,of,files,to,be,merged,at,once,param,start,spilling,fraction,the,faction,of,the,buffers,that,have,to,be,filled,before,the,spilling,thread,actually,begins,spilling,data,to,disk,throws,ioexception,thrown,if,an,error,occurs,initializing,the,resources,for,external,sorting,throws,memory,allocation,exception,thrown,if,not,enough,memory,can,be,obtained,from,the,memory,manager,to,perform,the,sort;public,unilateral,sort,merger,memory,manager,memory,manager,iomanager,io,manager,mutable,object,iterator,e,input,abstract,invokable,parent,task,type,serializer,factory,e,serializer,factory,type,comparator,e,comparator,double,memory,fraction,int,num,sort,buffers,int,max,num,file,handles,float,start,spilling,fraction,throws,ioexception,memory,allocation,exception,this,memory,manager,io,manager,input,parent,task,serializer,factory,comparator,memory,fraction,num,sort,buffers,max,num,file,handles,start,spilling,fraction,false
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1405024514;Entry point of the thread.;public void go() throws IOException_		{			_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}_					_					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1405090423;Entry point of the thread.;public void go() throws IOException_		{			_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}_					_					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1409911022;Entry point of the thread.;public void go() throws IOException_		{			_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}_					_					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1411236168;Entry point of the thread.;public void go() throws IOException_		{			_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}_					_					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1411236169;Entry point of the thread.;public void go() throws IOException_		{			_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}_					_					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1411473593;Entry point of the thread.;public void go() throws IOException_		{			_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}_					_					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1415702894;Entry point of the thread.;public void go() throws IOException_		{			_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}_					_					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1420663430;Entry point of the thread.;public void go() throws IOException_		{			_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}_					_					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1421838095;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1421838095;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1421838096;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1421838096;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1423142112;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1426697080;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1441738685;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1442312401;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1442870284;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1443522094;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1466529056;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1530185676;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SortingThread -> public void go() throws IOException;1533306679;Entry point of the thread.;public void go() throws IOException {_			boolean alive = true___			_			while (isRunning() && alive) {_				CircularElement<E> element = null__				try {_					element = this.queues.sort.take()__				}_				catch (InterruptedException iex) {_					if (isRunning()) {_						if (LOG.isErrorEnabled()) {_							LOG.error(_								"Sorting thread was interrupted (without being shut down) while grabbing a buffer. " +_								"Retrying to grab buffer...")__						}_						continue__					}_					else {_						return__					}_				}__				if (element != EOF_MARKER && element != SPILLING_MARKER) {_					_					if (element.buffer.size() == 0) {_						element.buffer.reset()__						this.queues.empty.add(element)__						continue__					}_					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting buffer " + element.id + ".")__					}__					this.sorter.sort(element.buffer)__					_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorted buffer " + element.id + ".")__					}_				}_				else if (element == EOF_MARKER) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Sorting thread done.")__					}_					alive = false__				}_				this.queues.spill.add(element)__			}_		};entry,point,of,the,thread;public,void,go,throws,ioexception,boolean,alive,true,while,is,running,alive,circular,element,e,element,null,try,element,this,queues,sort,take,catch,interrupted,exception,iex,if,is,running,if,log,is,error,enabled,log,error,sorting,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,continue,else,return,if,element,element,if,element,buffer,size,0,element,buffer,reset,this,queues,empty,add,element,continue,if,log,is,debug,enabled,log,debug,sorting,buffer,element,id,this,sorter,sort,element,buffer,if,log,is,debug,enabled,log,debug,sorted,buffer,element,id,else,if,element,if,log,is,debug,enabled,log,debug,sorting,thread,done,alive,false,this,queues,spill,add,element
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(Channel.ID channel);1405024514;Adds a channel to the list of channels that are to be removed at shutdown.__@param s The channel id.;protected void registerChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(Channel.ID channel);1405090423;Adds a channel to the list of channels that are to be removed at shutdown.__@param s The channel id.;protected void registerChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(Channel.ID channel);1409911022;Adds a channel to the list of channels that are to be removed at shutdown.__@param s The channel id.;protected void registerChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(Channel.ID channel);1411236168;Adds a channel to the list of channels that are to be removed at shutdown.__@param s The channel id.;protected void registerChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(Channel.ID channel);1411236169;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void registerChannelToBeRemovedAtShudown(Channel.ID channel);1411473593;Adds a channel to the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void registerChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.add(channel)__		};adds,a,channel,to,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,register,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,add,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1415702894;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1420663430;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1421838095;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1421838095;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1421838096;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1421838096;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1423142112;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1426697080;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1441738685;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1442312401;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1442870284;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1443522094;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1466529056;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1530185676;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel);1533306679;Removes a channel reader/writer from the list of channels that are to be removed at shutdown.__@param channel The channel reader/writer.;protected void unregisterOpenChannelToBeRemovedAtShudown(FileIOChannel channel) {_			UnilateralSortMerger.this.openChannels.remove(channel)__		};removes,a,channel,reader,writer,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,reader,writer;protected,void,unregister,open,channel,to,be,removed,at,shudown,file,iochannel,channel,unilateral,sort,merger,this,open,channels,remove,channel
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1405024514;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1405090423;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1409911022;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1411236168;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1411236169;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1411473593;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1415702894;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1420663430;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1421838095;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1421838095;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1421838096;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1421838096;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1423142112;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1426697080;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1441738685;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1442312401;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1442870284;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1443522094;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1466529056;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1530185676;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIteratorException(IOException ioex);1533306679;Reports an exception to all threads that are waiting for the result iterator.__@param ioex The exception to be reported to the threads that wait for the result iterator.;protected final void setResultIteratorException(IOException ioex) {_		synchronized (this.iteratorLock) {_			if (this.iteratorException == null) {_				this.iteratorException = ioex__				this.iteratorLock.notifyAll()__			}_		}_	};reports,an,exception,to,all,threads,that,are,waiting,for,the,result,iterator,param,ioex,the,exception,to,be,reported,to,the,threads,that,wait,for,the,result,iterator;protected,final,void,set,result,iterator,exception,ioexception,ioex,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,exception,ioex,this,iterator,lock,notify,all
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel);1405024514;Removes a channel from the list of channels that are to be removed at shutdown.__@param s The channel id.;protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel);1405090423;Removes a channel from the list of channels that are to be removed at shutdown.__@param s The channel id.;protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel);1409911022;Removes a channel from the list of channels that are to be removed at shutdown.__@param s The channel id.;protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel);1411236168;Removes a channel from the list of channels that are to be removed at shutdown.__@param s The channel id.;protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,s,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel);1411236169;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SpillingThread -> protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel);1411473593;Removes a channel from the list of channels that are to be removed at shutdown.__@param channel The channel id.;protected void unregisterChannelToBeRemovedAtShudown(Channel.ID channel) {_			UnilateralSortMerger.this.channelsToDeleteAtShutdown.remove(channel)__		};removes,a,channel,from,the,list,of,channels,that,are,to,be,removed,at,shutdown,param,channel,the,channel,id;protected,void,unregister,channel,to,be,removed,at,shudown,channel,id,channel,unilateral,sort,merger,this,channels,to,delete,at,shutdown,remove,channel
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1405024514;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1405090423;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1409911022;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1411236168;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1411236169;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1411473593;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1415702894;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1420663430;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1421838095;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1421838095;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1421838096;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1421838096;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1423142112;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1426697080;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1441738685;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1442312401;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1442870284;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1443522094;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1466529056;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1530185676;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> SortingThread -> public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues, 				AbstractInvokable parentTask);1533306679;Creates a new sorting thread.__@param exceptionHandler The exception handler to call for all exceptions._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public SortingThread(ExceptionHandler<IOException> exceptionHandler, CircularQueues<E> queues,_				AbstractInvokable parentTask) {_			super(exceptionHandler, "SortMerger sorting thread", queues, parentTask)___			_			this.sorter = new QuickSort()__		};creates,a,new,sorting,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,sorting,thread,exception,handler,ioexception,exception,handler,circular,queues,e,queues,abstract,invokable,parent,task,super,exception,handler,sort,merger,sorting,thread,queues,parent,task,this,sorter,new,quick,sort
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1421838095;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1421838095;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1421838096;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1421838096;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1423142112;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1426697080;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1441738685;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1442312401;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1442870284;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1443522094;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1466529056;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1530185676;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> ReadingThread -> public ReadingThread(ExceptionHandler<IOException> exceptionHandler, 				MutableObjectIterator<E> reader, CircularQueues<E> queues, 				LargeRecordHandler<E> largeRecordsHandler, E readTarget, 				AbstractInvokable parentTask, long startSpillingBytes);1533306679;Creates a new reading thread.__@param exceptionHandler The exception handler to call for all exceptions._@param reader The reader to pull the data from._@param queues The queues used to pass buffers between the threads._@param parentTask The task that started this thread. If non-null, it is used to register this thread.;public ReadingThread(ExceptionHandler<IOException> exceptionHandler,_				MutableObjectIterator<E> reader, CircularQueues<E> queues,_				LargeRecordHandler<E> largeRecordsHandler, E readTarget,_				AbstractInvokable parentTask, long startSpillingBytes)_		{_			super(exceptionHandler, "SortMerger Reading Thread", queues, parentTask)___			_			this.reader = reader__			this.readTarget = readTarget__			this.startSpillingBytes = startSpillingBytes__			this.largeRecords = largeRecordsHandler__		};creates,a,new,reading,thread,param,exception,handler,the,exception,handler,to,call,for,all,exceptions,param,reader,the,reader,to,pull,the,data,from,param,queues,the,queues,used,to,pass,buffers,between,the,threads,param,parent,task,the,task,that,started,this,thread,if,non,null,it,is,used,to,register,this,thread;public,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,records,handler,e,read,target,abstract,invokable,parent,task,long,start,spilling,bytes,super,exception,handler,sort,merger,reading,thread,queues,parent,task,this,reader,reader,this,read,target,read,target,this,start,spilling,bytes,start,spilling,bytes,this,large,records,large,records,handler
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1405024514;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1405090423;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1409911022;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1411236168;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1411236169;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1411473593;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1415702894;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1420663430;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1421838095;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1421838095;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1421838096;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1421838096;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1423142112;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1426697080;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1441738685;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1442312401;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1442870284;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1443522094;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1466529056;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1530185676;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> spillingMarker();1533306679;Gets the element that is passed as marker for signal beginning of spilling.__@return The element that is passed as marker for signal beginning of spilling.;protected static <T> CircularElement<T> spillingMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) SPILLING_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling,return,the,element,that,is,passed,as,marker,for,signal,beginning,of,spilling;protected,static,t,circular,element,t,spilling,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1405024514;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1405090423;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1409911022;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1411236168;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1411236169;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1411473593;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1415702894;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1420663430;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1421838095;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1421838095;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1421838096;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1421838096;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1423142112;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1426697080;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1441738685;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1442312401;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1442870284;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1443522094;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1466529056;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1530185676;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> ThreadBase -> public boolean isRunning();1533306679;Checks whether this thread is still alive.__@return true, if the thread is alive, false otherwise.;public boolean isRunning() {_			return this.alive__		};checks,whether,this,thread,is,still,alive,return,true,if,the,thread,is,alive,false,otherwise;public,boolean,is,running,return,this,alive
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1421838095;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1421838095;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1421838096;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1421838096;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1423142112;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1426697080;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1441738685;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1442312401;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1442870284;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1443522094;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1466529056;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1530185676;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords) 			throws IOException;1533306679;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<FileIOChannel> readerList, MutableObjectIterator<E> largeRecords)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size() + 1)__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}_			_			if (largeRecords != null) {_				iterators.add(largeRecords)__			}__			return new MergeIterator<E>(iterators, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,file,iochannel,reader,list,mutable,object,iterator,e,large,records,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,1,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,if,large,records,null,iterators,add,large,records,return,new,merge,iterator,e,iterators,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1405024514;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero._@return A list with all memory segments that were allocated.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero,return,a,list,with,all,memory,segments,that,were,allocated;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1405090423;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero._@return A list with all memory segments that were allocated.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero,return,a,list,with,all,memory,segments,that,were,allocated;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1409911022;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero._@return A list with all memory segments that were allocated.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero,return,a,list,with,all,memory,segments,that,were,allocated;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1411236168;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero._@return A list with all memory segments that were allocated.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero,return,a,list,with,all,memory,segments,that,were,allocated;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1411236169;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1411473593;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1415702894;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1420663430;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1421838095;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1421838095;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1421838096;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1421838096;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1423142112;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1426697080;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1441738685;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1442312401;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1442870284;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1443522094;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1466529056;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1530185676;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> SpillingThread -> protected final void getSegmentsForReaders(List<List<MemorySegment>> target, 			List<MemorySegment> memory, int numChannels);1533306679;Divides the given collection of memory buffers among {@code numChannels} sublists.__@param target The list into which the lists with buffers for the channels are put._@param memory A list containing the memory buffers to be distributed. The buffers are not_removed from this list._@param numChannels The number of channels for which to allocate buffers. Must not be zero.;protected final void getSegmentsForReaders(List<List<MemorySegment>> target,_			List<MemorySegment> memory, int numChannels)_		{_			_			final int numBuffers = memory.size()__			final int buffersPerChannelLowerBound = numBuffers / numChannels__			final int numChannelsWithOneMore = numBuffers % numChannels__			_			final Iterator<MemorySegment> segments = memory.iterator()__			_			_			for (int i = 0_ i < numChannelsWithOneMore_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound + 1)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k >= 0_ k--) {_					segs.add(segments.next())__				}_			}_			_			_			for (int i = numChannelsWithOneMore_ i < numChannels_ i++) {_				final ArrayList<MemorySegment> segs = new ArrayList<MemorySegment>(buffersPerChannelLowerBound)__				target.add(segs)__				for (int k = buffersPerChannelLowerBound_ k > 0_ k--) {_					segs.add(segments.next())__				}_			}_		};divides,the,given,collection,of,memory,buffers,among,code,num,channels,sublists,param,target,the,list,into,which,the,lists,with,buffers,for,the,channels,are,put,param,memory,a,list,containing,the,memory,buffers,to,be,distributed,the,buffers,are,not,removed,from,this,list,param,num,channels,the,number,of,channels,for,which,to,allocate,buffers,must,not,be,zero;protected,final,void,get,segments,for,readers,list,list,memory,segment,target,list,memory,segment,memory,int,num,channels,final,int,num,buffers,memory,size,final,int,buffers,per,channel,lower,bound,num,buffers,num,channels,final,int,num,channels,with,one,more,num,buffers,num,channels,final,iterator,memory,segment,segments,memory,iterator,for,int,i,0,i,num,channels,with,one,more,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,1,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next,for,int,i,num,channels,with,one,more,i,num,channels,i,final,array,list,memory,segment,segs,new,array,list,memory,segment,buffers,per,channel,lower,bound,target,add,segs,for,int,k,buffers,per,channel,lower,bound,k,0,k,segs,add,segments,next
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1421838095;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1421838095;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1421838096;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1421838096;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1423142112;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1426697080;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1441738685;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1442312401;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1442870284;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1443522094;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1466529056;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1530185676;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues,  			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1533306679;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, _			LargeRecordHandler<E> largeRecordHandler, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, largeRecordHandler, _				serializer.createInstance(),parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,large,record,handler,e,large,record,handler,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,large,record,handler,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1405024514;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1405090423;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1409911022;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1411236168;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1411236169;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1411473593;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1415702894;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1420663430;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1421838095;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1421838095;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1421838096;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1421838096;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1423142112;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1426697080;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1441738685;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1442312401;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1442870284;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1443522094;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1466529056;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1530185676;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> ThreadBase -> protected abstract void go() throws IOException_;1533306679;Equivalent to the run() method.__@throws IOException Exceptions that prohibit correct completion of the work may be thrown by the thread.;protected abstract void go() throws IOException_;equivalent,to,the,run,method,throws,ioexception,exceptions,that,prohibit,correct,completion,of,the,work,may,be,thrown,by,the,thread;protected,abstract,void,go,throws,ioexception
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1405024514;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, serializer.createInstance(),_			parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1405090423;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, serializer.createInstance(),_			parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1409911022;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, serializer.createInstance(),_			parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1411236168;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, serializer.createInstance(),_			parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1411236169;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, serializer.createInstance(),_			parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1411473593;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, serializer.createInstance(),_			parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1415702894;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, serializer.createInstance(),_			parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler, 			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask, 			TypeSerializer<E> serializer, long startSpillingBytes);1420663430;Creates the reading thread. The reading thread simply reads the data off the input and puts it_into the buffer where it will be sorted._<p>_The returned thread is not yet started.__@param exceptionHandler_The handler for exceptions in the thread._@param reader_The reader from which the thread reads._@param queues_The queues through which the thread communicates with the other threads._@param parentTask_The task at which the thread registers itself (for profiling purposes)._@param serializer_The serializer used to serialize records._@param startSpillingBytes_The number of bytes after which the reader thread will send the notification to_start the spilling.__@return The thread that reads data from an input, writes it into sort buffers and puts_them into a queue.;protected ThreadBase<E> getReadingThread(ExceptionHandler<IOException> exceptionHandler,_			MutableObjectIterator<E> reader, CircularQueues<E> queues, AbstractInvokable parentTask,_			TypeSerializer<E> serializer, long startSpillingBytes)_	{_		return new ReadingThread<E>(exceptionHandler, reader, queues, serializer.createInstance(),_			parentTask, startSpillingBytes)__	};creates,the,reading,thread,the,reading,thread,simply,reads,the,data,off,the,input,and,puts,it,into,the,buffer,where,it,will,be,sorted,p,the,returned,thread,is,not,yet,started,param,exception,handler,the,handler,for,exceptions,in,the,thread,param,reader,the,reader,from,which,the,thread,reads,param,queues,the,queues,through,which,the,thread,communicates,with,the,other,threads,param,parent,task,the,task,at,which,the,thread,registers,itself,for,profiling,purposes,param,serializer,the,serializer,used,to,serialize,records,param,start,spilling,bytes,the,number,of,bytes,after,which,the,reader,thread,will,send,the,notification,to,start,the,spilling,return,the,thread,that,reads,data,from,an,input,writes,it,into,sort,buffers,and,puts,them,into,a,queue;protected,thread,base,e,get,reading,thread,exception,handler,ioexception,exception,handler,mutable,object,iterator,e,reader,circular,queues,e,queues,abstract,invokable,parent,task,type,serializer,e,serializer,long,start,spilling,bytes,return,new,reading,thread,e,exception,handler,reader,queues,serializer,create,instance,parent,task,start,spilling,bytes
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1405024514;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1405090423;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1409911022;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1411236168;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1411236169;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1411473593;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1415702894;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1420663430;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1421838095;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1421838095;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1421838096;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1421838096;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1423142112;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1426697080;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1441738685;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1442312401;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1442870284;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1443522094;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1466529056;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1530185676;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected static <T> CircularElement<T> endMarker();1533306679;Gets the element that is passed as marker for the end of data.__@return The element that is passed as marker for the end of data.;protected static <T> CircularElement<T> endMarker() {_		@SuppressWarnings("unchecked")_		CircularElement<T> c = (CircularElement<T>) EOF_MARKER__		return c__	};gets,the,element,that,is,passed,as,marker,for,the,end,of,data,return,the,element,that,is,passed,as,marker,for,the,end,of,data;protected,static,t,circular,element,t,end,marker,suppress,warnings,unchecked,circular,element,t,c,circular,element,t,return,c
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1405024514;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1405090423;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1409911022;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1411236168;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1411236169;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1411473593;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1415702894;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1420663430;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1421838095;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1421838095;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1421838096;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1421838096;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1423142112;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1426697080;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1441738685;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1442312401;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1442870284;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1443522094;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1466529056;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1530185676;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> protected final void setResultIterator(MutableObjectIterator<E> iterator);1533306679;Sets the result iterator. By setting the result iterator, all threads that are waiting for the result_iterator are notified and will obtain it.__@param iterator The result iterator to set.;protected final void setResultIterator(MutableObjectIterator<E> iterator) {_		synchronized (this.iteratorLock) {_			_			if (this.iteratorException == null) {_				this.iterator = iterator__				this.iteratorLock.notifyAll()__			}_		}_	};sets,the,result,iterator,by,setting,the,result,iterator,all,threads,that,are,waiting,for,the,result,iterator,are,notified,and,will,obtain,it,param,iterator,the,result,iterator,to,set;protected,final,void,set,result,iterator,mutable,object,iterator,e,iterator,synchronized,this,iterator,lock,if,this,iterator,exception,null,this,iterator,iterator,this,iterator,lock,notify,all
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1405024514;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException_		{	_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						if (isRunning()) {_							LOG.error("Reading thread was interrupted (without being shut down) while grabbing a buffer. " +_									"Retrying to grab buffer...")__						} else {_							return__						}_					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						throw new IOException("Record could not be written to empty buffer: Serialized record exceeds buffer capacity.")__					}_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,if,is,running,log,error,reading,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,else,return,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,throw,new,ioexception,record,could,not,be,written,to,empty,buffer,serialized,record,exceeds,buffer,capacity,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1405090423;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException_		{	_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						if (isRunning()) {_							LOG.error("Reading thread was interrupted (without being shut down) while grabbing a buffer. " +_									"Retrying to grab buffer...")__						} else {_							return__						}_					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						throw new IOException("Record could not be written to empty buffer: Serialized record exceeds buffer capacity.")__					}_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,if,is,running,log,error,reading,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,else,return,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,throw,new,ioexception,record,could,not,be,written,to,empty,buffer,serialized,record,exceeds,buffer,capacity,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1409911022;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException_		{	_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						if (isRunning()) {_							LOG.error("Reading thread was interrupted (without being shut down) while grabbing a buffer. " +_									"Retrying to grab buffer...")__						} else {_							return__						}_					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						throw new IOException("Record could not be written to empty buffer: Serialized record exceeds buffer capacity.")__					}_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,if,is,running,log,error,reading,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,else,return,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,throw,new,ioexception,record,could,not,be,written,to,empty,buffer,serialized,record,exceeds,buffer,capacity,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1411236168;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException_		{	_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						if (isRunning()) {_							LOG.error("Reading thread was interrupted (without being shut down) while grabbing a buffer. " +_									"Retrying to grab buffer...")__						} else {_							return__						}_					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						throw new IOException("Record could not be written to empty buffer: Serialized record exceeds buffer capacity.")__					}_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,if,is,running,log,error,reading,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,else,return,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,throw,new,ioexception,record,could,not,be,written,to,empty,buffer,serialized,record,exceeds,buffer,capacity,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1411236169;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException_		{	_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						if (isRunning()) {_							LOG.error("Reading thread was interrupted (without being shut down) while grabbing a buffer. " +_									"Retrying to grab buffer...")__						} else {_							return__						}_					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						throw new IOException("Record could not be written to empty buffer: Serialized record exceeds buffer capacity.")__					}_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,if,is,running,log,error,reading,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,else,return,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,throw,new,ioexception,record,could,not,be,written,to,empty,buffer,serialized,record,exceeds,buffer,capacity,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1411473593;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException_		{	_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						if (isRunning()) {_							LOG.error("Reading thread was interrupted (without being shut down) while grabbing a buffer. " +_									"Retrying to grab buffer...")__						} else {_							return__						}_					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						throw new IOException("Record could not be written to empty buffer: Serialized record exceeds buffer capacity.")__					}_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,if,is,running,log,error,reading,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,else,return,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,throw,new,ioexception,record,could,not,be,written,to,empty,buffer,serialized,record,exceeds,buffer,capacity,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1415702894;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException_		{	_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						if (isRunning()) {_							LOG.error("Reading thread was interrupted (without being shut down) while grabbing a buffer. " +_									"Retrying to grab buffer...")__						} else {_							return__						}_					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						throw new IOException("Record could not be written to empty buffer: Serialized record exceeds buffer capacity.")__					}_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,if,is,running,log,error,reading,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,else,return,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,throw,new,ioexception,record,could,not,be,written,to,empty,buffer,serialized,record,exceeds,buffer,capacity,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1420663430;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException_		{	_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						if (isRunning()) {_							LOG.error("Reading thread was interrupted (without being shut down) while grabbing a buffer. " +_									"Retrying to grab buffer...")__						} else {_							return__						}_					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						throw new IOException("Record could not be written to empty buffer: Serialized record exceeds buffer capacity.")__					}_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,if,is,running,log,error,reading,thread,was,interrupted,without,being,shut,down,while,grabbing,a,buffer,retrying,to,grab,buffer,else,return,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,throw,new,ioexception,record,could,not,be,written,to,empty,buffer,serialized,record,exceeds,buffer,capacity,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1421838095;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						if (this.largeRecords != null) {_							this.largeRecords.addRecord(leftoverRecord)__						} else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1421838095;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						if (this.largeRecords != null) {_							this.largeRecords.addRecord(leftoverRecord)__						} else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1421838096;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1421838096;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1423142112;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1426697080;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1441738685;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1442312401;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1442870284;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1443522094;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1466529056;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1530185676;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> ReadingThread -> public void go() throws IOException;1533306679;The entry point for the thread. Gets a buffer for all threads and then loops as long as there is input_available.;public void go() throws IOException {_			_			final MutableObjectIterator<E> reader = this.reader__			_			E current = this.readTarget__			E leftoverRecord = null__			_			CircularElement<E> element = null__			long bytesUntilSpilling = this.startSpillingBytes__			boolean done = false__			_			_			if (bytesUntilSpilling < 1) {_				bytesUntilSpilling = 0__				_				_				this.queues.sort.add(UnilateralSortMerger.<E>spillingMarker())__			}__			_			while (!done && isRunning())_			{_				_				while (element == null) {_					try {_						element = this.queues.empty.take()__					}_					catch (InterruptedException iex) {_						throw new IOException(iex)__					}_				}_				_				_				final InMemorySorter<E> buffer = element.buffer__				if (!buffer.isEmpty()) {_					throw new IOException("New buffer is not empty.")__				}_				_				if (LOG.isDebugEnabled()) {_					LOG.debug("Retrieved empty read buffer " + element.id + ".")__				}_				_				_				if (leftoverRecord != null) {_					if (!buffer.write(leftoverRecord)) {_						_						_						if (this.largeRecords != null) {_							if (LOG.isDebugEnabled()) {_								LOG.debug("Large record did not fit into a fresh sort buffer. Putting into large record store.")__							}_							this.largeRecords.addRecord(leftoverRecord)__						}_						else {_							throw new IOException("The record exceeds the maximum size of a sort buffer (current maximum: "_									+ buffer.getCapacity() + " bytes).")__						}_						buffer.reset()__					}_					_					leftoverRecord = null__				}_				_				_				_				boolean available = true__				if (bytesUntilSpilling > 0 && buffer.getCapacity() >= bytesUntilSpilling)_				{_					boolean fullBuffer = false__					_					_					_					E newCurrent__					while (isRunning() && (available = (newCurrent = reader.next(current)) != null))_					{_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							fullBuffer = true__							break__						}_						_						_						_						if (bytesUntilSpilling - buffer.getOccupancy() <= 0) {_							bytesUntilSpilling = 0__							_							_							final CircularElement<E> SPILLING_MARKER = spillingMarker()__							this.queues.sort.add(SPILLING_MARKER)__							_							_							_							break__						}_					}_					_					if (fullBuffer) {_						_						_						if (bytesUntilSpilling > 0) {_							bytesUntilSpilling -= buffer.getCapacity()__							if (bytesUntilSpilling <= 0) {_								bytesUntilSpilling = 0__								_								final CircularElement<E> SPILLING_MARKER = spillingMarker()__								this.queues.sort.add(SPILLING_MARKER)__							}_						}_						_						_						if (LOG.isDebugEnabled()) {_							LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__						}_						this.queues.sort.add(element)__						element = null__						continue__					}_				}_				else if (bytesUntilSpilling > 0) {_					_					_					bytesUntilSpilling -= buffer.getCapacity()__					if (bytesUntilSpilling <= 0) {_						bytesUntilSpilling = 0__						_						final CircularElement<E> SPILLING_MARKER = spillingMarker()__						this.queues.sort.add(SPILLING_MARKER)__					}_				}_				_				_				_				if (available) {_					E newCurrent__					while (isRunning() && ((newCurrent = reader.next(current)) != null)) {_						current = newCurrent__						if (!buffer.write(current)) {_							leftoverRecord = current__							break__						}_					}_				}_				_				_				if (leftoverRecord != null) {_					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting full buffer from reader thread: " + element.id + ".")__					}_				}_				else {_					done = true__					if (LOG.isDebugEnabled()) {_						LOG.debug("Emitting final buffer from reader thread: " + element.id + ".")__					}_				}_					_				_				_				if (!buffer.isEmpty()) {_					this.queues.sort.add(element)__				}_				else {_					buffer.reset()__					this.queues.empty.add(element)__				}_				element = null__			}__			_			if (!isRunning()) {_				return__			}__			_			_			final CircularElement<E> EOF_MARKER = endMarker()__			this.queues.sort.add(EOF_MARKER)__			LOG.debug("Reading thread done.")__		};the,entry,point,for,the,thread,gets,a,buffer,for,all,threads,and,then,loops,as,long,as,there,is,input,available;public,void,go,throws,ioexception,final,mutable,object,iterator,e,reader,this,reader,e,current,this,read,target,e,leftover,record,null,circular,element,e,element,null,long,bytes,until,spilling,this,start,spilling,bytes,boolean,done,false,if,bytes,until,spilling,1,bytes,until,spilling,0,this,queues,sort,add,unilateral,sort,merger,e,spilling,marker,while,done,is,running,while,element,null,try,element,this,queues,empty,take,catch,interrupted,exception,iex,throw,new,ioexception,iex,final,in,memory,sorter,e,buffer,element,buffer,if,buffer,is,empty,throw,new,ioexception,new,buffer,is,not,empty,if,log,is,debug,enabled,log,debug,retrieved,empty,read,buffer,element,id,if,leftover,record,null,if,buffer,write,leftover,record,if,this,large,records,null,if,log,is,debug,enabled,log,debug,large,record,did,not,fit,into,a,fresh,sort,buffer,putting,into,large,record,store,this,large,records,add,record,leftover,record,else,throw,new,ioexception,the,record,exceeds,the,maximum,size,of,a,sort,buffer,current,maximum,buffer,get,capacity,bytes,buffer,reset,leftover,record,null,boolean,available,true,if,bytes,until,spilling,0,buffer,get,capacity,bytes,until,spilling,boolean,full,buffer,false,e,new,current,while,is,running,available,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,full,buffer,true,break,if,bytes,until,spilling,buffer,get,occupancy,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,break,if,full,buffer,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,this,queues,sort,add,element,element,null,continue,else,if,bytes,until,spilling,0,bytes,until,spilling,buffer,get,capacity,if,bytes,until,spilling,0,bytes,until,spilling,0,final,circular,element,e,spilling,marker,this,queues,sort,add,if,available,e,new,current,while,is,running,new,current,reader,next,current,null,current,new,current,if,buffer,write,current,leftover,record,current,break,if,leftover,record,null,if,log,is,debug,enabled,log,debug,emitting,full,buffer,from,reader,thread,element,id,else,done,true,if,log,is,debug,enabled,log,debug,emitting,final,buffer,from,reader,thread,element,id,if,buffer,is,empty,this,queues,sort,add,element,else,buffer,reset,this,queues,empty,add,element,element,null,if,is,running,return,final,circular,element,e,end,marker,this,queues,sort,add,log,debug,reading,thread,done
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1405024514;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers._@param writeBufferSize The size of the write buffers._@param  readMemorySize The amount of memory dedicated to the readers._@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem._@throws MemoryAllocationException Thrown, if the specified memory is insufficient to merge the channels_or if the memory manager could not provide the requested memory.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxNumFileHandles))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,param,write,buffer,size,the,size,of,the,write,buffers,param,read,memory,size,the,amount,of,memory,dedicated,to,the,readers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem,throws,memory,allocation,exception,thrown,if,the,specified,memory,is,insufficient,to,merge,the,channels,or,if,the,memory,manager,could,not,provide,the,requested,memory;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,num,file,handles,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1405090423;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers._@param writeBufferSize The size of the write buffers._@param  readMemorySize The amount of memory dedicated to the readers._@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem._@throws MemoryAllocationException Thrown, if the specified memory is insufficient to merge the channels_or if the memory manager could not provide the requested memory.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxNumFileHandles))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,param,write,buffer,size,the,size,of,the,write,buffers,param,read,memory,size,the,amount,of,memory,dedicated,to,the,readers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem,throws,memory,allocation,exception,thrown,if,the,specified,memory,is,insufficient,to,merge,the,channels,or,if,the,memory,manager,could,not,provide,the,requested,memory;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,num,file,handles,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1409911022;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers._@param writeBufferSize The size of the write buffers._@param  readMemorySize The amount of memory dedicated to the readers._@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem._@throws MemoryAllocationException Thrown, if the specified memory is insufficient to merge the channels_or if the memory manager could not provide the requested memory.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxNumFileHandles))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,param,write,buffer,size,the,size,of,the,write,buffers,param,read,memory,size,the,amount,of,memory,dedicated,to,the,readers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem,throws,memory,allocation,exception,thrown,if,the,specified,memory,is,insufficient,to,merge,the,channels,or,if,the,memory,manager,could,not,provide,the,requested,memory;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,num,file,handles,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1411236168;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers._@param writeBufferSize The size of the write buffers._@param  readMemorySize The amount of memory dedicated to the readers._@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem._@throws MemoryAllocationException Thrown, if the specified memory is insufficient to merge the channels_or if the memory manager could not provide the requested memory.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxNumFileHandles))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,param,write,buffer,size,the,size,of,the,write,buffers,param,read,memory,size,the,amount,of,memory,dedicated,to,the,readers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem,throws,memory,allocation,exception,thrown,if,the,specified,memory,is,insufficient,to,merge,the,channels,or,if,the,memory,manager,could,not,provide,the,requested,memory;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,num,file,handles,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1411236169;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxNumFileHandles))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,num,file,handles,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1411473593;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxNumFileHandles))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,num,file,handles,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1415702894;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxNumFileHandles))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,num,file,handles,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1420663430;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxNumFileHandles))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,num,file,handles,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1421838095;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxFanIn))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,fan,in,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1421838095;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxFanIn))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,fan,in,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1421838096;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxFanIn))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,fan,in,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1421838096;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxFanIn))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,fan,in,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1423142112;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxFanIn))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,fan,in,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1426697080;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxFanIn))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,fan,in,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1441738685;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param writeBuffers The buffers to be used by the writers.__@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			final double numMerges = Math.ceil(channelIDs.size() / ((double) this.maxFanIn))__			final int channelsToMergePerStep = (int) Math.ceil(channelIDs.size() / numMerges)__			_			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)__			_			_			final ArrayList<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>((int) (numMerges + 1))___			final ArrayList<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = 0__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}_				_				_				if (channelsToMergeThisStep.size() < 2)  {_					mergedChannelIDs.addAll(channelsToMergeThisStep)__				}_				else {_					mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__				}_			}_			_			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,num,merges,math,ceil,channel,ids,size,double,this,max,fan,in,final,int,channels,to,merge,per,step,int,math,ceil,channel,ids,size,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,array,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,int,num,merges,1,final,array,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,0,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,if,channels,to,merge,this,step,size,2,merged,channel,ids,add,all,channels,to,merge,this,step,else,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1442312401;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param allReadBuffers_@param writeBuffers The buffers to be used by the writers._@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			_			_			final double scale = Math.ceil(Math.log(channelIDs.size()) / Math.log(this.maxFanIn)) - 1___			final int numStart = channelIDs.size()__			final int numEnd = (int) Math.pow(this.maxFanIn, scale)___			final int numMerges = (int) Math.ceil((numStart - numEnd) / (double) (this.maxFanIn - 1))___			final int numNotMerged = numEnd - numMerges__			final int numToMerge = numStart - numNotMerged___			_			final List<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>(numEnd)__			mergedChannelIDs.addAll(channelIDs.subList(0, numNotMerged))___			final int channelsToMergePerStep = (int) Math.ceil(numToMerge / (double) numMerges)___			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)___			final List<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = numNotMerged__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}__				mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__			}__			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,all,read,buffers,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,scale,math,ceil,math,log,channel,ids,size,math,log,this,max,fan,in,1,final,int,num,start,channel,ids,size,final,int,num,end,int,math,pow,this,max,fan,in,scale,final,int,num,merges,int,math,ceil,num,start,num,end,double,this,max,fan,in,1,final,int,num,not,merged,num,end,num,merges,final,int,num,to,merge,num,start,num,not,merged,final,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,num,end,merged,channel,ids,add,all,channel,ids,sub,list,0,num,not,merged,final,int,channels,to,merge,per,step,int,math,ceil,num,to,merge,double,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,num,not,merged,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1442870284;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param allReadBuffers_@param writeBuffers The buffers to be used by the writers._@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			_			_			final double scale = Math.ceil(Math.log(channelIDs.size()) / Math.log(this.maxFanIn)) - 1___			final int numStart = channelIDs.size()__			final int numEnd = (int) Math.pow(this.maxFanIn, scale)___			final int numMerges = (int) Math.ceil((numStart - numEnd) / (double) (this.maxFanIn - 1))___			final int numNotMerged = numEnd - numMerges__			final int numToMerge = numStart - numNotMerged___			_			final List<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>(numEnd)__			mergedChannelIDs.addAll(channelIDs.subList(0, numNotMerged))___			final int channelsToMergePerStep = (int) Math.ceil(numToMerge / (double) numMerges)___			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)___			final List<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = numNotMerged__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}__				mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__			}__			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,all,read,buffers,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,scale,math,ceil,math,log,channel,ids,size,math,log,this,max,fan,in,1,final,int,num,start,channel,ids,size,final,int,num,end,int,math,pow,this,max,fan,in,scale,final,int,num,merges,int,math,ceil,num,start,num,end,double,this,max,fan,in,1,final,int,num,not,merged,num,end,num,merges,final,int,num,to,merge,num,start,num,not,merged,final,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,num,end,merged,channel,ids,add,all,channel,ids,sub,list,0,num,not,merged,final,int,channels,to,merge,per,step,int,math,ceil,num,to,merge,double,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,num,not,merged,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1443522094;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param allReadBuffers_@param writeBuffers The buffers to be used by the writers._@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			_			_			final double scale = Math.ceil(Math.log(channelIDs.size()) / Math.log(this.maxFanIn)) - 1___			final int numStart = channelIDs.size()__			final int numEnd = (int) Math.pow(this.maxFanIn, scale)___			final int numMerges = (int) Math.ceil((numStart - numEnd) / (double) (this.maxFanIn - 1))___			final int numNotMerged = numEnd - numMerges__			final int numToMerge = numStart - numNotMerged___			_			final List<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>(numEnd)__			mergedChannelIDs.addAll(channelIDs.subList(0, numNotMerged))___			final int channelsToMergePerStep = (int) Math.ceil(numToMerge / (double) numMerges)___			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)___			final List<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = numNotMerged__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}__				mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__			}__			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,all,read,buffers,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,scale,math,ceil,math,log,channel,ids,size,math,log,this,max,fan,in,1,final,int,num,start,channel,ids,size,final,int,num,end,int,math,pow,this,max,fan,in,scale,final,int,num,merges,int,math,ceil,num,start,num,end,double,this,max,fan,in,1,final,int,num,not,merged,num,end,num,merges,final,int,num,to,merge,num,start,num,not,merged,final,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,num,end,merged,channel,ids,add,all,channel,ids,sub,list,0,num,not,merged,final,int,channels,to,merge,per,step,int,math,ceil,num,to,merge,double,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,num,not,merged,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1466529056;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param allReadBuffers_@param writeBuffers The buffers to be used by the writers._@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			_			_			final double scale = Math.ceil(Math.log(channelIDs.size()) / Math.log(this.maxFanIn)) - 1___			final int numStart = channelIDs.size()__			final int numEnd = (int) Math.pow(this.maxFanIn, scale)___			final int numMerges = (int) Math.ceil((numStart - numEnd) / (double) (this.maxFanIn - 1))___			final int numNotMerged = numEnd - numMerges__			final int numToMerge = numStart - numNotMerged___			_			final List<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>(numEnd)__			mergedChannelIDs.addAll(channelIDs.subList(0, numNotMerged))___			final int channelsToMergePerStep = (int) Math.ceil(numToMerge / (double) numMerges)___			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)___			final List<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = numNotMerged__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}__				mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__			}__			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,all,read,buffers,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,scale,math,ceil,math,log,channel,ids,size,math,log,this,max,fan,in,1,final,int,num,start,channel,ids,size,final,int,num,end,int,math,pow,this,max,fan,in,scale,final,int,num,merges,int,math,ceil,num,start,num,end,double,this,max,fan,in,1,final,int,num,not,merged,num,end,num,merges,final,int,num,to,merge,num,start,num,not,merged,final,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,num,end,merged,channel,ids,add,all,channel,ids,sub,list,0,num,not,merged,final,int,channels,to,merge,per,step,int,math,ceil,num,to,merge,double,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,num,not,merged,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1530185676;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param allReadBuffers_@param writeBuffers The buffers to be used by the writers._@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			_			_			final double scale = Math.ceil(Math.log(channelIDs.size()) / Math.log(this.maxFanIn)) - 1___			final int numStart = channelIDs.size()__			final int numEnd = (int) Math.pow(this.maxFanIn, scale)___			final int numMerges = (int) Math.ceil((numStart - numEnd) / (double) (this.maxFanIn - 1))___			final int numNotMerged = numEnd - numMerges__			final int numToMerge = numStart - numNotMerged___			_			final List<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>(numEnd)__			mergedChannelIDs.addAll(channelIDs.subList(0, numNotMerged))___			final int channelsToMergePerStep = (int) Math.ceil(numToMerge / (double) numMerges)___			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)___			final List<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = numNotMerged__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}__				mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__			}__			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,all,read,buffers,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,scale,math,ceil,math,log,channel,ids,size,math,log,this,max,fan,in,1,final,int,num,start,channel,ids,size,final,int,num,end,int,math,pow,this,max,fan,in,scale,final,int,num,merges,int,math,ceil,num,start,num,end,double,this,max,fan,in,1,final,int,num,not,merged,num,end,num,merges,final,int,num,to,merge,num,start,num,not,merged,final,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,num,end,merged,channel,ids,add,all,channel,ids,sub,list,0,num,not,merged,final,int,channels,to,merge,per,step,int,math,ceil,num,to,merge,double,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,num,not,merged,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs, 					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers) 		throws IOException;1533306679;Merges the given sorted runs to a smaller number of sorted runs.__@param channelIDs The IDs of the sorted runs that need to be merged._@param allReadBuffers_@param writeBuffers The buffers to be used by the writers._@return A list of the IDs of the merged channels._@throws IOException Thrown, if the readers or writers encountered an I/O problem.;protected final List<ChannelWithBlockCount> mergeChannelList(final List<ChannelWithBlockCount> channelIDs,_					final List<MemorySegment> allReadBuffers, final List<MemorySegment> writeBuffers)_		throws IOException_		{_			_			_			_			final double scale = Math.ceil(Math.log(channelIDs.size()) / Math.log(this.maxFanIn)) - 1___			final int numStart = channelIDs.size()__			final int numEnd = (int) Math.pow(this.maxFanIn, scale)___			final int numMerges = (int) Math.ceil((numStart - numEnd) / (double) (this.maxFanIn - 1))___			final int numNotMerged = numEnd - numMerges__			final int numToMerge = numStart - numNotMerged___			_			final List<ChannelWithBlockCount> mergedChannelIDs = new ArrayList<ChannelWithBlockCount>(numEnd)__			mergedChannelIDs.addAll(channelIDs.subList(0, numNotMerged))___			final int channelsToMergePerStep = (int) Math.ceil(numToMerge / (double) numMerges)___			_			final List<List<MemorySegment>> readBuffers = new ArrayList<List<MemorySegment>>(channelsToMergePerStep)__			getSegmentsForReaders(readBuffers, allReadBuffers, channelsToMergePerStep)___			final List<ChannelWithBlockCount> channelsToMergeThisStep = new ArrayList<ChannelWithBlockCount>(channelsToMergePerStep)__			int channelNum = numNotMerged__			while (isRunning() && channelNum < channelIDs.size()) {_				channelsToMergeThisStep.clear()___				for (int i = 0_ i < channelsToMergePerStep && channelNum < channelIDs.size()_ i++, channelNum++) {_					channelsToMergeThisStep.add(channelIDs.get(channelNum))__				}__				mergedChannelIDs.add(mergeChannels(channelsToMergeThisStep, readBuffers, writeBuffers))__			}__			return mergedChannelIDs__		};merges,the,given,sorted,runs,to,a,smaller,number,of,sorted,runs,param,channel,ids,the,ids,of,the,sorted,runs,that,need,to,be,merged,param,all,read,buffers,param,write,buffers,the,buffers,to,be,used,by,the,writers,return,a,list,of,the,ids,of,the,merged,channels,throws,ioexception,thrown,if,the,readers,or,writers,encountered,an,i,o,problem;protected,final,list,channel,with,block,count,merge,channel,list,final,list,channel,with,block,count,channel,ids,final,list,memory,segment,all,read,buffers,final,list,memory,segment,write,buffers,throws,ioexception,final,double,scale,math,ceil,math,log,channel,ids,size,math,log,this,max,fan,in,1,final,int,num,start,channel,ids,size,final,int,num,end,int,math,pow,this,max,fan,in,scale,final,int,num,merges,int,math,ceil,num,start,num,end,double,this,max,fan,in,1,final,int,num,not,merged,num,end,num,merges,final,int,num,to,merge,num,start,num,not,merged,final,list,channel,with,block,count,merged,channel,ids,new,array,list,channel,with,block,count,num,end,merged,channel,ids,add,all,channel,ids,sub,list,0,num,not,merged,final,int,channels,to,merge,per,step,int,math,ceil,num,to,merge,double,num,merges,final,list,list,memory,segment,read,buffers,new,array,list,list,memory,segment,channels,to,merge,per,step,get,segments,for,readers,read,buffers,all,read,buffers,channels,to,merge,per,step,final,list,channel,with,block,count,channels,to,merge,this,step,new,array,list,channel,with,block,count,channels,to,merge,per,step,int,channel,num,num,not,merged,while,is,running,channel,num,channel,ids,size,channels,to,merge,this,step,clear,for,int,i,0,i,channels,to,merge,per,step,channel,num,channel,ids,size,i,channel,num,channels,to,merge,this,step,add,channel,ids,get,channel,num,merged,channel,ids,add,merge,channels,channels,to,merge,this,step,read,buffers,write,buffers,return,merged,channel,ids
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList) 			throws IOException;1405024514;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size())__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = segsForChannel.size() >= 4 ? _					this.ioManager.createBlockChannelReader(channel.getChannel(), segsForChannel.size() / 2) :_					this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}__			return new MergeIterator<E>(iterators, this.serializer, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,block,channel,access,reader,list,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,segs,for,channel,size,4,this,io,manager,create,block,channel,reader,channel,get,channel,segs,for,channel,size,2,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,return,new,merge,iterator,e,iterators,this,serializer,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList) 			throws IOException;1405090423;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size())__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = segsForChannel.size() >= 4 ? _					this.ioManager.createBlockChannelReader(channel.getChannel(), segsForChannel.size() / 2) :_					this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}__			return new MergeIterator<E>(iterators, this.serializer, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,block,channel,access,reader,list,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,segs,for,channel,size,4,this,io,manager,create,block,channel,reader,channel,get,channel,segs,for,channel,size,2,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,return,new,merge,iterator,e,iterators,this,serializer,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList) 			throws IOException;1409911022;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size())__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = segsForChannel.size() >= 4 ? _					this.ioManager.createBlockChannelReader(channel.getChannel(), segsForChannel.size() / 2) :_					this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}__			return new MergeIterator<E>(iterators, this.serializer, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,block,channel,access,reader,list,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,segs,for,channel,size,4,this,io,manager,create,block,channel,reader,channel,get,channel,segs,for,channel,size,2,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,return,new,merge,iterator,e,iterators,this,serializer,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList) 			throws IOException;1411236168;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size())__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = segsForChannel.size() >= 4 ? _					this.ioManager.createBlockChannelReader(channel.getChannel(), segsForChannel.size() / 2) :_					this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}__			return new MergeIterator<E>(iterators, this.serializer, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,block,channel,access,reader,list,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,segs,for,channel,size,4,this,io,manager,create,block,channel,reader,channel,get,channel,segs,for,channel,size,2,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,return,new,merge,iterator,e,iterators,this,serializer,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList) 			throws IOException;1411236169;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size())__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = segsForChannel.size() >= 4 ? _					this.ioManager.createBlockChannelReader(channel.getChannel(), segsForChannel.size() / 2) :_					this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}__			return new MergeIterator<E>(iterators, this.serializer, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,block,channel,access,reader,list,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,segs,for,channel,size,4,this,io,manager,create,block,channel,reader,channel,get,channel,segs,for,channel,size,2,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,return,new,merge,iterator,e,iterators,this,serializer,this,comparator
UnilateralSortMerger -> SpillingThread -> protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs, 				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList) 			throws IOException;1411473593;Returns an iterator that iterates over the merged result from all given channels.__@param channelIDs The channels that are to be merged and returned._@param inputSegments The buffers to be used for reading. The list contains for each channel one_list of input segments. The size of the <code>inputSegments</code> list must be equal to_that of the <code>channelIDs</code> list._@return An iterator over the merged records of the input channels._@throws IOException Thrown, if the readers encounter an I/O problem.;protected final MergeIterator<E> getMergingIterator(final List<ChannelWithBlockCount> channelIDs,_				final List<List<MemorySegment>> inputSegments, List<BlockChannelAccess<?, ?>> readerList)_			throws IOException_		{_			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Performing merge of " + channelIDs.size() + " sorted streams.")__			}_			_			final List<MutableObjectIterator<E>> iterators = new ArrayList<MutableObjectIterator<E>>(channelIDs.size())__			_			for (int i = 0_ i < channelIDs.size()_ i++) {_				final ChannelWithBlockCount channel = channelIDs.get(i)__				final List<MemorySegment> segsForChannel = inputSegments.get(i)__				_				_				final BlockChannelReader reader = segsForChannel.size() >= 4 ? _					this.ioManager.createBlockChannelReader(channel.getChannel(), segsForChannel.size() / 2) :_					this.ioManager.createBlockChannelReader(channel.getChannel())__					_				readerList.add(reader)__				registerOpenChannelToBeRemovedAtShudown(reader)__				unregisterChannelToBeRemovedAtShudown(channel.getChannel())__				_				_				final ChannelReaderInputView inView = new ChannelReaderInputView(reader, segsForChannel, _																			channel.getBlockCount(), false)__				iterators.add(new ChannelReaderInputViewIterator<E>(inView, null, this.serializer))__			}__			return new MergeIterator<E>(iterators, this.serializer, this.comparator)__		};returns,an,iterator,that,iterates,over,the,merged,result,from,all,given,channels,param,channel,ids,the,channels,that,are,to,be,merged,and,returned,param,input,segments,the,buffers,to,be,used,for,reading,the,list,contains,for,each,channel,one,list,of,input,segments,the,size,of,the,code,input,segments,code,list,must,be,equal,to,that,of,the,code,channel,ids,code,list,return,an,iterator,over,the,merged,records,of,the,input,channels,throws,ioexception,thrown,if,the,readers,encounter,an,i,o,problem;protected,final,merge,iterator,e,get,merging,iterator,final,list,channel,with,block,count,channel,ids,final,list,list,memory,segment,input,segments,list,block,channel,access,reader,list,throws,ioexception,if,log,is,debug,enabled,log,debug,performing,merge,of,channel,ids,size,sorted,streams,final,list,mutable,object,iterator,e,iterators,new,array,list,mutable,object,iterator,e,channel,ids,size,for,int,i,0,i,channel,ids,size,i,final,channel,with,block,count,channel,channel,ids,get,i,final,list,memory,segment,segs,for,channel,input,segments,get,i,final,block,channel,reader,reader,segs,for,channel,size,4,this,io,manager,create,block,channel,reader,channel,get,channel,segs,for,channel,size,2,this,io,manager,create,block,channel,reader,channel,get,channel,reader,list,add,reader,register,open,channel,to,be,removed,at,shudown,reader,unregister,channel,to,be,removed,at,shudown,channel,get,channel,final,channel,reader,input,view,in,view,new,channel,reader,input,view,reader,segs,for,channel,channel,get,block,count,false,iterators,add,new,channel,reader,input,view,iterator,e,in,view,null,this,serializer,return,new,merge,iterator,e,iterators,this,serializer,this,comparator
