commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;32;;// -------------------------------------------------------------------------------------------- // Main life cycle methods that implement the iterative behavior // -------------------------------------------------------------------------------------------- @Override protected void initialize() throws Exception {     super.initialize().     // check if the driver is resettable     if (this.driver instanceof ResettableDriver) {         final ResettableDriver<?, ?> resDriver = (ResettableDriver<?, ?>) this.driver.         // make sure that the according inputs are not reset         for (int i = 0. i < resDriver.getNumberOfInputs(). i++) {             if (resDriver.isInputResettable(i)) {                 excludeFromReset(i).             }         }     }     TaskConfig config = getLastTasksConfig().     isWorksetIteration = config.getIsWorksetIteration().     isWorksetUpdate = config.getIsWorksetUpdate().     isSolutionSetUpdate = config.getIsSolutionSetUpdate().     if (isWorksetUpdate) {         worksetBackChannel = BlockingBackChannelBroker.instance().getAndRemove(brokerKey()).         if (isWorksetIteration) {             worksetAggregator = getIterationAggregators().getAggregator(WorksetEmptyConvergenceCriterion.AGGREGATOR_NAME).             if (worksetAggregator == null) {                 throw new RuntimeException("Missing workset elements count aggregator.").             }         }     } }
false;public;0;27;;@Override public void run() throws Exception {     if (inFirstIteration()) {         if (this.driver instanceof ResettableDriver) {             // initialize the repeatable driver             ((ResettableDriver<?, ?>) this.driver).initialize().         }     } else {         reinstantiateDriver().         resetAllInputs().         // re-read the iterative broadcast variables         for (int i : this.iterativeBroadcastInputs) {             final String name = getTaskConfig().getBroadcastInputName(i).             readAndSetBroadcastInput(i, name, this.runtimeUdfContext, superstepNum).         }     }     // call the parent to execute the superstep     super.run().     // release the iterative broadcast variables     for (int i : this.iterativeBroadcastInputs) {         final String name = getTaskConfig().getBroadcastInputName(i).         releaseBroadcastVariables(name, superstepNum, this.runtimeUdfContext).     } }
false;protected;0;16;;@Override protected void closeLocalStrategiesAndCaches() {     try {         super.closeLocalStrategiesAndCaches().     } finally {         if (this.driver instanceof ResettableDriver) {             final ResettableDriver<?, ?> resDriver = (ResettableDriver<?, ?>) this.driver.             try {                 resDriver.teardown().             } catch (Throwable t) {                 log.error("Error while shutting down an iterative operator.", t).             }         }     } }
false;public;1;6;;@Override public DistributedRuntimeUDFContext createRuntimeContext(MetricGroup metrics) {     Environment env = getEnvironment().     return new IterativeRuntimeUdfContext(env.getTaskInfo(), getUserCodeClassLoader(), getExecutionConfig(), env.getDistributedCacheEntries(), this.accumulatorMap, metrics). }
false;protected;0;3;;// -------------------------------------------------------------------------------------------- // Utility Methods for Iteration Handling // -------------------------------------------------------------------------------------------- protected boolean inFirstIteration() {     return this.superstepNum == 1. }
false;protected;0;3;;protected int currentIteration() {     return this.superstepNum. }
false;protected;0;3;;protected void incrementIterationCounter() {     this.superstepNum++. }
false;public;0;8;;public String brokerKey() {     if (brokerKey == null) {         int iterationId = config.getIterationId().         brokerKey = getEnvironment().getJobID().toString() + '#' + iterationId + '#' + getEnvironment().getTaskInfo().getIndexOfThisSubtask().     }     return brokerKey. }
false;private;0;17;;private void reinstantiateDriver() throws Exception {     if (this.driver instanceof ResettableDriver) {         final ResettableDriver<?, ?> resDriver = (ResettableDriver<?, ?>) this.driver.         resDriver.reset().     } else {         Class<? extends Driver<S, OT>> driverClass = this.config.getDriver().         this.driver = InstantiationUtil.instantiate(driverClass, Driver.class).         try {             this.driver.setup(this).         } catch (Throwable t) {             throw new Exception("The pact driver setup for '" + this.getEnvironment().getTaskInfo().getTaskName() + "' , caused an error: " + t.getMessage(), t).         }     } }
false;public;0;6;;public RuntimeAggregatorRegistry getIterationAggregators() {     if (this.iterationAggregators == null) {         this.iterationAggregators = IterationAggregatorBroker.instance().get(brokerKey()).     }     return this.iterationAggregators. }
false;protected;0;43;;protected void verifyEndOfSuperstepState() throws IOException {     // sanity check that there is at least one iterative input reader     if (this.iterativeInputs.length == 0 && this.iterativeBroadcastInputs.length == 0) {         throw new IllegalStateException("Error: Iterative task without a single iterative input.").     }     for (int inputNum : this.iterativeInputs) {         MutableReader<?> reader = this.inputReaders[inputNum].         if (!reader.isFinished()) {             if (reader.hasReachedEndOfSuperstep()) {                 reader.startNextSuperstep().             } else {                 // need to read and drop all non-consumed data until we reach the end-of-superstep                 @SuppressWarnings("unchecked")                 MutableObjectIterator<Object> inIter = (MutableObjectIterator<Object>) this.inputIterators[inputNum].                 Object o = this.inputSerializers[inputNum].getSerializer().createInstance().                 while ((o = inIter.next(o)) != null) {                 }                 if (!reader.isFinished()) {                     // also reset the end-of-superstep state                     reader.startNextSuperstep().                 }             }         }     }     for (int inputNum : this.iterativeBroadcastInputs) {         MutableReader<?> reader = this.broadcastInputReaders[inputNum].         if (!reader.isFinished()) {             // sanity check that the BC input is at the end of the superstep             if (!reader.hasReachedEndOfSuperstep()) {                 throw new IllegalStateException("An iterative broadcast input has not been fully consumed.").             }             reader.startNextSuperstep().         }     } }
false;public;0;4;;@Override public boolean terminationRequested() {     return this.terminationRequested. }
false;public;0;4;;@Override public void requestTermination() {     this.terminationRequested = true. }
false;public;0;5;;@Override public void cancel() throws Exception {     requestTermination().     super.cancel(). }
true;protected;1;5;/**  * Creates a new {@link WorksetUpdateOutputCollector}.  *  * <p>This collector is used by {@link IterationIntermediateTask} or {@link IterationTailTask} to update the  * workset.  *  * <p>If a non-null delegate is given, the new {@link Collector} will write to the solution set and also call  * collect(T) of the delegate.  *  * @param delegate null -OR- the delegate on which to call collect() by the newly created collector  * @return a new {@link WorksetUpdateOutputCollector}  */ ;// ----------------------------------------------------------------------------------------------------------------- // Iteration State Update Handling // ----------------------------------------------------------------------------------------------------------------- /**  * Creates a new {@link WorksetUpdateOutputCollector}.  *  * <p>This collector is used by {@link IterationIntermediateTask} or {@link IterationTailTask} to update the  * workset.  *  * <p>If a non-null delegate is given, the new {@link Collector} will write to the solution set and also call  * collect(T) of the delegate.  *  * @param delegate null -OR- the delegate on which to call collect() by the newly created collector  * @return a new {@link WorksetUpdateOutputCollector}  */ protected Collector<OT> createWorksetUpdateOutputCollector(Collector<OT> delegate) {     DataOutputView outputView = worksetBackChannel.getWriteEnd().     TypeSerializer<OT> serializer = getOutputSerializer().     return new WorksetUpdateOutputCollector<OT>(outputView, serializer, delegate). }
false;protected;0;3;;protected Collector<OT> createWorksetUpdateOutputCollector() {     return createWorksetUpdateOutputCollector(null). }
true;protected;1;17;/**  * Creates a new solution set update output collector.  *  * <p>This collector is used by {@link IterationIntermediateTask} or {@link IterationTailTask} to update the  * solution set of workset iterations. Depending on the task configuration, either a fast (non-probing)  * {@link org.apache.flink.runtime.iterative.io.SolutionSetFastUpdateOutputCollector} or normal (re-probing)  * {@link SolutionSetUpdateOutputCollector} is created.  *  * <p>If a non-null delegate is given, the new {@link Collector} will write back to the solution set and also call  * collect(T) of the delegate.  *  * @param delegate null -OR- a delegate collector to be called by the newly created collector  * @return a new {@link org.apache.flink.runtime.iterative.io.SolutionSetFastUpdateOutputCollector} or  * {@link SolutionSetUpdateOutputCollector}  */ ;/**  * Creates a new solution set update output collector.  *  * <p>This collector is used by {@link IterationIntermediateTask} or {@link IterationTailTask} to update the  * solution set of workset iterations. Depending on the task configuration, either a fast (non-probing)  * {@link org.apache.flink.runtime.iterative.io.SolutionSetFastUpdateOutputCollector} or normal (re-probing)  * {@link SolutionSetUpdateOutputCollector} is created.  *  * <p>If a non-null delegate is given, the new {@link Collector} will write back to the solution set and also call  * collect(T) of the delegate.  *  * @param delegate null -OR- a delegate collector to be called by the newly created collector  * @return a new {@link org.apache.flink.runtime.iterative.io.SolutionSetFastUpdateOutputCollector} or  * {@link SolutionSetUpdateOutputCollector}  */ protected Collector<OT> createSolutionSetUpdateOutputCollector(Collector<OT> delegate) {     Broker<Object> solutionSetBroker = SolutionSetBroker.instance().     Object ss = solutionSetBroker.get(brokerKey()).     if (ss instanceof CompactingHashTable) {         @SuppressWarnings("unchecked")         CompactingHashTable<OT> solutionSet = (CompactingHashTable<OT>) ss.         return new SolutionSetUpdateOutputCollector<OT>(solutionSet, delegate).     } else if (ss instanceof JoinHashMap) {         @SuppressWarnings("unchecked")         JoinHashMap<OT> map = (JoinHashMap<OT>) ss.         return new SolutionSetObjectsUpdateOutputCollector<OT>(map, delegate).     } else {         throw new RuntimeException("Unrecognized solution set handle: " + ss).     } }
true;private;0;10;/**  * @return output serializer of this task  */ ;/**  * @return output serializer of this task  */ private TypeSerializer<OT> getOutputSerializer() {     TypeSerializerFactory<OT> serializerFactory.     if ((serializerFactory = getLastTasksConfig().getOutputSerializer(getUserCodeClassLoader())) == null) {         throw new RuntimeException("Missing output serializer for workset update.").     }     return serializerFactory.getSerializer(). }
false;public;0;4;;@Override public int getSuperstepNumber() {     return AbstractIterativeTask.this.superstepNum. }
false;public;1;4;;@Override public <T extends Aggregator<?>> T getIterationAggregator(String name) {     return getIterationAggregators().<T>getAggregator(name). }
false;public;1;5;;@Override @SuppressWarnings("unchecked") public <T extends Value> T getPreviousIterationAggregate(String name) {     return (T) getIterationAggregators().getPreviousGlobalAggregate(name). }
false;public;2;7;;@Override public <V, A extends Serializable> void addAccumulator(String name, Accumulator<V, A> newAccumulator) {     // only add accumulator on first iteration     if (inFirstIteration()) {         super.addAccumulator(name, newAccumulator).     } }
