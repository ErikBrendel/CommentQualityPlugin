commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;// ------------------------------------------------------------------------ // Input channel/receiver registration // ------------------------------------------------------------------------ @Override public void addInputChannel(RemoteInputChannel listener) throws IOException {     checkError().     inputChannels.putIfAbsent(listener.getInputChannelId(), listener). }
false;public;1;4;;@Override public void removeInputChannel(RemoteInputChannel listener) {     inputChannels.remove(listener.getInputChannelId()). }
false;public;1;10;;@Override public void cancelRequestFor(InputChannelID inputChannelId) {     if (inputChannelId == null || ctx == null) {         return.     }     if (cancelled.putIfAbsent(inputChannelId, inputChannelId) == null) {         ctx.writeAndFlush(new NettyMessage.CancelPartitionRequest(inputChannelId)).     } }
false;public;1;4;;@Override public void notifyCreditAvailable(final RemoteInputChannel inputChannel) {     ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(inputChannel)). }
false;public;1;8;;// ------------------------------------------------------------------------ // Network events // ------------------------------------------------------------------------ @Override public void channelActive(final ChannelHandlerContext ctx) throws Exception {     if (this.ctx == null) {         this.ctx = ctx.     }     super.channelActive(ctx). }
false;public;1;14;;@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {     // channels have been removed. This indicates a problem with the remote task manager.     if (!inputChannels.isEmpty()) {         final SocketAddress remoteAddr = ctx.channel().remoteAddress().         notifyAllChannelsOfErrorAndClose(new RemoteTransportException("Connection unexpectedly closed by remote task manager '" + remoteAddr + "'. " + "This might indicate that the remote task manager was lost.", remoteAddr)).     }     super.channelInactive(ctx). }
true;public;2;22;/**  * Called on exceptions in the client handler pipeline.  *  * <p>Remote exceptions are received as regular payload.  */ ;/**  * Called on exceptions in the client handler pipeline.  *  * <p>Remote exceptions are received as regular payload.  */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {     if (cause instanceof TransportException) {         notifyAllChannelsOfErrorAndClose(cause).     } else {         final SocketAddress remoteAddr = ctx.channel().remoteAddress().         final TransportException tex.         // Improve on the connection reset by peer error message         if (cause instanceof IOException && cause.getMessage().equals("Connection reset by peer")) {             tex = new RemoteTransportException("Lost connection to task manager '" + remoteAddr + "'. " + "This indicates that the remote task manager was lost.", remoteAddr, cause).         } else {             final SocketAddress localAddr = ctx.channel().localAddress().             tex = new LocalTransportException(String.format("%s (connection to '%s')", cause.getMessage(), remoteAddr), localAddr, cause).         }         notifyAllChannelsOfErrorAndClose(tex).     } }
false;public;2;8;;@Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {     try {         decodeMsg(msg).     } catch (Throwable t) {         notifyAllChannelsOfErrorAndClose(t).     } }
true;public;2;14;/**  * Triggered by notifying credit available in the client handler pipeline.  *  * <p>Enqueues the input channel and will trigger write&flush unannounced credits  * for this input channel if it is the first one in the queue.  */ ;/**  * Triggered by notifying credit available in the client handler pipeline.  *  * <p>Enqueues the input channel and will trigger write&flush unannounced credits  * for this input channel if it is the first one in the queue.  */ @Override public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {     if (msg instanceof RemoteInputChannel) {         boolean triggerWrite = inputChannelsWithCredit.isEmpty().         inputChannelsWithCredit.add((RemoteInputChannel) msg).         if (triggerWrite) {             writeAndFlushNextMessageIfPossible(ctx.channel()).         }     } else {         ctx.fireUserEventTriggered(msg).     } }
false;public;1;4;;@Override public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {     writeAndFlushNextMessageIfPossible(ctx.channel()). }
false;private;1;19;;private void notifyAllChannelsOfErrorAndClose(Throwable cause) {     if (channelError.compareAndSet(null, cause)) {         try {             for (RemoteInputChannel inputChannel : inputChannels.values()) {                 inputChannel.onError(cause).             }         } catch (Throwable t) {             // We can only swallow the Exception at this point. :(             LOG.warn("An Exception was thrown during error notification of a remote input channel.", t).         } finally {             inputChannels.clear().             inputChannelsWithCredit.clear().             if (ctx != null) {                 ctx.close().             }         }     } }
true;private;0;11;/**  * Checks for an error and rethrows it if one was reported.  */ ;// ------------------------------------------------------------------------ /**  * Checks for an error and rethrows it if one was reported.  */ private void checkError() throws IOException {     final Throwable t = channelError.get().     if (t != null) {         if (t instanceof IOException) {             throw (IOException) t.         } else {             throw new IOException("There has been an error in the channel.", t).         }     } }
false;private;1;47;;private void decodeMsg(Object msg) throws Throwable {     final Class<?> msgClazz = msg.getClass().     // ---- Buffer --------------------------------------------------------     if (msgClazz == NettyMessage.BufferResponse.class) {         NettyMessage.BufferResponse bufferOrEvent = (NettyMessage.BufferResponse) msg.         RemoteInputChannel inputChannel = inputChannels.get(bufferOrEvent.receiverId).         if (inputChannel == null) {             bufferOrEvent.releaseBuffer().             cancelRequestFor(bufferOrEvent.receiverId).             return.         }         decodeBufferOrEvent(inputChannel, bufferOrEvent).     } else if (msgClazz == NettyMessage.ErrorResponse.class) {         // ---- Error ---------------------------------------------------------         NettyMessage.ErrorResponse error = (NettyMessage.ErrorResponse) msg.         SocketAddress remoteAddr = ctx.channel().remoteAddress().         if (error.isFatalError()) {             notifyAllChannelsOfErrorAndClose(new RemoteTransportException("Fatal error at remote task manager '" + remoteAddr + "'.", remoteAddr, error.cause)).         } else {             RemoteInputChannel inputChannel = inputChannels.get(error.receiverId).             if (inputChannel != null) {                 if (error.cause.getClass() == PartitionNotFoundException.class) {                     inputChannel.onFailedPartitionRequest().                 } else {                     inputChannel.onError(new RemoteTransportException("Error at remote task manager '" + remoteAddr + "'.", remoteAddr, error.cause)).                 }             }         }     } else {         throw new IllegalStateException("Received unknown message from producer: " + msg.getClass()).     } }
false;private;2;39;;private void decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent) throws Throwable {     try {         ByteBuf nettyBuffer = bufferOrEvent.getNettyBuffer().         final int receivedSize = nettyBuffer.readableBytes().         if (bufferOrEvent.isBuffer()) {             // IndexOutOfBoundsException.             if (receivedSize == 0) {                 inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog).                 return.             }             Buffer buffer = inputChannel.requestBuffer().             if (buffer != null) {                 nettyBuffer.readBytes(buffer.asByteBuf(), receivedSize).                 inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber, bufferOrEvent.backlog).             } else if (inputChannel.isReleased()) {                 cancelRequestFor(bufferOrEvent.receiverId).             } else {                 throw new IllegalStateException("No buffer available in credit-based input channel.").             }         } else {             // ---- Event -------------------------------------------------             // TODO We can just keep the serialized data in the Netty buffer and release it later at the reader             byte[] byteArray = new byte[receivedSize].             nettyBuffer.readBytes(byteArray).             MemorySegment memSeg = MemorySegmentFactory.wrap(byteArray).             Buffer buffer = new NetworkBuffer(memSeg, FreeingBufferRecycler.INSTANCE, false, receivedSize).             inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber, bufferOrEvent.backlog).         }     } finally {         bufferOrEvent.releaseBuffer().     } }
true;private;1;29;/**  * Tries to write&flush unannounced credits for the next input channel in queue.  *  * <p>This method may be called by the first input channel enqueuing, or the complete  * future's callback in previous input channel, or the channel writability changed event.  */ ;/**  * Tries to write&flush unannounced credits for the next input channel in queue.  *  * <p>This method may be called by the first input channel enqueuing, or the complete  * future's callback in previous input channel, or the channel writability changed event.  */ private void writeAndFlushNextMessageIfPossible(Channel channel) {     if (channelError.get() != null || !channel.isWritable()) {         return.     }     while (true) {         RemoteInputChannel inputChannel = inputChannelsWithCredit.poll().         // that are executed after each write.         if (inputChannel == null) {             return.         }         // It is no need to notify credit for the released channel.         if (!inputChannel.isReleased()) {             AddCredit msg = new AddCredit(inputChannel.getPartitionId(), inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId()).             // Write and flush and wait until this is done before             // trying to continue with the next input channel.             channel.writeAndFlush(msg).addListener(writeListener).             return.         }     } }
false;public;1;14;;@Override public void operationComplete(ChannelFuture future) throws Exception {     try {         if (future.isSuccess()) {             writeAndFlushNextMessageIfPossible(future.channel()).         } else if (future.cause() != null) {             notifyAllChannelsOfErrorAndClose(future.cause()).         } else {             notifyAllChannelsOfErrorAndClose(new IllegalStateException("Sending cancelled by user.")).         }     } catch (Throwable t) {         notifyAllChannelsOfErrorAndClose(t).     } }
