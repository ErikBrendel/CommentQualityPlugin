commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// -------------------------------------------------------------------------------------------- // Properties // -------------------------------------------------------------------------------------------- public ResultPartitionManager getResultPartitionManager() {     return resultPartitionManager. }
false;public;0;3;;public TaskEventDispatcher getTaskEventDispatcher() {     return taskEventDispatcher. }
false;public;0;3;;public ConnectionManager getConnectionManager() {     return connectionManager. }
false;public;0;3;;public NetworkBufferPool getNetworkBufferPool() {     return networkBufferPool. }
false;public;0;3;;public IOMode getDefaultIOMode() {     return defaultIOMode. }
false;public;0;3;;public int getPartitionRequestInitialBackoff() {     return partitionRequestInitialBackoff. }
false;public;0;3;;public int getPartitionRequestMaxBackoff() {     return partitionRequestMaxBackoff. }
false;public;0;3;;public boolean isCreditBased() {     return enableCreditBased. }
false;public;0;3;;public KvStateRegistry getKvStateRegistry() {     return kvStateRegistry. }
false;public;0;3;;public KvStateServer getKvStateServer() {     return kvStateServer. }
false;public;0;3;;public KvStateClientProxy getKvStateProxy() {     return kvStateProxy. }
false;public;2;3;;public TaskKvStateRegistry createKvStateTaskRegistry(JobID jobId, JobVertexID jobVertexId) {     return kvStateRegistry.createTaskRegistry(jobId, jobVertexId). }
false;public;1;19;;// -------------------------------------------------------------------------------------------- // Task operations // -------------------------------------------------------------------------------------------- public void registerTask(Task task) throws IOException {     final ResultPartition[] producedPartitions = task.getProducedPartitions().     synchronized (lock) {         if (isShutdown) {             throw new IllegalStateException("NetworkEnvironment is shut down").         }         for (final ResultPartition partition : producedPartitions) {             setupPartition(partition).         }         // Setup the buffer pool for each buffer reader         final SingleInputGate[] inputGates = task.getAllInputGates().         for (SingleInputGate gate : inputGates) {             setupInputGate(gate).         }     } }
false;public;1;31;;@VisibleForTesting public void setupPartition(ResultPartition partition) throws IOException {     BufferPool bufferPool = null.     try {         int maxNumberOfMemorySegments = partition.getPartitionType().isBounded() ? partition.getNumberOfSubpartitions() * networkBuffersPerChannel + extraNetworkBuffersPerGate : Integer.MAX_VALUE.         // If the partition type is back pressure-free, we register with the buffer pool for         // callbacks to release memory.         bufferPool = networkBufferPool.createBufferPool(partition.getNumberOfSubpartitions(), maxNumberOfMemorySegments, partition.getPartitionType().hasBackPressure() ? Optional.empty() : Optional.of(partition)).         partition.registerBufferPool(bufferPool).         resultPartitionManager.registerResultPartition(partition).     } catch (Throwable t) {         if (bufferPool != null) {             bufferPool.lazyDestroy().         }         if (t instanceof IOException) {             throw (IOException) t.         } else {             throw new IOException(t.getMessage(), t).         }     }     taskEventDispatcher.registerPartition(partition.getPartitionId()). }
false;public;1;29;;@VisibleForTesting public void setupInputGate(SingleInputGate gate) throws IOException {     BufferPool bufferPool = null.     int maxNumberOfMemorySegments.     try {         if (enableCreditBased) {             maxNumberOfMemorySegments = gate.getConsumedPartitionType().isBounded() ? extraNetworkBuffersPerGate : Integer.MAX_VALUE.             // assign exclusive buffers to input channels directly and use the rest for floating buffers             gate.assignExclusiveSegments(networkBufferPool, networkBuffersPerChannel).             bufferPool = networkBufferPool.createBufferPool(0, maxNumberOfMemorySegments).         } else {             maxNumberOfMemorySegments = gate.getConsumedPartitionType().isBounded() ? gate.getNumberOfInputChannels() * networkBuffersPerChannel + extraNetworkBuffersPerGate : Integer.MAX_VALUE.             bufferPool = networkBufferPool.createBufferPool(gate.getNumberOfInputChannels(), maxNumberOfMemorySegments).         }         gate.setBufferPool(bufferPool).     } catch (Throwable t) {         if (bufferPool != null) {             bufferPool.lazyDestroy().         }         ExceptionUtils.rethrowIOException(t).     } }
false;public;1;37;;public void unregisterTask(Task task) {     LOG.debug("Unregister task {} from network environment (state: {}).", task.getTaskInfo().getTaskNameWithSubtasks(), task.getExecutionState()).     final ExecutionAttemptID executionId = task.getExecutionId().     synchronized (lock) {         if (isShutdown) {             // no need to do anything when we are not operational             return.         }         if (task.isCanceledOrFailed()) {             resultPartitionManager.releasePartitionsProducedBy(executionId, task.getFailureCause()).         }         for (ResultPartition partition : task.getProducedPartitions()) {             taskEventDispatcher.unregisterPartition(partition.getPartitionId()).             partition.destroyBufferPool().         }         final SingleInputGate[] inputGates = task.getAllInputGates().         if (inputGates != null) {             for (SingleInputGate gate : inputGates) {                 try {                     if (gate != null) {                         gate.releaseAllResources().                     }                 } catch (IOException e) {                     LOG.error("Error during release of reader resources: " + e.getMessage(), e).                 }             }         }     } }
false;public;0;34;;public void start() throws IOException {     synchronized (lock) {         Preconditions.checkState(!isShutdown, "The NetworkEnvironment has already been shut down.").         LOG.info("Starting the network environment and its components.").         try {             LOG.debug("Starting network connection manager").             connectionManager.start(resultPartitionManager, taskEventDispatcher).         } catch (IOException t) {             throw new IOException("Failed to instantiate network connection manager.", t).         }         if (kvStateServer != null) {             try {                 kvStateServer.start().             } catch (Throwable ie) {                 kvStateServer.shutdown().                 kvStateServer = null.                 LOG.error("Failed to start the Queryable State Data Server.", ie).             }         }         if (kvStateProxy != null) {             try {                 kvStateProxy.start().             } catch (Throwable ie) {                 kvStateProxy.shutdown().                 kvStateProxy = null.                 LOG.error("Failed to start the Queryable State Client Proxy.", ie).             }         }     } }
true;public;0;60;/**  * Tries to shut down all network I/O components.  */ ;/**  * Tries to shut down all network I/O components.  */ public void shutdown() {     synchronized (lock) {         if (isShutdown) {             return.         }         LOG.info("Shutting down the network environment and its components.").         if (kvStateProxy != null) {             try {                 LOG.debug("Shutting down Queryable State Client Proxy.").                 kvStateProxy.shutdown().             } catch (Throwable t) {                 LOG.warn("Cannot shut down Queryable State Client Proxy.", t).             }         }         if (kvStateServer != null) {             try {                 LOG.debug("Shutting down Queryable State Data Server.").                 kvStateServer.shutdown().             } catch (Throwable t) {                 LOG.warn("Cannot shut down Queryable State Data Server.", t).             }         }         // terminate all network connections         try {             LOG.debug("Shutting down network connection manager").             connectionManager.shutdown().         } catch (Throwable t) {             LOG.warn("Cannot shut down the network connection manager.", t).         }         // shutdown all intermediate results         try {             LOG.debug("Shutting down intermediate result partition manager").             resultPartitionManager.shutdown().         } catch (Throwable t) {             LOG.warn("Cannot shut down the result partition manager.", t).         }         taskEventDispatcher.clearAll().         // make sure that the global buffer pool re-acquires all buffers         networkBufferPool.destroyAllBufferPools().         // destroy the buffer pool         try {             networkBufferPool.destroy().         } catch (Throwable t) {             LOG.warn("Network buffer pool did not shut down properly.", t).         }         isShutdown = true.     } }
false;public;0;5;;public boolean isShutdown() {     synchronized (lock) {         return isShutdown.     } }
