commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Returns the MetricStore containing all stored metrics.  *  * @return MetricStore containing all stored metrics.  */ ;/**  * Returns the MetricStore containing all stored metrics.  *  * @return MetricStore containing all stored metrics.  */ @Override public MetricStore getMetricStore() {     return metrics. }
true;public;0;10;/**  * This method can be used to signal this MetricFetcher that the metrics are still in use and should be updated.  */ ;/**  * This method can be used to signal this MetricFetcher that the metrics are still in use and should be updated.  */ @Override public void update() {     synchronized (this) {         long currentTime = System.currentTimeMillis().         if (currentTime - lastUpdateTime > updateInterval) {             lastUpdateTime = currentTime.             fetchMetrics().         }     } }
false;private;0;70;;private void fetchMetrics() {     LOG.debug("Start fetching metrics.").     try {         Optional<T> optionalLeaderGateway = retriever.getNow().         if (optionalLeaderGateway.isPresent()) {             final T leaderGateway = optionalLeaderGateway.get().             /* 				 * Remove all metrics that belong to a job that is not running and no longer archived. 				 */             CompletableFuture<MultipleJobsDetails> jobDetailsFuture = leaderGateway.requestMultipleJobDetails(timeout).             jobDetailsFuture.whenCompleteAsync((MultipleJobsDetails jobDetails, Throwable throwable) -> {                 if (throwable != null) {                     LOG.debug("Fetching of JobDetails failed.", throwable).                 } else {                     ArrayList<String> toRetain = new ArrayList<>(jobDetails.getJobs().size()).                     for (JobDetails job : jobDetails.getJobs()) {                         toRetain.add(job.getJobId().toString()).                     }                     metrics.retainJobs(toRetain).                 }             }, executor).             CompletableFuture<Collection<String>> queryServicePathsFuture = leaderGateway.requestMetricQueryServicePaths(timeout).             queryServicePathsFuture.whenCompleteAsync((Collection<String> queryServicePaths, Throwable throwable) -> {                 if (throwable != null) {                     LOG.warn("Requesting paths for query services failed.", throwable).                 } else {                     for (String queryServicePath : queryServicePaths) {                         retrieveAndQueryMetrics(queryServicePath).                     }                 }             }, executor).             // TODO: Once the old code has been ditched, remove the explicit TaskManager query service discovery             // TODO: and return it as part of requestQueryServicePaths. Moreover, change the MetricStore such that             // TODO: we don't have to explicitly retain the valid TaskManagers, e.g. letting it be a cache with expiry time             CompletableFuture<Collection<Tuple2<ResourceID, String>>> taskManagerQueryServicePathsFuture = leaderGateway.requestTaskManagerMetricQueryServicePaths(timeout).             taskManagerQueryServicePathsFuture.whenCompleteAsync((Collection<Tuple2<ResourceID, String>> queryServicePaths, Throwable throwable) -> {                 if (throwable != null) {                     LOG.warn("Requesting TaskManager's path for query services failed.", throwable).                 } else {                     List<String> taskManagersToRetain = queryServicePaths.stream().map((Tuple2<ResourceID, String> tuple) -> {                         retrieveAndQueryMetrics(tuple.f1).                         return tuple.f0.getResourceIdString().                     }).collect(Collectors.toList()).                     metrics.retainTaskManagers(taskManagersToRetain).                 }             }, executor).         }     } catch (Exception e) {         LOG.warn("Exception while fetching metrics.", e).     } }
true;private;1;15;/**  * Retrieves and queries the specified QueryServiceGateway.  *  * @param queryServicePath specifying the QueryServiceGateway  */ ;/**  * Retrieves and queries the specified QueryServiceGateway.  *  * @param queryServicePath specifying the QueryServiceGateway  */ private void retrieveAndQueryMetrics(String queryServicePath) {     LOG.debug("Retrieve metric query service gateway for {}", queryServicePath).     final CompletableFuture<MetricQueryServiceGateway> queryServiceGatewayFuture = queryServiceRetriever.retrieveService(queryServicePath).     queryServiceGatewayFuture.whenCompleteAsync((MetricQueryServiceGateway queryServiceGateway, Throwable t) -> {         if (t != null) {             LOG.debug("Could not retrieve QueryServiceGateway.", t).         } else {             queryMetrics(queryServiceGateway).         }     }, executor). }
true;private;1;15;/**  * Query the metrics from the given QueryServiceGateway.  *  * @param queryServiceGateway to query for metrics  */ ;/**  * Query the metrics from the given QueryServiceGateway.  *  * @param queryServiceGateway to query for metrics  */ private void queryMetrics(final MetricQueryServiceGateway queryServiceGateway) {     LOG.debug("Query metrics for {}.", queryServiceGateway.getAddress()).     queryServiceGateway.queryMetrics(timeout).whenCompleteAsync((MetricDumpSerialization.MetricSerializationResult result, Throwable t) -> {         if (t != null) {             LOG.debug("Fetching metrics failed.", t).         } else {             metrics.addAll(deserializer.deserialize(result)).         }     }, executor). }
false;public,static;4;16;;@Nonnull public static <T extends RestfulGateway> MetricFetcherImpl<T> fromConfiguration(final Configuration configuration, final MetricQueryServiceRetriever metricQueryServiceRetriever, final GatewayRetriever<T> dispatcherGatewayRetriever, final ExecutorService executor) {     final Time timeout = Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT)).     final long updateInterval = configuration.getLong(MetricOptions.METRIC_FETCHER_UPDATE_INTERVAL).     return new MetricFetcherImpl<>(dispatcherGatewayRetriever, metricQueryServiceRetriever, executor, timeout, updateInterval). }
