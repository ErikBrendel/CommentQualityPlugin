commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;// ------------------------------------------------------------------------ @Override public void setup(TaskContext<CoGroupFunction<IT1, IT2, OT>, OT> context) {     this.taskContext = context.     this.running = true. }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 2. }
false;public;0;6;;@Override public Class<CoGroupFunction<IT1, IT2, OT>> getStubType() {     @SuppressWarnings("unchecked")     final Class<CoGroupFunction<IT1, IT2, OT>> clazz = (Class<CoGroupFunction<IT1, IT2, OT>>) (Class<?>) CoGroupFunction.class.     return clazz. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 2. }
false;public;0;55;;@Override public void prepare() throws Exception {     final TaskConfig config = this.taskContext.getTaskConfig().     if (config.getDriverStrategy() != DriverStrategy.CO_GROUP) {         throw new Exception("Unrecognized driver strategy for CoGoup driver: " + config.getDriverStrategy().name()).     }     final Counter numRecordsIn = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsInCounter().     final MutableObjectIterator<IT1> in1 = new CountingMutableObjectIterator<>(this.taskContext.<IT1>getInput(0), numRecordsIn).     final MutableObjectIterator<IT2> in2 = new CountingMutableObjectIterator<>(this.taskContext.<IT2>getInput(1), numRecordsIn).     // get the key positions and types     final TypeSerializer<IT1> serializer1 = this.taskContext.<IT1>getInputSerializer(0).getSerializer().     final TypeSerializer<IT2> serializer2 = this.taskContext.<IT2>getInputSerializer(1).getSerializer().     final TypeComparator<IT1> groupComparator1 = this.taskContext.getDriverComparator(0).     final TypeComparator<IT2> groupComparator2 = this.taskContext.getDriverComparator(1).     final TypePairComparatorFactory<IT1, IT2> pairComparatorFactory = config.getPairComparatorFactory(this.taskContext.getUserCodeClassLoader()).     if (pairComparatorFactory == null) {         throw new Exception("Missing pair comparator factory for CoGroup driver").     }     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     this.objectReuseEnabled = executionConfig.isObjectReuseEnabled().     if (LOG.isDebugEnabled()) {         LOG.debug("CoGroupDriver object reuse: " + (this.objectReuseEnabled ? "ENABLED" : "DISABLED") + ".").     }     if (objectReuseEnabled) {         // create CoGroupTaskIterator according to provided local strategy.         this.coGroupIterator = new ReusingSortMergeCoGroupIterator<IT1, IT2>(in1, in2, serializer1, groupComparator1, serializer2, groupComparator2, pairComparatorFactory.createComparator12(groupComparator1, groupComparator2)).     } else {         // create CoGroupTaskIterator according to provided local strategy.         this.coGroupIterator = new NonReusingSortMergeCoGroupIterator<IT1, IT2>(in1, in2, serializer1, groupComparator1, serializer2, groupComparator2, pairComparatorFactory.createComparator12(groupComparator1, groupComparator2)).     }     // open CoGroupTaskIterator - this triggers the sorting and blocks until the iterator is ready     this.coGroupIterator.open().     if (LOG.isDebugEnabled()) {         LOG.debug(this.taskContext.formatLogString("CoGroup task iterator ready.")).     } }
false;public;0;13;;@Override public void run() throws Exception {     final Counter numRecordsOut = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsOutCounter().     final CoGroupFunction<IT1, IT2, OT> coGroupStub = this.taskContext.getStub().     final Collector<OT> collector = new CountingCollector<>(this.taskContext.getOutputCollector(), numRecordsOut).     final CoGroupTaskIterator<IT1, IT2> coGroupIterator = this.coGroupIterator.     while (this.running && coGroupIterator.next()) {         coGroupStub.coGroup(coGroupIterator.getValues1(), coGroupIterator.getValues2(), collector).     } }
false;public;0;7;;@Override public void cleanup() throws Exception {     if (this.coGroupIterator != null) {         this.coGroupIterator.close().         this.coGroupIterator = null.     } }
false;public;0;5;;@Override public void cancel() throws Exception {     this.running = false.     cleanup(). }
