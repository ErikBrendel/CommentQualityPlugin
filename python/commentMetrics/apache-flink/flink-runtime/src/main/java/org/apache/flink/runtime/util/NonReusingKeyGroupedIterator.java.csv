commented;modifiers;parameterAmount;loc;comment;code
true;public;0;59;/**  * Moves the iterator to the next key. This method may skip any values that have not yet been returned by the  * iterator created by the {@link #getValues()} method. Hence, if called multiple times it "removes" key groups.  *  * @return true, if the input iterator has an other group of records with the same key.  */ ;/**  * Moves the iterator to the next key. This method may skip any values that have not yet been returned by the  * iterator created by the {@link #getValues()} method. Hence, if called multiple times it "removes" key groups.  *  * @return true, if the input iterator has an other group of records with the same key.  */ public boolean nextKey() throws IOException {     if (lookahead != null) {         // common case: whole value-iterator was consumed and a new key group is available.         this.comparator.setReference(this.lookahead).         this.valuesIterator.next = this.lookahead.         this.lastKeyRecord = this.lookahead.         this.lookahead = null.         this.valuesIterator.iteratorAvailable = true.         return true.     }     // first element, empty/done, or the values iterator was not entirely consumed     if (this.done) {         return false.     }     if (this.valuesIterator != null) {         // values was not entirely consumed. move to the next key         // Required if user code / reduce() method did not read the whole value iterator.         E next.         while (true) {             if ((next = this.iterator.next()) != null) {                 if (!this.comparator.equalToReference(next)) {                     // the keys do not match, so we have a new group. store the current key                     this.comparator.setReference(next).                     this.valuesIterator.next = next.                     this.lastKeyRecord = next.                     this.valuesIterator.iteratorAvailable = true.                     return true.                 }             } else {                 // input exhausted                 this.valuesIterator.next = null.                 this.valuesIterator = null.                 this.lastKeyRecord = null.                 this.done = true.                 return false.             }         }     } else {         // first element         // get the next element         E first = this.iterator.next().         if (first != null) {             this.comparator.setReference(first).             this.valuesIterator = new ValuesIterator(first).             this.lastKeyRecord = first.             return true.         } else {             // empty input, set everything null             this.done = true.             return false.         }     } }
false;private;0;23;;private E advanceToNext() {     try {         E next = this.iterator.next().         if (next != null) {             if (comparator.equalToReference(next)) {                 // same key                 return next.             } else {                 // moved to the next key, no more values here                 this.lookahead = next.                 return null.             }         } else {             // backing iterator is consumed             this.done = true.             return null.         }     } catch (IOException e) {         throw new RuntimeException("An error occurred while reading the next record.", e).     } }
false;public;0;3;;public E getCurrent() {     return lastKeyRecord. }
false;public;0;3;;public TypeComparator<E> getComparatorWithCurrentReference() {     return this.comparator. }
true;public;0;4;/**  * Returns an iterator over all values that belong to the current key. The iterator is initially <code>null</code>  * (before the first call to {@link #nextKey()} and after all keys are consumed. In general, this method returns  * always a non-null value, if a previous call to {@link #nextKey()} return <code>true</code>.  *  * @return Iterator over all values that belong to the current key.  */ ;/**  * Returns an iterator over all values that belong to the current key. The iterator is initially <code>null</code>  * (before the first call to {@link #nextKey()} and after all keys are consumed. In general, this method returns  * always a non-null value, if a previous call to {@link #nextKey()} return <code>true</code>.  *  * @return Iterator over all values that belong to the current key.  */ @Override public ValuesIterator getValues() {     return this.valuesIterator. }
false;public;0;4;;@Override public boolean hasNext() {     return next != null. }
false;public;0;10;;@Override public E next() {     if (this.next != null) {         E current = this.next.         this.next = NonReusingKeyGroupedIterator.this.advanceToNext().         return current.     } else {         throw new NoSuchElementException().     } }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;10;;@Override public Iterator<E> iterator() {     if (iteratorAvailable) {         iteratorAvailable = false.         return this.     } else {         throw new TraversableOnceException().     } }
