commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void start(@Nonnull ComponentMainThreadExecutor mainThreadExecutor) {     this.componentMainThreadExecutor = mainThreadExecutor. }
false;public;5;31;;// --------------------------- @Override public CompletableFuture<LogicalSlot> allocateSlot(SlotRequestId slotRequestId, ScheduledUnit scheduledUnit, SlotProfile slotProfile, boolean allowQueuedScheduling, Time allocationTimeout) {     log.debug("Received slot request [{}] for task: {}", slotRequestId, scheduledUnit.getTaskToExecute()).     componentMainThreadExecutor.assertRunningInMainThread().     final CompletableFuture<LogicalSlot> allocationResultFuture = new CompletableFuture<>().     CompletableFuture<LogicalSlot> allocationFuture = scheduledUnit.getSlotSharingGroupId() == null ? allocateSingleSlot(slotRequestId, slotProfile, allowQueuedScheduling, allocationTimeout) : allocateSharedSlot(slotRequestId, scheduledUnit, slotProfile, allowQueuedScheduling, allocationTimeout).     allocationFuture.whenComplete((LogicalSlot slot, Throwable failure) -> {         if (failure != null) {             cancelSlotRequest(slotRequestId, scheduledUnit.getSlotSharingGroupId(), failure).             allocationResultFuture.completeExceptionally(failure).         } else {             allocationResultFuture.complete(slot).         }     }).     return allocationResultFuture. }
false;public;3;14;;@Override public void cancelSlotRequest(SlotRequestId slotRequestId, @Nullable SlotSharingGroupId slotSharingGroupId, Throwable cause) {     componentMainThreadExecutor.assertRunningInMainThread().     if (slotSharingGroupId != null) {         releaseSharedSlot(slotRequestId, slotSharingGroupId, cause).     } else {         slotPool.releaseSlot(slotRequestId, cause).     } }
false;public;1;7;;@Override public void returnLogicalSlot(LogicalSlot logicalSlot) {     SlotRequestId slotRequestId = logicalSlot.getSlotRequestId().     SlotSharingGroupId slotSharingGroupId = logicalSlot.getSlotSharingGroupId().     FlinkException cause = new FlinkException("Slot is being returned to the SlotPool.").     cancelSlotRequest(slotRequestId, slotSharingGroupId, cause). }
false;private;4;33;;// --------------------------- private CompletableFuture<LogicalSlot> allocateSingleSlot(SlotRequestId slotRequestId, SlotProfile slotProfile, boolean allowQueuedScheduling, Time allocationTimeout) {     Optional<SlotAndLocality> slotAndLocality = tryAllocateFromAvailable(slotRequestId, slotProfile).     if (slotAndLocality.isPresent()) {         // already successful from available         try {             return CompletableFuture.completedFuture(completeAllocationByAssigningPayload(slotRequestId, slotAndLocality.get())).         } catch (FlinkException e) {             return FutureUtils.completedExceptionally(e).         }     } else if (allowQueuedScheduling) {         // we allocate by requesting a new slot         return slotPool.requestNewAllocatedSlot(slotRequestId, slotProfile.getResourceProfile(), allocationTimeout).thenApply((PhysicalSlot allocatedSlot) -> {             try {                 return completeAllocationByAssigningPayload(slotRequestId, new SlotAndLocality(allocatedSlot, Locality.UNKNOWN)).             } catch (FlinkException e) {                 throw new CompletionException(e).             }         }).     } else {         // failed to allocate         return FutureUtils.completedExceptionally(new NoResourceAvailableException("Could not allocate a simple slot for " + slotRequestId + '.')).     } }
false;private;2;23;;@Nonnull private LogicalSlot completeAllocationByAssigningPayload(@Nonnull SlotRequestId slotRequestId, @Nonnull SlotAndLocality slotAndLocality) throws FlinkException {     final PhysicalSlot allocatedSlot = slotAndLocality.getSlot().     final SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(slotRequestId, allocatedSlot, null, slotAndLocality.getLocality(), this).     if (allocatedSlot.tryAssignPayload(singleTaskSlot)) {         return singleTaskSlot.     } else {         final FlinkException flinkException = new FlinkException("Could not assign payload to allocated slot " + allocatedSlot.getAllocationId() + '.').         slotPool.releaseSlot(slotRequestId, flinkException).         throw flinkException.     } }
false;private;2;18;;private Optional<SlotAndLocality> tryAllocateFromAvailable(@Nonnull SlotRequestId slotRequestId, @Nonnull SlotProfile slotProfile) {     Collection<SlotInfo> slotInfoList = slotPool.getAvailableSlotsInformation().     Optional<SlotSelectionStrategy.SlotInfoAndLocality> selectedAvailableSlot = slotSelectionStrategy.selectBestSlotForProfile(slotInfoList, slotProfile).     return selectedAvailableSlot.flatMap(slotInfoAndLocality -> {         Optional<PhysicalSlot> optionalAllocatedSlot = slotPool.allocateAvailableSlot(slotRequestId, slotInfoAndLocality.getSlotInfo().getAllocationId()).         return optionalAllocatedSlot.map(allocatedSlot -> new SlotAndLocality(allocatedSlot, slotInfoAndLocality.getLocality())).     }). }
false;private;5;44;;// ------------------------------- slot sharing code private CompletableFuture<LogicalSlot> allocateSharedSlot(SlotRequestId slotRequestId, ScheduledUnit scheduledUnit, SlotProfile slotProfile, boolean allowQueuedScheduling, Time allocationTimeout) {     // allocate slot with slot sharing     final SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(scheduledUnit.getSlotSharingGroupId(), id -> new SlotSharingManager(id, slotPool, this)).     final SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality.     try {         if (scheduledUnit.getCoLocationConstraint() != null) {             multiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(scheduledUnit.getCoLocationConstraint(), multiTaskSlotManager, slotProfile, allowQueuedScheduling, allocationTimeout).         } else {             multiTaskSlotLocality = allocateMultiTaskSlot(scheduledUnit.getJobVertexId(), multiTaskSlotManager, slotProfile, allowQueuedScheduling, allocationTimeout).         }     } catch (NoResourceAvailableException noResourceException) {         return FutureUtils.completedExceptionally(noResourceException).     }     // sanity check     Preconditions.checkState(!multiTaskSlotLocality.getMultiTaskSlot().contains(scheduledUnit.getJobVertexId())).     final SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(slotRequestId, scheduledUnit.getJobVertexId(), multiTaskSlotLocality.getLocality()).     return leaf.getLogicalSlotFuture(). }
true;private;5;80;/**  * Allocates a co-located {@link SlotSharingManager.MultiTaskSlot} for the given {@link CoLocationConstraint}.  *  * <p>If allowQueuedScheduling is true, then the returned {@link SlotSharingManager.MultiTaskSlot} can be  * uncompleted.  *  * @param coLocationConstraint for which to allocate a {@link SlotSharingManager.MultiTaskSlot}  * @param multiTaskSlotManager responsible for the slot sharing group for which to allocate the slot  * @param slotProfile specifying the requirements for the requested slot  * @param allowQueuedScheduling true if queued scheduling (the returned task slot must not be completed yet) is allowed, otherwise false  * @param allocationTimeout timeout before the slot allocation times out  * @return A {@link SlotAndLocality} which contains the allocated{@link SlotSharingManager.MultiTaskSlot}  * 		and its locality wrt the given location preferences  */ ;/**  * Allocates a co-located {@link SlotSharingManager.MultiTaskSlot} for the given {@link CoLocationConstraint}.  *  * <p>If allowQueuedScheduling is true, then the returned {@link SlotSharingManager.MultiTaskSlot} can be  * uncompleted.  *  * @param coLocationConstraint for which to allocate a {@link SlotSharingManager.MultiTaskSlot}  * @param multiTaskSlotManager responsible for the slot sharing group for which to allocate the slot  * @param slotProfile specifying the requirements for the requested slot  * @param allowQueuedScheduling true if queued scheduling (the returned task slot must not be completed yet) is allowed, otherwise false  * @param allocationTimeout timeout before the slot allocation times out  * @return A {@link SlotAndLocality} which contains the allocated{@link SlotSharingManager.MultiTaskSlot}  * 		and its locality wrt the given location preferences  */ private SlotSharingManager.MultiTaskSlotLocality allocateCoLocatedMultiTaskSlot(CoLocationConstraint coLocationConstraint, SlotSharingManager multiTaskSlotManager, SlotProfile slotProfile, boolean allowQueuedScheduling, Time allocationTimeout) throws NoResourceAvailableException {     final SlotRequestId coLocationSlotRequestId = coLocationConstraint.getSlotRequestId().     if (coLocationSlotRequestId != null) {         // we have a slot assigned --> try to retrieve it         final SlotSharingManager.TaskSlot taskSlot = multiTaskSlotManager.getTaskSlot(coLocationSlotRequestId).         if (taskSlot != null) {             Preconditions.checkState(taskSlot instanceof SlotSharingManager.MultiTaskSlot).             return SlotSharingManager.MultiTaskSlotLocality.of(((SlotSharingManager.MultiTaskSlot) taskSlot), Locality.LOCAL).         } else {             // the slot may have been cancelled in the mean time             coLocationConstraint.setSlotRequestId(null).         }     }     if (coLocationConstraint.isAssigned()) {         // refine the preferred locations of the slot profile         slotProfile = new SlotProfile(slotProfile.getResourceProfile(), Collections.singleton(coLocationConstraint.getLocation()), slotProfile.getPreferredAllocations()).     }     // get a new multi task slot     SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = allocateMultiTaskSlot(coLocationConstraint.getGroupId(), multiTaskSlotManager, slotProfile, allowQueuedScheduling, allocationTimeout).     // check whether we fulfill the co-location constraint     if (coLocationConstraint.isAssigned() && multiTaskSlotLocality.getLocality() != Locality.LOCAL) {         multiTaskSlotLocality.getMultiTaskSlot().release(new FlinkException("Multi task slot is not local and, thus, does not fulfill the co-location constraint.")).         throw new NoResourceAvailableException("Could not allocate a local multi task slot for the " + "co location constraint " + coLocationConstraint + '.').     }     final SlotRequestId slotRequestId = new SlotRequestId().     final SlotSharingManager.MultiTaskSlot coLocationSlot = multiTaskSlotLocality.getMultiTaskSlot().allocateMultiTaskSlot(slotRequestId, coLocationConstraint.getGroupId()).     // mark the requested slot as co-located slot for other co-located tasks     coLocationConstraint.setSlotRequestId(slotRequestId).     // lock the co-location constraint once we have obtained the allocated slot     coLocationSlot.getSlotContextFuture().whenComplete((SlotContext slotContext, Throwable throwable) -> {         if (throwable == null) {             // check whether we are still assigned to the co-location constraint             if (Objects.equals(coLocationConstraint.getSlotRequestId(), slotRequestId)) {                 coLocationConstraint.lockLocation(slotContext.getTaskManagerLocation()).             } else {                 log.debug("Failed to lock colocation constraint {} because assigned slot " + "request {} differs from fulfilled slot request {}.", coLocationConstraint.getGroupId(), coLocationConstraint.getSlotRequestId(), slotRequestId).             }         } else {             log.debug("Failed to lock colocation constraint {} because the slot " + "allocation for slot request {} failed.", coLocationConstraint.getGroupId(), coLocationConstraint.getSlotRequestId(), throwable).         }     }).     return SlotSharingManager.MultiTaskSlotLocality.of(coLocationSlot, multiTaskSlotLocality.getLocality()). }
true;private;5;99;/**  * Allocates a {@link SlotSharingManager.MultiTaskSlot} for the given groupId which is in the  * slot sharing group for which the given {@link SlotSharingManager} is responsible.  *  * <p>If allowQueuedScheduling is true, then the method can return an uncompleted {@link SlotSharingManager.MultiTaskSlot}.  *  * @param groupId for which to allocate a new {@link SlotSharingManager.MultiTaskSlot}  * @param slotSharingManager responsible for the slot sharing group for which to allocate the slot  * @param slotProfile slot profile that specifies the requirements for the slot  * @param allowQueuedScheduling true if queued scheduling (the returned task slot must not be completed yet) is allowed, otherwise false  * @param allocationTimeout timeout before the slot allocation times out  * @return A {@link SlotSharingManager.MultiTaskSlotLocality} which contains the allocated {@link SlotSharingManager.MultiTaskSlot}  * 		and its locality wrt the given location preferences  */ ;/**  * Allocates a {@link SlotSharingManager.MultiTaskSlot} for the given groupId which is in the  * slot sharing group for which the given {@link SlotSharingManager} is responsible.  *  * <p>If allowQueuedScheduling is true, then the method can return an uncompleted {@link SlotSharingManager.MultiTaskSlot}.  *  * @param groupId for which to allocate a new {@link SlotSharingManager.MultiTaskSlot}  * @param slotSharingManager responsible for the slot sharing group for which to allocate the slot  * @param slotProfile slot profile that specifies the requirements for the slot  * @param allowQueuedScheduling true if queued scheduling (the returned task slot must not be completed yet) is allowed, otherwise false  * @param allocationTimeout timeout before the slot allocation times out  * @return A {@link SlotSharingManager.MultiTaskSlotLocality} which contains the allocated {@link SlotSharingManager.MultiTaskSlot}  * 		and its locality wrt the given location preferences  */ private SlotSharingManager.MultiTaskSlotLocality allocateMultiTaskSlot(AbstractID groupId, SlotSharingManager slotSharingManager, SlotProfile slotProfile, boolean allowQueuedScheduling, Time allocationTimeout) throws NoResourceAvailableException {     Collection<SlotInfo> resolvedRootSlotsInfo = slotSharingManager.listResolvedRootSlotInfo(groupId).     SlotSelectionStrategy.SlotInfoAndLocality bestResolvedRootSlotWithLocality = slotSelectionStrategy.selectBestSlotForProfile(resolvedRootSlotsInfo, slotProfile).orElse(null).     final SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = bestResolvedRootSlotWithLocality != null ? new SlotSharingManager.MultiTaskSlotLocality(slotSharingManager.getResolvedRootSlot(bestResolvedRootSlotWithLocality.getSlotInfo()), bestResolvedRootSlotWithLocality.getLocality()) : null.     if (multiTaskSlotLocality != null && multiTaskSlotLocality.getLocality() == Locality.LOCAL) {         return multiTaskSlotLocality.     }     final SlotRequestId allocatedSlotRequestId = new SlotRequestId().     final SlotRequestId multiTaskSlotRequestId = new SlotRequestId().     Optional<SlotAndLocality> optionalPoolSlotAndLocality = tryAllocateFromAvailable(allocatedSlotRequestId, slotProfile).     if (optionalPoolSlotAndLocality.isPresent()) {         SlotAndLocality poolSlotAndLocality = optionalPoolSlotAndLocality.get().         if (poolSlotAndLocality.getLocality() == Locality.LOCAL || bestResolvedRootSlotWithLocality == null) {             final PhysicalSlot allocatedSlot = poolSlotAndLocality.getSlot().             final SlotSharingManager.MultiTaskSlot multiTaskSlot = slotSharingManager.createRootSlot(multiTaskSlotRequestId, CompletableFuture.completedFuture(poolSlotAndLocality.getSlot()), allocatedSlotRequestId).             if (allocatedSlot.tryAssignPayload(multiTaskSlot)) {                 return SlotSharingManager.MultiTaskSlotLocality.of(multiTaskSlot, poolSlotAndLocality.getLocality()).             } else {                 multiTaskSlot.release(new FlinkException("Could not assign payload to allocated slot " + allocatedSlot.getAllocationId() + '.')).             }         }     }     if (multiTaskSlotLocality != null) {         // prefer slot sharing group slots over unused slots         if (optionalPoolSlotAndLocality.isPresent()) {             slotPool.releaseSlot(allocatedSlotRequestId, new FlinkException("Locality constraint is not better fulfilled by allocated slot.")).         }         return multiTaskSlotLocality.     }     if (allowQueuedScheduling) {         // there is no slot immediately available --> check first for uncompleted slots at the slot sharing group         SlotSharingManager.MultiTaskSlot multiTaskSlot = slotSharingManager.getUnresolvedRootSlot(groupId).         if (multiTaskSlot == null) {             // it seems as if we have to request a new slot from the resource manager, this is always the last resort!!!             final CompletableFuture<PhysicalSlot> slotAllocationFuture = slotPool.requestNewAllocatedSlot(allocatedSlotRequestId, slotProfile.getResourceProfile(), allocationTimeout).             multiTaskSlot = slotSharingManager.createRootSlot(multiTaskSlotRequestId, slotAllocationFuture, allocatedSlotRequestId).             slotAllocationFuture.whenComplete((PhysicalSlot allocatedSlot, Throwable throwable) -> {                 final SlotSharingManager.TaskSlot taskSlot = slotSharingManager.getTaskSlot(multiTaskSlotRequestId).                 if (taskSlot != null) {                     // still valid                     if (!(taskSlot instanceof SlotSharingManager.MultiTaskSlot) || throwable != null) {                         taskSlot.release(throwable).                     } else {                         if (!allocatedSlot.tryAssignPayload(((SlotSharingManager.MultiTaskSlot) taskSlot))) {                             taskSlot.release(new FlinkException("Could not assign payload to allocated slot " + allocatedSlot.getAllocationId() + '.')).                         }                     }                 } else {                     slotPool.releaseSlot(allocatedSlotRequestId, new FlinkException("Could not find task slot with " + multiTaskSlotRequestId + '.')).                 }             }).         }         return SlotSharingManager.MultiTaskSlotLocality.of(multiTaskSlot, Locality.UNKNOWN).     }     throw new NoResourceAvailableException("Could not allocate a shared slot for " + groupId + '.'). }
false;private;3;19;;private void releaseSharedSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull SlotSharingGroupId slotSharingGroupId, Throwable cause) {     final SlotSharingManager multiTaskSlotManager = slotSharingManagers.get(slotSharingGroupId).     if (multiTaskSlotManager != null) {         final SlotSharingManager.TaskSlot taskSlot = multiTaskSlotManager.getTaskSlot(slotRequestId).         if (taskSlot != null) {             taskSlot.release(cause).         } else {             log.debug("Could not find slot [{}] in slot sharing group {}. Ignoring release slot request.", slotRequestId, slotSharingGroupId).         }     } else {         log.debug("Could not find slot sharing group {}. Ignoring release slot request.", slotSharingGroupId).     } }
false;public;0;4;;@Override public boolean requiresPreviousExecutionGraphAllocations() {     return slotSelectionStrategy instanceof PreviousAllocationSlotSelectionStrategy. }
