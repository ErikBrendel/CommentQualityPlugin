commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;@Override public void postStop() throws Exception {     super.postStop().     if (rpcEndpointTerminationResult.isSuccess()) {         terminationFuture.complete(null).     } else {         terminationFuture.completeExceptionally(rpcEndpointTerminationResult.getFailureCause()).     }     state = state.finishTermination(). }
false;public;1;23;;@Override public void onReceive(final Object message) {     if (message instanceof RemoteHandshakeMessage) {         handleHandshakeMessage((RemoteHandshakeMessage) message).     } else if (message instanceof ControlMessages) {         handleControlMessage(((ControlMessages) message)).     } else if (state.isRunning()) {         mainThreadValidator.enterMainThread().         try {             handleRpcMessage(message).         } finally {             mainThreadValidator.exitMainThread().         }     } else {         log.info("The rpc endpoint {} has not been started yet. Discarding message {} until processing is started.", rpcEndpoint.getClass().getName(), message.getClass().getName()).         sendErrorIfSender(new AkkaRpcException(String.format("Discard message, because the rpc endpoint %s has not been started yet.", rpcEndpoint.getAddress()))).     } }
false;private;1;15;;private void handleControlMessage(ControlMessages controlMessage) {     switch(controlMessage) {         case START:             state = state.start(this).             break.         case STOP:             state = state.stop().             break.         case TERMINATE:             state.terminate(this).             break.         default:             handleUnknownControlMessage(controlMessage).     } }
false;private;1;5;;private void handleUnknownControlMessage(ControlMessages controlMessage) {     final String message = String.format("Received unknown control message %s. Dropping this message!", controlMessage).     log.warn(message).     sendErrorIfSender(new AkkaUnknownMessageException(message)). }
false;protected;1;17;;protected void handleRpcMessage(Object message) {     if (message instanceof RunAsync) {         handleRunAsync((RunAsync) message).     } else if (message instanceof CallAsync) {         handleCallAsync((CallAsync) message).     } else if (message instanceof RpcInvocation) {         handleRpcInvocation((RpcInvocation) message).     } else {         log.warn("Received message of unknown type {} with value {}. Dropping this message!", message.getClass().getName(), message).         sendErrorIfSender(new AkkaUnknownMessageException("Received unknown message " + message + " of type " + message.getClass().getSimpleName() + '.')).     } }
false;private;1;16;;private void handleHandshakeMessage(RemoteHandshakeMessage handshakeMessage) {     if (!isCompatibleVersion(handshakeMessage.getVersion())) {         sendErrorIfSender(new AkkaHandshakeException(String.format("Version mismatch between source (%s) and target (%s) rpc component. Please verify that all components have the same version.", handshakeMessage.getVersion(), getVersion()))).     } else if (!isGatewaySupported(handshakeMessage.getRpcGateway())) {         sendErrorIfSender(new AkkaHandshakeException(String.format("The rpc endpoint does not support the gateway %s.", handshakeMessage.getRpcGateway().getSimpleName()))).     } else {         getSender().tell(new Status.Success(HandshakeSuccessMessage.INSTANCE), getSelf()).     } }
false;private;1;3;;private boolean isGatewaySupported(Class<?> rpcGateway) {     return rpcGateway.isAssignableFrom(rpcEndpoint.getClass()). }
false;private;1;3;;private boolean isCompatibleVersion(int sourceVersion) {     return sourceVersion == getVersion(). }
false;private;0;3;;private int getVersion() {     return version. }
true;private;1;63;/**  * Handle rpc invocations by looking up the rpc method on the rpc endpoint and calling this  * method with the provided method arguments. If the method has a return value, it is returned  * to the sender of the call.  *  * @param rpcInvocation Rpc invocation message  */ ;/**  * Handle rpc invocations by looking up the rpc method on the rpc endpoint and calling this  * method with the provided method arguments. If the method has a return value, it is returned  * to the sender of the call.  *  * @param rpcInvocation Rpc invocation message  */ private void handleRpcInvocation(RpcInvocation rpcInvocation) {     Method rpcMethod = null.     try {         String methodName = rpcInvocation.getMethodName().         Class<?>[] parameterTypes = rpcInvocation.getParameterTypes().         rpcMethod = lookupRpcMethod(methodName, parameterTypes).     } catch (ClassNotFoundException e) {         log.error("Could not load method arguments.", e).         RpcConnectionException rpcException = new RpcConnectionException("Could not load method arguments.", e).         getSender().tell(new Status.Failure(rpcException), getSelf()).     } catch (IOException e) {         log.error("Could not deserialize rpc invocation message.", e).         RpcConnectionException rpcException = new RpcConnectionException("Could not deserialize rpc invocation message.", e).         getSender().tell(new Status.Failure(rpcException), getSelf()).     } catch (final NoSuchMethodException e) {         log.error("Could not find rpc method for rpc invocation.", e).         RpcConnectionException rpcException = new RpcConnectionException("Could not find rpc method for rpc invocation.", e).         getSender().tell(new Status.Failure(rpcException), getSelf()).     }     if (rpcMethod != null) {         try {             // this supports declaration of anonymous classes             rpcMethod.setAccessible(true).             if (rpcMethod.getReturnType().equals(Void.TYPE)) {                 // No return value to send back                 rpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs()).             } else {                 final Object result.                 try {                     result = rpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs()).                 } catch (InvocationTargetException e) {                     log.trace("Reporting back error thrown in remote procedure {}", rpcMethod, e).                     // tell the sender about the failure                     getSender().tell(new Status.Failure(e.getTargetException()), getSelf()).                     return.                 }                 final String methodName = rpcMethod.getName().                 if (result instanceof CompletableFuture) {                     final CompletableFuture<?> responseFuture = (CompletableFuture<?>) result.                     sendAsyncResponse(responseFuture, methodName).                 } else {                     sendSyncResponse(result, methodName).                 }             }         } catch (Throwable e) {             log.error("Error while executing remote procedure call {}.", rpcMethod, e).             // tell the sender about the failure             getSender().tell(new Status.Failure(e), getSelf()).         }     } }
false;private;2;13;;private void sendSyncResponse(Object response, String methodName) {     if (isRemoteSender(getSender())) {         Either<SerializedValue<?>, AkkaRpcException> serializedResult = serializeRemoteResultAndVerifySize(response, methodName).         if (serializedResult.isLeft()) {             getSender().tell(new Status.Success(serializedResult.left()), getSelf()).         } else {             getSender().tell(new Status.Failure(serializedResult.right()), getSelf()).         }     } else {         getSender().tell(new Status.Success(response), getSelf()).     } }
false;private;2;25;;private void sendAsyncResponse(CompletableFuture<?> asyncResponse, String methodName) {     final ActorRef sender = getSender().     Promise.DefaultPromise<Object> promise = new Promise.DefaultPromise<>().     asyncResponse.whenComplete((value, throwable) -> {         if (throwable != null) {             promise.failure(throwable).         } else {             if (isRemoteSender(sender)) {                 Either<SerializedValue<?>, AkkaRpcException> serializedResult = serializeRemoteResultAndVerifySize(value, methodName).                 if (serializedResult.isLeft()) {                     promise.success(serializedResult.left()).                 } else {                     promise.failure(serializedResult.right()).                 }             } else {                 promise.success(value).             }         }     }).     Patterns.pipe(promise.future(), getContext().dispatcher()).to(sender). }
false;private;1;3;;private boolean isRemoteSender(ActorRef sender) {     return !sender.path().address().hasLocalScope(). }
false;private;2;17;;private Either<SerializedValue<?>, AkkaRpcException> serializeRemoteResultAndVerifySize(Object result, String methodName) {     try {         SerializedValue<?> serializedResult = new SerializedValue<>(result).         long resultSize = serializedResult.getByteArray().length.         if (resultSize > maximumFramesize) {             return Either.Right(new AkkaRpcException("The method " + methodName + "'s result size " + resultSize + " exceeds the maximum size " + maximumFramesize + " .")).         } else {             return Either.Left(serializedResult).         }     } catch (IOException e) {         return Either.Right(new AkkaRpcException("Failed to serialize the result for RPC call : " + methodName + '.', e)).     } }
true;private;1;9;/**  * Handle asynchronous {@link Callable}. This method simply executes the given {@link Callable}  * in the context of the actor thread.  *  * @param callAsync Call async message  */ ;/**  * Handle asynchronous {@link Callable}. This method simply executes the given {@link Callable}  * in the context of the actor thread.  *  * @param callAsync Call async message  */ private void handleCallAsync(CallAsync callAsync) {     try {         Object result = callAsync.getCallable().call().         getSender().tell(new Status.Success(result), getSelf()).     } catch (Throwable e) {         getSender().tell(new Status.Failure(e), getSelf()).     } }
true;private;1;24;/**  * Handle asynchronous {@link Runnable}. This method simply executes the given {@link Runnable}  * in the context of the actor thread.  *  * @param runAsync Run async message  */ ;/**  * Handle asynchronous {@link Runnable}. This method simply executes the given {@link Runnable}  * in the context of the actor thread.  *  * @param runAsync Run async message  */ private void handleRunAsync(RunAsync runAsync) {     final long timeToRun = runAsync.getTimeNanos().     final long delayNanos.     if (timeToRun == 0 || (delayNanos = timeToRun - System.nanoTime()) <= 0) {         // run immediately         try {             runAsync.getRunnable().run().         } catch (Throwable t) {             log.error("Caught exception while executing runnable in main thread.", t).             ExceptionUtils.rethrowIfFatalErrorOrOOM(t).         }     } else {         // schedule for later. send a new message after the delay, which will then be immediately executed         FiniteDuration delay = new FiniteDuration(delayNanos, TimeUnit.NANOSECONDS).         RunAsync message = new RunAsync(runAsync.getRunnable(), timeToRun).         final Object envelopedSelfMessage = envelopeSelfMessage(message).         getContext().system().scheduler().scheduleOnce(delay, getSelf(), envelopedSelfMessage, getContext().dispatcher(), ActorRef.noSender()).     } }
true;private;2;3;/**  * Look up the rpc method on the given {@link RpcEndpoint} instance.  *  * @param methodName Name of the method  * @param parameterTypes Parameter types of the method  * @return Method of the rpc endpoint  * @throws NoSuchMethodException Thrown if the method with the given name and parameter types  * 									cannot be found at the rpc endpoint  */ ;/**  * Look up the rpc method on the given {@link RpcEndpoint} instance.  *  * @param methodName Name of the method  * @param parameterTypes Parameter types of the method  * @return Method of the rpc endpoint  * @throws NoSuchMethodException Thrown if the method with the given name and parameter types  * 									cannot be found at the rpc endpoint  */ private Method lookupRpcMethod(final String methodName, final Class<?>[] parameterTypes) throws NoSuchMethodException {     return rpcEndpoint.getClass().getMethod(methodName, parameterTypes). }
true;protected;1;5;/**  * Send throwable to sender if the sender is specified.  *  * @param throwable to send to the sender  */ ;/**  * Send throwable to sender if the sender is specified.  *  * @param throwable to send to the sender  */ protected void sendErrorIfSender(Throwable throwable) {     if (!getSender().equals(ActorRef.noSender())) {         getSender().tell(new Status.Failure(throwable), getSelf()).     } }
true;protected;1;3;/**  * Hook to envelope self messages.  *  * @param message to envelope  * @return enveloped message  */ ;/**  * Hook to envelope self messages.  *  * @param message to envelope  * @return enveloped message  */ protected Object envelopeSelfMessage(Object message) {     return message. }
true;private;1;6;/**  * Stop the actor immediately.  */ ;/**  * Stop the actor immediately.  */ private void stop(RpcEndpointTerminationResult rpcEndpointTerminationResult) {     if (rpcEndpointStopped.compareAndSet(false, true)) {         this.rpcEndpointTerminationResult = rpcEndpointTerminationResult.         getContext().stop(getSelf()).     } }
false;default;1;3;;default State start(AkkaRpcActor<?> akkaRpcActor) {     throw new AkkaRpcInvalidStateException(invalidStateTransitionMessage(StartedState.INSTANCE)). }
false;default;0;3;;default State stop() {     throw new AkkaRpcInvalidStateException(invalidStateTransitionMessage(StoppedState.INSTANCE)). }
false;default;1;3;;default State terminate(AkkaRpcActor<?> akkaRpcActor) {     throw new AkkaRpcInvalidStateException(invalidStateTransitionMessage(TerminatingState.INSTANCE)). }
false;default;0;3;;default State finishTermination() {     return TerminatedState.INSTANCE. }
false;default;0;3;;default boolean isRunning() {     return false. }
false;default;1;3;;default String invalidStateTransitionMessage(State targetState) {     return String.format("AkkaRpcActor is currently in state %s and cannot go into state %s.", this, targetState). }
false;public;1;4;;@Override public State start(AkkaRpcActor<?> akkaRpcActor) {     return INSTANCE. }
false;public;0;4;;@Override public State stop() {     return StoppedState.INSTANCE. }
false;public;1;25;;@Override public State terminate(AkkaRpcActor<?> akkaRpcActor) {     akkaRpcActor.mainThreadValidator.enterMainThread().     CompletableFuture<Void> terminationFuture.     try {         terminationFuture = akkaRpcActor.rpcEndpoint.onStop().     } catch (Throwable t) {         terminationFuture = FutureUtils.completedExceptionally(new AkkaRpcException(String.format("Failure while stopping RpcEndpoint %s.", akkaRpcActor.rpcEndpoint.getEndpointId()), t)).     } finally {         akkaRpcActor.mainThreadValidator.exitMainThread().     }     // IMPORTANT: This only works if we don't use a restarting supervisor strategy. Otherwise     // we would complete the future and let the actor system restart the actor with a completed     // future.     // Complete the termination future so that others know that we've stopped.     terminationFuture.whenComplete((ignored, throwable) -> akkaRpcActor.stop(RpcEndpointTerminationResult.of(throwable))).     return TerminatingState.INSTANCE. }
false;public;0;4;;@Override public boolean isRunning() {     return true. }
false;public;1;18;;@Override public State start(AkkaRpcActor<?> akkaRpcActor) {     akkaRpcActor.mainThreadValidator.enterMainThread().     try {         akkaRpcActor.rpcEndpoint.onStart().     } catch (Throwable throwable) {         akkaRpcActor.stop(RpcEndpointTerminationResult.failure(new AkkaRpcException(String.format("Could not start RpcEndpoint %s.", akkaRpcActor.rpcEndpoint.getEndpointId()), throwable))).     } finally {         akkaRpcActor.mainThreadValidator.exitMainThread().     }     return StartedState.INSTANCE. }
false;public;0;4;;@Override public State stop() {     return INSTANCE. }
false;public;1;6;;@Override public State terminate(AkkaRpcActor<?> akkaRpcActor) {     akkaRpcActor.stop(RpcEndpointTerminationResult.success()).     return TerminatingState.INSTANCE. }
false;public;0;4;;@Override public boolean isRunning() {     return true. }
false;public;0;3;;public boolean isSuccess() {     return failureCause == null. }
false;public;0;4;;public Throwable getFailureCause() {     Preconditions.checkState(failureCause != null).     return failureCause. }
false;private,static;0;3;;private static RpcEndpointTerminationResult success() {     return SUCCESS. }
false;private,static;1;3;;private static RpcEndpointTerminationResult failure(Throwable failureCause) {     return new RpcEndpointTerminationResult(failureCause). }
false;private,static;1;7;;private static RpcEndpointTerminationResult of(@Nullable Throwable failureCause) {     if (failureCause == null) {         return success().     } else {         return failure(failureCause).     } }
