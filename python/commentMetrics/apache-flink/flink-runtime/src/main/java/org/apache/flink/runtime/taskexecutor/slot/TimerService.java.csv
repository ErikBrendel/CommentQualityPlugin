commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;public void start(TimeoutListener<K> initialTimeoutListener) {     // sanity check. We only allow to assign a timeout listener once     Preconditions.checkState(!scheduledExecutorService.isShutdown()).     Preconditions.checkState(timeoutListener == null).     this.timeoutListener = Preconditions.checkNotNull(initialTimeoutListener). }
false;public;0;18;;public void stop() {     unregisterAllTimeouts().     timeoutListener = null.     scheduledExecutorService.shutdown().     try {         if (!scheduledExecutorService.awaitTermination(shutdownTimeout, TimeUnit.MILLISECONDS)) {             LOG.debug("The scheduled executor service did not properly terminate. Shutting " + "it down now.").             scheduledExecutorService.shutdownNow().         }     } catch (InterruptedException e) {         LOG.debug("Could not properly await the termination of the scheduled executor service.", e).         scheduledExecutorService.shutdownNow().     } }
true;public;3;10;/**  * Register a timeout for the given key which shall occur in the given delay.  *  * @param key for which to register the timeout  * @param delay until the timeout  * @param unit of the timeout delay  */ ;/**  * Register a timeout for the given key which shall occur in the given delay.  *  * @param key for which to register the timeout  * @param delay until the timeout  * @param unit of the timeout delay  */ public void registerTimeout(final K key, final long delay, final TimeUnit unit) {     Preconditions.checkState(timeoutListener != null, "The " + getClass().getSimpleName() + " has not been started.").     if (timeouts.containsKey(key)) {         unregisterTimeout(key).     }     timeouts.put(key, new Timeout<>(timeoutListener, key, delay, unit, scheduledExecutorService)). }
true;public;1;7;/**  * Unregister the timeout for the given key.  *  * @param key for which to unregister the timeout  */ ;/**  * Unregister the timeout for the given key.  *  * @param key for which to unregister the timeout  */ public void unregisterTimeout(K key) {     Timeout<K> timeout = timeouts.remove(key).     if (timeout != null) {         timeout.cancel().     } }
true;protected;0;6;/**  * Unregister all timeouts.  */ ;/**  * Unregister all timeouts.  */ protected void unregisterAllTimeouts() {     for (Timeout<K> timeout : timeouts.values()) {         timeout.cancel().     }     timeouts.clear(). }
true;public;2;9;/**  * Check whether the timeout for the given key and ticket is still valid (not yet unregistered  * and not yet overwritten).  *  * @param key for which to check the timeout  * @param ticket of the timeout  * @return True if the timeout ticket is still valid. otherwise false  */ ;/**  * Check whether the timeout for the given key and ticket is still valid (not yet unregistered  * and not yet overwritten).  *  * @param key for which to check the timeout  * @param ticket of the timeout  * @return True if the timeout ticket is still valid. otherwise false  */ public boolean isValid(K key, UUID ticket) {     if (timeouts.containsKey(key)) {         Timeout<K> timeout = timeouts.get(key).         return timeout.getTicket().equals(ticket).     } else {         return false.     } }
false;;0;3;;UUID getTicket() {     return ticket. }
false;;0;3;;void cancel() {     scheduledTimeout.cancel(true). }
false;public;0;4;;@Override public void run() {     timeoutListener.notifyTimeout(key, ticket). }
