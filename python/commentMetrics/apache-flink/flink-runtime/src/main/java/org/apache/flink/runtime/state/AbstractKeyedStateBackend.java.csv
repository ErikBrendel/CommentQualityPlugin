commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;7;;private static StreamCompressionDecorator determineStreamCompression(ExecutionConfig executionConfig) {     if (executionConfig != null && executionConfig.isUseSnapshotCompression()) {         return SnappyStreamCompressionDecorator.INSTANCE.     } else {         return UncompressedStreamCompressionDecorator.INSTANCE.     } }
true;public;0;13;/**  * Closes the state backend, releasing all internal resources, but does not delete any persistent  * checkpoint data.  */ ;/**  * Closes the state backend, releasing all internal resources, but does not delete any persistent  * checkpoint data.  */ @Override public void dispose() {     IOUtils.closeQuietly(cancelStreamRegistry).     if (kvStateRegistry != null) {         kvStateRegistry.unregisterAll().     }     lastName = null.     lastState = null.     keyValueStatesByName.clear(). }
true;public;1;6;/**  * @see KeyedStateBackend  */ ;/**  * @see KeyedStateBackend  */ @Override public void setCurrentKey(K newKey) {     notifyKeySelected(newKey).     this.currentKey = newKey.     this.currentKeyGroup = KeyGroupRangeAssignment.assignToKeyGroup(newKey, numberOfKeyGroups). }
false;private;1;3;;private void notifyKeySelected(K newKey) {     keySelectionListeners.forEach(listener -> listener.keySelected(newKey)). }
false;public;1;4;;@Override public void registerKeySelectionListener(KeySelectionListener<K> listener) {     keySelectionListeners.add(listener). }
false;public;1;4;;@Override public boolean deregisterKeySelectionListener(KeySelectionListener<K> listener) {     return keySelectionListeners.remove(listener). }
true;public;0;4;/**  * @see KeyedStateBackend  */ ;/**  * @see KeyedStateBackend  */ @Override public TypeSerializer<K> getKeySerializer() {     return keySerializerProvider.currentSchemaSerializer(). }
false;public;1;5;;public TypeSerializerSchemaCompatibility<K> checkKeySerializerSchemaCompatibility(TypeSerializerSnapshot<K> previousKeySerializerSnapshot) {     return keySerializerProvider.setPreviousSerializerSnapshotForRestoredState(previousKeySerializerSnapshot). }
true;public;0;4;/**  * @see KeyedStateBackend  */ ;/**  * @see KeyedStateBackend  */ @Override public K getCurrentKey() {     return currentKey. }
true;public;0;4;/**  * @see KeyedStateBackend  */ ;/**  * @see KeyedStateBackend  */ @Override public int getCurrentKeyGroupIndex() {     return currentKeyGroup. }
true;public;0;4;/**  * @see KeyedStateBackend  */ ;/**  * @see KeyedStateBackend  */ @Override public int getNumberOfKeyGroups() {     return numberOfKeyGroups. }
true;public;0;4;/**  * @see KeyedStateBackend  */ ;/**  * @see KeyedStateBackend  */ @Override public KeyGroupRange getKeyGroupRange() {     return keyGroupRange. }
true;public;4;26;/**  * @see KeyedStateBackend  */ ;/**  * @see KeyedStateBackend  */ @Override public <N, S extends State, T> void applyToAllKeys(final N namespace, final TypeSerializer<N> namespaceSerializer, final StateDescriptor<S, T> stateDescriptor, final KeyedStateFunction<K, S> function) throws Exception {     try (Stream<K> keyStream = getKeys(stateDescriptor.getName(), namespace)) {         final S state = getPartitionedState(namespace, namespaceSerializer, stateDescriptor).         keyStream.forEach((K key) -> {             setCurrentKey(key).             try {                 function.process(key, state).             } catch (Throwable e) {                 // one and catch it (and re-throw it) later.                 throw new RuntimeException(e).             }         }).     } }
true;public;2;21;/**  * @see KeyedStateBackend  */ ;/**  * @see KeyedStateBackend  */ @Override @SuppressWarnings("unchecked") public <N, S extends State, V> S getOrCreateKeyedState(final TypeSerializer<N> namespaceSerializer, StateDescriptor<S, V> stateDescriptor) throws Exception {     checkNotNull(namespaceSerializer, "Namespace serializer").     checkNotNull(keySerializerProvider, "State key serializer has not been configured in the config. " + "This operation cannot use partitioned state.").     InternalKvState<K, ?, ?> kvState = keyValueStatesByName.get(stateDescriptor.getName()).     if (kvState == null) {         if (!stateDescriptor.isSerializerInitialized()) {             stateDescriptor.initializeSerializerUnlessSet(executionConfig).         }         kvState = TtlStateFactory.createStateAndWrapWithTtlIfEnabled(namespaceSerializer, stateDescriptor, this, ttlTimeProvider).         keyValueStatesByName.put(stateDescriptor.getName(), kvState).         publishQueryableStateIfEnabled(stateDescriptor, kvState).     }     return (S) kvState. }
false;private;2;11;;private void publishQueryableStateIfEnabled(StateDescriptor<?, ?> stateDescriptor, InternalKvState<?, ?, ?> kvState) {     if (stateDescriptor.isQueryable()) {         if (kvStateRegistry == null) {             throw new IllegalStateException("State backend has not been initialized for job.").         }         String name = stateDescriptor.getQueryableStateName().         kvStateRegistry.registerKvState(keyGroupRange, name, kvState).     } }
true;public;3;31;/**  * TODO: NOTE: This method does a lot of work caching / retrieving states just to update the namespace.  *       This method should be removed for the sake of namespaces being lazily fetched from the keyed  *       state backend, or being set on the state directly.  *  * @see KeyedStateBackend  */ ;/**  * TODO: NOTE: This method does a lot of work caching / retrieving states just to update the namespace.  *       This method should be removed for the sake of namespaces being lazily fetched from the keyed  *       state backend, or being set on the state directly.  *  * @see KeyedStateBackend  */ @SuppressWarnings("unchecked") @Override public <N, S extends State> S getPartitionedState(final N namespace, final TypeSerializer<N> namespaceSerializer, final StateDescriptor<S, ?> stateDescriptor) throws Exception {     checkNotNull(namespace, "Namespace").     if (lastName != null && lastName.equals(stateDescriptor.getName())) {         lastState.setCurrentNamespace(namespace).         return (S) lastState.     }     InternalKvState<K, ?, ?> previous = keyValueStatesByName.get(stateDescriptor.getName()).     if (previous != null) {         lastState = previous.         lastState.setCurrentNamespace(namespace).         lastName = stateDescriptor.getName().         return (S) previous.     }     final S state = getOrCreateKeyedState(namespaceSerializer, stateDescriptor).     final InternalKvState<K, N, ?> kvState = (InternalKvState<K, N, ?>) state.     lastName = stateDescriptor.getName().     lastState = kvState.     kvState.setCurrentNamespace(namespace).     return state. }
false;public;0;4;;@Override public void close() throws IOException {     cancelStreamRegistry.close(). }
false;public;0;4;;@VisibleForTesting public boolean supportsAsynchronousSnapshots() {     return false. }
false;public;0;4;;@VisibleForTesting public StreamCompressionDecorator getKeyGroupCompressionDecorator() {     return keyGroupCompressionDecorator. }
true;public,abstract;0;2;/**  * Returns the total number of state entries across all keys/namespaces.  */ ;/**  * Returns the total number of state entries across all keys/namespaces.  */ @VisibleForTesting public abstract int numKeyValueStateEntries().
true;public;0;3;// TODO remove this once heap-based timers are working with RocksDB incremental snapshots! ;// TODO remove this once heap-based timers are working with RocksDB incremental snapshots! public boolean requiresLegacySynchronousTimerSnapshots() {     return false. }
