commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void onEvent(TaskEvent event) {     if (WorkerDoneEvent.class.equals(event.getClass())) {         onWorkerDoneEvent((WorkerDoneEvent) event).         return.     }     throw new IllegalStateException("Unable to handle event " + event.getClass().getName()). }
false;private;1;25;;private void onWorkerDoneEvent(WorkerDoneEvent workerDoneEvent) {     if (this.endOfSuperstep) {         throw new RuntimeException("Encountered WorderDoneEvent when still in End-of-Superstep status.").     }     workerDoneEventCounter++.     String[] aggNames = workerDoneEvent.getAggregatorNames().     Value[] aggregates = workerDoneEvent.getAggregates(userCodeClassLoader).     if (aggNames.length != aggregates.length) {         throw new RuntimeException("Inconsistent WorkerDoneEvent received!").     }     for (int i = 0. i < aggNames.length. i++) {         @SuppressWarnings("unchecked")         Aggregator<Value> aggregator = (Aggregator<Value>) this.aggregators.get(aggNames[i]).         aggregator.aggregate(aggregates[i]).     }     if (workerDoneEventCounter % numberOfEventsUntilEndOfSuperstep == 0) {         endOfSuperstep = true.         Thread.currentThread().interrupt().     } }
false;public;0;3;;public boolean isEndOfSuperstep() {     return this.endOfSuperstep. }
false;public;0;3;;public void resetEndOfSuperstep() {     this.endOfSuperstep = false. }
