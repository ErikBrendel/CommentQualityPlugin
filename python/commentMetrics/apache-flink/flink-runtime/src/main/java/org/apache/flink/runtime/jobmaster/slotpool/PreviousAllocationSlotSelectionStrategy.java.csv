commented;modifiers;parameterAmount;loc;comment;code
false;public;2;22;;@Override public Optional<SlotInfoAndLocality> selectBestSlotForProfile(@Nonnull Collection<? extends SlotInfo> availableSlots, @Nonnull SlotProfile slotProfile) {     Collection<AllocationID> priorAllocations = slotProfile.getPreferredAllocations().     // First, if there was a prior allocation try to schedule to the same/old slot     if (!priorAllocations.isEmpty()) {         for (SlotInfo availableSlot : availableSlots) {             if (priorAllocations.contains(availableSlot.getAllocationId())) {                 return Optional.of(SlotInfoAndLocality.of(availableSlot, Locality.LOCAL)).             }         }     }     // Second, select based on location preference, excluding blacklisted allocations     Set<AllocationID> blackListedAllocations = slotProfile.getPreviousExecutionGraphAllocations().     Collection<? extends SlotInfo> availableAndAllowedSlots = computeWithoutBlacklistedSlots(availableSlots, blackListedAllocations).     return LocationPreferenceSlotSelectionStrategy.INSTANCE.selectBestSlotForProfile(availableAndAllowedSlots, slotProfile). }
false;private;2;18;;@Nonnull private Collection<SlotInfo> computeWithoutBlacklistedSlots(@Nonnull Collection<? extends SlotInfo> availableSlots, @Nonnull Set<AllocationID> blacklistedAllocations) {     if (blacklistedAllocations.isEmpty()) {         return Collections.unmodifiableCollection(availableSlots).     }     ArrayList<SlotInfo> availableAndAllowedSlots = new ArrayList<>(availableSlots.size()).     for (SlotInfo availableSlot : availableSlots) {         if (!blacklistedAllocations.contains(availableSlot.getAllocationId())) {             availableAndAllowedSlots.add(availableSlot).         }     }     return availableAndAllowedSlots. }
