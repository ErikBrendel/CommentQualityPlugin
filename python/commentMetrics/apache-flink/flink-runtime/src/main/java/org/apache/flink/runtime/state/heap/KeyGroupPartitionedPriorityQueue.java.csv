commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Nullable @Override public T poll() {     final PQ headList = heapOfKeyGroupedHeaps.peek().     final T head = headList.poll().     heapOfKeyGroupedHeaps.adjustModifiedElement(headList).     return head. }
false;public;0;5;;@Nullable @Override public T peek() {     return heapOfKeyGroupedHeaps.peek().peek(). }
false;public;1;14;;@Override public boolean add(@Nonnull T toAdd) {     final PQ list = getKeyGroupSubHeapForElement(toAdd).     // the branch checks if the head element has (potentially) changed.     if (list.add(toAdd)) {         heapOfKeyGroupedHeaps.adjustModifiedElement(list).         // could we have a new head?         return toAdd.equals(peek()).     } else {         // head unchanged         return false.     } }
false;public;1;16;;@Override public boolean remove(@Nonnull T toRemove) {     final PQ list = getKeyGroupSubHeapForElement(toRemove).     final T oldHead = peek().     // the branch checks if the head element has (potentially) changed.     if (list.remove(toRemove)) {         heapOfKeyGroupedHeaps.adjustModifiedElement(list).         // could we have a new head?         return toRemove.equals(oldHead).     } else {         // head unchanged         return false.     } }
false;public;0;4;;@Override public boolean isEmpty() {     return peek() == null. }
false;public;0;8;;@Override public int size() {     int sizeSum = 0.     for (PQ list : keyGroupedHeaps) {         sizeSum += list.size().     }     return sizeSum. }
false;public;1;12;;@Override public void addAll(@Nullable Collection<? extends T> toAdd) {     if (toAdd == null) {         return.     }     // TODO consider bulk loading the partitions and "heapify" keyGroupHeap once after all elements are inserted.     for (T element : toAdd) {         add(element).     } }
false;public;0;5;;@Nonnull @Override public CloseableIterator<T> iterator() {     return new KeyGroupConcatenationIterator<>(keyGroupedHeaps). }
false;private;1;3;;private PQ getKeyGroupSubHeapForElement(T element) {     return keyGroupedHeaps[computeKeyGroupIndex(element)]. }
false;private;1;5;;private int computeKeyGroupIndex(T element) {     final Object extractKeyFromElement = keyExtractor.extractKeyFromElement(element).     final int keyGroupId = KeyGroupRangeAssignment.assignToKeyGroup(extractKeyFromElement, totalKeyGroups).     return globalKeyGroupToLocalIndex(keyGroupId). }
false;private;1;3;;private int globalKeyGroupToLocalIndex(int keyGroupId) {     return keyGroupId - firstKeyGroup. }
false;public;1;14;;@Nonnull @Override public Set<T> getSubsetForKeyGroup(int keyGroupId) {     HashSet<T> result = new HashSet<>().     PQ partitionQueue = keyGroupedHeaps[globalKeyGroupToLocalIndex(keyGroupId)].     try (CloseableIterator<T> iterator = partitionQueue.iterator()) {         while (iterator.hasNext()) {             result.add(iterator.next()).         }     } catch (Exception e) {         throw new FlinkRuntimeException("Exception while iterating key group.", e).     }     return result. }
false;public;0;12;;@Override public boolean hasNext() {     boolean currentHasNext = current.hasNext().     // find the iterator of the next partition that has elements.     while (!currentHasNext && index < keyGroupLists.length) {         IOUtils.closeQuietly(current).         current = keyGroupLists[index++].iterator().         currentHasNext = current.hasNext().     }     return currentHasNext. }
false;public;0;4;;@Override public T next() {     return current.next(). }
false;public;0;4;;@Override public void close() throws Exception {     current.close(). }
false;public;2;10;;@Override public int comparePriority(Q o1, Q o2) {     final T left = o1.peek().     final T right = o2.peek().     if (left == null) {         return (right == null ? 0 : 1).     } else {         return (right == null ? -1 : elementPriorityComparator.comparePriority(left, right)).     } }
true;;4;6;/**  * Creates a new queue for a given key-group partition.  *  * @param keyGroupId the key-group of the elements managed by the produced queue.  * @param numKeyGroups the total number of key-groups in the job.  * @param elementPriorityComparator the comparator that determines the order of managed elements by priority.  * @return a new queue for the given key-group.  */ ;/**  * Creates a new queue for a given key-group partition.  *  * @param keyGroupId the key-group of the elements managed by the produced queue.  * @param numKeyGroups the total number of key-groups in the job.  * @param elementPriorityComparator the comparator that determines the order of managed elements by priority.  * @return a new queue for the given key-group.  */ @Nonnull PQS create(@Nonnegative int keyGroupId, @Nonnegative int numKeyGroups, @Nonnull KeyExtractorFunction<T> keyExtractorFunction, @Nonnull PriorityComparator<T> elementPriorityComparator).
