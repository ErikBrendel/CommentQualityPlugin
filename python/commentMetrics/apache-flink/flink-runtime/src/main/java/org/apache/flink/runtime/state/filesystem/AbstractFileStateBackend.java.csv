commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Gets the checkpoint base directory. Jobs will create job-specific subdirectories  * for checkpoints within this directory. May be null, if not configured.  *  * @return The checkpoint base directory  */ ;// ------------------------------------------------------------------------ /**  * Gets the checkpoint base directory. Jobs will create job-specific subdirectories  * for checkpoints within this directory. May be null, if not configured.  *  * @return The checkpoint base directory  */ @Nullable public Path getCheckpointPath() {     return baseCheckpointPath. }
true;public;0;4;/**  * Gets the directory where savepoints are stored by default (when no custom path is given  * to the savepoint trigger command).  *  * @return The default directory for savepoints, or null, if no default directory has been configured.  */ ;/**  * Gets the directory where savepoints are stored by default (when no custom path is given  * to the savepoint trigger command).  *  * @return The default directory for savepoints, or null, if no default directory has been configured.  */ @Nullable public Path getSavepointPath() {     return baseSavepointPath. }
false;public;1;4;;// ------------------------------------------------------------------------ // Initialization and metadata storage // ------------------------------------------------------------------------ @Override public CompletedCheckpointStorageLocation resolveCheckpoint(String pointer) throws IOException {     return AbstractFsCheckpointStorage.resolveCheckpointPointer(pointer). }
true;private,static;1;20;/**  * Checks the validity of the path's scheme and path.  *  * @param path The path to check.  * @return The URI as a Path.  *  * @throws IllegalArgumentException Thrown, if the URI misses scheme or path.  */ ;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ /**  * Checks the validity of the path's scheme and path.  *  * @param path The path to check.  * @return The URI as a Path.  *  * @throws IllegalArgumentException Thrown, if the URI misses scheme or path.  */ private static Path validatePath(Path path) {     final URI uri = path.toUri().     final String scheme = uri.getScheme().     final String pathPart = uri.getPath().     // some validity checks     if (scheme == null) {         throw new IllegalArgumentException("The scheme (hdfs://, file://, etc) is null. " + "Please specify the file system scheme explicitly in the URI.").     }     if (pathPart == null) {         throw new IllegalArgumentException("The path to store the checkpoint data in is null. " + "Please specify a directory path for the checkpoint data.").     }     if (pathPart.length() == 0 || pathPart.equals("/")) {         throw new IllegalArgumentException("Cannot use the root directory for checkpoints.").     }     return path. }
false;private,static;3;16;;@Nullable private static Path parameterOrConfigured(@Nullable Path path, Configuration config, ConfigOption<String> option) {     if (path != null) {         return path.     } else {         String configValue = config.getString(option).         try {             return configValue == null ? null : new Path(configValue).         } catch (IllegalArgumentException e) {             throw new IllegalConfigurationException("Cannot parse value for " + option.key() + " : " + configValue + " . Not a valid path.").         }     } }
