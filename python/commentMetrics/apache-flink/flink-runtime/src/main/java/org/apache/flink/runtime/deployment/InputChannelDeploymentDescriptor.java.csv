commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public ResultPartitionID getConsumedPartitionId() {     return consumedPartitionId. }
false;public;0;3;;public ResultPartitionLocation getConsumedPartitionLocation() {     return consumedPartitionLocation. }
false;public;0;6;;@Override public String toString() {     return String.format("InputChannelDeploymentDescriptor [consumed partition id: %s, " + "consumed partition location: %s]", consumedPartitionId, consumedPartitionLocation). }
true;public,static;3;71;/**  * Creates an input channel deployment descriptor for each partition.  */ ;// ------------------------------------------------------------------------ /**  * Creates an input channel deployment descriptor for each partition.  */ public static InputChannelDeploymentDescriptor[] fromEdges(ExecutionEdge[] edges, ResourceID consumerResourceId, boolean allowLazyDeployment) throws ExecutionGraphException {     final InputChannelDeploymentDescriptor[] icdd = new InputChannelDeploymentDescriptor[edges.length].     // Each edge is connected to a different result partition     for (int i = 0. i < edges.length. i++) {         final IntermediateResultPartition consumedPartition = edges[i].getSource().         final Execution producer = consumedPartition.getProducer().getCurrentExecutionAttempt().         final ExecutionState producerState = producer.getState().         final LogicalSlot producerSlot = producer.getAssignedResource().         final ResultPartitionLocation partitionLocation.         // The producing task needs to be RUNNING or already FINISHED         if ((consumedPartition.getResultType().isPipelined() || consumedPartition.isConsumable()) && producerSlot != null && (producerState == ExecutionState.RUNNING || producerState == ExecutionState.FINISHED || producerState == ExecutionState.SCHEDULED || producerState == ExecutionState.DEPLOYING)) {             final TaskManagerLocation partitionTaskManagerLocation = producerSlot.getTaskManagerLocation().             final ResourceID partitionTaskManager = partitionTaskManagerLocation.getResourceID().             if (partitionTaskManager.equals(consumerResourceId)) {                 // Consuming task is deployed to the same TaskManager as the partition => local                 partitionLocation = ResultPartitionLocation.createLocal().             } else {                 // Different instances => remote                 final ConnectionID connectionId = new ConnectionID(partitionTaskManagerLocation, consumedPartition.getIntermediateResult().getConnectionIndex()).                 partitionLocation = ResultPartitionLocation.createRemote(connectionId).             }         } else if (allowLazyDeployment) {             // The producing task might not have registered the partition yet             partitionLocation = ResultPartitionLocation.createUnknown().         } else if (producerState == ExecutionState.CANCELING || producerState == ExecutionState.CANCELED || producerState == ExecutionState.FAILED) {             String msg = "Trying to schedule a task whose inputs were canceled or failed. " + "The producer is in state " + producerState + ".".             throw new ExecutionGraphException(msg).         } else {             String msg = String.format("Trying to eagerly schedule a task whose inputs " + "are not ready (result type: %s, partition consumable: %s, producer state: %s, producer slot: %s).", consumedPartition.getResultType(), consumedPartition.isConsumable(), producerState, producerSlot).             throw new ExecutionGraphException(msg).         }         final ResultPartitionID consumedPartitionId = new ResultPartitionID(consumedPartition.getPartitionId(), producer.getAttemptId()).         icdd[i] = new InputChannelDeploymentDescriptor(consumedPartitionId, partitionLocation).     }     return icdd. }
