commented;modifiers;parameterAmount;loc;comment;code
false;;0;8;;void stateAccessed() {     initIteratorIfNot().     try {         runCleanup().     } catch (Throwable t) {         throw new FlinkRuntimeException("Failed to incrementally clean up state with TTL", t).     } }
false;private;0;5;;private void initIteratorIfNot() {     if (stateIterator == null || !stateIterator.hasNext()) {         stateIterator = ttlState.original.getStateIncrementalVisitor(cleanupSize).     } }
false;private;0;20;;private void runCleanup() {     int entryNum = 0.     Collection<StateEntry<K, N, S>> nextEntries.     while (entryNum < cleanupSize && stateIterator.hasNext() && !(nextEntries = stateIterator.nextEntries()).isEmpty()) {         for (StateEntry<K, N, S> state : nextEntries) {             S cleanState = ttlState.getUnexpiredOrNull(state.getState()).             if (cleanState == null) {                 stateIterator.remove(state).             } else if (cleanState != state.getState()) {                 stateIterator.update(state, cleanState).             }         }         entryNum += nextEntries.size().     } }
true;public;1;3;/**  * As TTL state wrapper depends on this class through access callback,  * it has to be set here after its construction is done.  */ ;/**  * As TTL state wrapper depends on this class through access callback,  * it has to be set here after its construction is done.  */ public void setTtlState(@Nonnull AbstractTtlState<K, N, ?, S, ?> ttlState) {     this.ttlState = ttlState. }
false;;0;3;;int getCleanupSize() {     return cleanupSize. }
