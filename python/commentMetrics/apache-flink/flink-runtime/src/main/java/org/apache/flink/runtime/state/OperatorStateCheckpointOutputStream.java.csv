commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * User code can call this method to signal that it begins to write a new partition of operator state.  * Each previously written partition is considered final/immutable as soon as this method is called again.  */ ;/**  * User code can call this method to signal that it begins to write a new partition of operator state.  * Each previously written partition is considered final/immutable as soon as this method is called again.  */ public void startNewPartition() throws IOException {     partitionOffsets.add(delegate.getPos()). }
true;;0;23;/**  * This method should not be public so as to not expose internals to user code.  */ ;/**  * This method should not be public so as to not expose internals to user code.  */ @Override OperatorStateHandle closeAndGetHandle() throws IOException {     StreamStateHandle streamStateHandle = delegate.closeAndGetHandle().     if (null == streamStateHandle) {         return null.     }     if (partitionOffsets.isEmpty() && delegate.getPos() > initialPosition) {         startNewPartition().     }     Map<String, OperatorStateHandle.StateMetaInfo> offsetsMap = new HashMap<>(1).     OperatorStateHandle.StateMetaInfo metaInfo = new OperatorStateHandle.StateMetaInfo(partitionOffsets.toArray(), OperatorStateHandle.Mode.SPLIT_DISTRIBUTE).     offsetsMap.put(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME, metaInfo).     return new OperatorStreamStateHandle(offsetsMap, streamStateHandle). }
false;public;0;3;;public int getNumberOfPartitions() {     return partitionOffsets.size(). }
