commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// -------------------------------------------------------------------------------------------- // ------------------------------------------------------------------------ // Properties // ------------------------------------------------------------------------ public JobID getJobId() {     return jobId. }
false;public;0;3;;public long getCheckpointId() {     return checkpointId. }
false;public;0;3;;public long getCheckpointTimestamp() {     return checkpointTimestamp. }
false;public;0;3;;public int getNumberOfNonAcknowledgedTasks() {     return notYetAcknowledgedTasks.size(). }
false;public;0;3;;public int getNumberOfAcknowledgedTasks() {     return numAcknowledgedTasks. }
false;public;0;3;;public Map<OperatorID, OperatorState> getOperatorStates() {     return operatorStates. }
false;public;0;3;;public boolean isFullyAcknowledged() {     return this.notYetAcknowledgedTasks.isEmpty() && !discarded. }
false;public;1;3;;public boolean isAcknowledgedBy(ExecutionAttemptID executionAttemptId) {     return !notYetAcknowledgedTasks.containsKey(executionAttemptId). }
false;public;0;3;;public boolean isDiscarded() {     return discarded. }
true;public;0;4;/**  * Checks whether this checkpoint can be subsumed or whether it should always continue, regardless  * of newer checkpoints in progress.  *  * @return True if the checkpoint can be subsumed, false otherwise.  */ ;/**  * Checks whether this checkpoint can be subsumed or whether it should always continue, regardless  * of newer checkpoints in progress.  *  * @return True if the checkpoint can be subsumed, false otherwise.  */ public boolean canBeSubsumed() {     // If the checkpoint is forced, it cannot be subsumed.     return !props.forceCheckpoint(). }
false;;0;3;;CheckpointProperties getProps() {     return props. }
true;;1;3;/**  * Sets the callback for tracking this pending checkpoint.  *  * @param trackerCallback Callback for collecting subtask stats.  */ ;/**  * Sets the callback for tracking this pending checkpoint.  *  * @param trackerCallback Callback for collecting subtask stats.  */ void setStatsCallback(@Nullable PendingCheckpointStats trackerCallback) {     this.statsCallback = trackerCallback. }
true;public;1;15;/**  * Sets the handle for the canceller to this pending checkpoint. This method fails  * with an exception if a handle has already been set.  *  * @return true, if the handle was set, false, if the checkpoint is already disposed.  */ ;/**  * Sets the handle for the canceller to this pending checkpoint. This method fails  * with an exception if a handle has already been set.  *  * @return true, if the handle was set, false, if the checkpoint is already disposed.  */ public boolean setCancellerHandle(ScheduledFuture<?> cancellerHandle) {     synchronized (lock) {         if (this.cancellerHandle == null) {             if (!discarded) {                 this.cancellerHandle = cancellerHandle.                 return true.             } else {                 return false.             }         } else {             throw new IllegalStateException("A canceller handle was already set").         }     } }
true;public;0;3;/**  * Returns the completion future.  *  * @return A future to the completed checkpoint  */ ;// ------------------------------------------------------------------------ // Progress and Completion // ------------------------------------------------------------------------ /**  * Returns the completion future.  *  * @return A future to the completed checkpoint  */ public CompletableFuture<CompletedCheckpoint> getCompletionFuture() {     return onCompletionPromise. }
false;public;0;50;;public CompletedCheckpoint finalizeCheckpoint() throws IOException {     synchronized (lock) {         checkState(isFullyAcknowledged(), "Pending checkpoint has not been fully acknowledged yet.").         // make sure we fulfill the promise with an exception if something fails         try {             // write out the metadata             final Savepoint savepoint = new SavepointV2(checkpointId, operatorStates.values(), masterState).             final CompletedCheckpointStorageLocation finalizedLocation.             try (CheckpointMetadataOutputStream out = targetLocation.createMetadataOutputStream()) {                 Checkpoints.storeCheckpointMetadata(savepoint, out).                 finalizedLocation = out.closeAndFinalizeCheckpoint().             }             CompletedCheckpoint completed = new CompletedCheckpoint(jobId, checkpointId, checkpointTimestamp, System.currentTimeMillis(), operatorStates, masterState, props, finalizedLocation).             onCompletionPromise.complete(completed).             // to prevent null-pointers from concurrent modification, copy reference onto stack             PendingCheckpointStats statsCallback = this.statsCallback.             if (statsCallback != null) {                 // Finalize the statsCallback and give the completed checkpoint a                 // callback for discards.                 CompletedCheckpointStats.DiscardCallback discardCallback = statsCallback.reportCompletedCheckpoint(finalizedLocation.getExternalPointer()).                 completed.setDiscardCallback(discardCallback).             }             // mark this pending checkpoint as disposed, but do NOT drop the state             dispose(false).             return completed.         } catch (Throwable t) {             onCompletionPromise.completeExceptionally(t).             ExceptionUtils.rethrowIOException(t).             // silence the compiler             return null.         }     } }
true;public;3;78;/**  * Acknowledges the task with the given execution attempt id and the given subtask state.  *  * @param executionAttemptId of the acknowledged task  * @param operatorSubtaskStates of the acknowledged task  * @param metrics Checkpoint metrics for the stats  * @return TaskAcknowledgeResult of the operation  */ ;/**  * Acknowledges the task with the given execution attempt id and the given subtask state.  *  * @param executionAttemptId of the acknowledged task  * @param operatorSubtaskStates of the acknowledged task  * @param metrics Checkpoint metrics for the stats  * @return TaskAcknowledgeResult of the operation  */ public TaskAcknowledgeResult acknowledgeTask(ExecutionAttemptID executionAttemptId, TaskStateSnapshot operatorSubtaskStates, CheckpointMetrics metrics) {     synchronized (lock) {         if (discarded) {             return TaskAcknowledgeResult.DISCARDED.         }         final ExecutionVertex vertex = notYetAcknowledgedTasks.remove(executionAttemptId).         if (vertex == null) {             if (acknowledgedTasks.contains(executionAttemptId)) {                 return TaskAcknowledgeResult.DUPLICATE.             } else {                 return TaskAcknowledgeResult.UNKNOWN.             }         } else {             acknowledgedTasks.add(executionAttemptId).         }         List<OperatorID> operatorIDs = vertex.getJobVertex().getOperatorIDs().         int subtaskIndex = vertex.getParallelSubtaskIndex().         long ackTimestamp = System.currentTimeMillis().         long stateSize = 0L.         if (operatorSubtaskStates != null) {             for (OperatorID operatorID : operatorIDs) {                 OperatorSubtaskState operatorSubtaskState = operatorSubtaskStates.getSubtaskStateByOperatorID(operatorID).                 // if no real operatorSubtaskState was reported, we insert an empty state                 if (operatorSubtaskState == null) {                     operatorSubtaskState = new OperatorSubtaskState().                 }                 OperatorState operatorState = operatorStates.get(operatorID).                 if (operatorState == null) {                     operatorState = new OperatorState(operatorID, vertex.getTotalNumberOfParallelSubtasks(), vertex.getMaxParallelism()).                     operatorStates.put(operatorID, operatorState).                 }                 operatorState.putState(subtaskIndex, operatorSubtaskState).                 stateSize += operatorSubtaskState.getStateSize().             }         }         ++numAcknowledgedTasks.         // publish the checkpoint statistics         // to prevent null-pointers from concurrent modification, copy reference onto stack         final PendingCheckpointStats statsCallback = this.statsCallback.         if (statsCallback != null) {             // Do this in millis because the web frontend works with them             long alignmentDurationMillis = metrics.getAlignmentDurationNanos() / 1_000_000.             SubtaskStateStats subtaskStateStats = new SubtaskStateStats(subtaskIndex, ackTimestamp, stateSize, metrics.getSyncDurationMillis(), metrics.getAsyncDurationMillis(), metrics.getBytesBufferedInAlignment(), alignmentDurationMillis).             statsCallback.reportSubtaskStats(vertex.getJobvertexId(), subtaskStateStats).         }         return TaskAcknowledgeResult.SUCCESS.     } }
true;public;1;9;/**  * Adds a master state (state generated on the checkpoint coordinator) to  * the pending checkpoint.  *  * @param state The state to add  */ ;/**  * Adds a master state (state generated on the checkpoint coordinator) to  * the pending checkpoint.  *  * @param state The state to add  */ public void addMasterState(MasterState state) {     checkNotNull(state).     synchronized (lock) {         if (!discarded) {             masterState.add(state).         }     } }
true;public;0;9;/**  * Aborts a checkpoint because it expired (took too long).  */ ;// ------------------------------------------------------------------------ // Cancellation // ------------------------------------------------------------------------ /**  * Aborts a checkpoint because it expired (took too long).  */ public void abortExpired() {     try {         Exception cause = new Exception("Checkpoint expired before completing").         onCompletionPromise.completeExceptionally(cause).         reportFailedCheckpoint(cause).     } finally {         dispose(true).     } }
true;public;0;13;/**  * Aborts the pending checkpoint because a newer completed checkpoint subsumed it.  */ ;/**  * Aborts the pending checkpoint because a newer completed checkpoint subsumed it.  */ public void abortSubsumed() {     try {         Exception cause = new Exception("Checkpoints has been subsumed").         onCompletionPromise.completeExceptionally(cause).         reportFailedCheckpoint(cause).         if (props.forceCheckpoint()) {             throw new IllegalStateException("Bug: forced checkpoints must never be subsumed").         }     } finally {         dispose(true).     } }
false;public;0;3;;public void abortDeclined() {     abortWithCause(new Exception("Checkpoint was declined (tasks not ready)")). }
true;public;1;3;/**  * Aborts the pending checkpoint due to an error.  * @param cause The error's exception.  */ ;/**  * Aborts the pending checkpoint due to an error.  * @param cause The error's exception.  */ public void abortError(@Nonnull Throwable cause) {     abortWithCause(new Exception("Checkpoint failed: " + cause.getMessage(), cause)). }
false;private;1;8;;private void abortWithCause(@Nonnull Exception cause) {     try {         onCompletionPromise.completeExceptionally(cause).         reportFailedCheckpoint(cause).     } finally {         dispose(true).     } }
false;public;0;15;;@Override public void run() {     // unregistered shared states are still considered private at this point.     try {         StateUtil.bestEffortDiscardAllStateObjects(operatorStates.values()).         targetLocation.disposeOnFailure().     } catch (Throwable t) {         LOG.warn("Could not properly dispose the private states in the pending checkpoint {} of job {}.", checkpointId, jobId, t).     } finally {         operatorStates.clear().     } }
false;private;1;33;;private void dispose(boolean releaseState) {     synchronized (lock) {         try {             numAcknowledgedTasks = -1.             if (!discarded && releaseState) {                 executor.execute(new Runnable() {                      @Override                     public void run() {                         // unregistered shared states are still considered private at this point.                         try {                             StateUtil.bestEffortDiscardAllStateObjects(operatorStates.values()).                             targetLocation.disposeOnFailure().                         } catch (Throwable t) {                             LOG.warn("Could not properly dispose the private states in the pending checkpoint {} of job {}.", checkpointId, jobId, t).                         } finally {                             operatorStates.clear().                         }                     }                 }).             }         } finally {             discarded = true.             notYetAcknowledgedTasks.clear().             acknowledgedTasks.clear().             cancelCanceller().         }     } }
false;private;0;12;;private void cancelCanceller() {     try {         final ScheduledFuture<?> canceller = this.cancellerHandle.         if (canceller != null) {             canceller.cancel(false).         }     } catch (Exception e) {         // this code should not throw exceptions         LOG.warn("Error while cancelling checkpoint timeout task", e).     } }
true;private;1;8;/**  * Reports a failed checkpoint with the given optional cause.  *  * @param cause The failure cause or <code>null</code>.  */ ;/**  * Reports a failed checkpoint with the given optional cause.  *  * @param cause The failure cause or <code>null</code>.  */ private void reportFailedCheckpoint(Exception cause) {     // to prevent null-pointers from concurrent modification, copy reference onto stack     final PendingCheckpointStats statsCallback = this.statsCallback.     if (statsCallback != null) {         long failureTimestamp = System.currentTimeMillis().         statsCallback.reportFailedCheckpoint(failureTimestamp, cause).     } }
false;public;0;5;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ @Override public String toString() {     return String.format("Pending Checkpoint %d @ %d - confirmed=%d, pending=%d", checkpointId, checkpointTimestamp, getNumberOfAcknowledgedTasks(), getNumberOfNonAcknowledgedTasks()). }
