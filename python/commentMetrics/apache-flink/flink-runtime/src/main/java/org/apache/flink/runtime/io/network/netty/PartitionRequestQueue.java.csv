commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {     if (this.ctx == null) {         this.ctx = ctx.     }     super.channelRegistered(ctx). }
false;;1;12;;void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {     // The notification might come from the same thread. For the initial writes this     // might happen before the reader has set its reference to the view, because     // creating the queue and the initial notification happen in the same method call.     // This can be resolved by separating the creation of the view and allowing     // notifications.     // TODO This could potentially have a bad performance impact as in the     // worst case (network consumes faster than the producer) each buffer     // will trigger a separate event loop task being scheduled.     ctx.executor().execute(() -> ctx.pipeline().fireUserEventTriggered(reader)). }
true;private;1;14;/**  * Try to enqueue the reader once receiving credit notification from the consumer or receiving  * non-empty reader notification from the producer.  *  * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's  * availability, so there is no race condition here.  */ ;/**  * Try to enqueue the reader once receiving credit notification from the consumer or receiving  * non-empty reader notification from the producer.  *  * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's  * availability, so there is no race condition here.  */ private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {     if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {         return.     }     // Queue an available reader for consumption. If the queue is empty,     // we try trigger the actual write. Otherwise this will be handled by     // the writeAndFlushNextMessageIfPossible calls.     boolean triggerWrite = availableReaders.isEmpty().     registerAvailableReader(reader).     if (triggerWrite) {         writeAndFlushNextMessageIfPossible(ctx.channel()).     } }
true;;0;4;/**  * Accesses internal state to verify reader registration in the unit tests.  *  * <p><strong>Do not use anywhere else!</strong>  *  * @return readers which are enqueued available for transferring data  */ ;/**  * Accesses internal state to verify reader registration in the unit tests.  *  * <p><strong>Do not use anywhere else!</strong>  *  * @return readers which are enqueued available for transferring data  */ @VisibleForTesting ArrayDeque<NetworkSequenceViewReader> getAvailableReaders() {     return availableReaders. }
false;public;1;3;;public void notifyReaderCreated(final NetworkSequenceViewReader reader) {     allReaders.put(reader.getReceiverId(), reader). }
false;public;1;3;;public void cancel(InputChannelID receiverId) {     ctx.pipeline().fireUserEventTriggered(receiverId). }
false;public;0;5;;public void close() {     if (ctx != null) {         ctx.channel().close().     } }
true;;2;14;/**  * Adds unannounced credits from the consumer and enqueues the corresponding reader for this  * consumer (if not enqueued yet).  *  * @param receiverId The input channel id to identify the consumer.  * @param credit The unannounced credits of the consumer.  */ ;/**  * Adds unannounced credits from the consumer and enqueues the corresponding reader for this  * consumer (if not enqueued yet).  *  * @param receiverId The input channel id to identify the consumer.  * @param credit The unannounced credits of the consumer.  */ void addCredit(InputChannelID receiverId, int credit) throws Exception {     if (fatalError) {         return.     }     NetworkSequenceViewReader reader = allReaders.get(receiverId).     if (reader != null) {         reader.addCredit(credit).         enqueueAvailableReader(reader).     } else {         throw new IllegalStateException("No reader for receiverId = " + receiverId + " exists.").     } }
false;public;2;31;;@Override public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {     if (msg instanceof NetworkSequenceViewReader) {         enqueueAvailableReader((NetworkSequenceViewReader) msg).     } else if (msg.getClass() == InputChannelID.class) {         // Release partition view that get a cancel request.         InputChannelID toCancel = (InputChannelID) msg.         if (released.contains(toCancel)) {             return.         }         // Cancel the request for the input channel         int size = availableReaders.size().         for (int i = 0. i < size. i++) {             NetworkSequenceViewReader reader = pollAvailableReader().             if (reader.getReceiverId().equals(toCancel)) {                 reader.releaseAllResources().                 markAsReleased(reader.getReceiverId()).             } else {                 registerAvailableReader(reader).             }         }         allReaders.remove(toCancel).     } else {         ctx.fireUserEventTriggered(msg).     } }
false;public;1;4;;@Override public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {     writeAndFlushNextMessageIfPossible(ctx.channel()). }
false;private;1;70;;private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {     if (fatalError || !channel.isWritable()) {         return.     }     // The logic here is very similar to the combined input gate and local     // input channel logic. You can think of this class acting as the input     // gate and the consumed views as the local input channels.     BufferAndAvailability next = null.     try {         while (true) {             NetworkSequenceViewReader reader = pollAvailableReader().             // of the write callbacks that are executed after each write.             if (reader == null) {                 return.             }             next = reader.getNextBuffer().             if (next == null) {                 if (!reader.isReleased()) {                     continue.                 }                 markAsReleased(reader.getReceiverId()).                 Throwable cause = reader.getFailureCause().                 if (cause != null) {                     ErrorResponse msg = new ErrorResponse(new ProducerFailedException(cause), reader.getReceiverId()).                     ctx.writeAndFlush(msg).                 }             } else {                 // We re-add it into the queue if it is still available                 if (next.moreAvailable()) {                     registerAvailableReader(reader).                 }                 BufferResponse msg = new BufferResponse(next.buffer(), reader.getSequenceNumber(), reader.getReceiverId(), next.buffersInBacklog()).                 if (isEndOfPartitionEvent(next.buffer())) {                     reader.notifySubpartitionConsumed().                     reader.releaseAllResources().                     markAsReleased(reader.getReceiverId()).                 }                 // Write and flush and wait until this is done before                 // trying to continue with the next buffer.                 channel.writeAndFlush(msg).addListener(writeListener).                 return.             }         }     } catch (Throwable t) {         if (next != null) {             next.buffer().recycleBuffer().         }         throw new IOException(t.getMessage(), t).     } }
false;private;1;4;;private void registerAvailableReader(NetworkSequenceViewReader reader) {     availableReaders.add(reader).     reader.setRegisteredAsAvailable(true). }
false;private;0;8;;@Nullable private NetworkSequenceViewReader pollAvailableReader() {     NetworkSequenceViewReader reader = availableReaders.poll().     if (reader != null) {         reader.setRegisteredAsAvailable(false).     }     return reader. }
false;private;1;3;;private boolean isEndOfPartitionEvent(Buffer buffer) throws IOException {     return EventSerializer.isEvent(buffer, EndOfPartitionEvent.class). }
false;public;1;6;;@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {     releaseAllResources().     ctx.fireChannelInactive(). }
false;public;2;4;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {     handleException(ctx.channel(), cause). }
false;private;2;10;;private void handleException(Channel channel, Throwable cause) throws IOException {     LOG.error("Encountered error while consuming partitions", cause).     fatalError = true.     releaseAllResources().     if (channel.isActive()) {         channel.writeAndFlush(new ErrorResponse(cause)).addListener(ChannelFutureListener.CLOSE).     } }
false;private;0;10;;private void releaseAllResources() throws IOException {     // note: this is only ever executed by one thread: the Netty IO thread!     for (NetworkSequenceViewReader reader : allReaders.values()) {         reader.releaseAllResources().         markAsReleased(reader.getReceiverId()).     }     availableReaders.clear().     allReaders.clear(). }
true;private;1;3;/**  * Marks a receiver as released.  */ ;/**  * Marks a receiver as released.  */ private void markAsReleased(InputChannelID receiverId) {     released.add(receiverId). }
false;public;1;14;;@Override public void operationComplete(ChannelFuture future) throws Exception {     try {         if (future.isSuccess()) {             writeAndFlushNextMessageIfPossible(future.channel()).         } else if (future.cause() != null) {             handleException(future.channel(), future.cause()).         } else {             handleException(future.channel(), new IllegalStateException("Sending cancelled by user.")).         }     } catch (Throwable t) {         handleException(future.channel(), t).     } }
