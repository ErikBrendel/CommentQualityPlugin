commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public List<AbstractCheckpointStats> getCheckpoints() {     return checkpointsHistory. }
false;public;1;3;;public AbstractCheckpointStats getCheckpointById(long checkpointId) {     return checkpointsById.get(checkpointId). }
false;public;0;4;;@Nullable public CompletedCheckpointStats getLatestCompletedCheckpoint() {     return latestCompletedCheckpoint. }
false;public;0;4;;@Nullable public FailedCheckpointStats getLatestFailedCheckpoint() {     return latestFailedCheckpoint. }
false;public;0;4;;@Nullable public CompletedCheckpointStats getLatestSavepoint() {     return latestSavepoint. }
true;;0;50;/**  * Creates a snapshot of the current state.  *  * @return Snapshot of the current state.  */ ;/**  * Creates a snapshot of the current state.  *  * @return Snapshot of the current state.  */ CheckpointStatsHistory createSnapshot() {     if (readOnly) {         throw new UnsupportedOperationException("Can't create a snapshot of a read-only history.").     }     List<AbstractCheckpointStats> checkpointsHistory.     Map<Long, AbstractCheckpointStats> checkpointsById.     checkpointsById = new HashMap<>(checkpointsArray.length).     if (maxSize == 0) {         checkpointsHistory = Collections.emptyList().     } else {         AbstractCheckpointStats[] newCheckpointsArray = new AbstractCheckpointStats[checkpointsArray.length].         System.arraycopy(checkpointsArray, nextPos, newCheckpointsArray, 0, checkpointsArray.length - nextPos).         System.arraycopy(checkpointsArray, 0, newCheckpointsArray, checkpointsArray.length - nextPos, nextPos).         checkpointsHistory = Arrays.asList(newCheckpointsArray).         // reverse the order such that we start with the youngest checkpoint         Collections.reverse(checkpointsHistory).         for (AbstractCheckpointStats checkpoint : checkpointsHistory) {             checkpointsById.put(checkpoint.getCheckpointId(), checkpoint).         }     }     if (latestCompletedCheckpoint != null) {         checkpointsById.put(latestCompletedCheckpoint.getCheckpointId(), latestCompletedCheckpoint).     }     if (latestFailedCheckpoint != null) {         checkpointsById.put(latestFailedCheckpoint.getCheckpointId(), latestFailedCheckpoint).     }     if (latestSavepoint != null) {         checkpointsById.put(latestSavepoint.getCheckpointId(), latestSavepoint).     }     return new CheckpointStatsHistory(true, maxSize, null, checkpointsHistory, checkpointsById, latestCompletedCheckpoint, latestFailedCheckpoint, latestSavepoint). }
true;;1;26;/**  * Adds an in progress checkpoint to the checkpoint history.  *  * @param pending In progress checkpoint to add.  */ ;/**  * Adds an in progress checkpoint to the checkpoint history.  *  * @param pending In progress checkpoint to add.  */ void addInProgressCheckpoint(PendingCheckpointStats pending) {     if (readOnly) {         throw new UnsupportedOperationException("Can't create a snapshot of a read-only history.").     }     if (maxSize == 0) {         return.     }     checkNotNull(pending, "Pending checkpoint").     // null elements with the growing array.     if (checkpointsArray.length < maxSize) {         checkpointsArray = Arrays.copyOf(checkpointsArray, checkpointsArray.length + 1).     }     // added checkpoint.     if (nextPos == checkpointsArray.length) {         nextPos = 0.     }     checkpointsArray[nextPos++] = pending. }
true;;1;56;/**  * Searches for the in progress checkpoint with the given ID and replaces  * it with the given completed or failed checkpoint.  *  * <p>This is bounded by the maximum number of concurrent in progress  * checkpointsArray, which means that the runtime of this is constant.  *  * @param completedOrFailed The completed or failed checkpoint to replace the in progress checkpoint with.  * @return <code>true</code> if the checkpoint was replaced or <code>false</code> otherwise.  */ ;/**  * Searches for the in progress checkpoint with the given ID and replaces  * it with the given completed or failed checkpoint.  *  * <p>This is bounded by the maximum number of concurrent in progress  * checkpointsArray, which means that the runtime of this is constant.  *  * @param completedOrFailed The completed or failed checkpoint to replace the in progress checkpoint with.  * @return <code>true</code> if the checkpoint was replaced or <code>false</code> otherwise.  */ boolean replacePendingCheckpointById(AbstractCheckpointStats completedOrFailed) {     checkArgument(!completedOrFailed.getStatus().isInProgress(), "Not allowed to replace with in progress checkpoints.").     if (readOnly) {         throw new UnsupportedOperationException("Can't create a snapshot of a read-only history.").     }     // Update the latest checkpoint stats     if (completedOrFailed.getStatus().isCompleted()) {         CompletedCheckpointStats completed = (CompletedCheckpointStats) completedOrFailed.         if (completed.getProperties().isSavepoint() && (latestSavepoint == null || completed.getCheckpointId() > latestSavepoint.getCheckpointId())) {             latestSavepoint = completed.         } else if (latestCompletedCheckpoint == null || completed.getCheckpointId() > latestCompletedCheckpoint.getCheckpointId()) {             latestCompletedCheckpoint = completed.         }     } else if (completedOrFailed.getStatus().isFailed()) {         FailedCheckpointStats failed = (FailedCheckpointStats) completedOrFailed.         if (latestFailedCheckpoint == null || failed.getCheckpointId() > latestFailedCheckpoint.getCheckpointId()) {             latestFailedCheckpoint = failed.         }     }     if (maxSize == 0) {         return false.     }     long checkpointId = completedOrFailed.getCheckpointId().     // We start searching from the last inserted position. Since the entries     // wrap around the array we search until we are at index 0 and then from     // the end of the array until (start pos + 1).     int startPos = nextPos == checkpointsArray.length ? checkpointsArray.length - 1 : nextPos - 1.     for (int i = startPos. i >= 0. i--) {         if (checkpointsArray[i].getCheckpointId() == checkpointId) {             checkpointsArray[i] = completedOrFailed.             return true.         }     }     for (int i = checkpointsArray.length - 1. i > startPos. i--) {         if (checkpointsArray[i].getCheckpointId() == checkpointId) {             checkpointsArray[i] = completedOrFailed.             return true.         }     }     return false. }
