commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;19;;@Override protected void initChannel(SocketChannel socketChannel) {     try {         // SSL should be the first handler in the pipeline         if (sslHandlerFactory != null) {             socketChannel.pipeline().addLast("ssl", sslHandlerFactory.createNettySSLHandler()).         }         socketChannel.pipeline().addLast(new HttpClientCodec()).addLast(new HttpObjectAggregator(configuration.getMaxContentLength())).addLast(// required for multipart-requests         new ChunkedWriteHandler()).addLast(new IdleStateHandler(configuration.getIdlenessTimeout(), configuration.getIdlenessTimeout(), configuration.getIdlenessTimeout(), TimeUnit.MILLISECONDS)).addLast(new ClientHandler()).     } catch (Throwable t) {         t.printStackTrace().         ExceptionUtils.rethrow(t).     } }
false;public;0;4;;@Override public CompletableFuture<Void> closeAsync() {     return shutdownInternally(Time.seconds(10L)). }
false;public;1;10;;public void shutdown(Time timeout) {     final CompletableFuture<Void> shutDownFuture = shutdownInternally(timeout).     try {         shutDownFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS).         LOG.info("Rest endpoint shutdown complete.").     } catch (Exception e) {         LOG.warn("Rest endpoint shutdown failed.", e).     } }
false;private;1;19;;private CompletableFuture<Void> shutdownInternally(Time timeout) {     if (isRunning.compareAndSet(true, false)) {         LOG.info("Shutting down rest endpoint.").         if (bootstrap != null) {             if (bootstrap.group() != null) {                 bootstrap.group().shutdownGracefully(0L, timeout.toMilliseconds(), TimeUnit.MILLISECONDS).addListener(finished -> {                     if (finished.isSuccess()) {                         terminationFuture.complete(null).                     } else {                         terminationFuture.completeExceptionally(finished.cause()).                     }                 }).             }         }     }     return terminationFuture. }
false;public;3;6;;public <M extends MessageHeaders<EmptyRequestBody, P, EmptyMessageParameters>, P extends ResponseBody> CompletableFuture<P> sendRequest(String targetAddress, int targetPort, M messageHeaders) throws IOException {     return sendRequest(targetAddress, targetPort, messageHeaders, EmptyMessageParameters.getInstance(), EmptyRequestBody.getInstance()). }
false;public;5;8;;public <M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P> sendRequest(String targetAddress, int targetPort, M messageHeaders, U messageParameters, R request) throws IOException {     return sendRequest(targetAddress, targetPort, messageHeaders, messageParameters, request, Collections.emptyList()). }
false;public;6;16;;public <M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P> sendRequest(String targetAddress, int targetPort, M messageHeaders, U messageParameters, R request, Collection<FileUpload> fileUploads) throws IOException {     return sendRequest(targetAddress, targetPort, messageHeaders, messageParameters, request, fileUploads, RestAPIVersion.getLatestVersion(messageHeaders.getSupportedAPIVersions())). }
false;public;7;50;;public <M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P> sendRequest(String targetAddress, int targetPort, M messageHeaders, U messageParameters, R request, Collection<FileUpload> fileUploads, RestAPIVersion apiVersion) throws IOException {     Preconditions.checkNotNull(targetAddress).     Preconditions.checkArgument(0 <= targetPort && targetPort < 65536, "The target port " + targetPort + " is not in the range (0, 65536].").     Preconditions.checkNotNull(messageHeaders).     Preconditions.checkNotNull(request).     Preconditions.checkNotNull(messageParameters).     Preconditions.checkNotNull(fileUploads).     Preconditions.checkState(messageParameters.isResolved(), "Message parameters were not resolved.").     if (!messageHeaders.getSupportedAPIVersions().contains(apiVersion)) {         throw new IllegalArgumentException(String.format("The requested version %s is not supported by the request (method=%s URL=%s). Supported versions are: %s.", apiVersion, messageHeaders.getHttpMethod(), messageHeaders.getTargetRestEndpointURL(), messageHeaders.getSupportedAPIVersions().stream().map(RestAPIVersion::getURLVersionPrefix).collect(Collectors.joining(",")))).     }     String versionedHandlerURL = "/" + apiVersion.getURLVersionPrefix() + messageHeaders.getTargetRestEndpointURL().     String targetUrl = MessageParameters.resolveUrl(versionedHandlerURL, messageParameters).     LOG.debug("Sending request of class {} to {}:{}{}", request.getClass(), targetAddress, targetPort, targetUrl).     // serialize payload     StringWriter sw = new StringWriter().     objectMapper.writeValue(sw, request).     ByteBuf payload = Unpooled.wrappedBuffer(sw.toString().getBytes(ConfigConstants.DEFAULT_CHARSET)).     Request httpRequest = createRequest(targetAddress + ':' + targetPort, targetUrl, messageHeaders.getHttpMethod().getNettyHttpMethod(), payload, fileUploads).     final JavaType responseType.     final Collection<Class<?>> typeParameters = messageHeaders.getResponseTypeParameters().     if (typeParameters.isEmpty()) {         responseType = objectMapper.constructType(messageHeaders.getResponseClass()).     } else {         responseType = objectMapper.getTypeFactory().constructParametricType(messageHeaders.getResponseClass(), typeParameters.toArray(new Class<?>[typeParameters.size()])).     }     return submitRequest(targetAddress, targetPort, httpRequest, responseType). }
false;private,static;5;56;;private static Request createRequest(String targetAddress, String targetUrl, HttpMethod httpMethod, ByteBuf jsonPayload, Collection<FileUpload> fileUploads) throws IOException {     if (fileUploads.isEmpty()) {         HttpRequest httpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, httpMethod, targetUrl, jsonPayload).         httpRequest.headers().set(HttpHeaders.Names.HOST, targetAddress).set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE).add(HttpHeaders.Names.CONTENT_LENGTH, jsonPayload.capacity()).add(HttpHeaders.Names.CONTENT_TYPE, RestConstants.REST_CONTENT_TYPE).         return new SimpleRequest(httpRequest).     } else {         HttpRequest httpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, httpMethod, targetUrl).         httpRequest.headers().set(HttpHeaders.Names.HOST, targetAddress).set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE).         // takes care of splitting the request into multiple parts         HttpPostRequestEncoder bodyRequestEncoder.         try {             // we could use mixed attributes here but we have to ensure that the minimum size is greater than             // any file as the upload otherwise fails             DefaultHttpDataFactory httpDataFactory = new DefaultHttpDataFactory(true).             // the FileUploadHandler explicitly checks for multipart headers             bodyRequestEncoder = new HttpPostRequestEncoder(httpDataFactory, httpRequest, true).             Attribute requestAttribute = new MemoryAttribute(FileUploadHandler.HTTP_ATTRIBUTE_REQUEST).             requestAttribute.setContent(jsonPayload).             bodyRequestEncoder.addBodyHttpData(requestAttribute).             int fileIndex = 0.             for (FileUpload fileUpload : fileUploads) {                 Path path = fileUpload.getFile().                 if (Files.isDirectory(path)) {                     throw new IllegalArgumentException("Upload of directories is not supported. Dir=" + path).                 }                 File file = path.toFile().                 LOG.trace("Adding file {} to request.", file).                 bodyRequestEncoder.addBodyFileUpload("file_" + fileIndex, file, fileUpload.getContentType(), false).                 fileIndex++.             }         } catch (HttpPostRequestEncoder.ErrorDataEncoderException e) {             throw new IOException("Could not encode request.", e).         }         try {             httpRequest = bodyRequestEncoder.finalizeRequest().         } catch (HttpPostRequestEncoder.ErrorDataEncoderException e) {             throw new IOException("Could not finalize request.", e).         }         return new MultipartRequest(httpRequest, bodyRequestEncoder).     } }
false;private;4;45;;private <P extends ResponseBody> CompletableFuture<P> submitRequest(String targetAddress, int targetPort, Request httpRequest, JavaType responseType) {     final ChannelFuture connectFuture = bootstrap.connect(targetAddress, targetPort).     final CompletableFuture<Channel> channelFuture = new CompletableFuture<>().     connectFuture.addListener((ChannelFuture future) -> {         if (future.isSuccess()) {             channelFuture.complete(future.channel()).         } else {             channelFuture.completeExceptionally(future.cause()).         }     }).     return channelFuture.thenComposeAsync(channel -> {         ClientHandler handler = channel.pipeline().get(ClientHandler.class).         CompletableFuture<JsonResponse> future.         boolean success = false.         try {             if (handler == null) {                 throw new IOException("Netty pipeline was not properly initialized.").             } else {                 httpRequest.writeTo(channel).                 future = handler.getJsonFuture().                 success = true.             }         } catch (IOException e) {             future = FutureUtils.completedExceptionally(new ConnectionException("Could not write request.", e)).         } finally {             if (!success) {                 channel.close().             }         }         return future.     }, executor).thenComposeAsync((JsonResponse rawResponse) -> parseResponse(rawResponse, responseType), executor). }
false;private,static;2;26;;private static <P extends ResponseBody> CompletableFuture<P> parseResponse(JsonResponse rawResponse, JavaType responseType) {     CompletableFuture<P> responseFuture = new CompletableFuture<>().     final JsonParser jsonParser = objectMapper.treeAsTokens(rawResponse.json).     try {         P response = objectMapper.readValue(jsonParser, responseType).         responseFuture.complete(response).     } catch (IOException originalException) {         // lets see if it is an ErrorResponse instead         try {             ErrorResponseBody error = objectMapper.treeToValue(rawResponse.getJson(), ErrorResponseBody.class).             responseFuture.completeExceptionally(new RestClientException(error.errors.toString(), rawResponse.getHttpResponseStatus())).         } catch (JsonProcessingException jpe2) {             // if this fails it is either the expected type or response type was wrong, most likely caused             // by a client/search MessageHeaders mismatch             LOG.error("Received response was neither of the expected type ({}) nor an error. Response={}", responseType, rawResponse, jpe2).             responseFuture.completeExceptionally(new RestClientException("Response was neither of the expected type(" + responseType + ") nor an error.", originalException, rawResponse.getHttpResponseStatus())).         }     }     return responseFuture. }
false;;1;1;;void writeTo(Channel channel) throws IOException.
false;public;1;4;;@Override public void writeTo(Channel channel) {     channel.writeAndFlush(httpRequest). }
false;public;1;11;;@Override public void writeTo(Channel channel) {     ChannelFuture future = channel.writeAndFlush(httpRequest).     // this should never be false as we explicitly set the encoder to use multipart messages     if (bodyRequestEncoder.isChunked()) {         future = channel.writeAndFlush(bodyRequestEncoder).     }     // release data and remove temporary files if they were created, once the writing is complete     future.addListener((ignored) -> bodyRequestEncoder.cleanFiles()). }
false;;0;3;;CompletableFuture<JsonResponse> getJsonFuture() {     return jsonFuture. }
false;protected;2;28;;@Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) {     if (msg instanceof HttpResponse && ((HttpResponse) msg).status().equals(REQUEST_ENTITY_TOO_LARGE)) {         jsonFuture.completeExceptionally(new RestClientException(String.format(REQUEST_ENTITY_TOO_LARGE + ". Try to raise [%s]", RestOptions.CLIENT_MAX_CONTENT_LENGTH.key()), ((HttpResponse) msg).status())).     } else if (msg instanceof FullHttpResponse) {         readRawResponse((FullHttpResponse) msg).     } else {         LOG.error("Implementation error: Received a response that wasn't a FullHttpResponse.").         if (msg instanceof HttpResponse) {             jsonFuture.completeExceptionally(new RestClientException("Implementation error: Received a response that wasn't a FullHttpResponse.", ((HttpResponse) msg).getStatus())).         } else {             jsonFuture.completeExceptionally(new RestClientException("Implementation error: Received a response that wasn't a FullHttpResponse.", HttpResponseStatus.INTERNAL_SERVER_ERROR)).         }     }     ctx.close(). }
false;public;1;5;;@Override public void channelInactive(ChannelHandlerContext ctx) {     jsonFuture.completeExceptionally(new ConnectionClosedException("Channel became inactive.")).     ctx.close(). }
false;public;2;9;;@Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {     if (evt instanceof IdleStateEvent) {         jsonFuture.completeExceptionally(new ConnectionIdleException("Channel became idle.")).         ctx.close().     } else {         super.userEventTriggered(ctx, evt).     } }
false;public;2;11;;@Override public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) {     if (cause instanceof TooLongFrameException) {         jsonFuture.completeExceptionally(new TooLongFrameException(String.format(cause.getMessage() + " Try to raise [%s]", RestOptions.CLIENT_MAX_CONTENT_LENGTH.key()))).     } else {         jsonFuture.completeExceptionally(cause).     }     ctx.close(). }
false;private;1;28;;private void readRawResponse(FullHttpResponse msg) {     ByteBuf content = msg.content().     JsonNode rawResponse.     try (InputStream in = new ByteBufInputStream(content)) {         rawResponse = objectMapper.readTree(in).         LOG.debug("Received response {}.", rawResponse).     } catch (JsonProcessingException je) {         LOG.error("Response was not valid JSON.", je).         // let's see if it was a plain-text message instead         content.readerIndex(0).         try (ByteBufInputStream in = new ByteBufInputStream(content)) {             byte[] data = new byte[in.available()].             in.readFully(data).             String message = new String(data).             LOG.error("Unexpected plain-text response: {}", message).             jsonFuture.completeExceptionally(new RestClientException("Response was not valid JSON, but plain-text: " + message, je, msg.getStatus())).         } catch (IOException e) {             jsonFuture.completeExceptionally(new RestClientException("Response was not valid JSON, nor plain-text.", je, msg.getStatus())).         }         return.     } catch (IOException ioe) {         LOG.error("Response could not be read.", ioe).         jsonFuture.completeExceptionally(new RestClientException("Response could not be read.", ioe, msg.getStatus())).         return.     }     jsonFuture.complete(new JsonResponse(rawResponse, msg.getStatus())). }
false;public;0;3;;public JsonNode getJson() {     return json. }
false;public;0;3;;public HttpResponseStatus getHttpResponseStatus() {     return httpResponseStatus. }
false;public;0;7;;@Override public String toString() {     return "JsonResponse{" + "json=" + json + ", httpResponseStatus=" + httpResponseStatus + '}'. }
