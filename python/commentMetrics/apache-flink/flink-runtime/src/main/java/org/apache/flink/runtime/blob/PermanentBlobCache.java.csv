commented;modifiers;parameterAmount;loc;comment;code
true;public;1;15;/**  * Registers use of job-related BLOBs.  *  * <p>Using any other method to access BLOBs, e.g. {@link #getFile}, is only valid within  * calls to <tt>registerJob(JobID)</tt> and {@link #releaseJob(JobID)}.  *  * @param jobId  * 		ID of the job this blob belongs to  *  * @see #releaseJob(JobID)  */ ;/**  * Registers use of job-related BLOBs.  *  * <p>Using any other method to access BLOBs, e.g. {@link #getFile}, is only valid within  * calls to <tt>registerJob(JobID)</tt> and {@link #releaseJob(JobID)}.  *  * @param jobId  * 		ID of the job this blob belongs to  *  * @see #releaseJob(JobID)  */ public void registerJob(JobID jobId) {     checkNotNull(jobId).     synchronized (jobRefCounters) {         RefCount ref = jobRefCounters.get(jobId).         if (ref == null) {             ref = new RefCount().             jobRefCounters.put(jobId, ref).         } else {             // reset cleanup timeout             ref.keepUntil = -1.         }         ++ref.references.     } }
true;public;1;17;/**  * Unregisters use of job-related BLOBs and allow them to be released.  *  * @param jobId  * 		ID of the job this blob belongs to  *  * @see #registerJob(JobID)  */ ;/**  * Unregisters use of job-related BLOBs and allow them to be released.  *  * @param jobId  * 		ID of the job this blob belongs to  *  * @see #registerJob(JobID)  */ public void releaseJob(JobID jobId) {     checkNotNull(jobId).     synchronized (jobRefCounters) {         RefCount ref = jobRefCounters.get(jobId).         if (ref == null || ref.references == 0) {             log.warn("improper use of releaseJob() without a matching number of registerJob() calls for jobId " + jobId).             return.         }         --ref.references.         if (ref.references == 0) {             ref.keepUntil = System.currentTimeMillis() + cleanupInterval.         }     } }
false;public;1;12;;public int getNumberOfReferenceHolders(JobID jobId) {     checkNotNull(jobId).     synchronized (jobRefCounters) {         RefCount ref = jobRefCounters.get(jobId).         if (ref == null) {             return 0.         } else {             return ref.references.         }     } }
true;public;2;5;/**  * Returns the path to a local copy of the file associated with the provided job ID and blob  * key.  *  * <p>We will first attempt to serve the BLOB from the local storage. If the BLOB is not in  * there, we will try to download it from the HA store, or directly from the {@link BlobServer}.  *  * @param jobId  * 		ID of the job this blob belongs to  * @param key  * 		blob key associated with the requested file  *  * @return The path to the file.  *  * @throws java.io.FileNotFoundException  * 		if the BLOB does not exist.  * @throws IOException  * 		if any other error occurs when retrieving the file  */ ;/**  * Returns the path to a local copy of the file associated with the provided job ID and blob  * key.  *  * <p>We will first attempt to serve the BLOB from the local storage. If the BLOB is not in  * there, we will try to download it from the HA store, or directly from the {@link BlobServer}.  *  * @param jobId  * 		ID of the job this blob belongs to  * @param key  * 		blob key associated with the requested file  *  * @return The path to the file.  *  * @throws java.io.FileNotFoundException  * 		if the BLOB does not exist.  * @throws IOException  * 		if any other error occurs when retrieving the file  */ @Override public File getFile(JobID jobId, PermanentBlobKey key) throws IOException {     checkNotNull(jobId).     return getFileInternal(jobId, key). }
true;public;2;5;/**  * Returns a file handle to the file associated with the given blob key on the blob  * server.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param key  * 		identifying the file  *  * @return file handle to the file  *  * @throws IOException  * 		if creating the directory fails  */ ;/**  * Returns a file handle to the file associated with the given blob key on the blob  * server.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param key  * 		identifying the file  *  * @return file handle to the file  *  * @throws IOException  * 		if creating the directory fails  */ @VisibleForTesting public File getStorageLocation(JobID jobId, BlobKey key) throws IOException {     checkNotNull(jobId).     return BlobUtils.getStorageLocation(storageDir, jobId, key). }
true;;0;4;/**  * Returns the job reference counters - for testing purposes only!  *  * @return job reference counters (internal state!)  */ ;/**  * Returns the job reference counters - for testing purposes only!  *  * @return job reference counters (internal state!)  */ @VisibleForTesting Map<JobID, RefCount> getJobRefCounters() {     return jobRefCounters. }
true;public;0;42;/**  * Cleans up BLOBs which are not referenced anymore.  */ ;/**  * Cleans up BLOBs which are not referenced anymore.  */ @Override public void run() {     synchronized (jobRefCounters) {         Iterator<Map.Entry<JobID, RefCount>> entryIter = jobRefCounters.entrySet().iterator().         final long currentTimeMillis = System.currentTimeMillis().         while (entryIter.hasNext()) {             Map.Entry<JobID, RefCount> entry = entryIter.next().             RefCount ref = entry.getValue().             if (ref.references <= 0 && ref.keepUntil > 0 && currentTimeMillis >= ref.keepUntil) {                 JobID jobId = entry.getKey().                 final File localFile = new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId)).                 /* 					 * NOTE: normally it is not required to acquire the write lock to delete the job's 					 *       storage directory since there should be no one accessing it with the ref 					 *       counter being 0 - acquire it just in case, to always be on the safe side 					 */                 readWriteLock.writeLock().lock().                 boolean success = false.                 try {                     FileUtils.deleteDirectory(localFile).                     success = true.                 } catch (Throwable t) {                     log.warn("Failed to locally delete job directory " + localFile.getAbsolutePath(), t).                 } finally {                     readWriteLock.writeLock().unlock().                 }                 // (does not need the write lock)                 if (success) {                     entryIter.remove().                 }             }         }     } }
false;protected;0;4;;@Override protected void cancelCleanupTask() {     cleanupTimer.cancel(). }
