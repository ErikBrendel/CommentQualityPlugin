commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the rpc endpoint's identifier.  *  * @return Rpc endpoint's identifier.  */ ;/**  * Returns the rpc endpoint's identifier.  *  * @return Rpc endpoint's identifier.  */ public String getEndpointId() {     return endpointId. }
true;public,final;0;3;/**  * Starts the rpc endpoint. This tells the underlying rpc server that the rpc endpoint is ready  * to process remote procedure calls.  *  * @throws Exception indicating that something went wrong while starting the RPC endpoint  */ ;// ------------------------------------------------------------------------ // Start & shutdown & lifecycle callbacks // ------------------------------------------------------------------------ /**  * Starts the rpc endpoint. This tells the underlying rpc server that the rpc endpoint is ready  * to process remote procedure calls.  *  * @throws Exception indicating that something went wrong while starting the RPC endpoint  */ public final void start() {     rpcServer.start(). }
true;public;0;1;/**  * User overridable callback.  *  * <p>This method is called when the RpcEndpoint is being started. The method is guaranteed  * to be executed in the main thread context and can be used to start the rpc endpoint in the  * context of the rpc endpoint's main thread.  *  * <p>IMPORTANT: This method should never be called directly by the user.  * @throws Exception indicating that the rpc endpoint could not be started. If an exception occurs,  * then the rpc endpoint will automatically terminate.  */ ;/**  * User overridable callback.  *  * <p>This method is called when the RpcEndpoint is being started. The method is guaranteed  * to be executed in the main thread context and can be used to start the rpc endpoint in the  * context of the rpc endpoint's main thread.  *  * <p>IMPORTANT: This method should never be called directly by the user.  * @throws Exception indicating that the rpc endpoint could not be started. If an exception occurs,  * then the rpc endpoint will automatically terminate.  */ public void onStart() throws Exception { }
true;protected,final;0;3;/**  * Stops the rpc endpoint. This tells the underlying rpc server that the rpc endpoint is  * no longer ready to process remote procedure calls.  */ ;/**  * Stops the rpc endpoint. This tells the underlying rpc server that the rpc endpoint is  * no longer ready to process remote procedure calls.  */ protected final void stop() {     rpcServer.stop(). }
true;public;0;3;/**  * User overridable callback.  *  * <p>This method is called when the RpcEndpoint is being shut down. The method is guaranteed  * to be executed in the main thread context and can be used to clean up internal state.  *  * <p>IMPORTANT: This method should never be called directly by the user.  *  * @return Future which is completed once all post stop actions are completed. If an error  * occurs this future is completed exceptionally  */ ;/**  * User overridable callback.  *  * <p>This method is called when the RpcEndpoint is being shut down. The method is guaranteed  * to be executed in the main thread context and can be used to clean up internal state.  *  * <p>IMPORTANT: This method should never be called directly by the user.  *  * @return Future which is completed once all post stop actions are completed. If an error  * occurs this future is completed exceptionally  */ public CompletableFuture<Void> onStop() {     return CompletableFuture.completedFuture(null). }
true;public,final;0;5;/**  * Triggers the shut down of the rpc endpoint. The shut down is executed asynchronously.  *  * <p>In order to wait on the completion of the shut down, obtain the termination future  * via {@link #getTerminationFuture()}} and wait on its completion.  */ ;/**  * Triggers the shut down of the rpc endpoint. The shut down is executed asynchronously.  *  * <p>In order to wait on the completion of the shut down, obtain the termination future  * via {@link #getTerminationFuture()}} and wait on its completion.  */ @Override public final CompletableFuture<Void> closeAsync() {     rpcService.stopServer(rpcServer).     return getTerminationFuture(). }
true;public;1;10;/**  * Returns a self gateway of the specified type which can be used to issue asynchronous  * calls against the RpcEndpoint.  *  * <p>IMPORTANT: The self gateway type must be implemented by the RpcEndpoint. Otherwise  * the method will fail.  *  * @param selfGatewayType class of the self gateway type  * @param <C> type of the self gateway to create  * @return Self gateway of the specified type which can be used to issue asynchronous rpcs  */ ;// ------------------------------------------------------------------------ // Basic RPC endpoint properties // ------------------------------------------------------------------------ /**  * Returns a self gateway of the specified type which can be used to issue asynchronous  * calls against the RpcEndpoint.  *  * <p>IMPORTANT: The self gateway type must be implemented by the RpcEndpoint. Otherwise  * the method will fail.  *  * @param selfGatewayType class of the self gateway type  * @param <C> type of the self gateway to create  * @return Self gateway of the specified type which can be used to issue asynchronous rpcs  */ public <C extends RpcGateway> C getSelfGateway(Class<C> selfGatewayType) {     if (selfGatewayType.isInstance(rpcServer)) {         @SuppressWarnings("unchecked")         C selfGateway = ((C) rpcServer).         return selfGateway.     } else {         throw new RuntimeException("RpcEndpoint does not implement the RpcGateway interface of type " + selfGatewayType + '.').     } }
true;public;0;4;/**  * Gets the address of the underlying RPC endpoint. The address should be fully qualified so that  * a remote system can connect to this RPC endpoint via this address.  *  * @return Fully qualified address of the underlying RPC endpoint  */ ;/**  * Gets the address of the underlying RPC endpoint. The address should be fully qualified so that  * a remote system can connect to this RPC endpoint via this address.  *  * @return Fully qualified address of the underlying RPC endpoint  */ @Override public String getAddress() {     return rpcServer.getAddress(). }
true;public;0;4;/**  * Gets the hostname of the underlying RPC endpoint.  *  * @return Hostname on which the RPC endpoint is running  */ ;/**  * Gets the hostname of the underlying RPC endpoint.  *  * @return Hostname on which the RPC endpoint is running  */ @Override public String getHostname() {     return rpcServer.getHostname(). }
true;protected;0;3;/**  * Gets the main thread execution context. The main thread execution context can be used to  * execute tasks in the main thread of the underlying RPC endpoint.  *  * @return Main thread execution context  */ ;/**  * Gets the main thread execution context. The main thread execution context can be used to  * execute tasks in the main thread of the underlying RPC endpoint.  *  * @return Main thread execution context  */ protected MainThreadExecutor getMainThreadExecutor() {     return mainThreadExecutor. }
true;public;0;3;/**  * Gets the endpoint's RPC service.  *  * @return The endpoint's RPC service  */ ;/**  * Gets the endpoint's RPC service.  *  * @return The endpoint's RPC service  */ public RpcService getRpcService() {     return rpcService. }
true;public;0;3;/**  * Return a future which is completed with true when the rpc endpoint has been terminated.  * In case of a failure, this future is completed with the occurring exception.  *  * @return Future which is completed when the rpc endpoint has been terminated.  */ ;/**  * Return a future which is completed with true when the rpc endpoint has been terminated.  * In case of a failure, this future is completed with the occurring exception.  *  * @return Future which is completed when the rpc endpoint has been terminated.  */ public CompletableFuture<Void> getTerminationFuture() {     return rpcServer.getTerminationFuture(). }
true;protected;1;3;/**  * Execute the runnable in the main thread of the underlying RPC endpoint.  *  * @param runnable Runnable to be executed in the main thread of the underlying RPC endpoint  */ ;// ------------------------------------------------------------------------ // Asynchronous executions // ------------------------------------------------------------------------ /**  * Execute the runnable in the main thread of the underlying RPC endpoint.  *  * @param runnable Runnable to be executed in the main thread of the underlying RPC endpoint  */ protected void runAsync(Runnable runnable) {     rpcServer.runAsync(runnable). }
true;protected;2;3;/**  * Execute the runnable in the main thread of the underlying RPC endpoint, with  * a delay of the given number of milliseconds.  *  * @param runnable Runnable to be executed  * @param delay    The delay after which the runnable will be executed  */ ;/**  * Execute the runnable in the main thread of the underlying RPC endpoint, with  * a delay of the given number of milliseconds.  *  * @param runnable Runnable to be executed  * @param delay    The delay after which the runnable will be executed  */ protected void scheduleRunAsync(Runnable runnable, Time delay) {     scheduleRunAsync(runnable, delay.getSize(), delay.getUnit()). }
true;protected;3;3;/**  * Execute the runnable in the main thread of the underlying RPC endpoint, with  * a delay of the given number of milliseconds.  *  * @param runnable Runnable to be executed  * @param delay    The delay after which the runnable will be executed  */ ;/**  * Execute the runnable in the main thread of the underlying RPC endpoint, with  * a delay of the given number of milliseconds.  *  * @param runnable Runnable to be executed  * @param delay    The delay after which the runnable will be executed  */ protected void scheduleRunAsync(Runnable runnable, long delay, TimeUnit unit) {     rpcServer.scheduleRunAsync(runnable, unit.toMillis(delay)). }
true;protected;2;3;/**  * Execute the callable in the main thread of the underlying RPC service, returning a future for  * the result of the callable. If the callable is not completed within the given timeout, then  * the future will be failed with a {@link TimeoutException}.  *  * @param callable Callable to be executed in the main thread of the underlying rpc server  * @param timeout Timeout for the callable to be completed  * @param <V> Return type of the callable  * @return Future for the result of the callable.  */ ;/**  * Execute the callable in the main thread of the underlying RPC service, returning a future for  * the result of the callable. If the callable is not completed within the given timeout, then  * the future will be failed with a {@link TimeoutException}.  *  * @param callable Callable to be executed in the main thread of the underlying rpc server  * @param timeout Timeout for the callable to be completed  * @param <V> Return type of the callable  * @return Future for the result of the callable.  */ protected <V> CompletableFuture<V> callAsync(Callable<V> callable, Time timeout) {     return rpcServer.callAsync(callable, timeout). }
true;public;0;3;/**  * Validates that the method call happens in the RPC endpoint's main thread.  *  * <p><b>IMPORTANT:</b> This check only happens when assertions are enabled,  * such as when running tests.  *  * <p>This can be used for additional checks, like  * <pre>{@code  * protected void concurrencyCriticalMethod() {  *     validateRunsInMainThread().  *  *     // some critical stuff  * }  * }</pre>  */ ;// ------------------------------------------------------------------------ // Main Thread Validation // ------------------------------------------------------------------------ /**  * Validates that the method call happens in the RPC endpoint's main thread.  *  * <p><b>IMPORTANT:</b> This check only happens when assertions are enabled,  * such as when running tests.  *  * <p>This can be used for additional checks, like  * <pre>{@code  * protected void concurrencyCriticalMethod() {  *     validateRunsInMainThread().  *  *     // some critical stuff  * }  * }</pre>  */ public void validateRunsInMainThread() {     assert MainThreadValidatorUtil.isRunningInExpectedThread(currentMainThread.get()). }
false;public;1;3;;public void runAsync(Runnable runnable) {     gateway.runAsync(runnable). }
false;public;2;3;;public void scheduleRunAsync(Runnable runnable, long delayMillis) {     gateway.scheduleRunAsync(runnable, delayMillis). }
false;public;1;3;;public void execute(@Nonnull Runnable command) {     runAsync(command). }
false;public;3;7;;@Override public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {     final long delayMillis = TimeUnit.MILLISECONDS.convert(delay, unit).     FutureTask<Void> ft = new FutureTask<>(command, null).     scheduleRunAsync(ft, delayMillis).     return new ScheduledFutureAdapter<>(ft, delayMillis, TimeUnit.MILLISECONDS). }
false;public;3;4;;@Override public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {     throw new UnsupportedOperationException("Not implemented because the method is currently not required."). }
false;public;4;4;;@Override public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {     throw new UnsupportedOperationException("Not implemented because the method is currently not required."). }
false;public;4;4;;@Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {     throw new UnsupportedOperationException("Not implemented because the method is currently not required."). }
false;public;0;4;;@Override public void assertRunningInMainThread() {     mainThreadCheck.run(). }
