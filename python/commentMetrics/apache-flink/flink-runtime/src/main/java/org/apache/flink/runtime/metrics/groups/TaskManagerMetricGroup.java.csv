commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String hostname() {     return hostname. }
false;public;0;3;;public String taskManagerId() {     return taskManagerId. }
false;protected;1;4;;@Override protected QueryScopeInfo.TaskManagerQueryScopeInfo createQueryServiceMetricInfo(CharacterFilter filter) {     return new QueryScopeInfo.TaskManagerQueryScopeInfo(this.taskManagerId). }
false;public;7;45;;// ------------------------------------------------------------------------ // job groups // ------------------------------------------------------------------------ public TaskMetricGroup addTaskForJob(final JobID jobId, final String jobName, final JobVertexID jobVertexId, final ExecutionAttemptID executionAttemptId, final String taskName, final int subtaskIndex, final int attemptNumber) {     Preconditions.checkNotNull(jobId).     String resolvedJobName = jobName == null || jobName.isEmpty() ? jobId.toString() : jobName.     // because it might lead to a deadlock     while (true) {         // get or create a jobs metric group         TaskManagerJobMetricGroup currentJobGroup.         synchronized (this) {             currentJobGroup = jobs.get(jobId).             if (currentJobGroup == null || currentJobGroup.isClosed()) {                 currentJobGroup = new TaskManagerJobMetricGroup(registry, this, jobId, resolvedJobName).                 jobs.put(jobId, currentJobGroup).             }         }         // try to add another task. this may fail if we found a pre-existing job metrics         // group and it is closed concurrently         TaskMetricGroup taskGroup = currentJobGroup.addTask(jobVertexId, executionAttemptId, taskName, subtaskIndex, attemptNumber).         if (taskGroup != null) {             // successfully added the next task             return taskGroup.         }     // else fall through the loop     } }
false;public;2;15;;public void removeJobMetricsGroup(JobID jobId, TaskManagerJobMetricGroup group) {     if (jobId == null || group == null || !group.isClosed()) {         return.     }     synchronized (this) {         // optimistically remove the currently contained group, and check later if it was correct         TaskManagerJobMetricGroup containedGroup = jobs.remove(jobId).         // check if another group was actually contained, and restore that one         if (containedGroup != null && containedGroup != group) {             jobs.put(jobId, containedGroup).         }     } }
false;public;0;3;;public int numRegisteredJobMetricGroups() {     return jobs.size(). }
false;protected;1;5;;// ------------------------------------------------------------------------ // Component Metric Group Specifics // ------------------------------------------------------------------------ @Override protected void putVariables(Map<String, String> variables) {     variables.put(ScopeFormat.SCOPE_HOST, hostname).     variables.put(ScopeFormat.SCOPE_TASKMANAGER_ID, taskManagerId). }
false;protected;0;4;;@Override protected Iterable<? extends ComponentMetricGroup> subComponents() {     return jobs.values(). }
false;protected;1;4;;@Override protected String getGroupName(CharacterFilter filter) {     return "taskmanager". }
