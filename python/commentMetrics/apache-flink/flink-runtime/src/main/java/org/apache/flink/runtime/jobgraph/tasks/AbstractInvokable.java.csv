commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;0;1;/**  * Starts the execution.  *  * <p>Must be overwritten by the concrete task implementation. This method  * is called by the task manager when the actual execution of the task  * starts.  *  * <p>All resources should be cleaned up when the method returns. Make sure  * to guard the code with <code>try-finally</code> blocks where necessary.  *  * @throws Exception  *         Tasks may forward their exceptions for the TaskManager to handle through failure/recovery.  */ ;// ------------------------------------------------------------------------ // Core methods // ------------------------------------------------------------------------ /**  * Starts the execution.  *  * <p>Must be overwritten by the concrete task implementation. This method  * is called by the task manager when the actual execution of the task  * starts.  *  * <p>All resources should be cleaned up when the method returns. Make sure  * to guard the code with <code>try-finally</code> blocks where necessary.  *  * @throws Exception  *         Tasks may forward their exceptions for the TaskManager to handle through failure/recovery.  */ public abstract void invoke() throws Exception.
true;public;0;3;/**  * This method is called when a task is canceled either as a result of a user abort or an execution failure. It can  * be overwritten to respond to shut down the user code properly.  *  * @throws Exception  *         thrown if any exception occurs during the execution of the user code  */ ;/**  * This method is called when a task is canceled either as a result of a user abort or an execution failure. It can  * be overwritten to respond to shut down the user code properly.  *  * @throws Exception  *         thrown if any exception occurs during the execution of the user code  */ public void cancel() throws Exception { // The default implementation does nothing. }
true;public;1;3;/**  * Sets whether the thread that executes the {@link #invoke()} method should be  * interrupted during cancellation. This method sets the flag for both the initial  * interrupt, as well as for the repeated interrupt. Setting the interruption to  * false at some point during the cancellation procedure is a way to stop further  * interrupts from happening.  */ ;/**  * Sets whether the thread that executes the {@link #invoke()} method should be  * interrupted during cancellation. This method sets the flag for both the initial  * interrupt, as well as for the repeated interrupt. Setting the interruption to  * false at some point during the cancellation procedure is a way to stop further  * interrupts from happening.  */ public void setShouldInterruptOnCancel(boolean shouldInterruptOnCancel) {     this.shouldInterruptOnCancel = shouldInterruptOnCancel. }
true;public;0;3;/**  * Checks whether the task should be interrupted during cancellation.  * This method is check both for the initial interrupt, as well as for the  * repeated interrupt. Setting the interruption to false via  * {@link #setShouldInterruptOnCancel(boolean)} is a way to stop further interrupts  * from happening.  */ ;/**  * Checks whether the task should be interrupted during cancellation.  * This method is check both for the initial interrupt, as well as for the  * repeated interrupt. Setting the interruption to false via  * {@link #setShouldInterruptOnCancel(boolean)} is a way to stop further interrupts  * from happening.  */ public boolean shouldInterruptOnCancel() {     return shouldInterruptOnCancel. }
true;public;0;3;/**  * Returns the environment of this task.  *  * @return The environment of this task.  */ ;// ------------------------------------------------------------------------ // Access to Environment and Configuration // ------------------------------------------------------------------------ /**  * Returns the environment of this task.  *  * @return The environment of this task.  */ public Environment getEnvironment() {     return this.environment. }
true;public;0;3;/**  * Returns the user code class loader of this invokable.  *  * @return user code class loader of this invokable.  */ ;/**  * Returns the user code class loader of this invokable.  *  * @return user code class loader of this invokable.  */ public ClassLoader getUserCodeClassLoader() {     return getEnvironment().getUserClassLoader(). }
true;public;0;3;/**  * Returns the current number of subtasks the respective task is split into.  *  * @return the current number of subtasks the respective task is split into  */ ;/**  * Returns the current number of subtasks the respective task is split into.  *  * @return the current number of subtasks the respective task is split into  */ public int getCurrentNumberOfSubtasks() {     return this.environment.getTaskInfo().getNumberOfParallelSubtasks(). }
true;public;0;3;/**  * Returns the index of this subtask in the subtask group.  *  * @return the index of this subtask in the subtask group  */ ;/**  * Returns the index of this subtask in the subtask group.  *  * @return the index of this subtask in the subtask group  */ public int getIndexInSubtaskGroup() {     return this.environment.getTaskInfo().getIndexOfThisSubtask(). }
true;public;0;3;/**  * Returns the task configuration object which was attached to the original {@link org.apache.flink.runtime.jobgraph.JobVertex}.  *  * @return the task configuration object which was attached to the original {@link org.apache.flink.runtime.jobgraph.JobVertex}  */ ;/**  * Returns the task configuration object which was attached to the original {@link org.apache.flink.runtime.jobgraph.JobVertex}.  *  * @return the task configuration object which was attached to the original {@link org.apache.flink.runtime.jobgraph.JobVertex}  */ public Configuration getTaskConfiguration() {     return this.environment.getTaskConfiguration(). }
true;public;0;3;/**  * Returns the job configuration object which was attached to the original {@link org.apache.flink.runtime.jobgraph.JobGraph}.  *  * @return the job configuration object which was attached to the original {@link org.apache.flink.runtime.jobgraph.JobGraph}  */ ;/**  * Returns the job configuration object which was attached to the original {@link org.apache.flink.runtime.jobgraph.JobGraph}.  *  * @return the job configuration object which was attached to the original {@link org.apache.flink.runtime.jobgraph.JobGraph}  */ public Configuration getJobConfiguration() {     return this.environment.getJobConfiguration(). }
true;public;0;3;/**  * Returns the global ExecutionConfig.  */ ;/**  * Returns the global ExecutionConfig.  */ public ExecutionConfig getExecutionConfig() {     return this.environment.getExecutionConfig(). }
true;public;2;3;/**  * This method is called to trigger a checkpoint, asynchronously by the checkpoint  * coordinator.  *  * <p>This method is called for tasks that start the checkpoints by injecting the initial barriers,  * i.e., the source tasks. In contrast, checkpoints on downstream operators, which are the result of  * receiving checkpoint barriers, invoke the {@link #triggerCheckpointOnBarrier(CheckpointMetaData, CheckpointOptions, CheckpointMetrics)}  * method.  *  * @param checkpointMetaData Meta data for about this checkpoint  * @param checkpointOptions Options for performing this checkpoint  *  * @return {@code false} if the checkpoint can not be carried out, {@code true} otherwise  */ ;// ------------------------------------------------------------------------ // Checkpointing Methods // ------------------------------------------------------------------------ /**  * This method is called to trigger a checkpoint, asynchronously by the checkpoint  * coordinator.  *  * <p>This method is called for tasks that start the checkpoints by injecting the initial barriers,  * i.e., the source tasks. In contrast, checkpoints on downstream operators, which are the result of  * receiving checkpoint barriers, invoke the {@link #triggerCheckpointOnBarrier(CheckpointMetaData, CheckpointOptions, CheckpointMetrics)}  * method.  *  * @param checkpointMetaData Meta data for about this checkpoint  * @param checkpointOptions Options for performing this checkpoint  *  * @return {@code false} if the checkpoint can not be carried out, {@code true} otherwise  */ public boolean triggerCheckpoint(CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions) throws Exception {     throw new UnsupportedOperationException(String.format("triggerCheckpoint not supported by %s", this.getClass().getName())). }
true;public;3;3;/**  * This method is called when a checkpoint is triggered as a result of receiving checkpoint  * barriers on all input streams.  *  * @param checkpointMetaData Meta data for about this checkpoint  * @param checkpointOptions Options for performing this checkpoint  * @param checkpointMetrics Metrics about this checkpoint  *  * @throws Exception Exceptions thrown as the result of triggering a checkpoint are forwarded.  */ ;/**  * This method is called when a checkpoint is triggered as a result of receiving checkpoint  * barriers on all input streams.  *  * @param checkpointMetaData Meta data for about this checkpoint  * @param checkpointOptions Options for performing this checkpoint  * @param checkpointMetrics Metrics about this checkpoint  *  * @throws Exception Exceptions thrown as the result of triggering a checkpoint are forwarded.  */ public void triggerCheckpointOnBarrier(CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions, CheckpointMetrics checkpointMetrics) throws Exception {     throw new UnsupportedOperationException(String.format("triggerCheckpointOnBarrier not supported by %s", this.getClass().getName())). }
true;public;2;3;/**  * Aborts a checkpoint as the result of receiving possibly some checkpoint barriers,  * but at least one {@link org.apache.flink.runtime.io.network.api.CancelCheckpointMarker}.  *  * <p>This requires implementing tasks to forward a  * {@link org.apache.flink.runtime.io.network.api.CancelCheckpointMarker} to their outputs.  *  * @param checkpointId The ID of the checkpoint to be aborted.  * @param cause The reason why the checkpoint was aborted during alignment  */ ;/**  * Aborts a checkpoint as the result of receiving possibly some checkpoint barriers,  * but at least one {@link org.apache.flink.runtime.io.network.api.CancelCheckpointMarker}.  *  * <p>This requires implementing tasks to forward a  * {@link org.apache.flink.runtime.io.network.api.CancelCheckpointMarker} to their outputs.  *  * @param checkpointId The ID of the checkpoint to be aborted.  * @param cause The reason why the checkpoint was aborted during alignment  */ public void abortCheckpointOnBarrier(long checkpointId, Throwable cause) throws Exception {     throw new UnsupportedOperationException(String.format("abortCheckpointOnBarrier not supported by %s", this.getClass().getName())). }
true;public;1;3;/**  * Invoked when a checkpoint has been completed, i.e., when the checkpoint coordinator has received  * the notification from all participating tasks.  *  * @param checkpointId The ID of the checkpoint that is complete..  * @throws Exception The notification method may forward its exceptions.  */ ;/**  * Invoked when a checkpoint has been completed, i.e., when the checkpoint coordinator has received  * the notification from all participating tasks.  *  * @param checkpointId The ID of the checkpoint that is complete..  * @throws Exception The notification method may forward its exceptions.  */ public void notifyCheckpointComplete(long checkpointId) throws Exception {     throw new UnsupportedOperationException(String.format("notifyCheckpointComplete not supported by %s", this.getClass().getName())). }
