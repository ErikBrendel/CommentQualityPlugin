commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;// ------------------------------------------------------------------------ // Properties // ------------------------------------------------------------------------ @Override public boolean isDestroyed() {     synchronized (availableMemorySegments) {         return isDestroyed.     } }
false;public;0;4;;@Override public int getMemorySegmentSize() {     return networkBufferPool.getMemorySegmentSize(). }
false;public;0;4;;@Override public int getNumberOfRequiredMemorySegments() {     return numberOfRequiredMemorySegments. }
false;public;0;4;;@Override public int getMaxNumberOfMemorySegments() {     return maxNumberOfMemorySegments. }
false;public;0;6;;@Override public int getNumberOfAvailableMemorySegments() {     synchronized (availableMemorySegments) {         return availableMemorySegments.size().     } }
false;public;0;6;;@Override public int getNumBuffers() {     synchronized (availableMemorySegments) {         return currentPoolSize.     } }
false;public;0;4;;@Override public int bestEffortGetNumOfUsedBuffers() {     return Math.max(0, numberOfRequestedMemorySegments - availableMemorySegments.size()). }
false;public;0;9;;@Override public Buffer requestBuffer() throws IOException {     try {         return toBuffer(requestMemorySegment(false)).     } catch (InterruptedException e) {         throw new IOException(e).     } }
false;public;0;4;;@Override public Buffer requestBufferBlocking() throws IOException, InterruptedException {     return toBuffer(requestMemorySegment(true)). }
false;public;0;4;;@Override public BufferBuilder requestBufferBuilderBlocking() throws IOException, InterruptedException {     return toBufferBuilder(requestMemorySegment(true)). }
false;private;1;6;;private Buffer toBuffer(MemorySegment memorySegment) {     if (memorySegment == null) {         return null.     }     return new NetworkBuffer(memorySegment, this). }
false;private;1;6;;private BufferBuilder toBufferBuilder(MemorySegment memorySegment) {     if (memorySegment == null) {         return null.     }     return new BufferBuilder(memorySegment, this). }
false;private;1;36;;private MemorySegment requestMemorySegment(boolean isBlocking) throws InterruptedException, IOException {     synchronized (availableMemorySegments) {         returnExcessMemorySegments().         boolean askToRecycle = owner.isPresent().         // fill availableMemorySegments with at least one element, wait if required         while (availableMemorySegments.isEmpty()) {             if (isDestroyed) {                 throw new IllegalStateException("Buffer pool is destroyed.").             }             if (numberOfRequestedMemorySegments < currentPoolSize) {                 final MemorySegment segment = networkBufferPool.requestMemorySegment().                 if (segment != null) {                     numberOfRequestedMemorySegments++.                     return segment.                 }             }             if (askToRecycle) {                 owner.get().releaseMemory(1).             }             if (isBlocking) {                 availableMemorySegments.wait(2000).             } else {                 return null.             }         }         return availableMemorySegments.poll().     } }
false;public;1;21;;@Override public void recycle(MemorySegment segment) {     BufferListener listener.     NotificationResult notificationResult = NotificationResult.BUFFER_NOT_USED.     while (!notificationResult.isBufferUsed()) {         synchronized (availableMemorySegments) {             if (isDestroyed || numberOfRequestedMemorySegments > currentPoolSize) {                 returnMemorySegment(segment).                 return.             } else {                 listener = registeredListeners.poll().                 if (listener == null) {                     availableMemorySegments.add(segment).                     availableMemorySegments.notify().                     return.                 }             }         }         notificationResult = fireBufferAvailableNotification(listener, segment).     } }
false;private;2;17;;private NotificationResult fireBufferAvailableNotification(BufferListener listener, MemorySegment segment) {     // We do not know which locks have been acquired before the recycle() or are needed in the     // notification and which other threads also access them.     // -> call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock (FLINK-9676)     NotificationResult notificationResult = listener.notifyBufferAvailable(new NetworkBuffer(segment, this)).     if (notificationResult.needsMoreBuffers()) {         synchronized (availableMemorySegments) {             if (isDestroyed) {                 // cleanup tasks how they would have been done if we only had one synchronized block                 listener.notifyBufferDestroyed().             } else {                 registeredListeners.add(listener).             }         }     }     return notificationResult. }
true;public;0;25;/**  * Destroy is called after the produce or consume phase of a task finishes.  */ ;/**  * Destroy is called after the produce or consume phase of a task finishes.  */ @Override public void lazyDestroy() {     // NOTE: if you change this logic, be sure to update recycle() as well!     synchronized (availableMemorySegments) {         if (!isDestroyed) {             MemorySegment segment.             while ((segment = availableMemorySegments.poll()) != null) {                 returnMemorySegment(segment).             }             BufferListener listener.             while ((listener = registeredListeners.poll()) != null) {                 listener.notifyBufferDestroyed().             }             isDestroyed = true.         }     }     try {         networkBufferPool.destroyBufferPool(this).     } catch (IOException e) {         ExceptionUtils.rethrow(e).     } }
false;public;1;11;;@Override public boolean addBufferListener(BufferListener listener) {     synchronized (availableMemorySegments) {         if (!availableMemorySegments.isEmpty() || isDestroyed) {             return false.         }         registeredListeners.add(listener).         return true.     } }
false;public;1;25;;@Override public void setNumBuffers(int numBuffers) throws IOException {     int numExcessBuffers.     synchronized (availableMemorySegments) {         checkArgument(numBuffers >= numberOfRequiredMemorySegments, "Buffer pool needs at least %s buffers, but tried to set to %s", numberOfRequiredMemorySegments, numBuffers).         if (numBuffers > maxNumberOfMemorySegments) {             currentPoolSize = maxNumberOfMemorySegments.         } else {             currentPoolSize = numBuffers.         }         returnExcessMemorySegments().         numExcessBuffers = numberOfRequestedMemorySegments - currentPoolSize.     }     // size, trigger a recycle via the owner.     if (owner.isPresent() && numExcessBuffers > 0) {         owner.get().releaseMemory(numExcessBuffers).     } }
false;public;0;9;;@Override public String toString() {     synchronized (availableMemorySegments) {         return String.format("[size: %d, required: %d, requested: %d, available: %d, max: %d, listeners: %d, destroyed: %s]", currentPoolSize, numberOfRequiredMemorySegments, numberOfRequestedMemorySegments, availableMemorySegments.size(), maxNumberOfMemorySegments, registeredListeners.size(), isDestroyed).     } }
false;private;1;6;;// ------------------------------------------------------------------------ private void returnMemorySegment(MemorySegment segment) {     assert Thread.holdsLock(availableMemorySegments).     numberOfRequestedMemorySegments--.     networkBufferPool.recycle(segment). }
false;private;0;12;;private void returnExcessMemorySegments() {     assert Thread.holdsLock(availableMemorySegments).     while (numberOfRequestedMemorySegments > currentPoolSize) {         MemorySegment segment = availableMemorySegments.poll().         if (segment == null) {             return.         }         returnMemorySegment(segment).     } }
