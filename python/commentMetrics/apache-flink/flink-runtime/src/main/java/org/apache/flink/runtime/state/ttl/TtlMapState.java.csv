commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public UV get(UK key) throws Exception {     TtlValue<UV> ttlValue = getWrapped(key).     return ttlValue == null ? null : ttlValue.getUserValue(). }
false;private;1;5;;private TtlValue<UV> getWrapped(UK key) throws Exception {     accessCallback.run().     return getWrappedWithTtlCheckAndUpdate(() -> original.get(key), v -> original.put(key, v), () -> original.remove(key)). }
false;public;2;5;;@Override public void put(UK key, UV value) throws Exception {     accessCallback.run().     original.put(key, wrapWithTs(value)). }
false;public;1;14;;@Override public void putAll(Map<UK, UV> map) throws Exception {     accessCallback.run().     if (map == null) {         return.     }     Map<UK, TtlValue<UV>> ttlMap = new HashMap<>(map.size()).     long currentTimestamp = timeProvider.currentTimestamp().     for (Map.Entry<UK, UV> entry : map.entrySet()) {         UK key = entry.getKey().         ttlMap.put(key, TtlUtils.wrapWithTs(entry.getValue(), currentTimestamp)).     }     original.putAll(ttlMap). }
false;public;1;5;;@Override public void remove(UK key) throws Exception {     accessCallback.run().     original.remove(key). }
false;public;1;5;;@Override public boolean contains(UK key) throws Exception {     TtlValue<UV> ttlValue = getWrapped(key).     return ttlValue != null. }
false;public;0;4;;@Override public Iterable<Map.Entry<UK, UV>> entries() throws Exception {     return entries(e -> e). }
false;private;1;6;;private <R> Iterable<R> entries(Function<Map.Entry<UK, UV>, R> resultMapper) throws Exception {     accessCallback.run().     Iterable<Map.Entry<UK, TtlValue<UV>>> withTs = original.entries().     return () -> new EntriesIterator<>(withTs == null ? Collections.emptyList() : withTs, resultMapper). }
false;public;0;4;;@Override public Iterable<UK> keys() throws Exception {     return entries(Map.Entry::getKey). }
false;public;0;4;;@Override public Iterable<UV> values() throws Exception {     return entries(Map.Entry::getValue). }
false;public;0;4;;@Override public Iterator<Map.Entry<UK, UV>> iterator() throws Exception {     return entries().iterator(). }
false;public;1;14;;@Nullable @Override public Map<UK, TtlValue<UV>> getUnexpiredOrNull(@Nonnull Map<UK, TtlValue<UV>> ttlValue) {     Map<UK, TtlValue<UV>> unexpired = new HashMap<>().     TypeSerializer<TtlValue<UV>> valueSerializer = ((MapSerializer<UK, TtlValue<UV>>) original.getValueSerializer()).getValueSerializer().     for (Map.Entry<UK, TtlValue<UV>> e : ttlValue.entrySet()) {         if (!expired(e.getValue())) {             // we have to do the defensive copy to update the value             unexpired.put(e.getKey(), valueSerializer.copy(e.getValue())).         }     }     return ttlValue.size() == unexpired.size() ? ttlValue : unexpired. }
false;public;0;4;;@Override public void clear() {     original.clear(). }
false;public;0;8;;@Override public boolean hasNext() {     rightAfterNextIsCalled = false.     while (nextUnexpired == null && originalIterator.hasNext()) {         nextUnexpired = getUnexpiredAndUpdateOrCleanup(originalIterator.next()).     }     return nextUnexpired != null. }
false;public;0;10;;@Override public R next() {     if (hasNext()) {         rightAfterNextIsCalled = true.         R result = resultMapper.apply(nextUnexpired).         nextUnexpired = null.         return result.     }     throw new NoSuchElementException(). }
false;public;0;9;;@Override public void remove() {     if (rightAfterNextIsCalled) {         originalIterator.remove().     } else {         throw new IllegalStateException("next() has not been called or hasNext() has been called afterwards," + " remove() is supported only right after calling next()").     } }
false;private;1;12;;private Map.Entry<UK, UV> getUnexpiredAndUpdateOrCleanup(Map.Entry<UK, TtlValue<UV>> e) {     TtlValue<UV> unexpiredValue.     try {         unexpiredValue = getWrappedWithTtlCheckAndUpdate(e::getValue, v -> original.put(e.getKey(), v), originalIterator::remove).     } catch (Exception ex) {         throw new FlinkRuntimeException(ex).     }     return unexpiredValue == null ? null : new AbstractMap.SimpleEntry<>(e.getKey(), unexpiredValue.getUserValue()). }
