# id;timestamp;commentText;codeText;commentWords;codeWords
ExecutionGraphCache -> public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway);1506967078;Gets the {@link AccessExecutionGraph} for the given {@link JobID} and caches it. The_{@link AccessExecutionGraph} will be requested again after the refresh interval has passed_or if the graph could not be retrieved from the given gateway.__@param jobId identifying the {@link AccessExecutionGraph} to get_@param restfulGateway to request the {@link AccessExecutionGraph} from_@return Future containing the requested {@link AccessExecutionGraph};public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway) {__		Preconditions.checkState(running, "ExecutionGraphCache is no longer running")___		while (true) {_			final ExecutionGraphEntry oldEntry = cachedExecutionGraphs.get(jobId)___			final long currentTime = System.currentTimeMillis()___			if (oldEntry != null) {_				if (currentTime < oldEntry.getTTL()) {_					if (oldEntry.getExecutionGraphFuture().isDone() && !oldEntry.getExecutionGraphFuture().isCompletedExceptionally()) {__						_						try {_							if (oldEntry.getExecutionGraphFuture().get().getState() != JobStatus.SUSPENDED) {_								return oldEntry.getExecutionGraphFuture()__							}_							_						} catch (InterruptedException | ExecutionException e) {_							throw new RuntimeException("Could not retrieve ExecutionGraph from the orderly completed future. This should never happen.", e)__						}_					} else if (!oldEntry.getExecutionGraphFuture().isDone()) {_						return oldEntry.getExecutionGraphFuture()__					}_					_				}_			}__			final ExecutionGraphEntry newEntry = new ExecutionGraphEntry(currentTime + timeToLive.toMilliseconds())___			final boolean successfulUpdate___			if (oldEntry == null) {_				successfulUpdate = cachedExecutionGraphs.putIfAbsent(jobId, newEntry) == null__			} else {_				successfulUpdate = cachedExecutionGraphs.replace(jobId, oldEntry, newEntry)__				_				oldEntry.getExecutionGraphFuture().cancel(false)__			}__			if (successfulUpdate) {_				final CompletableFuture<AccessExecutionGraph> executionGraphFuture = restfulGateway.requestJob(jobId, timeout)___				executionGraphFuture.whenComplete(_					(AccessExecutionGraph executionGraph, Throwable throwable) -> {_						if (throwable != null) {_							newEntry.getExecutionGraphFuture().completeExceptionally(throwable)___							_							cachedExecutionGraphs.remove(jobId, newEntry)__						} else {_							newEntry.getExecutionGraphFuture().complete(executionGraph)___							_							if (executionGraph.getState() == JobStatus.SUSPENDED) {_								_								cachedExecutionGraphs.remove(jobId, newEntry)__							}_						}_					})___				if (!running) {_					_					cachedExecutionGraphs.remove(jobId, newEntry)__				}__				return newEntry.getExecutionGraphFuture()__			}_		}_	};gets,the,link,access,execution,graph,for,the,given,link,job,id,and,caches,it,the,link,access,execution,graph,will,be,requested,again,after,the,refresh,interval,has,passed,or,if,the,graph,could,not,be,retrieved,from,the,given,gateway,param,job,id,identifying,the,link,access,execution,graph,to,get,param,restful,gateway,to,request,the,link,access,execution,graph,from,return,future,containing,the,requested,link,access,execution,graph;public,completable,future,access,execution,graph,get,execution,graph,job,id,job,id,restful,gateway,restful,gateway,preconditions,check,state,running,execution,graph,cache,is,no,longer,running,while,true,final,execution,graph,entry,old,entry,cached,execution,graphs,get,job,id,final,long,current,time,system,current,time,millis,if,old,entry,null,if,current,time,old,entry,get,ttl,if,old,entry,get,execution,graph,future,is,done,old,entry,get,execution,graph,future,is,completed,exceptionally,try,if,old,entry,get,execution,graph,future,get,get,state,job,status,suspended,return,old,entry,get,execution,graph,future,catch,interrupted,exception,execution,exception,e,throw,new,runtime,exception,could,not,retrieve,execution,graph,from,the,orderly,completed,future,this,should,never,happen,e,else,if,old,entry,get,execution,graph,future,is,done,return,old,entry,get,execution,graph,future,final,execution,graph,entry,new,entry,new,execution,graph,entry,current,time,time,to,live,to,milliseconds,final,boolean,successful,update,if,old,entry,null,successful,update,cached,execution,graphs,put,if,absent,job,id,new,entry,null,else,successful,update,cached,execution,graphs,replace,job,id,old,entry,new,entry,old,entry,get,execution,graph,future,cancel,false,if,successful,update,final,completable,future,access,execution,graph,execution,graph,future,restful,gateway,request,job,job,id,timeout,execution,graph,future,when,complete,access,execution,graph,execution,graph,throwable,throwable,if,throwable,null,new,entry,get,execution,graph,future,complete,exceptionally,throwable,cached,execution,graphs,remove,job,id,new,entry,else,new,entry,get,execution,graph,future,complete,execution,graph,if,execution,graph,get,state,job,status,suspended,cached,execution,graphs,remove,job,id,new,entry,if,running,cached,execution,graphs,remove,job,id,new,entry,return,new,entry,get,execution,graph,future
ExecutionGraphCache -> public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway);1516970998;Gets the {@link AccessExecutionGraph} for the given {@link JobID} and caches it. The_{@link AccessExecutionGraph} will be requested again after the refresh interval has passed_or if the graph could not be retrieved from the given gateway.__@param jobId identifying the {@link AccessExecutionGraph} to get_@param restfulGateway to request the {@link AccessExecutionGraph} from_@return Future containing the requested {@link AccessExecutionGraph};public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway) {__		Preconditions.checkState(running, "ExecutionGraphCache is no longer running")___		while (true) {_			final ExecutionGraphEntry oldEntry = cachedExecutionGraphs.get(jobId)___			final long currentTime = System.currentTimeMillis()___			if (oldEntry != null) {_				if (currentTime < oldEntry.getTTL()) {_					if (oldEntry.getExecutionGraphFuture().isDone() && !oldEntry.getExecutionGraphFuture().isCompletedExceptionally()) {__						_						try {_							if (oldEntry.getExecutionGraphFuture().get().getState() != JobStatus.SUSPENDED) {_								return oldEntry.getExecutionGraphFuture()__							}_							_						} catch (InterruptedException | ExecutionException e) {_							throw new RuntimeException("Could not retrieve ExecutionGraph from the orderly completed future. This should never happen.", e)__						}_					} else if (!oldEntry.getExecutionGraphFuture().isDone()) {_						return oldEntry.getExecutionGraphFuture()__					}_					_				}_			}__			final ExecutionGraphEntry newEntry = new ExecutionGraphEntry(currentTime + timeToLive.toMilliseconds())___			final boolean successfulUpdate___			if (oldEntry == null) {_				successfulUpdate = cachedExecutionGraphs.putIfAbsent(jobId, newEntry) == null__			} else {_				successfulUpdate = cachedExecutionGraphs.replace(jobId, oldEntry, newEntry)__				_				oldEntry.getExecutionGraphFuture().cancel(false)__			}__			if (successfulUpdate) {_				final CompletableFuture<? extends AccessExecutionGraph> executionGraphFuture = restfulGateway.requestJob(jobId, timeout)___				executionGraphFuture.whenComplete(_					(AccessExecutionGraph executionGraph, Throwable throwable) -> {_						if (throwable != null) {_							newEntry.getExecutionGraphFuture().completeExceptionally(throwable)___							_							cachedExecutionGraphs.remove(jobId, newEntry)__						} else {_							newEntry.getExecutionGraphFuture().complete(executionGraph)___							_							if (executionGraph.getState() == JobStatus.SUSPENDED) {_								_								cachedExecutionGraphs.remove(jobId, newEntry)__							}_						}_					})___				if (!running) {_					_					cachedExecutionGraphs.remove(jobId, newEntry)__				}__				return newEntry.getExecutionGraphFuture()__			}_		}_	};gets,the,link,access,execution,graph,for,the,given,link,job,id,and,caches,it,the,link,access,execution,graph,will,be,requested,again,after,the,refresh,interval,has,passed,or,if,the,graph,could,not,be,retrieved,from,the,given,gateway,param,job,id,identifying,the,link,access,execution,graph,to,get,param,restful,gateway,to,request,the,link,access,execution,graph,from,return,future,containing,the,requested,link,access,execution,graph;public,completable,future,access,execution,graph,get,execution,graph,job,id,job,id,restful,gateway,restful,gateway,preconditions,check,state,running,execution,graph,cache,is,no,longer,running,while,true,final,execution,graph,entry,old,entry,cached,execution,graphs,get,job,id,final,long,current,time,system,current,time,millis,if,old,entry,null,if,current,time,old,entry,get,ttl,if,old,entry,get,execution,graph,future,is,done,old,entry,get,execution,graph,future,is,completed,exceptionally,try,if,old,entry,get,execution,graph,future,get,get,state,job,status,suspended,return,old,entry,get,execution,graph,future,catch,interrupted,exception,execution,exception,e,throw,new,runtime,exception,could,not,retrieve,execution,graph,from,the,orderly,completed,future,this,should,never,happen,e,else,if,old,entry,get,execution,graph,future,is,done,return,old,entry,get,execution,graph,future,final,execution,graph,entry,new,entry,new,execution,graph,entry,current,time,time,to,live,to,milliseconds,final,boolean,successful,update,if,old,entry,null,successful,update,cached,execution,graphs,put,if,absent,job,id,new,entry,null,else,successful,update,cached,execution,graphs,replace,job,id,old,entry,new,entry,old,entry,get,execution,graph,future,cancel,false,if,successful,update,final,completable,future,extends,access,execution,graph,execution,graph,future,restful,gateway,request,job,job,id,timeout,execution,graph,future,when,complete,access,execution,graph,execution,graph,throwable,throwable,if,throwable,null,new,entry,get,execution,graph,future,complete,exceptionally,throwable,cached,execution,graphs,remove,job,id,new,entry,else,new,entry,get,execution,graph,future,complete,execution,graph,if,execution,graph,get,state,job,status,suspended,cached,execution,graphs,remove,job,id,new,entry,if,running,cached,execution,graphs,remove,job,id,new,entry,return,new,entry,get,execution,graph,future
ExecutionGraphCache -> public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway);1519317157;Gets the {@link AccessExecutionGraph} for the given {@link JobID} and caches it. The_{@link AccessExecutionGraph} will be requested again after the refresh interval has passed_or if the graph could not be retrieved from the given gateway.__@param jobId identifying the {@link AccessExecutionGraph} to get_@param restfulGateway to request the {@link AccessExecutionGraph} from_@return Future containing the requested {@link AccessExecutionGraph};public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway) {__		Preconditions.checkState(running, "ExecutionGraphCache is no longer running")___		while (true) {_			final ExecutionGraphEntry oldEntry = cachedExecutionGraphs.get(jobId)___			final long currentTime = System.currentTimeMillis()___			if (oldEntry != null) {_				if (currentTime < oldEntry.getTTL()) {_					final CompletableFuture<AccessExecutionGraph> executionGraphFuture = oldEntry.getExecutionGraphFuture()__					if (executionGraphFuture.isDone() && !executionGraphFuture.isCompletedExceptionally()) {__						_						try {_							final AccessExecutionGraph executionGraph = executionGraphFuture.get()__							if (executionGraph.getState() != JobStatus.SUSPENDING &&_								executionGraph.getState() != JobStatus.SUSPENDED) {_								return executionGraphFuture__							}_							_						} catch (InterruptedException | ExecutionException e) {_							throw new RuntimeException("Could not retrieve ExecutionGraph from the orderly completed future. This should never happen.", e)__						}_					} else if (!executionGraphFuture.isDone()) {_						return executionGraphFuture__					}_					_				}_			}__			final ExecutionGraphEntry newEntry = new ExecutionGraphEntry(currentTime + timeToLive.toMilliseconds())___			final boolean successfulUpdate___			if (oldEntry == null) {_				successfulUpdate = cachedExecutionGraphs.putIfAbsent(jobId, newEntry) == null__			} else {_				successfulUpdate = cachedExecutionGraphs.replace(jobId, oldEntry, newEntry)__				_				oldEntry.getExecutionGraphFuture().cancel(false)__			}__			if (successfulUpdate) {_				final CompletableFuture<? extends AccessExecutionGraph> executionGraphFuture = restfulGateway.requestJob(jobId, timeout)___				executionGraphFuture.whenComplete(_					(AccessExecutionGraph executionGraph, Throwable throwable) -> {_						if (throwable != null) {_							newEntry.getExecutionGraphFuture().completeExceptionally(throwable)___							_							cachedExecutionGraphs.remove(jobId, newEntry)__						} else {_							newEntry.getExecutionGraphFuture().complete(executionGraph)___							_							if (executionGraph.getState() == JobStatus.SUSPENDING ||_								executionGraph.getState() == JobStatus.SUSPENDED) {_								_								cachedExecutionGraphs.remove(jobId, newEntry)__							}_						}_					})___				if (!running) {_					_					cachedExecutionGraphs.remove(jobId, newEntry)__				}__				return newEntry.getExecutionGraphFuture()__			}_		}_	};gets,the,link,access,execution,graph,for,the,given,link,job,id,and,caches,it,the,link,access,execution,graph,will,be,requested,again,after,the,refresh,interval,has,passed,or,if,the,graph,could,not,be,retrieved,from,the,given,gateway,param,job,id,identifying,the,link,access,execution,graph,to,get,param,restful,gateway,to,request,the,link,access,execution,graph,from,return,future,containing,the,requested,link,access,execution,graph;public,completable,future,access,execution,graph,get,execution,graph,job,id,job,id,restful,gateway,restful,gateway,preconditions,check,state,running,execution,graph,cache,is,no,longer,running,while,true,final,execution,graph,entry,old,entry,cached,execution,graphs,get,job,id,final,long,current,time,system,current,time,millis,if,old,entry,null,if,current,time,old,entry,get,ttl,final,completable,future,access,execution,graph,execution,graph,future,old,entry,get,execution,graph,future,if,execution,graph,future,is,done,execution,graph,future,is,completed,exceptionally,try,final,access,execution,graph,execution,graph,execution,graph,future,get,if,execution,graph,get,state,job,status,suspending,execution,graph,get,state,job,status,suspended,return,execution,graph,future,catch,interrupted,exception,execution,exception,e,throw,new,runtime,exception,could,not,retrieve,execution,graph,from,the,orderly,completed,future,this,should,never,happen,e,else,if,execution,graph,future,is,done,return,execution,graph,future,final,execution,graph,entry,new,entry,new,execution,graph,entry,current,time,time,to,live,to,milliseconds,final,boolean,successful,update,if,old,entry,null,successful,update,cached,execution,graphs,put,if,absent,job,id,new,entry,null,else,successful,update,cached,execution,graphs,replace,job,id,old,entry,new,entry,old,entry,get,execution,graph,future,cancel,false,if,successful,update,final,completable,future,extends,access,execution,graph,execution,graph,future,restful,gateway,request,job,job,id,timeout,execution,graph,future,when,complete,access,execution,graph,execution,graph,throwable,throwable,if,throwable,null,new,entry,get,execution,graph,future,complete,exceptionally,throwable,cached,execution,graphs,remove,job,id,new,entry,else,new,entry,get,execution,graph,future,complete,execution,graph,if,execution,graph,get,state,job,status,suspending,execution,graph,get,state,job,status,suspended,cached,execution,graphs,remove,job,id,new,entry,if,running,cached,execution,graphs,remove,job,id,new,entry,return,new,entry,get,execution,graph,future
ExecutionGraphCache -> public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway);1550683188;Gets the {@link AccessExecutionGraph} for the given {@link JobID} and caches it. The_{@link AccessExecutionGraph} will be requested again after the refresh interval has passed_or if the graph could not be retrieved from the given gateway.__@param jobId identifying the {@link AccessExecutionGraph} to get_@param restfulGateway to request the {@link AccessExecutionGraph} from_@return Future containing the requested {@link AccessExecutionGraph};public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway) {__		Preconditions.checkState(running, "ExecutionGraphCache is no longer running")___		while (true) {_			final ExecutionGraphEntry oldEntry = cachedExecutionGraphs.get(jobId)___			final long currentTime = System.currentTimeMillis()___			if (oldEntry != null) {_				if (currentTime < oldEntry.getTTL()) {_					final CompletableFuture<AccessExecutionGraph> executionGraphFuture = oldEntry.getExecutionGraphFuture()__					if (executionGraphFuture.isDone() && !executionGraphFuture.isCompletedExceptionally()) {__						_						try {_							final AccessExecutionGraph executionGraph = executionGraphFuture.get()__							if (executionGraph.getState() != JobStatus.SUSPENDED) {_								return executionGraphFuture__							}_							_						} catch (InterruptedException | ExecutionException e) {_							throw new RuntimeException("Could not retrieve ExecutionGraph from the orderly completed future. This should never happen.", e)__						}_					} else if (!executionGraphFuture.isDone()) {_						return executionGraphFuture__					}_					_				}_			}__			final ExecutionGraphEntry newEntry = new ExecutionGraphEntry(currentTime + timeToLive.toMilliseconds())___			final boolean successfulUpdate___			if (oldEntry == null) {_				successfulUpdate = cachedExecutionGraphs.putIfAbsent(jobId, newEntry) == null__			} else {_				successfulUpdate = cachedExecutionGraphs.replace(jobId, oldEntry, newEntry)__				_				oldEntry.getExecutionGraphFuture().cancel(false)__			}__			if (successfulUpdate) {_				final CompletableFuture<? extends AccessExecutionGraph> executionGraphFuture = restfulGateway.requestJob(jobId, timeout)___				executionGraphFuture.whenComplete(_					(AccessExecutionGraph executionGraph, Throwable throwable) -> {_						if (throwable != null) {_							newEntry.getExecutionGraphFuture().completeExceptionally(throwable)___							_							cachedExecutionGraphs.remove(jobId, newEntry)__						} else {_							newEntry.getExecutionGraphFuture().complete(executionGraph)___							_							if (executionGraph.getState() == JobStatus.SUSPENDED) {_								_								cachedExecutionGraphs.remove(jobId, newEntry)__							}_						}_					})___				if (!running) {_					_					cachedExecutionGraphs.remove(jobId, newEntry)__				}__				return newEntry.getExecutionGraphFuture()__			}_		}_	};gets,the,link,access,execution,graph,for,the,given,link,job,id,and,caches,it,the,link,access,execution,graph,will,be,requested,again,after,the,refresh,interval,has,passed,or,if,the,graph,could,not,be,retrieved,from,the,given,gateway,param,job,id,identifying,the,link,access,execution,graph,to,get,param,restful,gateway,to,request,the,link,access,execution,graph,from,return,future,containing,the,requested,link,access,execution,graph;public,completable,future,access,execution,graph,get,execution,graph,job,id,job,id,restful,gateway,restful,gateway,preconditions,check,state,running,execution,graph,cache,is,no,longer,running,while,true,final,execution,graph,entry,old,entry,cached,execution,graphs,get,job,id,final,long,current,time,system,current,time,millis,if,old,entry,null,if,current,time,old,entry,get,ttl,final,completable,future,access,execution,graph,execution,graph,future,old,entry,get,execution,graph,future,if,execution,graph,future,is,done,execution,graph,future,is,completed,exceptionally,try,final,access,execution,graph,execution,graph,execution,graph,future,get,if,execution,graph,get,state,job,status,suspended,return,execution,graph,future,catch,interrupted,exception,execution,exception,e,throw,new,runtime,exception,could,not,retrieve,execution,graph,from,the,orderly,completed,future,this,should,never,happen,e,else,if,execution,graph,future,is,done,return,execution,graph,future,final,execution,graph,entry,new,entry,new,execution,graph,entry,current,time,time,to,live,to,milliseconds,final,boolean,successful,update,if,old,entry,null,successful,update,cached,execution,graphs,put,if,absent,job,id,new,entry,null,else,successful,update,cached,execution,graphs,replace,job,id,old,entry,new,entry,old,entry,get,execution,graph,future,cancel,false,if,successful,update,final,completable,future,extends,access,execution,graph,execution,graph,future,restful,gateway,request,job,job,id,timeout,execution,graph,future,when,complete,access,execution,graph,execution,graph,throwable,throwable,if,throwable,null,new,entry,get,execution,graph,future,complete,exceptionally,throwable,cached,execution,graphs,remove,job,id,new,entry,else,new,entry,get,execution,graph,future,complete,execution,graph,if,execution,graph,get,state,job,status,suspended,cached,execution,graphs,remove,job,id,new,entry,if,running,cached,execution,graphs,remove,job,id,new,entry,return,new,entry,get,execution,graph,future
ExecutionGraphCache -> public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway);1550683189;Gets the {@link AccessExecutionGraph} for the given {@link JobID} and caches it. The_{@link AccessExecutionGraph} will be requested again after the refresh interval has passed_or if the graph could not be retrieved from the given gateway.__@param jobId identifying the {@link ArchivedExecutionGraph} to get_@param restfulGateway to request the {@link ArchivedExecutionGraph} from_@return Future containing the requested {@link ArchivedExecutionGraph};public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway) {_		return getExecutionGraphInternal(jobId, restfulGateway).thenApply(Function.identity())__	};gets,the,link,access,execution,graph,for,the,given,link,job,id,and,caches,it,the,link,access,execution,graph,will,be,requested,again,after,the,refresh,interval,has,passed,or,if,the,graph,could,not,be,retrieved,from,the,given,gateway,param,job,id,identifying,the,link,archived,execution,graph,to,get,param,restful,gateway,to,request,the,link,archived,execution,graph,from,return,future,containing,the,requested,link,archived,execution,graph;public,completable,future,access,execution,graph,get,execution,graph,job,id,job,id,restful,gateway,restful,gateway,return,get,execution,graph,internal,job,id,restful,gateway,then,apply,function,identity
ExecutionGraphCache -> public void cleanup();1506967078;Perform the cleanup of out dated {@link ExecutionGraphEntry}.;public void cleanup() {_		long currentTime = System.currentTimeMillis()___		_		cachedExecutionGraphs.values().removeIf(_			(ExecutionGraphEntry entry) -> currentTime >= entry.getTTL())__	};perform,the,cleanup,of,out,dated,link,execution,graph,entry;public,void,cleanup,long,current,time,system,current,time,millis,cached,execution,graphs,values,remove,if,execution,graph,entry,entry,current,time,entry,get,ttl
ExecutionGraphCache -> public void cleanup();1516970998;Perform the cleanup of out dated {@link ExecutionGraphEntry}.;public void cleanup() {_		long currentTime = System.currentTimeMillis()___		_		cachedExecutionGraphs.values().removeIf(_			(ExecutionGraphEntry entry) -> currentTime >= entry.getTTL())__	};perform,the,cleanup,of,out,dated,link,execution,graph,entry;public,void,cleanup,long,current,time,system,current,time,millis,cached,execution,graphs,values,remove,if,execution,graph,entry,entry,current,time,entry,get,ttl
ExecutionGraphCache -> public void cleanup();1519317157;Perform the cleanup of out dated {@link ExecutionGraphEntry}.;public void cleanup() {_		long currentTime = System.currentTimeMillis()___		_		cachedExecutionGraphs.values().removeIf(_			(ExecutionGraphEntry entry) -> currentTime >= entry.getTTL())__	};perform,the,cleanup,of,out,dated,link,execution,graph,entry;public,void,cleanup,long,current,time,system,current,time,millis,cached,execution,graphs,values,remove,if,execution,graph,entry,entry,current,time,entry,get,ttl
ExecutionGraphCache -> public void cleanup();1550683188;Perform the cleanup of out dated {@link ExecutionGraphEntry}.;public void cleanup() {_		long currentTime = System.currentTimeMillis()___		_		cachedExecutionGraphs.values().removeIf(_			(ExecutionGraphEntry entry) -> currentTime >= entry.getTTL())__	};perform,the,cleanup,of,out,dated,link,execution,graph,entry;public,void,cleanup,long,current,time,system,current,time,millis,cached,execution,graphs,values,remove,if,execution,graph,entry,entry,current,time,entry,get,ttl
ExecutionGraphCache -> public void cleanup();1550683189;Perform the cleanup of out dated {@link ExecutionGraphEntry}.;public void cleanup() {_		long currentTime = System.currentTimeMillis()___		_		cachedExecutionGraphs.values().removeIf(_			(ExecutionGraphEntry entry) -> currentTime >= entry.getTTL())__	};perform,the,cleanup,of,out,dated,link,execution,graph,entry;public,void,cleanup,long,current,time,system,current,time,millis,cached,execution,graphs,values,remove,if,execution,graph,entry,entry,current,time,entry,get,ttl
ExecutionGraphCache -> public int size();1506967078;Gets the number of cache entries.;public int size() {_		return cachedExecutionGraphs.size()__	};gets,the,number,of,cache,entries;public,int,size,return,cached,execution,graphs,size
ExecutionGraphCache -> public int size();1516970998;Gets the number of cache entries.;public int size() {_		return cachedExecutionGraphs.size()__	};gets,the,number,of,cache,entries;public,int,size,return,cached,execution,graphs,size
ExecutionGraphCache -> public int size();1519317157;Gets the number of cache entries.;public int size() {_		return cachedExecutionGraphs.size()__	};gets,the,number,of,cache,entries;public,int,size,return,cached,execution,graphs,size
ExecutionGraphCache -> public int size();1550683188;Gets the number of cache entries.;public int size() {_		return cachedExecutionGraphs.size()__	};gets,the,number,of,cache,entries;public,int,size,return,cached,execution,graphs,size
ExecutionGraphCache -> public int size();1550683189;Gets the number of cache entries.;public int size() {_		return cachedExecutionGraphs.size()__	};gets,the,number,of,cache,entries;public,int,size,return,cached,execution,graphs,size
