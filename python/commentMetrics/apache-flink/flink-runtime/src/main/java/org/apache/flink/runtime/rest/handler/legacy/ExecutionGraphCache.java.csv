commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public void close() {     running = false.     // clear all cached AccessExecutionGraphs     cachedExecutionGraphs.clear(). }
true;public;0;3;/**  * Gets the number of cache entries.  */ ;/**  * Gets the number of cache entries.  */ public int size() {     return cachedExecutionGraphs.size(). }
true;public;2;3;/**  * Gets the {@link AccessExecutionGraph} for the given {@link JobID} and caches it. The  * {@link AccessExecutionGraph} will be requested again after the refresh interval has passed  * or if the graph could not be retrieved from the given gateway.  *  * @param jobId identifying the {@link ArchivedExecutionGraph} to get  * @param restfulGateway to request the {@link ArchivedExecutionGraph} from  * @return Future containing the requested {@link ArchivedExecutionGraph}  */ ;/**  * Gets the {@link AccessExecutionGraph} for the given {@link JobID} and caches it. The  * {@link AccessExecutionGraph} will be requested again after the refresh interval has passed  * or if the graph could not be retrieved from the given gateway.  *  * @param jobId identifying the {@link ArchivedExecutionGraph} to get  * @param restfulGateway to request the {@link ArchivedExecutionGraph} from  * @return Future containing the requested {@link ArchivedExecutionGraph}  */ public CompletableFuture<AccessExecutionGraph> getExecutionGraph(JobID jobId, RestfulGateway restfulGateway) {     return getExecutionGraphInternal(jobId, restfulGateway).thenApply(Function.identity()). }
false;private;2;52;;private CompletableFuture<ArchivedExecutionGraph> getExecutionGraphInternal(JobID jobId, RestfulGateway restfulGateway) {     Preconditions.checkState(running, "ExecutionGraphCache is no longer running").     while (true) {         final ExecutionGraphEntry oldEntry = cachedExecutionGraphs.get(jobId).         final long currentTime = System.currentTimeMillis().         if (oldEntry != null && currentTime < oldEntry.getTTL()) {             final CompletableFuture<ArchivedExecutionGraph> executionGraphFuture = oldEntry.getExecutionGraphFuture().             if (!executionGraphFuture.isCompletedExceptionally()) {                 return executionGraphFuture.             }         // otherwise it must be completed exceptionally         }         final ExecutionGraphEntry newEntry = new ExecutionGraphEntry(currentTime + timeToLive.toMilliseconds()).         final boolean successfulUpdate.         if (oldEntry == null) {             successfulUpdate = cachedExecutionGraphs.putIfAbsent(jobId, newEntry) == null.         } else {             successfulUpdate = cachedExecutionGraphs.replace(jobId, oldEntry, newEntry).             // cancel potentially outstanding futures             oldEntry.getExecutionGraphFuture().cancel(false).         }         if (successfulUpdate) {             final CompletableFuture<ArchivedExecutionGraph> executionGraphFuture = restfulGateway.requestJob(jobId, timeout).             executionGraphFuture.whenComplete((ArchivedExecutionGraph executionGraph, Throwable throwable) -> {                 if (throwable != null) {                     newEntry.getExecutionGraphFuture().completeExceptionally(throwable).                     // remove exceptionally completed entry because it doesn't help                     cachedExecutionGraphs.remove(jobId, newEntry).                 } else {                     newEntry.getExecutionGraphFuture().complete(executionGraph).                 }             }).             if (!running) {                 // delete newly added entry in case of a concurrent stopping operation                 cachedExecutionGraphs.remove(jobId, newEntry).             }             return newEntry.getExecutionGraphFuture().         }     } }
true;public;0;7;/**  * Perform the cleanup of out dated {@link ExecutionGraphEntry}.  */ ;/**  * Perform the cleanup of out dated {@link ExecutionGraphEntry}.  */ public void cleanup() {     long currentTime = System.currentTimeMillis().     // remove entries which have exceeded their time to live     cachedExecutionGraphs.values().removeIf((ExecutionGraphEntry entry) -> currentTime >= entry.getTTL()). }
false;public;0;3;;public long getTTL() {     return ttl. }
false;public;0;3;;public CompletableFuture<ArchivedExecutionGraph> getExecutionGraphFuture() {     return executionGraphFuture. }
