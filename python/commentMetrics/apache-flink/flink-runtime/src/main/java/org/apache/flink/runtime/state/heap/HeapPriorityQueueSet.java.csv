commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override @Nullable public T poll() {     final T toRemove = super.poll().     return toRemove != null ? getDedupMapForElement(toRemove).remove(toRemove) : null. }
true;public;1;4;/**  * Adds the element to the queue. In contrast to the superclass and to maintain set semantics, this happens only if  * no such element is already contained (determined by {@link #equals(Object)}).  *  * @return <code>true</code> if the operation changed the head element or if is it unclear if the head element changed.  * Only returns <code>false</code> iff the head element was not changed by this operation.  */ ;/**  * Adds the element to the queue. In contrast to the superclass and to maintain set semantics, this happens only if  * no such element is already contained (determined by {@link #equals(Object)}).  *  * @return <code>true</code> if the operation changed the head element or if is it unclear if the head element changed.  * Only returns <code>false</code> iff the head element was not changed by this operation.  */ @Override public boolean add(@Nonnull T element) {     return getDedupMapForElement(element).putIfAbsent(element, element) == null && super.add(element). }
true;public;1;5;/**  * In contrast to the superclass and to maintain set semantics, removal here is based on comparing the given element  * via {@link #equals(Object)}.  *  * @return <code>true</code> if the operation changed the head element or if is it unclear if the head element changed.  * Only returns <code>false</code> iff the head element was not changed by this operation.  */ ;/**  * In contrast to the superclass and to maintain set semantics, removal here is based on comparing the given element  * via {@link #equals(Object)}.  *  * @return <code>true</code> if the operation changed the head element or if is it unclear if the head element changed.  * Only returns <code>false</code> iff the head element was not changed by this operation.  */ @Override public boolean remove(@Nonnull T toRemove) {     T storedElement = getDedupMapForElement(toRemove).remove(toRemove).     return storedElement != null && super.remove(storedElement). }
false;public;0;7;;@Override public void clear() {     super.clear().     for (HashMap<?, ?> elementHashMap : deduplicationMapsByKeyGroup) {         elementHashMap.clear().     } }
false;private;1;4;;private HashMap<T, T> getDedupMapForKeyGroup(@Nonnegative int keyGroupId) {     return deduplicationMapsByKeyGroup[globalKeyGroupToLocalIndex(keyGroupId)]. }
false;private;1;6;;private HashMap<T, T> getDedupMapForElement(T element) {     int keyGroup = KeyGroupRangeAssignment.assignToKeyGroup(keyExtractor.extractKeyFromElement(element), totalNumberOfKeyGroups).     return getDedupMapForKeyGroup(keyGroup). }
false;private;1;4;;private int globalKeyGroupToLocalIndex(int keyGroup) {     checkArgument(keyGroupRange.contains(keyGroup)).     return keyGroup - keyGroupRange.getStartKeyGroup(). }
false;public;1;5;;@Nonnull @Override public Set<T> getSubsetForKeyGroup(int keyGroupId) {     return getDedupMapForKeyGroup(keyGroupId).keySet(). }
