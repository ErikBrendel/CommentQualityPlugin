commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;public Map<String, String> getAllVariables() {     if (variables == null) {         Map<String, String> tmpVariables = new HashMap<>().         putVariables(tmpVariables).         if (parent != null) {             // not true for Job-/TaskManagerMetricGroup             tmpVariables.putAll(parent.getAllVariables()).         }         variables = tmpVariables.     }     return variables. }
true;protected;1;2;/**  * Enters all variables specific to this {@link AbstractMetricGroup} and their associated values into the map.  *  * @param variables map to enter variables and their values into  */ ;/**  * Enters all variables specific to this {@link AbstractMetricGroup} and their associated values into the map.  *  * @param variables map to enter variables and their values into  */ protected void putVariables(Map<String, String> variables) { }
true;public;1;3;/**  * Returns the logical scope of this group, for example  * {@code "taskmanager.job.task"}.  *  * @param filter character filter which is applied to the scope components  * @return logical scope  */ ;/**  * Returns the logical scope of this group, for example  * {@code "taskmanager.job.task"}.  *  * @param filter character filter which is applied to the scope components  * @return logical scope  */ public String getLogicalScope(CharacterFilter filter) {     return getLogicalScope(filter, registry.getDelimiter()). }
true;public;2;3;/**  * Returns the logical scope of this group, for example  * {@code "taskmanager.job.task"}.  *  * @param filter character filter which is applied to the scope components  * @return logical scope  */ ;/**  * Returns the logical scope of this group, for example  * {@code "taskmanager.job.task"}.  *  * @param filter character filter which is applied to the scope components  * @return logical scope  */ public String getLogicalScope(CharacterFilter filter, char delimiter) {     return getLogicalScope(filter, delimiter, -1). }
true;;3;10;/**  * Returns the logical scope of this group, for example  * {@code "taskmanager.job.task"}.  *  * @param filter character filter which is applied to the scope components  * @param delimiter delimiter to use for concatenating scope components  * @param reporterIndex index of the reporter  * @return logical scope  */ ;/**  * Returns the logical scope of this group, for example  * {@code "taskmanager.job.task"}.  *  * @param filter character filter which is applied to the scope components  * @param delimiter delimiter to use for concatenating scope components  * @param reporterIndex index of the reporter  * @return logical scope  */ String getLogicalScope(CharacterFilter filter, char delimiter, int reporterIndex) {     if (logicalScopeStrings.length == 0 || (reporterIndex < 0 || reporterIndex >= logicalScopeStrings.length)) {         return createLogicalScope(filter, delimiter).     } else {         if (logicalScopeStrings[reporterIndex] == null) {             logicalScopeStrings[reporterIndex] = createLogicalScope(filter, delimiter).         }         return logicalScopeStrings[reporterIndex].     } }
false;protected;2;6;;protected String createLogicalScope(CharacterFilter filter, char delimiter) {     final String groupName = getGroupName(filter).     return parent == null ? groupName : parent.getLogicalScope(filter, delimiter) + delimiter + groupName. }
true;protected,abstract;1;1;/**  * Returns the name for this group, meaning what kind of entity it represents, for example "taskmanager".  *  * @param filter character filter which is applied to the name  * @return logical name for this group  */ ;/**  * Returns the name for this group, meaning what kind of entity it represents, for example "taskmanager".  *  * @param filter character filter which is applied to the name  * @return logical name for this group  */ protected abstract String getGroupName(CharacterFilter filter).
true;public;0;3;/**  * Gets the scope as an array of the scope components, for example  * {@code ["host-7", "taskmanager-2", "window_word_count", "my-mapper"]}.  *  * @see #getMetricIdentifier(String)  */ ;/**  * Gets the scope as an array of the scope components, for example  * {@code ["host-7", "taskmanager-2", "window_word_count", "my-mapper"]}.  *  * @see #getMetricIdentifier(String)  */ public String[] getScopeComponents() {     return scopeComponents. }
true;public;1;6;/**  * Returns the metric query service scope for this group.  *  * @param filter character filter  * @return query service scope  */ ;/**  * Returns the metric query service scope for this group.  *  * @param filter character filter  * @return query service scope  */ public QueryScopeInfo getQueryServiceMetricInfo(CharacterFilter filter) {     if (queryServiceScopeInfo == null) {         queryServiceScopeInfo = createQueryServiceMetricInfo(filter).     }     return queryServiceScopeInfo. }
true;protected,abstract;1;1;/**  * Creates the metric query service scope for this group.  *  * @param filter character filter  * @return query service scope  */ ;/**  * Creates the metric query service scope for this group.  *  * @param filter character filter  * @return query service scope  */ protected abstract QueryScopeInfo createQueryServiceMetricInfo(CharacterFilter filter).
true;public;1;3;/**  * Returns the fully qualified metric name, for example  * {@code "host-7.taskmanager-2.window_word_count.my-mapper.metricName"}.  *  * @param metricName metric name  * @return fully qualified metric name  */ ;/**  * Returns the fully qualified metric name, for example  * {@code "host-7.taskmanager-2.window_word_count.my-mapper.metricName"}.  *  * @param metricName metric name  * @return fully qualified metric name  */ public String getMetricIdentifier(String metricName) {     return getMetricIdentifier(metricName, null). }
true;public;2;3;/**  * Returns the fully qualified metric name, for example  * {@code "host-7.taskmanager-2.window_word_count.my-mapper.metricName"}.  *  * @param metricName metric name  * @param filter character filter which is applied to the scope components if not null.  * @return fully qualified metric name  */ ;/**  * Returns the fully qualified metric name, for example  * {@code "host-7.taskmanager-2.window_word_count.my-mapper.metricName"}.  *  * @param metricName metric name  * @param filter character filter which is applied to the scope components if not null.  * @return fully qualified metric name  */ public String getMetricIdentifier(String metricName, CharacterFilter filter) {     return getMetricIdentifier(metricName, filter, -1). }
true;public;3;26;/**  * Returns the fully qualified metric name using the configured delimiter for the reporter with the given index, for example  * {@code "host-7.taskmanager-2.window_word_count.my-mapper.metricName"}.  *  * @param metricName metric name  * @param filter character filter which is applied to the scope components if not null.  * @param reporterIndex index of the reporter whose delimiter should be used  * @return fully qualified metric name  */ ;/**  * Returns the fully qualified metric name using the configured delimiter for the reporter with the given index, for example  * {@code "host-7.taskmanager-2.window_word_count.my-mapper.metricName"}.  *  * @param metricName metric name  * @param filter character filter which is applied to the scope components if not null.  * @param reporterIndex index of the reporter whose delimiter should be used  * @return fully qualified metric name  */ public String getMetricIdentifier(String metricName, CharacterFilter filter, int reporterIndex) {     if (scopeStrings.length == 0 || (reporterIndex < 0 || reporterIndex >= scopeStrings.length)) {         char delimiter = registry.getDelimiter().         String newScopeString.         if (filter != null) {             newScopeString = ScopeFormat.concat(filter, delimiter, scopeComponents).             metricName = filter.filterCharacters(metricName).         } else {             newScopeString = ScopeFormat.concat(delimiter, scopeComponents).         }         return newScopeString + delimiter + metricName.     } else {         char delimiter = registry.getDelimiter(reporterIndex).         if (scopeStrings[reporterIndex] == null) {             if (filter != null) {                 scopeStrings[reporterIndex] = ScopeFormat.concat(filter, delimiter, scopeComponents).             } else {                 scopeStrings[reporterIndex] = ScopeFormat.concat(delimiter, scopeComponents).             }         }         if (filter != null) {             metricName = filter.filterCharacters(metricName).         }         return scopeStrings[reporterIndex] + delimiter + metricName.     } }
false;public;0;19;;// ------------------------------------------------------------------------ // Closing // ------------------------------------------------------------------------ public void close() {     synchronized (this) {         if (!closed) {             closed = true.             // close all subgroups             for (AbstractMetricGroup group : groups.values()) {                 group.close().             }             groups.clear().             // un-register all directly contained metrics             for (Map.Entry<String, Metric> metric : metrics.entrySet()) {                 registry.unregister(metric.getValue(), metric.getKey(), this).             }             metrics.clear().         }     } }
false;public,final;0;3;;public final boolean isClosed() {     return closed. }
false;public;1;4;;// ----------------------------------------------------------------------------------------------------------------- // Metrics // ----------------------------------------------------------------------------------------------------------------- @Override public Counter counter(int name) {     return counter(String.valueOf(name)). }
false;public;1;4;;@Override public Counter counter(String name) {     return counter(name, new SimpleCounter()). }
false;public;2;4;;@Override public <C extends Counter> C counter(int name, C counter) {     return counter(String.valueOf(name), counter). }
false;public;2;5;;@Override public <C extends Counter> C counter(String name, C counter) {     addMetric(name, counter).     return counter. }
false;public;2;4;;@Override public <T, G extends Gauge<T>> G gauge(int name, G gauge) {     return gauge(String.valueOf(name), gauge). }
false;public;2;5;;@Override public <T, G extends Gauge<T>> G gauge(String name, G gauge) {     addMetric(name, gauge).     return gauge. }
false;public;2;4;;@Override public <H extends Histogram> H histogram(int name, H histogram) {     return histogram(String.valueOf(name), histogram). }
false;public;2;5;;@Override public <H extends Histogram> H histogram(String name, H histogram) {     addMetric(name, histogram).     return histogram. }
false;public;2;4;;@Override public <M extends Meter> M meter(int name, M meter) {     return meter(String.valueOf(name), meter). }
false;public;2;5;;@Override public <M extends Meter> M meter(String name, M meter) {     addMetric(name, meter).     return meter. }
true;protected;2;37;/**  * Adds the given metric to the group and registers it at the registry, if the group  * is not yet closed, and if no metric with the same name has been registered before.  *  * @param name the name to register the metric under  * @param metric the metric to register  */ ;/**  * Adds the given metric to the group and registers it at the registry, if the group  * is not yet closed, and if no metric with the same name has been registered before.  *  * @param name the name to register the metric under  * @param metric the metric to register  */ protected void addMetric(String name, Metric metric) {     if (metric == null) {         LOG.warn("Ignoring attempted registration of a metric due to being null for name {}.", name).         return.     }     // add the metric only if the group is still open     synchronized (this) {         if (!closed) {             // immediately put without a 'contains' check to optimize the common case (no collision)             // collisions are resolved later             Metric prior = metrics.put(name, metric).             // check for collisions with other metric names             if (prior == null) {                 if (groups.containsKey(name)) {                     // we warn here, rather than failing, because metrics are tools that should not fail the                     // program when used incorrectly                     LOG.warn("Name collision: Adding a metric with the same name as a metric subgroup: '" + name + "'. Metric might not get properly reported. " + Arrays.toString(scopeComponents)).                 }                 registry.register(metric, name, this).             } else {                 // we had a collision. put back the original value                 metrics.put(name, prior).                 // we warn here, rather than failing, because metrics are tools that should not fail the                 // program when used incorrectly                 LOG.warn("Name collision: Group already contains a Metric with the name '" + name + "'. Metric will not be reported." + Arrays.toString(scopeComponents)).             }         }     } }
false;public;1;4;;// ------------------------------------------------------------------------ // Groups // ------------------------------------------------------------------------ @Override public MetricGroup addGroup(int name) {     return addGroup(String.valueOf(name), ChildType.GENERIC). }
false;public;1;4;;@Override public MetricGroup addGroup(String name) {     return addGroup(name, ChildType.GENERIC). }
false;public;2;4;;@Override public MetricGroup addGroup(String key, String value) {     return addGroup(key, ChildType.KEY).addGroup(value, ChildType.VALUE). }
false;private;2;30;;private AbstractMetricGroup<?> addGroup(String name, ChildType childType) {     synchronized (this) {         if (!closed) {             // program when used incorrectly             if (metrics.containsKey(name)) {                 LOG.warn("Name collision: Adding a metric subgroup with the same name as an existing metric: '" + name + "'. Metric might not get properly reported. " + Arrays.toString(scopeComponents)).             }             AbstractMetricGroup newGroup = createChildGroup(name, childType).             AbstractMetricGroup prior = groups.put(name, newGroup).             if (prior == null) {                 // no prior group with that name                 return newGroup.             } else {                 // had a prior group with that name, add the prior group back                 groups.put(name, prior).                 return prior.             }         } else {             // return a non-registered group that is immediately closed already             GenericMetricGroup closedGroup = new GenericMetricGroup(registry, this, name).             closedGroup.close().             return closedGroup.         }     } }
false;protected;2;8;;protected GenericMetricGroup createChildGroup(String name, ChildType childType) {     switch(childType) {         case KEY:             return new GenericKeyMetricGroup(registry, this, name).         default:             return new GenericMetricGroup(registry, this, name).     } }
