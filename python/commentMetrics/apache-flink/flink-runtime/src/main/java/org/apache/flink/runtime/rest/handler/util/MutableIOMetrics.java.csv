commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isNumBytesInLocalComplete() {     return numBytesInLocalComplete. }
false;public;0;3;;public boolean isNumBytesInRemoteComplete() {     return numBytesInRemoteComplete. }
false;public;0;3;;public boolean isNumBytesOutComplete() {     return numBytesOutComplete. }
false;public;0;3;;public boolean isNumRecordsInComplete() {     return numRecordsInComplete. }
false;public;0;3;;public boolean isNumRecordsOutComplete() {     return numRecordsOutComplete. }
true;public;4;67;/**  * Adds the IO metrics for the given attempt to this object. If the {@link AccessExecution} is in  * a terminal state the contained {@link IOMetrics} object is added. Otherwise the given {@link MetricFetcher} is  * used to retrieve the required metrics.  *  * @param attempt Attempt whose IO metrics should be added  * @param fetcher MetricFetcher to retrieve metrics for running jobs  * @param jobID JobID to which the attempt belongs  * @param taskID TaskID to which the attempt belongs  */ ;/**  * Adds the IO metrics for the given attempt to this object. If the {@link AccessExecution} is in  * a terminal state the contained {@link IOMetrics} object is added. Otherwise the given {@link MetricFetcher} is  * used to retrieve the required metrics.  *  * @param attempt Attempt whose IO metrics should be added  * @param fetcher MetricFetcher to retrieve metrics for running jobs  * @param jobID JobID to which the attempt belongs  * @param taskID TaskID to which the attempt belongs  */ public void addIOMetrics(AccessExecution attempt, @Nullable MetricFetcher fetcher, String jobID, String taskID) {     if (attempt.getState().isTerminal()) {         IOMetrics ioMetrics = attempt.getIOMetrics().         if (ioMetrics != null) {             // execAttempt is already finished, use final metrics stored in ExecutionGraph             this.numBytesInLocal += ioMetrics.getNumBytesInLocal().             this.numBytesInRemote += ioMetrics.getNumBytesInRemote().             this.numBytesOut += ioMetrics.getNumBytesOut().             this.numRecordsIn += ioMetrics.getNumRecordsIn().             this.numRecordsOut += ioMetrics.getNumRecordsOut().         }     } else {         // execAttempt is still running, use MetricQueryService instead         if (fetcher != null) {             fetcher.update().             MetricStore.ComponentMetricStore metrics = fetcher.getMetricStore().getSubtaskMetricStore(jobID, taskID, attempt.getParallelSubtaskIndex()).             if (metrics != null) {                 /**                  * We want to keep track of missing metrics to be able to make a difference between 0 as a value                  * and a missing value.                  * In case a metric is missing for a parallel instance of a task, we set the complete flag as                  * false.                  */                 if (metrics.getMetric(MetricNames.IO_NUM_BYTES_IN_LOCAL) == null) {                     this.numBytesInLocalComplete = false.                 } else {                     this.numBytesInLocal += Long.valueOf(metrics.getMetric(MetricNames.IO_NUM_BYTES_IN_LOCAL)).                 }                 if (metrics.getMetric(MetricNames.IO_NUM_BYTES_IN_REMOTE) == null) {                     this.numBytesInRemoteComplete = false.                 } else {                     this.numBytesInRemote += Long.valueOf(metrics.getMetric(MetricNames.IO_NUM_BYTES_IN_REMOTE)).                 }                 if (metrics.getMetric(MetricNames.IO_NUM_BYTES_OUT) == null) {                     this.numBytesOutComplete = false.                 } else {                     this.numBytesOut += Long.valueOf(metrics.getMetric(MetricNames.IO_NUM_BYTES_OUT)).                 }                 if (metrics.getMetric(MetricNames.IO_NUM_RECORDS_IN) == null) {                     this.numRecordsInComplete = false.                 } else {                     this.numRecordsIn += Long.valueOf(metrics.getMetric(MetricNames.IO_NUM_RECORDS_IN)).                 }                 if (metrics.getMetric(MetricNames.IO_NUM_RECORDS_OUT) == null) {                     this.numRecordsOutComplete = false.                 } else {                     this.numRecordsOut += Long.valueOf(metrics.getMetric(MetricNames.IO_NUM_RECORDS_OUT)).                 }             } else {                 this.numBytesInLocalComplete = false.                 this.numBytesInRemoteComplete = false.                 this.numBytesOutComplete = false.                 this.numRecordsInComplete = false.                 this.numRecordsOutComplete = false.             }         }     } }
true;public;1;21;/**  * Writes the IO metrics contained in this object to the given {@link JsonGenerator}.  *  * <p>The JSON structure written is as follows:  * "metrics": {  *     "read-bytes": 1,  *     "read-bytes-complete": true,  *     "write-bytes": 2,  *     "write-bytes-complete": true,  *     "read-records": 3,  *     "read-records-complete": true,  *     "write-records": 4,  *     "write-records-complete": true  * }  *  * @param gen JsonGenerator to which the metrics should be written  * @throws IOException  */ ;/**  * Writes the IO metrics contained in this object to the given {@link JsonGenerator}.  *  * <p>The JSON structure written is as follows:  * "metrics": {  *     "read-bytes": 1,  *     "read-bytes-complete": true,  *     "write-bytes": 2,  *     "write-bytes-complete": true,  *     "read-records": 3,  *     "read-records-complete": true,  *     "write-records": 4,  *     "write-records-complete": true  * }  *  * @param gen JsonGenerator to which the metrics should be written  * @throws IOException  */ public void writeIOMetricsAsJson(JsonGenerator gen) throws IOException {     /**      * As described in {@link addIOMetrics}, we want to distinguish incomplete values from 0.      * However, for API backward compatibility, incomplete metrics will still be represented by the 0 value and      * a boolean will indicate the completeness.      */     gen.writeObjectFieldStart("metrics").     Long numBytesIn = this.numBytesInLocal + this.numBytesInRemote.     gen.writeNumberField("read-bytes", numBytesIn).     gen.writeBooleanField("read-bytes-complete", (this.numBytesInLocalComplete && this.numBytesInRemoteComplete)).     gen.writeNumberField("write-bytes", this.numBytesOut).     gen.writeBooleanField("write-bytes-complete", this.numBytesOutComplete).     gen.writeNumberField("read-records", this.numRecordsIn).     gen.writeBooleanField("read-records-complete", this.numRecordsInComplete).     gen.writeNumberField("write-records", this.numRecordsOut).     gen.writeBooleanField("write-records-complete", this.numRecordsOutComplete).     gen.writeEndObject(). }
