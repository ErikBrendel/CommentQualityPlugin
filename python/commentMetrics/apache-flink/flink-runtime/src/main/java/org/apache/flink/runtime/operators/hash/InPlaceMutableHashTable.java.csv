# id;timestamp;commentText;codeText;commentWords;codeWords
InPlaceMutableHashTable -> @Override 	public void insertOrReplaceRecord(T record) throws IOException;1468441547;Searches the hash table for a record with the given key._If it is found, then it is overridden with the specified record._Otherwise, the specified record is inserted._@param record The record to insert or to replace with._@throws IOException (EOFException specifically, if memory ran out);@Override_	public void insertOrReplaceRecord(T record) throws IOException {_		if (closed) {_			return__		}__		T match = prober.getMatchFor(record, reuse)__		if (match == null) {_			prober.insertAfterNoMatch(record)__		} else {_			prober.updateMatch(record)__		}_	};searches,the,hash,table,for,a,record,with,the,given,key,if,it,is,found,then,it,is,overridden,with,the,specified,record,otherwise,the,specified,record,is,inserted,param,record,the,record,to,insert,or,to,replace,with,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,insert,or,replace,record,t,record,throws,ioexception,if,closed,return,t,match,prober,get,match,for,record,reuse,if,match,null,prober,insert,after,no,match,record,else,prober,update,match,record
InPlaceMutableHashTable -> @Override 	public void insertOrReplaceRecord(T record) throws IOException;1515177485;Searches the hash table for a record with the given key._If it is found, then it is overridden with the specified record._Otherwise, the specified record is inserted._@param record The record to insert or to replace with._@throws IOException (EOFException specifically, if memory ran out);@Override_	public void insertOrReplaceRecord(T record) throws IOException {_		if (closed) {_			return__		}__		T match = prober.getMatchFor(record, reuse)__		if (match == null) {_			prober.insertAfterNoMatch(record)__		} else {_			prober.updateMatch(record)__		}_	};searches,the,hash,table,for,a,record,with,the,given,key,if,it,is,found,then,it,is,overridden,with,the,specified,record,otherwise,the,specified,record,is,inserted,param,record,the,record,to,insert,or,to,replace,with,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,insert,or,replace,record,t,record,throws,ioexception,if,closed,return,t,match,prober,get,match,for,record,reuse,if,match,null,prober,insert,after,no,match,record,else,prober,update,match,record
InPlaceMutableHashTable -> @Override 	public void insertOrReplaceRecord(T record) throws IOException;1517317681;Searches the hash table for a record with the given key._If it is found, then it is overridden with the specified record._Otherwise, the specified record is inserted._@param record The record to insert or to replace with._@throws IOException (EOFException specifically, if memory ran out);@Override_	public void insertOrReplaceRecord(T record) throws IOException {_		if (closed) {_			return__		}__		T match = prober.getMatchFor(record, reuse)__		if (match == null) {_			prober.insertAfterNoMatch(record)__		} else {_			prober.updateMatch(record)__		}_	};searches,the,hash,table,for,a,record,with,the,given,key,if,it,is,found,then,it,is,overridden,with,the,specified,record,otherwise,the,specified,record,is,inserted,param,record,the,record,to,insert,or,to,replace,with,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,insert,or,replace,record,t,record,throws,ioexception,if,closed,return,t,match,prober,get,match,for,record,reuse,if,match,null,prober,insert,after,no,match,record,else,prober,update,match,record
InPlaceMutableHashTable -> @Override 	public void insertOrReplaceRecord(T record) throws IOException;1550567875;Searches the hash table for a record with the given key._If it is found, then it is overridden with the specified record._Otherwise, the specified record is inserted._@param record The record to insert or to replace with._@throws IOException (EOFException specifically, if memory ran out);@Override_	public void insertOrReplaceRecord(T record) throws IOException {_		if (closed) {_			return__		}__		T match = prober.getMatchFor(record, reuse)__		if (match == null) {_			prober.insertAfterNoMatch(record)__		} else {_			prober.updateMatch(record)__		}_	};searches,the,hash,table,for,a,record,with,the,given,key,if,it,is,found,then,it,is,overridden,with,the,specified,record,otherwise,the,specified,record,is,inserted,param,record,the,record,to,insert,or,to,replace,with,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,insert,or,replace,record,t,record,throws,ioexception,if,closed,return,t,match,prober,get,match,for,record,reuse,if,match,null,prober,insert,after,no,match,record,else,prober,update,match,record
InPlaceMutableHashTable -> RecordArea -> public void giveBackSegments();1468441547;Moves all its memory segments to freeMemorySegments._Warning: this will leave the RecordArea in an unwritable state: you have to_call setWritePosition before writing again.;public void giveBackSegments() {_			freeMemorySegments.addAll(segments)__			segments.clear()___			resetAppendPosition()__		};moves,all,its,memory,segments,to,free,memory,segments,warning,this,will,leave,the,record,area,in,an,unwritable,state,you,have,to,call,set,write,position,before,writing,again;public,void,give,back,segments,free,memory,segments,add,all,segments,segments,clear,reset,append,position
InPlaceMutableHashTable -> RecordArea -> public void giveBackSegments();1515177485;Moves all its memory segments to freeMemorySegments._Warning: this will leave the RecordArea in an unwritable state: you have to_call setWritePosition before writing again.;public void giveBackSegments() {_			freeMemorySegments.addAll(segments)__			segments.clear()___			resetAppendPosition()__		};moves,all,its,memory,segments,to,free,memory,segments,warning,this,will,leave,the,record,area,in,an,unwritable,state,you,have,to,call,set,write,position,before,writing,again;public,void,give,back,segments,free,memory,segments,add,all,segments,segments,clear,reset,append,position
InPlaceMutableHashTable -> RecordArea -> public void giveBackSegments();1517317681;Moves all its memory segments to freeMemorySegments._Warning: this will leave the RecordArea in an unwritable state: you have to_call setWritePosition before writing again.;public void giveBackSegments() {_			freeMemorySegments.addAll(segments)__			segments.clear()___			resetAppendPosition()__		};moves,all,its,memory,segments,to,free,memory,segments,warning,this,will,leave,the,record,area,in,an,unwritable,state,you,have,to,call,set,write,position,before,writing,again;public,void,give,back,segments,free,memory,segments,add,all,segments,segments,clear,reset,append,position
InPlaceMutableHashTable -> RecordArea -> public void giveBackSegments();1550567875;Moves all its memory segments to freeMemorySegments._Warning: this will leave the RecordArea in an unwritable state: you have to_call setWritePosition before writing again.;public void giveBackSegments() {_			freeMemorySegments.addAll(segments)__			segments.clear()___			resetAppendPosition()__		};moves,all,its,memory,segments,to,free,memory,segments,warning,this,will,leave,the,record,area,in,an,unwritable,state,you,have,to,call,set,write,position,before,writing,again;public,void,give,back,segments,free,memory,segments,add,all,segments,segments,clear,reset,append,position
InPlaceMutableHashTable -> StagingOutputView -> public void reset();1468441547;Seeks to the beginning.;public void reset() {_			seekOutput(segments.get(0), 0)__			currentSegmentIndex = 0__		};seeks,to,the,beginning;public,void,reset,seek,output,segments,get,0,0,current,segment,index,0
InPlaceMutableHashTable -> StagingOutputView -> public void reset();1515177485;Seeks to the beginning.;public void reset() {_			seekOutput(segments.get(0), 0)__			currentSegmentIndex = 0__		};seeks,to,the,beginning;public,void,reset,seek,output,segments,get,0,0,current,segment,index,0
InPlaceMutableHashTable -> StagingOutputView -> public void reset();1517317681;Seeks to the beginning.;public void reset() {_			seekOutput(segments.get(0), 0)__			currentSegmentIndex = 0__		};seeks,to,the,beginning;public,void,reset,seek,output,segments,get,0,0,current,segment,index,0
InPlaceMutableHashTable -> StagingOutputView -> public void reset();1550567875;Seeks to the beginning.;public void reset() {_			seekOutput(segments.get(0), 0)__			currentSegmentIndex = 0__		};seeks,to,the,beginning;public,void,reset,seek,output,segments,get,0,0,current,segment,index,0
InPlaceMutableHashTable -> HashTableProber -> public void insertAfterNoMatch(T record) throws IOException;1468441547;This method can be called after getMatchFor returned null._It inserts the given record to the hash table._Important: The given record should have the same key as the record_that was given to getMatchFor!_WARNING_ Don't do any modifications to the table between_getMatchFor and insertAfterNoMatch!_@throws IOException (EOFException specifically, if memory ran out);public void insertAfterNoMatch(T record) throws IOException {_			if (closed) {_				return__			}__			_			long pointerToAppended__			try {_				pointerToAppended = recordArea.appendPointerAndRecord(END_OF_LIST ,record)__			} catch (EOFException ex) {_				compactOrThrow()__				insert(record)__				return__			}__			_			if (prevElemPtr == INVALID_PREV_POINTER) {_				_				bucketSegments[bucketSegmentIndex].putLong(bucketOffset, pointerToAppended)__			} else {_				_				recordArea.overwritePointerAt(prevElemPtr, pointerToAppended)__			}__			numElements++__			resizeTableIfNecessary()__		};this,method,can,be,called,after,get,match,for,returned,null,it,inserts,the,given,record,to,the,hash,table,important,the,given,record,should,have,the,same,key,as,the,record,that,was,given,to,get,match,for,warning,don,t,do,any,modifications,to,the,table,between,get,match,for,and,insert,after,no,match,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,void,insert,after,no,match,t,record,throws,ioexception,if,closed,return,long,pointer,to,appended,try,pointer,to,appended,record,area,append,pointer,and,record,record,catch,eofexception,ex,compact,or,throw,insert,record,return,if,prev,elem,ptr,bucket,segments,bucket,segment,index,put,long,bucket,offset,pointer,to,appended,else,record,area,overwrite,pointer,at,prev,elem,ptr,pointer,to,appended,num,elements,resize,table,if,necessary
InPlaceMutableHashTable -> HashTableProber -> public void insertAfterNoMatch(T record) throws IOException;1515177485;This method can be called after getMatchFor returned null._It inserts the given record to the hash table._Important: The given record should have the same key as the record_that was given to getMatchFor!_WARNING_ Don't do any modifications to the table between_getMatchFor and insertAfterNoMatch!_@throws IOException (EOFException specifically, if memory ran out);public void insertAfterNoMatch(T record) throws IOException {_			if (closed) {_				return__			}__			_			long pointerToAppended__			try {_				pointerToAppended = recordArea.appendPointerAndRecord(END_OF_LIST ,record)__			} catch (EOFException ex) {_				compactOrThrow()__				insert(record)__				return__			}__			_			if (prevElemPtr == INVALID_PREV_POINTER) {_				_				bucketSegments[bucketSegmentIndex].putLong(bucketOffset, pointerToAppended)__			} else {_				_				recordArea.overwritePointerAt(prevElemPtr, pointerToAppended)__			}__			numElements++__			resizeTableIfNecessary()__		};this,method,can,be,called,after,get,match,for,returned,null,it,inserts,the,given,record,to,the,hash,table,important,the,given,record,should,have,the,same,key,as,the,record,that,was,given,to,get,match,for,warning,don,t,do,any,modifications,to,the,table,between,get,match,for,and,insert,after,no,match,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,void,insert,after,no,match,t,record,throws,ioexception,if,closed,return,long,pointer,to,appended,try,pointer,to,appended,record,area,append,pointer,and,record,record,catch,eofexception,ex,compact,or,throw,insert,record,return,if,prev,elem,ptr,bucket,segments,bucket,segment,index,put,long,bucket,offset,pointer,to,appended,else,record,area,overwrite,pointer,at,prev,elem,ptr,pointer,to,appended,num,elements,resize,table,if,necessary
InPlaceMutableHashTable -> HashTableProber -> public void insertAfterNoMatch(T record) throws IOException;1517317681;This method can be called after getMatchFor returned null._It inserts the given record to the hash table._Important: The given record should have the same key as the record_that was given to getMatchFor!_WARNING_ Don't do any modifications to the table between_getMatchFor and insertAfterNoMatch!_@throws IOException (EOFException specifically, if memory ran out);public void insertAfterNoMatch(T record) throws IOException {_			if (closed) {_				return__			}__			_			long pointerToAppended__			try {_				pointerToAppended = recordArea.appendPointerAndRecord(END_OF_LIST ,record)__			} catch (EOFException ex) {_				compactOrThrow()__				insert(record)__				return__			}__			_			if (prevElemPtr == INVALID_PREV_POINTER) {_				_				bucketSegments[bucketSegmentIndex].putLong(bucketOffset, pointerToAppended)__			} else {_				_				recordArea.overwritePointerAt(prevElemPtr, pointerToAppended)__			}__			numElements++__			resizeTableIfNecessary()__		};this,method,can,be,called,after,get,match,for,returned,null,it,inserts,the,given,record,to,the,hash,table,important,the,given,record,should,have,the,same,key,as,the,record,that,was,given,to,get,match,for,warning,don,t,do,any,modifications,to,the,table,between,get,match,for,and,insert,after,no,match,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,void,insert,after,no,match,t,record,throws,ioexception,if,closed,return,long,pointer,to,appended,try,pointer,to,appended,record,area,append,pointer,and,record,record,catch,eofexception,ex,compact,or,throw,insert,record,return,if,prev,elem,ptr,bucket,segments,bucket,segment,index,put,long,bucket,offset,pointer,to,appended,else,record,area,overwrite,pointer,at,prev,elem,ptr,pointer,to,appended,num,elements,resize,table,if,necessary
InPlaceMutableHashTable -> HashTableProber -> public void insertAfterNoMatch(T record) throws IOException;1550567875;This method can be called after getMatchFor returned null._It inserts the given record to the hash table._Important: The given record should have the same key as the record_that was given to getMatchFor!_WARNING_ Don't do any modifications to the table between_getMatchFor and insertAfterNoMatch!_@throws IOException (EOFException specifically, if memory ran out);public void insertAfterNoMatch(T record) throws IOException {_			if (closed) {_				return__			}__			_			long pointerToAppended__			try {_				pointerToAppended = recordArea.appendPointerAndRecord(END_OF_LIST ,record)__			} catch (EOFException ex) {_				compactOrThrow()__				insert(record)__				return__			}__			_			if (prevElemPtr == INVALID_PREV_POINTER) {_				_				bucketSegments[bucketSegmentIndex].putLong(bucketOffset, pointerToAppended)__			} else {_				_				recordArea.overwritePointerAt(prevElemPtr, pointerToAppended)__			}__			numElements++__			resizeTableIfNecessary()__		};this,method,can,be,called,after,get,match,for,returned,null,it,inserts,the,given,record,to,the,hash,table,important,the,given,record,should,have,the,same,key,as,the,record,that,was,given,to,get,match,for,warning,don,t,do,any,modifications,to,the,table,between,get,match,for,and,insert,after,no,match,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,void,insert,after,no,match,t,record,throws,ioexception,if,closed,return,long,pointer,to,appended,try,pointer,to,appended,record,area,append,pointer,and,record,record,catch,eofexception,ex,compact,or,throw,insert,record,return,if,prev,elem,ptr,bucket,segments,bucket,segment,index,put,long,bucket,offset,pointer,to,appended,else,record,area,overwrite,pointer,at,prev,elem,ptr,pointer,to,appended,num,elements,resize,table,if,necessary
InPlaceMutableHashTable -> ReduceFacade -> public void updateTableEntryWithReduce(T record) throws Exception;1468441547;Looks up the table entry that has the same key as the given record, and updates it by performing_a reduce step._@param record The record to update._@throws Exception;public void updateTableEntryWithReduce(T record) throws Exception {_			T match = prober.getMatchFor(record, reuse)__			if (match == null) {_				prober.insertAfterNoMatch(record)__			} else {_				_				T res = reducer.reduce(match, record)___				_				if (!objectReuseEnabled) {_					reuse = buildSideSerializer.createInstance()__				}__				prober.updateMatch(res)__			}_		};looks,up,the,table,entry,that,has,the,same,key,as,the,given,record,and,updates,it,by,performing,a,reduce,step,param,record,the,record,to,update,throws,exception;public,void,update,table,entry,with,reduce,t,record,throws,exception,t,match,prober,get,match,for,record,reuse,if,match,null,prober,insert,after,no,match,record,else,t,res,reducer,reduce,match,record,if,object,reuse,enabled,reuse,build,side,serializer,create,instance,prober,update,match,res
InPlaceMutableHashTable -> ReduceFacade -> public void updateTableEntryWithReduce(T record) throws Exception;1515177485;Looks up the table entry that has the same key as the given record, and updates it by performing_a reduce step._@param record The record to update._@throws Exception;public void updateTableEntryWithReduce(T record) throws Exception {_			T match = prober.getMatchFor(record, reuse)__			if (match == null) {_				prober.insertAfterNoMatch(record)__			} else {_				_				T res = reducer.reduce(match, record)___				_				if (!objectReuseEnabled) {_					reuse = buildSideSerializer.createInstance()__				}__				prober.updateMatch(res)__			}_		};looks,up,the,table,entry,that,has,the,same,key,as,the,given,record,and,updates,it,by,performing,a,reduce,step,param,record,the,record,to,update,throws,exception;public,void,update,table,entry,with,reduce,t,record,throws,exception,t,match,prober,get,match,for,record,reuse,if,match,null,prober,insert,after,no,match,record,else,t,res,reducer,reduce,match,record,if,object,reuse,enabled,reuse,build,side,serializer,create,instance,prober,update,match,res
InPlaceMutableHashTable -> ReduceFacade -> public void updateTableEntryWithReduce(T record) throws Exception;1517317681;Looks up the table entry that has the same key as the given record, and updates it by performing_a reduce step._@param record The record to update._@throws Exception;public void updateTableEntryWithReduce(T record) throws Exception {_			T match = prober.getMatchFor(record, reuse)__			if (match == null) {_				prober.insertAfterNoMatch(record)__			} else {_				_				T res = reducer.reduce(match, record)___				_				if (!objectReuseEnabled) {_					reuse = buildSideSerializer.createInstance()__				}__				prober.updateMatch(res)__			}_		};looks,up,the,table,entry,that,has,the,same,key,as,the,given,record,and,updates,it,by,performing,a,reduce,step,param,record,the,record,to,update,throws,exception;public,void,update,table,entry,with,reduce,t,record,throws,exception,t,match,prober,get,match,for,record,reuse,if,match,null,prober,insert,after,no,match,record,else,t,res,reducer,reduce,match,record,if,object,reuse,enabled,reuse,build,side,serializer,create,instance,prober,update,match,res
InPlaceMutableHashTable -> ReduceFacade -> public void updateTableEntryWithReduce(T record) throws Exception;1550567875;Looks up the table entry that has the same key as the given record, and updates it by performing_a reduce step._@param record The record to update._@throws Exception;public void updateTableEntryWithReduce(T record) throws Exception {_			T match = prober.getMatchFor(record, reuse)__			if (match == null) {_				prober.insertAfterNoMatch(record)__			} else {_				_				T res = reducer.reduce(match, record)___				_				if (!objectReuseEnabled) {_					reuse = buildSideSerializer.createInstance()__				}__				prober.updateMatch(res)__			}_		};looks,up,the,table,entry,that,has,the,same,key,as,the,given,record,and,updates,it,by,performing,a,reduce,step,param,record,the,record,to,update,throws,exception;public,void,update,table,entry,with,reduce,t,record,throws,exception,t,match,prober,get,match,for,record,reuse,if,match,null,prober,insert,after,no,match,record,else,t,res,reducer,reduce,match,record,if,object,reuse,enabled,reuse,build,side,serializer,create,instance,prober,update,match,res
InPlaceMutableHashTable -> private void rebuild() throws IOException;1468441547;This function reinitializes the bucket segments,_reads all records from the record segments (sequentially, without using the pointers or the buckets),_and rebuilds the hash table.;private void rebuild() throws IOException {_		rebuild(bucketSegments.length)__	};this,function,reinitializes,the,bucket,segments,reads,all,records,from,the,record,segments,sequentially,without,using,the,pointers,or,the,buckets,and,rebuilds,the,hash,table;private,void,rebuild,throws,ioexception,rebuild,bucket,segments,length
InPlaceMutableHashTable -> private void rebuild() throws IOException;1515177485;This function reinitializes the bucket segments,_reads all records from the record segments (sequentially, without using the pointers or the buckets),_and rebuilds the hash table.;private void rebuild() throws IOException {_		rebuild(bucketSegments.length)__	};this,function,reinitializes,the,bucket,segments,reads,all,records,from,the,record,segments,sequentially,without,using,the,pointers,or,the,buckets,and,rebuilds,the,hash,table;private,void,rebuild,throws,ioexception,rebuild,bucket,segments,length
InPlaceMutableHashTable -> private void rebuild() throws IOException;1517317681;This function reinitializes the bucket segments,_reads all records from the record segments (sequentially, without using the pointers or the buckets),_and rebuilds the hash table.;private void rebuild() throws IOException {_		rebuild(bucketSegments.length)__	};this,function,reinitializes,the,bucket,segments,reads,all,records,from,the,record,segments,sequentially,without,using,the,pointers,or,the,buckets,and,rebuilds,the,hash,table;private,void,rebuild,throws,ioexception,rebuild,bucket,segments,length
InPlaceMutableHashTable -> private void rebuild() throws IOException;1550567875;This function reinitializes the bucket segments,_reads all records from the record segments (sequentially, without using the pointers or the buckets),_and rebuilds the hash table.;private void rebuild() throws IOException {_		rebuild(bucketSegments.length)__	};this,function,reinitializes,the,bucket,segments,reads,all,records,from,the,record,segments,sequentially,without,using,the,pointers,or,the,buckets,and,rebuilds,the,hash,table;private,void,rebuild,throws,ioexception,rebuild,bucket,segments,length
InPlaceMutableHashTable -> ReduceFacade -> public void emitAndReset() throws IOException;1468441547;Emits all elements currently held by the table to the collector,_and resets the table. The table will have the same number of buckets_as before the reset, to avoid doing resizes again.;public void emitAndReset() throws IOException {_			final int oldNumBucketSegments = bucketSegments.length__			emit()__			close()__			open(oldNumBucketSegments)__		};emits,all,elements,currently,held,by,the,table,to,the,collector,and,resets,the,table,the,table,will,have,the,same,number,of,buckets,as,before,the,reset,to,avoid,doing,resizes,again;public,void,emit,and,reset,throws,ioexception,final,int,old,num,bucket,segments,bucket,segments,length,emit,close,open,old,num,bucket,segments
InPlaceMutableHashTable -> ReduceFacade -> public void emitAndReset() throws IOException;1515177485;Emits all elements currently held by the table to the collector,_and resets the table. The table will have the same number of buckets_as before the reset, to avoid doing resizes again.;public void emitAndReset() throws IOException {_			final int oldNumBucketSegments = bucketSegments.length__			emit()__			close()__			open(oldNumBucketSegments)__		};emits,all,elements,currently,held,by,the,table,to,the,collector,and,resets,the,table,the,table,will,have,the,same,number,of,buckets,as,before,the,reset,to,avoid,doing,resizes,again;public,void,emit,and,reset,throws,ioexception,final,int,old,num,bucket,segments,bucket,segments,length,emit,close,open,old,num,bucket,segments
InPlaceMutableHashTable -> ReduceFacade -> public void emitAndReset() throws IOException;1517317681;Emits all elements currently held by the table to the collector,_and resets the table. The table will have the same number of buckets_as before the reset, to avoid doing resizes again.;public void emitAndReset() throws IOException {_			final int oldNumBucketSegments = bucketSegments.length__			emit()__			close()__			open(oldNumBucketSegments)__		};emits,all,elements,currently,held,by,the,table,to,the,collector,and,resets,the,table,the,table,will,have,the,same,number,of,buckets,as,before,the,reset,to,avoid,doing,resizes,again;public,void,emit,and,reset,throws,ioexception,final,int,old,num,bucket,segments,bucket,segments,length,emit,close,open,old,num,bucket,segments
InPlaceMutableHashTable -> ReduceFacade -> public void emitAndReset() throws IOException;1550567875;Emits all elements currently held by the table to the collector,_and resets the table. The table will have the same number of buckets_as before the reset, to avoid doing resizes again.;public void emitAndReset() throws IOException {_			final int oldNumBucketSegments = bucketSegments.length__			emit()__			close()__			open(oldNumBucketSegments)__		};emits,all,elements,currently,held,by,the,table,to,the,collector,and,resets,the,table,the,table,will,have,the,same,number,of,buckets,as,before,the,reset,to,avoid,doing,resizes,again;public,void,emit,and,reset,throws,ioexception,final,int,old,num,bucket,segments,bucket,segments,length,emit,close,open,old,num,bucket,segments
InPlaceMutableHashTable -> RecordArea -> public long readPointer() throws IOException;1468441547;Note: this is sometimes a negated length instead of a pointer (see HashTableProber.updateMatch).;public long readPointer() throws IOException {_			return inView.readLong()__		};note,this,is,sometimes,a,negated,length,instead,of,a,pointer,see,hash,table,prober,update,match;public,long,read,pointer,throws,ioexception,return,in,view,read,long
InPlaceMutableHashTable -> RecordArea -> public long readPointer() throws IOException;1515177485;Note: this is sometimes a negated length instead of a pointer (see HashTableProber.updateMatch).;public long readPointer() throws IOException {_			return inView.readLong()__		};note,this,is,sometimes,a,negated,length,instead,of,a,pointer,see,hash,table,prober,update,match;public,long,read,pointer,throws,ioexception,return,in,view,read,long
InPlaceMutableHashTable -> RecordArea -> public long readPointer() throws IOException;1517317681;Note: this is sometimes a negated length instead of a pointer (see HashTableProber.updateMatch).;public long readPointer() throws IOException {_			return inView.readLong()__		};note,this,is,sometimes,a,negated,length,instead,of,a,pointer,see,hash,table,prober,update,match;public,long,read,pointer,throws,ioexception,return,in,view,read,long
InPlaceMutableHashTable -> RecordArea -> public long readPointer() throws IOException;1550567875;Note: this is sometimes a negated length instead of a pointer (see HashTableProber.updateMatch).;public long readPointer() throws IOException {_			return inView.readLong()__		};note,this,is,sometimes,a,negated,length,instead,of,a,pointer,see,hash,table,prober,update,match;public,long,read,pointer,throws,ioexception,return,in,view,read,long
InPlaceMutableHashTable -> public long getCapacity();1468441547;Gets the total capacity of this hash table, in bytes.__@return The hash table's total capacity.;public long getCapacity() {_		return numAllMemorySegments * segmentSize__	};gets,the,total,capacity,of,this,hash,table,in,bytes,return,the,hash,table,s,total,capacity;public,long,get,capacity,return,num,all,memory,segments,segment,size
InPlaceMutableHashTable -> public long getCapacity();1515177485;Gets the total capacity of this hash table, in bytes.__@return The hash table's total capacity.;public long getCapacity() {_		return numAllMemorySegments * segmentSize__	};gets,the,total,capacity,of,this,hash,table,in,bytes,return,the,hash,table,s,total,capacity;public,long,get,capacity,return,num,all,memory,segments,segment,size
InPlaceMutableHashTable -> public long getCapacity();1517317681;Gets the total capacity of this hash table, in bytes.__@return The hash table's total capacity.;public long getCapacity() {_		return numAllMemorySegments * (long)segmentSize__	};gets,the,total,capacity,of,this,hash,table,in,bytes,return,the,hash,table,s,total,capacity;public,long,get,capacity,return,num,all,memory,segments,long,segment,size
InPlaceMutableHashTable -> public long getCapacity();1550567875;Gets the total capacity of this hash table, in bytes.__@return The hash table's total capacity.;public long getCapacity() {_		return numAllMemorySegments * (long)segmentSize__	};gets,the,total,capacity,of,this,hash,table,in,bytes,return,the,hash,table,s,total,capacity;public,long,get,capacity,return,num,all,memory,segments,long,segment,size
InPlaceMutableHashTable -> public long getOccupancy();1468441547;Gets the number of bytes currently occupied in this hash table.__@return The number of bytes occupied.;public long getOccupancy() {_		return numAllMemorySegments * segmentSize - freeMemorySegments.size() * segmentSize__	};gets,the,number,of,bytes,currently,occupied,in,this,hash,table,return,the,number,of,bytes,occupied;public,long,get,occupancy,return,num,all,memory,segments,segment,size,free,memory,segments,size,segment,size
InPlaceMutableHashTable -> public long getOccupancy();1515177485;Gets the number of bytes currently occupied in this hash table.__@return The number of bytes occupied.;public long getOccupancy() {_		return numAllMemorySegments * segmentSize - freeMemorySegments.size() * segmentSize__	};gets,the,number,of,bytes,currently,occupied,in,this,hash,table,return,the,number,of,bytes,occupied;public,long,get,occupancy,return,num,all,memory,segments,segment,size,free,memory,segments,size,segment,size
InPlaceMutableHashTable -> public long getOccupancy();1517317681;Gets the number of bytes currently occupied in this hash table.__@return The number of bytes occupied.;public long getOccupancy() {_		return numAllMemorySegments * segmentSize - freeMemorySegments.size() * segmentSize__	};gets,the,number,of,bytes,currently,occupied,in,this,hash,table,return,the,number,of,bytes,occupied;public,long,get,occupancy,return,num,all,memory,segments,segment,size,free,memory,segments,size,segment,size
InPlaceMutableHashTable -> public long getOccupancy();1550567875;Gets the number of bytes currently occupied in this hash table.__@return The number of bytes occupied.;public long getOccupancy() {_		return numAllMemorySegments * segmentSize - freeMemorySegments.size() * segmentSize__	};gets,the,number,of,bytes,currently,occupied,in,this,hash,table,return,the,number,of,bytes,occupied;public,long,get,occupancy,return,num,all,memory,segments,segment,size,free,memory,segments,size,segment,size
InPlaceMutableHashTable -> HashTableProber -> @Override 		public T getMatchFor(PT record, T targetForMatch);1468441547;Searches the hash table for the record with the given key._(If there would be multiple matches, only one is returned.)_@param record The record whose key we are searching for_@param targetForMatch If a match is found, it will be written here_@return targetForMatch if a match is found, otherwise null.;@Override_		public T getMatchFor(PT record, T targetForMatch) {_			if (closed) {_				return null__			}__			final int hashCode = MathUtils.jenkinsHash(probeTypeComparator.hash(record))__			final int bucket = hashCode & numBucketsMask__			bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _			final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__			bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ __			curElemPtr = bucketSegment.getLong(bucketOffset)___			pairComparator.setReference(record)___			T currentRecordInList = targetForMatch___			prevElemPtr = INVALID_PREV_POINTER__			try {_				while (curElemPtr != END_OF_LIST && !closed) {_					recordArea.setReadPosition(curElemPtr)__					nextPtr = recordArea.readPointer()___					currentRecordInList = recordArea.readRecord(currentRecordInList)__					recordEnd = recordArea.getReadPosition()__					if (pairComparator.equalToReference(currentRecordInList)) {_						_						return currentRecordInList__					}__					prevElemPtr = curElemPtr__					curElemPtr = nextPtr__				}_			} catch (IOException ex) {_				throw new RuntimeException("Error deserializing record from the hashtable: " + ex.getMessage(), ex)__			}_			return null__		};searches,the,hash,table,for,the,record,with,the,given,key,if,there,would,be,multiple,matches,only,one,is,returned,param,record,the,record,whose,key,we,are,searching,for,param,target,for,match,if,a,match,is,found,it,will,be,written,here,return,target,for,match,if,a,match,is,found,otherwise,null;override,public,t,get,match,for,pt,record,t,target,for,match,if,closed,return,null,final,int,hash,code,math,utils,jenkins,hash,probe,type,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,cur,elem,ptr,bucket,segment,get,long,bucket,offset,pair,comparator,set,reference,record,t,current,record,in,list,target,for,match,prev,elem,ptr,try,while,cur,elem,ptr,closed,record,area,set,read,position,cur,elem,ptr,next,ptr,record,area,read,pointer,current,record,in,list,record,area,read,record,current,record,in,list,record,end,record,area,get,read,position,if,pair,comparator,equal,to,reference,current,record,in,list,return,current,record,in,list,prev,elem,ptr,cur,elem,ptr,cur,elem,ptr,next,ptr,catch,ioexception,ex,throw,new,runtime,exception,error,deserializing,record,from,the,hashtable,ex,get,message,ex,return,null
InPlaceMutableHashTable -> HashTableProber -> @Override 		public T getMatchFor(PT record, T targetForMatch);1515177485;Searches the hash table for the record with the given key._(If there would be multiple matches, only one is returned.)_@param record The record whose key we are searching for_@param targetForMatch If a match is found, it will be written here_@return targetForMatch if a match is found, otherwise null.;@Override_		public T getMatchFor(PT record, T targetForMatch) {_			if (closed) {_				return null__			}__			final int hashCode = MathUtils.jenkinsHash(probeTypeComparator.hash(record))__			final int bucket = hashCode & numBucketsMask__			bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _			final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__			bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ __			curElemPtr = bucketSegment.getLong(bucketOffset)___			pairComparator.setReference(record)___			T currentRecordInList = targetForMatch___			prevElemPtr = INVALID_PREV_POINTER__			try {_				while (curElemPtr != END_OF_LIST && !closed) {_					recordArea.setReadPosition(curElemPtr)__					nextPtr = recordArea.readPointer()___					currentRecordInList = recordArea.readRecord(currentRecordInList)__					recordEnd = recordArea.getReadPosition()__					if (pairComparator.equalToReference(currentRecordInList)) {_						_						return currentRecordInList__					}__					prevElemPtr = curElemPtr__					curElemPtr = nextPtr__				}_			} catch (IOException ex) {_				throw new RuntimeException("Error deserializing record from the hashtable: " + ex.getMessage(), ex)__			}_			return null__		};searches,the,hash,table,for,the,record,with,the,given,key,if,there,would,be,multiple,matches,only,one,is,returned,param,record,the,record,whose,key,we,are,searching,for,param,target,for,match,if,a,match,is,found,it,will,be,written,here,return,target,for,match,if,a,match,is,found,otherwise,null;override,public,t,get,match,for,pt,record,t,target,for,match,if,closed,return,null,final,int,hash,code,math,utils,jenkins,hash,probe,type,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,cur,elem,ptr,bucket,segment,get,long,bucket,offset,pair,comparator,set,reference,record,t,current,record,in,list,target,for,match,prev,elem,ptr,try,while,cur,elem,ptr,closed,record,area,set,read,position,cur,elem,ptr,next,ptr,record,area,read,pointer,current,record,in,list,record,area,read,record,current,record,in,list,record,end,record,area,get,read,position,if,pair,comparator,equal,to,reference,current,record,in,list,return,current,record,in,list,prev,elem,ptr,cur,elem,ptr,cur,elem,ptr,next,ptr,catch,ioexception,ex,throw,new,runtime,exception,error,deserializing,record,from,the,hashtable,ex,get,message,ex,return,null
InPlaceMutableHashTable -> HashTableProber -> @Override 		public T getMatchFor(PT record, T targetForMatch);1517317681;Searches the hash table for the record with the given key._(If there would be multiple matches, only one is returned.)_@param record The record whose key we are searching for_@param targetForMatch If a match is found, it will be written here_@return targetForMatch if a match is found, otherwise null.;@Override_		public T getMatchFor(PT record, T targetForMatch) {_			if (closed) {_				return null__			}__			final int hashCode = MathUtils.jenkinsHash(probeTypeComparator.hash(record))__			final int bucket = hashCode & numBucketsMask__			bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _			final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__			bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ __			curElemPtr = bucketSegment.getLong(bucketOffset)___			pairComparator.setReference(record)___			T currentRecordInList = targetForMatch___			prevElemPtr = INVALID_PREV_POINTER__			try {_				while (curElemPtr != END_OF_LIST && !closed) {_					recordArea.setReadPosition(curElemPtr)__					nextPtr = recordArea.readPointer()___					currentRecordInList = recordArea.readRecord(currentRecordInList)__					recordEnd = recordArea.getReadPosition()__					if (pairComparator.equalToReference(currentRecordInList)) {_						_						return currentRecordInList__					}__					prevElemPtr = curElemPtr__					curElemPtr = nextPtr__				}_			} catch (IOException ex) {_				throw new RuntimeException("Error deserializing record from the hashtable: " + ex.getMessage(), ex)__			}_			return null__		};searches,the,hash,table,for,the,record,with,the,given,key,if,there,would,be,multiple,matches,only,one,is,returned,param,record,the,record,whose,key,we,are,searching,for,param,target,for,match,if,a,match,is,found,it,will,be,written,here,return,target,for,match,if,a,match,is,found,otherwise,null;override,public,t,get,match,for,pt,record,t,target,for,match,if,closed,return,null,final,int,hash,code,math,utils,jenkins,hash,probe,type,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,cur,elem,ptr,bucket,segment,get,long,bucket,offset,pair,comparator,set,reference,record,t,current,record,in,list,target,for,match,prev,elem,ptr,try,while,cur,elem,ptr,closed,record,area,set,read,position,cur,elem,ptr,next,ptr,record,area,read,pointer,current,record,in,list,record,area,read,record,current,record,in,list,record,end,record,area,get,read,position,if,pair,comparator,equal,to,reference,current,record,in,list,return,current,record,in,list,prev,elem,ptr,cur,elem,ptr,cur,elem,ptr,next,ptr,catch,ioexception,ex,throw,new,runtime,exception,error,deserializing,record,from,the,hashtable,ex,get,message,ex,return,null
InPlaceMutableHashTable -> HashTableProber -> @Override 		public T getMatchFor(PT record, T targetForMatch);1550567875;Searches the hash table for the record with the given key._(If there would be multiple matches, only one is returned.)_@param record The record whose key we are searching for_@param targetForMatch If a match is found, it will be written here_@return targetForMatch if a match is found, otherwise null.;@Override_		public T getMatchFor(PT record, T targetForMatch) {_			if (closed) {_				return null__			}__			final int hashCode = MathUtils.jenkinsHash(probeTypeComparator.hash(record))__			final int bucket = hashCode & numBucketsMask__			bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _			final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__			bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ __			curElemPtr = bucketSegment.getLong(bucketOffset)___			pairComparator.setReference(record)___			T currentRecordInList = targetForMatch___			prevElemPtr = INVALID_PREV_POINTER__			try {_				while (curElemPtr != END_OF_LIST && !closed) {_					recordArea.setReadPosition(curElemPtr)__					nextPtr = recordArea.readPointer()___					currentRecordInList = recordArea.readRecord(currentRecordInList)__					recordEnd = recordArea.getReadPosition()__					if (pairComparator.equalToReference(currentRecordInList)) {_						_						return currentRecordInList__					}__					prevElemPtr = curElemPtr__					curElemPtr = nextPtr__				}_			} catch (IOException ex) {_				throw new RuntimeException("Error deserializing record from the hashtable: " + ex.getMessage(), ex)__			}_			return null__		};searches,the,hash,table,for,the,record,with,the,given,key,if,there,would,be,multiple,matches,only,one,is,returned,param,record,the,record,whose,key,we,are,searching,for,param,target,for,match,if,a,match,is,found,it,will,be,written,here,return,target,for,match,if,a,match,is,found,otherwise,null;override,public,t,get,match,for,pt,record,t,target,for,match,if,closed,return,null,final,int,hash,code,math,utils,jenkins,hash,probe,type,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,cur,elem,ptr,bucket,segment,get,long,bucket,offset,pair,comparator,set,reference,record,t,current,record,in,list,target,for,match,prev,elem,ptr,try,while,cur,elem,ptr,closed,record,area,set,read,position,cur,elem,ptr,next,ptr,record,area,read,pointer,current,record,in,list,record,area,read,record,current,record,in,list,record,end,record,area,get,read,position,if,pair,comparator,equal,to,reference,current,record,in,list,return,current,record,in,list,prev,elem,ptr,cur,elem,ptr,cur,elem,ptr,next,ptr,catch,ioexception,ex,throw,new,runtime,exception,error,deserializing,record,from,the,hashtable,ex,get,message,ex,return,null
InPlaceMutableHashTable -> RecordArea -> public void overwritePointerAt(long pointer, long value) throws IOException;1468441547;Overwrites the long value at the specified position._@param pointer Points to the position to overwrite._@param value The value to write._@throws IOException;public void overwritePointerAt(long pointer, long value) throws IOException {_			setWritePosition(pointer)__			outView.writeLong(value)__		};overwrites,the,long,value,at,the,specified,position,param,pointer,points,to,the,position,to,overwrite,param,value,the,value,to,write,throws,ioexception;public,void,overwrite,pointer,at,long,pointer,long,value,throws,ioexception,set,write,position,pointer,out,view,write,long,value
InPlaceMutableHashTable -> RecordArea -> public void overwritePointerAt(long pointer, long value) throws IOException;1515177485;Overwrites the long value at the specified position._@param pointer Points to the position to overwrite._@param value The value to write._@throws IOException;public void overwritePointerAt(long pointer, long value) throws IOException {_			setWritePosition(pointer)__			outView.writeLong(value)__		};overwrites,the,long,value,at,the,specified,position,param,pointer,points,to,the,position,to,overwrite,param,value,the,value,to,write,throws,ioexception;public,void,overwrite,pointer,at,long,pointer,long,value,throws,ioexception,set,write,position,pointer,out,view,write,long,value
InPlaceMutableHashTable -> RecordArea -> public void overwritePointerAt(long pointer, long value) throws IOException;1517317681;Overwrites the long value at the specified position._@param pointer Points to the position to overwrite._@param value The value to write._@throws IOException;public void overwritePointerAt(long pointer, long value) throws IOException {_			setWritePosition(pointer)__			outView.writeLong(value)__		};overwrites,the,long,value,at,the,specified,position,param,pointer,points,to,the,position,to,overwrite,param,value,the,value,to,write,throws,ioexception;public,void,overwrite,pointer,at,long,pointer,long,value,throws,ioexception,set,write,position,pointer,out,view,write,long,value
InPlaceMutableHashTable -> RecordArea -> public void overwritePointerAt(long pointer, long value) throws IOException;1550567875;Overwrites the long value at the specified position._@param pointer Points to the position to overwrite._@param value The value to write._@throws IOException;public void overwritePointerAt(long pointer, long value) throws IOException {_			setWritePosition(pointer)__			outView.writeLong(value)__		};overwrites,the,long,value,at,the,specified,position,param,pointer,points,to,the,position,to,overwrite,param,value,the,value,to,write,throws,ioexception;public,void,overwrite,pointer,at,long,pointer,long,value,throws,ioexception,set,write,position,pointer,out,view,write,long,value
InPlaceMutableHashTable -> @Override 	public EntryIterator getEntryIterator();1468441547;Returns an iterator that can be used to iterate over all the elements in the table._WARNING: Doing any other operation on the table invalidates the iterator! (Even_using getMatchFor of a prober!)_@return the iterator;@Override_	public EntryIterator getEntryIterator() {_		return new EntryIterator()__	};returns,an,iterator,that,can,be,used,to,iterate,over,all,the,elements,in,the,table,warning,doing,any,other,operation,on,the,table,invalidates,the,iterator,even,using,get,match,for,of,a,prober,return,the,iterator;override,public,entry,iterator,get,entry,iterator,return,new,entry,iterator
InPlaceMutableHashTable -> @Override 	public EntryIterator getEntryIterator();1515177485;Returns an iterator that can be used to iterate over all the elements in the table._WARNING: Doing any other operation on the table invalidates the iterator! (Even_using getMatchFor of a prober!)_@return the iterator;@Override_	public EntryIterator getEntryIterator() {_		return new EntryIterator()__	};returns,an,iterator,that,can,be,used,to,iterate,over,all,the,elements,in,the,table,warning,doing,any,other,operation,on,the,table,invalidates,the,iterator,even,using,get,match,for,of,a,prober,return,the,iterator;override,public,entry,iterator,get,entry,iterator,return,new,entry,iterator
InPlaceMutableHashTable -> @Override 	public EntryIterator getEntryIterator();1517317681;Returns an iterator that can be used to iterate over all the elements in the table._WARNING: Doing any other operation on the table invalidates the iterator! (Even_using getMatchFor of a prober!)_@return the iterator;@Override_	public EntryIterator getEntryIterator() {_		return new EntryIterator()__	};returns,an,iterator,that,can,be,used,to,iterate,over,all,the,elements,in,the,table,warning,doing,any,other,operation,on,the,table,invalidates,the,iterator,even,using,get,match,for,of,a,prober,return,the,iterator;override,public,entry,iterator,get,entry,iterator,return,new,entry,iterator
InPlaceMutableHashTable -> @Override 	public EntryIterator getEntryIterator();1550567875;Returns an iterator that can be used to iterate over all the elements in the table._WARNING: Doing any other operation on the table invalidates the iterator! (Even_using getMatchFor of a prober!)_@return the iterator;@Override_	public EntryIterator getEntryIterator() {_		return new EntryIterator()__	};returns,an,iterator,that,can,be,used,to,iterate,over,all,the,elements,in,the,table,warning,doing,any,other,operation,on,the,table,invalidates,the,iterator,even,using,get,match,for,of,a,prober,return,the,iterator;override,public,entry,iterator,get,entry,iterator,return,new,entry,iterator
InPlaceMutableHashTable -> @Override 	public void insert(T record) throws IOException;1468441547;Inserts the given record into the hash table._Note: this method doesn't care about whether a record with the same key is already present._@param record The record to insert._@throws IOException (EOFException specifically, if memory ran out);@Override_	public void insert(T record) throws IOException {_		if (closed) {_			return__		}__		final int hashCode = MathUtils.jenkinsHash(buildSideComparator.hash(record))__		final int bucket = hashCode & numBucketsMask__		final int bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _		final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__		final int bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ _		final long firstPointer = bucketSegment.getLong(bucketOffset)___		try {_			final long newFirstPointer = recordArea.appendPointerAndRecord(firstPointer, record)__			bucketSegment.putLong(bucketOffset, newFirstPointer)__		} catch (EOFException ex) {_			compactOrThrow()__			insert(record)__			return__		}__		numElements++__		resizeTableIfNecessary()__	};inserts,the,given,record,into,the,hash,table,note,this,method,doesn,t,care,about,whether,a,record,with,the,same,key,is,already,present,param,record,the,record,to,insert,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,insert,t,record,throws,ioexception,if,closed,return,final,int,hash,code,math,utils,jenkins,hash,build,side,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,final,int,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,final,int,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,final,long,first,pointer,bucket,segment,get,long,bucket,offset,try,final,long,new,first,pointer,record,area,append,pointer,and,record,first,pointer,record,bucket,segment,put,long,bucket,offset,new,first,pointer,catch,eofexception,ex,compact,or,throw,insert,record,return,num,elements,resize,table,if,necessary
InPlaceMutableHashTable -> @Override 	public void insert(T record) throws IOException;1515177485;Inserts the given record into the hash table._Note: this method doesn't care about whether a record with the same key is already present._@param record The record to insert._@throws IOException (EOFException specifically, if memory ran out);@Override_	public void insert(T record) throws IOException {_		if (closed) {_			return__		}__		final int hashCode = MathUtils.jenkinsHash(buildSideComparator.hash(record))__		final int bucket = hashCode & numBucketsMask__		final int bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _		final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__		final int bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ _		final long firstPointer = bucketSegment.getLong(bucketOffset)___		try {_			final long newFirstPointer = recordArea.appendPointerAndRecord(firstPointer, record)__			bucketSegment.putLong(bucketOffset, newFirstPointer)__		} catch (EOFException ex) {_			compactOrThrow()__			insert(record)__			return__		}__		numElements++__		resizeTableIfNecessary()__	};inserts,the,given,record,into,the,hash,table,note,this,method,doesn,t,care,about,whether,a,record,with,the,same,key,is,already,present,param,record,the,record,to,insert,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,insert,t,record,throws,ioexception,if,closed,return,final,int,hash,code,math,utils,jenkins,hash,build,side,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,final,int,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,final,int,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,final,long,first,pointer,bucket,segment,get,long,bucket,offset,try,final,long,new,first,pointer,record,area,append,pointer,and,record,first,pointer,record,bucket,segment,put,long,bucket,offset,new,first,pointer,catch,eofexception,ex,compact,or,throw,insert,record,return,num,elements,resize,table,if,necessary
InPlaceMutableHashTable -> @Override 	public void insert(T record) throws IOException;1517317681;Inserts the given record into the hash table._Note: this method doesn't care about whether a record with the same key is already present._@param record The record to insert._@throws IOException (EOFException specifically, if memory ran out);@Override_	public void insert(T record) throws IOException {_		if (closed) {_			return__		}__		final int hashCode = MathUtils.jenkinsHash(buildSideComparator.hash(record))__		final int bucket = hashCode & numBucketsMask__		final int bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _		final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__		final int bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ _		final long firstPointer = bucketSegment.getLong(bucketOffset)___		try {_			final long newFirstPointer = recordArea.appendPointerAndRecord(firstPointer, record)__			bucketSegment.putLong(bucketOffset, newFirstPointer)__		} catch (EOFException ex) {_			compactOrThrow()__			insert(record)__			return__		}__		numElements++__		resizeTableIfNecessary()__	};inserts,the,given,record,into,the,hash,table,note,this,method,doesn,t,care,about,whether,a,record,with,the,same,key,is,already,present,param,record,the,record,to,insert,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,insert,t,record,throws,ioexception,if,closed,return,final,int,hash,code,math,utils,jenkins,hash,build,side,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,final,int,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,final,int,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,final,long,first,pointer,bucket,segment,get,long,bucket,offset,try,final,long,new,first,pointer,record,area,append,pointer,and,record,first,pointer,record,bucket,segment,put,long,bucket,offset,new,first,pointer,catch,eofexception,ex,compact,or,throw,insert,record,return,num,elements,resize,table,if,necessary
InPlaceMutableHashTable -> @Override 	public void insert(T record) throws IOException;1550567875;Inserts the given record into the hash table._Note: this method doesn't care about whether a record with the same key is already present._@param record The record to insert._@throws IOException (EOFException specifically, if memory ran out);@Override_	public void insert(T record) throws IOException {_		if (closed) {_			return__		}__		final int hashCode = MathUtils.jenkinsHash(buildSideComparator.hash(record))__		final int bucket = hashCode & numBucketsMask__		final int bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _		final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__		final int bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ _		final long firstPointer = bucketSegment.getLong(bucketOffset)___		try {_			final long newFirstPointer = recordArea.appendPointerAndRecord(firstPointer, record)__			bucketSegment.putLong(bucketOffset, newFirstPointer)__		} catch (EOFException ex) {_			compactOrThrow()__			insert(record)__			return__		}__		numElements++__		resizeTableIfNecessary()__	};inserts,the,given,record,into,the,hash,table,note,this,method,doesn,t,care,about,whether,a,record,with,the,same,key,is,already,present,param,record,the,record,to,insert,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,insert,t,record,throws,ioexception,if,closed,return,final,int,hash,code,math,utils,jenkins,hash,build,side,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,final,int,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,final,int,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,final,long,first,pointer,bucket,segment,get,long,bucket,offset,try,final,long,new,first,pointer,record,area,append,pointer,and,record,first,pointer,record,bucket,segment,put,long,bucket,offset,new,first,pointer,catch,eofexception,ex,compact,or,throw,insert,record,return,num,elements,resize,table,if,necessary
InPlaceMutableHashTable -> private void compactOrThrow() throws IOException;1468441547;If there is wasted space (due to updated records not fitting in their old places), then do a compaction._Else, throw EOFException to indicate that memory ran out._@throws IOException;private void compactOrThrow() throws IOException {_		if (holes > (double)recordArea.getTotalSize() * 0.05) {_			rebuild()__		} else {_			throw new EOFException("InPlaceMutableHashTable memory ran out. " + getMemoryConsumptionString())__		}_	};if,there,is,wasted,space,due,to,updated,records,not,fitting,in,their,old,places,then,do,a,compaction,else,throw,eofexception,to,indicate,that,memory,ran,out,throws,ioexception;private,void,compact,or,throw,throws,ioexception,if,holes,double,record,area,get,total,size,0,05,rebuild,else,throw,new,eofexception,in,place,mutable,hash,table,memory,ran,out,get,memory,consumption,string
InPlaceMutableHashTable -> private void compactOrThrow() throws IOException;1515177485;If there is wasted space (due to updated records not fitting in their old places), then do a compaction._Else, throw EOFException to indicate that memory ran out._@throws IOException;private void compactOrThrow() throws IOException {_		if (holes > (double)recordArea.getTotalSize() * 0.05) {_			rebuild()__		} else {_			throw new EOFException("InPlaceMutableHashTable memory ran out. " + getMemoryConsumptionString())__		}_	};if,there,is,wasted,space,due,to,updated,records,not,fitting,in,their,old,places,then,do,a,compaction,else,throw,eofexception,to,indicate,that,memory,ran,out,throws,ioexception;private,void,compact,or,throw,throws,ioexception,if,holes,double,record,area,get,total,size,0,05,rebuild,else,throw,new,eofexception,in,place,mutable,hash,table,memory,ran,out,get,memory,consumption,string
InPlaceMutableHashTable -> private void compactOrThrow() throws IOException;1517317681;If there is wasted space (due to updated records not fitting in their old places), then do a compaction._Else, throw EOFException to indicate that memory ran out._@throws IOException;private void compactOrThrow() throws IOException {_		if (holes > (double)recordArea.getTotalSize() * 0.05) {_			rebuild()__		} else {_			throw new EOFException("InPlaceMutableHashTable memory ran out. " + getMemoryConsumptionString())__		}_	};if,there,is,wasted,space,due,to,updated,records,not,fitting,in,their,old,places,then,do,a,compaction,else,throw,eofexception,to,indicate,that,memory,ran,out,throws,ioexception;private,void,compact,or,throw,throws,ioexception,if,holes,double,record,area,get,total,size,0,05,rebuild,else,throw,new,eofexception,in,place,mutable,hash,table,memory,ran,out,get,memory,consumption,string
InPlaceMutableHashTable -> private void compactOrThrow() throws IOException;1550567875;If there is wasted space (due to updated records not fitting in their old places), then do a compaction._Else, throw EOFException to indicate that memory ran out._@throws IOException;private void compactOrThrow() throws IOException {_		if (holes > (double)recordArea.getTotalSize() * 0.05) {_			rebuild()__		} else {_			throw new EOFException("InPlaceMutableHashTable memory ran out. " + getMemoryConsumptionString())__		}_	};if,there,is,wasted,space,due,to,updated,records,not,fitting,in,their,old,places,then,do,a,compaction,else,throw,eofexception,to,indicate,that,memory,ran,out,throws,ioexception;private,void,compact,or,throw,throws,ioexception,if,holes,double,record,area,get,total,size,0,05,rebuild,else,throw,new,eofexception,in,place,mutable,hash,table,memory,ran,out,get,memory,consumption,string
InPlaceMutableHashTable -> RecordArea -> public void freeSegmentsAfterAppendPosition();1468441547;Releases the memory segments that are after the current append position._Note: The situation that there are segments after the current append position_can arise from a call to resetAppendPosition().;public void freeSegmentsAfterAppendPosition() {_			final int appendSegmentIndex = (int)(appendPosition >>> segmentSizeBits)__			while (segments.size() > appendSegmentIndex + 1 && !closed) {_				freeMemorySegments.add(segments.get(segments.size() - 1))__				segments.remove(segments.size() - 1)__			}_		};releases,the,memory,segments,that,are,after,the,current,append,position,note,the,situation,that,there,are,segments,after,the,current,append,position,can,arise,from,a,call,to,reset,append,position;public,void,free,segments,after,append,position,final,int,append,segment,index,int,append,position,segment,size,bits,while,segments,size,append,segment,index,1,closed,free,memory,segments,add,segments,get,segments,size,1,segments,remove,segments,size,1
InPlaceMutableHashTable -> RecordArea -> public void freeSegmentsAfterAppendPosition();1515177485;Releases the memory segments that are after the current append position._Note: The situation that there are segments after the current append position_can arise from a call to resetAppendPosition().;public void freeSegmentsAfterAppendPosition() {_			final int appendSegmentIndex = (int)(appendPosition >>> segmentSizeBits)__			while (segments.size() > appendSegmentIndex + 1 && !closed) {_				freeMemorySegments.add(segments.get(segments.size() - 1))__				segments.remove(segments.size() - 1)__			}_		};releases,the,memory,segments,that,are,after,the,current,append,position,note,the,situation,that,there,are,segments,after,the,current,append,position,can,arise,from,a,call,to,reset,append,position;public,void,free,segments,after,append,position,final,int,append,segment,index,int,append,position,segment,size,bits,while,segments,size,append,segment,index,1,closed,free,memory,segments,add,segments,get,segments,size,1,segments,remove,segments,size,1
InPlaceMutableHashTable -> RecordArea -> public void freeSegmentsAfterAppendPosition();1517317681;Releases the memory segments that are after the current append position._Note: The situation that there are segments after the current append position_can arise from a call to resetAppendPosition().;public void freeSegmentsAfterAppendPosition() {_			final int appendSegmentIndex = (int)(appendPosition >>> segmentSizeBits)__			while (segments.size() > appendSegmentIndex + 1 && !closed) {_				freeMemorySegments.add(segments.get(segments.size() - 1))__				segments.remove(segments.size() - 1)__			}_		};releases,the,memory,segments,that,are,after,the,current,append,position,note,the,situation,that,there,are,segments,after,the,current,append,position,can,arise,from,a,call,to,reset,append,position;public,void,free,segments,after,append,position,final,int,append,segment,index,int,append,position,segment,size,bits,while,segments,size,append,segment,index,1,closed,free,memory,segments,add,segments,get,segments,size,1,segments,remove,segments,size,1
InPlaceMutableHashTable -> RecordArea -> public void freeSegmentsAfterAppendPosition();1550567875;Releases the memory segments that are after the current append position._Note: The situation that there are segments after the current append position_can arise from a call to resetAppendPosition().;public void freeSegmentsAfterAppendPosition() {_			final int appendSegmentIndex = (int)(appendPosition >>> segmentSizeBits)__			while (segments.size() > appendSegmentIndex + 1 && !closed) {_				freeMemorySegments.add(segments.get(segments.size() - 1))__				segments.remove(segments.size() - 1)__			}_		};releases,the,memory,segments,that,are,after,the,current,append,position,note,the,situation,that,there,are,segments,after,the,current,append,position,can,arise,from,a,call,to,reset,append,position;public,void,free,segments,after,append,position,final,int,append,segment,index,int,append,position,segment,size,bits,while,segments,size,append,segment,index,1,closed,free,memory,segments,add,segments,get,segments,size,1,segments,remove,segments,size,1
InPlaceMutableHashTable -> RecordArea -> public void overwriteRecordAt(long pointer, DataInputView input, int size) throws IOException;1468441547;Overwrites a record at the sepcified position. The record is read from a DataInputView  (this will be the staging area)._WARNING: The record must not be larger than the original record._@param pointer Points to the position to overwrite._@param input The DataInputView to read the record from_@param size The size of the record_@throws IOException;public void overwriteRecordAt(long pointer, DataInputView input, int size) throws IOException {_			setWritePosition(pointer)__			outView.write(input, size)__		};overwrites,a,record,at,the,sepcified,position,the,record,is,read,from,a,data,input,view,this,will,be,the,staging,area,warning,the,record,must,not,be,larger,than,the,original,record,param,pointer,points,to,the,position,to,overwrite,param,input,the,data,input,view,to,read,the,record,from,param,size,the,size,of,the,record,throws,ioexception;public,void,overwrite,record,at,long,pointer,data,input,view,input,int,size,throws,ioexception,set,write,position,pointer,out,view,write,input,size
InPlaceMutableHashTable -> RecordArea -> public void overwriteRecordAt(long pointer, DataInputView input, int size) throws IOException;1515177485;Overwrites a record at the specified position. The record is read from a DataInputView  (this will be the staging area)._WARNING: The record must not be larger than the original record._@param pointer Points to the position to overwrite._@param input The DataInputView to read the record from_@param size The size of the record_@throws IOException;public void overwriteRecordAt(long pointer, DataInputView input, int size) throws IOException {_			setWritePosition(pointer)__			outView.write(input, size)__		};overwrites,a,record,at,the,specified,position,the,record,is,read,from,a,data,input,view,this,will,be,the,staging,area,warning,the,record,must,not,be,larger,than,the,original,record,param,pointer,points,to,the,position,to,overwrite,param,input,the,data,input,view,to,read,the,record,from,param,size,the,size,of,the,record,throws,ioexception;public,void,overwrite,record,at,long,pointer,data,input,view,input,int,size,throws,ioexception,set,write,position,pointer,out,view,write,input,size
InPlaceMutableHashTable -> RecordArea -> public void overwriteRecordAt(long pointer, DataInputView input, int size) throws IOException;1517317681;Overwrites a record at the specified position. The record is read from a DataInputView  (this will be the staging area)._WARNING: The record must not be larger than the original record._@param pointer Points to the position to overwrite._@param input The DataInputView to read the record from_@param size The size of the record_@throws IOException;public void overwriteRecordAt(long pointer, DataInputView input, int size) throws IOException {_			setWritePosition(pointer)__			outView.write(input, size)__		};overwrites,a,record,at,the,specified,position,the,record,is,read,from,a,data,input,view,this,will,be,the,staging,area,warning,the,record,must,not,be,larger,than,the,original,record,param,pointer,points,to,the,position,to,overwrite,param,input,the,data,input,view,to,read,the,record,from,param,size,the,size,of,the,record,throws,ioexception;public,void,overwrite,record,at,long,pointer,data,input,view,input,int,size,throws,ioexception,set,write,position,pointer,out,view,write,input,size
InPlaceMutableHashTable -> RecordArea -> public void overwriteRecordAt(long pointer, DataInputView input, int size) throws IOException;1550567875;Overwrites a record at the specified position. The record is read from a DataInputView  (this will be the staging area)._WARNING: The record must not be larger than the original record._@param pointer Points to the position to overwrite._@param input The DataInputView to read the record from_@param size The size of the record_@throws IOException;public void overwriteRecordAt(long pointer, DataInputView input, int size) throws IOException {_			setWritePosition(pointer)__			outView.write(input, size)__		};overwrites,a,record,at,the,specified,position,the,record,is,read,from,a,data,input,view,this,will,be,the,staging,area,warning,the,record,must,not,be,larger,than,the,original,record,param,pointer,points,to,the,position,to,overwrite,param,input,the,data,input,view,to,read,the,record,from,param,size,the,size,of,the,record,throws,ioexception;public,void,overwrite,record,at,long,pointer,data,input,view,input,int,size,throws,ioexception,set,write,position,pointer,out,view,write,input,size
InPlaceMutableHashTable -> private void rebuild(long newNumBucketSegments) throws IOException;1468441547;Same as above, but the number of bucket segments of the new table can be specified.;private void rebuild(long newNumBucketSegments) throws IOException {_		_		releaseBucketSegments()__		allocateBucketSegments((int)newNumBucketSegments)___		T record = buildSideSerializer.createInstance()__		try {_			EntryIterator iter = getEntryIterator()__			recordArea.resetAppendPosition()__			recordArea.setWritePosition(0)__			while ((record = iter.next(record)) != null && !closed) {_				final int hashCode = MathUtils.jenkinsHash(buildSideComparator.hash(record))__				final int bucket = hashCode & numBucketsMask__				final int bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _				final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__				final int bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ _				final long firstPointer = bucketSegment.getLong(bucketOffset)___				long ptrToAppended = recordArea.noSeekAppendPointerAndRecord(firstPointer, record)__				bucketSegment.putLong(bucketOffset, ptrToAppended)__			}_			recordArea.freeSegmentsAfterAppendPosition()__			holes = 0___		} catch (EOFException ex) {_			throw new RuntimeException("Bug in InPlaceMutableHashTable: we shouldn't get out of memory during a rebuild, " +_				"because we aren't allocating any new memory.")__		}_	};same,as,above,but,the,number,of,bucket,segments,of,the,new,table,can,be,specified;private,void,rebuild,long,new,num,bucket,segments,throws,ioexception,release,bucket,segments,allocate,bucket,segments,int,new,num,bucket,segments,t,record,build,side,serializer,create,instance,try,entry,iterator,iter,get,entry,iterator,record,area,reset,append,position,record,area,set,write,position,0,while,record,iter,next,record,null,closed,final,int,hash,code,math,utils,jenkins,hash,build,side,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,final,int,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,final,int,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,final,long,first,pointer,bucket,segment,get,long,bucket,offset,long,ptr,to,appended,record,area,no,seek,append,pointer,and,record,first,pointer,record,bucket,segment,put,long,bucket,offset,ptr,to,appended,record,area,free,segments,after,append,position,holes,0,catch,eofexception,ex,throw,new,runtime,exception,bug,in,in,place,mutable,hash,table,we,shouldn,t,get,out,of,memory,during,a,rebuild,because,we,aren,t,allocating,any,new,memory
InPlaceMutableHashTable -> private void rebuild(long newNumBucketSegments) throws IOException;1515177485;Same as above, but the number of bucket segments of the new table can be specified.;private void rebuild(long newNumBucketSegments) throws IOException {_		_		releaseBucketSegments()__		allocateBucketSegments((int)newNumBucketSegments)___		T record = buildSideSerializer.createInstance()__		try {_			EntryIterator iter = getEntryIterator()__			recordArea.resetAppendPosition()__			recordArea.setWritePosition(0)__			while ((record = iter.next(record)) != null && !closed) {_				final int hashCode = MathUtils.jenkinsHash(buildSideComparator.hash(record))__				final int bucket = hashCode & numBucketsMask__				final int bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _				final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__				final int bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ _				final long firstPointer = bucketSegment.getLong(bucketOffset)___				long ptrToAppended = recordArea.noSeekAppendPointerAndRecord(firstPointer, record)__				bucketSegment.putLong(bucketOffset, ptrToAppended)__			}_			recordArea.freeSegmentsAfterAppendPosition()__			holes = 0___		} catch (EOFException ex) {_			throw new RuntimeException("Bug in InPlaceMutableHashTable: we shouldn't get out of memory during a rebuild, " +_				"because we aren't allocating any new memory.")__		}_	};same,as,above,but,the,number,of,bucket,segments,of,the,new,table,can,be,specified;private,void,rebuild,long,new,num,bucket,segments,throws,ioexception,release,bucket,segments,allocate,bucket,segments,int,new,num,bucket,segments,t,record,build,side,serializer,create,instance,try,entry,iterator,iter,get,entry,iterator,record,area,reset,append,position,record,area,set,write,position,0,while,record,iter,next,record,null,closed,final,int,hash,code,math,utils,jenkins,hash,build,side,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,final,int,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,final,int,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,final,long,first,pointer,bucket,segment,get,long,bucket,offset,long,ptr,to,appended,record,area,no,seek,append,pointer,and,record,first,pointer,record,bucket,segment,put,long,bucket,offset,ptr,to,appended,record,area,free,segments,after,append,position,holes,0,catch,eofexception,ex,throw,new,runtime,exception,bug,in,in,place,mutable,hash,table,we,shouldn,t,get,out,of,memory,during,a,rebuild,because,we,aren,t,allocating,any,new,memory
InPlaceMutableHashTable -> private void rebuild(long newNumBucketSegments) throws IOException;1517317681;Same as above, but the number of bucket segments of the new table can be specified.;private void rebuild(long newNumBucketSegments) throws IOException {_		_		releaseBucketSegments()__		allocateBucketSegments((int)newNumBucketSegments)___		T record = buildSideSerializer.createInstance()__		try {_			EntryIterator iter = getEntryIterator()__			recordArea.resetAppendPosition()__			recordArea.setWritePosition(0)__			while ((record = iter.next(record)) != null && !closed) {_				final int hashCode = MathUtils.jenkinsHash(buildSideComparator.hash(record))__				final int bucket = hashCode & numBucketsMask__				final int bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _				final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__				final int bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ _				final long firstPointer = bucketSegment.getLong(bucketOffset)___				long ptrToAppended = recordArea.noSeekAppendPointerAndRecord(firstPointer, record)__				bucketSegment.putLong(bucketOffset, ptrToAppended)__			}_			recordArea.freeSegmentsAfterAppendPosition()__			holes = 0___		} catch (EOFException ex) {_			throw new RuntimeException("Bug in InPlaceMutableHashTable: we shouldn't get out of memory during a rebuild, " +_				"because we aren't allocating any new memory.")__		}_	};same,as,above,but,the,number,of,bucket,segments,of,the,new,table,can,be,specified;private,void,rebuild,long,new,num,bucket,segments,throws,ioexception,release,bucket,segments,allocate,bucket,segments,int,new,num,bucket,segments,t,record,build,side,serializer,create,instance,try,entry,iterator,iter,get,entry,iterator,record,area,reset,append,position,record,area,set,write,position,0,while,record,iter,next,record,null,closed,final,int,hash,code,math,utils,jenkins,hash,build,side,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,final,int,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,final,int,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,final,long,first,pointer,bucket,segment,get,long,bucket,offset,long,ptr,to,appended,record,area,no,seek,append,pointer,and,record,first,pointer,record,bucket,segment,put,long,bucket,offset,ptr,to,appended,record,area,free,segments,after,append,position,holes,0,catch,eofexception,ex,throw,new,runtime,exception,bug,in,in,place,mutable,hash,table,we,shouldn,t,get,out,of,memory,during,a,rebuild,because,we,aren,t,allocating,any,new,memory
InPlaceMutableHashTable -> private void rebuild(long newNumBucketSegments) throws IOException;1550567875;Same as above, but the number of bucket segments of the new table can be specified.;private void rebuild(long newNumBucketSegments) throws IOException {_		_		releaseBucketSegments()__		allocateBucketSegments((int)newNumBucketSegments)___		T record = buildSideSerializer.createInstance()__		try {_			EntryIterator iter = getEntryIterator()__			recordArea.resetAppendPosition()__			recordArea.setWritePosition(0)__			while ((record = iter.next(record)) != null && !closed) {_				final int hashCode = MathUtils.jenkinsHash(buildSideComparator.hash(record))__				final int bucket = hashCode & numBucketsMask__				final int bucketSegmentIndex = bucket >>> numBucketsPerSegmentBits_ _				final MemorySegment bucketSegment = bucketSegments[bucketSegmentIndex]__				final int bucketOffset = (bucket & numBucketsPerSegmentMask) << bucketSizeBits_ _				final long firstPointer = bucketSegment.getLong(bucketOffset)___				long ptrToAppended = recordArea.noSeekAppendPointerAndRecord(firstPointer, record)__				bucketSegment.putLong(bucketOffset, ptrToAppended)__			}_			recordArea.freeSegmentsAfterAppendPosition()__			holes = 0___		} catch (EOFException ex) {_			throw new RuntimeException("Bug in InPlaceMutableHashTable: we shouldn't get out of memory during a rebuild, " +_				"because we aren't allocating any new memory.")__		}_	};same,as,above,but,the,number,of,bucket,segments,of,the,new,table,can,be,specified;private,void,rebuild,long,new,num,bucket,segments,throws,ioexception,release,bucket,segments,allocate,bucket,segments,int,new,num,bucket,segments,t,record,build,side,serializer,create,instance,try,entry,iterator,iter,get,entry,iterator,record,area,reset,append,position,record,area,set,write,position,0,while,record,iter,next,record,null,closed,final,int,hash,code,math,utils,jenkins,hash,build,side,comparator,hash,record,final,int,bucket,hash,code,num,buckets,mask,final,int,bucket,segment,index,bucket,num,buckets,per,segment,bits,final,memory,segment,bucket,segment,bucket,segments,bucket,segment,index,final,int,bucket,offset,bucket,num,buckets,per,segment,mask,bucket,size,bits,final,long,first,pointer,bucket,segment,get,long,bucket,offset,long,ptr,to,appended,record,area,no,seek,append,pointer,and,record,first,pointer,record,bucket,segment,put,long,bucket,offset,ptr,to,appended,record,area,free,segments,after,append,position,holes,0,catch,eofexception,ex,throw,new,runtime,exception,bug,in,in,place,mutable,hash,table,we,shouldn,t,get,out,of,memory,during,a,rebuild,because,we,aren,t,allocating,any,new,memory
InPlaceMutableHashTable -> HashTableProber -> @Override 		public void updateMatch(T newRecord) throws IOException;1468441547;This method can be called after getMatchFor returned a match._It will overwrite the record that was found by getMatchFor._Warning: The new record should have the same key as the old!_WARNING_ Don't do any modifications to the table between_getMatchFor and updateMatch!_@param newRecord The record to override the old record with._@throws IOException (EOFException specifically, if memory ran out);@Override_		public void updateMatch(T newRecord) throws IOException {_			if (closed) {_				return__			}_			if (curElemPtr == END_OF_LIST) {_				throw new RuntimeException("updateMatch was called after getMatchFor returned no match")__			}__			try {_				_				stagingSegmentsOutView.reset()__				buildSideSerializer.serialize(newRecord, stagingSegmentsOutView)__				final int newRecordSize = (int)stagingSegmentsOutView.getWritePosition()__				stagingSegmentsInView.setReadPosition(0)___				_				final int oldRecordSize = (int)(recordEnd - (curElemPtr + RECORD_OFFSET_IN_LINK))___				if (newRecordSize == oldRecordSize) {_					_					recordArea.overwriteRecordAt(curElemPtr + RECORD_OFFSET_IN_LINK, stagingSegmentsInView, newRecordSize)__				} else {_					_					_					__					final long pointerToAppended =_						recordArea.appendPointerAndCopyRecord(nextPtr, stagingSegmentsInView, newRecordSize)___					_					if (prevElemPtr == INVALID_PREV_POINTER) {_						_						bucketSegments[bucketSegmentIndex].putLong(bucketOffset, pointerToAppended)__					} else {_						recordArea.overwritePointerAt(prevElemPtr, pointerToAppended)__					}__					_					_					_					_					_					_					recordArea.overwritePointerAt(curElemPtr, -oldRecordSize - 1)___					holes += oldRecordSize__				}_			} catch (EOFException ex) {_				compactOrThrow()__				insertOrReplaceRecord(newRecord)__			}_		};this,method,can,be,called,after,get,match,for,returned,a,match,it,will,overwrite,the,record,that,was,found,by,get,match,for,warning,the,new,record,should,have,the,same,key,as,the,old,warning,don,t,do,any,modifications,to,the,table,between,get,match,for,and,update,match,param,new,record,the,record,to,override,the,old,record,with,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,update,match,t,new,record,throws,ioexception,if,closed,return,if,cur,elem,ptr,throw,new,runtime,exception,update,match,was,called,after,get,match,for,returned,no,match,try,staging,segments,out,view,reset,build,side,serializer,serialize,new,record,staging,segments,out,view,final,int,new,record,size,int,staging,segments,out,view,get,write,position,staging,segments,in,view,set,read,position,0,final,int,old,record,size,int,record,end,cur,elem,ptr,if,new,record,size,old,record,size,record,area,overwrite,record,at,cur,elem,ptr,staging,segments,in,view,new,record,size,else,final,long,pointer,to,appended,record,area,append,pointer,and,copy,record,next,ptr,staging,segments,in,view,new,record,size,if,prev,elem,ptr,bucket,segments,bucket,segment,index,put,long,bucket,offset,pointer,to,appended,else,record,area,overwrite,pointer,at,prev,elem,ptr,pointer,to,appended,record,area,overwrite,pointer,at,cur,elem,ptr,old,record,size,1,holes,old,record,size,catch,eofexception,ex,compact,or,throw,insert,or,replace,record,new,record
InPlaceMutableHashTable -> HashTableProber -> @Override 		public void updateMatch(T newRecord) throws IOException;1515177485;This method can be called after getMatchFor returned a match._It will overwrite the record that was found by getMatchFor._Warning: The new record should have the same key as the old!_WARNING_ Don't do any modifications to the table between_getMatchFor and updateMatch!_@param newRecord The record to override the old record with._@throws IOException (EOFException specifically, if memory ran out);@Override_		public void updateMatch(T newRecord) throws IOException {_			if (closed) {_				return__			}_			if (curElemPtr == END_OF_LIST) {_				throw new RuntimeException("updateMatch was called after getMatchFor returned no match")__			}__			try {_				_				stagingSegmentsOutView.reset()__				buildSideSerializer.serialize(newRecord, stagingSegmentsOutView)__				final int newRecordSize = (int)stagingSegmentsOutView.getWritePosition()__				stagingSegmentsInView.setReadPosition(0)___				_				final int oldRecordSize = (int)(recordEnd - (curElemPtr + RECORD_OFFSET_IN_LINK))___				if (newRecordSize == oldRecordSize) {_					_					recordArea.overwriteRecordAt(curElemPtr + RECORD_OFFSET_IN_LINK, stagingSegmentsInView, newRecordSize)__				} else {_					_					_					__					final long pointerToAppended =_						recordArea.appendPointerAndCopyRecord(nextPtr, stagingSegmentsInView, newRecordSize)___					_					if (prevElemPtr == INVALID_PREV_POINTER) {_						_						bucketSegments[bucketSegmentIndex].putLong(bucketOffset, pointerToAppended)__					} else {_						recordArea.overwritePointerAt(prevElemPtr, pointerToAppended)__					}__					_					_					_					_					_					_					recordArea.overwritePointerAt(curElemPtr, -oldRecordSize - 1)___					holes += oldRecordSize__				}_			} catch (EOFException ex) {_				compactOrThrow()__				insertOrReplaceRecord(newRecord)__			}_		};this,method,can,be,called,after,get,match,for,returned,a,match,it,will,overwrite,the,record,that,was,found,by,get,match,for,warning,the,new,record,should,have,the,same,key,as,the,old,warning,don,t,do,any,modifications,to,the,table,between,get,match,for,and,update,match,param,new,record,the,record,to,override,the,old,record,with,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,update,match,t,new,record,throws,ioexception,if,closed,return,if,cur,elem,ptr,throw,new,runtime,exception,update,match,was,called,after,get,match,for,returned,no,match,try,staging,segments,out,view,reset,build,side,serializer,serialize,new,record,staging,segments,out,view,final,int,new,record,size,int,staging,segments,out,view,get,write,position,staging,segments,in,view,set,read,position,0,final,int,old,record,size,int,record,end,cur,elem,ptr,if,new,record,size,old,record,size,record,area,overwrite,record,at,cur,elem,ptr,staging,segments,in,view,new,record,size,else,final,long,pointer,to,appended,record,area,append,pointer,and,copy,record,next,ptr,staging,segments,in,view,new,record,size,if,prev,elem,ptr,bucket,segments,bucket,segment,index,put,long,bucket,offset,pointer,to,appended,else,record,area,overwrite,pointer,at,prev,elem,ptr,pointer,to,appended,record,area,overwrite,pointer,at,cur,elem,ptr,old,record,size,1,holes,old,record,size,catch,eofexception,ex,compact,or,throw,insert,or,replace,record,new,record
InPlaceMutableHashTable -> HashTableProber -> @Override 		public void updateMatch(T newRecord) throws IOException;1517317681;This method can be called after getMatchFor returned a match._It will overwrite the record that was found by getMatchFor._Warning: The new record should have the same key as the old!_WARNING_ Don't do any modifications to the table between_getMatchFor and updateMatch!_@param newRecord The record to override the old record with._@throws IOException (EOFException specifically, if memory ran out);@Override_		public void updateMatch(T newRecord) throws IOException {_			if (closed) {_				return__			}_			if (curElemPtr == END_OF_LIST) {_				throw new RuntimeException("updateMatch was called after getMatchFor returned no match")__			}__			try {_				_				stagingSegmentsOutView.reset()__				buildSideSerializer.serialize(newRecord, stagingSegmentsOutView)__				final int newRecordSize = (int)stagingSegmentsOutView.getWritePosition()__				stagingSegmentsInView.setReadPosition(0)___				_				final int oldRecordSize = (int)(recordEnd - (curElemPtr + RECORD_OFFSET_IN_LINK))___				if (newRecordSize == oldRecordSize) {_					_					recordArea.overwriteRecordAt(curElemPtr + RECORD_OFFSET_IN_LINK, stagingSegmentsInView, newRecordSize)__				} else {_					_					_					__					final long pointerToAppended =_						recordArea.appendPointerAndCopyRecord(nextPtr, stagingSegmentsInView, newRecordSize)___					_					if (prevElemPtr == INVALID_PREV_POINTER) {_						_						bucketSegments[bucketSegmentIndex].putLong(bucketOffset, pointerToAppended)__					} else {_						recordArea.overwritePointerAt(prevElemPtr, pointerToAppended)__					}__					_					_					_					_					_					_					recordArea.overwritePointerAt(curElemPtr, -oldRecordSize - 1)___					holes += oldRecordSize__				}_			} catch (EOFException ex) {_				compactOrThrow()__				insertOrReplaceRecord(newRecord)__			}_		};this,method,can,be,called,after,get,match,for,returned,a,match,it,will,overwrite,the,record,that,was,found,by,get,match,for,warning,the,new,record,should,have,the,same,key,as,the,old,warning,don,t,do,any,modifications,to,the,table,between,get,match,for,and,update,match,param,new,record,the,record,to,override,the,old,record,with,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,update,match,t,new,record,throws,ioexception,if,closed,return,if,cur,elem,ptr,throw,new,runtime,exception,update,match,was,called,after,get,match,for,returned,no,match,try,staging,segments,out,view,reset,build,side,serializer,serialize,new,record,staging,segments,out,view,final,int,new,record,size,int,staging,segments,out,view,get,write,position,staging,segments,in,view,set,read,position,0,final,int,old,record,size,int,record,end,cur,elem,ptr,if,new,record,size,old,record,size,record,area,overwrite,record,at,cur,elem,ptr,staging,segments,in,view,new,record,size,else,final,long,pointer,to,appended,record,area,append,pointer,and,copy,record,next,ptr,staging,segments,in,view,new,record,size,if,prev,elem,ptr,bucket,segments,bucket,segment,index,put,long,bucket,offset,pointer,to,appended,else,record,area,overwrite,pointer,at,prev,elem,ptr,pointer,to,appended,record,area,overwrite,pointer,at,cur,elem,ptr,old,record,size,1,holes,old,record,size,catch,eofexception,ex,compact,or,throw,insert,or,replace,record,new,record
InPlaceMutableHashTable -> HashTableProber -> @Override 		public void updateMatch(T newRecord) throws IOException;1550567875;This method can be called after getMatchFor returned a match._It will overwrite the record that was found by getMatchFor._Warning: The new record should have the same key as the old!_WARNING_ Don't do any modifications to the table between_getMatchFor and updateMatch!_@param newRecord The record to override the old record with._@throws IOException (EOFException specifically, if memory ran out);@Override_		public void updateMatch(T newRecord) throws IOException {_			if (closed) {_				return__			}_			if (curElemPtr == END_OF_LIST) {_				throw new RuntimeException("updateMatch was called after getMatchFor returned no match")__			}__			try {_				_				stagingSegmentsOutView.reset()__				buildSideSerializer.serialize(newRecord, stagingSegmentsOutView)__				final int newRecordSize = (int)stagingSegmentsOutView.getWritePosition()__				stagingSegmentsInView.setReadPosition(0)___				_				final int oldRecordSize = (int)(recordEnd - (curElemPtr + RECORD_OFFSET_IN_LINK))___				if (newRecordSize == oldRecordSize) {_					_					recordArea.overwriteRecordAt(curElemPtr + RECORD_OFFSET_IN_LINK, stagingSegmentsInView, newRecordSize)__				} else {_					_					_					__					final long pointerToAppended =_						recordArea.appendPointerAndCopyRecord(nextPtr, stagingSegmentsInView, newRecordSize)___					_					if (prevElemPtr == INVALID_PREV_POINTER) {_						_						bucketSegments[bucketSegmentIndex].putLong(bucketOffset, pointerToAppended)__					} else {_						recordArea.overwritePointerAt(prevElemPtr, pointerToAppended)__					}__					_					_					_					_					_					_					recordArea.overwritePointerAt(curElemPtr, -oldRecordSize - 1)___					holes += oldRecordSize__				}_			} catch (EOFException ex) {_				compactOrThrow()__				insertOrReplaceRecord(newRecord)__			}_		};this,method,can,be,called,after,get,match,for,returned,a,match,it,will,overwrite,the,record,that,was,found,by,get,match,for,warning,the,new,record,should,have,the,same,key,as,the,old,warning,don,t,do,any,modifications,to,the,table,between,get,match,for,and,update,match,param,new,record,the,record,to,override,the,old,record,with,throws,ioexception,eofexception,specifically,if,memory,ran,out;override,public,void,update,match,t,new,record,throws,ioexception,if,closed,return,if,cur,elem,ptr,throw,new,runtime,exception,update,match,was,called,after,get,match,for,returned,no,match,try,staging,segments,out,view,reset,build,side,serializer,serialize,new,record,staging,segments,out,view,final,int,new,record,size,int,staging,segments,out,view,get,write,position,staging,segments,in,view,set,read,position,0,final,int,old,record,size,int,record,end,cur,elem,ptr,if,new,record,size,old,record,size,record,area,overwrite,record,at,cur,elem,ptr,staging,segments,in,view,new,record,size,else,final,long,pointer,to,appended,record,area,append,pointer,and,copy,record,next,ptr,staging,segments,in,view,new,record,size,if,prev,elem,ptr,bucket,segments,bucket,segment,index,put,long,bucket,offset,pointer,to,appended,else,record,area,overwrite,pointer,at,prev,elem,ptr,pointer,to,appended,record,area,overwrite,pointer,at,cur,elem,ptr,old,record,size,1,holes,old,record,size,catch,eofexception,ex,compact,or,throw,insert,or,replace,record,new,record
InPlaceMutableHashTable -> private String getMemoryConsumptionString();1468441547;@return String containing a summary of the memory consumption for error messages;private String getMemoryConsumptionString() {_		return "InPlaceMutableHashTable memory stats:\n" +_			"Total memory:     " + numAllMemorySegments * segmentSize + "\n" +_			"Free memory:      " + freeMemorySegments.size() * segmentSize + "\n" +_			"Bucket area:      " + numBuckets * 8  + "\n" +_			"Record area:      " + recordArea.getTotalSize() + "\n" +_			"Staging area:     " + stagingSegments.size() * segmentSize + "\n" +_			"Num of elements:  " + numElements + "\n" +_			"Holes total size: " + holes__	};return,string,containing,a,summary,of,the,memory,consumption,for,error,messages;private,string,get,memory,consumption,string,return,in,place,mutable,hash,table,memory,stats,n,total,memory,num,all,memory,segments,segment,size,n,free,memory,free,memory,segments,size,segment,size,n,bucket,area,num,buckets,8,n,record,area,record,area,get,total,size,n,staging,area,staging,segments,size,segment,size,n,num,of,elements,num,elements,n,holes,total,size,holes
InPlaceMutableHashTable -> private String getMemoryConsumptionString();1515177485;@return String containing a summary of the memory consumption for error messages;private String getMemoryConsumptionString() {_		return "InPlaceMutableHashTable memory stats:\n" +_			"Total memory:     " + numAllMemorySegments * segmentSize + "\n" +_			"Free memory:      " + freeMemorySegments.size() * segmentSize + "\n" +_			"Bucket area:      " + numBuckets * 8  + "\n" +_			"Record area:      " + recordArea.getTotalSize() + "\n" +_			"Staging area:     " + stagingSegments.size() * segmentSize + "\n" +_			"Num of elements:  " + numElements + "\n" +_			"Holes total size: " + holes__	};return,string,containing,a,summary,of,the,memory,consumption,for,error,messages;private,string,get,memory,consumption,string,return,in,place,mutable,hash,table,memory,stats,n,total,memory,num,all,memory,segments,segment,size,n,free,memory,free,memory,segments,size,segment,size,n,bucket,area,num,buckets,8,n,record,area,record,area,get,total,size,n,staging,area,staging,segments,size,segment,size,n,num,of,elements,num,elements,n,holes,total,size,holes
InPlaceMutableHashTable -> private String getMemoryConsumptionString();1517317681;@return String containing a summary of the memory consumption for error messages;private String getMemoryConsumptionString() {_		return "InPlaceMutableHashTable memory stats:\n" +_			"Total memory:     " + numAllMemorySegments * segmentSize + "\n" +_			"Free memory:      " + freeMemorySegments.size() * segmentSize + "\n" +_			"Bucket area:      " + numBuckets * 8  + "\n" +_			"Record area:      " + recordArea.getTotalSize() + "\n" +_			"Staging area:     " + stagingSegments.size() * segmentSize + "\n" +_			"Num of elements:  " + numElements + "\n" +_			"Holes total size: " + holes__	};return,string,containing,a,summary,of,the,memory,consumption,for,error,messages;private,string,get,memory,consumption,string,return,in,place,mutable,hash,table,memory,stats,n,total,memory,num,all,memory,segments,segment,size,n,free,memory,free,memory,segments,size,segment,size,n,bucket,area,num,buckets,8,n,record,area,record,area,get,total,size,n,staging,area,staging,segments,size,segment,size,n,num,of,elements,num,elements,n,holes,total,size,holes
InPlaceMutableHashTable -> private String getMemoryConsumptionString();1550567875;@return String containing a summary of the memory consumption for error messages;private String getMemoryConsumptionString() {_		return "InPlaceMutableHashTable memory stats:\n" +_			"Total memory:     " + numAllMemorySegments * segmentSize + "\n" +_			"Free memory:      " + freeMemorySegments.size() * segmentSize + "\n" +_			"Bucket area:      " + numBuckets * 8  + "\n" +_			"Record area:      " + recordArea.getTotalSize() + "\n" +_			"Staging area:     " + stagingSegments.size() * segmentSize + "\n" +_			"Num of elements:  " + numElements + "\n" +_			"Holes total size: " + holes__	};return,string,containing,a,summary,of,the,memory,consumption,for,error,messages;private,string,get,memory,consumption,string,return,in,place,mutable,hash,table,memory,stats,n,total,memory,num,all,memory,segments,segment,size,n,free,memory,free,memory,segments,size,segment,size,n,bucket,area,num,buckets,8,n,record,area,record,area,get,total,size,n,staging,area,staging,segments,size,segment,size,n,num,of,elements,num,elements,n,holes,total,size,holes
InPlaceMutableHashTable -> ReduceFacade -> public void emit() throws IOException;1468441547;Emits all elements currently held by the table to the collector.;public void emit() throws IOException {_			T record = buildSideSerializer.createInstance()__			EntryIterator iter = getEntryIterator()__			while ((record = iter.next(record)) != null && !closed) {_				outputCollector.collect(record)__				if (!objectReuseEnabled) {_					record = buildSideSerializer.createInstance()__				}_			}_		};emits,all,elements,currently,held,by,the,table,to,the,collector;public,void,emit,throws,ioexception,t,record,build,side,serializer,create,instance,entry,iterator,iter,get,entry,iterator,while,record,iter,next,record,null,closed,output,collector,collect,record,if,object,reuse,enabled,record,build,side,serializer,create,instance
InPlaceMutableHashTable -> ReduceFacade -> public void emit() throws IOException;1515177485;Emits all elements currently held by the table to the collector.;public void emit() throws IOException {_			T record = buildSideSerializer.createInstance()__			EntryIterator iter = getEntryIterator()__			while ((record = iter.next(record)) != null && !closed) {_				outputCollector.collect(record)__				if (!objectReuseEnabled) {_					record = buildSideSerializer.createInstance()__				}_			}_		};emits,all,elements,currently,held,by,the,table,to,the,collector;public,void,emit,throws,ioexception,t,record,build,side,serializer,create,instance,entry,iterator,iter,get,entry,iterator,while,record,iter,next,record,null,closed,output,collector,collect,record,if,object,reuse,enabled,record,build,side,serializer,create,instance
InPlaceMutableHashTable -> ReduceFacade -> public void emit() throws IOException;1517317681;Emits all elements currently held by the table to the collector.;public void emit() throws IOException {_			T record = buildSideSerializer.createInstance()__			EntryIterator iter = getEntryIterator()__			while ((record = iter.next(record)) != null && !closed) {_				outputCollector.collect(record)__				if (!objectReuseEnabled) {_					record = buildSideSerializer.createInstance()__				}_			}_		};emits,all,elements,currently,held,by,the,table,to,the,collector;public,void,emit,throws,ioexception,t,record,build,side,serializer,create,instance,entry,iterator,iter,get,entry,iterator,while,record,iter,next,record,null,closed,output,collector,collect,record,if,object,reuse,enabled,record,build,side,serializer,create,instance
InPlaceMutableHashTable -> ReduceFacade -> public void emit() throws IOException;1550567875;Emits all elements currently held by the table to the collector.;public void emit() throws IOException {_			T record = buildSideSerializer.createInstance()__			EntryIterator iter = getEntryIterator()__			while ((record = iter.next(record)) != null && !closed) {_				outputCollector.collect(record)__				if (!objectReuseEnabled) {_					record = buildSideSerializer.createInstance()__				}_			}_		};emits,all,elements,currently,held,by,the,table,to,the,collector;public,void,emit,throws,ioexception,t,record,build,side,serializer,create,instance,entry,iterator,iter,get,entry,iterator,while,record,iter,next,record,null,closed,output,collector,collect,record,if,object,reuse,enabled,record,build,side,serializer,create,instance
InPlaceMutableHashTable -> @Override 	public void open();1468441547;Initialize the hash table;@Override_	public void open() {_		open(calcInitialNumBucketSegments())__	};initialize,the,hash,table;override,public,void,open,open,calc,initial,num,bucket,segments
InPlaceMutableHashTable -> @Override 	public void open();1515177485;Initialize the hash table;@Override_	public void open() {_		open(calcInitialNumBucketSegments())__	};initialize,the,hash,table;override,public,void,open,open,calc,initial,num,bucket,segments
InPlaceMutableHashTable -> @Override 	public void open();1517317681;Initialize the hash table;@Override_	public void open() {_		open(calcInitialNumBucketSegments())__	};initialize,the,hash,table;override,public,void,open,open,calc,initial,num,bucket,segments
InPlaceMutableHashTable -> @Override 	public void open();1550567875;Initialize the hash table;@Override_	public void open() {_		open(calcInitialNumBucketSegments())__	};initialize,the,hash,table;override,public,void,open,open,calc,initial,num,bucket,segments
InPlaceMutableHashTable -> RecordArea -> public void resetAppendPosition();1468441547;Sets appendPosition and the write position to 0, so that appending starts_overwriting elements from the beginning. (This is used in rebuild.)__Note: if data was written to the area after the current appendPosition_before a call to resetAppendPosition, it should still be readable. To_release the segments after the current append position, call_freeSegmentsAfterAppendPosition();public void resetAppendPosition() {_			appendPosition = 0___			_			_			outView.currentSegmentIndex = -1__			outView.seekOutput(null, -1)__		};sets,append,position,and,the,write,position,to,0,so,that,appending,starts,overwriting,elements,from,the,beginning,this,is,used,in,rebuild,note,if,data,was,written,to,the,area,after,the,current,append,position,before,a,call,to,reset,append,position,it,should,still,be,readable,to,release,the,segments,after,the,current,append,position,call,free,segments,after,append,position;public,void,reset,append,position,append,position,0,out,view,current,segment,index,1,out,view,seek,output,null,1
InPlaceMutableHashTable -> RecordArea -> public void resetAppendPosition();1515177485;Sets appendPosition and the write position to 0, so that appending starts_overwriting elements from the beginning. (This is used in rebuild.)__Note: if data was written to the area after the current appendPosition_before a call to resetAppendPosition, it should still be readable. To_release the segments after the current append position, call_freeSegmentsAfterAppendPosition();public void resetAppendPosition() {_			appendPosition = 0___			_			_			outView.currentSegmentIndex = -1__			outView.seekOutput(null, -1)__		};sets,append,position,and,the,write,position,to,0,so,that,appending,starts,overwriting,elements,from,the,beginning,this,is,used,in,rebuild,note,if,data,was,written,to,the,area,after,the,current,append,position,before,a,call,to,reset,append,position,it,should,still,be,readable,to,release,the,segments,after,the,current,append,position,call,free,segments,after,append,position;public,void,reset,append,position,append,position,0,out,view,current,segment,index,1,out,view,seek,output,null,1
InPlaceMutableHashTable -> RecordArea -> public void resetAppendPosition();1517317681;Sets appendPosition and the write position to 0, so that appending starts_overwriting elements from the beginning. (This is used in rebuild.)__Note: if data was written to the area after the current appendPosition_before a call to resetAppendPosition, it should still be readable. To_release the segments after the current append position, call_freeSegmentsAfterAppendPosition();public void resetAppendPosition() {_			appendPosition = 0___			_			_			outView.currentSegmentIndex = -1__			outView.seekOutput(null, -1)__		};sets,append,position,and,the,write,position,to,0,so,that,appending,starts,overwriting,elements,from,the,beginning,this,is,used,in,rebuild,note,if,data,was,written,to,the,area,after,the,current,append,position,before,a,call,to,reset,append,position,it,should,still,be,readable,to,release,the,segments,after,the,current,append,position,call,free,segments,after,append,position;public,void,reset,append,position,append,position,0,out,view,current,segment,index,1,out,view,seek,output,null,1
InPlaceMutableHashTable -> RecordArea -> public void resetAppendPosition();1550567875;Sets appendPosition and the write position to 0, so that appending starts_overwriting elements from the beginning. (This is used in rebuild.)__Note: if data was written to the area after the current appendPosition_before a call to resetAppendPosition, it should still be readable. To_release the segments after the current append position, call_freeSegmentsAfterAppendPosition();public void resetAppendPosition() {_			appendPosition = 0___			_			_			outView.currentSegmentIndex = -1__			outView.seekOutput(null, -1)__		};sets,append,position,and,the,write,position,to,0,so,that,appending,starts,overwriting,elements,from,the,beginning,this,is,used,in,rebuild,note,if,data,was,written,to,the,area,after,the,current,append,position,before,a,call,to,reset,append,position,it,should,still,be,readable,to,release,the,segments,after,the,current,append,position,call,free,segments,after,append,position;public,void,reset,append,position,append,position,0,out,view,current,segment,index,1,out,view,seek,output,null,1
InPlaceMutableHashTable -> RecordArea -> public long appendPointerAndRecord(long pointer, T record) throws IOException;1468441547;Appends a pointer and a record._@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param record The record to write_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long appendPointerAndRecord(long pointer, T record) throws IOException {_			setWritePosition(appendPosition)__			return noSeekAppendPointerAndRecord(pointer, record)__		};appends,a,pointer,and,a,record,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,record,the,record,to,write,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,append,pointer,and,record,long,pointer,t,record,throws,ioexception,set,write,position,append,position,return,no,seek,append,pointer,and,record,pointer,record
InPlaceMutableHashTable -> RecordArea -> public long appendPointerAndRecord(long pointer, T record) throws IOException;1515177485;Appends a pointer and a record._@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param record The record to write_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long appendPointerAndRecord(long pointer, T record) throws IOException {_			setWritePosition(appendPosition)__			return noSeekAppendPointerAndRecord(pointer, record)__		};appends,a,pointer,and,a,record,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,record,the,record,to,write,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,append,pointer,and,record,long,pointer,t,record,throws,ioexception,set,write,position,append,position,return,no,seek,append,pointer,and,record,pointer,record
InPlaceMutableHashTable -> RecordArea -> public long appendPointerAndRecord(long pointer, T record) throws IOException;1517317681;Appends a pointer and a record._@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param record The record to write_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long appendPointerAndRecord(long pointer, T record) throws IOException {_			setWritePosition(appendPosition)__			return noSeekAppendPointerAndRecord(pointer, record)__		};appends,a,pointer,and,a,record,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,record,the,record,to,write,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,append,pointer,and,record,long,pointer,t,record,throws,ioexception,set,write,position,append,position,return,no,seek,append,pointer,and,record,pointer,record
InPlaceMutableHashTable -> RecordArea -> public long appendPointerAndRecord(long pointer, T record) throws IOException;1550567875;Appends a pointer and a record._@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param record The record to write_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long appendPointerAndRecord(long pointer, T record) throws IOException {_			setWritePosition(appendPosition)__			return noSeekAppendPointerAndRecord(pointer, record)__		};appends,a,pointer,and,a,record,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,record,the,record,to,write,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,append,pointer,and,record,long,pointer,t,record,throws,ioexception,set,write,position,append,position,return,no,seek,append,pointer,and,record,pointer,record
InPlaceMutableHashTable -> RecordArea -> public long noSeekAppendPointerAndRecord(long pointer, T record) throws IOException;1468441547;Appends a pointer and a record. Call this function only if the write position is at the end!_@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param record The record to write_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long noSeekAppendPointerAndRecord(long pointer, T record) throws IOException {_			final long oldLastPosition = appendPosition__			final long oldPositionInSegment = outView.getCurrentPositionInSegment()__			final long oldSegmentIndex = outView.currentSegmentIndex__			outView.writeLong(pointer)__			buildSideSerializer.serialize(record, outView)__			appendPosition += outView.getCurrentPositionInSegment() - oldPositionInSegment +_				outView.getSegmentSize() * (outView.currentSegmentIndex - oldSegmentIndex)__			return oldLastPosition__		};appends,a,pointer,and,a,record,call,this,function,only,if,the,write,position,is,at,the,end,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,record,the,record,to,write,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,no,seek,append,pointer,and,record,long,pointer,t,record,throws,ioexception,final,long,old,last,position,append,position,final,long,old,position,in,segment,out,view,get,current,position,in,segment,final,long,old,segment,index,out,view,current,segment,index,out,view,write,long,pointer,build,side,serializer,serialize,record,out,view,append,position,out,view,get,current,position,in,segment,old,position,in,segment,out,view,get,segment,size,out,view,current,segment,index,old,segment,index,return,old,last,position
InPlaceMutableHashTable -> RecordArea -> public long noSeekAppendPointerAndRecord(long pointer, T record) throws IOException;1515177485;Appends a pointer and a record. Call this function only if the write position is at the end!_@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param record The record to write_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long noSeekAppendPointerAndRecord(long pointer, T record) throws IOException {_			final long oldLastPosition = appendPosition__			final long oldPositionInSegment = outView.getCurrentPositionInSegment()__			final long oldSegmentIndex = outView.currentSegmentIndex__			outView.writeLong(pointer)__			buildSideSerializer.serialize(record, outView)__			appendPosition += outView.getCurrentPositionInSegment() - oldPositionInSegment +_				outView.getSegmentSize() * (outView.currentSegmentIndex - oldSegmentIndex)__			return oldLastPosition__		};appends,a,pointer,and,a,record,call,this,function,only,if,the,write,position,is,at,the,end,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,record,the,record,to,write,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,no,seek,append,pointer,and,record,long,pointer,t,record,throws,ioexception,final,long,old,last,position,append,position,final,long,old,position,in,segment,out,view,get,current,position,in,segment,final,long,old,segment,index,out,view,current,segment,index,out,view,write,long,pointer,build,side,serializer,serialize,record,out,view,append,position,out,view,get,current,position,in,segment,old,position,in,segment,out,view,get,segment,size,out,view,current,segment,index,old,segment,index,return,old,last,position
InPlaceMutableHashTable -> RecordArea -> public long noSeekAppendPointerAndRecord(long pointer, T record) throws IOException;1517317681;Appends a pointer and a record. Call this function only if the write position is at the end!_@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param record The record to write_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long noSeekAppendPointerAndRecord(long pointer, T record) throws IOException {_			final long oldLastPosition = appendPosition__			final long oldPositionInSegment = outView.getCurrentPositionInSegment()__			final long oldSegmentIndex = outView.currentSegmentIndex__			outView.writeLong(pointer)__			buildSideSerializer.serialize(record, outView)__			appendPosition += outView.getCurrentPositionInSegment() - oldPositionInSegment +_				outView.getSegmentSize() * (outView.currentSegmentIndex - oldSegmentIndex)__			return oldLastPosition__		};appends,a,pointer,and,a,record,call,this,function,only,if,the,write,position,is,at,the,end,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,record,the,record,to,write,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,no,seek,append,pointer,and,record,long,pointer,t,record,throws,ioexception,final,long,old,last,position,append,position,final,long,old,position,in,segment,out,view,get,current,position,in,segment,final,long,old,segment,index,out,view,current,segment,index,out,view,write,long,pointer,build,side,serializer,serialize,record,out,view,append,position,out,view,get,current,position,in,segment,old,position,in,segment,out,view,get,segment,size,out,view,current,segment,index,old,segment,index,return,old,last,position
InPlaceMutableHashTable -> RecordArea -> public long noSeekAppendPointerAndRecord(long pointer, T record) throws IOException;1550567875;Appends a pointer and a record. Call this function only if the write position is at the end!_@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param record The record to write_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long noSeekAppendPointerAndRecord(long pointer, T record) throws IOException {_			final long oldLastPosition = appendPosition__			final long oldPositionInSegment = outView.getCurrentPositionInSegment()__			final long oldSegmentIndex = outView.currentSegmentIndex__			outView.writeLong(pointer)__			buildSideSerializer.serialize(record, outView)__			appendPosition += outView.getCurrentPositionInSegment() - oldPositionInSegment +_				outView.getSegmentSize() * (outView.currentSegmentIndex - oldSegmentIndex)__			return oldLastPosition__		};appends,a,pointer,and,a,record,call,this,function,only,if,the,write,position,is,at,the,end,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,record,the,record,to,write,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,no,seek,append,pointer,and,record,long,pointer,t,record,throws,ioexception,final,long,old,last,position,append,position,final,long,old,position,in,segment,out,view,get,current,position,in,segment,final,long,old,segment,index,out,view,current,segment,index,out,view,write,long,pointer,build,side,serializer,serialize,record,out,view,append,position,out,view,get,current,position,in,segment,old,position,in,segment,out,view,get,segment,size,out,view,current,segment,index,old,segment,index,return,old,last,position
InPlaceMutableHashTable -> RecordArea -> public long appendPointerAndCopyRecord(long pointer, DataInputView input, int recordSize) throws IOException;1468441547;Appends a pointer and a record. The record is read from a DataInputView (this will be the staging area)._@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param input The DataInputView to read the record from_@param recordSize The size of the record_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long appendPointerAndCopyRecord(long pointer, DataInputView input, int recordSize) throws IOException {_			setWritePosition(appendPosition)__			final long oldLastPosition = appendPosition__			outView.writeLong(pointer)__			outView.write(input, recordSize)__			appendPosition += 8 + recordSize__			return oldLastPosition__		};appends,a,pointer,and,a,record,the,record,is,read,from,a,data,input,view,this,will,be,the,staging,area,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,input,the,data,input,view,to,read,the,record,from,param,record,size,the,size,of,the,record,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,append,pointer,and,copy,record,long,pointer,data,input,view,input,int,record,size,throws,ioexception,set,write,position,append,position,final,long,old,last,position,append,position,out,view,write,long,pointer,out,view,write,input,record,size,append,position,8,record,size,return,old,last,position
InPlaceMutableHashTable -> RecordArea -> public long appendPointerAndCopyRecord(long pointer, DataInputView input, int recordSize) throws IOException;1515177485;Appends a pointer and a record. The record is read from a DataInputView (this will be the staging area)._@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param input The DataInputView to read the record from_@param recordSize The size of the record_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long appendPointerAndCopyRecord(long pointer, DataInputView input, int recordSize) throws IOException {_			setWritePosition(appendPosition)__			final long oldLastPosition = appendPosition__			outView.writeLong(pointer)__			outView.write(input, recordSize)__			appendPosition += 8 + recordSize__			return oldLastPosition__		};appends,a,pointer,and,a,record,the,record,is,read,from,a,data,input,view,this,will,be,the,staging,area,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,input,the,data,input,view,to,read,the,record,from,param,record,size,the,size,of,the,record,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,append,pointer,and,copy,record,long,pointer,data,input,view,input,int,record,size,throws,ioexception,set,write,position,append,position,final,long,old,last,position,append,position,out,view,write,long,pointer,out,view,write,input,record,size,append,position,8,record,size,return,old,last,position
InPlaceMutableHashTable -> RecordArea -> public long appendPointerAndCopyRecord(long pointer, DataInputView input, int recordSize) throws IOException;1517317681;Appends a pointer and a record. The record is read from a DataInputView (this will be the staging area)._@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param input The DataInputView to read the record from_@param recordSize The size of the record_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long appendPointerAndCopyRecord(long pointer, DataInputView input, int recordSize) throws IOException {_			setWritePosition(appendPosition)__			final long oldLastPosition = appendPosition__			outView.writeLong(pointer)__			outView.write(input, recordSize)__			appendPosition += 8 + recordSize__			return oldLastPosition__		};appends,a,pointer,and,a,record,the,record,is,read,from,a,data,input,view,this,will,be,the,staging,area,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,input,the,data,input,view,to,read,the,record,from,param,record,size,the,size,of,the,record,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,append,pointer,and,copy,record,long,pointer,data,input,view,input,int,record,size,throws,ioexception,set,write,position,append,position,final,long,old,last,position,append,position,out,view,write,long,pointer,out,view,write,input,record,size,append,position,8,record,size,return,old,last,position
InPlaceMutableHashTable -> RecordArea -> public long appendPointerAndCopyRecord(long pointer, DataInputView input, int recordSize) throws IOException;1550567875;Appends a pointer and a record. The record is read from a DataInputView (this will be the staging area)._@param pointer The pointer to write (Note: this is NOT the position to write to!)_@param input The DataInputView to read the record from_@param recordSize The size of the record_@return A pointer to the written data_@throws IOException (EOFException specifically, if memory ran out);public long appendPointerAndCopyRecord(long pointer, DataInputView input, int recordSize) throws IOException {_			setWritePosition(appendPosition)__			final long oldLastPosition = appendPosition__			outView.writeLong(pointer)__			outView.write(input, recordSize)__			appendPosition += 8 + recordSize__			return oldLastPosition__		};appends,a,pointer,and,a,record,the,record,is,read,from,a,data,input,view,this,will,be,the,staging,area,param,pointer,the,pointer,to,write,note,this,is,not,the,position,to,write,to,param,input,the,data,input,view,to,read,the,record,from,param,record,size,the,size,of,the,record,return,a,pointer,to,the,written,data,throws,ioexception,eofexception,specifically,if,memory,ran,out;public,long,append,pointer,and,copy,record,long,pointer,data,input,view,input,int,record,size,throws,ioexception,set,write,position,append,position,final,long,old,last,position,append,position,out,view,write,long,pointer,out,view,write,input,record,size,append,position,8,record,size,return,old,last,position
