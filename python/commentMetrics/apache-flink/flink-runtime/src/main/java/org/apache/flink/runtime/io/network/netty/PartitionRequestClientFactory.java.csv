commented;modifiers;parameterAmount;loc;comment;code
true;;1;54;/**  * Atomically establishes a TCP connection to the given remote address and  * creates a {@link PartitionRequestClient} instance for this connection.  */ ;/**  * Atomically establishes a TCP connection to the given remote address and  * creates a {@link PartitionRequestClient} instance for this connection.  */ PartitionRequestClient createPartitionRequestClient(ConnectionID connectionId) throws IOException, InterruptedException {     Object entry.     PartitionRequestClient client = null.     while (client == null) {         entry = clients.get(connectionId).         if (entry != null) {             // Existing channel or connecting channel             if (entry instanceof PartitionRequestClient) {                 client = (PartitionRequestClient) entry.             } else {                 ConnectingChannel future = (ConnectingChannel) entry.                 client = future.waitForChannel().                 clients.replace(connectionId, future, client).             }         } else {             // No channel yet. Create one, but watch out for a race.             // We create a "connecting future" and atomically add it to the map.             // Only the thread that really added it establishes the channel.             // The others need to wait on that original establisher's future.             ConnectingChannel connectingChannel = new ConnectingChannel(connectionId, this).             Object old = clients.putIfAbsent(connectionId, connectingChannel).             if (old == null) {                 nettyClient.connect(connectionId.getAddress()).addListener(connectingChannel).                 client = connectingChannel.waitForChannel().                 clients.replace(connectionId, connectingChannel, client).             } else if (old instanceof ConnectingChannel) {                 client = ((ConnectingChannel) old).waitForChannel().                 clients.replace(connectionId, old, client).             } else {                 client = (PartitionRequestClient) old.             }         }         // out to ensure correct bookkeeping for channel closing.         if (!client.incrementReferenceCounter()) {             destroyPartitionRequestClient(connectionId, client).             client = null.         }     }     return client. }
false;public;1;11;;public void closeOpenChannelConnections(ConnectionID connectionId) {     Object entry = clients.get(connectionId).     if (entry instanceof ConnectingChannel) {         ConnectingChannel channel = (ConnectingChannel) entry.         if (channel.dispose()) {             clients.remove(connectionId, channel).         }     } }
false;;0;3;;int getNumberOfActiveClients() {     return clients.size(). }
true;;2;3;/**  * Removes the client for the given {@link ConnectionID}.  */ ;/**  * Removes the client for the given {@link ConnectionID}.  */ void destroyPartitionRequestClient(ConnectionID connectionId, PartitionRequestClient client) {     clients.remove(connectionId, client). }
false;private;0;16;;private boolean dispose() {     boolean result.     synchronized (connectLock) {         if (partitionRequestClient != null) {             result = partitionRequestClient.disposeIfNotUsed().         } else {             disposeRequestClient = true.             result = true.         }         connectLock.notifyAll().     }     return result. }
false;private;1;18;;private void handInChannel(Channel channel) {     synchronized (connectLock) {         try {             NetworkClientHandler clientHandler = channel.pipeline().get(NetworkClientHandler.class).             partitionRequestClient = new PartitionRequestClient(channel, clientHandler, connectionId, clientFactory).             if (disposeRequestClient) {                 partitionRequestClient.disposeIfNotUsed().             }             connectLock.notifyAll().         } catch (Throwable t) {             notifyOfError(t).         }     } }
false;private;0;13;;private PartitionRequestClient waitForChannel() throws IOException, InterruptedException {     synchronized (connectLock) {         while (error == null && partitionRequestClient == null) {             connectLock.wait(2000).         }     }     if (error != null) {         throw new IOException("Connecting the channel failed: " + error.getMessage(), error).     }     return partitionRequestClient. }
false;private;1;6;;private void notifyOfError(Throwable error) {     synchronized (connectLock) {         this.error = error.         connectLock.notifyAll().     } }
false;public;1;20;;@Override public void operationComplete(ChannelFuture future) throws Exception {     if (future.isSuccess()) {         handInChannel(future.channel()).     } else if (future.cause() != null) {         notifyOfError(new RemoteTransportException("Connecting to remote task manager + '" + connectionId.getAddress() + "' has failed. This might indicate that the remote task " + "manager has been lost.", connectionId.getAddress(), future.cause())).     } else {         notifyOfError(new LocalTransportException(String.format("Connecting to remote task manager '%s' has been cancelled.", connectionId.getAddress()), null)).     } }
