commented;modifiers;parameterAmount;loc;comment;code
true;;0;3;/**  * Returns whether the checkpoint should be forced.  *  * <p>Forced checkpoints ignore the configured maximum number of concurrent  * checkpoints and minimum time between checkpoints. Furthermore, they are  * not subsumed by more recent checkpoints as long as they are pending.  *  * @return <code>true</code> if the checkpoint should be forced.  * <code>false</code> otherwise.  *  * @see CheckpointCoordinator  * @see PendingCheckpoint  */ ;// ------------------------------------------------------------------------ /**  * Returns whether the checkpoint should be forced.  *  * <p>Forced checkpoints ignore the configured maximum number of concurrent  * checkpoints and minimum time between checkpoints. Furthermore, they are  * not subsumed by more recent checkpoints as long as they are pending.  *  * @return <code>true</code> if the checkpoint should be forced.  * <code>false</code> otherwise.  *  * @see CheckpointCoordinator  * @see PendingCheckpoint  */ boolean forceCheckpoint() {     return forced. }
true;;0;3;/**  * Returns whether the checkpoint should be discarded when it is subsumed.  *  * <p>A checkpoint is subsumed when the maximum number of retained  * checkpoints is reached and a more recent checkpoint completes..  *  * @return <code>true</code> if the checkpoint should be discarded when it  * is subsumed. <code>false</code> otherwise.  *  * @see CompletedCheckpointStore  */ ;// ------------------------------------------------------------------------ // Garbage collection behaviour // ------------------------------------------------------------------------ /**  * Returns whether the checkpoint should be discarded when it is subsumed.  *  * <p>A checkpoint is subsumed when the maximum number of retained  * checkpoints is reached and a more recent checkpoint completes..  *  * @return <code>true</code> if the checkpoint should be discarded when it  * is subsumed. <code>false</code> otherwise.  *  * @see CompletedCheckpointStore  */ boolean discardOnSubsumed() {     return discardSubsumed. }
true;;0;3;/**  * Returns whether the checkpoint should be discarded when the owning job  * reaches the {@link JobStatus#FINISHED} state.  *  * @return <code>true</code> if the checkpoint should be discarded when the  * owning job reaches the {@link JobStatus#FINISHED} state. <code>false</code>  * otherwise.  *  * @see CompletedCheckpointStore  */ ;/**  * Returns whether the checkpoint should be discarded when the owning job  * reaches the {@link JobStatus#FINISHED} state.  *  * @return <code>true</code> if the checkpoint should be discarded when the  * owning job reaches the {@link JobStatus#FINISHED} state. <code>false</code>  * otherwise.  *  * @see CompletedCheckpointStore  */ boolean discardOnJobFinished() {     return discardFinished. }
true;;0;3;/**  * Returns whether the checkpoint should be discarded when the owning job  * reaches the {@link JobStatus#CANCELED} state.  *  * @return <code>true</code> if the checkpoint should be discarded when the  * owning job reaches the {@link JobStatus#CANCELED} state. <code>false</code>  * otherwise.  *  * @see CompletedCheckpointStore  */ ;/**  * Returns whether the checkpoint should be discarded when the owning job  * reaches the {@link JobStatus#CANCELED} state.  *  * @return <code>true</code> if the checkpoint should be discarded when the  * owning job reaches the {@link JobStatus#CANCELED} state. <code>false</code>  * otherwise.  *  * @see CompletedCheckpointStore  */ boolean discardOnJobCancelled() {     return discardCancelled. }
true;;0;3;/**  * Returns whether the checkpoint should be discarded when the owning job  * reaches the {@link JobStatus#FAILED} state.  *  * @return <code>true</code> if the checkpoint should be discarded when the  * owning job reaches the {@link JobStatus#FAILED} state. <code>false</code>  * otherwise.  *  * @see CompletedCheckpointStore  */ ;/**  * Returns whether the checkpoint should be discarded when the owning job  * reaches the {@link JobStatus#FAILED} state.  *  * @return <code>true</code> if the checkpoint should be discarded when the  * owning job reaches the {@link JobStatus#FAILED} state. <code>false</code>  * otherwise.  *  * @see CompletedCheckpointStore  */ boolean discardOnJobFailed() {     return discardFailed. }
true;;0;3;/**  * Returns whether the checkpoint should be discarded when the owning job  * reaches the {@link JobStatus#SUSPENDED} state.  *  * @return <code>true</code> if the checkpoint should be discarded when the  * owning job reaches the {@link JobStatus#SUSPENDED} state. <code>false</code>  * otherwise.  *  * @see CompletedCheckpointStore  */ ;/**  * Returns whether the checkpoint should be discarded when the owning job  * reaches the {@link JobStatus#SUSPENDED} state.  *  * @return <code>true</code> if the checkpoint should be discarded when the  * owning job reaches the {@link JobStatus#SUSPENDED} state. <code>false</code>  * otherwise.  *  * @see CompletedCheckpointStore  */ boolean discardOnJobSuspended() {     return discardSuspended. }
true;public;0;3;/**  * Gets the type of the checkpoint (checkpoint / savepoint).  */ ;/**  * Gets the type of the checkpoint (checkpoint / savepoint).  */ public CheckpointType getCheckpointType() {     return checkpointType. }
true;public;0;3;/**  * Returns whether the checkpoint properties describe a standard savepoint.  *  * @return <code>true</code> if the properties describe a savepoint, <code>false</code> otherwise.  */ ;/**  * Returns whether the checkpoint properties describe a standard savepoint.  *  * @return <code>true</code> if the properties describe a savepoint, <code>false</code> otherwise.  */ public boolean isSavepoint() {     return checkpointType == CheckpointType.SAVEPOINT. }
false;public;1;19;;// ------------------------------------------------------------------------ @Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     CheckpointProperties that = (CheckpointProperties) o.     return forced == that.forced && checkpointType == that.checkpointType && discardSubsumed == that.discardSubsumed && discardFinished == that.discardFinished && discardCancelled == that.discardCancelled && discardFailed == that.discardFailed && discardSuspended == that.discardSuspended. }
false;public;0;11;;@Override public int hashCode() {     int result = (forced ? 1 : 0).     result = 31 * result + checkpointType.hashCode().     result = 31 * result + (discardSubsumed ? 1 : 0).     result = 31 * result + (discardFinished ? 1 : 0).     result = 31 * result + (discardCancelled ? 1 : 0).     result = 31 * result + (discardFailed ? 1 : 0).     result = 31 * result + (discardSuspended ? 1 : 0).     return result. }
false;public;0;12;;@Override public String toString() {     return "CheckpointProperties{" + "forced=" + forced + ", checkpointType=" + checkpointType + ", discardSubsumed=" + discardSubsumed + ", discardFinished=" + discardFinished + ", discardCancelled=" + discardCancelled + ", discardFailed=" + discardFailed + ", discardSuspended=" + discardSuspended + '}'. }
true;public,static;0;3;/**  * Creates the checkpoint properties for a (manually triggered) savepoint.  *  * <p>Savepoints are not queued due to time trigger limits. They have to be  * garbage collected manually.  *  * @return Checkpoint properties for a (manually triggered) savepoint.  */ ;/**  * Creates the checkpoint properties for a (manually triggered) savepoint.  *  * <p>Savepoints are not queued due to time trigger limits. They have to be  * garbage collected manually.  *  * @return Checkpoint properties for a (manually triggered) savepoint.  */ public static CheckpointProperties forSavepoint() {     return SAVEPOINT. }
true;public,static;1;12;/**  * Creates the checkpoint properties for a checkpoint.  *  * <p>Checkpoints may be queued in case too many other checkpoints are currently happening.  * They are garbage collected automatically, except when the owning job  * terminates in state {@link JobStatus#FAILED}. The user is required to  * configure the clean up behaviour on job cancellation.  *  * @return Checkpoint properties for an external checkpoint.  */ ;/**  * Creates the checkpoint properties for a checkpoint.  *  * <p>Checkpoints may be queued in case too many other checkpoints are currently happening.  * They are garbage collected automatically, except when the owning job  * terminates in state {@link JobStatus#FAILED}. The user is required to  * configure the clean up behaviour on job cancellation.  *  * @return Checkpoint properties for an external checkpoint.  */ public static CheckpointProperties forCheckpoint(CheckpointRetentionPolicy policy) {     switch(policy) {         case NEVER_RETAIN_AFTER_TERMINATION:             return CHECKPOINT_NEVER_RETAINED.         case RETAIN_ON_FAILURE:             return CHECKPOINT_RETAINED_ON_FAILURE.         case RETAIN_ON_CANCELLATION:             return CHECKPOINT_RETAINED_ON_CANCELLATION.         default:             throw new IllegalArgumentException("unknown policy: " + policy).     } }
