commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override public String getMethodName() throws IOException, ClassNotFoundException {     deserializeMethodInvocation().     return methodInvocation.getMethodName(). }
false;public;0;6;;@Override public Class<?>[] getParameterTypes() throws IOException, ClassNotFoundException {     deserializeMethodInvocation().     return methodInvocation.getParameterTypes(). }
false;public;0;6;;@Override public Object[] getArgs() throws IOException, ClassNotFoundException {     deserializeMethodInvocation().     return methodInvocation.getArgs(). }
false;public;0;28;;@Override public String toString() {     if (toString == null) {         try {             Class<?>[] parameterTypes = getParameterTypes().             String methodName = getMethodName().             StringBuilder paramTypeStringBuilder = new StringBuilder(parameterTypes.length * 5).             if (parameterTypes.length > 0) {                 paramTypeStringBuilder.append(parameterTypes[0].getSimpleName()).                 for (int i = 1. i < parameterTypes.length. i++) {                     paramTypeStringBuilder.append(", ").append(parameterTypes[i].getSimpleName()).                 }             }             toString = "RemoteRpcInvocation(" + methodName + '(' + paramTypeStringBuilder + "))".         } catch (IOException | ClassNotFoundException e) {             toString = "Could not deserialize RemoteRpcInvocation: " + e.getMessage().         }     }     return toString. }
true;public;0;3;/**  * Size (#bytes of the serialized data) of the rpc invocation message.  *  * @return Size of the remote rpc invocation message  */ ;/**  * Size (#bytes of the serialized data) of the rpc invocation message.  *  * @return Size of the remote rpc invocation message  */ public long getSize() {     return serializedMethodInvocation.getByteArray().length. }
false;private;0;5;;private void deserializeMethodInvocation() throws IOException, ClassNotFoundException {     if (methodInvocation == null) {         methodInvocation = serializedMethodInvocation.deserializeValue(ClassLoader.getSystemClassLoader()).     } }
false;private;1;3;;// ------------------------------------------------------------------- // Serialization methods // ------------------------------------------------------------------- private void writeObject(ObjectOutputStream oos) throws IOException {     oos.writeObject(serializedMethodInvocation). }
false;private;1;5;;@SuppressWarnings("unchecked") private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {     serializedMethodInvocation = (SerializedValue<RemoteRpcInvocation.MethodInvocation>) ois.readObject().     methodInvocation = null. }
false;;0;3;;String getMethodName() {     return methodName. }
false;;0;3;;Class<?>[] getParameterTypes() {     return parameterTypes. }
false;;0;3;;Object[] getArgs() {     return args. }
false;private;1;26;;private void writeObject(ObjectOutputStream oos) throws IOException {     oos.writeUTF(methodName).     oos.writeInt(parameterTypes.length).     for (Class<?> parameterType : parameterTypes) {         oos.writeObject(parameterType).     }     if (args != null) {         oos.writeBoolean(true).         for (int i = 0. i < args.length. i++) {             try {                 oos.writeObject(args[i]).             } catch (IOException e) {                 throw new IOException("Could not serialize " + i + "th argument of method " + methodName + ". This indicates that the argument type " + args.getClass().getName() + " is not serializable. Arguments have to " + "be serializable for remote rpc calls.", e).             }         }     } else {         oos.writeBoolean(false).     } }
false;private;1;53;;private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {     methodName = ois.readUTF().     int length = ois.readInt().     parameterTypes = new Class<?>[length].     for (int i = 0. i < length. i++) {         try {             parameterTypes[i] = (Class<?>) ois.readObject().         } catch (IOException e) {             StringBuilder incompleteMethod = getIncompleteMethodString(i, 0).             throw new IOException("Could not deserialize " + i + "th parameter type of method " + incompleteMethod + '.', e).         } catch (ClassNotFoundException e) {             // note: wrapping this CNFE into another CNFE does not overwrite the Exception             // stored in the ObjectInputStream (see ObjectInputStream#readSerialData)             // -> add a suppressed exception that adds a more specific message             StringBuilder incompleteMethod = getIncompleteMethodString(i, 0).             e.addSuppressed(new ClassNotFoundException("Could not deserialize " + i + "th " + "parameter type of method " + incompleteMethod + ". This indicates that the parameter " + "type is not part of the system class loader.")).             throw e.         }     }     boolean hasArgs = ois.readBoolean().     if (hasArgs) {         args = new Object[length].         for (int i = 0. i < length. i++) {             try {                 args[i] = ois.readObject().             } catch (IOException e) {                 StringBuilder incompleteMethod = getIncompleteMethodString(length, i).                 throw new IOException("Could not deserialize " + i + "th argument of method " + incompleteMethod + '.', e).             } catch (ClassNotFoundException e) {                 // note: wrapping this CNFE into another CNFE does not overwrite the Exception                 // stored in the ObjectInputStream (see ObjectInputStream#readSerialData)                 // -> add a suppressed exception that adds a more specific message                 StringBuilder incompleteMethod = getIncompleteMethodString(length, i).                 e.addSuppressed(new ClassNotFoundException("Could not deserialize " + i + "th " + "argument of method " + incompleteMethod + ". This indicates that the argument " + "type is not part of the system class loader.")).                 throw e.             }         }     } else {         args = null.     } }
false;private;2;13;;private StringBuilder getIncompleteMethodString(int lastMethodTypeIdx, int lastArgumentIdx) {     StringBuilder incompleteMethod = new StringBuilder().     incompleteMethod.append(methodName).append('(').     for (int i = 0. i < lastMethodTypeIdx. ++i) {         incompleteMethod.append(parameterTypes[i].getCanonicalName()).         if (i < lastArgumentIdx) {             incompleteMethod.append(": ").append(args[i]).         }         incompleteMethod.append(", ").     }     // some parameters could not be deserialized     incompleteMethod.append("...)").     return incompleteMethod. }
