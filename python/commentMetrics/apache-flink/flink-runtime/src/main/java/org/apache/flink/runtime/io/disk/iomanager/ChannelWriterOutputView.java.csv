commented;modifiers;parameterAmount;loc;comment;code
true;public;0;23;/**  * Closes this OutputView, closing the underlying writer and returning all memory segments.  *  * @return A list containing all memory segments originally supplied to this view.  * @throws IOException Thrown, if the underlying writer could not be properly closed.  */ ;// -------------------------------------------------------------------------------------------- /**  * Closes this OutputView, closing the underlying writer and returning all memory segments.  *  * @return A list containing all memory segments originally supplied to this view.  * @throws IOException Thrown, if the underlying writer could not be properly closed.  */ public List<MemorySegment> close() throws IOException {     // send off set last segment     writeSegment(getCurrentSegment(), getCurrentPositionInSegment(), true).     clear().     // close the writer and gather all segments     final LinkedBlockingQueue<MemorySegment> queue = this.writer.getReturnQueue().     this.writer.close().     // re-collect all memory segments     ArrayList<MemorySegment> list = new ArrayList<MemorySegment>(this.numSegments).     for (int i = 0. i < this.numSegments. i++) {         final MemorySegment m = queue.poll().         if (m == null) {             // we get null if the queue is empty. that should not be the case if the reader was properly closed.             throw new RuntimeException("ChannelWriterOutputView: MemorySegments have been taken from return queue by different actor.").         }         list.add(m).     }     return list. }
true;public;0;4;/**  * Gets the number of blocks used by this view.  *  * @return The number of blocks used.  */ ;// -------------------------------------------------------------------------------------------- /**  * Gets the number of blocks used by this view.  *  * @return The number of blocks used.  */ public int getBlockCount() {     return this.blockCount. }
true;public;0;4;/**  * Gets the number of pay-load bytes already written. This excludes the number of bytes spent on headers  * in the segments.  *  * @return The number of bytes that have been written to this output view.  */ ;/**  * Gets the number of pay-load bytes already written. This excludes the number of bytes spent on headers  * in the segments.  *  * @return The number of bytes that have been written to this output view.  */ public long getBytesWritten() {     return this.bytesBeforeSegment + getCurrentPositionInSegment() - HEADER_LENGTH. }
true;public;0;4;/**  * Gets the number of bytes used by this output view, including written bytes and header bytes.  *  * @return The number of bytes that have been written to this output view.  */ ;/**  * Gets the number of bytes used by this output view, including written bytes and header bytes.  *  * @return The number of bytes that have been written to this output view.  */ public long getBytesMemoryUsed() {     return (this.blockCount - 1) * getSegmentSize() + getCurrentPositionInSegment(). }
false;protected,final;2;10;;// -------------------------------------------------------------------------------------------- // Page Management // -------------------------------------------------------------------------------------------- protected final MemorySegment nextSegment(MemorySegment current, int posInSegment) throws IOException {     if (current != null) {         writeSegment(current, posInSegment, false).     }     final MemorySegment next = this.writer.getNextReturnedBlock().     this.blockCount++.     return next. }
false;private;3;9;;private void writeSegment(MemorySegment segment, int writePosition, boolean lastSegment) throws IOException {     segment.putShort(0, HEADER_MAGIC_NUMBER).     segment.putShort(HEADER_FLAGS_OFFSET, lastSegment ? FLAG_LAST_BLOCK : 0).     segment.putInt(HEAD_BLOCK_LENGTH_OFFSET, writePosition).     this.writer.writeBlock(segment).     this.bytesBeforeSegment += writePosition - HEADER_LENGTH. }
