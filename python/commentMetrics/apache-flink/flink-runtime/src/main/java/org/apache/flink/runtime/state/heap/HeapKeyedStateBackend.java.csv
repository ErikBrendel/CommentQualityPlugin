commented;modifiers;parameterAmount;loc;comment;code
false;public;2;32;;// ------------------------------------------------------------------------ // state backend operations // ------------------------------------------------------------------------ @SuppressWarnings("unchecked") @Nonnull @Override public <T extends HeapPriorityQueueElement & PriorityComparable & Keyed> KeyGroupedInternalPriorityQueue<T> create(@Nonnull String stateName, @Nonnull TypeSerializer<T> byteOrderedElementSerializer) {     final HeapPriorityQueueSnapshotRestoreWrapper existingState = registeredPQStates.get(stateName).     if (existingState != null) {         // TODO we implement the simple way of supporting the current functionality, mimicking keyed state         // because this should be reworked in FLINK-9376 and then we should have a common algorithm over         // StateMetaInfoSnapshot that avoids this code duplication.         TypeSerializerSchemaCompatibility<T> compatibilityResult = existingState.getMetaInfo().updateElementSerializer(byteOrderedElementSerializer).         if (compatibilityResult.isIncompatible()) {             throw new FlinkRuntimeException(new StateMigrationException("For heap backends, the new priority queue serializer must not be incompatible.")).         } else {             registeredPQStates.put(stateName, existingState.forUpdatedSerializer(byteOrderedElementSerializer)).         }         return existingState.getPriorityQueue().     } else {         final RegisteredPriorityQueueStateBackendMetaInfo<T> metaInfo = new RegisteredPriorityQueueStateBackendMetaInfo<>(stateName, byteOrderedElementSerializer).         return createInternal(metaInfo).     } }
false;private;1;20;;@Nonnull private <T extends HeapPriorityQueueElement & PriorityComparable & Keyed> KeyGroupedInternalPriorityQueue<T> createInternal(RegisteredPriorityQueueStateBackendMetaInfo<T> metaInfo) {     final String stateName = metaInfo.getName().     final HeapPriorityQueueSet<T> priorityQueue = priorityQueueSetFactory.create(stateName, metaInfo.getElementSerializer()).     HeapPriorityQueueSnapshotRestoreWrapper<T> wrapper = new HeapPriorityQueueSnapshotRestoreWrapper<>(priorityQueue, metaInfo, KeyExtractorFunction.forKeyedObjects(), keyGroupRange, numberOfKeyGroups).     registeredPQStates.put(stateName, wrapper).     return priorityQueue. }
false;private;3;45;;private <N, V> StateTable<K, N, V> tryRegisterStateTable(TypeSerializer<N> namespaceSerializer, StateDescriptor<?, V> stateDesc, @Nonnull StateSnapshotTransformFactory<V> snapshotTransformFactory) throws StateMigrationException {     @SuppressWarnings("unchecked")     StateTable<K, N, V> stateTable = (StateTable<K, N, V>) registeredKVStates.get(stateDesc.getName()).     TypeSerializer<V> newStateSerializer = stateDesc.getSerializer().     if (stateTable != null) {         RegisteredKeyValueStateBackendMetaInfo<N, V> restoredKvMetaInfo = stateTable.getMetaInfo().         restoredKvMetaInfo.updateSnapshotTransformFactory(snapshotTransformFactory).         TypeSerializerSchemaCompatibility<N> namespaceCompatibility = restoredKvMetaInfo.updateNamespaceSerializer(namespaceSerializer).         if (namespaceCompatibility.isCompatibleAfterMigration() || namespaceCompatibility.isIncompatible()) {             throw new StateMigrationException("For heap backends, the new namespace serializer must be compatible.").         }         restoredKvMetaInfo.checkStateMetaInfo(stateDesc).         TypeSerializerSchemaCompatibility<V> stateCompatibility = restoredKvMetaInfo.updateStateSerializer(newStateSerializer).         if (stateCompatibility.isIncompatible()) {             throw new StateMigrationException("For heap backends, the new state serializer must not be incompatible.").         }         stateTable.setMetaInfo(restoredKvMetaInfo).     } else {         RegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(stateDesc.getType(), stateDesc.getName(), namespaceSerializer, newStateSerializer, snapshotTransformFactory).         stateTable = snapshotStrategy.newStateTable(newMetaInfo).         registeredKVStates.put(stateDesc.getName(), stateTable).     }     return stateTable. }
false;public;2;11;;@SuppressWarnings("unchecked") @Override public <N> Stream<K> getKeys(String state, N namespace) {     if (!registeredKVStates.containsKey(state)) {         return Stream.empty().     }     final StateSnapshotRestore stateSnapshotRestore = registeredKVStates.get(state).     StateTable<K, N, ?> table = (StateTable<K, N, ?>) stateSnapshotRestore.     return table.getKeys(namespace). }
false;private;0;3;;private boolean hasRegisteredState() {     return !(registeredKVStates.isEmpty() && registeredPQStates.isEmpty()). }
false;public;3;16;;@Override @Nonnull public <N, SV, SEV, S extends State, IS extends S> IS createInternalState(@Nonnull TypeSerializer<N> namespaceSerializer, @Nonnull StateDescriptor<S, SV> stateDesc, @Nonnull StateSnapshotTransformFactory<SEV> snapshotTransformFactory) throws Exception {     StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass()).     if (stateFactory == null) {         String message = String.format("State %s is not supported by %s", stateDesc.getClass(), this.getClass()).         throw new FlinkRuntimeException(message).     }     StateTable<K, N, SV> stateTable = tryRegisterStateTable(namespaceSerializer, stateDesc, getStateSnapshotTransformFactory(stateDesc, snapshotTransformFactory)).     return stateFactory.createState(stateDesc, stateTable, getKeySerializer()). }
false;private;2;12;;@SuppressWarnings("unchecked") private <SV, SEV> StateSnapshotTransformFactory<SV> getStateSnapshotTransformFactory(StateDescriptor<?, SV> stateDesc, StateSnapshotTransformFactory<SEV> snapshotTransformFactory) {     if (stateDesc instanceof ListStateDescriptor) {         return (StateSnapshotTransformFactory<SV>) new StateSnapshotTransformers.ListStateSnapshotTransformFactory<>(snapshotTransformFactory).     } else if (stateDesc instanceof MapStateDescriptor) {         return (StateSnapshotTransformFactory<SV>) new StateSnapshotTransformers.MapStateSnapshotTransformFactory<>(snapshotTransformFactory).     } else {         return (StateSnapshotTransformFactory<SV>) snapshotTransformFactory.     } }
false;public;4;17;;@Nonnull @Override @SuppressWarnings("unchecked") public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(final long checkpointId, final long timestamp, @Nonnull final CheckpointStreamFactory streamFactory, @Nonnull CheckpointOptions checkpointOptions) throws IOException {     long startTime = System.currentTimeMillis().     final RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunner = snapshotStrategy.snapshot(checkpointId, timestamp, streamFactory, checkpointOptions).     snapshotStrategy.logSyncCompleted(streamFactory, startTime).     return snapshotRunner. }
false;public;1;14;;@SuppressWarnings("deprecation") public void restore(Collection<KeyedStateHandle> restoredState) throws Exception {     if (restoredState == null || restoredState.isEmpty()) {         return.     }     LOG.info("Initializing heap keyed state backend from snapshot.").     if (LOG.isDebugEnabled()) {         LOG.debug("Restoring snapshot from state handles: {}.", restoredState).     }     restorePartitionedState(restoredState). }
false;private;1;64;;@SuppressWarnings({ "unchecked" }) private void restorePartitionedState(Collection<KeyedStateHandle> state) throws Exception {     final Map<Integer, StateMetaInfoSnapshot> kvStatesById = new HashMap<>().     registeredKVStates.clear().     registeredPQStates.clear().     boolean keySerializerRestored = false.     for (KeyedStateHandle keyedStateHandle : state) {         if (keyedStateHandle == null) {             continue.         }         if (!(keyedStateHandle instanceof KeyGroupsStateHandle)) {             throw new IllegalStateException("Unexpected state handle type, " + "expected: " + KeyGroupsStateHandle.class + ", but found: " + keyedStateHandle.getClass()).         }         KeyGroupsStateHandle keyGroupsStateHandle = (KeyGroupsStateHandle) keyedStateHandle.         FSDataInputStream fsDataInputStream = keyGroupsStateHandle.openInputStream().         cancelStreamRegistry.registerCloseable(fsDataInputStream).         try {             DataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(fsDataInputStream).             KeyedBackendSerializationProxy<K> serializationProxy = new KeyedBackendSerializationProxy<>(userCodeClassLoader).             serializationProxy.read(inView).             if (!keySerializerRestored) {                 // check for key serializer compatibility. this also reconfigures the                 // key serializer to be compatible, if it is required and is possible                 TypeSerializerSchemaCompatibility<K> keySerializerSchemaCompat = checkKeySerializerSchemaCompatibility(serializationProxy.getKeySerializerSnapshot()).                 if (keySerializerSchemaCompat.isCompatibleAfterMigration() || keySerializerSchemaCompat.isIncompatible()) {                     throw new StateMigrationException("The new key serializer must be compatible.").                 }                 keySerializerRestored = true.             }             List<StateMetaInfoSnapshot> restoredMetaInfos = serializationProxy.getStateMetaInfoSnapshots().             createOrCheckStateForMetaInfo(restoredMetaInfos, kvStatesById).             readStateHandleStateData(fsDataInputStream, inView, keyGroupsStateHandle.getGroupRangeOffsets(), kvStatesById, restoredMetaInfos.size(), serializationProxy.getReadVersion(), serializationProxy.isUsingKeyGroupCompression()).         } finally {             if (cancelStreamRegistry.unregisterCloseable(fsDataInputStream)) {                 IOUtils.closeQuietly(fsDataInputStream).             }         }     } }
false;private;7;37;;private void readStateHandleStateData(FSDataInputStream fsDataInputStream, DataInputViewStreamWrapper inView, KeyGroupRangeOffsets keyGroupOffsets, Map<Integer, StateMetaInfoSnapshot> kvStatesById, int numStates, int readVersion, boolean isCompressed) throws IOException {     final StreamCompressionDecorator streamCompressionDecorator = isCompressed ? SnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE.     for (Tuple2<Integer, Long> groupOffset : keyGroupOffsets) {         int keyGroupIndex = groupOffset.f0.         long offset = groupOffset.f1.         // Check that restored key groups all belong to the backend.         Preconditions.checkState(keyGroupRange.contains(keyGroupIndex), "The key group must belong to the backend.").         fsDataInputStream.seek(offset).         int writtenKeyGroupIndex = inView.readInt().         Preconditions.checkState(writtenKeyGroupIndex == keyGroupIndex, "Unexpected key-group in restore.").         try (InputStream kgCompressionInStream = streamCompressionDecorator.decorateWithCompression(fsDataInputStream)) {             readKeyGroupStateData(kgCompressionInStream, kvStatesById, keyGroupIndex, numStates, readVersion).         }     } }
false;private;5;32;;private void readKeyGroupStateData(InputStream inputStream, Map<Integer, StateMetaInfoSnapshot> kvStatesById, int keyGroupIndex, int numStates, int readVersion) throws IOException {     DataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(inputStream).     for (int i = 0. i < numStates. i++) {         final int kvStateId = inView.readShort().         final StateMetaInfoSnapshot stateMetaInfoSnapshot = kvStatesById.get(kvStateId).         final StateSnapshotRestore registeredState.         switch(stateMetaInfoSnapshot.getBackendStateType()) {             case KEY_VALUE:                 registeredState = registeredKVStates.get(stateMetaInfoSnapshot.getName()).                 break.             case PRIORITY_QUEUE:                 registeredState = registeredPQStates.get(stateMetaInfoSnapshot.getName()).                 break.             default:                 throw new IllegalStateException("Unexpected state type: " + stateMetaInfoSnapshot.getBackendStateType() + ".").         }         StateSnapshotKeyGroupReader keyGroupReader = registeredState.keyGroupReader(readVersion).         keyGroupReader.readMappingsInKeyGroup(inView, keyGroupIndex).     } }
false;private;2;34;;private void createOrCheckStateForMetaInfo(List<StateMetaInfoSnapshot> restoredMetaInfo, Map<Integer, StateMetaInfoSnapshot> kvStatesById) {     for (StateMetaInfoSnapshot metaInfoSnapshot : restoredMetaInfo) {         final StateSnapshotRestore registeredState.         switch(metaInfoSnapshot.getBackendStateType()) {             case KEY_VALUE:                 registeredState = registeredKVStates.get(metaInfoSnapshot.getName()).                 if (registeredState == null) {                     RegisteredKeyValueStateBackendMetaInfo<?, ?> registeredKeyedBackendStateMetaInfo = new RegisteredKeyValueStateBackendMetaInfo<>(metaInfoSnapshot).                     registeredKVStates.put(metaInfoSnapshot.getName(), snapshotStrategy.newStateTable(registeredKeyedBackendStateMetaInfo)).                 }                 break.             case PRIORITY_QUEUE:                 registeredState = registeredPQStates.get(metaInfoSnapshot.getName()).                 if (registeredState == null) {                     createInternal(new RegisteredPriorityQueueStateBackendMetaInfo<>(metaInfoSnapshot)).                 }                 break.             default:                 throw new IllegalStateException("Unexpected state type: " + metaInfoSnapshot.getBackendStateType() + ".").         }         if (registeredState == null) {             kvStatesById.put(kvStatesById.size(), metaInfoSnapshot).         }     } }
false;public;1;4;;@Override public void notifyCheckpointComplete(long checkpointId) { // Nothing to do }
false;public;4;24;;@Override public <N, S extends State, T> void applyToAllKeys(final N namespace, final TypeSerializer<N> namespaceSerializer, final StateDescriptor<S, T> stateDescriptor, final KeyedStateFunction<K, S> function) throws Exception {     try (Stream<K> keyStream = getKeys(stateDescriptor.getName(), namespace)) {         // we copy the keys into list to avoid the concurrency problem         // when state.clear() is invoked in function.process().         final List<K> keys = keyStream.collect(Collectors.toList()).         final S state = getPartitionedState(namespace, namespaceSerializer, stateDescriptor).         for (K key : keys) {             setCurrentKey(key).             function.process(key, state).         }     } }
false;public;0;4;;@Override public String toString() {     return "HeapKeyedStateBackend". }
true;public;0;10;/**  * Returns the total number of state entries across all keys/namespaces.  */ ;/**  * Returns the total number of state entries across all keys/namespaces.  */ @VisibleForTesting @SuppressWarnings("unchecked") @Override public int numKeyValueStateEntries() {     int sum = 0.     for (StateSnapshotRestore state : registeredKVStates.values()) {         sum += ((StateTable<?, ?, ?>) state).size().     }     return sum. }
true;public;1;8;/**  * Returns the total number of state entries across all keys for the given namespace.  */ ;/**  * Returns the total number of state entries across all keys for the given namespace.  */ @VisibleForTesting public int numKeyValueStateEntries(Object namespace) {     int sum = 0.     for (StateTable<?, ?, ?> state : registeredKVStates.values()) {         sum += state.sizeOfNamespace(namespace).     }     return sum. }
false;public;0;4;;@Override public boolean supportsAsynchronousSnapshots() {     return snapshotStrategy.isAsynchronous(). }
false;public;0;4;;@VisibleForTesting public LocalRecoveryConfig getLocalRecoveryConfig() {     return localRecoveryConfig. }
false;default;1;3;;default void finalizeSnapshotBeforeReturnHook(Runnable runnable) { }
false;;0;1;;boolean isAsynchronous().
false;;1;1;;<N, V> StateTable<K, N, V> newStateTable(RegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo).
false;public;0;4;;@Override public boolean isAsynchronous() {     return true. }
false;public;1;4;;@Override public <N, V> StateTable<K, N, V> newStateTable(RegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo) {     return new CopyOnWriteStateTable<>(HeapKeyedStateBackend.this, newMetaInfo). }
false;public;1;5;;@Override public void finalizeSnapshotBeforeReturnHook(Runnable runnable) {     // this triggers a synchronous execution from the main checkpointing thread.     runnable.run(). }
false;public;0;4;;@Override public boolean isAsynchronous() {     return false. }
false;public;1;4;;@Override public <N, V> StateTable<K, N, V> newStateTable(RegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo) {     return new NestedMapsStateTable<>(HeapKeyedStateBackend.this, newMetaInfo). }
false;protected;0;46;;@Override protected SnapshotResult<KeyedStateHandle> callInternal() throws Exception {     final CheckpointStreamWithResultProvider streamWithResultProvider = checkpointStreamSupplier.get().     snapshotCloseableRegistry.registerCloseable(streamWithResultProvider).     final CheckpointStreamFactory.CheckpointStateOutputStream localStream = streamWithResultProvider.getCheckpointOutputStream().     final DataOutputViewStreamWrapper outView = new DataOutputViewStreamWrapper(localStream).     serializationProxy.write(outView).     final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()].     for (int keyGroupPos = 0. keyGroupPos < keyGroupRange.getNumberOfKeyGroups(). ++keyGroupPos) {         int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos).         keyGroupRangeOffsets[keyGroupPos] = localStream.getPos().         outView.writeInt(keyGroupId).         for (Map.Entry<StateUID, StateSnapshot> stateSnapshot : cowStateStableSnapshots.entrySet()) {             StateSnapshot.StateKeyGroupWriter partitionedSnapshot = stateSnapshot.getValue().getKeyGroupWriter().             try (OutputStream kgCompressionOut = keyGroupCompressionDecorator.decorateWithCompression(localStream)) {                 DataOutputViewStreamWrapper kgCompressionView = new DataOutputViewStreamWrapper(kgCompressionOut).                 kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey())).                 partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId).             }         // this will just close the outer compression stream         }     }     if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {         KeyGroupRangeOffsets kgOffs = new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets).         SnapshotResult<StreamStateHandle> result = streamWithResultProvider.closeAndFinalizeCheckpointStreamResult().         return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(result, kgOffs).     } else {         throw new IOException("Stream already unregistered.").     } }
false;protected;0;6;;@Override protected void cleanupProvidedResources() {     for (StateSnapshot tableSnapshot : cowStateStableSnapshots.values()) {         tableSnapshot.release().     } }
false;protected;1;6;;@Override protected void logAsyncSnapshotComplete(long startTime) {     if (snapshotStrategySynchronicityTrait.isAsynchronous()) {         logAsyncCompleted(primaryStreamFactory, startTime).     } }
false;public;4;132;;@Nonnull @Override public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(long checkpointId, long timestamp, @Nonnull CheckpointStreamFactory primaryStreamFactory, @Nonnull CheckpointOptions checkpointOptions) throws IOException {     if (!hasRegisteredState()) {         return DoneFuture.of(SnapshotResult.empty()).     }     int numStates = registeredKVStates.size() + registeredPQStates.size().     Preconditions.checkState(numStates <= Short.MAX_VALUE, "Too many states: " + numStates + ". Currently at most " + Short.MAX_VALUE + " states are supported").     final List<StateMetaInfoSnapshot> metaInfoSnapshots = new ArrayList<>(numStates).     final Map<StateUID, Integer> stateNamesToId = new HashMap<>(numStates).     final Map<StateUID, StateSnapshot> cowStateStableSnapshots = new HashMap<>(numStates).     processSnapshotMetaInfoForAllStates(metaInfoSnapshots, cowStateStableSnapshots, stateNamesToId, registeredKVStates, StateMetaInfoSnapshot.BackendStateType.KEY_VALUE).     processSnapshotMetaInfoForAllStates(metaInfoSnapshots, cowStateStableSnapshots, stateNamesToId, registeredPQStates, StateMetaInfoSnapshot.BackendStateType.PRIORITY_QUEUE).     final KeyedBackendSerializationProxy<K> serializationProxy = new KeyedBackendSerializationProxy<>(// get a serialized form already at state registration time in the future     getKeySerializer(), metaInfoSnapshots, !Objects.equals(UncompressedStreamCompressionDecorator.INSTANCE, keyGroupCompressionDecorator)).     final SupplierWithException<CheckpointStreamWithResultProvider, Exception> checkpointStreamSupplier = localRecoveryConfig.isLocalRecoveryEnabled() ? () -> CheckpointStreamWithResultProvider.createDuplicatingStream(checkpointId, CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory, localRecoveryConfig.getLocalStateDirectoryProvider()) : () -> CheckpointStreamWithResultProvider.createSimpleStream(CheckpointedStateScope.EXCLUSIVE, primaryStreamFactory).     // --------------------------------------------------- this becomes the end of sync part     final AsyncSnapshotCallable<SnapshotResult<KeyedStateHandle>> asyncSnapshotCallable = new AsyncSnapshotCallable<SnapshotResult<KeyedStateHandle>>() {          @Override         protected SnapshotResult<KeyedStateHandle> callInternal() throws Exception {             final CheckpointStreamWithResultProvider streamWithResultProvider = checkpointStreamSupplier.get().             snapshotCloseableRegistry.registerCloseable(streamWithResultProvider).             final CheckpointStreamFactory.CheckpointStateOutputStream localStream = streamWithResultProvider.getCheckpointOutputStream().             final DataOutputViewStreamWrapper outView = new DataOutputViewStreamWrapper(localStream).             serializationProxy.write(outView).             final long[] keyGroupRangeOffsets = new long[keyGroupRange.getNumberOfKeyGroups()].             for (int keyGroupPos = 0. keyGroupPos < keyGroupRange.getNumberOfKeyGroups(). ++keyGroupPos) {                 int keyGroupId = keyGroupRange.getKeyGroupId(keyGroupPos).                 keyGroupRangeOffsets[keyGroupPos] = localStream.getPos().                 outView.writeInt(keyGroupId).                 for (Map.Entry<StateUID, StateSnapshot> stateSnapshot : cowStateStableSnapshots.entrySet()) {                     StateSnapshot.StateKeyGroupWriter partitionedSnapshot = stateSnapshot.getValue().getKeyGroupWriter().                     try (OutputStream kgCompressionOut = keyGroupCompressionDecorator.decorateWithCompression(localStream)) {                         DataOutputViewStreamWrapper kgCompressionView = new DataOutputViewStreamWrapper(kgCompressionOut).                         kgCompressionView.writeShort(stateNamesToId.get(stateSnapshot.getKey())).                         partitionedSnapshot.writeStateInKeyGroup(kgCompressionView, keyGroupId).                     }                 // this will just close the outer compression stream                 }             }             if (snapshotCloseableRegistry.unregisterCloseable(streamWithResultProvider)) {                 KeyGroupRangeOffsets kgOffs = new KeyGroupRangeOffsets(keyGroupRange, keyGroupRangeOffsets).                 SnapshotResult<StreamStateHandle> result = streamWithResultProvider.closeAndFinalizeCheckpointStreamResult().                 return CheckpointStreamWithResultProvider.toKeyedStateHandleSnapshotResult(result, kgOffs).             } else {                 throw new IOException("Stream already unregistered.").             }         }          @Override         protected void cleanupProvidedResources() {             for (StateSnapshot tableSnapshot : cowStateStableSnapshots.values()) {                 tableSnapshot.release().             }         }          @Override         protected void logAsyncSnapshotComplete(long startTime) {             if (snapshotStrategySynchronicityTrait.isAsynchronous()) {                 logAsyncCompleted(primaryStreamFactory, startTime).             }         }     }.     final FutureTask<SnapshotResult<KeyedStateHandle>> task = asyncSnapshotCallable.toAsyncSnapshotFutureTask(cancelStreamRegistry).     finalizeSnapshotBeforeReturnHook(task).     return task. }
false;public;1;4;;@Override public void finalizeSnapshotBeforeReturnHook(Runnable runnable) {     snapshotStrategySynchronicityTrait.finalizeSnapshotBeforeReturnHook(runnable). }
false;public;0;4;;@Override public boolean isAsynchronous() {     return snapshotStrategySynchronicityTrait.isAsynchronous(). }
false;public;1;4;;@Override public <N, V> StateTable<K, N, V> newStateTable(RegisteredKeyValueStateBackendMetaInfo<N, V> newMetaInfo) {     return snapshotStrategySynchronicityTrait.newStateTable(newMetaInfo). }
false;private;5;18;;private void processSnapshotMetaInfoForAllStates(List<StateMetaInfoSnapshot> metaInfoSnapshots, Map<StateUID, StateSnapshot> cowStateStableSnapshots, Map<StateUID, Integer> stateNamesToId, Map<String, ? extends StateSnapshotRestore> registeredStates, StateMetaInfoSnapshot.BackendStateType stateType) {     for (Map.Entry<String, ? extends StateSnapshotRestore> kvState : registeredStates.entrySet()) {         final StateUID stateUid = StateUID.of(kvState.getKey(), stateType).         stateNamesToId.put(stateUid, stateNamesToId.size()).         StateSnapshotRestore state = kvState.getValue().         if (null != state) {             final StateSnapshot stateSnapshot = state.stateSnapshot().             metaInfoSnapshots.add(stateSnapshot.getMetaInfoSnapshot()).             cowStateStableSnapshots.put(stateUid, stateSnapshot).         }     } }
false;;3;4;;<K, N, SV, S extends State, IS extends S> IS createState(StateDescriptor<S, SV> stateDesc, StateTable<K, N, SV> stateTable, TypeSerializer<K> keySerializer) throws Exception.
false;public;0;4;;@Nonnull public String getStateName() {     return stateName. }
false;public;0;4;;@Nonnull public StateMetaInfoSnapshot.BackendStateType getStateType() {     return stateType. }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     StateUID uid = (StateUID) o.     return Objects.equals(getStateName(), uid.getStateName()) && getStateType() == uid.getStateType(). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(getStateName(), getStateType()). }
false;public,static;2;3;;public static StateUID of(@Nonnull String stateName, @Nonnull StateMetaInfoSnapshot.BackendStateType stateType) {     return new StateUID(stateName, stateType). }
