commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public ActorSystem getActorSystem() {     return actorSystem. }
false;protected;0;3;;protected int getVersion() {     return VERSION. }
false;public;0;4;;@Override public String getAddress() {     return address. }
false;public;0;4;;@Override public int getPort() {     return port. }
true;public;2;20;// this method does not mutate state and is thus thread-safe ;// this method does not mutate state and is thus thread-safe @Override public <C extends RpcGateway> CompletableFuture<C> connect(final String address, final Class<C> clazz) {     return connectInternal(address, clazz, (ActorRef actorRef) -> {         Tuple2<String, String> addressHostname = extractAddressHostname(actorRef).         return new AkkaInvocationHandler(addressHostname.f0, addressHostname.f1, actorRef, configuration.getTimeout(), configuration.getMaximumFramesize(), null).     }). }
true;public;3;18;// this method does not mutate state and is thus thread-safe ;// this method does not mutate state and is thus thread-safe @Override public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {     return connectInternal(address, clazz, (ActorRef actorRef) -> {         Tuple2<String, String> addressHostname = extractAddressHostname(actorRef).         return new FencedAkkaInvocationHandler<>(addressHostname.f0, addressHostname.f1, actorRef, configuration.getTimeout(), configuration.getMaximumFramesize(), null, () -> fencingToken).     }). }
false;public;1;84;;@Override public <C extends RpcEndpoint & RpcGateway> RpcServer startServer(C rpcEndpoint) {     checkNotNull(rpcEndpoint, "rpc endpoint").     CompletableFuture<Void> terminationFuture = new CompletableFuture<>().     final Props akkaRpcActorProps.     if (rpcEndpoint instanceof FencedRpcEndpoint) {         akkaRpcActorProps = Props.create(FencedAkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion(), configuration.getMaximumFramesize()).     } else {         akkaRpcActorProps = Props.create(AkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion(), configuration.getMaximumFramesize()).     }     ActorRef actorRef.     synchronized (lock) {         checkState(!stopped, "RpcService is stopped").         actorRef = actorSystem.actorOf(akkaRpcActorProps, rpcEndpoint.getEndpointId()).         actors.put(actorRef, rpcEndpoint).     }     LOG.info("Starting RPC endpoint for {} at {} .", rpcEndpoint.getClass().getName(), actorRef.path()).     final String akkaAddress = AkkaUtils.getAkkaURL(actorSystem, actorRef).     final String hostname.     Option<String> host = actorRef.path().address().host().     if (host.isEmpty()) {         hostname = "localhost".     } else {         hostname = host.get().     }     Set<Class<?>> implementedRpcGateways = new HashSet<>(RpcUtils.extractImplementedRpcGateways(rpcEndpoint.getClass())).     implementedRpcGateways.add(RpcServer.class).     implementedRpcGateways.add(AkkaBasedEndpoint.class).     final InvocationHandler akkaInvocationHandler.     if (rpcEndpoint instanceof FencedRpcEndpoint) {         // a FencedRpcEndpoint needs a FencedAkkaInvocationHandler         akkaInvocationHandler = new FencedAkkaInvocationHandler<>(akkaAddress, hostname, actorRef, configuration.getTimeout(), configuration.getMaximumFramesize(), terminationFuture, ((FencedRpcEndpoint<?>) rpcEndpoint)::getFencingToken).         implementedRpcGateways.add(FencedMainThreadExecutable.class).     } else {         akkaInvocationHandler = new AkkaInvocationHandler(akkaAddress, hostname, actorRef, configuration.getTimeout(), configuration.getMaximumFramesize(), terminationFuture).     }     // Rather than using the System ClassLoader directly, we derive the ClassLoader     // from this class . That works better in cases where Flink runs embedded and all Flink     // code is loaded dynamically (for example from an OSGI bundle) through a custom ClassLoader     ClassLoader classLoader = getClass().getClassLoader().     @SuppressWarnings("unchecked")     RpcServer server = (RpcServer) Proxy.newProxyInstance(classLoader, implementedRpcGateways.toArray(new Class<?>[implementedRpcGateways.size()]), akkaInvocationHandler).     return server. }
false;public;2;26;;@Override public <F extends Serializable> RpcServer fenceRpcServer(RpcServer rpcServer, F fencingToken) {     if (rpcServer instanceof AkkaBasedEndpoint) {         InvocationHandler fencedInvocationHandler = new FencedAkkaInvocationHandler<>(rpcServer.getAddress(), rpcServer.getHostname(), ((AkkaBasedEndpoint) rpcServer).getActorRef(), configuration.getTimeout(), configuration.getMaximumFramesize(), null, () -> fencingToken).         // Rather than using the System ClassLoader directly, we derive the ClassLoader         // from this class . That works better in cases where Flink runs embedded and all Flink         // code is loaded dynamically (for example from an OSGI bundle) through a custom ClassLoader         ClassLoader classLoader = getClass().getClassLoader().         return (RpcServer) Proxy.newProxyInstance(classLoader, new Class<?>[] { RpcServer.class, AkkaBasedEndpoint.class }, fencedInvocationHandler).     } else {         throw new RuntimeException("The given RpcServer must implement the AkkaGateway in order to fence it.").     } }
false;public;1;21;;@Override public void stopServer(RpcServer selfGateway) {     if (selfGateway instanceof AkkaBasedEndpoint) {         final AkkaBasedEndpoint akkaClient = (AkkaBasedEndpoint) selfGateway.         final RpcEndpoint rpcEndpoint.         synchronized (lock) {             if (stopped) {                 return.             } else {                 rpcEndpoint = actors.remove(akkaClient.getActorRef()).             }         }         if (rpcEndpoint != null) {             terminateAkkaRpcActor(akkaClient.getActorRef(), rpcEndpoint).         } else {             LOG.debug("RPC endpoint {} already stopped or from different RPC service", selfGateway.getAddress()).         }     } }
false;public;0;33;;@Override public CompletableFuture<Void> stopService() {     final CompletableFuture<Void> akkaRpcActorsTerminationFuture.     synchronized (lock) {         if (stopped) {             return terminationFuture.         }         LOG.info("Stopping Akka RPC service.").         stopped = true.         akkaRpcActorsTerminationFuture = terminateAkkaRpcActors().     }     final CompletableFuture<Void> actorSystemTerminationFuture = FutureUtils.composeAfterwards(akkaRpcActorsTerminationFuture, () -> FutureUtils.toJava(actorSystem.terminate())).     actorSystemTerminationFuture.whenComplete((Void ignored, Throwable throwable) -> {         if (throwable != null) {             terminationFuture.completeExceptionally(throwable).         } else {             terminationFuture.complete(null).         }         LOG.info("Stopped Akka RPC service.").     }).     return terminationFuture. }
false;private;0;12;;@GuardedBy("lock") @Nonnull private CompletableFuture<Void> terminateAkkaRpcActors() {     final Collection<CompletableFuture<Void>> akkaRpcActorTerminationFutures = new ArrayList<>(actors.size()).     for (Map.Entry<ActorRef, RpcEndpoint> actorRefRpcEndpointEntry : actors.entrySet()) {         akkaRpcActorTerminationFutures.add(terminateAkkaRpcActor(actorRefRpcEndpointEntry.getKey(), actorRefRpcEndpointEntry.getValue())).     }     actors.clear().     return FutureUtils.waitForAll(akkaRpcActorTerminationFutures). }
false;private;2;5;;private CompletableFuture<Void> terminateAkkaRpcActor(ActorRef akkaRpcActorRef, RpcEndpoint rpcEndpoint) {     akkaRpcActorRef.tell(ControlMessages.TERMINATE, ActorRef.noSender()).     return rpcEndpoint.getTerminationFuture(). }
false;public;0;4;;@Override public CompletableFuture<Void> getTerminationFuture() {     return terminationFuture. }
false;public;0;4;;@Override public Executor getExecutor() {     return actorSystem.dispatcher(). }
false;public;0;4;;@Override public ScheduledExecutor getScheduledExecutor() {     return internalScheduledExecutor. }
false;public;3;8;;@Override public ScheduledFuture<?> scheduleRunnable(Runnable runnable, long delay, TimeUnit unit) {     checkNotNull(runnable, "runnable").     checkNotNull(unit, "unit").     checkArgument(delay >= 0L, "delay must be zero or larger").     return internalScheduledExecutor.schedule(runnable, delay, unit). }
false;public;1;4;;@Override public void execute(Runnable runnable) {     actorSystem.dispatcher().execute(runnable). }
false;public;1;6;;@Override public <T> CompletableFuture<T> execute(Callable<T> callable) {     Future<T> scalaFuture = Futures.<T>future(callable, actorSystem.dispatcher()).     return FutureUtils.toJava(scalaFuture). }
false;private;1;12;;// --------------------------------------------------------------------------------------- // Private helper methods // --------------------------------------------------------------------------------------- private Tuple2<String, String> extractAddressHostname(ActorRef actorRef) {     final String actorAddress = AkkaUtils.getAkkaURL(actorSystem, actorRef).     final String hostname.     Option<String> host = actorRef.path().address().host().     if (host.isEmpty()) {         hostname = "localhost".     } else {         hostname = host.get().     }     return Tuple2.of(actorAddress, hostname). }
false;private;3;52;;private <C extends RpcGateway> CompletableFuture<C> connectInternal(final String address, final Class<C> clazz, Function<ActorRef, InvocationHandler> invocationHandlerFactory) {     checkState(!stopped, "RpcService is stopped").     LOG.debug("Try to connect to remote RPC endpoint with address {}. Returning a {} gateway.", address, clazz.getName()).     final ActorSelection actorSel = actorSystem.actorSelection(address).     final Future<ActorIdentity> identify = Patterns.ask(actorSel, new Identify(42), configuration.getTimeout().toMilliseconds()).<ActorIdentity>mapTo(ClassTag$.MODULE$.<ActorIdentity>apply(ActorIdentity.class)).     final CompletableFuture<ActorIdentity> identifyFuture = FutureUtils.toJava(identify).     final CompletableFuture<ActorRef> actorRefFuture = identifyFuture.thenApply((ActorIdentity actorIdentity) -> {         if (actorIdentity.getRef() == null) {             throw new CompletionException(new RpcConnectionException("Could not connect to rpc endpoint under address " + address + '.')).         } else {             return actorIdentity.getRef().         }     }).     final CompletableFuture<HandshakeSuccessMessage> handshakeFuture = actorRefFuture.thenCompose((ActorRef actorRef) -> FutureUtils.toJava(Patterns.ask(actorRef, new RemoteHandshakeMessage(clazz, getVersion()), configuration.getTimeout().toMilliseconds()).<HandshakeSuccessMessage>mapTo(ClassTag$.MODULE$.<HandshakeSuccessMessage>apply(HandshakeSuccessMessage.class)))).     return actorRefFuture.thenCombineAsync(handshakeFuture, (ActorRef actorRef, HandshakeSuccessMessage ignored) -> {         InvocationHandler invocationHandler = invocationHandlerFactory.apply(actorRef).         // Rather than using the System ClassLoader directly, we derive the ClassLoader         // from this class . That works better in cases where Flink runs embedded and all Flink         // code is loaded dynamically (for example from an OSGI bundle) through a custom ClassLoader         ClassLoader classLoader = getClass().getClassLoader().         @SuppressWarnings("unchecked")         C proxy = (C) Proxy.newProxyInstance(classLoader, new Class<?>[] { clazz }, invocationHandler).         return proxy.     }, actorSystem.dispatcher()). }
