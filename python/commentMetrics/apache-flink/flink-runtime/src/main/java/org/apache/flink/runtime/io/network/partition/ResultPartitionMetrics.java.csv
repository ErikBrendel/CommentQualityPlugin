commented;modifiers;parameterAmount;loc;comment;code
true;;0;9;/**  * Iterates over all sub-partitions and collects the total number of queued buffers in a  * best-effort way.  *  * @return total number of queued buffers  */ ;// ------------------------------------------------------------------------ // these methods are package private to make access from the nested classes faster /**  * Iterates over all sub-partitions and collects the total number of queued buffers in a  * best-effort way.  *  * @return total number of queued buffers  */ long refreshAndGetTotal() {     long total = 0.     for (ResultSubpartition part : partition.getAllPartitions()) {         total += part.unsynchronizedGetNumberOfQueuedBuffers().     }     return total. }
true;;0;16;/**  * Iterates over all sub-partitions and collects the minimum number of queued buffers in a  * sub-partition in a best-effort way.  *  * @return minimum number of queued buffers per sub-partition (<tt>0</tt> if sub-partitions exist)  */ ;/**  * Iterates over all sub-partitions and collects the minimum number of queued buffers in a  * sub-partition in a best-effort way.  *  * @return minimum number of queued buffers per sub-partition (<tt>0</tt> if sub-partitions exist)  */ int refreshAndGetMin() {     int min = Integer.MAX_VALUE.     ResultSubpartition[] allPartitions = partition.getAllPartitions().     if (allPartitions.length == 0) {         // meaningful value when no channels exist:         return 0.     }     for (ResultSubpartition part : allPartitions) {         int size = part.unsynchronizedGetNumberOfQueuedBuffers().         min = Math.min(min, size).     }     return min. }
true;;0;10;/**  * Iterates over all sub-partitions and collects the maximum number of queued buffers in a  * sub-partition in a best-effort way.  *  * @return maximum number of queued buffers per sub-partition  */ ;/**  * Iterates over all sub-partitions and collects the maximum number of queued buffers in a  * sub-partition in a best-effort way.  *  * @return maximum number of queued buffers per sub-partition  */ int refreshAndGetMax() {     int max = 0.     for (ResultSubpartition part : partition.getAllPartitions()) {         int size = part.unsynchronizedGetNumberOfQueuedBuffers().         max = Math.max(max, size).     }     return max. }
true;;0;11;/**  * Iterates over all sub-partitions and collects the average number of queued buffers in a  * sub-partition in a best-effort way.  *  * @return average number of queued buffers per sub-partition  */ ;/**  * Iterates over all sub-partitions and collects the average number of queued buffers in a  * sub-partition in a best-effort way.  *  * @return average number of queued buffers per sub-partition  */ float refreshAndGetAvg() {     long total = 0.     ResultSubpartition[] allPartitions = partition.getAllPartitions().     for (ResultSubpartition part : allPartitions) {         int size = part.unsynchronizedGetNumberOfQueuedBuffers().         total += size.     }     return total / (float) allPartitions.length. }
false;public;0;4;;@Override public Long getValue() {     return refreshAndGetTotal(). }
false;private;0;8;;// ------------------------------------------------------------------------ // Gauges to access the stats // ------------------------------------------------------------------------ private Gauge<Long> getTotalQueueLenGauge() {     return new Gauge<Long>() {          @Override         public Long getValue() {             return refreshAndGetTotal().         }     }. }
false;public;0;4;;@Override public Integer getValue() {     return refreshAndGetMin(). }
false;private;0;8;;private Gauge<Integer> getMinQueueLenGauge() {     return new Gauge<Integer>() {          @Override         public Integer getValue() {             return refreshAndGetMin().         }     }. }
false;public;0;4;;@Override public Integer getValue() {     return refreshAndGetMax(). }
false;private;0;8;;private Gauge<Integer> getMaxQueueLenGauge() {     return new Gauge<Integer>() {          @Override         public Integer getValue() {             return refreshAndGetMax().         }     }. }
false;public;0;4;;@Override public Float getValue() {     return refreshAndGetAvg(). }
false;private;0;8;;private Gauge<Float> getAvgQueueLenGauge() {     return new Gauge<Float>() {          @Override         public Float getValue() {             return refreshAndGetAvg().         }     }. }
false;public,static;2;8;;// ------------------------------------------------------------------------ // Static access // ------------------------------------------------------------------------ public static void registerQueueLengthMetrics(MetricGroup group, ResultPartition partition) {     ResultPartitionMetrics metrics = new ResultPartitionMetrics(partition).     group.gauge("totalQueueLen", metrics.getTotalQueueLenGauge()).     group.gauge("minQueueLen", metrics.getMinQueueLenGauge()).     group.gauge("maxQueueLen", metrics.getMaxQueueLenGauge()).     group.gauge("avgQueueLen", metrics.getAvgQueueLenGauge()). }
