commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Checks whether or not a single key-group is contained in the range.  *  * @param keyGroup Key-group to check for inclusion.  * @return True, only if the key-group is in the range.  */ ;/**  * Checks whether or not a single key-group is contained in the range.  *  * @param keyGroup Key-group to check for inclusion.  * @return True, only if the key-group is in the range.  */ @Override public boolean contains(int keyGroup) {     return keyGroup >= startKeyGroup && keyGroup <= endKeyGroup. }
true;public;1;5;/**  * Create a range that represent the intersection between this range and the given range.  *  * @param other A KeyGroupRange to intersect.  * @return Key-group range that is the intersection between this and the given key-group range.  */ ;/**  * Create a range that represent the intersection between this range and the given range.  *  * @param other A KeyGroupRange to intersect.  * @return Key-group range that is the intersection between this and the given key-group range.  */ public KeyGroupRange getIntersection(KeyGroupRange other) {     int start = Math.max(startKeyGroup, other.startKeyGroup).     int end = Math.min(endKeyGroup, other.endKeyGroup).     return start <= end ? new KeyGroupRange(start, end) : EMPTY_KEY_GROUP_RANGE. }
true;public;0;4;/**  * @return The number of key-groups in the range  */ ;/**  * @return The number of key-groups in the range  */ @Override public int getNumberOfKeyGroups() {     return 1 + endKeyGroup - startKeyGroup. }
true;public;0;3;/**  * @return The first key-group in the range.  */ ;/**  * @return The first key-group in the range.  */ public int getStartKeyGroup() {     return startKeyGroup. }
true;public;0;3;/**  * @return The last key-group in the range.  */ ;/**  * @return The last key-group in the range.  */ public int getEndKeyGroup() {     return endKeyGroup. }
false;public;1;7;;@Override public int getKeyGroupId(int idx) {     if (idx < 0 || idx > getNumberOfKeyGroups()) {         throw new IndexOutOfBoundsException("Key group index out of bounds: " + idx).     }     return startKeyGroup + idx. }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (!(o instanceof KeyGroupRange)) {         return false.     }     KeyGroupRange that = (KeyGroupRange) o.     return startKeyGroup == that.startKeyGroup && endKeyGroup == that.endKeyGroup. }
false;public;0;6;;@Override public int hashCode() {     int result = startKeyGroup.     result = 31 * result + endKeyGroup.     return result. }
false;public;0;7;;@Override public String toString() {     return "KeyGroupRange{" + "startKeyGroup=" + startKeyGroup + ", endKeyGroup=" + endKeyGroup + '}'. }
false;public;0;4;;@Override public Iterator<Integer> iterator() {     return new KeyGroupIterator(). }
false;public;0;4;;@Override public boolean hasNext() {     return iteratorPos < getNumberOfKeyGroups(). }
false;public;0;6;;@Override public Integer next() {     int rv = startKeyGroup + iteratorPos.     ++iteratorPos.     return rv. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException("Unsupported by this iterator!"). }
true;public,static;2;3;/**  * Factory method that also handles creation of empty key-groups.  *  * @param startKeyGroup start of the range (inclusive)  * @param endKeyGroup end of the range (inclusive)  * @return the key-group from start to end or an empty key-group range.  */ ;/**  * Factory method that also handles creation of empty key-groups.  *  * @param startKeyGroup start of the range (inclusive)  * @param endKeyGroup end of the range (inclusive)  * @return the key-group from start to end or an empty key-group range.  */ public static KeyGroupRange of(int startKeyGroup, int endKeyGroup) {     return startKeyGroup <= endKeyGroup ? new KeyGroupRange(startKeyGroup, endKeyGroup) : EMPTY_KEY_GROUP_RANGE. }
