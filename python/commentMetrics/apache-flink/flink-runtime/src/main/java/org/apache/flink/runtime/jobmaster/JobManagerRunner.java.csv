commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// ---------------------------------------------------------------------------------------------- // Getter // ---------------------------------------------------------------------------------------------- public CompletableFuture<JobMasterGateway> getLeaderGatewayFuture() {     return leaderGatewayFuture. }
false;public;0;3;;public JobGraph getJobGraph() {     return jobGraph. }
false;public;0;3;;public CompletableFuture<ArchivedExecutionGraph> getResultFuture() {     return resultFuture. }
false;public;0;8;;// ---------------------------------------------------------------------------------------------- // Lifecycle management // ---------------------------------------------------------------------------------------------- public void start() throws Exception {     try {         leaderElectionService.start(this).     } catch (Exception e) {         log.error("Could not start the JobManager because the leader election service did not start.", e).         throw new Exception("Could not start the leader election service.", e).     } }
false;public;0;38;;@Override public CompletableFuture<Void> closeAsync() {     synchronized (lock) {         if (!shutdown) {             shutdown = true.             setNewLeaderGatewayFuture().             leaderGatewayFuture.completeExceptionally(new FlinkException("JobMaster has been shut down.")).             final CompletableFuture<Void> jobManagerTerminationFuture = jobMasterService.closeAsync().             jobManagerTerminationFuture.whenComplete((Void ignored, Throwable throwable) -> {                 try {                     leaderElectionService.stop().                 } catch (Throwable t) {                     throwable = ExceptionUtils.firstOrSuppressed(t, ExceptionUtils.stripCompletionException(throwable)).                 }                 libraryCacheManager.unregisterJob(jobGraph.getJobID()).                 if (throwable != null) {                     terminationFuture.completeExceptionally(new FlinkException("Could not properly shut down the JobManagerRunner", throwable)).                 } else {                     terminationFuture.complete(null).                 }             }).             terminationFuture.whenComplete((Void ignored, Throwable throwable) -> {                 resultFuture.completeExceptionally(new JobNotFinishedException(jobGraph.getJobID())).             }).         }         return terminationFuture.     } }
true;public;1;6;/**  * Job completion notification triggered by JobManager.  */ ;// ---------------------------------------------------------------------------------------------- // Result and error handling methods // ---------------------------------------------------------------------------------------------- /**  * Job completion notification triggered by JobManager.  */ @Override public void jobReachedGloballyTerminalState(ArchivedExecutionGraph executionGraph) {     unregisterJobFromHighAvailability().     // complete the result future with the terminal execution graph     resultFuture.complete(executionGraph). }
true;public;0;4;/**  * Job completion notification triggered by self.  */ ;/**  * Job completion notification triggered by self.  */ @Override public void jobFinishedByOther() {     resultFuture.completeExceptionally(new JobNotFinishedException(jobGraph.getJobID())). }
false;public;1;4;;@Override public void jobMasterFailed(Throwable cause) {     handleJobManagerRunnerError(cause). }
false;private;1;7;;private void handleJobManagerRunnerError(Throwable cause) {     if (ExceptionUtils.isJvmFatalError(cause)) {         fatalErrorHandler.onFatalError(cause).     } else {         resultFuture.completeExceptionally(cause).     } }
true;private;0;10;/**  * Marks this runner's job as not running. Other JobManager will not recover the job  * after this call.  *  * <p>This method never throws an exception.  */ ;/**  * Marks this runner's job as not running. Other JobManager will not recover the job  * after this call.  *  * <p>This method never throws an exception.  */ private void unregisterJobFromHighAvailability() {     try {         runningJobsRegistry.setJobFinished(jobGraph.getJobID()).     } catch (Throwable t) {         log.error("Could not un-register from high-availability services job {} ({})." + "Other JobManager's may attempt to recover it and re-execute it.", jobGraph.getName(), jobGraph.getJobID(), t).     } }
false;public;1;18;;// ---------------------------------------------------------------------------------------------- // Leadership methods // ---------------------------------------------------------------------------------------------- @Override public void grantLeadership(final UUID leaderSessionID) {     synchronized (lock) {         if (shutdown) {             log.info("JobManagerRunner already shutdown.").             return.         }         leadershipOperation = leadershipOperation.thenCompose((ignored) -> {             synchronized (lock) {                 return verifyJobSchedulingStatusAndStartJobManager(leaderSessionID).             }         }).         handleException(leadershipOperation, "Could not start the job manager.").     } }
false;private;1;12;;private CompletableFuture<Void> verifyJobSchedulingStatusAndStartJobManager(UUID leaderSessionId) {     final CompletableFuture<JobSchedulingStatus> jobSchedulingStatusFuture = getJobSchedulingStatus().     return jobSchedulingStatusFuture.thenCompose(jobSchedulingStatus -> {         if (jobSchedulingStatus == JobSchedulingStatus.DONE) {             return jobAlreadyDone().         } else {             return startJobMaster(leaderSessionId).         }     }). }
false;private;1;25;;private CompletionStage<Void> startJobMaster(UUID leaderSessionId) {     log.info("JobManager runner for job {} ({}) was granted leadership with session id {} at {}.", jobGraph.getName(), jobGraph.getJobID(), leaderSessionId, getAddress()).     try {         runningJobsRegistry.setJobRunning(jobGraph.getJobID()).     } catch (IOException e) {         return FutureUtils.completedExceptionally(new FlinkException(String.format("Failed to set the job %s to running in the running jobs registry.", jobGraph.getJobID()), e)).     }     final CompletableFuture<Acknowledge> startFuture.     try {         startFuture = jobMasterService.start(new JobMasterId(leaderSessionId)).     } catch (Exception e) {         return FutureUtils.completedExceptionally(new FlinkException("Failed to start the JobMaster.", e)).     }     final CompletableFuture<JobMasterGateway> currentLeaderGatewayFuture = leaderGatewayFuture.     return startFuture.thenAcceptAsync((Acknowledge ack) -> confirmLeaderSessionIdIfStillLeader(leaderSessionId, currentLeaderGatewayFuture), executor). }
false;private;0;6;;@Nonnull private CompletionStage<Void> jobAlreadyDone() {     log.info("Granted leader ship but job {} has been finished. ", jobGraph.getJobID()).     jobFinishedByOther().     return CompletableFuture.completedFuture(null). }
false;private;0;11;;private CompletableFuture<JobSchedulingStatus> getJobSchedulingStatus() {     try {         JobSchedulingStatus jobSchedulingStatus = runningJobsRegistry.getJobSchedulingStatus(jobGraph.getJobID()).         return CompletableFuture.completedFuture(jobSchedulingStatus).     } catch (IOException e) {         return FutureUtils.completedExceptionally(new FlinkException(String.format("Could not retrieve the job scheduling status for job %s.", jobGraph.getJobID()), e)).     } }
false;private;2;8;;private void confirmLeaderSessionIdIfStillLeader(UUID leaderSessionId, CompletableFuture<JobMasterGateway> currentLeaderGatewayFuture) {     if (leaderElectionService.hasLeadership(leaderSessionId)) {         currentLeaderGatewayFuture.complete(jobMasterService.getGateway()).         leaderElectionService.confirmLeaderSessionID(leaderSessionId).     } else {         log.debug("Ignoring confirmation of leader session id because {} is no longer the leader.", getAddress()).     } }
false;public;0;18;;@Override public void revokeLeadership() {     synchronized (lock) {         if (shutdown) {             log.info("JobManagerRunner already shutdown.").             return.         }         leadershipOperation = leadershipOperation.thenCompose((ignored) -> {             synchronized (lock) {                 return revokeJobMasterLeadership().             }         }).         handleException(leadershipOperation, "Could not suspend the job manager.").     } }
false;private;0;10;;private CompletableFuture<Void> revokeJobMasterLeadership() {     log.info("JobManager for job {} ({}) was revoked leadership at {}.", jobGraph.getName(), jobGraph.getJobID(), getAddress()).     setNewLeaderGatewayFuture().     return jobMasterService.suspend(new FlinkException("JobManager is no longer the leader.")).thenApply(FunctionUtils.nullFn()). }
false;private;2;8;;private void handleException(CompletableFuture<Void> leadershipOperation, String message) {     leadershipOperation.whenComplete((ignored, throwable) -> {         if (throwable != null) {             handleJobManagerRunnerError(new FlinkException(message, throwable)).         }     }). }
false;private;0;16;;private void setNewLeaderGatewayFuture() {     final CompletableFuture<JobMasterGateway> oldLeaderGatewayFuture = leaderGatewayFuture.     leaderGatewayFuture = new CompletableFuture<>().     if (!oldLeaderGatewayFuture.isDone()) {         leaderGatewayFuture.whenComplete((JobMasterGateway jobMasterGateway, Throwable throwable) -> {             if (throwable != null) {                 oldLeaderGatewayFuture.completeExceptionally(throwable).             } else {                 oldLeaderGatewayFuture.complete(jobMasterGateway).             }         }).     } }
false;public;0;4;;@Override public String getAddress() {     return jobMasterService.getAddress(). }
false;public;1;5;;@Override public void handleError(Exception exception) {     log.error("Leader Election Service encountered a fatal error.", exception).     handleJobManagerRunnerError(exception). }
false;;0;4;;// ---------------------------------------------------------------------------------------------- // Testing // ---------------------------------------------------------------------------------------------- @VisibleForTesting boolean isShutdown() {     return shutdown. }
