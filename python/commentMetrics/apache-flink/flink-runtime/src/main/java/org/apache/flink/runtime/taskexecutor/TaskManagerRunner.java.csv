commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// -------------------------------------------------------------------------------------------- // Lifecycle management // -------------------------------------------------------------------------------------------- public void start() throws Exception {     taskManager.start(). }
false;public;0;25;;@Override public CompletableFuture<Void> closeAsync() {     synchronized (lock) {         if (!shutdown) {             shutdown = true.             final CompletableFuture<Void> taskManagerTerminationFuture = taskManager.closeAsync().             final CompletableFuture<Void> serviceTerminationFuture = FutureUtils.composeAfterwards(taskManagerTerminationFuture, this::shutDownServices).             serviceTerminationFuture.whenComplete((Void ignored, Throwable throwable) -> {                 if (throwable != null) {                     terminationFuture.completeExceptionally(throwable).                 } else {                     terminationFuture.complete(null).                 }             }).         }     }     return terminationFuture. }
false;private;0;38;;private CompletableFuture<Void> shutDownServices() {     synchronized (lock) {         Collection<CompletableFuture<Void>> terminationFutures = new ArrayList<>(3).         Exception exception = null.         try {             blobCacheService.close().         } catch (Exception e) {             exception = ExceptionUtils.firstOrSuppressed(e, exception).         }         try {             metricRegistry.shutdown().         } catch (Exception e) {             exception = ExceptionUtils.firstOrSuppressed(e, exception).         }         if (metricQueryServiceActorSystem != null) {             terminationFutures.add(AkkaUtils.terminateActorSystem(metricQueryServiceActorSystem)).         }         try {             highAvailabilityServices.close().         } catch (Exception e) {             exception = ExceptionUtils.firstOrSuppressed(e, exception).         }         terminationFutures.add(rpcService.stopService()).         terminationFutures.add(ExecutorUtils.nonBlockingShutdown(timeout.toMilliseconds(), TimeUnit.MILLISECONDS, executor)).         if (exception != null) {             terminationFutures.add(FutureUtils.completedExceptionally(exception)).         }         return FutureUtils.completeAll(terminationFutures).     } }
true;public;0;3;// export the termination future for caller to know it is terminated ;// export the termination future for caller to know it is terminated public CompletableFuture<Void> getTerminationFuture() {     return terminationFuture. }
false;public;1;17;;// -------------------------------------------------------------------------------------------- // FatalErrorHandler methods // -------------------------------------------------------------------------------------------- @Override public void onFatalError(Throwable exception) {     LOG.error("Fatal error occurred while executing the TaskManager. Shutting it down...", exception).     if (ExceptionUtils.isJvmFatalOrOutOfMemoryError(exception)) {         terminateJVM().     } else {         closeAsync().         FutureUtils.orTimeout(terminationFuture, FATAL_ERROR_SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS).         terminationFuture.whenComplete((Void ignored, Throwable throwable) -> {             terminateJVM().         }).     } }
false;private;0;3;;private void terminateJVM() {     System.exit(RUNTIME_FAILURE_RETURN_CODE). }
false;public;0;5;;@Override public Void call() throws Exception {     runTaskManager(configuration, ResourceID.generate()).     return null. }
false;public,static;1;39;;// -------------------------------------------------------------------------------------------- // Static entry point // -------------------------------------------------------------------------------------------- public static void main(String[] args) throws Exception {     // startup checks and logging     EnvironmentInformation.logEnvironmentInfo(LOG, "TaskManager", args).     SignalHandler.register(LOG).     JvmShutdownSafeguard.installAsShutdownHook(LOG).     long maxOpenFileHandles = EnvironmentInformation.getOpenFileHandlesLimit().     if (maxOpenFileHandles != -1L) {         LOG.info("Maximum number of open file descriptors is {}.", maxOpenFileHandles).     } else {         LOG.info("Cannot determine the maximum number of open file descriptors").     }     final Configuration configuration = loadConfiguration(args).     try {         FileSystem.initialize(configuration).     } catch (IOException e) {         throw new IOException("Error while setting the default " + "filesystem scheme from configuration.", e).     }     SecurityUtils.install(new SecurityConfiguration(configuration)).     try {         SecurityUtils.getInstalledContext().runSecured(new Callable<Void>() {              @Override             public Void call() throws Exception {                 runTaskManager(configuration, ResourceID.generate()).                 return null.             }         }).     } catch (Throwable t) {         final Throwable strippedThrowable = ExceptionUtils.stripException(t, UndeclaredThrowableException.class).         LOG.error("TaskManager initialization failed.", strippedThrowable).         System.exit(STARTUP_FAILURE_RETURN_CODE).     } }
false;static;1;17;;@VisibleForTesting static Configuration loadConfiguration(String[] args) throws FlinkParseException {     final CommandLineParser<ClusterConfiguration> commandLineParser = new CommandLineParser<>(new ClusterConfigurationParserFactory()).     final ClusterConfiguration clusterConfiguration.     try {         clusterConfiguration = commandLineParser.parse(args).     } catch (FlinkParseException e) {         LOG.error("Could not parse the command line options.", e).         commandLineParser.printHelp(TaskManagerRunner.class.getSimpleName()).         throw e.     }     final Configuration dynamicProperties = ConfigurationUtils.createConfiguration(clusterConfiguration.getDynamicProperties()).     return GlobalConfiguration.loadConfiguration(clusterConfiguration.getConfigDir(), dynamicProperties). }
false;public,static;2;5;;public static void runTaskManager(Configuration configuration, ResourceID resourceId) throws Exception {     final TaskManagerRunner taskManagerRunner = new TaskManagerRunner(configuration, resourceId).     taskManagerRunner.start(). }
false;public,static;9;54;;// -------------------------------------------------------------------------------------------- // Static utilities // -------------------------------------------------------------------------------------------- public static TaskExecutor startTaskManager(Configuration configuration, ResourceID resourceID, RpcService rpcService, HighAvailabilityServices highAvailabilityServices, HeartbeatServices heartbeatServices, MetricRegistry metricRegistry, BlobCacheService blobCacheService, boolean localCommunicationOnly, FatalErrorHandler fatalErrorHandler) throws Exception {     checkNotNull(configuration).     checkNotNull(resourceID).     checkNotNull(rpcService).     checkNotNull(highAvailabilityServices).     LOG.info("Starting TaskManager with ResourceID: {}", resourceID).     InetAddress remoteAddress = InetAddress.getByName(rpcService.getAddress()).     TaskManagerServicesConfiguration taskManagerServicesConfiguration = TaskManagerServicesConfiguration.fromConfiguration(configuration, remoteAddress, localCommunicationOnly).     TaskManagerServices taskManagerServices = TaskManagerServices.fromConfiguration(taskManagerServicesConfiguration, resourceID, // TODO replace this later with some dedicated executor for io.     rpcService.getExecutor(), EnvironmentInformation.getSizeOfFreeHeapMemoryWithDefrag(), EnvironmentInformation.getMaxJvmHeapMemory()).     TaskManagerMetricGroup taskManagerMetricGroup = MetricUtils.instantiateTaskManagerMetricGroup(metricRegistry, taskManagerServices.getTaskManagerLocation(), taskManagerServices.getNetworkEnvironment(), taskManagerServicesConfiguration.getSystemResourceMetricsProbingInterval()).     TaskManagerConfiguration taskManagerConfiguration = TaskManagerConfiguration.fromConfiguration(configuration).     String metricQueryServicePath = metricRegistry.getMetricQueryServicePath().     return new TaskExecutor(rpcService, taskManagerConfiguration, highAvailabilityServices, taskManagerServices, heartbeatServices, taskManagerMetricGroup, metricQueryServicePath, blobCacheService, fatalErrorHandler). }
true;public,static;2;12;/**  * Create a RPC service for the task manager.  *  * @param configuration The configuration for the TaskManager.  * @param haServices to use for the task manager hostname retrieval  */ ;/**  * Create a RPC service for the task manager.  *  * @param configuration The configuration for the TaskManager.  * @param haServices to use for the task manager hostname retrieval  */ public static RpcService createRpcService(final Configuration configuration, final HighAvailabilityServices haServices) throws Exception {     checkNotNull(configuration).     checkNotNull(haServices).     final String taskManagerAddress = determineTaskManagerBindAddress(configuration, haServices).     final String portRangeDefinition = configuration.getString(TaskManagerOptions.RPC_PORT).     return AkkaRpcServiceUtils.createRpcService(taskManagerAddress, portRangeDefinition, configuration). }
false;private,static;2;13;;private static String determineTaskManagerBindAddress(final Configuration configuration, final HighAvailabilityServices haServices) throws Exception {     final String configuredTaskManagerHostname = configuration.getString(TaskManagerOptions.HOST).     if (configuredTaskManagerHostname != null) {         LOG.info("Using configured hostname/address for TaskManager: {}.", configuredTaskManagerHostname).         return configuredTaskManagerHostname.     } else {         return determineTaskManagerBindAddressByConnectingToResourceManager(configuration, haServices).     } }
false;private,static;2;16;;private static String determineTaskManagerBindAddressByConnectingToResourceManager(final Configuration configuration, final HighAvailabilityServices haServices) throws LeaderRetrievalException {     final Time lookupTimeout = Time.milliseconds(AkkaUtils.getLookupTimeout(configuration).toMillis()).     final InetAddress taskManagerAddress = LeaderRetrievalUtils.findConnectingAddress(haServices.getResourceManagerLeaderRetriever(), lookupTimeout).     LOG.info("TaskManager will use hostname/address '{}' ({}) for communication.", taskManagerAddress.getHostName(), taskManagerAddress.getHostAddress()).     HostBindPolicy bindPolicy = HostBindPolicy.fromString(configuration.getString(TaskManagerOptions.HOST_BIND_POLICY)).     return bindPolicy == HostBindPolicy.IP ? taskManagerAddress.getHostAddress() : taskManagerAddress.getHostName(). }
