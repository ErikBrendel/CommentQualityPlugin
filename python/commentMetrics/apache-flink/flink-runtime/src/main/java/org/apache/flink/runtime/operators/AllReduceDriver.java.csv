commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;// ------------------------------------------------------------------------ @Override public void setup(TaskContext<ReduceFunction<T>, T> context) {     this.taskContext = context.     this.running = true. }
false;public;0;4;;@Override public int getNumberOfInputs() {     return 1. }
false;public;0;6;;@Override public Class<ReduceFunction<T>> getStubType() {     @SuppressWarnings("unchecked")     final Class<ReduceFunction<T>> clazz = (Class<ReduceFunction<T>>) (Class<?>) ReduceFunction.class.     return clazz. }
false;public;0;4;;@Override public int getNumberOfDriverComparators() {     return 0. }
false;public;0;18;;// -------------------------------------------------------------------------------------------- @Override public void prepare() throws Exception {     final TaskConfig config = this.taskContext.getTaskConfig().     if (config.getDriverStrategy() != DriverStrategy.ALL_REDUCE) {         throw new Exception("Unrecognized driver strategy for AllReduce driver: " + config.getDriverStrategy().name()).     }     TypeSerializerFactory<T> serializerFactory = this.taskContext.getInputSerializer(0).     this.serializer = serializerFactory.getSerializer().     this.input = this.taskContext.getInput(0).     ExecutionConfig executionConfig = taskContext.getExecutionConfig().     this.objectReuseEnabled = executionConfig.isObjectReuseEnabled().     if (LOG.isDebugEnabled()) {         LOG.debug("AllReduceDriver object reuse: " + (this.objectReuseEnabled ? "ENABLED" : "DISABLED") + ".").     } }
false;public;0;51;;@Override public void run() throws Exception {     if (LOG.isDebugEnabled()) {         LOG.debug(this.taskContext.formatLogString("AllReduce preprocessing done. Running Reducer code.")).     }     final Counter numRecordsIn = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsInCounter().     final Counter numRecordsOut = this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsOutCounter().     final ReduceFunction<T> stub = this.taskContext.getStub().     final MutableObjectIterator<T> input = this.input.     final TypeSerializer<T> serializer = this.serializer.     final Collector<T> collector = new CountingCollector<>(this.taskContext.getOutputCollector(), numRecordsOut).     T val1.     if ((val1 = input.next()) == null) {         return.     }     numRecordsIn.inc().     if (objectReuseEnabled) {         // We only need two objects. The first reference stores results and is         // eventually collected. New values are read into the second.         T val2 = serializer.createInstance().         T value = val1.         while (running && (val2 = input.next(val2)) != null) {             numRecordsIn.inc().             value = stub.reduce(value, val2).             // by the user, so swap the reuse objects,             if (value == val2) {                 T tmp = val1.                 val1 = val2.                 val2 = tmp.             }         }         collector.collect(value).     } else {         T val2.         while (running && (val2 = input.next()) != null) {             numRecordsIn.inc().             val1 = stub.reduce(val1, val2).         }         collector.collect(val1).     } }
false;public;0;2;;@Override public void cleanup() { }
false;public;0;4;;@Override public void cancel() {     this.running = false. }
