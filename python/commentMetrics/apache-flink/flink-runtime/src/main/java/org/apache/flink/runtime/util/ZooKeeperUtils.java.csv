commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;62;/**  * Starts a {@link CuratorFramework} instance and connects it to the given ZooKeeper  * quorum.  *  * @param configuration {@link Configuration} object containing the configuration values  * @return {@link CuratorFramework} instance  */ ;/**  * Starts a {@link CuratorFramework} instance and connects it to the given ZooKeeper  * quorum.  *  * @param configuration {@link Configuration} object containing the configuration values  * @return {@link CuratorFramework} instance  */ public static CuratorFramework startCuratorFramework(Configuration configuration) {     Preconditions.checkNotNull(configuration, "configuration").     String zkQuorum = configuration.getValue(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM).     if (zkQuorum == null || StringUtils.isBlank(zkQuorum)) {         throw new RuntimeException("No valid ZooKeeper quorum has been specified. " + "You can specify the quorum via the configuration key '" + HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM.key() + "'.").     }     int sessionTimeout = configuration.getInteger(HighAvailabilityOptions.ZOOKEEPER_SESSION_TIMEOUT).     int connectionTimeout = configuration.getInteger(HighAvailabilityOptions.ZOOKEEPER_CONNECTION_TIMEOUT).     int retryWait = configuration.getInteger(HighAvailabilityOptions.ZOOKEEPER_RETRY_WAIT).     int maxRetryAttempts = configuration.getInteger(HighAvailabilityOptions.ZOOKEEPER_MAX_RETRY_ATTEMPTS).     String root = configuration.getValue(HighAvailabilityOptions.HA_ZOOKEEPER_ROOT).     String namespace = configuration.getValue(HighAvailabilityOptions.HA_CLUSTER_ID).     boolean disableSaslClient = configuration.getBoolean(SecurityOptions.ZOOKEEPER_SASL_DISABLE).     ACLProvider aclProvider.     ZkClientACLMode aclMode = ZkClientACLMode.fromConfig(configuration).     if (disableSaslClient && aclMode == ZkClientACLMode.CREATOR) {         String errorMessage = "Cannot set ACL role to " + aclMode + "  since SASL authentication is " + "disabled through the " + SecurityOptions.ZOOKEEPER_SASL_DISABLE.key() + " property".         LOG.warn(errorMessage).         throw new IllegalConfigurationException(errorMessage).     }     if (aclMode == ZkClientACLMode.CREATOR) {         LOG.info("Enforcing creator for ZK connections").         aclProvider = new SecureAclProvider().     } else {         LOG.info("Enforcing default ACL for ZK connections").         aclProvider = new DefaultACLProvider().     }     String rootWithNamespace = generateZookeeperPath(root, namespace).     LOG.info("Using '{}' as Zookeeper namespace.", rootWithNamespace).     CuratorFramework cf = CuratorFrameworkFactory.builder().connectString(zkQuorum).sessionTimeoutMs(sessionTimeout).connectionTimeoutMs(connectionTimeout).retryPolicy(new ExponentialBackoffRetry(retryWait, maxRetryAttempts)).namespace(rootWithNamespace.startsWith("/") ? rootWithNamespace.substring(1) : rootWithNamespace).aclProvider(aclProvider).build().     cf.start().     return cf. }
true;public,static;1;3;/**  * Returns whether {@link HighAvailabilityMode#ZOOKEEPER} is configured.  */ ;/**  * Returns whether {@link HighAvailabilityMode#ZOOKEEPER} is configured.  */ public static boolean isZooKeeperRecoveryMode(Configuration flinkConf) {     return HighAvailabilityMode.fromConfig(flinkConf).equals(HighAvailabilityMode.ZOOKEEPER). }
true;public,static;1;14;/**  * Returns the configured ZooKeeper quorum (and removes whitespace, because ZooKeeper does not  * tolerate it).  */ ;/**  * Returns the configured ZooKeeper quorum (and removes whitespace, because ZooKeeper does not  * tolerate it).  */ public static String getZooKeeperEnsemble(Configuration flinkConf) throws IllegalConfigurationException {     String zkQuorum = flinkConf.getValue(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM).     if (zkQuorum == null || StringUtils.isBlank(zkQuorum)) {         throw new IllegalConfigurationException("No ZooKeeper quorum specified in config.").     }     // Remove all whitespace     zkQuorum = zkQuorum.replaceAll("\\s+", "").     return zkQuorum. }
true;public,static;2;6;/**  * Creates a {@link ZooKeeperLeaderRetrievalService} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object containing the configuration values  * @return {@link ZooKeeperLeaderRetrievalService} instance.  * @throws Exception  */ ;/**  * Creates a {@link ZooKeeperLeaderRetrievalService} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object containing the configuration values  * @return {@link ZooKeeperLeaderRetrievalService} instance.  * @throws Exception  */ public static ZooKeeperLeaderRetrievalService createLeaderRetrievalService(final CuratorFramework client, final Configuration configuration) throws Exception {     return createLeaderRetrievalService(client, configuration, ""). }
true;public,static;3;9;/**  * Creates a {@link ZooKeeperLeaderRetrievalService} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object containing the configuration values  * @param pathSuffix    The path suffix which we want to append  * @return {@link ZooKeeperLeaderRetrievalService} instance.  * @throws Exception  */ ;/**  * Creates a {@link ZooKeeperLeaderRetrievalService} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object containing the configuration values  * @param pathSuffix    The path suffix which we want to append  * @return {@link ZooKeeperLeaderRetrievalService} instance.  * @throws Exception  */ public static ZooKeeperLeaderRetrievalService createLeaderRetrievalService(final CuratorFramework client, final Configuration configuration, final String pathSuffix) {     String leaderPath = configuration.getString(HighAvailabilityOptions.HA_ZOOKEEPER_LEADER_PATH) + pathSuffix.     return new ZooKeeperLeaderRetrievalService(client, leaderPath). }
true;public,static;2;6;/**  * Creates a {@link ZooKeeperLeaderElectionService} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object containing the configuration values  * @return {@link ZooKeeperLeaderElectionService} instance.  */ ;/**  * Creates a {@link ZooKeeperLeaderElectionService} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object containing the configuration values  * @return {@link ZooKeeperLeaderElectionService} instance.  */ public static ZooKeeperLeaderElectionService createLeaderElectionService(CuratorFramework client, Configuration configuration) throws Exception {     return createLeaderElectionService(client, configuration, ""). }
true;public,static;3;11;/**  * Creates a {@link ZooKeeperLeaderElectionService} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object containing the configuration values  * @param pathSuffix    The path suffix which we want to append  * @return {@link ZooKeeperLeaderElectionService} instance.  */ ;/**  * Creates a {@link ZooKeeperLeaderElectionService} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object containing the configuration values  * @param pathSuffix    The path suffix which we want to append  * @return {@link ZooKeeperLeaderElectionService} instance.  */ public static ZooKeeperLeaderElectionService createLeaderElectionService(final CuratorFramework client, final Configuration configuration, final String pathSuffix) {     final String latchPath = configuration.getString(HighAvailabilityOptions.HA_ZOOKEEPER_LATCH_PATH) + pathSuffix.     final String leaderPath = configuration.getString(HighAvailabilityOptions.HA_ZOOKEEPER_LEADER_PATH) + pathSuffix.     return new ZooKeeperLeaderElectionService(client, latchPath, leaderPath). }
true;public,static;2;29;/**  * Creates a {@link ZooKeeperSubmittedJobGraphStore} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object  * @return {@link ZooKeeperSubmittedJobGraphStore} instance  * @throws Exception if the submitted job graph store cannot be created  */ ;/**  * Creates a {@link ZooKeeperSubmittedJobGraphStore} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object  * @return {@link ZooKeeperSubmittedJobGraphStore} instance  * @throws Exception if the submitted job graph store cannot be created  */ public static ZooKeeperSubmittedJobGraphStore createSubmittedJobGraphs(CuratorFramework client, Configuration configuration) throws Exception {     checkNotNull(configuration, "Configuration").     RetrievableStateStorageHelper<SubmittedJobGraph> stateStorage = createFileSystemStateStorage(configuration, "submittedJobGraph").     // ZooKeeper submitted jobs root dir     String zooKeeperSubmittedJobsPath = configuration.getString(HighAvailabilityOptions.HA_ZOOKEEPER_JOBGRAPHS_PATH).     // Ensure that the job graphs path exists     client.newNamespaceAwareEnsurePath(zooKeeperSubmittedJobsPath).ensure(client.getZookeeperClient()).     // All operations will have the path as root     CuratorFramework facade = client.usingNamespace(client.getNamespace() + zooKeeperSubmittedJobsPath).     final String zooKeeperFullSubmittedJobsPath = client.getNamespace() + zooKeeperSubmittedJobsPath.     final ZooKeeperStateHandleStore<SubmittedJobGraph> zooKeeperStateHandleStore = new ZooKeeperStateHandleStore<>(facade, stateStorage).     final PathChildrenCache pathCache = new PathChildrenCache(facade, "/", false).     return new ZooKeeperSubmittedJobGraphStore(zooKeeperFullSubmittedJobsPath, zooKeeperStateHandleStore, pathCache). }
true;public,static;5;26;/**  * Creates a {@link ZooKeeperCompletedCheckpointStore} instance.  *  * @param client                         The {@link CuratorFramework} ZooKeeper client to use  * @param configuration                  {@link Configuration} object  * @param jobId                          ID of job to create the instance for  * @param maxNumberOfCheckpointsToRetain The maximum number of checkpoints to retain  * @param executor to run ZooKeeper callbacks  * @return {@link ZooKeeperCompletedCheckpointStore} instance  * @throws Exception if the completed checkpoint store cannot be created  */ ;/**  * Creates a {@link ZooKeeperCompletedCheckpointStore} instance.  *  * @param client                         The {@link CuratorFramework} ZooKeeper client to use  * @param configuration                  {@link Configuration} object  * @param jobId                          ID of job to create the instance for  * @param maxNumberOfCheckpointsToRetain The maximum number of checkpoints to retain  * @param executor to run ZooKeeper callbacks  * @return {@link ZooKeeperCompletedCheckpointStore} instance  * @throws Exception if the completed checkpoint store cannot be created  */ public static CompletedCheckpointStore createCompletedCheckpoints(CuratorFramework client, Configuration configuration, JobID jobId, int maxNumberOfCheckpointsToRetain, Executor executor) throws Exception {     checkNotNull(configuration, "Configuration").     String checkpointsPath = configuration.getString(HighAvailabilityOptions.HA_ZOOKEEPER_CHECKPOINTS_PATH).     RetrievableStateStorageHelper<CompletedCheckpoint> stateStorage = createFileSystemStateStorage(configuration, "completedCheckpoint").     checkpointsPath += ZooKeeperSubmittedJobGraphStore.getPathForJob(jobId).     final ZooKeeperCompletedCheckpointStore zooKeeperCompletedCheckpointStore = new ZooKeeperCompletedCheckpointStore(maxNumberOfCheckpointsToRetain, createZooKeeperStateHandleStore(client, checkpointsPath, stateStorage), executor).     LOG.info("Initialized {} in '{}'.", ZooKeeperCompletedCheckpointStore.class.getSimpleName(), checkpointsPath).     return zooKeeperCompletedCheckpointStore. }
true;public,static;3;6;/**  * Creates an instance of {@link ZooKeeperStateHandleStore}.  *  * @param client       ZK client  * @param path         Path to use for the client namespace  * @param stateStorage RetrievableStateStorageHelper that persist the actual state and whose  *                     returned state handle is then written to ZooKeeper  * @param <T>          Type of state  * @return {@link ZooKeeperStateHandleStore} instance  * @throws Exception ZK errors  */ ;/**  * Creates an instance of {@link ZooKeeperStateHandleStore}.  *  * @param client       ZK client  * @param path         Path to use for the client namespace  * @param stateStorage RetrievableStateStorageHelper that persist the actual state and whose  *                     returned state handle is then written to ZooKeeper  * @param <T>          Type of state  * @return {@link ZooKeeperStateHandleStore} instance  * @throws Exception ZK errors  */ public static <T extends Serializable> ZooKeeperStateHandleStore<T> createZooKeeperStateHandleStore(final CuratorFramework client, final String path, final RetrievableStateStorageHelper<T> stateStorage) throws Exception {     return new ZooKeeperStateHandleStore<>(useNamespaceAndEnsurePath(client, path), stateStorage). }
true;public,static;3;12;/**  * Creates a {@link ZooKeeperCheckpointIDCounter} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object  * @param jobId         ID of job to create the instance for  * @return {@link ZooKeeperCheckpointIDCounter} instance  */ ;/**  * Creates a {@link ZooKeeperCheckpointIDCounter} instance.  *  * @param client        The {@link CuratorFramework} ZooKeeper client to use  * @param configuration {@link Configuration} object  * @param jobId         ID of job to create the instance for  * @return {@link ZooKeeperCheckpointIDCounter} instance  */ public static ZooKeeperCheckpointIDCounter createCheckpointIDCounter(CuratorFramework client, Configuration configuration, JobID jobId) {     String checkpointIdCounterPath = configuration.getString(HighAvailabilityOptions.HA_ZOOKEEPER_CHECKPOINT_COUNTER_PATH).     checkpointIdCounterPath += ZooKeeperSubmittedJobGraphStore.getPathForJob(jobId).     return new ZooKeeperCheckpointIDCounter(client, checkpointIdCounterPath). }
true;public,static;2;13;/**  * Creates a {@link FileSystemStateStorageHelper} instance.  *  * @param configuration {@link Configuration} object  * @param prefix Prefix for the created files  * @param <T> Type of the state objects  * @return {@link FileSystemStateStorageHelper} instance  * @throws IOException if file system state storage cannot be created  */ ;/**  * Creates a {@link FileSystemStateStorageHelper} instance.  *  * @param configuration {@link Configuration} object  * @param prefix Prefix for the created files  * @param <T> Type of the state objects  * @return {@link FileSystemStateStorageHelper} instance  * @throws IOException if file system state storage cannot be created  */ public static <T extends Serializable> FileSystemStateStorageHelper<T> createFileSystemStateStorage(Configuration configuration, String prefix) throws IOException {     String rootPath = configuration.getValue(HighAvailabilityOptions.HA_STORAGE_PATH).     if (rootPath == null || StringUtils.isBlank(rootPath)) {         throw new IllegalConfigurationException("Missing high-availability storage path for metadata." + " Specify via configuration key '" + HighAvailabilityOptions.HA_STORAGE_PATH + "'.").     } else {         return new FileSystemStateStorageHelper<T>(rootPath, prefix).     } }
false;public,static;2;15;;public static String generateZookeeperPath(String root, String namespace) {     if (!namespace.startsWith("/")) {         namespace = '/' + namespace.     }     if (namespace.endsWith("/")) {         namespace = namespace.substring(0, namespace.length() - 1).     }     if (root.endsWith("/")) {         root = root.substring(0, root.length() - 1).     }     return root + namespace. }
true;public,static;2;11;/**  * Returns a facade of the client that uses the specified namespace, and ensures that all nodes  * in the path exist.  *  * @param client ZK client  * @param path the new namespace  * @return ZK Client that uses the new namespace  * @throws Exception ZK errors  */ ;/**  * Returns a facade of the client that uses the specified namespace, and ensures that all nodes  * in the path exist.  *  * @param client ZK client  * @param path the new namespace  * @return ZK Client that uses the new namespace  * @throws Exception ZK errors  */ public static CuratorFramework useNamespaceAndEnsurePath(final CuratorFramework client, final String path) throws Exception {     Preconditions.checkNotNull(client, "client must not be null").     Preconditions.checkNotNull(path, "path must not be null").     // Ensure that the checkpoints path exists     client.newNamespaceAwareEnsurePath(path).ensure(client.getZookeeperClient()).     // All operations will have the path as root     return client.usingNamespace(generateZookeeperPath(client.getNamespace(), path)). }
false;public;0;4;;@Override public List<ACL> getDefaultAcl() {     return ZooDefs.Ids.CREATOR_ALL_ACL. }
false;public;1;4;;@Override public List<ACL> getAclForPath(String path) {     return ZooDefs.Ids.CREATOR_ALL_ACL. }
true;public,static;1;12;/**  * Return the configured {@link ZkClientACLMode}.  *  * @param config The config to parse  * @return Configured ACL mode or the default defined by {@link HighAvailabilityOptions#ZOOKEEPER_CLIENT_ACL} if not  * configured.  */ ;/**  * Return the configured {@link ZkClientACLMode}.  *  * @param config The config to parse  * @return Configured ACL mode or the default defined by {@link HighAvailabilityOptions#ZOOKEEPER_CLIENT_ACL} if not  * configured.  */ public static ZkClientACLMode fromConfig(Configuration config) {     String aclMode = config.getString(HighAvailabilityOptions.ZOOKEEPER_CLIENT_ACL).     if (aclMode == null || aclMode.equalsIgnoreCase(ZkClientACLMode.OPEN.name())) {         return ZkClientACLMode.OPEN.     } else if (aclMode.equalsIgnoreCase(ZkClientACLMode.CREATOR.name())) {         return ZkClientACLMode.CREATOR.     } else {         String message = "Unsupported ACL option: [" + aclMode + "] provided".         LOG.error(message).         throw new IllegalConfigurationException(message).     } }
