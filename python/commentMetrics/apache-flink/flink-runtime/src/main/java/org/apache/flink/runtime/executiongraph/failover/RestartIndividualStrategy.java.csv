commented;modifiers;parameterAmount;loc;comment;code
false;public;2;26;;// ------------------------------------------------------------------------ @Override public void onTaskFailure(Execution taskExecution, Throwable cause) {     executionGraph.getJobMasterMainThreadExecutor().assertRunningInMainThread().     // make failures due to missing resources global failures     if (cause instanceof NoResourceAvailableException) {         LOG.info("Not enough resources to schedule {} - triggering full recovery.", taskExecution).         executionGraph.failGlobal(cause).         return.     }     LOG.info("Recovering task failure for {} (#{}) via individual restart.", taskExecution.getVertex().getTaskNameWithSubtaskIndex(), taskExecution.getAttemptNumber()).     numTaskFailures.inc().     // trigger the restart once the task has reached its terminal state     // Note: currently all tasks passed here are already in their terminal state,     // so we could actually avoid the future. We use it anyways because it is cheap and     // it helps to support better testing     final CompletableFuture<ExecutionState> terminationFuture = taskExecution.getTerminalStateFuture().     terminationFuture.thenRun(() -> performExecutionVertexRestart(taskExecution.getVertex(), taskExecution.getGlobalModVersion())). }
false;protected;2;14;;protected void performExecutionVertexRestart(ExecutionVertex vertexToRecover, long globalModVersion) {     try {         long createTimestamp = System.currentTimeMillis().         Execution newExecution = vertexToRecover.resetForNewExecution(createTimestamp, globalModVersion).         newExecution.scheduleForExecution().     } catch (GlobalModVersionMismatch e) {     // this happens if a concurrent global recovery happens. simply do nothing.     } catch (Exception e) {         executionGraph.failGlobal(new Exception("Error during fine grained recovery - triggering full recovery", e)).     } }
false;public;1;14;;@Override public void notifyNewVertices(List<ExecutionJobVertex> newJobVerticesTopological) {     // any other vertices     for (ExecutionJobVertex ejv : newJobVerticesTopological) {         List<IntermediateResult> inputs = ejv.getInputs().         IntermediateResult[] outputs = ejv.getProducedDataSets().         if ((inputs != null && inputs.size() > 0) || (outputs != null && outputs.length > 0)) {             throw new FlinkRuntimeException("Incompatible failover strategy - strategy '" + getStrategyName() + "' can only handle jobs with only disconnected tasks.").         }     } }
false;public;0;4;;@Override public String getStrategyName() {     return "Individual Task Restart". }
false;public;1;4;;@Override public void registerMetrics(MetricGroup metricGroup) {     metricGroup.counter("task_failures", numTaskFailures). }
false;public;1;4;;@Override public RestartIndividualStrategy create(ExecutionGraph executionGraph) {     return new RestartIndividualStrategy(executionGraph). }
