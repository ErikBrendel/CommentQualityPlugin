commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;// ------------------------------------------------------------------------ // Properties // ------------------------------------------------------------------------ int getChannelIndex() {     return channelIndex. }
false;public;0;3;;public ResultPartitionID getPartitionId() {     return partitionId. }
true;protected;0;3;/**  * Notifies the owning {@link SingleInputGate} that this channel became non-empty.  *  * <p>This is guaranteed to be called only when a Buffer was added to a previously  * empty input channel. The notion of empty is atomically consistent with the flag  * {@link BufferAndAvailability#moreAvailable()} when polling the next buffer  * from this channel.  *  * <p><b>Note:</b> When the input channel observes an exception, this  * method is called regardless of whether the channel was empty before. That ensures  * that the parent InputGate will always be notified about the exception.  */ ;/**  * Notifies the owning {@link SingleInputGate} that this channel became non-empty.  *  * <p>This is guaranteed to be called only when a Buffer was added to a previously  * empty input channel. The notion of empty is atomically consistent with the flag  * {@link BufferAndAvailability#moreAvailable()} when polling the next buffer  * from this channel.  *  * <p><b>Note:</b> When the input channel observes an exception, this  * method is called regardless of whether the channel was empty before. That ensures  * that the parent InputGate will always be notified about the exception.  */ protected void notifyChannelNonEmpty() {     inputGate.notifyChannelNonEmpty(this). }
true;abstract;1;1;/**  * Requests the queue with the specified index of the source intermediate  * result partition.  *  * <p>The queue index to request depends on which sub task the channel belongs  * to and is specified by the consumer of this channel.  */ ;// ------------------------------------------------------------------------ // Consume // ------------------------------------------------------------------------ /**  * Requests the queue with the specified index of the source intermediate  * result partition.  *  * <p>The queue index to request depends on which sub task the channel belongs  * to and is specified by the consumer of this channel.  */ abstract void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException.
true;abstract;0;1;/**  * Returns the next buffer from the consumed subpartition or {@code Optional.empty()} if there is no data to return.  */ ;/**  * Returns the next buffer from the consumed subpartition or {@code Optional.empty()} if there is no data to return.  */ abstract Optional<BufferAndAvailability> getNextBuffer() throws IOException, InterruptedException.
true;abstract;1;1;/**  * Sends a {@link TaskEvent} back to the task producing the consumed result partition.  *  * <p><strong>Important</strong>: The producing task has to be running to receive backwards events.  * This means that the result type needs to be pipelined and the task logic has to ensure that  * the producer will wait for all backwards events. Otherwise, this will lead to an Exception  * at runtime.  */ ;// ------------------------------------------------------------------------ // Task events // ------------------------------------------------------------------------ /**  * Sends a {@link TaskEvent} back to the task producing the consumed result partition.  *  * <p><strong>Important</strong>: The producing task has to be running to receive backwards events.  * This means that the result type needs to be pipelined and the task logic has to ensure that  * the producer will wait for all backwards events. Otherwise, this will lead to an Exception  * at runtime.  */ abstract void sendTaskEvent(TaskEvent event) throws IOException.
false;abstract;0;1;;// ------------------------------------------------------------------------ // Life cycle // ------------------------------------------------------------------------ abstract boolean isReleased().
false;abstract;0;1;;abstract void notifySubpartitionConsumed() throws IOException.
true;abstract;0;1;/**  * Releases all resources of the channel.  */ ;/**  * Releases all resources of the channel.  */ abstract void releaseAllResources() throws IOException.
true;protected;0;15;/**  * Checks for an error and rethrows it if one was reported.  */ ;// ------------------------------------------------------------------------ // Error notification // ------------------------------------------------------------------------ /**  * Checks for an error and rethrows it if one was reported.  */ protected void checkError() throws IOException {     final Throwable t = cause.get().     if (t != null) {         if (t instanceof CancelTaskException) {             throw (CancelTaskException) t.         }         if (t instanceof IOException) {             throw (IOException) t.         } else {             throw new IOException(t).         }     } }
true;protected;1;6;/**  * Atomically sets an error for this channel and notifies the input gate about available data to  * trigger querying this channel by the task thread.  */ ;/**  * Atomically sets an error for this channel and notifies the input gate about available data to  * trigger querying this channel by the task thread.  */ protected void setError(Throwable cause) {     if (this.cause.compareAndSet(null, checkNotNull(cause))) {         // Notify the input gate.         notifyChannelNonEmpty().     } }
true;protected;0;3;/**  * Returns the current backoff in ms.  */ ;// ------------------------------------------------------------------------ // Partition request exponential backoff // ------------------------------------------------------------------------ /**  * Returns the current backoff in ms.  */ protected int getCurrentBackoff() {     return currentBackoff <= 0 ? 0 : currentBackoff. }
true;protected;0;23;/**  * Increases the current backoff and returns whether the operation was successful.  *  * @return <code>true</code>, iff the operation was successful. Otherwise, <code>false</code>.  */ ;/**  * Increases the current backoff and returns whether the operation was successful.  *  * @return <code>true</code>, iff the operation was successful. Otherwise, <code>false</code>.  */ protected boolean increaseBackoff() {     // Backoff is disabled     if (currentBackoff < 0) {         return false.     }     // This is the first time backing off     if (currentBackoff == 0) {         currentBackoff = initialBackoff.         return true.     } else // Continue backing off     if (currentBackoff < maxBackoff) {         currentBackoff = Math.min(currentBackoff * 2, maxBackoff).         return true.     }     // Reached maximum backoff     return false. }
false;public;0;3;;public Buffer buffer() {     return buffer. }
false;public;0;3;;public boolean moreAvailable() {     return moreAvailable. }
false;public;0;3;;public int buffersInBacklog() {     return buffersInBacklog. }
