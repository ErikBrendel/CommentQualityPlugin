# id;timestamp;commentText;codeText;commentWords;codeWords
ArchivedExecutionGraph -> @Override 	public Map<ExecutionAttemptID, Map<AccumulatorRegistry.Metric, Accumulator<?, ?>>> getFlinkAccumulators();1476446128;Gets the internal flink accumulator map of maps which contains some metrics.__@return A map of accumulators for every executed task.;@Override_	public Map<ExecutionAttemptID, Map<AccumulatorRegistry.Metric, Accumulator<?, ?>>> getFlinkAccumulators() {_		Map<ExecutionAttemptID, Map<AccumulatorRegistry.Metric, Accumulator<?, ?>>> flinkAccumulators =_			new HashMap<>()___		for (AccessExecutionVertex vertex : getAllExecutionVertices()) {_			Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> taskAccs = vertex.getCurrentExecutionAttempt().getFlinkAccumulators()__			flinkAccumulators.put(vertex.getCurrentExecutionAttempt().getAttemptId(), taskAccs)__		}__		return flinkAccumulators__	};gets,the,internal,flink,accumulator,map,of,maps,which,contains,some,metrics,return,a,map,of,accumulators,for,every,executed,task;override,public,map,execution,attempt,id,map,accumulator,registry,metric,accumulator,get,flink,accumulators,map,execution,attempt,id,map,accumulator,registry,metric,accumulator,flink,accumulators,new,hash,map,for,access,execution,vertex,vertex,get,all,execution,vertices,map,accumulator,registry,metric,accumulator,task,accs,vertex,get,current,execution,attempt,get,flink,accumulators,flink,accumulators,put,vertex,get,current,execution,attempt,get,attempt,id,task,accs,return,flink,accumulators
ArchivedExecutionGraph -> @Override 	public Map<ExecutionAttemptID, Map<AccumulatorRegistry.Metric, Accumulator<?, ?>>> getFlinkAccumulators();1477645452;Gets the internal flink accumulator map of maps which contains some metrics.__@return A map of accumulators for every executed task.;@Override_	public Map<ExecutionAttemptID, Map<AccumulatorRegistry.Metric, Accumulator<?, ?>>> getFlinkAccumulators() {_		Map<ExecutionAttemptID, Map<AccumulatorRegistry.Metric, Accumulator<?, ?>>> flinkAccumulators =_			new HashMap<>()___		for (AccessExecutionVertex vertex : getAllExecutionVertices()) {_			Map<AccumulatorRegistry.Metric, Accumulator<?, ?>> taskAccs = vertex.getCurrentExecutionAttempt().getFlinkAccumulators()__			flinkAccumulators.put(vertex.getCurrentExecutionAttempt().getAttemptId(), taskAccs)__		}__		return flinkAccumulators__	};gets,the,internal,flink,accumulator,map,of,maps,which,contains,some,metrics,return,a,map,of,accumulators,for,every,executed,task;override,public,map,execution,attempt,id,map,accumulator,registry,metric,accumulator,get,flink,accumulators,map,execution,attempt,id,map,accumulator,registry,metric,accumulator,flink,accumulators,new,hash,map,for,access,execution,vertex,vertex,get,all,execution,vertices,map,accumulator,registry,metric,accumulator,task,accs,vertex,get,current,execution,attempt,get,flink,accumulators,flink,accumulators,put,vertex,get,current,execution,attempt,get,attempt,id,task,accs,return,flink,accumulators
ArchivedExecutionGraph -> public static ArchivedExecutionGraph createFrom(ExecutionGraph executionGraph);1516970986;Create a {@link ArchivedExecutionGraph} from the given {@link ExecutionGraph}.__@param executionGraph to create the ArchivedExecutionGraph from_@return ArchivedExecutionGraph created from the given ExecutionGraph;public static ArchivedExecutionGraph createFrom(ExecutionGraph executionGraph) {_		final int numberVertices = executionGraph.getTotalNumberOfVertices()___		Map<JobVertexID, ArchivedExecutionJobVertex> archivedTasks = new HashMap<>(numberVertices)__		List<ArchivedExecutionJobVertex> archivedVerticesInCreationOrder = new ArrayList<>(numberVertices)___		for (ExecutionJobVertex task : executionGraph.getVerticesTopologically()) {_			ArchivedExecutionJobVertex archivedTask = task.archive()__			archivedVerticesInCreationOrder.add(archivedTask)__			archivedTasks.put(task.getJobVertexId(), archivedTask)__		}__		final Map<String, SerializedValue<Object>> serializedUserAccumulators = executionGraph.getAccumulatorsSerialized()___		final long[] timestamps = new long[JobStatus.values().length]___		for (JobStatus jobStatus : JobStatus.values()) {_			final int ordinal = jobStatus.ordinal()__			timestamps[ordinal] = executionGraph.getStatusTimestamp(jobStatus)__		}__		return new ArchivedExecutionGraph(_			executionGraph.getJobID(),_			executionGraph.getJobName(),_			archivedTasks,_			archivedVerticesInCreationOrder,_			timestamps,_			executionGraph.getState(),_			executionGraph.getFailureInfo(),_			executionGraph.getJsonPlan(),_			executionGraph.getAccumulatorResultsStringified(),_			serializedUserAccumulators,_			executionGraph.getArchivedExecutionConfig(),_			executionGraph.isStoppable(),_			executionGraph.getCheckpointCoordinatorConfiguration(),_			executionGraph.getCheckpointStatsSnapshot())__	};create,a,link,archived,execution,graph,from,the,given,link,execution,graph,param,execution,graph,to,create,the,archived,execution,graph,from,return,archived,execution,graph,created,from,the,given,execution,graph;public,static,archived,execution,graph,create,from,execution,graph,execution,graph,final,int,number,vertices,execution,graph,get,total,number,of,vertices,map,job,vertex,id,archived,execution,job,vertex,archived,tasks,new,hash,map,number,vertices,list,archived,execution,job,vertex,archived,vertices,in,creation,order,new,array,list,number,vertices,for,execution,job,vertex,task,execution,graph,get,vertices,topologically,archived,execution,job,vertex,archived,task,task,archive,archived,vertices,in,creation,order,add,archived,task,archived,tasks,put,task,get,job,vertex,id,archived,task,final,map,string,serialized,value,object,serialized,user,accumulators,execution,graph,get,accumulators,serialized,final,long,timestamps,new,long,job,status,values,length,for,job,status,job,status,job,status,values,final,int,ordinal,job,status,ordinal,timestamps,ordinal,execution,graph,get,status,timestamp,job,status,return,new,archived,execution,graph,execution,graph,get,job,id,execution,graph,get,job,name,archived,tasks,archived,vertices,in,creation,order,timestamps,execution,graph,get,state,execution,graph,get,failure,info,execution,graph,get,json,plan,execution,graph,get,accumulator,results,stringified,serialized,user,accumulators,execution,graph,get,archived,execution,config,execution,graph,is,stoppable,execution,graph,get,checkpoint,coordinator,configuration,execution,graph,get,checkpoint,stats,snapshot
ArchivedExecutionGraph -> public static ArchivedExecutionGraph createFrom(ExecutionGraph executionGraph);1522049585;Create a {@link ArchivedExecutionGraph} from the given {@link ExecutionGraph}.__@param executionGraph to create the ArchivedExecutionGraph from_@return ArchivedExecutionGraph created from the given ExecutionGraph;public static ArchivedExecutionGraph createFrom(ExecutionGraph executionGraph) {_		final int numberVertices = executionGraph.getTotalNumberOfVertices()___		Map<JobVertexID, ArchivedExecutionJobVertex> archivedTasks = new HashMap<>(numberVertices)__		List<ArchivedExecutionJobVertex> archivedVerticesInCreationOrder = new ArrayList<>(numberVertices)___		for (ExecutionJobVertex task : executionGraph.getVerticesTopologically()) {_			ArchivedExecutionJobVertex archivedTask = task.archive()__			archivedVerticesInCreationOrder.add(archivedTask)__			archivedTasks.put(task.getJobVertexId(), archivedTask)__		}__		final Map<String, SerializedValue<Object>> serializedUserAccumulators = executionGraph.getAccumulatorsSerialized()___		final long[] timestamps = new long[JobStatus.values().length]___		for (JobStatus jobStatus : JobStatus.values()) {_			final int ordinal = jobStatus.ordinal()__			timestamps[ordinal] = executionGraph.getStatusTimestamp(jobStatus)__		}__		return new ArchivedExecutionGraph(_			executionGraph.getJobID(),_			executionGraph.getJobName(),_			archivedTasks,_			archivedVerticesInCreationOrder,_			timestamps,_			executionGraph.getState(),_			executionGraph.getFailureInfo(),_			executionGraph.getJsonPlan(),_			executionGraph.getAccumulatorResultsStringified(),_			serializedUserAccumulators,_			executionGraph.getArchivedExecutionConfig(),_			executionGraph.isStoppable(),_			executionGraph.getCheckpointCoordinatorConfiguration(),_			executionGraph.getCheckpointStatsSnapshot())__	};create,a,link,archived,execution,graph,from,the,given,link,execution,graph,param,execution,graph,to,create,the,archived,execution,graph,from,return,archived,execution,graph,created,from,the,given,execution,graph;public,static,archived,execution,graph,create,from,execution,graph,execution,graph,final,int,number,vertices,execution,graph,get,total,number,of,vertices,map,job,vertex,id,archived,execution,job,vertex,archived,tasks,new,hash,map,number,vertices,list,archived,execution,job,vertex,archived,vertices,in,creation,order,new,array,list,number,vertices,for,execution,job,vertex,task,execution,graph,get,vertices,topologically,archived,execution,job,vertex,archived,task,task,archive,archived,vertices,in,creation,order,add,archived,task,archived,tasks,put,task,get,job,vertex,id,archived,task,final,map,string,serialized,value,object,serialized,user,accumulators,execution,graph,get,accumulators,serialized,final,long,timestamps,new,long,job,status,values,length,for,job,status,job,status,job,status,values,final,int,ordinal,job,status,ordinal,timestamps,ordinal,execution,graph,get,status,timestamp,job,status,return,new,archived,execution,graph,execution,graph,get,job,id,execution,graph,get,job,name,archived,tasks,archived,vertices,in,creation,order,timestamps,execution,graph,get,state,execution,graph,get,failure,info,execution,graph,get,json,plan,execution,graph,get,accumulator,results,stringified,serialized,user,accumulators,execution,graph,get,archived,execution,config,execution,graph,is,stoppable,execution,graph,get,checkpoint,coordinator,configuration,execution,graph,get,checkpoint,stats,snapshot
ArchivedExecutionGraph -> public static ArchivedExecutionGraph createFrom(ExecutionGraph executionGraph);1522049586;Create a {@link ArchivedExecutionGraph} from the given {@link ExecutionGraph}.__@param executionGraph to create the ArchivedExecutionGraph from_@return ArchivedExecutionGraph created from the given ExecutionGraph;public static ArchivedExecutionGraph createFrom(ExecutionGraph executionGraph) {_		final int numberVertices = executionGraph.getTotalNumberOfVertices()___		Map<JobVertexID, ArchivedExecutionJobVertex> archivedTasks = new HashMap<>(numberVertices)__		List<ArchivedExecutionJobVertex> archivedVerticesInCreationOrder = new ArrayList<>(numberVertices)___		for (ExecutionJobVertex task : executionGraph.getVerticesTopologically()) {_			ArchivedExecutionJobVertex archivedTask = task.archive()__			archivedVerticesInCreationOrder.add(archivedTask)__			archivedTasks.put(task.getJobVertexId(), archivedTask)__		}__		final Map<String, SerializedValue<OptionalFailure<Object>>> serializedUserAccumulators =_			executionGraph.getAccumulatorsSerialized()___		final long[] timestamps = new long[JobStatus.values().length]___		for (JobStatus jobStatus : JobStatus.values()) {_			final int ordinal = jobStatus.ordinal()__			timestamps[ordinal] = executionGraph.getStatusTimestamp(jobStatus)__		}__		return new ArchivedExecutionGraph(_			executionGraph.getJobID(),_			executionGraph.getJobName(),_			archivedTasks,_			archivedVerticesInCreationOrder,_			timestamps,_			executionGraph.getState(),_			executionGraph.getFailureInfo(),_			executionGraph.getJsonPlan(),_			executionGraph.getAccumulatorResultsStringified(),_			serializedUserAccumulators,_			executionGraph.getArchivedExecutionConfig(),_			executionGraph.isStoppable(),_			executionGraph.getCheckpointCoordinatorConfiguration(),_			executionGraph.getCheckpointStatsSnapshot())__	};create,a,link,archived,execution,graph,from,the,given,link,execution,graph,param,execution,graph,to,create,the,archived,execution,graph,from,return,archived,execution,graph,created,from,the,given,execution,graph;public,static,archived,execution,graph,create,from,execution,graph,execution,graph,final,int,number,vertices,execution,graph,get,total,number,of,vertices,map,job,vertex,id,archived,execution,job,vertex,archived,tasks,new,hash,map,number,vertices,list,archived,execution,job,vertex,archived,vertices,in,creation,order,new,array,list,number,vertices,for,execution,job,vertex,task,execution,graph,get,vertices,topologically,archived,execution,job,vertex,archived,task,task,archive,archived,vertices,in,creation,order,add,archived,task,archived,tasks,put,task,get,job,vertex,id,archived,task,final,map,string,serialized,value,optional,failure,object,serialized,user,accumulators,execution,graph,get,accumulators,serialized,final,long,timestamps,new,long,job,status,values,length,for,job,status,job,status,job,status,values,final,int,ordinal,job,status,ordinal,timestamps,ordinal,execution,graph,get,status,timestamp,job,status,return,new,archived,execution,graph,execution,graph,get,job,id,execution,graph,get,job,name,archived,tasks,archived,vertices,in,creation,order,timestamps,execution,graph,get,state,execution,graph,get,failure,info,execution,graph,get,json,plan,execution,graph,get,accumulator,results,stringified,serialized,user,accumulators,execution,graph,get,archived,execution,config,execution,graph,is,stoppable,execution,graph,get,checkpoint,coordinator,configuration,execution,graph,get,checkpoint,stats,snapshot
