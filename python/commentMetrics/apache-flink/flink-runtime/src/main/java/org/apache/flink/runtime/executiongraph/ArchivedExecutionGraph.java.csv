commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public String getJsonPlan() {     return jsonPlan. }
false;public;0;4;;@Override public JobID getJobID() {     return jobID. }
false;public;0;4;;@Override public String getJobName() {     return jobName. }
false;public;0;4;;@Override public JobStatus getState() {     return state. }
false;public;0;5;;@Nullable @Override public ErrorInfo getFailureInfo() {     return failureCause. }
false;public;1;4;;@Override public ArchivedExecutionJobVertex getJobVertex(JobVertexID id) {     return this.tasks.get(id). }
false;public;0;4;;@Override public Map<JobVertexID, AccessExecutionJobVertex> getAllVertices() {     return Collections.<JobVertexID, AccessExecutionJobVertex>unmodifiableMap(this.tasks). }
false;public;0;4;;@Override public boolean hasNext() {     return pos < numElements. }
false;public;0;8;;@Override public ArchivedExecutionJobVertex next() {     if (hasNext()) {         return verticesInCreationOrder.get(pos++).     } else {         throw new NoSuchElementException().     } }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;25;;@Override public Iterator<ArchivedExecutionJobVertex> iterator() {     return new Iterator<ArchivedExecutionJobVertex>() {          private int pos = 0.          @Override         public boolean hasNext() {             return pos < numElements.         }          @Override         public ArchivedExecutionJobVertex next() {             if (hasNext()) {                 return verticesInCreationOrder.get(pos++).             } else {                 throw new NoSuchElementException().             }         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }. }
false;public;0;34;;@Override public Iterable<ArchivedExecutionJobVertex> getVerticesTopologically() {     // we return a specific iterator that does not fail with concurrent modifications     // the list is append only, so it is safe for that     final int numElements = this.verticesInCreationOrder.size().     return new Iterable<ArchivedExecutionJobVertex>() {          @Override         public Iterator<ArchivedExecutionJobVertex> iterator() {             return new Iterator<ArchivedExecutionJobVertex>() {                  private int pos = 0.                  @Override                 public boolean hasNext() {                     return pos < numElements.                 }                  @Override                 public ArchivedExecutionJobVertex next() {                     if (hasNext()) {                         return verticesInCreationOrder.get(pos++).                     } else {                         throw new NoSuchElementException().                     }                 }                  @Override                 public void remove() {                     throw new UnsupportedOperationException().                 }             }.         }     }. }
false;public;0;4;;@Override public Iterator<ArchivedExecutionVertex> iterator() {     return new AllVerticesIterator(getVerticesTopologically().iterator()). }
false;public;0;9;;@Override public Iterable<ArchivedExecutionVertex> getAllExecutionVertices() {     return new Iterable<ArchivedExecutionVertex>() {          @Override         public Iterator<ArchivedExecutionVertex> iterator() {             return new AllVerticesIterator(getVerticesTopologically().iterator()).         }     }. }
false;public;1;4;;@Override public long getStatusTimestamp(JobStatus status) {     return this.stateTimestamps[status.ordinal()]. }
false;public;0;4;;@Override public CheckpointCoordinatorConfiguration getCheckpointCoordinatorConfiguration() {     return jobCheckpointingConfiguration. }
false;public;0;4;;@Override public CheckpointStatsSnapshot getCheckpointStatsSnapshot() {     return checkpointStatsSnapshot. }
false;public;0;4;;@Override public boolean isArchived() {     return true. }
false;public;0;4;;@Override public ArchivedExecutionConfig getArchivedExecutionConfig() {     return archivedExecutionConfig. }
false;public;0;4;;@Override public boolean isStoppable() {     return isStoppable. }
false;public;0;4;;@Override public StringifiedAccumulatorResult[] getAccumulatorResultsStringified() {     return archivedUserAccumulators. }
false;public;0;4;;@Override public Map<String, SerializedValue<OptionalFailure<Object>>> getAccumulatorsSerialized() {     return serializedUserAccumulators. }
false;public;0;17;;@Override public boolean hasNext() {     while (true) {         if (currVertices != null) {             if (currPos < currVertices.length) {                 return true.             } else {                 currVertices = null.             }         } else if (jobVertices.hasNext()) {             currVertices = jobVertices.next().getTaskVertices().             currPos = 0.         } else {             return false.         }     } }
false;public;0;8;;@Override public ArchivedExecutionVertex next() {     if (hasNext()) {         return currVertices[currPos++].     } else {         throw new NoSuchElementException().     } }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
true;public,static;1;38;/**  * Create a {@link ArchivedExecutionGraph} from the given {@link ExecutionGraph}.  *  * @param executionGraph to create the ArchivedExecutionGraph from  * @return ArchivedExecutionGraph created from the given ExecutionGraph  */ ;/**  * Create a {@link ArchivedExecutionGraph} from the given {@link ExecutionGraph}.  *  * @param executionGraph to create the ArchivedExecutionGraph from  * @return ArchivedExecutionGraph created from the given ExecutionGraph  */ public static ArchivedExecutionGraph createFrom(ExecutionGraph executionGraph) {     final int numberVertices = executionGraph.getTotalNumberOfVertices().     Map<JobVertexID, ArchivedExecutionJobVertex> archivedTasks = new HashMap<>(numberVertices).     List<ArchivedExecutionJobVertex> archivedVerticesInCreationOrder = new ArrayList<>(numberVertices).     for (ExecutionJobVertex task : executionGraph.getVerticesTopologically()) {         ArchivedExecutionJobVertex archivedTask = task.archive().         archivedVerticesInCreationOrder.add(archivedTask).         archivedTasks.put(task.getJobVertexId(), archivedTask).     }     final Map<String, SerializedValue<OptionalFailure<Object>>> serializedUserAccumulators = executionGraph.getAccumulatorsSerialized().     final long[] timestamps = new long[JobStatus.values().length].     for (JobStatus jobStatus : JobStatus.values()) {         final int ordinal = jobStatus.ordinal().         timestamps[ordinal] = executionGraph.getStatusTimestamp(jobStatus).     }     return new ArchivedExecutionGraph(executionGraph.getJobID(), executionGraph.getJobName(), archivedTasks, archivedVerticesInCreationOrder, timestamps, executionGraph.getState(), executionGraph.getFailureInfo(), executionGraph.getJsonPlan(), executionGraph.getAccumulatorResultsStringified(), serializedUserAccumulators, executionGraph.getArchivedExecutionConfig(), executionGraph.isStoppable(), executionGraph.getCheckpointCoordinatorConfiguration(), executionGraph.getCheckpointStatsSnapshot()). }
