commented;modifiers;parameterAmount;loc;comment;code
true;;1;16;/**  * Assigns exclusive buffers to this input channel, and this method should be called only once  * after this input channel is created.  */ ;/**  * Assigns exclusive buffers to this input channel, and this method should be called only once  * after this input channel is created.  */ void assignExclusiveSegments(List<MemorySegment> segments) {     checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " + "already been set for this input channel.").     checkNotNull(segments).     checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.").     this.initialCredit = segments.size().     this.numRequiredBuffers = segments.size().     synchronized (bufferQueue) {         for (MemorySegment segment : segments) {             bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers).         }     } }
true;public;1;11;/**  * Requests a remote subpartition.  */ ;// ------------------------------------------------------------------------ // Consume // ------------------------------------------------------------------------ /**  * Requests a remote subpartition.  */ @VisibleForTesting @Override public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {     if (partitionRequestClient == null) {         // Create a client and request the partition         partitionRequestClient = connectionManager.createPartitionRequestClient(connectionId).         partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0).     } }
true;;1;10;/**  * Retriggers a remote subpartition request.  */ ;/**  * Retriggers a remote subpartition request.  */ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {     checkState(partitionRequestClient != null, "Missing initial subpartition request.").     if (increaseBackoff()) {         partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, getCurrentBackoff()).     } else {         failPartitionRequest().     } }
false;;0;19;;@Override Optional<BufferAndAvailability> getNextBuffer() throws IOException {     checkState(!isReleased.get(), "Queried for a buffer after channel has been closed.").     checkState(partitionRequestClient != null, "Queried for a buffer before requesting a queue.").     checkError().     final Buffer next.     final boolean moreAvailable.     synchronized (receivedBuffers) {         next = receivedBuffers.poll().         moreAvailable = !receivedBuffers.isEmpty().     }     numBytesIn.inc(next.getSizeUnsafe()).     numBuffersIn.inc().     return Optional.of(new BufferAndAvailability(next, moreAvailable, getSenderBacklog())). }
false;;1;9;;// ------------------------------------------------------------------------ // Task events // ------------------------------------------------------------------------ @Override void sendTaskEvent(TaskEvent event) throws IOException {     checkState(!isReleased.get(), "Tried to send task event to producer after channel has been released.").     checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.").     checkError().     partitionRequestClient.sendTaskEvent(partitionId, event, this). }
false;public;0;4;;// ------------------------------------------------------------------------ // Life cycle // ------------------------------------------------------------------------ @Override public boolean isReleased() {     return isReleased.get(). }
false;;0;4;;@Override void notifySubpartitionConsumed() { // Nothing to do }
true;;0;35;/**  * Releases all exclusive and floating buffers, closes the partition request client.  */ ;/**  * Releases all exclusive and floating buffers, closes the partition request client.  */ @Override void releaseAllResources() throws IOException {     if (isReleased.compareAndSet(false, true)) {         // Gather all exclusive buffers and recycle them to global pool in batch, because         // we do not want to trigger redistribution of buffers after each recycle.         final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>().         synchronized (receivedBuffers) {             Buffer buffer.             while ((buffer = receivedBuffers.poll()) != null) {                 if (buffer.getRecycler() == this) {                     exclusiveRecyclingSegments.add(buffer.getMemorySegment()).                 } else {                     buffer.recycleBuffer().                 }             }         }         synchronized (bufferQueue) {             bufferQueue.releaseAll(exclusiveRecyclingSegments).         }         if (exclusiveRecyclingSegments.size() > 0) {             inputGate.returnExclusiveSegments(exclusiveRecyclingSegments).         }         // buffers received concurrently with closing are properly recycled.         if (partitionRequestClient != null) {             partitionRequestClient.close(this).         } else {             connectionManager.closeOpenChannelConnections(connectionId).         }     } }
false;private;0;3;;private void failPartitionRequest() {     setError(new PartitionNotFoundException(partitionId)). }
false;public;0;4;;@Override public String toString() {     return "RemoteInputChannel [" + partitionId + " at " + connectionId + "]". }
true;private;0;5;/**  * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.  */ ;// ------------------------------------------------------------------------ // Credit-based // ------------------------------------------------------------------------ /**  * Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.  */ private void notifyCreditAvailable() {     checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.").     partitionRequestClient.notifyCreditAvailable(this). }
true;public;1;22;/**  * Exclusive buffer is recycled to this input channel directly and it may trigger return extra  * floating buffer and notify increased credit to the producer.  *  * @param segment The exclusive segment of this channel.  */ ;/**  * Exclusive buffer is recycled to this input channel directly and it may trigger return extra  * floating buffer and notify increased credit to the producer.  *  * @param segment The exclusive segment of this channel.  */ @Override public void recycle(MemorySegment segment) {     int numAddedBuffers.     synchronized (bufferQueue) {         // after releaseAllResources() released all buffers (see below for details).         if (isReleased.get()) {             try {                 inputGate.returnExclusiveSegments(Collections.singletonList(segment)).                 return.             } catch (Throwable t) {                 ExceptionUtils.rethrow(t).             }         }         numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers).     }     if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {         notifyCreditAvailable().     } }
false;public;0;5;;public int getNumberOfAvailableBuffers() {     synchronized (bufferQueue) {         return bufferQueue.getAvailableBufferSize().     } }
false;public;0;3;;public int getNumberOfRequiredBuffers() {     return numRequiredBuffers. }
false;public;0;3;;public int getSenderBacklog() {     return numRequiredBuffers - initialCredit. }
false;;0;4;;@VisibleForTesting boolean isWaitingForFloatingBuffers() {     return isWaitingForFloatingBuffers. }
true;public;1;38;/**  * The Buffer pool notifies this channel of an available floating buffer. If the channel is released or  * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,  * the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased  * by one.  *  * @param buffer Buffer that becomes available in buffer pool.  * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for  *  	more floating buffers.  */ ;/**  * The Buffer pool notifies this channel of an available floating buffer. If the channel is released or  * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,  * the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased  * by one.  *  * @param buffer Buffer that becomes available in buffer pool.  * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for  *  	more floating buffers.  */ @Override public NotificationResult notifyBufferAvailable(Buffer buffer) {     NotificationResult notificationResult = NotificationResult.BUFFER_NOT_USED.     try {         synchronized (bufferQueue) {             checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.").             // lock on bufferQueue to release buffers             if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {                 isWaitingForFloatingBuffers = false.                 return notificationResult.             }             bufferQueue.addFloatingBuffer(buffer).             if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {                 isWaitingForFloatingBuffers = false.                 notificationResult = NotificationResult.BUFFER_USED_NO_NEED_MORE.             } else {                 notificationResult = NotificationResult.BUFFER_USED_NEED_MORE.             }         }         if (unannouncedCredit.getAndAdd(1) == 0) {             notifyCreditAvailable().         }     } catch (Throwable t) {         setError(t).     }     return notificationResult. }
false;public;0;4;;@Override public void notifyBufferDestroyed() { // Nothing to do actually. }
true;public;0;3;/**  * Gets the currently unannounced credit.  *  * @return Credit which was not announced to the sender yet.  */ ;// ------------------------------------------------------------------------ // Network I/O notifications (called by network I/O thread) // ------------------------------------------------------------------------ /**  * Gets the currently unannounced credit.  *  * @return Credit which was not announced to the sender yet.  */ public int getUnannouncedCredit() {     return unannouncedCredit.get(). }
true;public;0;3;/**  * Gets the unannounced credit and resets it to <tt>0</tt> atomically.  *  * @return Credit which was not announced to the sender yet.  */ ;/**  * Gets the unannounced credit and resets it to <tt>0</tt> atomically.  *  * @return Credit which was not announced to the sender yet.  */ public int getAndResetUnannouncedCredit() {     return unannouncedCredit.getAndSet(0). }
true;public;0;5;/**  * Gets the current number of received buffers which have not been processed yet.  *  * @return Buffers queued for processing.  */ ;/**  * Gets the current number of received buffers which have not been processed yet.  *  * @return Buffers queued for processing.  */ public int getNumberOfQueuedBuffers() {     synchronized (receivedBuffers) {         return receivedBuffers.size().     } }
false;public;0;3;;public int unsynchronizedGetNumberOfQueuedBuffers() {     return Math.max(0, receivedBuffers.size()). }
false;public;0;3;;public InputChannelID getInputChannelId() {     return id. }
false;public;0;3;;public int getInitialCredit() {     return initialCredit. }
false;public;0;7;;public BufferProvider getBufferProvider() throws IOException {     if (isReleased.get()) {         return null.     }     return inputGate.getBufferProvider(). }
true;public;0;6;/**  * Requests buffer from input channel directly for receiving network data.  * It should always return an available buffer in credit-based mode unless  * the channel has been released.  *  * @return The available buffer.  */ ;/**  * Requests buffer from input channel directly for receiving network data.  * It should always return an available buffer in credit-based mode unless  * the channel has been released.  *  * @return The available buffer.  */ @Nullable public Buffer requestBuffer() {     synchronized (bufferQueue) {         return bufferQueue.takeBuffer().     } }
true;;1;28;/**  * Receives the backlog from the producer's buffer response. If the number of available  * buffers is less than backlog + initialCredit, it will request floating buffers from the buffer  * pool, and then notify unannounced credits to the producer.  *  * @param backlog The number of unsent buffers in the producer's sub partition.  */ ;/**  * Receives the backlog from the producer's buffer response. If the number of available  * buffers is less than backlog + initialCredit, it will request floating buffers from the buffer  * pool, and then notify unannounced credits to the producer.  *  * @param backlog The number of unsent buffers in the producer's sub partition.  */ void onSenderBacklog(int backlog) throws IOException {     int numRequestedBuffers = 0.     synchronized (bufferQueue) {         // after releaseAllResources() released all buffers (see above for details).         if (isReleased.get()) {             return.         }         numRequiredBuffers = backlog + initialCredit.         while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {             Buffer buffer = inputGate.getBufferPool().requestBuffer().             if (buffer != null) {                 bufferQueue.addFloatingBuffer(buffer).                 numRequestedBuffers++.             } else if (inputGate.getBufferProvider().addBufferListener(this)) {                 // If the channel has not got enough buffers, register it as listener to wait for more floating buffers.                 isWaitingForFloatingBuffers = true.                 break.             }         }     }     if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {         notifyCreditAvailable().     } }
false;public;3;39;;public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOException {     boolean recycleBuffer = true.     try {         final boolean wasEmpty.         synchronized (receivedBuffers) {             // (see above for details).             if (isReleased.get()) {                 return.             }             if (expectedSequenceNumber != sequenceNumber) {                 onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber)).                 return.             }             wasEmpty = receivedBuffers.isEmpty().             receivedBuffers.add(buffer).             recycleBuffer = false.         }         ++expectedSequenceNumber.         if (wasEmpty) {             notifyChannelNonEmpty().         }         if (backlog >= 0) {             onSenderBacklog(backlog).         }     } finally {         if (recycleBuffer) {             buffer.recycleBuffer().         }     } }
false;public;2;18;;public void onEmptyBuffer(int sequenceNumber, int backlog) throws IOException {     boolean success = false.     synchronized (receivedBuffers) {         if (!isReleased.get()) {             if (expectedSequenceNumber == sequenceNumber) {                 expectedSequenceNumber++.                 success = true.             } else {                 onError(new BufferReorderingException(expectedSequenceNumber, sequenceNumber)).             }         }     }     if (success && backlog >= 0) {         onSenderBacklog(backlog).     } }
false;public;0;3;;public void onFailedPartitionRequest() {     inputGate.triggerPartitionStateCheck(partitionId). }
false;public;1;3;;public void onError(Throwable cause) {     setError(cause). }
false;public;0;5;;@Override public String getMessage() {     return String.format("Buffer re-ordering: expected buffer with sequence number %d, but received %d.", expectedSequenceNumber, actualSequenceNumber). }
true;;2;10;/**  * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the  * number of available buffers in queue is more than the required amount.  *  * @param buffer The exclusive buffer to add  * @param numRequiredBuffers The number of required buffers  *  * @return How many buffers were added to the queue  */ ;/**  * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the  * number of available buffers in queue is more than the required amount.  *  * @param buffer The exclusive buffer to add  * @param numRequiredBuffers The number of required buffers  *  * @return How many buffers were added to the queue  */ int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {     exclusiveBuffers.add(buffer).     if (getAvailableBufferSize() > numRequiredBuffers) {         Buffer floatingBuffer = floatingBuffers.poll().         floatingBuffer.recycleBuffer().         return 0.     } else {         return 1.     } }
false;;1;3;;void addFloatingBuffer(Buffer buffer) {     floatingBuffers.add(buffer). }
true;;0;8;/**  * Takes the floating buffer first in order to make full use of floating  * buffers reasonably.  *  * @return An available floating or exclusive buffer, may be null  * if the channel is released.  */ ;/**  * Takes the floating buffer first in order to make full use of floating  * buffers reasonably.  *  * @return An available floating or exclusive buffer, may be null  * if the channel is released.  */ @Nullable Buffer takeBuffer() {     if (floatingBuffers.size() > 0) {         return floatingBuffers.poll().     } else {         return exclusiveBuffers.poll().     } }
true;;1;9;/**  * The floating buffer is recycled to local buffer pool directly, and the  * exclusive buffer will be gathered to return to global buffer pool later.  *  * @param exclusiveSegments The list that we will add exclusive segments into.  */ ;/**  * The floating buffer is recycled to local buffer pool directly, and the  * exclusive buffer will be gathered to return to global buffer pool later.  *  * @param exclusiveSegments The list that we will add exclusive segments into.  */ void releaseAll(List<MemorySegment> exclusiveSegments) {     Buffer buffer.     while ((buffer = floatingBuffers.poll()) != null) {         buffer.recycleBuffer().     }     while ((buffer = exclusiveBuffers.poll()) != null) {         exclusiveSegments.add(buffer.getMemorySegment()).     } }
false;;0;3;;int getAvailableBufferSize() {     return floatingBuffers.size() + exclusiveBuffers.size(). }
