# id;timestamp;commentText;codeText;commentWords;codeWords
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1421050512;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1424683371;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1424859135;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(producerAddress)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,producer,address
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1425375416;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(producerAddress)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,producer,address
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1426697080;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(producerAddress)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,producer,address
RemoteInputChannel -> @Override 	public void releaseAllResources() throws IOException;1426971870;Releases all received buffers and closes the partition request client.;@Override_	public void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(producerAddress)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,public,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,producer,address
RemoteInputChannel -> private void notifyCreditAvailable();1518785736;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1519039301;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1519834967;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1519834986;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1532012479;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1534316740;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1535633547;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1535633547;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1535633547;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		partitionRequestClient.notifyCreditAvailable(this)__	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,partition,request,client,notify,credit,available,this
RemoteInputChannel -> private void notifyCreditAvailable();1543328832;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;private void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		partitionRequestClient.notifyCreditAvailable(this)__	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;private,void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,partition,request,client,notify,credit,available,this
RemoteInputChannel -> public int getUnannouncedCredit();1515408360;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1515510677;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1516285456;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1516285878;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1518785736;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1519039301;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1519834967;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1519834986;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1532012479;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1534316740;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1535633547;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1535633547;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1535633547;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> public int getUnannouncedCredit();1543328832;Gets the currently unannounced credit.__@return Credit which was not announced to the sender yet.;public int getUnannouncedCredit() {_		return unannouncedCredit.get()__	};gets,the,currently,unannounced,credit,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,unannounced,credit,return,unannounced,credit,get
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1432295874;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		_		if (nextRequestBackoffMs == 0) {_			failPartitionRequest()__		}_		else if (nextRequestBackoffMs <= maxRequestBackoffMs) {_			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, nextRequestBackoffMs)___			_			nextRequestBackoffMs = nextRequestBackoffMs < maxRequestBackoffMs_					? Math.min(nextRequestBackoffMs * 2, maxRequestBackoffMs)_					: maxRequestBackoffMs + 1_ _		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,next,request,backoff,ms,0,fail,partition,request,else,if,next,request,backoff,ms,max,request,backoff,ms,partition,request,client,request,subpartition,partition,id,subpartition,index,this,next,request,backoff,ms,next,request,backoff,ms,next,request,backoff,ms,max,request,backoff,ms,math,min,next,request,backoff,ms,2,max,request,backoff,ms,max,request,backoff,ms,1,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1432760698;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1433143315;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1438523908;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1465991918;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1466072697;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1469529015;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1472821521;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1477389806;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_					partitionId, subpartitionIndex, this, getCurrentBackoff())__		}_		else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1480624969;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1493298849;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1507647199;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1507647199;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1507647200;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1507752418;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1512394876;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1515408360;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1515408360;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1515510677;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1516285456;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1516285878;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1518785736;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1519039301;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1519834967;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1519834986;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1532012479;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1534316740;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1535633547;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1535633547;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1535633547;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException;1543328832;Retriggers a remote subpartition request.;void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException, InterruptedException {_		checkState(partitionRequestClient != null, "Missing initial subpartition request.")___		if (increaseBackoff()) {_			partitionRequestClient.requestSubpartition(_				partitionId, subpartitionIndex, this, getCurrentBackoff())__		} else {_			failPartitionRequest()__		}_	};retriggers,a,remote,subpartition,request;void,retrigger,subpartition,request,int,subpartition,index,throws,ioexception,interrupted,exception,check,state,partition,request,client,null,missing,initial,subpartition,request,if,increase,backoff,partition,request,client,request,subpartition,partition,id,subpartition,index,this,get,current,backoff,else,fail,partition,request
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1507647199;Exclusive buffer is recycled to this input channel directly and it may trigger notify_credit to producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		synchronized (availableBuffers) {_			_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Arrays.asList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			availableBuffers.add(new Buffer(segment, this))__		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,notify,credit,to,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,synchronized,available,buffers,if,is,released,get,try,input,gate,return,exclusive,segments,arrays,as,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,available,buffers,add,new,buffer,segment,this,if,unannounced,credit,get,and,add,1,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1507647200;Exclusive buffer is recycled to this input channel directly and it may trigger notify_credit to producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		synchronized (availableBuffers) {_			_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Arrays.asList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			availableBuffers.add(new Buffer(segment, this))__		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,notify,credit,to,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,synchronized,available,buffers,if,is,released,get,try,input,gate,return,exclusive,segments,arrays,as,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,available,buffers,add,new,buffer,segment,this,if,unannounced,credit,get,and,add,1,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1507752418;Exclusive buffer is recycled to this input channel directly and it may trigger notify_credit to producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		synchronized (availableBuffers) {_			_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Arrays.asList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			availableBuffers.add(new Buffer(segment, this))__		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,notify,credit,to,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,synchronized,available,buffers,if,is,released,get,try,input,gate,return,exclusive,segments,arrays,as,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,available,buffers,add,new,buffer,segment,this,if,unannounced,credit,get,and,add,1,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1512394876;Exclusive buffer is recycled to this input channel directly and it may trigger notify_credit to producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		synchronized (availableBuffers) {_			_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Arrays.asList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			availableBuffers.add(new Buffer(segment, this))__		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,notify,credit,to,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,synchronized,available,buffers,if,is,released,get,try,input,gate,return,exclusive,segments,arrays,as,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,available,buffers,add,new,buffer,segment,this,if,unannounced,credit,get,and,add,1,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1515408360;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1515408360;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1515510677;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1516285456;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1516285878;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1518785736;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1519039301;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1519834967;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1519834986;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1532012479;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1534316740;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1535633547;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1535633547;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1535633547;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> @Override 	public void recycle(MemorySegment segment);1543328832;Exclusive buffer is recycled to this input channel directly and it may trigger return extra_floating buffer and notify increased credit to the producer.__@param segment The exclusive segment of this channel.;@Override_	public void recycle(MemorySegment segment) {_		int numAddedBuffers___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				try {_					inputGate.returnExclusiveSegments(Collections.singletonList(segment))__					return__				} catch (Throwable t) {_					ExceptionUtils.rethrow(t)__				}_			}_			numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__		}__		if (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};exclusive,buffer,is,recycled,to,this,input,channel,directly,and,it,may,trigger,return,extra,floating,buffer,and,notify,increased,credit,to,the,producer,param,segment,the,exclusive,segment,of,this,channel;override,public,void,recycle,memory,segment,segment,int,num,added,buffers,synchronized,buffer,queue,if,is,released,get,try,input,gate,return,exclusive,segments,collections,singleton,list,segment,return,catch,throwable,t,exception,utils,rethrow,t,num,added,buffers,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers,if,num,added,buffers,0,unannounced,credit,get,and,add,num,added,buffers,0,notify,credit,available
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1515408360;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycle()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1515408360;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycle()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1515510677;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycle()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1516285456;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycle()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1516285878;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1518785736;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1519039301;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1519834967;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1519834986;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1532012479;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1534316740;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1535633547;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1535633547;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1535633547;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> AvailableBufferQueue -> void releaseAll(List<MemorySegment> exclusiveSegments);1543328832;The floating buffer is recycled to local buffer pool directly, and the_exclusive buffer will be gathered to return to global buffer pool later.__@param exclusiveSegments The list that we will add exclusive segments into.;void releaseAll(List<MemorySegment> exclusiveSegments) {_			Buffer buffer__			while ((buffer = floatingBuffers.poll()) != null) {_				buffer.recycleBuffer()__			}_			while ((buffer = exclusiveBuffers.poll()) != null) {_				exclusiveSegments.add(buffer.getMemorySegment())__			}_		};the,floating,buffer,is,recycled,to,local,buffer,pool,directly,and,the,exclusive,buffer,will,be,gathered,to,return,to,global,buffer,pool,later,param,exclusive,segments,the,list,that,we,will,add,exclusive,segments,into;void,release,all,list,memory,segment,exclusive,segments,buffer,buffer,while,buffer,floating,buffers,poll,null,buffer,recycle,buffer,while,buffer,exclusive,buffers,poll,null,exclusive,segments,add,buffer,get,memory,segment
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1427367086;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1432295874;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1432760698;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1433143315;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1438523908;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1465991918;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1466072697;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1469529015;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1472821521;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1477389806;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			}_			else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1480624969;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1493298849;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1507647199;Releases all received buffers and closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {_			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					buffer.recycle()__				}_			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,received,buffers,and,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,buffer,recycle,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1507647199;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			synchronized (availableBuffers) {_				Buffer buffer__				while ((buffer = availableBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,available,buffers,buffer,buffer,while,buffer,available,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1507647200;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			synchronized (availableBuffers) {_				Buffer buffer__				while ((buffer = availableBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,available,buffers,buffer,buffer,while,buffer,available,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1507752418;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			synchronized (availableBuffers) {_				Buffer buffer__				while ((buffer = availableBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,available,buffers,buffer,buffer,while,buffer,available,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1512394876;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			synchronized (availableBuffers) {_				Buffer buffer__				while ((buffer = availableBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,available,buffers,buffer,buffer,while,buffer,available,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1515408360;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1515408360;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1515510677;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1516285456;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycle()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1516285878;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1518785736;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1519039301;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1519834967;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1519834986;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1532012479;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1534316740;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1535633547;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1535633547;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1535633547;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> @Override 	void releaseAllResources() throws IOException;1543328832;Releases all exclusive and floating buffers, closes the partition request client.;@Override_	void releaseAllResources() throws IOException {_		if (isReleased.compareAndSet(false, true)) {__			_			_			final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>()___			synchronized (receivedBuffers) {_				Buffer buffer__				while ((buffer = receivedBuffers.poll()) != null) {_					if (buffer.getRecycler() == this) {_						exclusiveRecyclingSegments.add(buffer.getMemorySegment())__					} else {_						buffer.recycleBuffer()__					}_				}_			}_			synchronized (bufferQueue) {_				bufferQueue.releaseAll(exclusiveRecyclingSegments)__			}__			if (exclusiveRecyclingSegments.size() > 0) {_				inputGate.returnExclusiveSegments(exclusiveRecyclingSegments)__			}__			_			_			if (partitionRequestClient != null) {_				partitionRequestClient.close(this)__			} else {_				connectionManager.closeOpenChannelConnections(connectionId)__			}_		}_	};releases,all,exclusive,and,floating,buffers,closes,the,partition,request,client;override,void,release,all,resources,throws,ioexception,if,is,released,compare,and,set,false,true,final,list,memory,segment,exclusive,recycling,segments,new,array,list,synchronized,received,buffers,buffer,buffer,while,buffer,received,buffers,poll,null,if,buffer,get,recycler,this,exclusive,recycling,segments,add,buffer,get,memory,segment,else,buffer,recycle,buffer,synchronized,buffer,queue,buffer,queue,release,all,exclusive,recycling,segments,if,exclusive,recycling,segments,size,0,input,gate,return,exclusive,segments,exclusive,recycling,segments,if,partition,request,client,null,partition,request,client,close,this,else,connection,manager,close,open,channel,connections,connection,id
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1515408360;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycle()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1515408360;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycle()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1515510677;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycle()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1516285456;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycle()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1516285878;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1518785736;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1519039301;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1519834967;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1519834986;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1532012479;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1534316740;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1535633547;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1535633547;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1535633547;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> AvailableBufferQueue -> int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers);1543328832;Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the_number of available buffers in queue is more than the required amount.__@param buffer The exclusive buffer to add_@param numRequiredBuffers The number of required buffers__@return How many buffers were added to the queue;int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {_			exclusiveBuffers.add(buffer)__			if (getAvailableBufferSize() > numRequiredBuffers) {_				Buffer floatingBuffer = floatingBuffers.poll()__				floatingBuffer.recycleBuffer()__				return 0__			} else {_				return 1__			}_		};adds,an,exclusive,buffer,back,into,the,queue,and,recycles,one,floating,buffer,if,the,number,of,available,buffers,in,queue,is,more,than,the,required,amount,param,buffer,the,exclusive,buffer,to,add,param,num,required,buffers,the,number,of,required,buffers,return,how,many,buffers,were,added,to,the,queue;int,add,exclusive,buffer,buffer,buffer,int,num,required,buffers,exclusive,buffers,add,buffer,if,get,available,buffer,size,num,required,buffers,buffer,floating,buffer,floating,buffers,poll,floating,buffer,recycle,buffer,return,0,else,return,1
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1515408360;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1515408360;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1515510677;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1516285456;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1516285878;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1518785736;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1519039301;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1519834967;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1519834986;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1532012479;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1534316740;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1535633547;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1535633547;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1535633547;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @Nullable 	public Buffer requestBuffer();1543328832;Requests buffer from input channel directly for receiving network data._It should always return an available buffer in credit-based mode unless_the channel has been released.__@return The available buffer.;@Nullable_	public Buffer requestBuffer() {_		synchronized (bufferQueue) {_			return bufferQueue.takeBuffer()__		}_	};requests,buffer,from,input,channel,directly,for,receiving,network,data,it,should,always,return,an,available,buffer,in,credit,based,mode,unless,the,channel,has,been,released,return,the,available,buffer;nullable,public,buffer,request,buffer,synchronized,buffer,queue,return,buffer,queue,take,buffer
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1515408360;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1515510677;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1516285456;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1516285878;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1518785736;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1519039301;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1519834967;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1519834986;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1532012479;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1534316740;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1535633547;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1535633547;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1535633547;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @VisibleForTesting 	@Override 	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1543328832;Requests a remote subpartition.;@VisibleForTesting_	@Override_	public void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;visible,for,testing,override,public,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1515408360;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1515510677;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1516285456;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1516285878;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1518785736;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1519039301;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1519834967;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1519834986;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1532012479;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1534316740;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1535633547;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1535633547;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1535633547;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> public int getNumberOfQueuedBuffers();1543328832;Gets the current number of received buffers which have not been processed yet.__@return Buffers queued for processing.;public int getNumberOfQueuedBuffers() {_		synchronized (receivedBuffers) {_			return receivedBuffers.size()__		}_	};gets,the,current,number,of,received,buffers,which,have,not,been,processed,yet,return,buffers,queued,for,processing;public,int,get,number,of,queued,buffers,synchronized,received,buffers,return,received,buffers,size
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1432295874;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1432760698;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1433143315;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1438523908;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1465991918;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1466072697;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1469529015;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1472821521;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1477389806;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_					.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1480624969;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1493298849;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1507647199;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1507647199;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1507647200;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1507752418;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1512394876;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> @Override 	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException;1515408360;Requests a remote subpartition.;@Override_	void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {_		if (partitionRequestClient == null) {_			_			partitionRequestClient = connectionManager_				.createPartitionRequestClient(connectionId)___			partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0)__		}_	};requests,a,remote,subpartition;override,void,request,subpartition,int,subpartition,index,throws,ioexception,interrupted,exception,if,partition,request,client,null,partition,request,client,connection,manager,create,partition,request,client,connection,id,partition,request,client,request,subpartition,partition,id,subpartition,index,this,0
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1507647199;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()___		synchronized(availableBuffers) {_			for (MemorySegment segment : segments) {_				availableBuffers.add(new Buffer(segment, this))__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,synchronized,available,buffers,for,memory,segment,segment,segments,available,buffers,add,new,buffer,segment,this
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1507647200;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()___		synchronized(availableBuffers) {_			for (MemorySegment segment : segments) {_				availableBuffers.add(new Buffer(segment, this))__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,synchronized,available,buffers,for,memory,segment,segment,segments,available,buffers,add,new,buffer,segment,this
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1507752418;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()___		synchronized(availableBuffers) {_			for (MemorySegment segment : segments) {_				availableBuffers.add(new Buffer(segment, this))__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,synchronized,available,buffers,for,memory,segment,segment,segments,available,buffers,add,new,buffer,segment,this
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1512394876;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()___		synchronized(availableBuffers) {_			for (MemorySegment segment : segments) {_				availableBuffers.add(new Buffer(segment, this))__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,synchronized,available,buffers,for,memory,segment,segment,segments,available,buffers,add,new,buffer,segment,this
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1515408360;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized(bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1515408360;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized(bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1515510677;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized(bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new Buffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1516285456;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1516285878;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1518785736;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1519039301;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1519834967;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1519834986;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1532012479;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1534316740;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1535633547;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1535633547;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1535633547;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void assignExclusiveSegments(List<MemorySegment> segments);1543328832;Assigns exclusive buffers to this input channel, and this method should be called only once_after this input channel is created.;void assignExclusiveSegments(List<MemorySegment> segments) {_		checkState(this.initialCredit == 0, "Bug in input channel setup logic: exclusive buffers have " +_			"already been set for this input channel.")___		checkNotNull(segments)__		checkArgument(segments.size() > 0, "The number of exclusive buffers per channel should be larger than 0.")___		this.initialCredit = segments.size()__		this.numRequiredBuffers = segments.size()___		synchronized (bufferQueue) {_			for (MemorySegment segment : segments) {_				bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers)__			}_		}_	};assigns,exclusive,buffers,to,this,input,channel,and,this,method,should,be,called,only,once,after,this,input,channel,is,created;void,assign,exclusive,segments,list,memory,segment,segments,check,state,this,initial,credit,0,bug,in,input,channel,setup,logic,exclusive,buffers,have,already,been,set,for,this,input,channel,check,not,null,segments,check,argument,segments,size,0,the,number,of,exclusive,buffers,per,channel,should,be,larger,than,0,this,initial,credit,segments,size,this,num,required,buffers,segments,size,synchronized,buffer,queue,for,memory,segment,segment,segments,buffer,queue,add,exclusive,buffer,new,network,buffer,segment,this,num,required,buffers
RemoteInputChannel -> void notifyCreditAvailable();1507647199;Enqueue this input channel in the pipeline for sending unannounced credits to producer.;void notifyCreditAvailable() {_		_	};enqueue,this,input,channel,in,the,pipeline,for,sending,unannounced,credits,to,producer;void,notify,credit,available
RemoteInputChannel -> void notifyCreditAvailable();1507647200;Enqueue this input channel in the pipeline for sending unannounced credits to producer.;void notifyCreditAvailable() {_		_	};enqueue,this,input,channel,in,the,pipeline,for,sending,unannounced,credits,to,producer;void,notify,credit,available
RemoteInputChannel -> void notifyCreditAvailable();1507752418;Enqueue this input channel in the pipeline for sending unannounced credits to producer.;void notifyCreditAvailable() {_		_	};enqueue,this,input,channel,in,the,pipeline,for,sending,unannounced,credits,to,producer;void,notify,credit,available
RemoteInputChannel -> void notifyCreditAvailable();1512394876;Enqueue this input channel in the pipeline for sending unannounced credits to producer.;void notifyCreditAvailable() {_		_	};enqueue,this,input,channel,in,the,pipeline,for,sending,unannounced,credits,to,producer;void,notify,credit,available
RemoteInputChannel -> void notifyCreditAvailable();1515408360;Enqueue this input channel in the pipeline for sending unannounced credits to producer.;void notifyCreditAvailable() {_		_	};enqueue,this,input,channel,in,the,pipeline,for,sending,unannounced,credits,to,producer;void,notify,credit,available
RemoteInputChannel -> void notifyCreditAvailable();1515408360;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> void notifyCreditAvailable();1515510677;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> void notifyCreditAvailable();1516285456;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> void notifyCreditAvailable();1516285878;Enqueue this input channel in the pipeline for notifying the producer of unannounced credit.;void notifyCreditAvailable() {_		checkState(partitionRequestClient != null, "Tried to send task event to producer before requesting a queue.")___		_		if (!isReleased.get()) {_			partitionRequestClient.notifyCreditAvailable(this)__		}_	};enqueue,this,input,channel,in,the,pipeline,for,notifying,the,producer,of,unannounced,credit;void,notify,credit,available,check,state,partition,request,client,null,tried,to,send,task,event,to,producer,before,requesting,a,queue,if,is,released,get,partition,request,client,notify,credit,available,this
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1507647200;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>availableBuffers</tt> queue and the unannounced credit is_increased by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		checkState(isWaitingForFloatingBuffers.get(), "This channel should be waiting for floating buffers.")___		synchronized (availableBuffers) {_			_			if (isReleased.get() || availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				buffer.recycle()___				return false__			}__			availableBuffers.add(buffer)___			if (unannouncedCredit.getAndAdd(1) == 0) {_				notifyCreditAvailable()__			}__			if (availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				return false__			} else {_				return true__			}_		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,available,buffers,tt,queue,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,check,state,is,waiting,for,floating,buffers,get,this,channel,should,be,waiting,for,floating,buffers,synchronized,available,buffers,if,is,released,get,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,buffer,recycle,return,false,available,buffers,add,buffer,if,unannounced,credit,get,and,add,1,0,notify,credit,available,if,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,return,false,else,return,true
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1507752418;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>availableBuffers</tt> queue and the unannounced credit is_increased by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		checkState(isWaitingForFloatingBuffers.get(), "This channel should be waiting for floating buffers.")___		synchronized (availableBuffers) {_			_			if (isReleased.get() || availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				buffer.recycle()___				return false__			}__			availableBuffers.add(buffer)___			if (unannouncedCredit.getAndAdd(1) == 0) {_				notifyCreditAvailable()__			}__			if (availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				return false__			} else {_				return true__			}_		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,available,buffers,tt,queue,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,check,state,is,waiting,for,floating,buffers,get,this,channel,should,be,waiting,for,floating,buffers,synchronized,available,buffers,if,is,released,get,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,buffer,recycle,return,false,available,buffers,add,buffer,if,unannounced,credit,get,and,add,1,0,notify,credit,available,if,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,return,false,else,return,true
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1512394876;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>availableBuffers</tt> queue and the unannounced credit is_increased by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		checkState(isWaitingForFloatingBuffers.get(), "This channel should be waiting for floating buffers.")___		synchronized (availableBuffers) {_			_			if (isReleased.get() || availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				buffer.recycle()___				return false__			}__			availableBuffers.add(buffer)___			if (unannouncedCredit.getAndAdd(1) == 0) {_				notifyCreditAvailable()__			}__			if (availableBuffers.size() >= senderBacklog.get()) {_				isWaitingForFloatingBuffers.set(false)__				return false__			} else {_				return true__			}_		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,available,buffers,tt,queue,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,check,state,is,waiting,for,floating,buffers,get,this,channel,should,be,waiting,for,floating,buffers,synchronized,available,buffers,if,is,released,get,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,buffer,recycle,return,false,available,buffers,add,buffer,if,unannounced,credit,get,and,add,1,0,notify,credit,available,if,available,buffers,size,sender,backlog,get,is,waiting,for,floating,buffers,set,false,return,false,else,return,true
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1515408360;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycle()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycle()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1515408360;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycle()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycle()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1515510677;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycle()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycle()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1516285456;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycle()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycle()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1516285878;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycleBuffer()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,buffer,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1518785736;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycleBuffer()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,buffer,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1519039301;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				buffer.recycleBuffer()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,buffer,recycle,buffer,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1519834967;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__				buffer.recycleBuffer()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,buffer,recycle,buffer,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1519834986;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean needMoreBuffers = false__		synchronized (bufferQueue) {_			checkState(isWaitingForFloatingBuffers, "This channel should be waiting for floating buffers.")___			_			_			if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__				buffer.recycleBuffer()__				return false__			}__			bufferQueue.addFloatingBuffer(buffer)___			if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_				isWaitingForFloatingBuffers = false__			} else {_				needMoreBuffers =  true__			}_		}__		if (unannouncedCredit.getAndAdd(1) == 0) {_			notifyCreditAvailable()__		}__		return needMoreBuffers__	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,buffer,recycle,buffer,return,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1532012479;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean recycleBuffer = true__		try {_			boolean needMoreBuffers = false__			synchronized (bufferQueue) {_				checkState(isWaitingForFloatingBuffers,_					"This channel should be waiting for floating buffers.")___				_				_				if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__					recycleBuffer = false_ _					buffer.recycleBuffer()__					return false__				}__				recycleBuffer = false__				bufferQueue.addFloatingBuffer(buffer)___				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__				} else {_					needMoreBuffers = true__				}__				if (unannouncedCredit.getAndAdd(1) == 0) {_					notifyCreditAvailable()__				}_			}__			return needMoreBuffers__		} catch (Throwable t) {_			if (recycleBuffer) {_				buffer.recycleBuffer()__			}_			setError(t)__			return false__		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,recycle,buffer,true,try,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,recycle,buffer,false,buffer,recycle,buffer,return,false,recycle,buffer,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers,catch,throwable,t,if,recycle,buffer,buffer,recycle,buffer,set,error,t,return,false
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1534316740;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean recycleBuffer = true__		try {_			boolean needMoreBuffers = false__			synchronized (bufferQueue) {_				checkState(isWaitingForFloatingBuffers,_					"This channel should be waiting for floating buffers.")___				_				_				if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__					recycleBuffer = false_ _					buffer.recycleBuffer()__					return false__				}__				recycleBuffer = false__				bufferQueue.addFloatingBuffer(buffer)___				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__				} else {_					needMoreBuffers = true__				}__				if (unannouncedCredit.getAndAdd(1) == 0) {_					notifyCreditAvailable()__				}_			}__			return needMoreBuffers__		} catch (Throwable t) {_			if (recycleBuffer) {_				buffer.recycleBuffer()__			}_			setError(t)__			return false__		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,recycle,buffer,true,try,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,recycle,buffer,false,buffer,recycle,buffer,return,false,recycle,buffer,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers,catch,throwable,t,if,recycle,buffer,buffer,recycle,buffer,set,error,t,return,false
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1535633547;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean recycleBuffer = true__		try {_			boolean needMoreBuffers = false__			synchronized (bufferQueue) {_				checkState(isWaitingForFloatingBuffers,_					"This channel should be waiting for floating buffers.")___				_				_				if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__					recycleBuffer = false_ _					buffer.recycleBuffer()__					return false__				}__				recycleBuffer = false__				bufferQueue.addFloatingBuffer(buffer)___				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__				} else {_					needMoreBuffers = true__				}__				if (unannouncedCredit.getAndAdd(1) == 0) {_					notifyCreditAvailable()__				}_			}__			return needMoreBuffers__		} catch (Throwable t) {_			if (recycleBuffer) {_				buffer.recycleBuffer()__			}_			setError(t)__			return false__		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,recycle,buffer,true,try,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,recycle,buffer,false,buffer,recycle,buffer,return,false,recycle,buffer,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers,catch,throwable,t,if,recycle,buffer,buffer,recycle,buffer,set,error,t,return,false
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1535633547;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		_		_		if (isReleased.get()) {_			buffer.recycleBuffer()__			return false__		}__		boolean recycleBuffer = true__		try {_			boolean needMoreBuffers = false__			synchronized (bufferQueue) {_				checkState(isWaitingForFloatingBuffers,_					"This channel should be waiting for floating buffers.")___				_				_				_				_				_				_				_				if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__					recycleBuffer = false_ _					buffer.recycleBuffer()__					return false__				}__				recycleBuffer = false__				bufferQueue.addFloatingBuffer(buffer)___				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__				} else {_					needMoreBuffers = true__				}_			}__			if (unannouncedCredit.getAndAdd(1) == 0) {_				notifyCreditAvailable()__			}__			return needMoreBuffers__		} catch (Throwable t) {_			if (recycleBuffer) {_				buffer.recycleBuffer()__			}_			setError(t)__			return false__		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,if,is,released,get,buffer,recycle,buffer,return,false,boolean,recycle,buffer,true,try,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,recycle,buffer,false,buffer,recycle,buffer,return,false,recycle,buffer,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers,catch,throwable,t,if,recycle,buffer,buffer,recycle,buffer,set,error,t,return,false
RemoteInputChannel -> @Override 	public boolean notifyBufferAvailable(Buffer buffer);1535633547;The Buffer pool notifies this channel of an available floating buffer. If the channel is released or_currently does not need extra buffers, the buffer should be recycled to the buffer pool. Otherwise,_the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased_by one.__@param buffer Buffer that becomes available in buffer pool._@return True when this channel is waiting for more floating buffers, otherwise false.;@Override_	public boolean notifyBufferAvailable(Buffer buffer) {_		boolean recycleBuffer = true__		try {_			boolean needMoreBuffers = false__			synchronized (bufferQueue) {_				checkState(isWaitingForFloatingBuffers,_					"This channel should be waiting for floating buffers.")___				_				_				_				_				_				_				_				if (isReleased.get() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__					recycleBuffer = false_ _					buffer.recycleBuffer()__					return false__				}__				recycleBuffer = false__				bufferQueue.addFloatingBuffer(buffer)___				if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {_					isWaitingForFloatingBuffers = false__				} else {_					needMoreBuffers = true__				}_			}__			if (unannouncedCredit.getAndAdd(1) == 0) {_				notifyCreditAvailable()__			}__			return needMoreBuffers__		} catch (Throwable t) {_			if (recycleBuffer) {_				buffer.recycleBuffer()__			}_			setError(t)__			return false__		}_	};the,buffer,pool,notifies,this,channel,of,an,available,floating,buffer,if,the,channel,is,released,or,currently,does,not,need,extra,buffers,the,buffer,should,be,recycled,to,the,buffer,pool,otherwise,the,buffer,will,be,added,into,the,tt,buffer,queue,tt,and,the,unannounced,credit,is,increased,by,one,param,buffer,buffer,that,becomes,available,in,buffer,pool,return,true,when,this,channel,is,waiting,for,more,floating,buffers,otherwise,false;override,public,boolean,notify,buffer,available,buffer,buffer,boolean,recycle,buffer,true,try,boolean,need,more,buffers,false,synchronized,buffer,queue,check,state,is,waiting,for,floating,buffers,this,channel,should,be,waiting,for,floating,buffers,if,is,released,get,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,recycle,buffer,false,buffer,recycle,buffer,return,false,recycle,buffer,false,buffer,queue,add,floating,buffer,buffer,if,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,false,else,need,more,buffers,true,if,unannounced,credit,get,and,add,1,0,notify,credit,available,return,need,more,buffers,catch,throwable,t,if,recycle,buffer,buffer,recycle,buffer,set,error,t,return,false
RemoteInputChannel -> private void checkError() throws IOException;1427367086;Checks whether this channel got notified by the network I/O thread about an error.;private void checkError() throws IOException {_		final Throwable t = error___		if (t != null) {_			throw new IOException(t)__		}_	};checks,whether,this,channel,got,notified,by,the,network,i,o,thread,about,an,error;private,void,check,error,throws,ioexception,final,throwable,t,error,if,t,null,throw,new,ioexception,t
RemoteInputChannel -> private void checkError() throws IOException;1432295874;Checks whether this channel got notified about an error.;private void checkError() throws IOException {_		final Throwable t = error.get()___		if (t != null) {_			if (t instanceof IOException) {_				throw (IOException) t__			}_			else {_				throw new IOException(t)__			}_		}_	};checks,whether,this,channel,got,notified,about,an,error;private,void,check,error,throws,ioexception,final,throwable,t,error,get,if,t,null,if,t,instanceof,ioexception,throw,ioexception,t,else,throw,new,ioexception,t
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1515408360;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1515408360;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1515510677;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1516285456;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1516285878;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1518785736;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1519039301;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1519834967;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1519834986;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1532012479;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1534316740;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1535633547;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1535633547;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1535633547;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> AvailableBufferQueue -> @Nullable 		Buffer takeBuffer();1543328832;Takes the floating buffer first in order to make full use of floating_buffers reasonably.__@return An available floating or exclusive buffer, may be null_if the channel is released.;@Nullable_		Buffer takeBuffer() {_			if (floatingBuffers.size() > 0) {_				return floatingBuffers.poll()__			} else {_				return exclusiveBuffers.poll()__			}_		};takes,the,floating,buffer,first,in,order,to,make,full,use,of,floating,buffers,reasonably,return,an,available,floating,or,exclusive,buffer,may,be,null,if,the,channel,is,released;nullable,buffer,take,buffer,if,floating,buffers,size,0,return,floating,buffers,poll,else,return,exclusive,buffers,poll
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1515408360;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1515510677;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1516285456;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1516285878;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1518785736;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1519039301;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1519834967;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1519834986;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1532012479;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1534316740;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1535633547;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1535633547;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1535633547;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> void onSenderBacklog(int backlog) throws IOException;1543328832;Receives the backlog from the producer's buffer response. If the number of available_buffers is less than backlog + initialCredit, it will request floating buffers from the buffer_pool, and then notify unannounced credits to the producer.__@param backlog The number of unsent buffers in the producer's sub partition.;void onSenderBacklog(int backlog) throws IOException {_		int numRequestedBuffers = 0___		synchronized (bufferQueue) {_			_			_			if (isReleased.get()) {_				return__			}__			numRequiredBuffers = backlog + initialCredit__			while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {_				Buffer buffer = inputGate.getBufferPool().requestBuffer()__				if (buffer != null) {_					bufferQueue.addFloatingBuffer(buffer)__					numRequestedBuffers++__				} else if (inputGate.getBufferProvider().addBufferListener(this)) {_					_					isWaitingForFloatingBuffers = true__					break__				}_			}_		}__		if (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {_			notifyCreditAvailable()__		}_	};receives,the,backlog,from,the,producer,s,buffer,response,if,the,number,of,available,buffers,is,less,than,backlog,initial,credit,it,will,request,floating,buffers,from,the,buffer,pool,and,then,notify,unannounced,credits,to,the,producer,param,backlog,the,number,of,unsent,buffers,in,the,producer,s,sub,partition;void,on,sender,backlog,int,backlog,throws,ioexception,int,num,requested,buffers,0,synchronized,buffer,queue,if,is,released,get,return,num,required,buffers,backlog,initial,credit,while,buffer,queue,get,available,buffer,size,num,required,buffers,is,waiting,for,floating,buffers,buffer,buffer,input,gate,get,buffer,pool,request,buffer,if,buffer,null,buffer,queue,add,floating,buffer,buffer,num,requested,buffers,else,if,input,gate,get,buffer,provider,add,buffer,listener,this,is,waiting,for,floating,buffers,true,break,if,num,requested,buffers,0,unannounced,credit,get,and,add,num,requested,buffers,0,notify,credit,available
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1515408360;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1515510677;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1516285456;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1516285878;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1518785736;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1519039301;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1519834967;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1519834986;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1532012479;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1534316740;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1535633547;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1535633547;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1535633547;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
RemoteInputChannel -> public int getAndResetUnannouncedCredit();1543328832;Gets the unannounced credit and resets it to <tt>0</tt> atomically.__@return Credit which was not announced to the sender yet.;public int getAndResetUnannouncedCredit() {_		return unannouncedCredit.getAndSet(0)__	};gets,the,unannounced,credit,and,resets,it,to,tt,0,tt,atomically,return,credit,which,was,not,announced,to,the,sender,yet;public,int,get,and,reset,unannounced,credit,return,unannounced,credit,get,and,set,0
