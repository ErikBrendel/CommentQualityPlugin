commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.  *  * @return the number of entries in this {@link CopyOnWriteStateTable}.  */ ;// Public API from AbstractStateTable ------------------------------------------------------------------------------ /**  * Returns the total number of entries in this {@link CopyOnWriteStateTable}. This is the sum of both sub-tables.  *  * @return the number of entries in this {@link CopyOnWriteStateTable}.  */ @Override public int size() {     return primaryTableSize + incrementalRehashTableSize. }
false;public;2;29;;@Override public S get(K key, N namespace) {     final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace).     final int requiredVersion = highestRequiredSnapshotVersion.     final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash).     int index = hash & (tab.length - 1).     for (StateTableEntry<K, N, S> e = tab[index]. e != null. e = e.next) {         final K eKey = e.key.         final N eNamespace = e.namespace.         if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {             // copy-on-write check for state             if (e.stateVersion < requiredVersion) {                 // copy-on-write check for entry                 if (e.entryVersion < requiredVersion) {                     e = handleChainedEntryCopyOnWrite(tab, hash & (tab.length - 1), e).                 }                 e.stateVersion = stateTableVersion.                 e.state = getStateSerializer().copy(e.state).             }             return e.state.         }     }     return null. }
false;public;1;6;;@Override public Stream<K> getKeys(N namespace) {     return StreamSupport.stream(spliterator(), false).filter(entry -> entry.getNamespace().equals(namespace)).map(StateEntry::getKey). }
false;public;4;4;;@Override public void put(K key, int keyGroup, N namespace, S state) {     put(key, namespace, state). }
false;public;1;4;;@Override public S get(N namespace) {     return get(keyContext.getCurrentKey(), namespace). }
false;public;1;4;;@Override public boolean containsKey(N namespace) {     return containsKey(keyContext.getCurrentKey(), namespace). }
false;public;2;4;;@Override public void put(N namespace, S state) {     put(keyContext.getCurrentKey(), namespace, state). }
false;public;2;4;;@Override public S putAndGetOld(N namespace, S state) {     return putAndGetOld(keyContext.getCurrentKey(), namespace, state). }
false;public;1;4;;@Override public void remove(N namespace) {     remove(keyContext.getCurrentKey(), namespace). }
false;public;1;4;;@Override public S removeAndGetOld(N namespace) {     return removeAndGetOld(keyContext.getCurrentKey(), namespace). }
false;public;3;4;;@Override public <T> void transform(N namespace, T value, StateTransformationFunction<S, T> transformation) throws Exception {     transform(keyContext.getCurrentKey(), namespace, value, transformation). }
true;;2;16;/**  * Returns whether this table contains the specified key/namespace composite key.  *  * @param key       the key in the composite key to search for. Not null.  * @param namespace the namespace in the composite key to search for. Not null.  * @return {@code true} if this map contains the specified key/namespace composite key,  * {@code false} otherwise.  */ ;// Private implementation details of the API methods --------------------------------------------------------------- /**  * Returns whether this table contains the specified key/namespace composite key.  *  * @param key       the key in the composite key to search for. Not null.  * @param namespace the namespace in the composite key to search for. Not null.  * @return {@code true} if this map contains the specified key/namespace composite key,  * {@code false} otherwise.  */ boolean containsKey(K key, N namespace) {     final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace).     final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash).     int index = hash & (tab.length - 1).     for (StateTableEntry<K, N, S> e = tab[index]. e != null. e = e.next) {         final K eKey = e.key.         final N eNamespace = e.namespace.         if ((e.hash == hash && key.equals(eKey) && namespace.equals(eNamespace))) {             return true.         }     }     return false. }
true;;3;6;/**  * Maps the specified key/namespace composite key to the specified value. This method should be preferred  * over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested  * in the old value, because this can potentially reduce copy-on-write activity.  *  * @param key       the key. Not null.  * @param namespace the namespace. Not null.  * @param value     the value. Can be null.  */ ;/**  * Maps the specified key/namespace composite key to the specified value. This method should be preferred  * over {@link #putAndGetOld(Object, Object, Object)} (Object, Object)} when the caller is not interested  * in the old value, because this can potentially reduce copy-on-write activity.  *  * @param key       the key. Not null.  * @param namespace the namespace. Not null.  * @param value     the value. Can be null.  */ void put(K key, N namespace, S value) {     final StateTableEntry<K, N, S> e = putEntry(key, namespace).     e.state = value.     e.stateVersion = stateTableVersion. }
true;;3;14;/**  * Maps the specified key/namespace composite key to the specified value. Returns the previous state that was  * registered under the composite key.  *  * @param key       the key. Not null.  * @param namespace the namespace. Not null.  * @param value     the value. Can be null.  * @return the value of any previous mapping with the specified key or  * {@code null} if there was no such mapping.  */ ;/**  * Maps the specified key/namespace composite key to the specified value. Returns the previous state that was  * registered under the composite key.  *  * @param key       the key. Not null.  * @param namespace the namespace. Not null.  * @param value     the value. Can be null.  * @return the value of any previous mapping with the specified key or  * {@code null} if there was no such mapping.  */ S putAndGetOld(K key, N namespace, S value) {     final StateTableEntry<K, N, S> e = putEntry(key, namespace).     // copy-on-write check for state     S oldState = (e.stateVersion < highestRequiredSnapshotVersion) ? getStateSerializer().copy(e.state) : e.state.     e.state = value.     e.stateVersion = stateTableVersion.     return oldState. }
true;;2;3;/**  * Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred  * over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this  * can potentially reduce copy-on-write activity.  *  * @param key       the key of the mapping to remove. Not null.  * @param namespace the namespace of the mapping to remove. Not null.  */ ;/**  * Removes the mapping with the specified key/namespace composite key from this map. This method should be preferred  * over {@link #removeAndGetOld(Object, Object)} when the caller is not interested in the old value, because this  * can potentially reduce copy-on-write activity.  *  * @param key       the key of the mapping to remove. Not null.  * @param namespace the namespace of the mapping to remove. Not null.  */ void remove(K key, N namespace) {     removeEntry(key, namespace). }
true;;2;11;/**  * Removes the mapping with the specified key/namespace composite key from this map, returning the state that was  * found under the entry.  *  * @param key       the key of the mapping to remove. Not null.  * @param namespace the namespace of the mapping to remove. Not null.  * @return the value of the removed mapping or {@code null} if no mapping  * for the specified key was found.  */ ;/**  * Removes the mapping with the specified key/namespace composite key from this map, returning the state that was  * found under the entry.  *  * @param key       the key of the mapping to remove. Not null.  * @param namespace the namespace of the mapping to remove. Not null.  * @return the value of the removed mapping or {@code null} if no mapping  * for the specified key was found.  */ S removeAndGetOld(K key, N namespace) {     final StateTableEntry<K, N, S> e = removeEntry(key, namespace).     return e != null ? // copy-on-write check for state     (e.stateVersion < highestRequiredSnapshotVersion ? getStateSerializer().copy(e.state) : e.state) : null. }
true;;4;16;/**  * @param key            the key of the mapping to remove. Not null.  * @param namespace      the namespace of the mapping to remove. Not null.  * @param value          the value that is the second input for the transformation.  * @param transformation the transformation function to apply on the old state and the given value.  * @param <T>            type of the value that is the second input to the {@link StateTransformationFunction}.  * @throws Exception exception that happen on applying the function.  * @see #transform(Object, Object, StateTransformationFunction).  */ ;/**  * @param key            the key of the mapping to remove. Not null.  * @param namespace      the namespace of the mapping to remove. Not null.  * @param value          the value that is the second input for the transformation.  * @param transformation the transformation function to apply on the old state and the given value.  * @param <T>            type of the value that is the second input to the {@link StateTransformationFunction}.  * @throws Exception exception that happen on applying the function.  * @see #transform(Object, Object, StateTransformationFunction).  */ <T> void transform(K key, N namespace, T value, StateTransformationFunction<S, T> transformation) throws Exception {     final StateTableEntry<K, N, S> entry = putEntry(key, namespace).     // copy-on-write check for state     entry.state = transformation.apply((entry.stateVersion < highestRequiredSnapshotVersion) ? getStateSerializer().copy(entry.state) : entry.state, value).     entry.stateVersion = stateTableVersion. }
true;private;2;25;/**  * Helper method that is the basis for operations that add mappings.  */ ;/**  * Helper method that is the basis for operations that add mappings.  */ private StateTableEntry<K, N, S> putEntry(K key, N namespace) {     final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace).     final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash).     int index = hash & (tab.length - 1).     for (StateTableEntry<K, N, S> e = tab[index]. e != null. e = e.next) {         if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {             // copy-on-write check for entry             if (e.entryVersion < highestRequiredSnapshotVersion) {                 e = handleChainedEntryCopyOnWrite(tab, index, e).             }             return e.         }     }     ++modCount.     if (size() > threshold) {         doubleCapacity().     }     return addNewStateTableEntry(tab, key, namespace, hash). }
true;private;2;28;/**  * Helper method that is the basis for operations that remove mappings.  */ ;/**  * Helper method that is the basis for operations that remove mappings.  */ private StateTableEntry<K, N, S> removeEntry(K key, N namespace) {     final int hash = computeHashForOperationAndDoIncrementalRehash(key, namespace).     final StateTableEntry<K, N, S>[] tab = selectActiveTable(hash).     int index = hash & (tab.length - 1).     for (StateTableEntry<K, N, S> e = tab[index], prev = null. e != null. prev = e, e = e.next) {         if (e.hash == hash && key.equals(e.key) && namespace.equals(e.namespace)) {             if (prev == null) {                 tab[index] = e.next.             } else {                 // copy-on-write check for entry                 if (prev.entryVersion < highestRequiredSnapshotVersion) {                     prev = handleChainedEntryCopyOnWrite(tab, index, prev).                 }                 prev.next = e.next.             }             ++modCount.             if (tab == primaryTable) {                 --primaryTableSize.             } else {                 --incrementalRehashTableSize.             }             return e.         }     }     return null. }
false;private;2;4;;private void checkKeyNamespacePreconditions(K key, N namespace) {     Preconditions.checkNotNull(key, "No key set. This method should not be called outside of a keyed context.").     Preconditions.checkNotNull(namespace, "Provided namespace is null."). }
false;public;0;4;;// Meta data setter / getter and toString -------------------------------------------------------------------------- @Override public TypeSerializer<S> getStateSerializer() {     return metaInfo.getStateSerializer(). }
false;public;0;4;;@Override public TypeSerializer<N> getNamespaceSerializer() {     return metaInfo.getNamespaceSerializer(). }
false;public;0;4;;@Override public RegisteredKeyValueStateBackendMetaInfo<N, S> getMetaInfo() {     return metaInfo. }
false;public;1;4;;@Override public void setMetaInfo(RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo) {     this.metaInfo = metaInfo. }
false;public;0;5;;// Iteration  ------------------------------------------------------------------------------------------------------ @Nonnull @Override public Iterator<StateEntry<K, N, S>> iterator() {     return new StateEntryIterator(). }
true;;1;9;/**  * @see #releaseSnapshot(CopyOnWriteStateTableSnapshot)  */ ;// Private utility functions for StateTable management ------------------------------------------------------------- /**  * @see #releaseSnapshot(CopyOnWriteStateTableSnapshot)  */ @VisibleForTesting void releaseSnapshot(int snapshotVersion) {     // Only stale reads of from the result of #releaseSnapshot calls are ok.     synchronized (snapshotVersions) {         Preconditions.checkState(snapshotVersions.remove(snapshotVersion), "Attempt to release unknown snapshot version").         highestRequiredSnapshotVersion = snapshotVersions.isEmpty() ? 0 : snapshotVersions.last().     } }
true;;0;49;/**  * Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that  * does modifications to the {@link CopyOnWriteStateTable}.  */ ;/**  * Creates (combined) copy of the table arrays for a snapshot. This method must be called by the same Thread that  * does modifications to the {@link CopyOnWriteStateTable}.  */ @VisibleForTesting @SuppressWarnings("unchecked") StateTableEntry<K, N, S>[] snapshotTableArrays() {     // from the same thread that does all the modifications to the table.     synchronized (snapshotVersions) {         // increase the table version for copy-on-write and register the snapshot         if (++stateTableVersion < 0) {             // this is just a safety net against overflows, but should never happen in practice (i.e., only after 2^31 snapshots)             throw new IllegalStateException("Version count overflow in CopyOnWriteStateTable. Enforcing restart.").         }         highestRequiredSnapshotVersion = stateTableVersion.         snapshotVersions.add(highestRequiredSnapshotVersion).     }     StateTableEntry<K, N, S>[] table = primaryTable.     // In order to reuse the copied array as the destination array for the partitioned records in     // CopyOnWriteStateTableSnapshot#partitionByKeyGroup(), we need to make sure that the copied array     // is big enough to hold the flattened entries. In fact, given the current rehashing algorithm, we only     // need to do this check when isRehashing() is false, but in order to get a more robust code(in case that     // the rehashing algorithm may changed in the future), we do this check for all the case.     final int totalTableIndexSize = rehashIndex + table.length.     final int copiedArraySize = Math.max(totalTableIndexSize, size()).     final StateTableEntry<K, N, S>[] copy = new StateTableEntry[copiedArraySize].     if (isRehashing()) {         // consider both tables for the snapshot, the rehash index tells us which part of the two tables we need         final int localRehashIndex = rehashIndex.         final int localCopyLength = table.length - localRehashIndex.         // for the primary table, take every index >= rhIdx.         System.arraycopy(table, localRehashIndex, copy, 0, localCopyLength).         // for the new table, we are sure that two regions contain all the entries:         // [0, rhIdx[ AND [table.length / 2, table.length / 2 + rhIdx[         table = incrementalRehashTable.         System.arraycopy(table, 0, copy, localCopyLength, localRehashIndex).         System.arraycopy(table, table.length >>> 1, copy, localCopyLength + localRehashIndex, localRehashIndex).     } else {         // we only need to copy the primary table         System.arraycopy(table, 0, copy, 0, table.length).     }     return copy. }
true;private;1;23;/**  * Allocate a table of the given capacity and set the threshold accordingly.  *  * @param newCapacity must be a power of two  */ ;/**  * Allocate a table of the given capacity and set the threshold accordingly.  *  * @param newCapacity must be a power of two  */ private StateTableEntry<K, N, S>[] makeTable(int newCapacity) {     if (newCapacity < MAXIMUM_CAPACITY) {         // 3/4 capacity         threshold = (newCapacity >> 1) + (newCapacity >> 2).     } else {         if (size() > MAX_ARRAY_SIZE) {             throw new IllegalStateException("Maximum capacity of CopyOnWriteStateTable is reached and the job " + "cannot continue. Please consider scaling-out your job or using a different keyed state backend " + "implementation!").         } else {             LOG.warn("Maximum capacity of 2^30 in StateTable reached. Cannot increase hash table size. This can " + "lead to more collisions and lower performance. Please consider scaling-out your job or using a " + "different keyed state backend implementation!").             threshold = MAX_ARRAY_SIZE.         }     }     @SuppressWarnings("unchecked")     StateTableEntry<K, N, S>[] newTable = (StateTableEntry<K, N, S>[]) new StateTableEntry[newCapacity].     return newTable. }
true;private;4;31;/**  * Creates and inserts a new {@link StateTableEntry}.  */ ;/**  * Creates and inserts a new {@link StateTableEntry}.  */ private StateTableEntry<K, N, S> addNewStateTableEntry(StateTableEntry<K, N, S>[] table, K key, N namespace, int hash) {     // small optimization that aims to avoid holding references on duplicate namespace objects     if (namespace.equals(lastNamespace)) {         namespace = lastNamespace.     } else {         lastNamespace = namespace.     }     int index = hash & (table.length - 1).     StateTableEntry<K, N, S> newEntry = new StateTableEntry<>(key, namespace, null, hash, table[index], stateTableVersion, stateTableVersion).     table[index] = newEntry.     if (table == primaryTable) {         ++primaryTableSize.     } else {         ++incrementalRehashTableSize.     }     return newEntry. }
true;private;1;3;/**  * Select the sub-table which is responsible for entries with the given hash code.  *  * @param hashCode the hash code which we use to decide about the table that is responsible.  * @return the index of the sub-table that is responsible for the entry with the given hash code.  */ ;/**  * Select the sub-table which is responsible for entries with the given hash code.  *  * @param hashCode the hash code which we use to decide about the table that is responsible.  * @return the index of the sub-table that is responsible for the entry with the given hash code.  */ private StateTableEntry<K, N, S>[] selectActiveTable(int hashCode) {     return (hashCode & (primaryTable.length - 1)) >= rehashIndex ? primaryTable : incrementalRehashTable. }
true;private;0;15;/**  * Doubles the capacity of the hash table. Existing entries are placed in  * the correct bucket on the enlarged table. If the current capacity is,  * MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which  * will be new unless we were already at MAXIMUM_CAPACITY.  */ ;/**  * Doubles the capacity of the hash table. Existing entries are placed in  * the correct bucket on the enlarged table. If the current capacity is,  * MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which  * will be new unless we were already at MAXIMUM_CAPACITY.  */ private void doubleCapacity() {     // There can only be one rehash in flight. From the amount of incremental rehash steps we take, this should always hold.     Preconditions.checkState(!isRehashing(), "There is already a rehash in progress.").     StateTableEntry<K, N, S>[] oldTable = primaryTable.     int oldCapacity = oldTable.length.     if (oldCapacity == MAXIMUM_CAPACITY) {         return.     }     incrementalRehashTable = makeTable(oldCapacity * 2). }
true;;0;5;/**  * Returns true, if an incremental rehash is in progress.  */ ;/**  * Returns true, if an incremental rehash is in progress.  */ @VisibleForTesting boolean isRehashing() {     // if we rehash, the secondary table is not empty     return EMPTY_TABLE != incrementalRehashTable. }
true;private;2;10;/**  * Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if  * incremental rehashing is in progress.  */ ;/**  * Computes the hash for the composite of key and namespace and performs some steps of incremental rehash if  * incremental rehashing is in progress.  */ private int computeHashForOperationAndDoIncrementalRehash(K key, N namespace) {     checkKeyNamespacePreconditions(key, namespace).     if (isRehashing()) {         incrementalRehash().     }     return compositeHash(key, namespace). }
true;private;0;47;/**  * Runs a number of steps for incremental rehashing.  */ ;/**  * Runs a number of steps for incremental rehashing.  */ @SuppressWarnings("unchecked") private void incrementalRehash() {     StateTableEntry<K, N, S>[] oldTable = primaryTable.     StateTableEntry<K, N, S>[] newTable = incrementalRehashTable.     int oldCapacity = oldTable.length.     int newMask = newTable.length - 1.     int requiredVersion = highestRequiredSnapshotVersion.     int rhIdx = rehashIndex.     int transferred = 0.     // we migrate a certain minimum amount of entries from the old to the new table     while (transferred < MIN_TRANSFERRED_PER_INCREMENTAL_REHASH) {         StateTableEntry<K, N, S> e = oldTable[rhIdx].         while (e != null) {             // copy-on-write check for entry             if (e.entryVersion < requiredVersion) {                 e = new StateTableEntry<>(e, stateTableVersion).             }             StateTableEntry<K, N, S> n = e.next.             int pos = e.hash & newMask.             e.next = newTable[pos].             newTable[pos] = e.             e = n.             ++transferred.         }         oldTable[rhIdx] = null.         if (++rhIdx == oldCapacity) {             // here, the rehash is complete and we release resources and reset fields             primaryTable = newTable.             incrementalRehashTable = (StateTableEntry<K, N, S>[]) EMPTY_TABLE.             primaryTableSize += incrementalRehashTableSize.             incrementalRehashTableSize = 0.             rehashIndex = 0.             return.         }     }     // sync our local bookkeeping the with official bookkeeping fields     primaryTableSize -= transferred.     incrementalRehashTableSize += transferred.     rehashIndex = rhIdx. }
true;private;3;36;/**  * Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace  * all links up to the 'untilEntry', which we actually wanted to modify.  */ ;/**  * Perform copy-on-write for entry chains. We iterate the (hopefully and probably) still cached chain, replace  * all links up to the 'untilEntry', which we actually wanted to modify.  */ private StateTableEntry<K, N, S> handleChainedEntryCopyOnWrite(StateTableEntry<K, N, S>[] tab, int tableIdx, StateTableEntry<K, N, S> untilEntry) {     final int required = highestRequiredSnapshotVersion.     StateTableEntry<K, N, S> current = tab[tableIdx].     StateTableEntry<K, N, S> copy.     if (current.entryVersion < required) {         copy = new StateTableEntry<>(current, stateTableVersion).         tab[tableIdx] = copy.     } else {         // nothing to do, just advance copy to current         copy = current.     }     // we iterate the chain up to 'until entry'     while (current != untilEntry) {         // advance current         current = current.next.         if (current.entryVersion < required) {             // copy and advance the current's copy             copy.next = new StateTableEntry<>(current, stateTableVersion).             copy = copy.next.         } else {             // nothing to do, just advance copy to current             copy = current.         }     }     return copy. }
false;private,static;0;4;;@SuppressWarnings("unchecked") private static <K, N, S> StateTableEntry<K, N, S> getBootstrapEntry() {     return (StateTableEntry<K, N, S>) ITERATOR_BOOTSTRAP_ENTRY. }
true;private,static;2;4;/**  * Helper function that creates and scrambles a composite hash for key and namespace.  */ ;/**  * Helper function that creates and scrambles a composite hash for key and namespace.  */ private static int compositeHash(Object key, Object namespace) {     // create composite key through XOR, then apply some bit-mixing for better distribution of skewed keys.     return MathUtils.bitMix(key.hashCode() ^ namespace.hashCode()). }
false;;0;3;;// Snapshotting ---------------------------------------------------------------------------------------------------- int getStateTableVersion() {     return stateTableVersion. }
true;public;0;5;/**  * Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity  * is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call  * {@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.  *  * @return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.  */ ;/**  * Creates a snapshot of this {@link CopyOnWriteStateTable}, to be written in checkpointing. The snapshot integrity  * is protected through copy-on-write from the {@link CopyOnWriteStateTable}. Users should call  * {@link #releaseSnapshot(CopyOnWriteStateTableSnapshot)} after using the returned object.  *  * @return a snapshot from this {@link CopyOnWriteStateTable}, for checkpointing.  */ @Nonnull @Override public CopyOnWriteStateTableSnapshot<K, N, S> stateSnapshot() {     return new CopyOnWriteStateTableSnapshot<>(this). }
true;;1;7;/**  * Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,  * so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary  * object creation.  *  * @param snapshotToRelease the snapshot to release, which was previously created by this state table.  */ ;/**  * Releases a snapshot for this {@link CopyOnWriteStateTable}. This method should be called once a snapshot is no more needed,  * so that the {@link CopyOnWriteStateTable} can stop considering this snapshot for copy-on-write, thus avoiding unnecessary  * object creation.  *  * @param snapshotToRelease the snapshot to release, which was previously created by this state table.  */ void releaseSnapshot(CopyOnWriteStateTableSnapshot<K, N, S> snapshotToRelease) {     Preconditions.checkArgument(snapshotToRelease.isOwner(this), "Cannot release snapshot which is owned by a different state table.").     releaseSnapshot(snapshotToRelease.getSnapshotVersion()). }
false;public,final;2;7;;public final void setState(@Nullable S value, int mapVersion) {     // naturally, we can update the state version every time we replace the old state with a different object     if (value != state) {         this.state = value.         this.stateVersion = mapVersion.     } }
false;public;0;5;;@Nonnull @Override public K getKey() {     return key. }
false;public;0;5;;@Nonnull @Override public N getNamespace() {     return namespace. }
false;public;0;5;;@Nullable @Override public S getState() {     return state. }
false;public,final;1;11;;@Override public final boolean equals(Object o) {     if (!(o instanceof CopyOnWriteStateTable.StateTableEntry)) {         return false.     }     StateEntry<?, ?, ?> e = (StateEntry<?, ?, ?>) o.     return e.getKey().equals(key) && e.getNamespace().equals(namespace) && Objects.equals(e.getState(), state). }
false;public,final;0;4;;@Override public final int hashCode() {     return (key.hashCode() ^ namespace.hashCode()) ^ Objects.hashCode(state). }
false;public,final;0;4;;@Override public final String toString() {     return "(" + key + "|" + namespace + ")=" + state. }
false;public;1;10;;// For testing  ---------------------------------------------------------------------------------------------------- @Override public int sizeOfNamespace(Object namespace) {     int count = 0.     for (StateEntry<K, N, S> entry : this) {         if (null != entry && namespace.equals(entry.getNamespace())) {             ++count.         }     }     return count. }
false;public;1;4;;// StateEntryIterator  --------------------------------------------------------------------------------------------- @Override public StateIncrementalVisitor<K, N, S> getStateIncrementalVisitor(int recommendedMaxNumberOfReturnedRecords) {     return new StateIncrementalVisitorImpl(recommendedMaxNumberOfReturnedRecords). }
false;public;0;4;;@Override public boolean hasNext() {     return size() > 0 && (nextTablePosition < activeTable.length || activeTable == primaryTable). }
false;public;0;21;;@Override public StateTableEntry<K, N, S> next() {     StateTableEntry<K, N, S> next.     // consider both sub-tables to cover the case of rehash     while (true) {         // current is empty         // try get next in active table or         // iteration is done over primary and rehash table         // or primary was swapped with rehash when rehash is done         next = nextActiveTablePosition().         if (next != null || nextTablePosition < activeTable.length || activeTable == incrementalRehashTable || activeTable != primaryTable) {             return next.         } else {             // switch to rehash (empty if no rehash)             activeTable = incrementalRehashTable.             nextTablePosition = 0.         }     } }
false;private;0;12;;private StateTableEntry<K, N, S> nextActiveTablePosition() {     StateTableEntry<K, N, S>[] tab = activeTable.     int traversedPositions = 0.     while (nextTablePosition < tab.length && traversedPositions < maxTraversedTablePositions) {         StateTableEntry<K, N, S> next = tab[nextTablePosition++].         if (next != null) {             return next.         }         traversedPositions++.     }     return null. }
false;public;0;4;;@Override public boolean hasNext() {     return nextEntry != null. }
false;public;0;10;;@Override public StateEntry<K, N, S> next() {     if (modCount != expectedModCount) {         throw new ConcurrentModificationException().     }     if (!hasNext()) {         throw new NoSuchElementException().     }     return advanceIterator(). }
false;;0;9;;StateTableEntry<K, N, S> advanceIterator() {     StateTableEntry<K, N, S> entryToReturn = nextEntry.     StateTableEntry<K, N, S> next = nextEntry.next.     if (next == null) {         next = chainIterator.next().     }     nextEntry = next.     return entryToReturn. }
false;public;0;4;;@Override public boolean hasNext() {     return chainIterator.hasNext(). }
false;public;0;14;;@Override public Collection<StateEntry<K, N, S>> nextEntries() {     if (!hasNext()) {         return null.     }     chainToReturn.clear().     for (StateTableEntry<K, N, S> nextEntry = chainIterator.next(). nextEntry != null. nextEntry = nextEntry.next) {         chainToReturn.add(nextEntry).     }     return chainToReturn. }
false;public;1;4;;@Override public void remove(StateEntry<K, N, S> stateEntry) {     CopyOnWriteStateTable.this.remove(stateEntry.getKey(), stateEntry.getNamespace()). }
false;public;2;4;;@Override public void update(StateEntry<K, N, S> stateEntry, S newValue) {     CopyOnWriteStateTable.this.put(stateEntry.getKey(), stateEntry.getNamespace(), newValue). }
