commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns all routes in this router, an unmodifiable map of {@code PathPattern -> Target}.  */ ;// -------------------------------------------------------------------------- /**  * Returns all routes in this router, an unmodifiable map of {@code PathPattern -> Target}.  */ public Map<PathPattern, T> routes() {     return Collections.unmodifiableMap(routes). }
true;public;2;9;/**  * This method does nothing if the path pattern has already been added.  * A path pattern can only point to one target.  */ ;/**  * This method does nothing if the path pattern has already been added.  * A path pattern can only point to one target.  */ public MethodlessRouter<T> addRoute(String pathPattern, T target) {     PathPattern p = new PathPattern(pathPattern).     if (routes.containsKey(p)) {         return this.     }     routes.put(p, target).     return this. }
true;public;1;7;/**  * Removes the route specified by the path pattern.  */ ;// -------------------------------------------------------------------------- /**  * Removes the route specified by the path pattern.  */ public void removePathPattern(String pathPattern) {     PathPattern p = new PathPattern(pathPattern).     T target = routes.remove(p).     if (target == null) {         return.     } }
true;public;4;16;/**  * @return {@code null} if no match  */ ;// -------------------------------------------------------------------------- /**  * @return {@code null} if no match  */ public RouteResult<T> route(String uri, String decodedPath, Map<String, List<String>> queryParameters, String[] pathTokens) {     // Optimize: reuse requestPathTokens and pathParams in the loop     Map<String, String> pathParams = new HashMap<>().     for (Entry<PathPattern, T> entry : routes.entrySet()) {         PathPattern pattern = entry.getKey().         if (pattern.match(pathTokens, pathParams)) {             T target = entry.getValue().             return new RouteResult<T>(uri, decodedPath, pathParams, queryParameters, target).         }         // Reset for the next try         pathParams.clear().     }     return null. }
true;public;1;13;/**  * Checks if there's any matching route.  */ ;/**  * Checks if there's any matching route.  */ public boolean anyMatched(String[] requestPathTokens) {     Map<String, String> pathParams = new HashMap<>().     for (PathPattern pattern : routes.keySet()) {         if (pattern.match(requestPathTokens, pathParams)) {             return true.         }         // Reset for the next loop         pathParams.clear().     }     return false. }
false;public;0;3;;public int size() {     return routes.size(). }
