commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String[] getAggregatorNames() {     return this.aggNames. }
false;public;1;32;;public Value[] getAggregates(ClassLoader classResolver) {     if (aggregates == null) {         // we have read the binary data, but not yet turned into the objects         final int num = aggNames.length.         aggregates = new Value[num].         for (int i = 0. i < num. i++) {             Value v.             try {                 Class<? extends Value> valClass = Class.forName(classNames[i], true, classResolver).asSubclass(Value.class).                 v = InstantiationUtil.instantiate(valClass, Value.class).             } catch (ClassNotFoundException e) {                 throw new RuntimeException("Could not load user-defined class '" + classNames[i] + "'.", e).             } catch (ClassCastException e) {                 throw new RuntimeException("User-defined aggregator class is not a value sublass.").             }             try (DataInputViewStreamWrapper in = new DataInputViewStreamWrapper(new ByteArrayInputStream(serializedData[i]))) {                 v.read(in).             } catch (IOException e) {                 throw new RuntimeException("Error while deserializing the user-defined aggregate class.", e).             }             aggregates[i] = v.         }     }     return this.aggregates. }
false;public;1;24;;@Override public void write(DataOutputView out) throws IOException {     int num = this.aggNames.length.     out.writeInt(num).     ByteArrayOutputStream boas = new ByteArrayOutputStream().     DataOutputViewStreamWrapper bufferStream = new DataOutputViewStreamWrapper(boas).     for (int i = 0. i < num. i++) {         // aggregator name and type         out.writeUTF(this.aggNames[i]).         out.writeUTF(this.aggregates[i].getClass().getName()).         // aggregator value indirect as a byte array         this.aggregates[i].write(bufferStream).         bufferStream.flush().         byte[] bytes = boas.toByteArray().         out.writeInt(bytes.length).         out.write(bytes).         boas.reset().     }     bufferStream.close().     boas.close(). }
false;public;1;31;;@Override public void read(DataInputView in) throws IOException {     int num = in.readInt().     if (num == 0) {         this.aggNames = NO_STRINGS.         this.aggregates = NO_VALUES.     } else {         if (this.aggNames == null || num > this.aggNames.length) {             this.aggNames = new String[num].         }         if (this.classNames == null || num > this.classNames.length) {             this.classNames = new String[num].         }         if (this.serializedData == null || num > this.serializedData.length) {             this.serializedData = new byte[num][].         }         for (int i = 0. i < num. i++) {             this.aggNames[i] = in.readUTF().             this.classNames[i] = in.readUTF().             int len = in.readInt().             byte[] data = new byte[len].             this.serializedData[i] = data.             in.readFully(data).         }         this.aggregates = null.     } }
