commented;modifiers;parameterAmount;loc;comment;code
true;public;0;34;/**  * Cleans up transient BLOBs whose TTL is up, tolerating that files do not exist (anymore).  */ ;/**  * Cleans up transient BLOBs whose TTL is up, tolerating that files do not exist (anymore).  */ @Override public void run() {     // let's cache the current time - we do not operate on a millisecond precision anyway     final long currentTimeMillis = System.currentTimeMillis().     // iterate through all entries and remove those where the current time is past their expiry     Set<Map.Entry<Tuple2<JobID, TransientBlobKey>, Long>> entries = blobExpiryTimes.entrySet().     for (Map.Entry<Tuple2<JobID, TransientBlobKey>, Long> entry : entries) {         if (currentTimeMillis >= entry.getValue()) {             JobID jobId = entry.getKey().f0.             BlobKey blobKey = entry.getKey().f1.             final File localFile = new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId, blobKey)).             // deleting the file or changing blobExpiryTimes' contents needs to be protected by the lock             writeLock.lock().             try {                 try {                     Files.delete(localFile.toPath()).                 } catch (Exception e) {                     log.error("Failed to delete local blob " + localFile.getAbsolutePath(), e).                 }                 if (!localFile.exists()) {                     // this needs to happen inside the write lock in case of concurrent getFile() calls                     entries.remove(entry).                 }             } finally {                 writeLock.unlock().             }         }     } }
