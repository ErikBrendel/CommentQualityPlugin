commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;6;;@Override protected JobDetailsInfo handleRequest(HandlerRequest<EmptyRequestBody, JobMessageParameters> request, AccessExecutionGraph executionGraph) throws RestHandlerException {     return createJobDetailsInfo(executionGraph, metricFetcher). }
false;public;1;7;;@Override public Collection<ArchivedJson> archiveJsonWithPath(AccessExecutionGraph graph) throws IOException {     ResponseBody json = createJobDetailsInfo(graph, null).     String path = getMessageHeaders().getTargetRestEndpointURL().replace(':' + JobIDPathParameter.KEY, graph.getJobID().toString()).     return Collections.singleton(new ArchivedJson(path, json)). }
false;private,static;2;47;;private static JobDetailsInfo createJobDetailsInfo(AccessExecutionGraph executionGraph, @Nullable MetricFetcher metricFetcher) {     final long now = System.currentTimeMillis().     final long startTime = executionGraph.getStatusTimestamp(JobStatus.CREATED).     final long endTime = executionGraph.getState().isGloballyTerminalState() ? executionGraph.getStatusTimestamp(executionGraph.getState()) : -1L.     final long duration = (endTime > 0L ? endTime : now) - startTime.     final Map<JobStatus, Long> timestamps = new HashMap<>(JobStatus.values().length).     for (JobStatus jobStatus : JobStatus.values()) {         timestamps.put(jobStatus, executionGraph.getStatusTimestamp(jobStatus)).     }     Collection<JobDetailsInfo.JobVertexDetailsInfo> jobVertexInfos = new ArrayList<>(executionGraph.getAllVertices().size()).     int[] jobVerticesPerState = new int[ExecutionState.values().length].     for (AccessExecutionJobVertex accessExecutionJobVertex : executionGraph.getVerticesTopologically()) {         final JobDetailsInfo.JobVertexDetailsInfo vertexDetailsInfo = createJobVertexDetailsInfo(accessExecutionJobVertex, now, executionGraph.getJobID(), metricFetcher).         jobVertexInfos.add(vertexDetailsInfo).         jobVerticesPerState[vertexDetailsInfo.getExecutionState().ordinal()]++.     }     Map<ExecutionState, Integer> jobVerticesPerStateMap = new HashMap<>(ExecutionState.values().length).     for (ExecutionState executionState : ExecutionState.values()) {         jobVerticesPerStateMap.put(executionState, jobVerticesPerState[executionState.ordinal()]).     }     return new JobDetailsInfo(executionGraph.getJobID(), executionGraph.getJobName(), executionGraph.isStoppable(), executionGraph.getState(), startTime, endTime, duration, now, timestamps, jobVertexInfos, jobVerticesPerStateMap, executionGraph.getJsonPlan()). }
false;private,static;4;80;;private static JobDetailsInfo.JobVertexDetailsInfo createJobVertexDetailsInfo(AccessExecutionJobVertex ejv, long now, JobID jobId, MetricFetcher metricFetcher) {     int[] tasksPerState = new int[ExecutionState.values().length].     long startTime = Long.MAX_VALUE.     long endTime = 0.     boolean allFinished = true.     for (AccessExecutionVertex vertex : ejv.getTaskVertices()) {         final ExecutionState state = vertex.getExecutionState().         tasksPerState[state.ordinal()]++.         // take the earliest start time         long started = vertex.getStateTimestamp(ExecutionState.DEPLOYING).         if (started > 0L) {             startTime = Math.min(startTime, started).         }         allFinished &= state.isTerminal().         endTime = Math.max(endTime, vertex.getStateTimestamp(state)).     }     long duration.     if (startTime < Long.MAX_VALUE) {         if (allFinished) {             duration = endTime - startTime.         } else {             endTime = -1L.             duration = now - startTime.         }     } else {         startTime = -1L.         endTime = -1L.         duration = -1L.     }     ExecutionState jobVertexState = ExecutionJobVertex.getAggregateJobVertexState(tasksPerState, ejv.getParallelism()).     Map<ExecutionState, Integer> tasksPerStateMap = new HashMap<>(tasksPerState.length).     for (ExecutionState executionState : ExecutionState.values()) {         tasksPerStateMap.put(executionState, tasksPerState[executionState.ordinal()]).     }     MutableIOMetrics counts = new MutableIOMetrics().     for (AccessExecutionVertex vertex : ejv.getTaskVertices()) {         counts.addIOMetrics(vertex.getCurrentExecutionAttempt(), metricFetcher, jobId.toString(), ejv.getJobVertexId().toString()).     }     final IOMetricsInfo jobVertexMetrics = new IOMetricsInfo(counts.getNumBytesInLocal() + counts.getNumBytesInRemote(), counts.isNumBytesInLocalComplete() && counts.isNumBytesInRemoteComplete(), counts.getNumBytesOut(), counts.isNumBytesOutComplete(), counts.getNumRecordsIn(), counts.isNumRecordsInComplete(), counts.getNumRecordsOut(), counts.isNumRecordsOutComplete()).     return new JobDetailsInfo.JobVertexDetailsInfo(ejv.getJobVertexId(), ejv.getName(), ejv.getParallelism(), jobVertexState, startTime, endTime, duration, tasksPerStateMap, jobVertexMetrics). }
