commented;modifiers;parameterAmount;loc;comment;code
true;public;0;6;/**  * This is the call back method for the spill writer. If a spill is still  * in progress when this view is created we wait until this method is called  * before we notify the availability listener.  */ ;/**  * This is the call back method for the spill writer. If a spill is still  * in progress when this view is created we wait until this method is called  * before we notify the availability listener.  */ @Override public void onNotification() {     isSpillInProgress = false.     availabilityListener.notifyDataAvailable().     LOG.debug("Finished spilling. Notified about {} available buffers.", numberOfSpilledBuffers). }
false;public;0;26;;@Nullable @Override public BufferAndBacklog getNextBuffer() throws IOException, InterruptedException {     if (isSpillInProgress) {         return null.     }     Buffer current.     boolean nextBufferIsEvent.     synchronized (this) {         if (nextBuffer == null) {             current = requestAndFillBuffer().         } else {             current = nextBuffer.         }         nextBuffer = requestAndFillBuffer().         nextBufferIsEvent = nextBuffer != null && !nextBuffer.isBuffer().     }     if (current == null) {         return null.     }     int newBacklog = parent.decreaseBuffersInBacklog(current).     return new BufferAndBacklog(current, newBacklog > 0 || nextBufferIsEvent, newBacklog, nextBufferIsEvent). }
false;private;0;13;;@Nullable private Buffer requestAndFillBuffer() throws IOException, InterruptedException {     assert Thread.holdsLock(this).     if (fileReader.hasReachedEndOfFile()) {         return null.     }     // TODO This is fragile as we implicitly expect that multiple calls to     // this method don't happen before recycling buffers returned earlier.     Buffer buffer = bufferPool.requestBufferBlocking().     fileReader.readInto(buffer).     return buffer. }
false;public;0;7;;@Override public void notifyDataAvailable() { // We do the availability listener notification either directly on // construction of this view (when everything has been spilled) or // as soon as spilling is done and we are notified about it in the // #onNotification callback. }
false;public;0;4;;@Override public void notifySubpartitionConsumed() throws IOException {     parent.onConsumedSubpartition(). }
false;public;0;20;;@Override public void releaseAllResources() throws IOException {     if (isReleased.compareAndSet(false, true)) {         // TODO This can block until all buffers are written out to         // disk if a spill is in-progress before deleting the file.         // It is possibly called from the Netty event loop threads,         // which can bring down the network.         spillWriter.closeAndDelete().         synchronized (this) {             fileReader.close().             if (nextBuffer != null) {                 nextBuffer.recycleBuffer().                 nextBuffer = null.             }         }         bufferPool.destroy().     } }
false;public;0;4;;@Override public boolean isReleased() {     return parent.isReleased() || isReleased.get(). }
false;public;0;14;;@Override public boolean nextBufferIsEvent() {     synchronized (this) {         if (nextBuffer == null) {             try {                 nextBuffer = requestAndFillBuffer().             } catch (Exception e) {                 // we can ignore this here (we will get it again once getNextBuffer() is called)                 return false.             }         }         return nextBuffer != null && !nextBuffer.isBuffer().     } }
false;public,synchronized;0;7;;@Override public synchronized boolean isAvailable() {     if (nextBuffer != null) {         return true.     }     return !fileReader.hasReachedEndOfFile(). }
false;public;0;4;;@Override public Throwable getFailureCause() {     return parent.getFailureCause(). }
false;public;0;7;;@Override public String toString() {     return String.format("SpilledSubpartitionView(index: %d, buffers: %d) of ResultPartition %s", parent.index, numberOfSpilledBuffers, parent.parent.getPartitionId()). }
false;public;1;11;;@Override public void recycle(MemorySegment memorySegment) {     synchronized (buffers) {         if (isDestroyed) {             memorySegment.free().         } else {             buffers.add(new NetworkBuffer(memorySegment, this)).             buffers.notifyAll().         }     } }
false;private;0;17;;private Buffer requestBufferBlocking() throws InterruptedException {     synchronized (buffers) {         while (true) {             if (isDestroyed) {                 return null.             }             Buffer buffer = buffers.poll().             if (buffer != null) {                 return buffer.             }             // Else: wait for a buffer             buffers.wait().         }     } }
false;private;0;6;;private void destroy() {     synchronized (buffers) {         isDestroyed = true.         buffers.notifyAll().     } }
