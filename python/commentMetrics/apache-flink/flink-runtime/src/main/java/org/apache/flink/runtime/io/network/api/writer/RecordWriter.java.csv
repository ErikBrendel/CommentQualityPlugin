commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public void emit(T record) throws IOException, InterruptedException {     checkErroneous().     emit(record, channelSelector.selectChannel(record)). }
true;public;1;16;/**  * This is used to broadcast Streaming Watermarks in-band with records. This ignores  * the {@link ChannelSelector}.  */ ;/**  * This is used to broadcast Streaming Watermarks in-band with records. This ignores  * the {@link ChannelSelector}.  */ public void broadcastEmit(T record) throws IOException, InterruptedException {     checkErroneous().     serializer.serializeRecord(record).     boolean pruneAfterCopying = false.     for (int channel : broadcastChannels) {         if (copyFromSerializerToTargetChannel(channel)) {             pruneAfterCopying = true.         }     }     // Make sure we don't hold onto the large intermediate serialization buffer for too long     if (pruneAfterCopying) {         serializer.prune().     } }
true;public;1;3;/**  * This is used to send LatencyMarks to a random target channel.  */ ;/**  * This is used to send LatencyMarks to a random target channel.  */ public void randomEmit(T record) throws IOException, InterruptedException {     emit(record, rng.nextInt(numberOfChannels)). }
false;private;2;7;;private void emit(T record, int targetChannel) throws IOException, InterruptedException {     serializer.serializeRecord(record).     if (copyFromSerializerToTargetChannel(targetChannel)) {         serializer.prune().     } }
true;private;1;31;/**  * @param targetChannel  * @return <tt>true</tt> if the intermediate serialization buffer should be pruned  */ ;/**  * @param targetChannel  * @return <tt>true</tt> if the intermediate serialization buffer should be pruned  */ private boolean copyFromSerializerToTargetChannel(int targetChannel) throws IOException, InterruptedException {     // We should reset the initial position of the intermediate serialization buffer before     // copying, so the serialization results can be copied to multiple target buffers.     serializer.reset().     boolean pruneTriggered = false.     BufferBuilder bufferBuilder = getBufferBuilder(targetChannel).     SerializationResult result = serializer.copyToBufferBuilder(bufferBuilder).     while (result.isFullBuffer()) {         numBytesOut.inc(bufferBuilder.finish()).         numBuffersOut.inc().         // problem per se, but it can lead to stalls in the pipeline).         if (result.isFullRecord()) {             pruneTriggered = true.             bufferBuilders[targetChannel] = Optional.empty().             break.         }         bufferBuilder = requestNewBufferBuilder(targetChannel).         result = serializer.copyToBufferBuilder(bufferBuilder).     }     checkState(!serializer.hasSerializedData(), "All data should be written at once").     if (flushAlways) {         targetPartition.flush(targetChannel).     }     return pruneTriggered. }
false;public;1;14;;public void broadcastEvent(AbstractEvent event) throws IOException {     try (BufferConsumer eventBufferConsumer = EventSerializer.toBufferConsumer(event)) {         for (int targetChannel = 0. targetChannel < numberOfChannels. targetChannel++) {             tryFinishCurrentBufferBuilder(targetChannel).             // Retain the buffer so that it can be recycled by each channel of targetPartition             targetPartition.addBufferConsumer(eventBufferConsumer.copy(), targetChannel).         }         if (flushAlways) {             flushAll().         }     } }
false;public;0;3;;public void flushAll() {     targetPartition.flushAll(). }
false;public;0;5;;public void clearBuffers() {     for (int targetChannel = 0. targetChannel < numberOfChannels. targetChannel++) {         closeBufferBuilder(targetChannel).     } }
true;public;1;4;/**  * Sets the metric group for this RecordWriter.  */ ;/**  * Sets the metric group for this RecordWriter.  */ public void setMetricGroup(TaskIOMetricGroup metrics) {     numBytesOut = metrics.getNumBytesOutCounter().     numBuffersOut = metrics.getNumBuffersOutCounter(). }
true;private;1;9;/**  * Marks the current {@link BufferBuilder} as finished and clears the state for next one.  */ ;/**  * Marks the current {@link BufferBuilder} as finished and clears the state for next one.  */ private void tryFinishCurrentBufferBuilder(int targetChannel) {     if (!bufferBuilders[targetChannel].isPresent()) {         return.     }     BufferBuilder bufferBuilder = bufferBuilders[targetChannel].get().     bufferBuilders[targetChannel] = Optional.empty().     numBytesOut.inc(bufferBuilder.finish()).     numBuffersOut.inc(). }
true;private;1;7;/**  * The {@link BufferBuilder} may already exist if not filled up last time, otherwise we need  * request a new one for this target channel.  */ ;/**  * The {@link BufferBuilder} may already exist if not filled up last time, otherwise we need  * request a new one for this target channel.  */ private BufferBuilder getBufferBuilder(int targetChannel) throws IOException, InterruptedException {     if (bufferBuilders[targetChannel].isPresent()) {         return bufferBuilders[targetChannel].get().     } else {         return requestNewBufferBuilder(targetChannel).     } }
false;private;1;8;;private BufferBuilder requestNewBufferBuilder(int targetChannel) throws IOException, InterruptedException {     checkState(!bufferBuilders[targetChannel].isPresent() || bufferBuilders[targetChannel].get().isFinished()).     BufferBuilder bufferBuilder = targetPartition.getBufferProvider().requestBufferBuilderBlocking().     bufferBuilders[targetChannel] = Optional.of(bufferBuilder).     targetPartition.addBufferConsumer(bufferBuilder.createBufferConsumer(), targetChannel).     return bufferBuilder. }
false;private;1;6;;private void closeBufferBuilder(int targetChannel) {     if (bufferBuilders[targetChannel].isPresent()) {         bufferBuilders[targetChannel].get().finish().         bufferBuilders[targetChannel] = Optional.empty().     } }
true;public;0;14;/**  * Closes the writer. This stops the flushing thread (if there is one).  */ ;/**  * Closes the writer. This stops the flushing thread (if there is one).  */ public void close() {     clearBuffers().     // make sure we terminate the thread in any case     if (outputFlusher.isPresent()) {         outputFlusher.get().terminate().         try {             outputFlusher.get().join().         } catch (InterruptedException e) {             // ignore on close             // restore interrupt flag to fast exit further blocking calls             Thread.currentThread().interrupt().         }     } }
true;private;1;6;/**  * Notifies the writer that the output flusher thread encountered an exception.  *  * @param t The exception to report.  */ ;/**  * Notifies the writer that the output flusher thread encountered an exception.  *  * @param t The exception to report.  */ private void notifyFlusherException(Throwable t) {     if (flusherException == null) {         LOG.error("An exception happened while flushing the outputs", t).         flusherException = t.     } }
false;private;0;5;;private void checkErroneous() throws IOException {     if (flusherException != null) {         throw new IOException("An exception happened while flushing the outputs", flusherException).     } }
false;public,static;4;11;;public static RecordWriter createRecordWriter(ResultPartitionWriter writer, ChannelSelector channelSelector, long timeout, String taskName) {     if (channelSelector.isBroadcast()) {         return new BroadcastRecordWriter<>(writer, channelSelector, timeout, taskName).     } else {         return new RecordWriter<>(writer, channelSelector, timeout, taskName).     } }
false;public,static;3;6;;public static RecordWriter createRecordWriter(ResultPartitionWriter writer, ChannelSelector channelSelector, String taskName) {     return createRecordWriter(writer, channelSelector, -1, taskName). }
false;public;0;4;;public void terminate() {     running = false.     interrupt(). }
false;public;0;22;;@Override public void run() {     try {         while (running) {             try {                 Thread.sleep(timeout).             } catch (InterruptedException e) {                 // in that case                 if (running) {                     throw new Exception(e).                 }             }             // any errors here should let the thread come to a halt and be             // recognized by the writer             flushAll().         }     } catch (Throwable t) {         notifyFlusherException(t).     } }
