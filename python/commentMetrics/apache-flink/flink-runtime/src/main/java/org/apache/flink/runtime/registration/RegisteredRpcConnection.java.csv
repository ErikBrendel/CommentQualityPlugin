commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;// ------------------------------------------------------------------------ // Life cycle // ------------------------------------------------------------------------ public void start() {     checkState(!closed, "The RPC connection is already closed").     checkState(!isConnected() && pendingRegistration == null, "The RPC connection is already started").     final RetryingRegistration<F, G, S> newRegistration = createNewRegistration().     if (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) {         newRegistration.startRegistration().     } else {         // concurrent start operation         newRegistration.cancel().     } }
false;public;0;32;;public boolean tryReconnect() {     checkState(isConnected(), "Cannot reconnect to an unknown destination.").     if (closed) {         return false.     } else {         final RetryingRegistration<F, G, S> currentPendingRegistration = pendingRegistration.         if (currentPendingRegistration != null) {             currentPendingRegistration.cancel().         }         final RetryingRegistration<F, G, S> newRegistration = createNewRegistration().         if (REGISTRATION_UPDATER.compareAndSet(this, currentPendingRegistration, newRegistration)) {             newRegistration.startRegistration().         } else {             // concurrent modification             newRegistration.cancel().             return false.         }         // double check for concurrent close operations         if (closed) {             newRegistration.cancel().             return false.         } else {             return true.         }     } }
true;protected,abstract;0;1;/**  * This method generate a specific Registration, for example TaskExecutor Registration at the ResourceManager.  */ ;/**  * This method generate a specific Registration, for example TaskExecutor Registration at the ResourceManager.  */ protected abstract RetryingRegistration<F, G, S> generateRegistration().
true;protected,abstract;1;1;/**  * This method handle the Registration Response.  */ ;/**  * This method handle the Registration Response.  */ protected abstract void onRegistrationSuccess(S success).
true;protected,abstract;1;1;/**  * This method handle the Registration failure.  */ ;/**  * This method handle the Registration failure.  */ protected abstract void onRegistrationFailure(Throwable failure).
true;public;0;8;/**  * Close connection.  */ ;/**  * Close connection.  */ public void close() {     closed = true.     // make sure we do not keep re-trying forever     if (pendingRegistration != null) {         pendingRegistration.cancel().     } }
false;public;0;3;;public boolean isClosed() {     return closed. }
false;public;0;3;;// ------------------------------------------------------------------------ // Properties // ------------------------------------------------------------------------ public F getTargetLeaderId() {     return fencingToken. }
false;public;0;3;;public String getTargetAddress() {     return targetAddress. }
true;public;0;3;/**  * Gets the RegisteredGateway. This returns null until the registration is completed.  */ ;/**  * Gets the RegisteredGateway. This returns null until the registration is completed.  */ public G getTargetGateway() {     return targetGateway. }
false;public;0;3;;public boolean isConnected() {     return targetGateway != null. }
false;public;0;20;;// ------------------------------------------------------------------------ @Override public String toString() {     String connectionInfo = "(ADDRESS: " + targetAddress + " FENCINGTOKEN: " + fencingToken + ")".     if (isConnected()) {         connectionInfo = "RPC connection to " + targetGateway.getClass().getSimpleName() + " " + connectionInfo.     } else {         connectionInfo = "RPC connection to " + connectionInfo.     }     if (isClosed()) {         connectionInfo += " is closed".     } else if (isConnected()) {         connectionInfo += " is established".     } else {         connectionInfo += " is connecting".     }     return connectionInfo. }
false;private;0;24;;// ------------------------------------------------------------------------ // Internal methods // ------------------------------------------------------------------------ private RetryingRegistration<F, G, S> createNewRegistration() {     RetryingRegistration<F, G, S> newRegistration = checkNotNull(generateRegistration()).     CompletableFuture<Tuple2<G, S>> future = newRegistration.getFuture().     future.whenCompleteAsync((Tuple2<G, S> result, Throwable failure) -> {         if (failure != null) {             if (failure instanceof CancellationException) {                 // we ignore cancellation exceptions because they originate from cancelling                 // the RetryingRegistration                 log.debug("Retrying registration towards {} was cancelled.", targetAddress).             } else {                 // this future should only ever fail if there is a bug, not if the registration is declined                 onRegistrationFailure(failure).             }         } else {             targetGateway = result.f0.             onRegistrationSuccess(result.f1).         }     }, executor).     return newRegistration. }
