commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;9;;@Override protected void decode(ChannelHandlerContext context, ByteBuf in, List<Object> out) {     if (in.readableBytes() >= SSL_RECORD_HEADER_LENGTH && SslHandler.isEncrypted(in)) {         handleSsl(context).     } else {         context.pipeline().replace(this, HTTP_CODEC_HANDLER_NAME, new HttpServerCodec()).         context.pipeline().addAfter(HTTP_CODEC_HANDLER_NAME, NON_SSL_HANDLER_NAME, new NonSslHandler()).     } }
false;private;1;9;;private void handleSsl(ChannelHandlerContext context) {     SslHandler sslHandler = sslHandlerFactory.createNettySSLHandler().     try {         context.pipeline().replace(this, SSL_HANDLER_NAME, sslHandler).     } catch (Throwable t) {         ReferenceCountUtil.safeRelease(sslHandler.engine()).         throw t.     } }
false;public;2;14;;@Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {     HttpRequest request = msg instanceof HttpRequest ? (HttpRequest) msg : null.     String path = request == null ? "" : request.uri().     String redirectAddress = getRedirectAddress(ctx).     log.trace("Received non-SSL request, redirecting to {}{}", redirectAddress, path).     HttpResponse response = HandlerRedirectUtils.getRedirectResponse(redirectAddress, path, HttpResponseStatus.MOVED_PERMANENTLY).     if (request != null) {         KeepAliveWrite.flush(ctx, request, response).     } else {         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE).     } }
false;private;1;4;;private String getRedirectAddress(ChannelHandlerContext ctx) throws Exception {     return redirectBaseUrl.isDone() ? redirectBaseUrl.get() : confRedirectBaseUrl + ((InetSocketAddress) (ctx.channel()).localAddress()).getPort(). }
