commented;modifiers;parameterAmount;loc;comment;code
true;public;2;4;/**  * Returns a file handle to the file associated with the given blob key on the blob  * server.  *  * <p><strong>This is only called from {@link BlobServerConnection} or unit tests.</strong>  *  * @param jobId ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param key identifying the file  * @return file handle to the file  *  * @throws IOException  * 		if creating the directory fails  */ ;// -------------------------------------------------------------------------------------------- // Path Accessors // -------------------------------------------------------------------------------------------- /**  * Returns a file handle to the file associated with the given blob key on the blob  * server.  *  * <p><strong>This is only called from {@link BlobServerConnection} or unit tests.</strong>  *  * @param jobId ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param key identifying the file  * @return file handle to the file  *  * @throws IOException  * 		if creating the directory fails  */ @VisibleForTesting public File getStorageLocation(@Nullable JobID jobId, BlobKey key) throws IOException {     return BlobUtils.getStorageLocation(storageDir, jobId, key). }
true;;0;4;/**  * Returns a temporary file inside the BLOB server's incoming directory.  *  * @return a temporary file inside the BLOB server's incoming directory  *  * @throws IOException  * 		if creating the directory fails  */ ;/**  * Returns a temporary file inside the BLOB server's incoming directory.  *  * @return a temporary file inside the BLOB server's incoming directory  *  * @throws IOException  * 		if creating the directory fails  */ File createTemporaryFilename() throws IOException {     return new File(BlobUtils.getIncomingDirectory(storageDir), String.format("temp-%08d", tempFileCounter.getAndIncrement())). }
true;;0;3;/**  * Returns the lock used to guard file accesses.  */ ;/**  * Returns the lock used to guard file accesses.  */ ReadWriteLock getReadWriteLock() {     return readWriteLock. }
false;public;0;38;;@Override public void run() {     try {         while (!this.shutdownRequested.get()) {             BlobServerConnection conn = new BlobServerConnection(serverSocket.accept(), this).             try {                 synchronized (activeConnections) {                     while (activeConnections.size() >= maxConnections) {                         activeConnections.wait(2000).                     }                     activeConnections.add(conn).                 }                 conn.start().                 conn = null.             } finally {                 if (conn != null) {                     conn.close().                     synchronized (activeConnections) {                         activeConnections.remove(conn).                     }                 }             }         }     } catch (Throwable t) {         if (!this.shutdownRequested.get()) {             LOG.error("BLOB server stopped working. Shutting down", t).             try {                 close().             } catch (Throwable closeThrowable) {                 LOG.error("Could not properly close the BlobServer.", closeThrowable).             }         }     } }
true;public;0;54;/**  * Shuts down the BLOB server.  */ ;/**  * Shuts down the BLOB server.  */ @Override public void close() throws IOException {     cleanupTimer.cancel().     if (shutdownRequested.compareAndSet(false, true)) {         Exception exception = null.         try {             this.serverSocket.close().         } catch (IOException ioe) {             exception = ioe.         }         // wake the thread up, in case it is waiting on some operation         interrupt().         try {             join().         } catch (InterruptedException ie) {             Thread.currentThread().interrupt().             LOG.debug("Error while waiting for this thread to die.", ie).         }         synchronized (activeConnections) {             if (!activeConnections.isEmpty()) {                 for (BlobServerConnection conn : activeConnections) {                     LOG.debug("Shutting down connection {}.", conn.getName()).                     conn.close().                 }                 activeConnections.clear().             }         }         // Clean up the storage directory         try {             FileUtils.deleteDirectory(storageDir).         } catch (IOException e) {             exception = ExceptionUtils.firstOrSuppressed(e, exception).         }         // Remove shutdown hook to prevent resource leaks         ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG).         if (LOG.isInfoEnabled()) {             LOG.info("Stopped BLOB server at {}:{}", serverSocket.getInetAddress().getHostAddress(), getPort()).         }         ExceptionUtils.tryRethrowIOException(exception).     } }
false;protected;0;4;;protected BlobClient createClient() throws IOException {     return new BlobClient(new InetSocketAddress(serverSocket.getInetAddress(), getPort()), blobServiceConfiguration). }
true;public;1;4;/**  * Retrieves the local path of a (job-unrelated) file associated with a job and a blob key.  *  * <p>The blob server looks the blob key up in its local storage. If the file exists, it is  * returned. If the file does not exist, it is retrieved from the HA blob store (if available)  * or a {@link FileNotFoundException} is thrown.  *  * @param key  * 		blob key associated with the requested file  *  * @return file referring to the local storage location of the BLOB  *  * @throws IOException  * 		Thrown if the file retrieval failed.  */ ;/**  * Retrieves the local path of a (job-unrelated) file associated with a job and a blob key.  *  * <p>The blob server looks the blob key up in its local storage. If the file exists, it is  * returned. If the file does not exist, it is retrieved from the HA blob store (if available)  * or a {@link FileNotFoundException} is thrown.  *  * @param key  * 		blob key associated with the requested file  *  * @return file referring to the local storage location of the BLOB  *  * @throws IOException  * 		Thrown if the file retrieval failed.  */ @Override public File getFile(TransientBlobKey key) throws IOException {     return getFileInternal(null, key). }
true;public;2;5;/**  * Retrieves the local path of a file associated with a job and a blob key.  *  * <p>The blob server looks the blob key up in its local storage. If the file exists, it is  * returned. If the file does not exist, it is retrieved from the HA blob store (if available)  * or a {@link FileNotFoundException} is thrown.  *  * @param jobId  * 		ID of the job this blob belongs to  * @param key  * 		blob key associated with the requested file  *  * @return file referring to the local storage location of the BLOB  *  * @throws IOException  * 		Thrown if the file retrieval failed.  */ ;/**  * Retrieves the local path of a file associated with a job and a blob key.  *  * <p>The blob server looks the blob key up in its local storage. If the file exists, it is  * returned. If the file does not exist, it is retrieved from the HA blob store (if available)  * or a {@link FileNotFoundException} is thrown.  *  * @param jobId  * 		ID of the job this blob belongs to  * @param key  * 		blob key associated with the requested file  *  * @return file referring to the local storage location of the BLOB  *  * @throws IOException  * 		Thrown if the file retrieval failed.  */ @Override public File getFile(JobID jobId, TransientBlobKey key) throws IOException {     checkNotNull(jobId).     return getFileInternal(jobId, key). }
true;public;2;5;/**  * Returns the path to a local copy of the file associated with the provided job ID and blob  * key.  *  * <p>We will first attempt to serve the BLOB from the local storage. If the BLOB is not in  * there, we will try to download it from the HA store.  *  * @param jobId  * 		ID of the job this blob belongs to  * @param key  * 		blob key associated with the requested file  *  * @return The path to the file.  *  * @throws java.io.FileNotFoundException  * 		if the BLOB does not exist.  * @throws IOException  * 		if any other error occurs when retrieving the file  */ ;/**  * Returns the path to a local copy of the file associated with the provided job ID and blob  * key.  *  * <p>We will first attempt to serve the BLOB from the local storage. If the BLOB is not in  * there, we will try to download it from the HA store.  *  * @param jobId  * 		ID of the job this blob belongs to  * @param key  * 		blob key associated with the requested file  *  * @return The path to the file.  *  * @throws java.io.FileNotFoundException  * 		if the BLOB does not exist.  * @throws IOException  * 		if any other error occurs when retrieving the file  */ @Override public File getFile(JobID jobId, PermanentBlobKey key) throws IOException {     checkNotNull(jobId).     return getFileInternal(jobId, key). }
true;private;2;13;/**  * Retrieves the local path of a file associated with a job and a blob key.  *  * <p>The blob server looks the blob key up in its local storage. If the file exists, it is  * returned. If the file does not exist, it is retrieved from the HA blob store (if available)  * or a {@link FileNotFoundException} is thrown.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param blobKey  * 		blob key associated with the requested file  *  * @return file referring to the local storage location of the BLOB  *  * @throws IOException  * 		Thrown if the file retrieval failed.  */ ;/**  * Retrieves the local path of a file associated with a job and a blob key.  *  * <p>The blob server looks the blob key up in its local storage. If the file exists, it is  * returned. If the file does not exist, it is retrieved from the HA blob store (if available)  * or a {@link FileNotFoundException} is thrown.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param blobKey  * 		blob key associated with the requested file  *  * @return file referring to the local storage location of the BLOB  *  * @throws IOException  * 		Thrown if the file retrieval failed.  */ private File getFileInternal(@Nullable JobID jobId, BlobKey blobKey) throws IOException {     checkArgument(blobKey != null, "BLOB key cannot be null.").     final File localFile = BlobUtils.getStorageLocation(storageDir, jobId, blobKey).     readWriteLock.readLock().lock().     try {         getFileInternal(jobId, blobKey, localFile).         return localFile.     } finally {         readWriteLock.readLock().unlock().     } }
true;;3;49;/**  * Helper to retrieve the local path of a file associated with a job and a blob key.  *  * <p>The blob server looks the blob key up in its local storage. If the file exists, it is  * returned. If the file does not exist, it is retrieved from the HA blob store (if available)  * or a {@link FileNotFoundException} is thrown.  *  * <p><strong>Assumes the read lock has already been acquired.</strong>  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param blobKey  * 		blob key associated with the requested file  * @param localFile  *      (local) file where the blob is/should be stored  *  * @throws IOException  * 		Thrown if the file retrieval failed.  */ ;/**  * Helper to retrieve the local path of a file associated with a job and a blob key.  *  * <p>The blob server looks the blob key up in its local storage. If the file exists, it is  * returned. If the file does not exist, it is retrieved from the HA blob store (if available)  * or a {@link FileNotFoundException} is thrown.  *  * <p><strong>Assumes the read lock has already been acquired.</strong>  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param blobKey  * 		blob key associated with the requested file  * @param localFile  *      (local) file where the blob is/should be stored  *  * @throws IOException  * 		Thrown if the file retrieval failed.  */ void getFileInternal(@Nullable JobID jobId, BlobKey blobKey, File localFile) throws IOException {     if (localFile.exists()) {         // update TTL for transient BLOBs:         if (blobKey instanceof TransientBlobKey) {             // regarding concurrent operations, it is not really important which timestamp makes             // it into the map as they are close to each other anyway, also we can simply             // overwrite old values as long as we are in the read (or write) lock             blobExpiryTimes.put(Tuple2.of(jobId, (TransientBlobKey) blobKey), System.currentTimeMillis() + cleanupInterval).         }         return.     } else if (blobKey instanceof PermanentBlobKey) {         // Try the HA blob store         // first we have to release the read lock in order to acquire the write lock         readWriteLock.readLock().unlock().         // use a temporary file (thread-safe without locking)         File incomingFile = null.         try {             incomingFile = createTemporaryFilename().             blobStore.get(jobId, blobKey, incomingFile).             readWriteLock.writeLock().lock().             try {                 BlobUtils.moveTempFileToStore(incomingFile, jobId, blobKey, localFile, LOG, null).             } finally {                 readWriteLock.writeLock().unlock().             }             return.         } finally {             // delete incomingFile from a failed download             if (incomingFile != null && !incomingFile.delete() && incomingFile.exists()) {                 LOG.warn("Could not delete the staging file {} for blob key {} and job {}.", incomingFile, blobKey, jobId).             }             // re-acquire lock so that it can be unlocked again outside             readWriteLock.readLock().lock().         }     }     throw new FileNotFoundException("Local file " + localFile + " does not exist " + "and failed to copy from blob store."). }
false;public;1;4;;@Override public TransientBlobKey putTransient(byte[] value) throws IOException {     return (TransientBlobKey) putBuffer(null, value, TRANSIENT_BLOB). }
false;public;2;5;;@Override public TransientBlobKey putTransient(JobID jobId, byte[] value) throws IOException {     checkNotNull(jobId).     return (TransientBlobKey) putBuffer(jobId, value, TRANSIENT_BLOB). }
false;public;1;4;;@Override public TransientBlobKey putTransient(InputStream inputStream) throws IOException {     return (TransientBlobKey) putInputStream(null, inputStream, TRANSIENT_BLOB). }
false;public;2;5;;@Override public TransientBlobKey putTransient(JobID jobId, InputStream inputStream) throws IOException {     checkNotNull(jobId).     return (TransientBlobKey) putInputStream(jobId, inputStream, TRANSIENT_BLOB). }
false;public;2;5;;@Override public PermanentBlobKey putPermanent(JobID jobId, byte[] value) throws IOException {     checkNotNull(jobId).     return (PermanentBlobKey) putBuffer(jobId, value, PERMANENT_BLOB). }
false;public;2;5;;@Override public PermanentBlobKey putPermanent(JobID jobId, InputStream inputStream) throws IOException {     checkNotNull(jobId).     return (PermanentBlobKey) putInputStream(jobId, inputStream, PERMANENT_BLOB). }
true;private;3;35;/**  * Uploads the data of the given byte array for the given job to the BLOB server.  *  * @param jobId  * 		the ID of the job the BLOB belongs to  * @param value  * 		the buffer to upload  * @param blobType  * 		whether to make the data permanent or transient  *  * @return the computed BLOB key identifying the BLOB on the server  *  * @throws IOException  * 		thrown if an I/O error occurs while writing it to a local file, or uploading it to the HA  * 		store  */ ;/**  * Uploads the data of the given byte array for the given job to the BLOB server.  *  * @param jobId  * 		the ID of the job the BLOB belongs to  * @param value  * 		the buffer to upload  * @param blobType  * 		whether to make the data permanent or transient  *  * @return the computed BLOB key identifying the BLOB on the server  *  * @throws IOException  * 		thrown if an I/O error occurs while writing it to a local file, or uploading it to the HA  * 		store  */ private BlobKey putBuffer(@Nullable JobID jobId, byte[] value, BlobKey.BlobType blobType) throws IOException {     if (LOG.isDebugEnabled()) {         LOG.debug("Received PUT call for BLOB of job {}.", jobId).     }     File incomingFile = createTemporaryFilename().     MessageDigest md = BlobUtils.createMessageDigest().     BlobKey blobKey = null.     try (FileOutputStream fos = new FileOutputStream(incomingFile)) {         md.update(value).         fos.write(value).     } catch (IOException ioe) {         // delete incomingFile from a failed download         if (!incomingFile.delete() && incomingFile.exists()) {             LOG.warn("Could not delete the staging file {} for job {}.", incomingFile, jobId).         }         throw ioe.     }     try {         // persist file         blobKey = moveTempFileToStore(incomingFile, jobId, md.digest(), blobType).         return blobKey.     } finally {         // delete incomingFile from a failed download         if (!incomingFile.delete() && incomingFile.exists()) {             LOG.warn("Could not delete the staging file {} for blob key {} and job {}.", incomingFile, blobKey, jobId).         }     } }
true;private;3;36;/**  * Uploads the data from the given input stream for the given job to the BLOB server.  *  * @param jobId  * 		the ID of the job the BLOB belongs to  * @param inputStream  * 		the input stream to read the data from  * @param blobType  * 		whether to make the data permanent or transient  *  * @return the computed BLOB key identifying the BLOB on the server  *  * @throws IOException  * 		thrown if an I/O error occurs while reading the data from the input stream, writing it to a  * 		local file, or uploading it to the HA store  */ ;/**  * Uploads the data from the given input stream for the given job to the BLOB server.  *  * @param jobId  * 		the ID of the job the BLOB belongs to  * @param inputStream  * 		the input stream to read the data from  * @param blobType  * 		whether to make the data permanent or transient  *  * @return the computed BLOB key identifying the BLOB on the server  *  * @throws IOException  * 		thrown if an I/O error occurs while reading the data from the input stream, writing it to a  * 		local file, or uploading it to the HA store  */ private BlobKey putInputStream(@Nullable JobID jobId, InputStream inputStream, BlobKey.BlobType blobType) throws IOException {     if (LOG.isDebugEnabled()) {         LOG.debug("Received PUT call for BLOB of job {}.", jobId).     }     File incomingFile = createTemporaryFilename().     MessageDigest md = BlobUtils.createMessageDigest().     BlobKey blobKey = null.     try (FileOutputStream fos = new FileOutputStream(incomingFile)) {         // read stream         byte[] buf = new byte[BUFFER_SIZE].         while (true) {             final int bytesRead = inputStream.read(buf).             if (bytesRead == -1) {                 // done                 break.             }             fos.write(buf, 0, bytesRead).             md.update(buf, 0, bytesRead).         }         // persist file         blobKey = moveTempFileToStore(incomingFile, jobId, md.digest(), blobType).         return blobKey.     } finally {         // delete incomingFile from a failed download         if (!incomingFile.delete() && incomingFile.exists()) {             LOG.warn("Could not delete the staging file {} for blob key {} and job {}.", incomingFile, blobKey, jobId).         }     } }
true;;4;45;/**  * Moves the temporary <tt>incomingFile</tt> to its permanent location where it is available for  * use.  *  * @param incomingFile  * 		temporary file created during transfer  * @param jobId  * 		ID of the job this blob belongs to or <tt>null</tt> if job-unrelated  * @param digest  * 		BLOB content digest, i.e. hash  * @param blobType  * 		whether this file is a permanent or transient BLOB  *  * @return unique BLOB key that identifies the BLOB on the server  *  * @throws IOException  * 		thrown if an I/O error occurs while moving the file or uploading it to the HA store  */ ;/**  * Moves the temporary <tt>incomingFile</tt> to its permanent location where it is available for  * use.  *  * @param incomingFile  * 		temporary file created during transfer  * @param jobId  * 		ID of the job this blob belongs to or <tt>null</tt> if job-unrelated  * @param digest  * 		BLOB content digest, i.e. hash  * @param blobType  * 		whether this file is a permanent or transient BLOB  *  * @return unique BLOB key that identifies the BLOB on the server  *  * @throws IOException  * 		thrown if an I/O error occurs while moving the file or uploading it to the HA store  */ BlobKey moveTempFileToStore(File incomingFile, @Nullable JobID jobId, byte[] digest, BlobKey.BlobType blobType) throws IOException {     int retries = 10.     int attempt = 0.     while (true) {         // add unique component independent of the BLOB content         BlobKey blobKey = BlobKey.createKey(blobType, digest).         File storageFile = BlobUtils.getStorageLocation(storageDir, jobId, blobKey).         // try again until the key is unique (put the existence check into the lock!)         readWriteLock.writeLock().lock().         try {             if (!storageFile.exists()) {                 BlobUtils.moveTempFileToStore(incomingFile, jobId, blobKey, storageFile, LOG, blobKey instanceof PermanentBlobKey ? blobStore : null).                 // add TTL for transient BLOBs:                 if (blobKey instanceof TransientBlobKey) {                     // must be inside read or write lock to add a TTL                     blobExpiryTimes.put(Tuple2.of(jobId, (TransientBlobKey) blobKey), System.currentTimeMillis() + cleanupInterval).                 }                 return blobKey.             }         } finally {             readWriteLock.writeLock().unlock().         }         ++attempt.         if (attempt >= retries) {             String message = "Failed to find a unique key for BLOB of job " + jobId + " (last tried " + storageFile.getAbsolutePath() + ".".             LOG.error(message + " No retries left.").             throw new IOException(message).         } else {             if (LOG.isDebugEnabled()) {                 LOG.debug("Trying to find a unique key for BLOB of job {} (retry {}, last tried {})", jobId, attempt, storageFile.getAbsolutePath()).             }         }     } }
true;public;1;4;/**  * Deletes the (job-unrelated) file associated with the blob key in the local storage of the  * blob server.  *  * @param key  * 		blob key associated with the file to be deleted  *  * @return  <tt>true</tt> if the given blob is successfully deleted or non-existing.  *          <tt>false</tt> otherwise  */ ;/**  * Deletes the (job-unrelated) file associated with the blob key in the local storage of the  * blob server.  *  * @param key  * 		blob key associated with the file to be deleted  *  * @return  <tt>true</tt> if the given blob is successfully deleted or non-existing.  *          <tt>false</tt> otherwise  */ @Override public boolean deleteFromCache(TransientBlobKey key) {     return deleteInternal(null, key). }
true;public;2;5;/**  * Deletes the file associated with the blob key in the local storage of the blob server.  *  * @param jobId  * 		ID of the job this blob belongs to  * @param key  * 		blob key associated with the file to be deleted  *  * @return  <tt>true</tt> if the given blob is successfully deleted or non-existing.  *          <tt>false</tt> otherwise  */ ;/**  * Deletes the file associated with the blob key in the local storage of the blob server.  *  * @param jobId  * 		ID of the job this blob belongs to  * @param key  * 		blob key associated with the file to be deleted  *  * @return  <tt>true</tt> if the given blob is successfully deleted or non-existing.  *          <tt>false</tt> otherwise  */ @Override public boolean deleteFromCache(JobID jobId, TransientBlobKey key) {     checkNotNull(jobId).     return deleteInternal(jobId, key). }
true;;2;18;/**  * Deletes the file associated with the blob key in the local storage of the blob server.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param key  * 		blob key associated with the file to be deleted  *  * @return  <tt>true</tt> if the given blob is successfully deleted or non-existing.  *          <tt>false</tt> otherwise  */ ;/**  * Deletes the file associated with the blob key in the local storage of the blob server.  *  * @param jobId  * 		ID of the job this blob belongs to (or <tt>null</tt> if job-unrelated)  * @param key  * 		blob key associated with the file to be deleted  *  * @return  <tt>true</tt> if the given blob is successfully deleted or non-existing.  *          <tt>false</tt> otherwise  */ boolean deleteInternal(@Nullable JobID jobId, TransientBlobKey key) {     final File localFile = new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId, key)).     readWriteLock.writeLock().lock().     try {         if (!localFile.delete() && localFile.exists()) {             LOG.warn("Failed to locally delete BLOB " + key + " at " + localFile.getAbsolutePath()).             return false.         }         // this needs to happen inside the write lock in case of concurrent getFile() calls         blobExpiryTimes.remove(Tuple2.of(jobId, key)).         return true.     } finally {         readWriteLock.writeLock().unlock().     } }
true;public;2;33;/**  * Removes all BLOBs from local and HA store belonging to the given job ID.  *  * @param jobId  * 		ID of the job this blob belongs to  * @param cleanupBlobStoreFiles  * 		True if the corresponding blob store files shall be cleaned up as well. Otherwise false.  *  * @return  <tt>true</tt> if the job directory is successfully deleted or non-existing.  *          <tt>false</tt> otherwise  */ ;/**  * Removes all BLOBs from local and HA store belonging to the given job ID.  *  * @param jobId  * 		ID of the job this blob belongs to  * @param cleanupBlobStoreFiles  * 		True if the corresponding blob store files shall be cleaned up as well. Otherwise false.  *  * @return  <tt>true</tt> if the job directory is successfully deleted or non-existing.  *          <tt>false</tt> otherwise  */ public boolean cleanupJob(JobID jobId, boolean cleanupBlobStoreFiles) {     checkNotNull(jobId).     final File jobDir = new File(BlobUtils.getStorageLocationPath(storageDir.getAbsolutePath(), jobId)).     readWriteLock.writeLock().lock().     try {         // delete locally         boolean deletedLocally = false.         try {             FileUtils.deleteDirectory(jobDir).             // NOTE: Instead of going through blobExpiryTimes, keep lingering entries - they             // will be cleaned up by the timer task which tolerates non-existing files             // If inserted again with the same IDs (via put()), the TTL will be updated             // again.             deletedLocally = true.         } catch (IOException e) {             LOG.warn("Failed to locally delete BLOB storage directory at " + jobDir.getAbsolutePath(), e).         }         // delete in HA blob store files         final boolean deletedHA = !cleanupBlobStoreFiles || blobStore.deleteAll(jobId).         return deletedLocally && deletedHA.     } finally {         readWriteLock.writeLock().unlock().     } }
false;public;0;4;;@Override public PermanentBlobService getPermanentBlobService() {     return this. }
false;public;0;4;;@Override public TransientBlobService getTransientBlobService() {     return this. }
true;public,final;0;4;/**  * Returns the configuration used by the BLOB server.  *  * @return configuration  */ ;/**  * Returns the configuration used by the BLOB server.  *  * @return configuration  */ @Override public final int getMinOffloadingSize() {     return blobServiceConfiguration.getInteger(BlobServerOptions.OFFLOAD_MINSIZE). }
true;public;0;4;/**  * Returns the port on which the server is listening.  *  * @return port on which the server is listening  */ ;/**  * Returns the port on which the server is listening.  *  * @return port on which the server is listening  */ @Override public int getPort() {     return this.serverSocket.getLocalPort(). }
true;;0;4;/**  * Returns the blob expiry times - for testing purposes only!  *  * @return blob expiry times (internal state!)  */ ;/**  * Returns the blob expiry times - for testing purposes only!  *  * @return blob expiry times (internal state!)  */ @VisibleForTesting ConcurrentMap<Tuple2<JobID, TransientBlobKey>, Long> getBlobExpiryTimes() {     return blobExpiryTimes. }
true;public;0;3;/**  * Tests whether the BLOB server has been requested to shut down.  *  * @return True, if the server has been requested to shut down, false otherwise.  */ ;/**  * Tests whether the BLOB server has been requested to shut down.  *  * @return True, if the server has been requested to shut down, false otherwise.  */ public boolean isShutdown() {     return this.shutdownRequested.get(). }
true;;0;3;/**  * Access to the server socket, for testing.  */ ;/**  * Access to the server socket, for testing.  */ ServerSocket getServerSocket() {     return this.serverSocket. }
false;;1;6;;void unregisterConnection(BlobServerConnection conn) {     synchronized (activeConnections) {         activeConnections.remove(conn).         activeConnections.notifyAll().     } }
true;;0;5;/**  * Returns all the current active connections in the BlobServer.  *  * @return the list of all the active in current BlobServer  */ ;/**  * Returns all the current active connections in the BlobServer.  *  * @return the list of all the active in current BlobServer  */ List<BlobServerConnection> getCurrentActiveConnections() {     synchronized (activeConnections) {         return new ArrayList<>(activeConnections).     } }
