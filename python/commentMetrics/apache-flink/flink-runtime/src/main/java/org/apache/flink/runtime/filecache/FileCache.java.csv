commented;modifiers;parameterAmount;loc;comment;code
true;public;0;32;/**  * Shuts down the file cache by cancelling all.  */ ;/**  * Shuts down the file cache by cancelling all.  */ public void shutdown() {     synchronized (lock) {         // first shutdown the thread pool         ScheduledExecutorService es = this.executorService.         if (es != null) {             es.shutdown().             try {                 es.awaitTermination(cleanupInterval, TimeUnit.MILLISECONDS).             } catch (InterruptedException e) {             // may happen             }         }         entries.clear().         jobRefHolders.clear().         // clean up the all storage directories         for (File dir : storageDirectories) {             try {                 FileUtils.deleteDirectory(dir).                 LOG.info("removed file cache directory {}", dir.getAbsolutePath()).             } catch (IOException e) {                 LOG.error("File cache could not properly clean up storage directory: {}", dir.getAbsolutePath(), e).             }         }         // Remove shutdown hook to prevent resource leaks         ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG).     } }
true;public;4;39;/**  * If the file doesn't exists locally, retrieve the file from the blob-service.  *  * @param entry The cache entry descriptor (path, executable flag)  * @param jobID The ID of the job for which the file is copied.  * @return The handle to the task that copies the file.  */ ;// ------------------------------------------------------------------------ /**  * If the file doesn't exists locally, retrieve the file from the blob-service.  *  * @param entry The cache entry descriptor (path, executable flag)  * @param jobID The ID of the job for which the file is copied.  * @return The handle to the task that copies the file.  */ public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception {     synchronized (lock) {         Map<String, Future<Path>> jobEntries = entries.computeIfAbsent(jobID, k -> new HashMap<>()).         // register reference holder         final Set<ExecutionAttemptID> refHolders = jobRefHolders.computeIfAbsent(jobID, id -> new HashSet<>()).         refHolders.add(executionId).         Future<Path> fileEntry = jobEntries.get(name).         if (fileEntry != null) {             // immediately returns the file             return fileEntry.         } else {             // need to copy the file             // create the target path             File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString()).             if (nextDirectory >= storageDirectories.length) {                 nextDirectory = 0.             }             // kick off the copying             Callable<Path> cp.             if (entry.blobKey != null) {                 cp = new CopyFromBlobProcess(entry, jobID, blobService, new Path(tempDirToUse.getAbsolutePath())).             } else {                 cp = new CopyFromDFSProcess(entry, new Path(tempDirToUse.getAbsolutePath())).             }             FutureTask<Path> copyTask = new FutureTask<>(cp).             executorService.submit(copyTask).             // store our entry             jobEntries.put(name, copyTask).             return copyTask.         }     } }
false;private,static;2;8;;private static Thread createShutdownHook(final FileCache cache, final Logger logger) {     return ShutdownHookUtil.addShutdownHook(cache::shutdown, FileCache.class.getSimpleName(), logger). }
false;public;2;16;;public void releaseJob(JobID jobId, ExecutionAttemptID executionId) {     checkNotNull(jobId).     synchronized (lock) {         Set<ExecutionAttemptID> jobRefCounter = jobRefHolders.get(jobId).         if (jobRefCounter == null || jobRefCounter.isEmpty()) {             return.         }         jobRefCounter.remove(executionId).         if (jobRefCounter.isEmpty()) {             executorService.schedule(new DeleteProcess(jobId), cleanupInterval, TimeUnit.MILLISECONDS).         }     } }
false;public;0;14;;@Override public Path call() throws IOException {     final File file = blobService.getFile(jobID, blobKey).     if (isDirectory) {         Path directory = FileUtils.expandDirectory(new Path(file.getAbsolutePath()), target).         return directory.     } else {         // noinspection ResultOfMethodCallIgnored         file.setExecutable(isExecutable).         return Path.fromLocalFile(file).     } }
false;public;0;7;;@Override public Path call() throws IOException {     // let exceptions propagate. we can retrieve them later from     // the future and report them upon access to the result     FileUtils.copy(filePath, cachedPath, this.executable).     return cachedPath. }
false;public;0;27;;@Override public void run() {     try {         synchronized (lock) {             Set<ExecutionAttemptID> jobRefs = jobRefHolders.get(jobID).             if (jobRefs != null && jobRefs.isEmpty()) {                 // abort the copy                 for (Future<Path> fileFuture : entries.get(jobID).values()) {                     fileFuture.cancel(true).                 }                 // remove job specific entries in maps                 entries.remove(jobID).                 jobRefHolders.remove(jobID).                 // remove the job wide temp directories                 for (File storageDirectory : storageDirectories) {                     File tempDir = new File(storageDirectory, jobID.toString()).                     FileUtils.deleteDirectory(tempDir).                 }             }         }     } catch (IOException e) {         LOG.error("Could not delete file from local file cache.", e).     } }
