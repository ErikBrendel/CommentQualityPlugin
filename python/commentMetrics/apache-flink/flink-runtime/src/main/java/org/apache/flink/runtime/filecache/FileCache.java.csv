# id;timestamp;commentText;codeText;commentWords;codeWords
FileCache -> public void shutdown();1431371277;Shuts down the file cache by cancelling all;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}_			_			entries.clear()__			_			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			_			if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_				try {_					Runtime.getRuntime().removeShutdownHook(shutdownHook)__				}_				catch (IllegalStateException e) {_					_				}_				catch (Throwable t) {_					LOG.warn("Exception while unregistering file cache's cleanup shutdown hook.")__				}_			}_		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,file,cache,s,cleanup,shutdown,hook
FileCache -> public void shutdown();1446112342;Shuts down the file cache by cancelling all;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}_			_			entries.clear()__			_			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			_			if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_				try {_					Runtime.getRuntime().removeShutdownHook(shutdownHook)__				}_				catch (IllegalStateException e) {_					_				}_				catch (Throwable t) {_					LOG.warn("Exception while unregistering file cache's cleanup shutdown hook.")__				}_			}_		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,file,cache,s,cleanup,shutdown,hook
FileCache -> public void shutdown();1460741894;Shuts down the file cache by cancelling all;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}_			_			entries.clear()__			_			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			_			if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_				try {_					Runtime.getRuntime().removeShutdownHook(shutdownHook)__				}_				catch (IllegalStateException e) {_					_				}_				catch (Throwable t) {_					LOG.warn("Exception while unregistering file cache's cleanup shutdown hook.")__				}_			}_		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,file,cache,s,cleanup,shutdown,hook
FileCache -> public void shutdown();1463093468;Shuts down the file cache by cancelling all;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}_			_			entries.clear()__			_			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			_			if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_				try {_					Runtime.getRuntime().removeShutdownHook(shutdownHook)__				}_				catch (IllegalStateException e) {_					_				}_				catch (Throwable t) {_					LOG.warn("Exception while unregistering file cache's cleanup shutdown hook.")__				}_			}_		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,file,cache,s,cleanup,shutdown,hook
FileCache -> public void shutdown();1469728126;Shuts down the file cache by cancelling all;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}_			_			entries.clear()__			_			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			_			if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_				try {_					Runtime.getRuntime().removeShutdownHook(shutdownHook)__				}_				catch (IllegalStateException e) {_					_				}_				catch (Throwable t) {_					LOG.warn("Exception while unregistering file cache's cleanup shutdown hook.")__				}_			}_		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,file,cache,s,cleanup,shutdown,hook
FileCache -> public void shutdown();1479853012;Shuts down the file cache by cancelling all;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}_			_			entries.clear()__			_			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			_			if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_				try {_					Runtime.getRuntime().removeShutdownHook(shutdownHook)__				}_				catch (IllegalStateException e) {_					_				}_				catch (Throwable t) {_					LOG.warn("Exception while unregistering file cache's cleanup shutdown hook.")__				}_			}_		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,file,cache,s,cleanup,shutdown,hook
FileCache -> public void shutdown();1482522862;Shuts down the file cache by cancelling all;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}_			_			entries.clear()__			_			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			_			if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_				try {_					Runtime.getRuntime().removeShutdownHook(shutdownHook)__				}_				catch (IllegalStateException e) {_					_				}_				catch (Throwable t) {_					LOG.warn("Exception while unregistering file cache's cleanup shutdown hook.")__				}_			}_		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,file,cache,s,cleanup,shutdown,hook
FileCache -> public void shutdown();1486740510;Shuts down the file cache by cancelling all;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}_			_			entries.clear()__			_			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			_			if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_				try {_					Runtime.getRuntime().removeShutdownHook(shutdownHook)__				}_				catch (IllegalStateException e) {_					_				}_				catch (Throwable t) {_					LOG.warn("Exception while unregistering file cache's cleanup shutdown hook.")__				}_			}_		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,file,cache,s,cleanup,shutdown,hook
FileCache -> public void shutdown();1496869568;Shuts down the file cache by cancelling all.;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}__			entries.clear()___			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			_			if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_				try {_					Runtime.getRuntime().removeShutdownHook(shutdownHook)__				}_				catch (IllegalStateException e) {_					_				}_				catch (Throwable t) {_					LOG.warn("Exception while unregistering file cache's cleanup shutdown hook.")__				}_			}_		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,file,cache,s,cleanup,shutdown,hook
FileCache -> public void shutdown();1498220069;Shuts down the file cache by cancelling all.;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}__			entries.clear()___			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			_			if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_				try {_					Runtime.getRuntime().removeShutdownHook(shutdownHook)__				}_				catch (IllegalStateException e) {_					_				}_				catch (Throwable t) {_					LOG.warn("Exception while unregistering file cache's cleanup shutdown hook.")__				}_			}_		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,e,catch,throwable,t,log,warn,exception,while,unregistering,file,cache,s,cleanup,shutdown,hook
FileCache -> public void shutdown();1519567828;Shuts down the file cache by cancelling all.;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(5000L, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}__			entries.clear()___			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG)__		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,5000l,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,shutdown,hook,util,remove,shutdown,hook,shutdown,hook,get,class,get,simple,name,log
FileCache -> public void shutdown();1525420604;Shuts down the file cache by cancelling all.;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(cleanupInterval, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}__			entries.clear()__			jobRefHolders.clear()___			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG)__		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,cleanup,interval,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,job,ref,holders,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,shutdown,hook,util,remove,shutdown,hook,shutdown,hook,get,class,get,simple,name,log
FileCache -> public void shutdown();1529065669;Shuts down the file cache by cancelling all.;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(cleanupInterval, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}__			entries.clear()__			jobRefHolders.clear()___			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG)__		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,cleanup,interval,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,job,ref,holders,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,shutdown,hook,util,remove,shutdown,hook,shutdown,hook,get,class,get,simple,name,log
FileCache -> public void shutdown();1529583969;Shuts down the file cache by cancelling all.;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(cleanupInterval, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}__			entries.clear()__			jobRefHolders.clear()___			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG)__		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,cleanup,interval,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,job,ref,holders,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,shutdown,hook,util,remove,shutdown,hook,shutdown,hook,get,class,get,simple,name,log
FileCache -> public void shutdown();1536223031;Shuts down the file cache by cancelling all.;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(cleanupInterval, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}__			entries.clear()__			jobRefHolders.clear()___			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory.")__				}_			}__			_			ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG)__		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,cleanup,interval,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,job,ref,holders,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,shutdown,hook,util,remove,shutdown,hook,shutdown,hook,get,class,get,simple,name,log
FileCache -> public void shutdown();1550138430;Shuts down the file cache by cancelling all.;public void shutdown() {_		synchronized (lock) {_			_			ScheduledExecutorService es = this.executorService__			if (es != null) {_				es.shutdown()__				try {_					es.awaitTermination(cleanupInterval, TimeUnit.MILLISECONDS)__				}_				catch (InterruptedException e) {_					_				}_			}__			entries.clear()__			jobRefHolders.clear()___			_			for (File dir : storageDirectories) {_				try {_					FileUtils.deleteDirectory(dir)__					LOG.info("removed file cache directory {}", dir.getAbsolutePath())__				}_				catch (IOException e) {_					LOG.error("File cache could not properly clean up storage directory: {}", dir.getAbsolutePath(), e)__				}_			}__			_			ShutdownHookUtil.removeShutdownHook(shutdownHook, getClass().getSimpleName(), LOG)__		}_	};shuts,down,the,file,cache,by,cancelling,all;public,void,shutdown,synchronized,lock,scheduled,executor,service,es,this,executor,service,if,es,null,es,shutdown,try,es,await,termination,cleanup,interval,time,unit,milliseconds,catch,interrupted,exception,e,entries,clear,job,ref,holders,clear,for,file,dir,storage,directories,try,file,utils,delete,directory,dir,log,info,removed,file,cache,directory,dir,get,absolute,path,catch,ioexception,e,log,error,file,cache,could,not,properly,clean,up,storage,directory,dir,get,absolute,path,e,shutdown,hook,util,remove,shutdown,hook,shutdown,hook,get,class,get,simple,name,log
FileCache -> public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1405024514;Deletes the local file after a 5 second delay._@param name file identifier_@param entry entry containing all relevant information_@param jobID;public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(name, entry, jobID, count.get(new ImmutablePair<JobID, String>(jobID,name)))__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id;public,void,delete,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,delete,process,dp,new,delete,process,name,entry,job,id,count,get,new,immutable,pair,job,id,string,job,id,name,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1405090423;Deletes the local file after a 5 second delay._@param name file identifier_@param entry entry containing all relevant information_@param jobID;public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(name, entry, jobID, count.get(new ImmutablePair<JobID, String>(jobID,name)))__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id;public,void,delete,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,delete,process,dp,new,delete,process,name,entry,job,id,count,get,new,immutable,pair,job,id,string,job,id,name,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1411236168;Deletes the local file after a 5 second delay._@param name file identifier_@param entry entry containing all relevant information_@param jobID;public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(name, entry, jobID, count.get(new ImmutablePair<JobID, String>(jobID,name)))__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id;public,void,delete,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,delete,process,dp,new,delete,process,name,entry,job,id,count,get,new,immutable,pair,job,id,string,job,id,name,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1411473593;Deletes the local file after a 5 second delay._@param name file identifier_@param entry entry containing all relevant information_@param jobID;public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(name, entry, jobID, count.get(new ImmutablePair<JobID, String>(jobID,name)))__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id;public,void,delete,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,delete,process,dp,new,delete,process,name,entry,job,id,count,get,new,immutable,pair,job,id,string,job,id,name,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1413290542;Deletes the local file after a 5 second delay._@param name file identifier_@param entry entry containing all relevant information_@param jobID;public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(name, entry, jobID, count.get(new ImmutablePair<JobID, String>(jobID,name)))__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id;public,void,delete,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,delete,process,dp,new,delete,process,name,entry,job,id,count,get,new,immutable,pair,job,id,string,job,id,name,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1422833259;Deletes the local file after a 5 second delay._@param name file identifier_@param entry entry containing all relevant information_@param jobID;public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(name, entry, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id;public,void,delete,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,delete,process,dp,new,delete,process,name,entry,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1427784999;Deletes the local file after a 5 second delay._@param name file identifier_@param entry entry containing all relevant information_@param jobID;public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(name, entry, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id;public,void,delete,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,delete,process,dp,new,delete,process,name,entry,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1405024514;If the file doesn't exists locally, it will copy the file to the temp directory._@param name file identifier_@param entry entry containing all relevant information_@param jobID_@return copy task;public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (count) {_			Pair<JobID, String> key = new ImmutablePair<JobID, String>(jobID, name)__			if (count.containsKey(key)) {_				count.put(key, count.get(key) + 1)__			} else {_				count.put(key, 1)__			}_		}_		CopyProcess cp = new CopyProcess(name, entry, jobID)__		FutureTask<Path> copyTask = new FutureTask<Path>(cp)__		executorService.submit(copyTask)__		return copyTask__	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id,return,copy,task;public,future,task,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,count,pair,job,id,string,key,new,immutable,pair,job,id,string,job,id,name,if,count,contains,key,key,count,put,key,count,get,key,1,else,count,put,key,1,copy,process,cp,new,copy,process,name,entry,job,id,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,return,copy,task
FileCache -> public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1405090423;If the file doesn't exists locally, it will copy the file to the temp directory._@param name file identifier_@param entry entry containing all relevant information_@param jobID_@return copy task;public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (count) {_			Pair<JobID, String> key = new ImmutablePair<JobID, String>(jobID, name)__			if (count.containsKey(key)) {_				count.put(key, count.get(key) + 1)__			} else {_				count.put(key, 1)__			}_		}_		CopyProcess cp = new CopyProcess(name, entry, jobID)__		FutureTask<Path> copyTask = new FutureTask<Path>(cp)__		executorService.submit(copyTask)__		return copyTask__	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id,return,copy,task;public,future,task,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,count,pair,job,id,string,key,new,immutable,pair,job,id,string,job,id,name,if,count,contains,key,key,count,put,key,count,get,key,1,else,count,put,key,1,copy,process,cp,new,copy,process,name,entry,job,id,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,return,copy,task
FileCache -> public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1411236168;If the file doesn't exists locally, it will copy the file to the temp directory._@param name file identifier_@param entry entry containing all relevant information_@param jobID_@return copy task;public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (count) {_			Pair<JobID, String> key = new ImmutablePair<JobID, String>(jobID, name)__			if (count.containsKey(key)) {_				count.put(key, count.get(key) + 1)__			} else {_				count.put(key, 1)__			}_		}_		CopyProcess cp = new CopyProcess(name, entry, jobID)__		FutureTask<Path> copyTask = new FutureTask<Path>(cp)__		executorService.submit(copyTask)__		return copyTask__	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id,return,copy,task;public,future,task,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,count,pair,job,id,string,key,new,immutable,pair,job,id,string,job,id,name,if,count,contains,key,key,count,put,key,count,get,key,1,else,count,put,key,1,copy,process,cp,new,copy,process,name,entry,job,id,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,return,copy,task
FileCache -> public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1411473593;If the file doesn't exists locally, it will copy the file to the temp directory._@param name file identifier_@param entry entry containing all relevant information_@param jobID_@return copy task;public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (count) {_			Pair<JobID, String> key = new ImmutablePair<JobID, String>(jobID, name)__			if (count.containsKey(key)) {_				count.put(key, count.get(key) + 1)__			} else {_				count.put(key, 1)__			}_		}_		CopyProcess cp = new CopyProcess(name, entry, jobID)__		FutureTask<Path> copyTask = new FutureTask<Path>(cp)__		executorService.submit(copyTask)__		return copyTask__	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id,return,copy,task;public,future,task,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,count,pair,job,id,string,key,new,immutable,pair,job,id,string,job,id,name,if,count,contains,key,key,count,put,key,count,get,key,1,else,count,put,key,1,copy,process,cp,new,copy,process,name,entry,job,id,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,return,copy,task
FileCache -> public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1413290542;If the file doesn't exists locally, it will copy the file to the temp directory._@param name file identifier_@param entry entry containing all relevant information_@param jobID_@return copy task;public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (count) {_			Pair<JobID, String> key = new ImmutablePair<JobID, String>(jobID, name)__			if (count.containsKey(key)) {_				count.put(key, count.get(key) + 1)__			} else {_				count.put(key, 1)__			}_		}_		CopyProcess cp = new CopyProcess(name, entry, jobID)__		FutureTask<Path> copyTask = new FutureTask<Path>(cp)__		executorService.submit(copyTask)__		return copyTask__	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id,return,copy,task;public,future,task,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,count,pair,job,id,string,key,new,immutable,pair,job,id,string,job,id,name,if,count,contains,key,key,count,put,key,count,get,key,1,else,count,put,key,1,copy,process,cp,new,copy,process,name,entry,job,id,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,return,copy,task
FileCache -> public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1422833259;If the file doesn't exists locally, it will copy the file to the temp directory._@param name file identifier_@param entry entry containing all relevant information_@param jobID_@return copy task;public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			if (!jobCounts.containsKey(jobID)) {_				jobCounts.put(jobID, new HashMap<String, Integer>())__			}_			Map<String, Integer> count = jobCounts.get(jobID)__			if (count.containsKey(name)) {_				count.put(name, count.get(name) + 1)__			} else {_				count.put(name, 1)__			}_		}_		CopyProcess cp = new CopyProcess(entry, jobID)__		FutureTask<Path> copyTask = new FutureTask<Path>(cp)__		executorService.submit(copyTask)__		return copyTask__	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id,return,copy,task;public,future,task,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,if,job,counts,contains,key,job,id,job,counts,put,job,id,new,hash,map,string,integer,map,string,integer,count,job,counts,get,job,id,if,count,contains,key,name,count,put,name,count,get,name,1,else,count,put,name,1,copy,process,cp,new,copy,process,entry,job,id,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,return,copy,task
FileCache -> public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1427784999;If the file doesn't exists locally, it will copy the file to the temp directory._@param name file identifier_@param entry entry containing all relevant information_@param jobID_@return copy task;public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			if (!jobCounts.containsKey(jobID)) {_				jobCounts.put(jobID, new HashMap<String, Integer>())__			}_			Map<String, Integer> count = jobCounts.get(jobID)__			if (count.containsKey(name)) {_				count.put(name, count.get(name) + 1)__			} else {_				count.put(name, 1)__			}_		}_		CopyProcess cp = new CopyProcess(entry, jobID)__		FutureTask<Path> copyTask = new FutureTask<Path>(cp)__		executorService.submit(copyTask)__		return copyTask__	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,file,identifier,param,entry,entry,containing,all,relevant,information,param,job,id,return,copy,task;public,future,task,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,if,job,counts,contains,key,job,id,job,counts,put,job,id,new,hash,map,string,integer,map,string,integer,count,job,counts,get,job,id,if,count,contains,key,name,count,put,name,count,get,name,1,else,count,put,name,1,copy,process,cp,new,copy,process,entry,job,id,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,return,copy,task
FileCache -> public void deleteTmpFile(String name, JobID jobID);1431371277;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, JobID jobID);1446112342;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, JobID jobID);1460741894;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, JobID jobID);1463093468;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, JobID jobID);1469728126;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, JobID jobID);1479853012;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, JobID jobID);1482522862;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, JobID jobID);1486740510;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, JobID jobID);1496869568;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, JobID jobID);1498220069;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public void deleteTmpFile(String name, JobID jobID);1519567828;Deletes the local file after a 5 second delay.__@param name  The name under which the file is registered._@param jobID The ID of the job for which the file is copied.;public void deleteTmpFile(String name, JobID jobID) {_		DeleteProcess dp = new DeleteProcess(lock, entries, name, jobID)__		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS)__	};deletes,the,local,file,after,a,5,second,delay,param,name,the,name,under,which,the,file,is,registered,param,job,id,the,id,of,the,job,for,which,the,file,is,copied;public,void,delete,tmp,file,string,name,job,id,job,id,delete,process,dp,new,delete,process,lock,entries,name,job,id,executor,service,schedule,dp,5000l,time,unit,milliseconds
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1431371277;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1__				_				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)__				_				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))__				_				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1446112342;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1__				_				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)__				_				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))__				_				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1460741894;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1__				_				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)__				_				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))__				_				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1463093468;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1__				_				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)__				_				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))__				_				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1469728126;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1__				_				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)__				_				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))__				_				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1479853012;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1__				_				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)__				_				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))__				_				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1482522862;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1__				_				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)__				_				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))__				_				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1486740510;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1__				_				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)__				_				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))__				_				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1496869568;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1___				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)___				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))___				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1498220069;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1___				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)___				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))___				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID);1519567828;If the file doesn't exists locally, it will copy the file to the temp directory.__@param name  The name under which the file is registered._@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {_		synchronized (lock) {_			Map<String, Tuple4<Integer, File, Path, Future<Path>>> jobEntries = entries.get(jobID)__			if (jobEntries == null) {_				jobEntries = new HashMap<String, Tuple4<Integer, File, Path, Future<Path>>>()__				entries.put(jobID, jobEntries)__			}__			_			Tuple4<Integer, File, Path, Future<Path>> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				fileEntry.f0 = fileEntry.f0 + 1___				_				return fileEntry.f3__			}_			else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				CopyProcess cp = new CopyProcess(entry, target)__				FutureTask<Path> copyTask = new FutureTask<Path>(cp)__				executorService.submit(copyTask)___				_				jobEntries.put(name, new Tuple4<Integer, File, Path, Future<Path>>(1, tempDirToUse, target, copyTask))___				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,name,the,name,under,which,the,file,is,registered,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,synchronized,lock,map,string,tuple4,integer,file,path,future,path,job,entries,entries,get,job,id,if,job,entries,null,job,entries,new,hash,map,string,tuple4,integer,file,path,future,path,entries,put,job,id,job,entries,tuple4,integer,file,path,future,path,file,entry,job,entries,get,name,if,file,entry,null,file,entry,f0,file,entry,f0,1,return,file,entry,f3,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,copy,process,cp,new,copy,process,entry,target,future,task,path,copy,task,new,future,task,path,cp,executor,service,submit,copy,task,job,entries,put,name,new,tuple4,integer,file,path,future,path,1,temp,dir,to,use,target,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception;1525420604;If the file doesn't exists locally, it will copy the file to the temp directory.__@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception {_		synchronized (lock) {_			Map<String, Future<Path>> jobEntries = entries.computeIfAbsent(jobID, k -> new HashMap<>())___			_			final Set<ExecutionAttemptID> refHolders = jobRefHolders.computeIfAbsent(jobID, id -> new HashSet<>())__			refHolders.add(executionId)___			Future<Path> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				return fileEntry__			} else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				Callable<Path> cp = new CopyFromBlobProcess(entry, jobID, blobService, target)__				FutureTask<Path> copyTask = new FutureTask<>(cp)__				executorService.submit(copyTask)___				_				jobEntries.put(name, copyTask)___				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,execution,attempt,id,execution,id,throws,exception,synchronized,lock,map,string,future,path,job,entries,entries,compute,if,absent,job,id,k,new,hash,map,final,set,execution,attempt,id,ref,holders,job,ref,holders,compute,if,absent,job,id,id,new,hash,set,ref,holders,add,execution,id,future,path,file,entry,job,entries,get,name,if,file,entry,null,return,file,entry,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,callable,path,cp,new,copy,from,blob,process,entry,job,id,blob,service,target,future,task,path,copy,task,new,future,task,cp,executor,service,submit,copy,task,job,entries,put,name,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception;1529065669;If the file doesn't exists locally, it will copy the file to the temp directory.__@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception {_		synchronized (lock) {_			Map<String, Future<Path>> jobEntries = entries.computeIfAbsent(jobID, k -> new HashMap<>())___			_			final Set<ExecutionAttemptID> refHolders = jobRefHolders.computeIfAbsent(jobID, id -> new HashSet<>())__			refHolders.add(executionId)___			Future<Path> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				return fileEntry__			} else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				String sourceFile = entry.filePath__				int posOfSep = sourceFile.lastIndexOf("/")__				if (posOfSep > 0) {_					sourceFile = sourceFile.substring(posOfSep + 1)__				}__				Path target = new Path(tempDirToUse.getAbsolutePath() + "/" + sourceFile)___				_				Callable<Path> cp__				if (entry.blobKey != null) {_					cp = new CopyFromBlobProcess(entry, jobID, blobService, target)__				} else {_					cp = new CopyFromDFSProcess(entry, target)__				}_				FutureTask<Path> copyTask = new FutureTask<>(cp)__				executorService.submit(copyTask)___				_				jobEntries.put(name, copyTask)___				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,it,will,copy,the,file,to,the,temp,directory,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,execution,attempt,id,execution,id,throws,exception,synchronized,lock,map,string,future,path,job,entries,entries,compute,if,absent,job,id,k,new,hash,map,final,set,execution,attempt,id,ref,holders,job,ref,holders,compute,if,absent,job,id,id,new,hash,set,ref,holders,add,execution,id,future,path,file,entry,job,entries,get,name,if,file,entry,null,return,file,entry,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,string,source,file,entry,file,path,int,pos,of,sep,source,file,last,index,of,if,pos,of,sep,0,source,file,source,file,substring,pos,of,sep,1,path,target,new,path,temp,dir,to,use,get,absolute,path,source,file,callable,path,cp,if,entry,blob,key,null,cp,new,copy,from,blob,process,entry,job,id,blob,service,target,else,cp,new,copy,from,dfsprocess,entry,target,future,task,path,copy,task,new,future,task,cp,executor,service,submit,copy,task,job,entries,put,name,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception;1529583969;If the file doesn't exists locally, retrieve the file from the blob-service.__@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception {_		synchronized (lock) {_			Map<String, Future<Path>> jobEntries = entries.computeIfAbsent(jobID, k -> new HashMap<>())___			_			final Set<ExecutionAttemptID> refHolders = jobRefHolders.computeIfAbsent(jobID, id -> new HashSet<>())__			refHolders.add(executionId)___			Future<Path> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				return fileEntry__			} else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				_				Callable<Path> cp__				if (entry.blobKey != null) {_					cp = new CopyFromBlobProcess(entry, jobID, blobService, new Path(tempDirToUse.getAbsolutePath()))__				} else {_					cp = new CopyFromDFSProcess(entry, new Path(tempDirToUse.getAbsolutePath()))__				}_				FutureTask<Path> copyTask = new FutureTask<>(cp)__				executorService.submit(copyTask)___				_				jobEntries.put(name, copyTask)___				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,retrieve,the,file,from,the,blob,service,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,execution,attempt,id,execution,id,throws,exception,synchronized,lock,map,string,future,path,job,entries,entries,compute,if,absent,job,id,k,new,hash,map,final,set,execution,attempt,id,ref,holders,job,ref,holders,compute,if,absent,job,id,id,new,hash,set,ref,holders,add,execution,id,future,path,file,entry,job,entries,get,name,if,file,entry,null,return,file,entry,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,callable,path,cp,if,entry,blob,key,null,cp,new,copy,from,blob,process,entry,job,id,blob,service,new,path,temp,dir,to,use,get,absolute,path,else,cp,new,copy,from,dfsprocess,entry,new,path,temp,dir,to,use,get,absolute,path,future,task,path,copy,task,new,future,task,cp,executor,service,submit,copy,task,job,entries,put,name,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception;1536223031;If the file doesn't exists locally, retrieve the file from the blob-service.__@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception {_		synchronized (lock) {_			Map<String, Future<Path>> jobEntries = entries.computeIfAbsent(jobID, k -> new HashMap<>())___			_			final Set<ExecutionAttemptID> refHolders = jobRefHolders.computeIfAbsent(jobID, id -> new HashSet<>())__			refHolders.add(executionId)___			Future<Path> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				return fileEntry__			} else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				_				Callable<Path> cp__				if (entry.blobKey != null) {_					cp = new CopyFromBlobProcess(entry, jobID, blobService, new Path(tempDirToUse.getAbsolutePath()))__				} else {_					cp = new CopyFromDFSProcess(entry, new Path(tempDirToUse.getAbsolutePath()))__				}_				FutureTask<Path> copyTask = new FutureTask<>(cp)__				executorService.submit(copyTask)___				_				jobEntries.put(name, copyTask)___				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,retrieve,the,file,from,the,blob,service,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,execution,attempt,id,execution,id,throws,exception,synchronized,lock,map,string,future,path,job,entries,entries,compute,if,absent,job,id,k,new,hash,map,final,set,execution,attempt,id,ref,holders,job,ref,holders,compute,if,absent,job,id,id,new,hash,set,ref,holders,add,execution,id,future,path,file,entry,job,entries,get,name,if,file,entry,null,return,file,entry,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,callable,path,cp,if,entry,blob,key,null,cp,new,copy,from,blob,process,entry,job,id,blob,service,new,path,temp,dir,to,use,get,absolute,path,else,cp,new,copy,from,dfsprocess,entry,new,path,temp,dir,to,use,get,absolute,path,future,task,path,copy,task,new,future,task,cp,executor,service,submit,copy,task,job,entries,put,name,copy,task,return,copy,task
FileCache -> public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception;1550138430;If the file doesn't exists locally, retrieve the file from the blob-service.__@param entry The cache entry descriptor (path, executable flag)_@param jobID The ID of the job for which the file is copied._@return The handle to the task that copies the file.;public Future<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID, ExecutionAttemptID executionId) throws Exception {_		synchronized (lock) {_			Map<String, Future<Path>> jobEntries = entries.computeIfAbsent(jobID, k -> new HashMap<>())___			_			final Set<ExecutionAttemptID> refHolders = jobRefHolders.computeIfAbsent(jobID, id -> new HashSet<>())__			refHolders.add(executionId)___			Future<Path> fileEntry = jobEntries.get(name)__			if (fileEntry != null) {_				_				_				return fileEntry__			} else {_				__				_				File tempDirToUse = new File(storageDirectories[nextDirectory++], jobID.toString())__				if (nextDirectory >= storageDirectories.length) {_					nextDirectory = 0__				}__				_				Callable<Path> cp__				if (entry.blobKey != null) {_					cp = new CopyFromBlobProcess(entry, jobID, blobService, new Path(tempDirToUse.getAbsolutePath()))__				} else {_					cp = new CopyFromDFSProcess(entry, new Path(tempDirToUse.getAbsolutePath()))__				}_				FutureTask<Path> copyTask = new FutureTask<>(cp)__				executorService.submit(copyTask)___				_				jobEntries.put(name, copyTask)___				return copyTask__			}_		}_	};if,the,file,doesn,t,exists,locally,retrieve,the,file,from,the,blob,service,param,entry,the,cache,entry,descriptor,path,executable,flag,param,job,id,the,id,of,the,job,for,which,the,file,is,copied,return,the,handle,to,the,task,that,copies,the,file;public,future,path,create,tmp,file,string,name,distributed,cache,entry,entry,job,id,job,id,execution,attempt,id,execution,id,throws,exception,synchronized,lock,map,string,future,path,job,entries,entries,compute,if,absent,job,id,k,new,hash,map,final,set,execution,attempt,id,ref,holders,job,ref,holders,compute,if,absent,job,id,id,new,hash,set,ref,holders,add,execution,id,future,path,file,entry,job,entries,get,name,if,file,entry,null,return,file,entry,else,file,temp,dir,to,use,new,file,storage,directories,next,directory,job,id,to,string,if,next,directory,storage,directories,length,next,directory,0,callable,path,cp,if,entry,blob,key,null,cp,new,copy,from,blob,process,entry,job,id,blob,service,new,path,temp,dir,to,use,get,absolute,path,else,cp,new,copy,from,dfsprocess,entry,new,path,temp,dir,to,use,get,absolute,path,future,task,path,copy,task,new,future,task,cp,executor,service,submit,copy,task,job,entries,put,name,copy,task,return,copy,task
