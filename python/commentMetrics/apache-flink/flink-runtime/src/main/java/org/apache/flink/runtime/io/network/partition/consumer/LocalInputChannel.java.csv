commented;modifiers;parameterAmount;loc;comment;code
false;;1;46;;// ------------------------------------------------------------------------ // Consume // ------------------------------------------------------------------------ @Override void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {     boolean retriggerRequest = false.     // The lock is required to request only once in the presence of retriggered requests.     synchronized (requestLock) {         checkState(!isReleased, "LocalInputChannel has been released already").         if (subpartitionView == null) {             LOG.debug("{}: Requesting LOCAL subpartition {} of partition {}.", this, subpartitionIndex, partitionId).             try {                 ResultSubpartitionView subpartitionView = partitionManager.createSubpartitionView(partitionId, subpartitionIndex, this).                 if (subpartitionView == null) {                     throw new IOException("Error requesting subpartition.").                 }                 // make the subpartition view visible                 this.subpartitionView = subpartitionView.                 // check if the channel was released in the meantime                 if (isReleased) {                     subpartitionView.releaseAllResources().                     this.subpartitionView = null.                 }             } catch (PartitionNotFoundException notFound) {                 if (increaseBackoff()) {                     retriggerRequest = true.                 } else {                     throw notFound.                 }             }         }     }     // input gate.     if (retriggerRequest) {         inputGate.retriggerPartitionRequest(partitionId.getPartitionId()).     } }
false;public;0;8;;@Override public void run() {     try {         requestSubpartition(subpartitionIndex).     } catch (Throwable t) {         setError(t).     } }
true;;2;16;/**  * Retriggers a subpartition request.  */ ;/**  * Retriggers a subpartition request.  */ void retriggerSubpartitionRequest(Timer timer, final int subpartitionIndex) {     synchronized (requestLock) {         checkState(subpartitionView == null, "already requested partition").         timer.schedule(new TimerTask() {              @Override             public void run() {                 try {                     requestSubpartition(subpartitionIndex).                 } catch (Throwable t) {                     setError(t).                 }             }         }, getCurrentBackoff()).     } }
false;;0;36;;@Override Optional<BufferAndAvailability> getNextBuffer() throws IOException, InterruptedException {     checkError().     ResultSubpartitionView subpartitionView = this.subpartitionView.     if (subpartitionView == null) {         // during) it was released during reading the EndOfPartitionEvent (2).         if (isReleased) {             return Optional.empty().         }         // this can happen if the request for the partition was triggered asynchronously         // by the time trigger         // would be good to avoid that, by guaranteeing that the requestPartition() and         // getNextBuffer() always come from the same thread         // we could do that by letting the timer insert a special "requesting channel" into the input gate's queue         subpartitionView = checkAndWaitForSubpartitionView().     }     BufferAndBacklog next = subpartitionView.getNextBuffer().     if (next == null) {         if (subpartitionView.isReleased()) {             throw new CancelTaskException("Consumed partition " + subpartitionView + " has been released.").         } else {             return Optional.empty().         }     }     numBytesIn.inc(next.buffer().getSizeUnsafe()).     numBuffersIn.inc().     return Optional.of(new BufferAndAvailability(next.buffer(), next.isMoreAvailable(), next.buffersInBacklog())). }
false;public;0;4;;@Override public void notifyDataAvailable() {     notifyChannelNonEmpty(). }
false;private;0;10;;private ResultSubpartitionView checkAndWaitForSubpartitionView() {     // by then the subpartition view is visible or the channel is released     synchronized (requestLock) {         checkState(!isReleased, "released").         checkState(subpartitionView != null, "Queried for a buffer before requesting the subpartition.").         return subpartitionView.     } }
false;;1;9;;// ------------------------------------------------------------------------ // Task events // ------------------------------------------------------------------------ @Override void sendTaskEvent(TaskEvent event) throws IOException {     checkError().     checkState(subpartitionView != null, "Tried to send task event to producer before requesting the subpartition.").     if (!taskEventDispatcher.publish(partitionId, event)) {         throw new IOException("Error while publishing event " + event + " to producer. The producer could not be found.").     } }
false;;0;4;;// ------------------------------------------------------------------------ // Life cycle // ------------------------------------------------------------------------ @Override boolean isReleased() {     return isReleased. }
false;;0;6;;@Override void notifySubpartitionConsumed() throws IOException {     if (subpartitionView != null) {         subpartitionView.notifySubpartitionConsumed().     } }
true;;0;12;/**  * Releases the partition reader.  */ ;/**  * Releases the partition reader.  */ @Override void releaseAllResources() throws IOException {     if (!isReleased) {         isReleased = true.         ResultSubpartitionView view = subpartitionView.         if (view != null) {             view.releaseAllResources().             subpartitionView = null.         }     } }
false;public;0;4;;@Override public String toString() {     return "LocalInputChannel [" + partitionId + "]". }
