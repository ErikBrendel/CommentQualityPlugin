commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public FSDataInputStream openInputStream() throws IOException {     return new ByteStateHandleInputStream(data). }
false;public;0;3;;public byte[] getData() {     return data. }
false;public;0;3;;public String getHandleName() {     return handleName. }
false;public;0;3;;@Override public void discardState() { }
false;public;0;4;;@Override public long getStateSize() {     return data.length. }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (!(o instanceof ByteStreamStateHandle)) {         return false.     }     ByteStreamStateHandle that = (ByteStreamStateHandle) o.     return handleName.equals(that.handleName). }
false;public;0;4;;@Override public int hashCode() {     return 31 * handleName.hashCode(). }
false;public;0;7;;@Override public String toString() {     return "ByteStreamStateHandle{" + "handleName='" + handleName + '\'' + ", dataBytes=" + data.length + '}'. }
false;public;1;8;;@Override public void seek(long desired) throws IOException {     if (desired >= 0 && desired <= data.length) {         index = (int) desired.     } else {         throw new IOException("position out of bounds").     } }
false;public;0;4;;@Override public long getPos() throws IOException {     return index. }
false;public;0;4;;@Override public int read() throws IOException {     return index < data.length ? data[index++] & 0xFF : -1. }
false;public;3;16;;@Override public int read(byte[] b, int off, int len) throws IOException {     // note that any bounds checking on "byte[] b" happend anyways by the     // System.arraycopy() call below, so we don't add extra checks here     final int bytesLeft = data.length - index.     if (bytesLeft > 0) {         final int bytesToCopy = Math.min(len, bytesLeft).         System.arraycopy(data, index, b, off, bytesToCopy).         index += bytesToCopy.         return bytesToCopy.     } else {         return -1.     } }
