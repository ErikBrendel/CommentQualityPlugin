commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public void close() throws IOException {     close(false). }
false;public;0;3;;public void closeAndDelete() throws IOException {     close(true). }
false;private;1;15;;private void close(boolean deleteFile) throws IOException {     try {         clear().         if (deleteFile) {             reader.closeAndDelete().         } else {             reader.close().         }     } finally {         synchronized (memory) {             memManager.release(memory).             memory.clear().         }     } }
false;protected;1;17;;@Override protected MemorySegment nextSegment(MemorySegment current) throws IOException {     // check for end-of-stream     if (numBlocksRemaining <= 0) {         reader.close().         throw new EOFException().     }     // send a request first. if we have only a single segment, this same segment will be the one obtained in the next lines     if (current != null) {         sendReadRequest(current).     }     // get the next segment     numBlocksRemaining--.     return reader.getNextReturnedBlock(). }
false;protected;1;4;;@Override protected int getLimitForSegment(MemorySegment segment) {     return numBlocksRemaining > 0 ? segment.size() : sizeOfLastBlock. }
false;private;1;8;;private void sendReadRequest(MemorySegment seg) throws IOException {     if (numRequestsRemaining > 0) {         reader.readBlock(seg).         numRequestsRemaining--.     } else {         memManager.release(seg).     } }
