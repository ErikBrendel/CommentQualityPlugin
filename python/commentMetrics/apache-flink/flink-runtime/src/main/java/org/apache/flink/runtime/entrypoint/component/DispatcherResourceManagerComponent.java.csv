commented;modifiers;parameterAmount;loc;comment;code
false;private;0;21;;private void registerShutDownFuture() {     terminationFuture.whenComplete((aVoid, throwable) -> {         if (throwable != null) {             shutDownFuture.completeExceptionally(throwable).         } else {             shutDownFuture.complete(ApplicationStatus.SUCCEEDED).         }     }).     dispatcher.getTerminationFuture().whenComplete((aVoid, throwable) -> {         if (throwable != null) {             shutDownFuture.completeExceptionally(throwable).         } else {             shutDownFuture.complete(ApplicationStatus.SUCCEEDED).         }     }). }
false;public,final;0;3;;public final CompletableFuture<ApplicationStatus> getShutDownFuture() {     return shutDownFuture. }
false;public;0;4;;@Nonnull public T getDispatcher() {     return dispatcher. }
false;public;0;4;;@Nonnull public WebMonitorEndpoint<?> getWebMonitorEndpoint() {     return webMonitorEndpoint. }
true;public;2;13;/**  * Deregister the Flink application from the resource management system by signalling  * the {@link ResourceManager}.  *  * @param applicationStatus to terminate the application with  * @param diagnostics additional information about the shut down, can be {@code null}  * @return Future which is completed once the shut down  */ ;/**  * Deregister the Flink application from the resource management system by signalling  * the {@link ResourceManager}.  *  * @param applicationStatus to terminate the application with  * @param diagnostics additional information about the shut down, can be {@code null}  * @return Future which is completed once the shut down  */ public CompletableFuture<Void> deregisterApplicationAndClose(final ApplicationStatus applicationStatus, @Nullable final String diagnostics) {     if (isRunning.compareAndSet(true, false)) {         final CompletableFuture<Void> closeWebMonitorAndDeregisterAppFuture = FutureUtils.composeAfterwards(webMonitorEndpoint.closeAsync(), () -> deregisterApplication(applicationStatus, diagnostics)).         return FutureUtils.composeAfterwards(closeWebMonitorAndDeregisterAppFuture, this::closeAsyncInternal).     } else {         return terminationFuture.     } }
false;private;2;7;;private CompletableFuture<Void> deregisterApplication(final ApplicationStatus applicationStatus, @Nullable final String diagnostics) {     final ResourceManagerGateway selfGateway = resourceManager.getSelfGateway(ResourceManagerGateway.class).     return selfGateway.deregisterApplication(applicationStatus, diagnostics).thenApply(ack -> null). }
false;private;0;41;;private CompletableFuture<Void> closeAsyncInternal() {     Exception exception = null.     final Collection<CompletableFuture<Void>> terminationFutures = new ArrayList<>(3).     try {         dispatcherLeaderRetrievalService.stop().     } catch (Exception e) {         exception = ExceptionUtils.firstOrSuppressed(e, exception).     }     try {         resourceManagerRetrievalService.stop().     } catch (Exception e) {         exception = ExceptionUtils.firstOrSuppressed(e, exception).     }     terminationFutures.add(dispatcher.closeAsync()).     terminationFutures.add(resourceManager.closeAsync()).     if (exception != null) {         terminationFutures.add(FutureUtils.completedExceptionally(exception)).     }     final CompletableFuture<Void> componentTerminationFuture = FutureUtils.completeAll(terminationFutures).     final CompletableFuture<Void> metricGroupTerminationFuture = FutureUtils.runAfterwards(componentTerminationFuture, jobManagerMetricGroup::close).     metricGroupTerminationFuture.whenComplete((aVoid, throwable) -> {         if (throwable != null) {             terminationFuture.completeExceptionally(throwable).         } else {             terminationFuture.complete(aVoid).         }     }).     return terminationFuture. }
false;public;0;4;;@Override public CompletableFuture<Void> closeAsync() {     return deregisterApplicationAndClose(ApplicationStatus.CANCELED, "DispatcherResourceManagerComponent has been closed."). }
