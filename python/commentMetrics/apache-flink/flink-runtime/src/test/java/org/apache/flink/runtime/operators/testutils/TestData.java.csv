commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;public Tuple2<Integer, String> next(Tuple2<Integer, String> reuse) {     this.key = nextKey().     if (this.valueMode != ValueMode.CONSTANT) {         this.value = randomString().     }     reuse.setFields(this.key, this.value).     return reuse. }
false;public;0;3;;public Tuple2<Integer, String> next() {     return next(new Tuple2<Integer, String>()). }
false;public;1;7;;public boolean next(org.apache.flink.types.Value[] target) {     this.key = nextKey().     // TODO change this to something proper     ((IntValue) target[0]).setValue(this.key).     ((IntValue) target[1]).setValue(random.nextInt()).     return true. }
false;private;0;11;;private int nextKey() {     if (keyMode == KeyMode.SORTED) {         return ++counter.     } else if (keyMode == KeyMode.SORTED_SPARSE) {         int max = (int) (1 / keyDensity).         counter += random.nextInt(max) + 1.         return counter.     } else {         return Math.abs(random.nextInt() % keyMax) + 1.     } }
false;public;0;4;;public void reset() {     this.random = new Random(seed).     this.counter = 0. }
false;private;0;15;;private String randomString() {     int length.     if (valueMode == ValueMode.FIX_LENGTH) {         length = valueLength.     } else {         length = valueLength - random.nextInt(valueLength / 3).     }     StringBuilder sb = new StringBuilder().     for (int i = 0. i < length. i++) {         sb.append(alpha[random.nextInt(alpha.length)]).     }     return sb.toString(). }
false;public;1;10;;@Override public Tuple2<Integer, String> next(Tuple2<Integer, String> target) {     if (counter < numberOfRecords) {         counter++.         return generator.next(target).     } else {         return null.     } }
false;public;0;10;;@Override public Tuple2<Integer, String> next() {     if (counter < numberOfRecords) {         counter++.         return generator.next().     } else {         return null.     } }
false;public;0;3;;public void reset() {     this.counter = 0. }
false;public;1;12;;@Override public Tuple2<Integer, String> next(Tuple2<Integer, String> reuse) {     if (pos < this.numPairs) {         this.value = this.valueValue + ' ' + pos.         reuse.setFields(this.key, this.value).         pos++.         return reuse.     } else {         return null.     } }
false;public;0;4;;@Override public Tuple2<Integer, String> next() {     return next(new Tuple2<Integer, String>()). }
false;public;0;3;;public void reset() {     this.pos = 0. }
false;public;1;11;;@Override public Tuple2<Integer, Integer> next(Tuple2<Integer, Integer> reuse) {     if (this.numLeft > 0) {         this.numLeft--.         reuse.setField(this.key, 0).         reuse.setField(this.value, 1).         return reuse.     } else {         return null.     } }
false;public;0;4;;@Override public Tuple2<Integer, Integer> next() {     return next(new Tuple2<>(0, 0)). }
false;public,static;0;3;;public static TupleTypeInfo<Tuple2<Integer, String>> getIntStringTupleTypeInfo() {     return typeInfoIntString. }
false;public,static;0;3;;public static TypeSerializerFactory<Tuple2<Integer, String>> getIntStringTupleSerializerFactory() {     return serializerFactoryIntString. }
false;public,static;0;3;;public static TypeSerializer<Tuple2<Integer, String>> getIntStringTupleSerializer() {     return serializerFactoryIntString.getSerializer(). }
false;public,static;0;3;;public static TypeComparator<Tuple2<Integer, String>> getIntStringTupleComparator() {     return getIntStringTupleTypeInfo().createComparator(new int[] { 0 }, new boolean[] { true }, 0, null). }
false;public,static;0;3;;public static MockTuple2Reader<Tuple2<Integer, String>> getIntStringTupleReader() {     return new MockTuple2Reader<Tuple2<Integer, String>>(). }
false;public,static;0;3;;public static TupleTypeInfo<Tuple2<Integer, Integer>> getIntIntTupleTypeInfo() {     return typeInfoIntInt. }
false;public,static;0;3;;public static TypeSerializerFactory<Tuple2<Integer, Integer>> getIntIntTupleSerializerFactory() {     return serializerFactoryIntInt. }
false;public,static;0;3;;public static TypeSerializer<Tuple2<Integer, Integer>> getIntIntTupleSerializer() {     return getIntIntTupleSerializerFactory().getSerializer(). }
false;public,static;0;3;;public static TypeComparator<Tuple2<Integer, Integer>> getIntIntTupleComparator() {     return getIntIntTupleTypeInfo().createComparator(new int[] { 0 }, new boolean[] { true }, 0, null). }
false;public,static;0;3;;public static MockTuple2Reader<Tuple2<Integer, Integer>> getIntIntTupleReader() {     return new MockTuple2Reader<>(). }
false;public;1;4;;@Override public void writeParametersToConfig(Configuration config) {     throw new UnsupportedOperationException("Not supported yet."). }
false;public;2;4;;@Override public void readParametersFromConfig(Configuration config, ClassLoader cl) throws ClassNotFoundException {     throw new UnsupportedOperationException("Not supported yet."). }
false;public;0;4;;@Override public TypeSerializer<T> getSerializer() {     return info.createSerializer(null). }
false;public;0;4;;@Override public Class<T> getDataType() {     return info.getTypeClass(). }
false;public;1;25;;@Override public T next(T reuse) {     Tuple2 r = null.     while (r == null) {         try {             r = queue.take().         } catch (InterruptedException iex) {             throw new RuntimeException("Reader was interrupted.").         }     }     if (r.equals(SENTINEL)) {         // put the sentinel back, to ensure that repeated calls do not block         try {             queue.put(r).         } catch (InterruptedException e) {             throw new RuntimeException("Reader was interrupted.").         }         return null.     } else {         reuse.setField(r.getField(0), 0).         reuse.setField(r.getField(1), 1).         return reuse.     } }
false;public;0;24;;@Override public T next() {     Tuple2 r = null.     while (r == null) {         try {             r = queue.take().         } catch (InterruptedException iex) {             throw new RuntimeException("Reader was interrupted.").         }     }     if (r.equals(SENTINEL)) {         // put the sentinel back, to ensure that repeated calls do not block         try {             queue.put(r).         } catch (InterruptedException e) {             throw new RuntimeException("Reader was interrupted.").         }         return null.     } else {         Tuple2 result = new Tuple2(r.f0, r.f1).         return (T) result.     } }
false;public;1;3;;public void emit(Tuple2 element) throws InterruptedException {     queue.put(new Tuple2(element.f0, element.f1)). }
false;public;0;7;;public void close() {     try {         queue.put(SENTINEL).     } catch (InterruptedException e) {         throw new RuntimeException(e).     } }
false;public;1;4;;@Override public int hash(IntPair object) {     return comparators[0].hash(object.getKey()). }
false;public;1;4;;@Override public void setReference(IntPair toCompare) {     this.reference = toCompare.getKey(). }
false;public;1;4;;@Override public boolean equalToReference(IntPair candidate) {     return candidate.getKey() == this.reference. }
false;public;1;5;;@Override public int compareToReference(TypeComparator<IntPair> referencedAccessors) {     final IntPairComparator comp = (IntPairComparator) referencedAccessors.     return comp.reference - this.reference. }
false;public;2;4;;@Override public int compare(IntPair first, IntPair second) {     return first.getKey() - second.getKey(). }
false;public;2;4;;@Override public int compareSerialized(DataInputView source1, DataInputView source2) throws IOException {     return source1.readInt() - source2.readInt(). }
false;public;0;4;;@Override public boolean supportsNormalizedKey() {     return true. }
false;public;0;4;;@Override public int getNormalizeKeyLen() {     return 4. }
false;public;1;4;;@Override public boolean isNormalizedKeyPrefixOnly(int keyBytes) {     return keyBytes < 4. }
false;public;4;19;;@Override public void putNormalizedKey(IntPair record, MemorySegment target, int offset, int len) {     // see IntValue for a documentation of the logic     final int value = record.getKey() - Integer.MIN_VALUE.     if (len == 4) {         target.putIntBigEndian(offset, value).     } else if (len <= 0) {     } else if (len < 4) {         for (int i = 0. len > 0. len--, i++) {             target.put(offset + i, (byte) ((value >>> ((3 - i) << 3)) & 0xff)).         }     } else {         target.putIntBigEndian(offset, value).         for (int i = 4. i < len. i++) {             target.put(offset + i, (byte) 0).         }     } }
false;public;0;4;;@Override public boolean invertNormalizedKey() {     return false. }
false;public;0;4;;@Override public IntPairComparator duplicate() {     return new IntPairComparator(). }
false;public;3;5;;@Override public int extractKeys(Object record, Object[] target, int index) {     target[index] = ((IntPair) record).getKey().     return 1. }
false;public;0;4;;@Override public TypeComparator[] getFlatComparators() {     return comparators. }
false;public;0;4;;@Override public boolean supportsSerializationWithKeyNormalization() {     return true. }
false;public;2;5;;@Override public void writeWithKeyNormalization(IntPair record, DataOutputView target) throws IOException {     target.writeInt(record.getKey() - Integer.MIN_VALUE).     target.writeInt(record.getValue()). }
false;public;2;6;;@Override public IntPair readWithKeyDenormalization(IntPair reuse, DataInputView source) throws IOException {     reuse.setKey(source.readInt() + Integer.MIN_VALUE).     reuse.setValue(source.readInt()).     return reuse. }
