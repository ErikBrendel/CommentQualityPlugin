# id;timestamp;commentText;codeText;commentWords;codeWords
BlobCacheCleanupTest -> public static int checkFilesExist( 		JobID jobId, Collection<BlobKey> keys, BlobService blobService, boolean doThrow) 		throws IOException;1503041372;Checks how many of the files given by blob keys are accessible.__@param jobId_ID of a job_@param keys_blob keys to check_@param blobService_BLOB store to use_@param doThrow_whether exceptions should be ignored (<tt>false</tt>), or thrown (<tt>true</tt>)__@return number of files we were able to retrieve via {@link BlobService#getFile};public static int checkFilesExist(_		JobID jobId, Collection<BlobKey> keys, BlobService blobService, boolean doThrow)_		throws IOException {__		int numFiles = 0___		for (BlobKey key : keys) {_			final File blobFile__			if (blobService instanceof BlobServer) {_				BlobServer server = (BlobServer) blobService__				blobFile = server.getStorageLocation(jobId, key)__			} else {_				BlobCache cache = (BlobCache) blobService__				blobFile = cache.getStorageLocation(jobId, key)__			}_			if (blobFile.exists()) {_				++numFiles__			} else if (doThrow) {_				throw new IOException("File " + blobFile + " does not exist.")__			}_		}__		return numFiles__	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,job,id,id,of,a,job,param,keys,blob,keys,to,check,param,blob,service,blob,store,to,use,param,do,throw,whether,exceptions,should,be,ignored,tt,false,tt,or,thrown,tt,true,tt,return,number,of,files,we,were,able,to,retrieve,via,link,blob,service,get,file;public,static,int,check,files,exist,job,id,job,id,collection,blob,key,keys,blob,service,blob,service,boolean,do,throw,throws,ioexception,int,num,files,0,for,blob,key,key,keys,final,file,blob,file,if,blob,service,instanceof,blob,server,blob,server,server,blob,server,blob,service,blob,file,server,get,storage,location,job,id,key,else,blob,cache,cache,blob,cache,blob,service,blob,file,cache,get,storage,location,job,id,key,if,blob,file,exists,num,files,else,if,do,throw,throw,new,ioexception,file,blob,file,does,not,exist,return,num,files
BlobCacheCleanupTest -> public static int checkFilesExist( 		JobID jobId, Collection<BlobKey> keys, BlobService blobService, boolean doThrow) 		throws IOException;1507212386;Checks how many of the files given by blob keys are accessible.__@param jobId_ID of a job_@param keys_blob keys to check_@param blobService_BLOB store to use_@param doThrow_whether exceptions should be ignored (<tt>false</tt>), or thrown (<tt>true</tt>)__@return number of files we were able to retrieve via {@link BlobService#getFile};public static int checkFilesExist(_		JobID jobId, Collection<BlobKey> keys, BlobService blobService, boolean doThrow)_		throws IOException {__		int numFiles = 0___		for (BlobKey key : keys) {_			final File blobFile__			if (blobService instanceof BlobServer) {_				BlobServer server = (BlobServer) blobService__				blobFile = server.getStorageLocation(jobId, key)__			} else {_				BlobCache cache = (BlobCache) blobService__				blobFile = cache.getStorageLocation(jobId, key)__			}_			if (blobFile.exists()) {_				++numFiles__			} else if (doThrow) {_				throw new IOException("File " + blobFile + " does not exist.")__			}_		}__		return numFiles__	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,job,id,id,of,a,job,param,keys,blob,keys,to,check,param,blob,service,blob,store,to,use,param,do,throw,whether,exceptions,should,be,ignored,tt,false,tt,or,thrown,tt,true,tt,return,number,of,files,we,were,able,to,retrieve,via,link,blob,service,get,file;public,static,int,check,files,exist,job,id,job,id,collection,blob,key,keys,blob,service,blob,service,boolean,do,throw,throws,ioexception,int,num,files,0,for,blob,key,key,keys,final,file,blob,file,if,blob,service,instanceof,blob,server,blob,server,server,blob,server,blob,service,blob,file,server,get,storage,location,job,id,key,else,blob,cache,cache,blob,cache,blob,service,blob,file,cache,get,storage,location,job,id,key,if,blob,file,exists,num,files,else,if,do,throw,throw,new,ioexception,file,blob,file,does,not,exist,return,num,files
BlobCacheCleanupTest -> static void verifyJobCleanup(PermanentBlobCache cache, JobID jobId, List<? extends BlobKey> keys) 		throws InterruptedException, IOException;1507212387;Checks that BLOBs for the given <tt>jobId</tt> are cleaned up eventually (after calling_{@link PermanentBlobCache#releaseJob(JobID)}, which is not done by this method!) (waits at_most 30s).__@param cache_BLOB server_@param jobId_job ID or <tt>null</tt> if job-unrelated_@param keys_keys identifying BLOBs which were previously registered for the <tt>jobId</tt>;static void verifyJobCleanup(PermanentBlobCache cache, JobID jobId, List<? extends BlobKey> keys)_		throws InterruptedException, IOException {_		_		_		{_			long deadline = System.currentTimeMillis() + 30_000L__			do {_				Thread.sleep(100)__			}_			while (checkFilesExist(jobId, keys, cache, false) != 0 &&_				System.currentTimeMillis() < deadline)__		}__		_		_		checkFileCountForJob(0, jobId, cache)__	};checks,that,blobs,for,the,given,tt,job,id,tt,are,cleaned,up,eventually,after,calling,link,permanent,blob,cache,release,job,job,id,which,is,not,done,by,this,method,waits,at,most,30s,param,cache,blob,server,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,keys,keys,identifying,blobs,which,were,previously,registered,for,the,tt,job,id,tt;static,void,verify,job,cleanup,permanent,blob,cache,cache,job,id,job,id,list,extends,blob,key,keys,throws,interrupted,exception,ioexception,long,deadline,system,current,time,millis,do,thread,sleep,100,while,check,files,exist,job,id,keys,cache,false,0,system,current,time,millis,deadline,check,file,count,for,job,0,job,id,cache
BlobCacheCleanupTest -> static void verifyJobCleanup(PermanentBlobCache cache, JobID jobId, List<? extends BlobKey> keys) 		throws InterruptedException, IOException;1508578816;Checks that BLOBs for the given <tt>jobId</tt> are cleaned up eventually (after calling_{@link PermanentBlobCache#releaseJob(JobID)}, which is not done by this method!) (waits at_most 30s).__@param cache_BLOB server_@param jobId_job ID or <tt>null</tt> if job-unrelated_@param keys_keys identifying BLOBs which were previously registered for the <tt>jobId</tt>;static void verifyJobCleanup(PermanentBlobCache cache, JobID jobId, List<? extends BlobKey> keys)_		throws InterruptedException, IOException {_		_		_		{_			long deadline = System.currentTimeMillis() + 30_000L__			do {_				Thread.sleep(100)__			}_			while (checkFilesExist(jobId, keys, cache, false) != 0 &&_				System.currentTimeMillis() < deadline)__		}__		_		_		checkFileCountForJob(0, jobId, cache)__	};checks,that,blobs,for,the,given,tt,job,id,tt,are,cleaned,up,eventually,after,calling,link,permanent,blob,cache,release,job,job,id,which,is,not,done,by,this,method,waits,at,most,30s,param,cache,blob,server,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,keys,keys,identifying,blobs,which,were,previously,registered,for,the,tt,job,id,tt;static,void,verify,job,cleanup,permanent,blob,cache,cache,job,id,job,id,list,extends,blob,key,keys,throws,interrupted,exception,ioexception,long,deadline,system,current,time,millis,do,thread,sleep,100,while,check,files,exist,job,id,keys,cache,false,0,system,current,time,millis,deadline,check,file,count,for,job,0,job,id,cache
BlobCacheCleanupTest -> static void verifyJobCleanup(PermanentBlobCache cache, JobID jobId, List<? extends BlobKey> keys) 		throws InterruptedException, IOException;1517915730;Checks that BLOBs for the given <tt>jobId</tt> are cleaned up eventually (after calling_{@link PermanentBlobCache#releaseJob(JobID)}, which is not done by this method!) (waits at_most 30s).__@param cache_BLOB server_@param jobId_job ID or <tt>null</tt> if job-unrelated_@param keys_keys identifying BLOBs which were previously registered for the <tt>jobId</tt>;static void verifyJobCleanup(PermanentBlobCache cache, JobID jobId, List<? extends BlobKey> keys)_		throws InterruptedException, IOException {_		_		_		{_			long deadline = System.currentTimeMillis() + 30_000L__			do {_				Thread.sleep(100)__			}_			while (checkFilesExist(jobId, keys, cache, false) != 0 &&_				System.currentTimeMillis() < deadline)__		}__		_		_		checkFileCountForJob(0, jobId, cache)__	};checks,that,blobs,for,the,given,tt,job,id,tt,are,cleaned,up,eventually,after,calling,link,permanent,blob,cache,release,job,job,id,which,is,not,done,by,this,method,waits,at,most,30s,param,cache,blob,server,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,keys,keys,identifying,blobs,which,were,previously,registered,for,the,tt,job,id,tt;static,void,verify,job,cleanup,permanent,blob,cache,cache,job,id,job,id,list,extends,blob,key,keys,throws,interrupted,exception,ioexception,long,deadline,system,current,time,millis,do,thread,sleep,100,while,check,files,exist,job,id,keys,cache,false,0,system,current,time,millis,deadline,check,file,count,for,job,0,job,id,cache
BlobCacheCleanupTest -> static void verifyJobCleanup(PermanentBlobCache cache, JobID jobId, List<? extends BlobKey> keys) 		throws InterruptedException, IOException;1526549506;Checks that BLOBs for the given <tt>jobId</tt> are cleaned up eventually (after calling_{@link PermanentBlobCache#releaseJob(JobID)}, which is not done by this method!) (waits at_most 30s).__@param cache_BLOB server_@param jobId_job ID or <tt>null</tt> if job-unrelated_@param keys_keys identifying BLOBs which were previously registered for the <tt>jobId</tt>;static void verifyJobCleanup(PermanentBlobCache cache, JobID jobId, List<? extends BlobKey> keys)_		throws InterruptedException, IOException {_		_		_		{_			long deadline = System.currentTimeMillis() + 30_000L__			do {_				Thread.sleep(100)__			}_			while (checkFilesExist(jobId, keys, cache, false) != 0 &&_				System.currentTimeMillis() < deadline)__		}__		_		_		checkFileCountForJob(0, jobId, cache)__	};checks,that,blobs,for,the,given,tt,job,id,tt,are,cleaned,up,eventually,after,calling,link,permanent,blob,cache,release,job,job,id,which,is,not,done,by,this,method,waits,at,most,30s,param,cache,blob,server,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,keys,keys,identifying,blobs,which,were,previously,registered,for,the,tt,job,id,tt;static,void,verify,job,cleanup,permanent,blob,cache,cache,job,id,job,id,list,extends,blob,key,keys,throws,interrupted,exception,ioexception,long,deadline,system,current,time,millis,do,thread,sleep,100,while,check,files,exist,job,id,keys,cache,false,0,system,current,time,millis,deadline,check,file,count,for,job,0,job,id,cache
BlobCacheCleanupTest -> @Test 	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ") 	public void testJobDeferredCleanup() throws IOException, InterruptedException;1503041372;Tests that {@link BlobCache} cleans up after calling {@link BlobCache#releaseJob(JobID)}_but only after preserving the file for a bit longer.;@Test_	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ")_	public void testJobDeferredCleanup() throws IOException, InterruptedException {_		_		long cleanupInterval = 5L___		JobID jobId = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, cleanupInterval)___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())___			_			try (BlobClient bc = new BlobClient(serverAddress, config)) {_				keys.add(bc.put(jobId, buf))__				buf[0] += 1__				keys.add(bc.put(jobId, buf))__			}__			cache = new BlobCache(serverAddress, config, new VoidBlobStore())___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (BlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (BlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep(cleanupInterval / 5)__			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep((cleanupInterval * 4) / 5)___			_			_			_			{_				long deadline = System.currentTimeMillis() + 30_000L__				do {_					Thread.sleep(100)__				}_				while (checkFilesExist(jobId, keys, cache, false) != 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			_			checkFileCountForJob(0, jobId, cache)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,blob,cache,cleans,up,after,calling,link,blob,cache,release,job,job,id,but,only,after,preserving,the,file,for,a,bit,longer;test,ignore,manual,test,due,to,stalling,ensures,a,blob,is,retained,first,and,only,deleted,after,the,long,timeout,public,void,test,job,deferred,cleanup,throws,ioexception,interrupted,exception,long,cleanup,interval,5l,job,id,job,id,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,cleanup,interval,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,try,blob,client,bc,new,blob,client,server,address,config,keys,add,bc,put,job,id,buf,buf,0,1,keys,add,bc,put,job,id,buf,cache,new,blob,cache,server,address,config,new,void,blob,store,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,5,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,4,5,long,deadline,system,current,time,millis,do,thread,sleep,100,while,check,files,exist,job,id,keys,cache,false,0,system,current,time,millis,deadline,check,file,count,for,job,0,job,id,cache,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ") 	public void testJobDeferredCleanup() throws IOException, InterruptedException;1507212386;Tests that {@link BlobCache} cleans up after calling {@link BlobCache#releaseJob(JobID)}_but only after preserving the file for a bit longer.;@Test_	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ")_	public void testJobDeferredCleanup() throws IOException, InterruptedException {_		_		long cleanupInterval = 5L___		JobID jobId = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, cleanupInterval)___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())___			_			try (BlobClient bc = new BlobClient(serverAddress, config)) {_				keys.add(bc.put(jobId, buf))__				buf[0] += 1__				keys.add(bc.put(jobId, buf))__			}__			cache = new BlobCache(serverAddress, config, new VoidBlobStore())___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (BlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (BlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep(cleanupInterval / 5)__			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep((cleanupInterval * 4) / 5)___			_			_			_			{_				long deadline = System.currentTimeMillis() + 30_000L__				do {_					Thread.sleep(100)__				}_				while (checkFilesExist(jobId, keys, cache, false) != 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			_			checkFileCountForJob(0, jobId, cache)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,blob,cache,cleans,up,after,calling,link,blob,cache,release,job,job,id,but,only,after,preserving,the,file,for,a,bit,longer;test,ignore,manual,test,due,to,stalling,ensures,a,blob,is,retained,first,and,only,deleted,after,the,long,timeout,public,void,test,job,deferred,cleanup,throws,ioexception,interrupted,exception,long,cleanup,interval,5l,job,id,job,id,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,cleanup,interval,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,try,blob,client,bc,new,blob,client,server,address,config,keys,add,bc,put,job,id,buf,buf,0,1,keys,add,bc,put,job,id,buf,cache,new,blob,cache,server,address,config,new,void,blob,store,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,5,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,4,5,long,deadline,system,current,time,millis,do,thread,sleep,100,while,check,files,exist,job,id,keys,cache,false,0,system,current,time,millis,deadline,check,file,count,for,job,0,job,id,cache,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ") 	public void testJobDeferredCleanup() throws IOException, InterruptedException;1507212387;Tests that {@link PermanentBlobCache} cleans up after calling {@link PermanentBlobCache#releaseJob(JobID)}_but only after preserving the file for a bit longer.;@Test_	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ")_	public void testJobDeferredCleanup() throws IOException, InterruptedException {_		_		long cleanupInterval = 5L___		JobID jobId = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		PermanentBlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, cleanupInterval)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			_			keys.add(server.putHA(jobId, buf))__			buf[0] += 1__			keys.add(server.putHA(jobId, buf))___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (BlobKey key : keys) {_				cache.getHAFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (BlobKey key : keys) {_				cache.getHAFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep(cleanupInterval / 5)__			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep((cleanupInterval * 4) / 5)___			_			_			_			{_				long deadline = System.currentTimeMillis() + 30_000L__				do {_					Thread.sleep(100)__				}_				while (checkFilesExist(jobId, keys, cache, false) != 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			_			checkFileCountForJob(0, jobId, cache)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,permanent,blob,cache,cleans,up,after,calling,link,permanent,blob,cache,release,job,job,id,but,only,after,preserving,the,file,for,a,bit,longer;test,ignore,manual,test,due,to,stalling,ensures,a,blob,is,retained,first,and,only,deleted,after,the,long,timeout,public,void,test,job,deferred,cleanup,throws,ioexception,interrupted,exception,long,cleanup,interval,5l,job,id,job,id,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,permanent,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,cleanup,interval,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,ha,job,id,buf,buf,0,1,keys,add,server,put,ha,job,id,buf,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,blob,key,key,keys,cache,get,hafile,job,id,key,cache,register,job,job,id,for,blob,key,key,keys,cache,get,hafile,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,5,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,4,5,long,deadline,system,current,time,millis,do,thread,sleep,100,while,check,files,exist,job,id,keys,cache,false,0,system,current,time,millis,deadline,check,file,count,for,job,0,job,id,cache,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ") 	public void testJobDeferredCleanup() throws IOException, InterruptedException;1507212387;Tests that {@link PermanentBlobCache} cleans up after calling {@link PermanentBlobCache#releaseJob(JobID)}_but only after preserving the file for a bit longer.;@Test_	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ")_	public void testJobDeferredCleanup() throws IOException, InterruptedException {_		_		long cleanupInterval = 5L___		JobID jobId = new JobID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, cleanupInterval)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			_			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep(cleanupInterval / 5)__			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep((cleanupInterval * 4) / 5)___			_			verifyJobCleanup(cache, jobId, keys)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,permanent,blob,cache,cleans,up,after,calling,link,permanent,blob,cache,release,job,job,id,but,only,after,preserving,the,file,for,a,bit,longer;test,ignore,manual,test,due,to,stalling,ensures,a,blob,is,retained,first,and,only,deleted,after,the,long,timeout,public,void,test,job,deferred,cleanup,throws,ioexception,interrupted,exception,long,cleanup,interval,5l,job,id,job,id,new,job,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,cleanup,interval,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,5,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,4,5,verify,job,cleanup,cache,job,id,keys,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	public void testJobReferences() throws IOException, InterruptedException;1507212386;Tests that {@link BlobCache} sets the expected reference counts and cleanup timeouts when_registering, releasing, and re-registering jobs.;@Test_	public void testJobReferences() throws IOException, InterruptedException {__		JobID jobId = new JobID()___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600_000L)_ __		_		InetSocketAddress serverAddress = new InetSocketAddress("localhost", 12345)___		try (BlobCache cache = new BlobCache(serverAddress, config, new VoidBlobStore())) {__			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.registerJob(jobId)__			assertEquals(2, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.releaseJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			long cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))___			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))__		}_	};tests,that,link,blob,cache,sets,the,expected,reference,counts,and,cleanup,timeouts,when,registering,releasing,and,re,registering,jobs;test,public,void,test,job,references,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,inet,socket,address,server,address,new,inet,socket,address,localhost,12345,try,blob,cache,cache,new,blob,cache,server,address,config,new,void,blob,store,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,register,job,job,id,assert,equals,2,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,release,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,long,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound
BlobCacheCleanupTest -> @Test 	public void testJobReferences() throws IOException, InterruptedException;1507212387;Tests that {@link BlobCache} sets the expected reference counts and cleanup timeouts when_registering, releasing, and re-registering jobs.;@Test_	public void testJobReferences() throws IOException, InterruptedException {__		JobID jobId = new JobID()___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600_000L)_ __		_		InetSocketAddress serverAddress = new InetSocketAddress("localhost", 12345)___		try (PermanentBlobCache cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())) {__			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.registerJob(jobId)__			assertEquals(2, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.releaseJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			long cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))___			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))__		}_	};tests,that,link,blob,cache,sets,the,expected,reference,counts,and,cleanup,timeouts,when,registering,releasing,and,re,registering,jobs;test,public,void,test,job,references,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,inet,socket,address,server,address,new,inet,socket,address,localhost,12345,try,permanent,blob,cache,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,register,job,job,id,assert,equals,2,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,release,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,long,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound
BlobCacheCleanupTest -> @Test 	public void testJobReferences() throws IOException, InterruptedException;1507212387;Tests that {@link PermanentBlobCache} sets the expected reference counts and cleanup timeouts_when registering, releasing, and re-registering jobs.;@Test_	public void testJobReferences() throws IOException, InterruptedException {__		JobID jobId = new JobID()___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600_000L)_ __		_		InetSocketAddress serverAddress = new InetSocketAddress("localhost", 12345)___		try (PermanentBlobCache cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())) {__			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.registerJob(jobId)__			assertEquals(2, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.releaseJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			long cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))___			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))__		}_	};tests,that,link,permanent,blob,cache,sets,the,expected,reference,counts,and,cleanup,timeouts,when,registering,releasing,and,re,registering,jobs;test,public,void,test,job,references,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,inet,socket,address,server,address,new,inet,socket,address,localhost,12345,try,permanent,blob,cache,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,register,job,job,id,assert,equals,2,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,release,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,long,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound
BlobCacheCleanupTest -> private void testTransientBlobCleanup(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1508578816;Tests that {@link TransientBlobCache} cleans up after a default TTL and keeps files which are_constantly accessed.;private void testTransientBlobCleanup(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		_		long cleanupInterval = 1L_ _		final int numberConcurrentGetOperations = 3___		final List<CompletableFuture<Void>> getOperations = new ArrayList<>(numberConcurrentGetOperations)___		byte[] data = new byte[2000000]__		rnd.nextBytes(data)__		byte[] data2 = Arrays.copyOfRange(data, 10, 54)___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, cleanupInterval)___		long cleanupLowerBound___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			final BlobCacheService cache = new BlobCacheService(_				new InetSocketAddress("localhost", server.getPort()), config,_				new VoidBlobStore())) {_			ConcurrentMap<Tuple2<JobID, TransientBlobKey>, Long> transientBlobExpiryTimes =_				cache.getTransientBlobService().getBlobExpiryTimes()___			server.start()___			final TransientBlobKey key1 =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			final TransientBlobKey key2 =_				(TransientBlobKey) put(server, jobId, data2, TRANSIENT_BLOB)___			_			cleanupLowerBound = System.currentTimeMillis() + cleanupInterval__			verifyContents(cache, jobId, key1, data)__			final Long key1ExpiryFirstAccess = transientBlobExpiryTimes.get(Tuple2.of(jobId, key1))__			assertThat(key1ExpiryFirstAccess, greaterThanOrEqualTo(cleanupLowerBound))__			assertNull(transientBlobExpiryTimes.get(Tuple2.of(jobId, key2)))___			_			Thread.sleep(1)__			cleanupLowerBound = System.currentTimeMillis() + cleanupInterval__			verifyContents(cache, jobId, key2, data2)__			assertEquals(key1ExpiryFirstAccess, transientBlobExpiryTimes.get(Tuple2.of(jobId, key1)))__			assertThat(transientBlobExpiryTimes.get(Tuple2.of(jobId, key2)),_				greaterThanOrEqualTo(cleanupLowerBound))___			_			if (jobId != null) {_				server.cleanupJob(jobId)__			} else {_				server.deleteFromCache(key1)__				server.deleteFromCache(key2)__			}_			checkFileCountForJob(0, jobId, server)___			_			_			_			final long finishTime = System.currentTimeMillis() + 3 * cleanupInterval___			final ExecutorService executor = Executors.newFixedThreadPool(numberConcurrentGetOperations)__			for (int i = 0_ i < numberConcurrentGetOperations_ i++) {_				CompletableFuture<Void> getOperation = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								_								while (System.currentTimeMillis() < finishTime) {_									get(cache, jobId, key1)__								}__								return null__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not retrieve blob.", e))__							}_					}, executor)___				getOperations.add(getOperation)__			}__			FutureUtils.ConjunctFuture<Collection<Void>> filesFuture = FutureUtils.combineAll(getOperations)__			filesFuture.get()___			verifyDeletedEventually(server, jobId, key1, key2)__		}_	};tests,that,link,transient,blob,cache,cleans,up,after,a,default,ttl,and,keeps,files,which,are,constantly,accessed;private,void,test,transient,blob,cleanup,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,long,cleanup,interval,1l,final,int,number,concurrent,get,operations,3,final,list,completable,future,void,get,operations,new,array,list,number,concurrent,get,operations,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,range,data,10,54,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,cleanup,interval,long,cleanup,lower,bound,try,blob,server,server,new,blob,server,config,new,void,blob,store,final,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,concurrent,map,tuple2,job,id,transient,blob,key,long,transient,blob,expiry,times,cache,get,transient,blob,service,get,blob,expiry,times,server,start,final,transient,blob,key,key1,transient,blob,key,put,server,job,id,data,final,transient,blob,key,key2,transient,blob,key,put,server,job,id,data2,cleanup,lower,bound,system,current,time,millis,cleanup,interval,verify,contents,cache,job,id,key1,data,final,long,key1expiry,first,access,transient,blob,expiry,times,get,tuple2,of,job,id,key1,assert,that,key1expiry,first,access,greater,than,or,equal,to,cleanup,lower,bound,assert,null,transient,blob,expiry,times,get,tuple2,of,job,id,key2,thread,sleep,1,cleanup,lower,bound,system,current,time,millis,cleanup,interval,verify,contents,cache,job,id,key2,data2,assert,equals,key1expiry,first,access,transient,blob,expiry,times,get,tuple2,of,job,id,key1,assert,that,transient,blob,expiry,times,get,tuple2,of,job,id,key2,greater,than,or,equal,to,cleanup,lower,bound,if,job,id,null,server,cleanup,job,job,id,else,server,delete,from,cache,key1,server,delete,from,cache,key2,check,file,count,for,job,0,job,id,server,final,long,finish,time,system,current,time,millis,3,cleanup,interval,final,executor,service,executor,executors,new,fixed,thread,pool,number,concurrent,get,operations,for,int,i,0,i,number,concurrent,get,operations,i,completable,future,void,get,operation,completable,future,supply,async,try,while,system,current,time,millis,finish,time,get,cache,job,id,key1,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,retrieve,blob,e,executor,get,operations,add,get,operation,future,utils,conjunct,future,collection,void,files,future,future,utils,combine,all,get,operations,files,future,get,verify,deleted,eventually,server,job,id,key1,key2
BlobCacheCleanupTest -> private void testTransientBlobCleanup(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1517915730;Tests that {@link TransientBlobCache} cleans up after a default TTL and keeps files which are_constantly accessed.;private void testTransientBlobCleanup(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		_		long cleanupInterval = 1L_ _		final int numberConcurrentGetOperations = 3___		final List<CompletableFuture<Void>> getOperations = new ArrayList<>(numberConcurrentGetOperations)___		byte[] data = new byte[2000000]__		rnd.nextBytes(data)__		byte[] data2 = Arrays.copyOfRange(data, 10, 54)___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, cleanupInterval)___		long cleanupLowerBound___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			final BlobCacheService cache = new BlobCacheService(_				config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {_			ConcurrentMap<Tuple2<JobID, TransientBlobKey>, Long> transientBlobExpiryTimes =_				cache.getTransientBlobService().getBlobExpiryTimes()___			server.start()___			final TransientBlobKey key1 =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			final TransientBlobKey key2 =_				(TransientBlobKey) put(server, jobId, data2, TRANSIENT_BLOB)___			_			cleanupLowerBound = System.currentTimeMillis() + cleanupInterval__			verifyContents(cache, jobId, key1, data)__			final Long key1ExpiryFirstAccess = transientBlobExpiryTimes.get(Tuple2.of(jobId, key1))__			assertThat(key1ExpiryFirstAccess, greaterThanOrEqualTo(cleanupLowerBound))__			assertNull(transientBlobExpiryTimes.get(Tuple2.of(jobId, key2)))___			_			Thread.sleep(1)__			cleanupLowerBound = System.currentTimeMillis() + cleanupInterval__			verifyContents(cache, jobId, key2, data2)__			assertEquals(key1ExpiryFirstAccess, transientBlobExpiryTimes.get(Tuple2.of(jobId, key1)))__			assertThat(transientBlobExpiryTimes.get(Tuple2.of(jobId, key2)),_				greaterThanOrEqualTo(cleanupLowerBound))___			_			if (jobId != null) {_				server.cleanupJob(jobId)__			} else {_				server.deleteFromCache(key1)__				server.deleteFromCache(key2)__			}_			checkFileCountForJob(0, jobId, server)___			_			_			_			final long finishTime = System.currentTimeMillis() + 3 * cleanupInterval___			final ExecutorService executor = Executors.newFixedThreadPool(numberConcurrentGetOperations)__			for (int i = 0_ i < numberConcurrentGetOperations_ i++) {_				CompletableFuture<Void> getOperation = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								_								while (System.currentTimeMillis() < finishTime) {_									get(cache, jobId, key1)__								}__								return null__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not retrieve blob.", e))__							}_					}, executor)___				getOperations.add(getOperation)__			}__			FutureUtils.ConjunctFuture<Collection<Void>> filesFuture = FutureUtils.combineAll(getOperations)__			filesFuture.get()___			verifyDeletedEventually(server, jobId, key1, key2)__		}_	};tests,that,link,transient,blob,cache,cleans,up,after,a,default,ttl,and,keeps,files,which,are,constantly,accessed;private,void,test,transient,blob,cleanup,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,long,cleanup,interval,1l,final,int,number,concurrent,get,operations,3,final,list,completable,future,void,get,operations,new,array,list,number,concurrent,get,operations,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,range,data,10,54,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,cleanup,interval,long,cleanup,lower,bound,try,blob,server,server,new,blob,server,config,new,void,blob,store,final,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,concurrent,map,tuple2,job,id,transient,blob,key,long,transient,blob,expiry,times,cache,get,transient,blob,service,get,blob,expiry,times,server,start,final,transient,blob,key,key1,transient,blob,key,put,server,job,id,data,final,transient,blob,key,key2,transient,blob,key,put,server,job,id,data2,cleanup,lower,bound,system,current,time,millis,cleanup,interval,verify,contents,cache,job,id,key1,data,final,long,key1expiry,first,access,transient,blob,expiry,times,get,tuple2,of,job,id,key1,assert,that,key1expiry,first,access,greater,than,or,equal,to,cleanup,lower,bound,assert,null,transient,blob,expiry,times,get,tuple2,of,job,id,key2,thread,sleep,1,cleanup,lower,bound,system,current,time,millis,cleanup,interval,verify,contents,cache,job,id,key2,data2,assert,equals,key1expiry,first,access,transient,blob,expiry,times,get,tuple2,of,job,id,key1,assert,that,transient,blob,expiry,times,get,tuple2,of,job,id,key2,greater,than,or,equal,to,cleanup,lower,bound,if,job,id,null,server,cleanup,job,job,id,else,server,delete,from,cache,key1,server,delete,from,cache,key2,check,file,count,for,job,0,job,id,server,final,long,finish,time,system,current,time,millis,3,cleanup,interval,final,executor,service,executor,executors,new,fixed,thread,pool,number,concurrent,get,operations,for,int,i,0,i,number,concurrent,get,operations,i,completable,future,void,get,operation,completable,future,supply,async,try,while,system,current,time,millis,finish,time,get,cache,job,id,key1,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,retrieve,blob,e,executor,get,operations,add,get,operation,future,utils,conjunct,future,collection,void,files,future,future,utils,combine,all,get,operations,files,future,get,verify,deleted,eventually,server,job,id,key1,key2
BlobCacheCleanupTest -> private void testTransientBlobCleanup(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1526549506;Tests that {@link TransientBlobCache} cleans up after a default TTL and keeps files which are_constantly accessed.;private void testTransientBlobCleanup(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		_		long cleanupInterval = 1L_ _		final int numberConcurrentGetOperations = 3___		final List<CompletableFuture<Void>> getOperations = new ArrayList<>(numberConcurrentGetOperations)___		byte[] data = new byte[2000000]__		rnd.nextBytes(data)__		byte[] data2 = Arrays.copyOfRange(data, 10, 54)___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, cleanupInterval)___		long cleanupLowerBound___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			final BlobCacheService cache = new BlobCacheService(_				config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {_			ConcurrentMap<Tuple2<JobID, TransientBlobKey>, Long> transientBlobExpiryTimes =_				cache.getTransientBlobService().getBlobExpiryTimes()___			server.start()___			final TransientBlobKey key1 =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			final TransientBlobKey key2 =_				(TransientBlobKey) put(server, jobId, data2, TRANSIENT_BLOB)___			_			cleanupLowerBound = System.currentTimeMillis() + cleanupInterval__			verifyContents(cache, jobId, key1, data)__			final Long key1ExpiryFirstAccess = transientBlobExpiryTimes.get(Tuple2.of(jobId, key1))__			assertThat(key1ExpiryFirstAccess, greaterThanOrEqualTo(cleanupLowerBound))__			assertNull(transientBlobExpiryTimes.get(Tuple2.of(jobId, key2)))___			_			Thread.sleep(1)__			cleanupLowerBound = System.currentTimeMillis() + cleanupInterval__			verifyContents(cache, jobId, key2, data2)__			assertEquals(key1ExpiryFirstAccess, transientBlobExpiryTimes.get(Tuple2.of(jobId, key1)))__			assertThat(transientBlobExpiryTimes.get(Tuple2.of(jobId, key2)),_				greaterThanOrEqualTo(cleanupLowerBound))___			_			if (jobId != null) {_				server.cleanupJob(jobId, true)__			} else {_				server.deleteFromCache(key1)__				server.deleteFromCache(key2)__			}_			checkFileCountForJob(0, jobId, server)___			_			_			_			final long finishTime = System.currentTimeMillis() + 3 * cleanupInterval___			final ExecutorService executor = Executors.newFixedThreadPool(numberConcurrentGetOperations)__			for (int i = 0_ i < numberConcurrentGetOperations_ i++) {_				CompletableFuture<Void> getOperation = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								_								while (System.currentTimeMillis() < finishTime) {_									get(cache, jobId, key1)__								}__								return null__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not retrieve blob.", e))__							}_					}, executor)___				getOperations.add(getOperation)__			}__			FutureUtils.ConjunctFuture<Collection<Void>> filesFuture = FutureUtils.combineAll(getOperations)__			filesFuture.get()___			verifyDeletedEventually(server, jobId, key1, key2)__		}_	};tests,that,link,transient,blob,cache,cleans,up,after,a,default,ttl,and,keeps,files,which,are,constantly,accessed;private,void,test,transient,blob,cleanup,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,long,cleanup,interval,1l,final,int,number,concurrent,get,operations,3,final,list,completable,future,void,get,operations,new,array,list,number,concurrent,get,operations,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,range,data,10,54,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,cleanup,interval,long,cleanup,lower,bound,try,blob,server,server,new,blob,server,config,new,void,blob,store,final,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,concurrent,map,tuple2,job,id,transient,blob,key,long,transient,blob,expiry,times,cache,get,transient,blob,service,get,blob,expiry,times,server,start,final,transient,blob,key,key1,transient,blob,key,put,server,job,id,data,final,transient,blob,key,key2,transient,blob,key,put,server,job,id,data2,cleanup,lower,bound,system,current,time,millis,cleanup,interval,verify,contents,cache,job,id,key1,data,final,long,key1expiry,first,access,transient,blob,expiry,times,get,tuple2,of,job,id,key1,assert,that,key1expiry,first,access,greater,than,or,equal,to,cleanup,lower,bound,assert,null,transient,blob,expiry,times,get,tuple2,of,job,id,key2,thread,sleep,1,cleanup,lower,bound,system,current,time,millis,cleanup,interval,verify,contents,cache,job,id,key2,data2,assert,equals,key1expiry,first,access,transient,blob,expiry,times,get,tuple2,of,job,id,key1,assert,that,transient,blob,expiry,times,get,tuple2,of,job,id,key2,greater,than,or,equal,to,cleanup,lower,bound,if,job,id,null,server,cleanup,job,job,id,true,else,server,delete,from,cache,key1,server,delete,from,cache,key2,check,file,count,for,job,0,job,id,server,final,long,finish,time,system,current,time,millis,3,cleanup,interval,final,executor,service,executor,executors,new,fixed,thread,pool,number,concurrent,get,operations,for,int,i,0,i,number,concurrent,get,operations,i,completable,future,void,get,operation,completable,future,supply,async,try,while,system,current,time,millis,finish,time,get,cache,job,id,key1,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,retrieve,blob,e,executor,get,operations,add,get,operation,future,utils,conjunct,future,collection,void,files,future,future,utils,combine,all,get,operations,files,future,get,verify,deleted,eventually,server,job,id,key1,key2
BlobCacheCleanupTest -> public static void checkFileCountForJob( 		int expectedCount, JobID jobId, BlobService blobService) 		throws IOException;1503041372;Checks how many of the files given by blob keys are accessible.__@param expectedCount_number of expected files in the blob service for the given job_@param jobId_ID of a job_@param blobService_BLOB store to use__@return number of files we were able to retrieve via {@link BlobService#getFile};public static void checkFileCountForJob(_		int expectedCount, JobID jobId, BlobService blobService)_		throws IOException {__		final File jobDir__		if (blobService instanceof BlobServer) {_			BlobServer server = (BlobServer) blobService__			jobDir = server.getStorageLocation(jobId, new BlobKey()).getParentFile()__		} else {_			BlobCache cache = (BlobCache) blobService__			jobDir = cache.getStorageLocation(jobId, new BlobKey()).getParentFile()__		}_		File[] blobsForJob = jobDir.listFiles()__		if (blobsForJob == null) {_			if (expectedCount != 0) {_				throw new IOException("File " + jobDir + " does not exist.")__			}_		} else {_			assertEquals("Too many/few files in job dir: " +_					Arrays.asList(blobsForJob).toString(), expectedCount,_				blobsForJob.length)__		}_	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,expected,count,number,of,expected,files,in,the,blob,service,for,the,given,job,param,job,id,id,of,a,job,param,blob,service,blob,store,to,use,return,number,of,files,we,were,able,to,retrieve,via,link,blob,service,get,file;public,static,void,check,file,count,for,job,int,expected,count,job,id,job,id,blob,service,blob,service,throws,ioexception,final,file,job,dir,if,blob,service,instanceof,blob,server,blob,server,server,blob,server,blob,service,job,dir,server,get,storage,location,job,id,new,blob,key,get,parent,file,else,blob,cache,cache,blob,cache,blob,service,job,dir,cache,get,storage,location,job,id,new,blob,key,get,parent,file,file,blobs,for,job,job,dir,list,files,if,blobs,for,job,null,if,expected,count,0,throw,new,ioexception,file,job,dir,does,not,exist,else,assert,equals,too,many,few,files,in,job,dir,arrays,as,list,blobs,for,job,to,string,expected,count,blobs,for,job,length
BlobCacheCleanupTest -> public static void checkFileCountForJob( 		int expectedCount, JobID jobId, BlobService blobService) 		throws IOException;1507212386;Checks how many of the files given by blob keys are accessible.__@param expectedCount_number of expected files in the blob service for the given job_@param jobId_ID of a job_@param blobService_BLOB store to use__@return number of files we were able to retrieve via {@link BlobService#getFile};public static void checkFileCountForJob(_		int expectedCount, JobID jobId, BlobService blobService)_		throws IOException {__		final File jobDir__		if (blobService instanceof BlobServer) {_			BlobServer server = (BlobServer) blobService__			jobDir = server.getStorageLocation(jobId, new BlobKey()).getParentFile()__		} else {_			BlobCache cache = (BlobCache) blobService__			jobDir = cache.getStorageLocation(jobId, new BlobKey()).getParentFile()__		}_		File[] blobsForJob = jobDir.listFiles()__		if (blobsForJob == null) {_			if (expectedCount != 0) {_				throw new IOException("File " + jobDir + " does not exist.")__			}_		} else {_			assertEquals("Too many/few files in job dir: " +_					Arrays.asList(blobsForJob).toString(), expectedCount,_				blobsForJob.length)__		}_	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,expected,count,number,of,expected,files,in,the,blob,service,for,the,given,job,param,job,id,id,of,a,job,param,blob,service,blob,store,to,use,return,number,of,files,we,were,able,to,retrieve,via,link,blob,service,get,file;public,static,void,check,file,count,for,job,int,expected,count,job,id,job,id,blob,service,blob,service,throws,ioexception,final,file,job,dir,if,blob,service,instanceof,blob,server,blob,server,server,blob,server,blob,service,job,dir,server,get,storage,location,job,id,new,blob,key,get,parent,file,else,blob,cache,cache,blob,cache,blob,service,job,dir,cache,get,storage,location,job,id,new,blob,key,get,parent,file,file,blobs,for,job,job,dir,list,files,if,blobs,for,job,null,if,expected,count,0,throw,new,ioexception,file,job,dir,does,not,exist,else,assert,equals,too,many,few,files,in,job,dir,arrays,as,list,blobs,for,job,to,string,expected,count,blobs,for,job,length
BlobCacheCleanupTest -> @Test 	public void testPermanentBlobCleanup() throws IOException, InterruptedException;1508578816;Tests that {@link PermanentBlobCache} cleans up after calling {@link PermanentBlobCache#releaseJob(JobID)}.;@Test_	public void testPermanentBlobCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			_			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)__			verifyJobCleanup(cache, jobId, keys)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,permanent,blob,cache,cleans,up,after,calling,link,permanent,blob,cache,release,job,job,id;test,public,void,test,permanent,blob,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,verify,job,cleanup,cache,job,id,keys,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	public void testPermanentBlobCleanup() throws IOException, InterruptedException;1517915730;Tests that {@link PermanentBlobCache} cleans up after calling {@link PermanentBlobCache#releaseJob(JobID)}.;@Test_	public void testPermanentBlobCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(config, new VoidBlobStore(), serverAddress)___			_			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)__			verifyJobCleanup(cache, jobId, keys)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,permanent,blob,cache,cleans,up,after,calling,link,permanent,blob,cache,release,job,job,id;test,public,void,test,permanent,blob,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,config,new,void,blob,store,server,address,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,verify,job,cleanup,cache,job,id,keys,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	public void testPermanentBlobCleanup() throws IOException, InterruptedException;1526549506;Tests that {@link PermanentBlobCache} cleans up after calling {@link PermanentBlobCache#releaseJob(JobID)}.;@Test_	public void testPermanentBlobCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(config, new VoidBlobStore(), serverAddress)___			_			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)__			verifyJobCleanup(cache, jobId, keys)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,permanent,blob,cache,cleans,up,after,calling,link,permanent,blob,cache,release,job,job,id;test,public,void,test,permanent,blob,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,config,new,void,blob,store,server,address,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,verify,job,cleanup,cache,job,id,keys,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	public void testJobCleanup() throws IOException, InterruptedException;1503041372;Tests that {@link BlobCache} cleans up after calling {@link BlobCache#releaseJob(JobID)}.;@Test_	public void testJobCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())___			_			try (BlobClient bc = new BlobClient(serverAddress, config)) {_				keys.add(bc.put(jobId, buf))__				buf[0] += 1__				keys.add(bc.put(jobId, buf))__			}__			cache = new BlobCache(serverAddress, config, new VoidBlobStore())___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (BlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (BlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			_			_			{_				long deadline = System.currentTimeMillis() + 30_000L__				do {_					Thread.sleep(100)__				}_				while (checkFilesExist(jobId, keys, cache, false) != 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			_			checkFileCountForJob(0, jobId, cache)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,blob,cache,cleans,up,after,calling,link,blob,cache,release,job,job,id;test,public,void,test,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,try,blob,client,bc,new,blob,client,server,address,config,keys,add,bc,put,job,id,buf,buf,0,1,keys,add,bc,put,job,id,buf,cache,new,blob,cache,server,address,config,new,void,blob,store,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,long,deadline,system,current,time,millis,do,thread,sleep,100,while,check,files,exist,job,id,keys,cache,false,0,system,current,time,millis,deadline,check,file,count,for,job,0,job,id,cache,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	public void testJobCleanup() throws IOException, InterruptedException;1507212386;Tests that {@link BlobCache} cleans up after calling {@link BlobCache#releaseJob(JobID)}.;@Test_	public void testJobCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())___			_			try (BlobClient bc = new BlobClient(serverAddress, config)) {_				keys.add(bc.put(jobId, buf))__				buf[0] += 1__				keys.add(bc.put(jobId, buf))__			}__			cache = new BlobCache(serverAddress, config, new VoidBlobStore())___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (BlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (BlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			_			_			{_				long deadline = System.currentTimeMillis() + 30_000L__				do {_					Thread.sleep(100)__				}_				while (checkFilesExist(jobId, keys, cache, false) != 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			_			checkFileCountForJob(0, jobId, cache)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,blob,cache,cleans,up,after,calling,link,blob,cache,release,job,job,id;test,public,void,test,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,try,blob,client,bc,new,blob,client,server,address,config,keys,add,bc,put,job,id,buf,buf,0,1,keys,add,bc,put,job,id,buf,cache,new,blob,cache,server,address,config,new,void,blob,store,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,long,deadline,system,current,time,millis,do,thread,sleep,100,while,check,files,exist,job,id,keys,cache,false,0,system,current,time,millis,deadline,check,file,count,for,job,0,job,id,cache,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	public void testJobCleanup() throws IOException, InterruptedException;1507212387;Tests that {@link PermanentBlobCache} cleans up after calling {@link PermanentBlobCache#releaseJob(JobID)}.;@Test_	public void testJobCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		List<BlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			_			keys.add(server.putHA(jobId, buf))__			buf[0] += 1__			keys.add(server.putHA(jobId, buf))___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (BlobKey key : keys) {_				cache.getHAFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (BlobKey key : keys) {_				cache.getHAFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			_			_			{_				long deadline = System.currentTimeMillis() + 30_000L__				do {_					Thread.sleep(100)__				}_				while (checkFilesExist(jobId, keys, cache, false) != 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			_			checkFileCountForJob(0, jobId, cache)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,permanent,blob,cache,cleans,up,after,calling,link,permanent,blob,cache,release,job,job,id;test,public,void,test,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,list,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,ha,job,id,buf,buf,0,1,keys,add,server,put,ha,job,id,buf,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,blob,key,key,keys,cache,get,hafile,job,id,key,cache,register,job,job,id,for,blob,key,key,keys,cache,get,hafile,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,long,deadline,system,current,time,millis,do,thread,sleep,100,while,check,files,exist,job,id,keys,cache,false,0,system,current,time,millis,deadline,check,file,count,for,job,0,job,id,cache,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	public void testJobCleanup() throws IOException, InterruptedException;1507212387;Tests that {@link PermanentBlobCache} cleans up after calling {@link PermanentBlobCache#releaseJob(JobID)}.;@Test_	public void testJobCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			_			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)__			verifyJobCleanup(cache, jobId, keys)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,that,link,permanent,blob,cache,cleans,up,after,calling,link,permanent,blob,cache,release,job,job,id;test,public,void,test,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,verify,job,cleanup,cache,job,id,keys,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ") 	public void testPermanentBlobDeferredCleanup() throws IOException, InterruptedException;1508578816;Tests the deferred cleanup of {@link PermanentBlobCache}, i.e. after calling {@link_PermanentBlobCache#releaseJob(JobID)} the file should be preserved a bit longer and then_cleaned up.;@Test_	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ")_	public void testPermanentBlobDeferredCleanup() throws IOException, InterruptedException {_		_		long cleanupInterval = 5L___		JobID jobId = new JobID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, cleanupInterval)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			_			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep(cleanupInterval / 5)__			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep((cleanupInterval * 4) / 5)___			_			verifyJobCleanup(cache, jobId, keys)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,the,deferred,cleanup,of,link,permanent,blob,cache,i,e,after,calling,link,permanent,blob,cache,release,job,job,id,the,file,should,be,preserved,a,bit,longer,and,then,cleaned,up;test,ignore,manual,test,due,to,stalling,ensures,a,blob,is,retained,first,and,only,deleted,after,the,long,timeout,public,void,test,permanent,blob,deferred,cleanup,throws,ioexception,interrupted,exception,long,cleanup,interval,5l,job,id,job,id,new,job,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,cleanup,interval,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,5,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,4,5,verify,job,cleanup,cache,job,id,keys,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ") 	public void testPermanentBlobDeferredCleanup() throws IOException, InterruptedException;1517915730;Tests the deferred cleanup of {@link PermanentBlobCache}, i.e. after calling {@link_PermanentBlobCache#releaseJob(JobID)} the file should be preserved a bit longer and then_cleaned up.;@Test_	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ")_	public void testPermanentBlobDeferredCleanup() throws IOException, InterruptedException {_		_		long cleanupInterval = 5L___		JobID jobId = new JobID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, cleanupInterval)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(config, new VoidBlobStore(), serverAddress)___			_			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep(cleanupInterval / 5)__			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep((cleanupInterval * 4) / 5)___			_			verifyJobCleanup(cache, jobId, keys)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,the,deferred,cleanup,of,link,permanent,blob,cache,i,e,after,calling,link,permanent,blob,cache,release,job,job,id,the,file,should,be,preserved,a,bit,longer,and,then,cleaned,up;test,ignore,manual,test,due,to,stalling,ensures,a,blob,is,retained,first,and,only,deleted,after,the,long,timeout,public,void,test,permanent,blob,deferred,cleanup,throws,ioexception,interrupted,exception,long,cleanup,interval,5l,job,id,job,id,new,job,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,cleanup,interval,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,config,new,void,blob,store,server,address,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,5,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,4,5,verify,job,cleanup,cache,job,id,keys,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> @Test 	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ") 	public void testPermanentBlobDeferredCleanup() throws IOException, InterruptedException;1526549506;Tests the deferred cleanup of {@link PermanentBlobCache}, i.e. after calling {@link_PermanentBlobCache#releaseJob(JobID)} the file should be preserved a bit longer and then_cleaned up.;@Test_	@Ignore("manual test due to stalling: ensures a BLOB is retained first and only deleted after the (long) timeout ")_	public void testPermanentBlobDeferredCleanup() throws IOException, InterruptedException {_		_		long cleanupInterval = 5L___		JobID jobId = new JobID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, cleanupInterval)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(config, new VoidBlobStore(), serverAddress)___			_			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			_			cache.registerJob(jobId)___			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			_			cache.registerJob(jobId)__			for (PermanentBlobKey key : keys) {_				cache.getFile(jobId, key)__			}__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_			cache.releaseJob(jobId)___			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep(cleanupInterval / 5)__			_			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, cache)___			Thread.sleep((cleanupInterval * 4) / 5)___			_			verifyJobCleanup(cache, jobId, keys)__			_			checkFileCountForJob(2, jobId, server)__		}_		finally {_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_			_			checkFileCountForJob(0, jobId, server)__		}_	};tests,the,deferred,cleanup,of,link,permanent,blob,cache,i,e,after,calling,link,permanent,blob,cache,release,job,job,id,the,file,should,be,preserved,a,bit,longer,and,then,cleaned,up;test,ignore,manual,test,due,to,stalling,ensures,a,blob,is,retained,first,and,only,deleted,after,the,long,timeout,public,void,test,permanent,blob,deferred,cleanup,throws,ioexception,interrupted,exception,long,cleanup,interval,5l,job,id,job,id,new,job,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,cleanup,interval,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,config,new,void,blob,store,server,address,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,cache,register,job,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,cache,register,job,job,id,for,permanent,blob,key,key,keys,cache,get,file,job,id,key,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,cache,release,job,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,5,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,cache,thread,sleep,cleanup,interval,4,5,verify,job,cleanup,cache,job,id,keys,check,file,count,for,job,2,job,id,server,finally,if,cache,null,cache,close,if,server,null,server,close,check,file,count,for,job,0,job,id,server
BlobCacheCleanupTest -> public static void checkFileCountForJob( 		int expectedCount, JobID jobId, PermanentBlobService blobService) 		throws IOException;1507212387;Checks how many of the files given by blob keys are accessible.__@param expectedCount_number of expected files in the blob service for the given job_@param jobId_ID of a job_@param blobService_BLOB store to use;public static void checkFileCountForJob(_		int expectedCount, JobID jobId, PermanentBlobService blobService)_		throws IOException {__		final File jobDir__		if (blobService instanceof BlobServer) {_			BlobServer server = (BlobServer) blobService__			jobDir = server.getStorageLocation(jobId, new BlobKey()).getParentFile()__		} else {_			PermanentBlobCache cache = (PermanentBlobCache) blobService__			jobDir = cache.getStorageLocation(jobId, new BlobKey()).getParentFile()__		}_		File[] blobsForJob = jobDir.listFiles()__		if (blobsForJob == null) {_			if (expectedCount != 0) {_				throw new IOException("File " + jobDir + " does not exist.")__			}_		} else {_			assertEquals("Too many/few files in job dir: " +_					Arrays.asList(blobsForJob).toString(), expectedCount,_				blobsForJob.length)__		}_	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,expected,count,number,of,expected,files,in,the,blob,service,for,the,given,job,param,job,id,id,of,a,job,param,blob,service,blob,store,to,use;public,static,void,check,file,count,for,job,int,expected,count,job,id,job,id,permanent,blob,service,blob,service,throws,ioexception,final,file,job,dir,if,blob,service,instanceof,blob,server,blob,server,server,blob,server,blob,service,job,dir,server,get,storage,location,job,id,new,blob,key,get,parent,file,else,permanent,blob,cache,cache,permanent,blob,cache,blob,service,job,dir,cache,get,storage,location,job,id,new,blob,key,get,parent,file,file,blobs,for,job,job,dir,list,files,if,blobs,for,job,null,if,expected,count,0,throw,new,ioexception,file,job,dir,does,not,exist,else,assert,equals,too,many,few,files,in,job,dir,arrays,as,list,blobs,for,job,to,string,expected,count,blobs,for,job,length
BlobCacheCleanupTest -> public static void checkFileCountForJob( 		int expectedCount, JobID jobId, PermanentBlobService blobService) 		throws IOException;1507212387;Checks how many of the files given by blob keys are accessible.__@param expectedCount_number of expected files in the blob service for the given job_@param jobId_ID of a job_@param blobService_BLOB store to use;public static void checkFileCountForJob(_		int expectedCount, JobID jobId, PermanentBlobService blobService)_		throws IOException {__		final File jobDir__		if (blobService instanceof BlobServer) {_			BlobServer server = (BlobServer) blobService__			jobDir = server.getStorageLocation(jobId, new PermanentBlobKey()).getParentFile()__		} else {_			PermanentBlobCache cache = (PermanentBlobCache) blobService__			jobDir = cache.getStorageLocation(jobId, new PermanentBlobKey()).getParentFile()__		}_		File[] blobsForJob = jobDir.listFiles()__		if (blobsForJob == null) {_			if (expectedCount != 0) {_				throw new IOException("File " + jobDir + " does not exist.")__			}_		} else {_			assertEquals("Too many/few files in job dir: " +_					Arrays.asList(blobsForJob).toString(), expectedCount,_				blobsForJob.length)__		}_	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,expected,count,number,of,expected,files,in,the,blob,service,for,the,given,job,param,job,id,id,of,a,job,param,blob,service,blob,store,to,use;public,static,void,check,file,count,for,job,int,expected,count,job,id,job,id,permanent,blob,service,blob,service,throws,ioexception,final,file,job,dir,if,blob,service,instanceof,blob,server,blob,server,server,blob,server,blob,service,job,dir,server,get,storage,location,job,id,new,permanent,blob,key,get,parent,file,else,permanent,blob,cache,cache,permanent,blob,cache,blob,service,job,dir,cache,get,storage,location,job,id,new,permanent,blob,key,get,parent,file,file,blobs,for,job,job,dir,list,files,if,blobs,for,job,null,if,expected,count,0,throw,new,ioexception,file,job,dir,does,not,exist,else,assert,equals,too,many,few,files,in,job,dir,arrays,as,list,blobs,for,job,to,string,expected,count,blobs,for,job,length
BlobCacheCleanupTest -> @Test 	public void testPermanentJobReferences() throws IOException, InterruptedException;1508578816;Tests that {@link PermanentBlobCache} sets the expected reference counts and cleanup timeouts_when registering, releasing, and re-registering jobs.;@Test_	public void testPermanentJobReferences() throws IOException, InterruptedException {__		JobID jobId = new JobID()___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600_000L)_ __		_		InetSocketAddress serverAddress = new InetSocketAddress("localhost", 12345)___		try (PermanentBlobCache cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())) {__			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.registerJob(jobId)__			assertEquals(2, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.releaseJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			long cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))___			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))__		}_	};tests,that,link,permanent,blob,cache,sets,the,expected,reference,counts,and,cleanup,timeouts,when,registering,releasing,and,re,registering,jobs;test,public,void,test,permanent,job,references,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,inet,socket,address,server,address,new,inet,socket,address,localhost,12345,try,permanent,blob,cache,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,register,job,job,id,assert,equals,2,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,release,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,long,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound
BlobCacheCleanupTest -> @Test 	public void testPermanentJobReferences() throws IOException, InterruptedException;1517915730;Tests that {@link PermanentBlobCache} sets the expected reference counts and cleanup timeouts_when registering, releasing, and re-registering jobs.;@Test_	public void testPermanentJobReferences() throws IOException, InterruptedException {__		JobID jobId = new JobID()___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600_000L)_ __		_		InetSocketAddress serverAddress = new InetSocketAddress("localhost", 12345)___		try (PermanentBlobCache cache = new PermanentBlobCache(config, new VoidBlobStore(), serverAddress)) {__			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.registerJob(jobId)__			assertEquals(2, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.releaseJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			long cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))___			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))__		}_	};tests,that,link,permanent,blob,cache,sets,the,expected,reference,counts,and,cleanup,timeouts,when,registering,releasing,and,re,registering,jobs;test,public,void,test,permanent,job,references,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,inet,socket,address,server,address,new,inet,socket,address,localhost,12345,try,permanent,blob,cache,cache,new,permanent,blob,cache,config,new,void,blob,store,server,address,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,register,job,job,id,assert,equals,2,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,release,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,long,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound
BlobCacheCleanupTest -> @Test 	public void testPermanentJobReferences() throws IOException, InterruptedException;1526549506;Tests that {@link PermanentBlobCache} sets the expected reference counts and cleanup timeouts_when registering, releasing, and re-registering jobs.;@Test_	public void testPermanentJobReferences() throws IOException, InterruptedException {__		JobID jobId = new JobID()___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600_000L)_ __		_		InetSocketAddress serverAddress = new InetSocketAddress("localhost", 12345)___		try (PermanentBlobCache cache = new PermanentBlobCache(config, new VoidBlobStore(), serverAddress)) {__			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.registerJob(jobId)__			assertEquals(2, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cache.releaseJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			long cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))___			_			cache.registerJob(jobId)__			assertEquals(1, cache.getJobRefCounters().get(jobId).references)__			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil)___			_			cleanupLowerBound =_				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL)__			cache.releaseJob(jobId)__			assertEquals(0, cache.getJobRefCounters().get(jobId).references)__			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,_				greaterThanOrEqualTo(cleanupLowerBound))__		}_	};tests,that,link,permanent,blob,cache,sets,the,expected,reference,counts,and,cleanup,timeouts,when,registering,releasing,and,re,registering,jobs;test,public,void,test,permanent,job,references,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,inet,socket,address,server,address,new,inet,socket,address,localhost,12345,try,permanent,blob,cache,cache,new,permanent,blob,cache,config,new,void,blob,store,server,address,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,register,job,job,id,assert,equals,2,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cache,release,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,long,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound,cache,register,job,job,id,assert,equals,1,cache,get,job,ref,counters,get,job,id,references,assert,equals,1,cache,get,job,ref,counters,get,job,id,keep,until,cleanup,lower,bound,system,current,time,millis,config,get,long,blob,server,options,cache,release,job,job,id,assert,equals,0,cache,get,job,ref,counters,get,job,id,references,assert,that,cache,get,job,ref,counters,get,job,id,keep,until,greater,than,or,equal,to,cleanup,lower,bound
