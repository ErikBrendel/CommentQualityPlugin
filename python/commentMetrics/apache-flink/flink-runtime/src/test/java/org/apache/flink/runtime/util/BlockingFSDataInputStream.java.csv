commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public void seek(long desired) throws IOException {     if (delegate != null) {         delegate.seek(desired).     }     this.position = desired. }
false;public;0;4;;@Override public long getPos() throws IOException {     return position. }
false;public;0;26;;@Override public int read() throws IOException {     if (position == blockAtPosition) {         unblockWaiter().         awaitBlocker().     }     int val = 0.     if (delegate != null) {         try {             val = delegate.read().         } catch (IOException ex) {             unblockWaiter().             throw ex.         }     }     // We also check for close here, in case the underlying stream does not do this     if (closed.get()) {         throw new IOException("Stream closed.").     } else {         ++position.         return val.     } }
false;public;3;30;;@Override public int read(byte[] b, int off, int len) throws IOException {     // We override this to ensure that we use the blocking read method internally.     if (b == null) {         throw new NullPointerException().     } else if (off < 0 || len < 0 || len > b.length - off) {         throw new IndexOutOfBoundsException().     } else if (len == 0) {         return 0.     }     int c = read().     if (c == -1) {         return -1.     }     b[off] = (byte) c.     int i = 1.     try {         for (. i < len. i++) {             c = read().             if (c == -1) {                 break.             }             b[off + i] = (byte) c.         }     } catch (IOException ee) {     }     return i. }
false;public;0;10;;@Override public void close() {     if (closed.compareAndSet(false, true)) {         if (delegate != null) {             IOUtils.closeQuietly(delegate).         }         // trigger all the latches, essentially all blocking ops on the stream should resume after close.         unblockAll().     } }
false;private;0;5;;private void unblockWaiter() {     if (null != waitUntilStreamBlocked) {         waitUntilStreamBlocked.trigger().     } }
false;private;0;8;;private void awaitBlocker() {     if (null != triggerUnblock) {         try {             triggerUnblock.await().         } catch (InterruptedException ignored) {         }     } }
false;private;0;8;;private void unblockAll() {     if (null != waitUntilStreamBlocked) {         waitUntilStreamBlocked.trigger().     }     if (null != triggerUnblock) {         triggerUnblock.trigger().     } }
