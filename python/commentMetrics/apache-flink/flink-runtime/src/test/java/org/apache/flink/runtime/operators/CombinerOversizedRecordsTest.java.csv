commented;modifiers;parameterAmount;loc;comment;code
false;public;0;63;;@Test public void testOversizedRecordCombineTask() {     try {         final int keyCnt = 100.         final int valCnt = 20.         // create a long heavy string payload         StringBuilder bld = new StringBuilder(10 * 1024 * 1024).         Random rnd = new Random().         for (int i = 0. i < 10000000. i++) {             bld.append((char) (rnd.nextInt(26) + 'a')).         }         String longString = bld.toString().         bld = null.         // construct the input as a union of         // 1) long string         // 2) some random values         // 3) long string         // 4) random values         // 5) long string         // random values 1         MutableObjectIterator<Tuple2<Integer, Integer>> gen1 = new UniformIntTupleGenerator(keyCnt, valCnt, false).         // random values 2         MutableObjectIterator<Tuple2<Integer, Integer>> gen2 = new UniformIntTupleGenerator(keyCnt, valCnt, false).         @SuppressWarnings("unchecked")         MutableObjectIterator<Tuple3<Integer, Integer, String>> input = new UnionIterator<Tuple3<Integer, Integer, String>>(new SingleValueIterator<Tuple3<Integer, Integer, String>>(new Tuple3<Integer, Integer, String>(-1, -1, longString)), new StringIteratorDecorator(gen1), new SingleValueIterator<Tuple3<Integer, Integer, String>>(new Tuple3<Integer, Integer, String>(-1, -1, longString)), new StringIteratorDecorator(gen2), new SingleValueIterator<Tuple3<Integer, Integer, String>>(new Tuple3<Integer, Integer, String>(-1, -1, longString))).         setInput(input, serializer).         addDriverComparator(this.comparator).         addDriverComparator(this.comparator).         setOutput(this.outList, this.outSerializer).         getTaskConfig().setDriverStrategy(DriverStrategy.SORTED_GROUP_COMBINE).         getTaskConfig().setRelativeMemoryDriver(combine_frac).         getTaskConfig().setFilehandlesDriver(2).         GroupReduceCombineDriver<Tuple3<Integer, Integer, String>, Tuple3<Integer, Double, String>> testTask = new GroupReduceCombineDriver<Tuple3<Integer, Integer, String>, Tuple3<Integer, Double, String>>().         testDriver(testTask, TestCombiner.class).         assertEquals(3, testTask.getOversizedRecordCount()).         assertTrue(keyCnt + 3 == outList.size() || 2 * keyCnt + 3 == outList.size()).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;16;;@Override public void combine(Iterable<Tuple3<Integer, Integer, String>> values, Collector<Tuple3<Integer, Double, String>> out) {     int key = 0.     int sum = 0.     String someString = null.     for (Tuple3<Integer, Integer, String> next : values) {         key = next.f0.         sum += next.f1.         someString = next.f2.     }     out.collect(new Tuple3<Integer, Double, String>(key, (double) sum, someString)). }
false;public;1;13;;@Override public Tuple3<Integer, Integer, String> next(Tuple3<Integer, Integer, String> reuse) throws IOException {     Tuple2<Integer, Integer> next = input.next().     if (next == null) {         return null.     } else {         reuse.f0 = next.f0.         reuse.f1 = next.f1.         reuse.f2 = "test string".         return reuse.     } }
false;public;0;10;;@Override public Tuple3<Integer, Integer, String> next() throws IOException {     Tuple2<Integer, Integer> next = input.next().     if (next == null) {         return null.     } else {         return new Tuple3<Integer, Integer, String>(next.f0, next.f1, "test string").     } }
false;public;1;4;;@Override public T next(T reuse) {     return next(). }
false;public;0;9;;@Override public T next() {     if (pending) {         pending = false.         return value.     } else {         return null.     } }
