commented;modifiers;parameterAmount;loc;comment;code
true;public;0;20;/**  * Tests that the checkpoint coordinator is shut down if the execution graph  * is failed.  */ ;/**  * Tests that the checkpoint coordinator is shut down if the execution graph  * is failed.  */ @Test public void testShutdownCheckpointCoordinatorOnFailure() throws Exception {     final CompletableFuture<JobStatus> counterShutdownFuture = new CompletableFuture<>().     CheckpointIDCounter counter = new TestingCheckpointIDCounter(counterShutdownFuture).     final CompletableFuture<JobStatus> storeShutdownFuture = new CompletableFuture<>().     CompletedCheckpointStore store = new TestingCompletedCheckpointStore(storeShutdownFuture).     ExecutionGraph graph = createExecutionGraphAndEnableCheckpointing(counter, store).     final CheckpointCoordinator checkpointCoordinator = graph.getCheckpointCoordinator().     assertThat(checkpointCoordinator, Matchers.notNullValue()).     assertThat(checkpointCoordinator.isShutdown(), is(false)).     graph.failGlobal(new Exception("Test Exception")).     assertThat(checkpointCoordinator.isShutdown(), is(true)).     assertThat(counterShutdownFuture.get(), is(JobStatus.FAILED)).     assertThat(storeShutdownFuture.get(), is(JobStatus.FAILED)). }
true;public;0;20;/**  * Tests that the checkpoint coordinator is shut down if the execution graph  * is suspended.  */ ;/**  * Tests that the checkpoint coordinator is shut down if the execution graph  * is suspended.  */ @Test public void testShutdownCheckpointCoordinatorOnSuspend() throws Exception {     final CompletableFuture<JobStatus> counterShutdownFuture = new CompletableFuture<>().     CheckpointIDCounter counter = new TestingCheckpointIDCounter(counterShutdownFuture).     final CompletableFuture<JobStatus> storeShutdownFuture = new CompletableFuture<>().     CompletedCheckpointStore store = new TestingCompletedCheckpointStore(storeShutdownFuture).     ExecutionGraph graph = createExecutionGraphAndEnableCheckpointing(counter, store).     final CheckpointCoordinator checkpointCoordinator = graph.getCheckpointCoordinator().     assertThat(checkpointCoordinator, Matchers.notNullValue()).     assertThat(checkpointCoordinator.isShutdown(), is(false)).     graph.suspend(new Exception("Test Exception")).     assertThat(checkpointCoordinator.isShutdown(), is(true)).     assertThat(counterShutdownFuture.get(), is(JobStatus.SUSPENDED)).     assertThat(storeShutdownFuture.get(), is(JobStatus.SUSPENDED)). }
true;public;0;27;/**  * Tests that the checkpoint coordinator is shut down if the execution graph  * is finished.  */ ;/**  * Tests that the checkpoint coordinator is shut down if the execution graph  * is finished.  */ @Test public void testShutdownCheckpointCoordinatorOnFinished() throws Exception {     final CompletableFuture<JobStatus> counterShutdownFuture = new CompletableFuture<>().     CheckpointIDCounter counter = new TestingCheckpointIDCounter(counterShutdownFuture).     final CompletableFuture<JobStatus> storeShutdownFuture = new CompletableFuture<>().     CompletedCheckpointStore store = new TestingCompletedCheckpointStore(storeShutdownFuture).     ExecutionGraph graph = createExecutionGraphAndEnableCheckpointing(counter, store).     final CheckpointCoordinator checkpointCoordinator = graph.getCheckpointCoordinator().     assertThat(checkpointCoordinator, Matchers.notNullValue()).     assertThat(checkpointCoordinator.isShutdown(), is(false)).     graph.scheduleForExecution().     for (ExecutionVertex executionVertex : graph.getAllExecutionVertices()) {         final Execution currentExecutionAttempt = executionVertex.getCurrentExecutionAttempt().         graph.updateState(new TaskExecutionState(graph.getJobID(), currentExecutionAttempt.getAttemptId(), ExecutionState.FINISHED)).     }     assertThat(graph.getTerminationFuture().get(), is(JobStatus.FINISHED)).     assertThat(checkpointCoordinator.isShutdown(), is(true)).     assertThat(counterShutdownFuture.get(), is(JobStatus.FINISHED)).     assertThat(storeShutdownFuture.get(), is(JobStatus.FINISHED)). }
false;private;2;40;;private ExecutionGraph createExecutionGraphAndEnableCheckpointing(CheckpointIDCounter counter, CompletedCheckpointStore store) throws Exception {     final Time timeout = Time.days(1L).     ExecutionGraph executionGraph = new ExecutionGraph(new DummyJobInformation(), TestingUtils.defaultExecutor(), TestingUtils.defaultExecutor(), timeout, new NoRestartStrategy(), new RestartAllStrategy.Factory(), new TestingSlotProvider(slotRequestId -> CompletableFuture.completedFuture(new TestingLogicalSlot())), ClassLoader.getSystemClassLoader(), VoidBlobWriter.getInstance(), timeout).     executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread()).     executionGraph.enableCheckpointing(100, 100, 100, 1, CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION, Collections.emptyList(), Collections.emptyList(), Collections.emptyList(), Collections.emptyList(), counter, store, new MemoryStateBackend(), CheckpointStatsTrackerTest.createTestTracker()).     JobVertex jobVertex = new JobVertex("MockVertex").     jobVertex.setInvokableClass(AbstractInvokable.class).     executionGraph.attachJobGraph(Collections.singletonList(jobVertex)).     executionGraph.setQueuedSchedulingAllowed(true).     return executionGraph. }
false;public;0;2;;@Override public void start() { }
false;public;1;4;;@Override public void shutdown(JobStatus jobStatus) {     shutdownStatus.complete(jobStatus). }
false;public;0;4;;@Override public long getAndIncrement() {     throw new UnsupportedOperationException("Not implemented."). }
false;public;1;4;;@Override public void setCount(long newId) {     throw new UnsupportedOperationException("Not implemented."). }
false;public;0;4;;@Override public void recover() {     throw new UnsupportedOperationException("Not implemented."). }
false;public;1;4;;@Override public void addCheckpoint(CompletedCheckpoint checkpoint) {     throw new UnsupportedOperationException("Not implemented."). }
false;public;0;4;;@Override public CompletedCheckpoint getLatestCheckpoint() {     throw new UnsupportedOperationException("Not implemented."). }
false;public;1;4;;@Override public void shutdown(JobStatus jobStatus) {     shutdownStatus.complete(jobStatus). }
false;public;0;4;;@Override public List<CompletedCheckpoint> getAllCheckpoints() {     throw new UnsupportedOperationException("Not implemented."). }
false;public;0;4;;@Override public int getNumberOfRetainedCheckpoints() {     throw new UnsupportedOperationException("Not implemented."). }
false;public;0;4;;@Override public int getMaxNumberOfRetainedCheckpoints() {     throw new UnsupportedOperationException("Not implemented."). }
false;public;0;4;;@Override public boolean requiresExternalizedCheckpoints() {     throw new UnsupportedOperationException("Not implemented."). }
