commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Test public void runJobWithSingleRpcService() throws Exception {     final int numOfTMs = 3.     final int slotsPerTM = 7.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(numOfTMs).setNumSlotsPerTaskManager(slotsPerTM).setRpcServiceSharing(RpcServiceSharing.SHARED).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         miniCluster.executeJobBlocking(getSimpleJob(numOfTMs * slotsPerTM)).     } }
false;public;0;18;;@Test public void runJobWithMultipleRpcServices() throws Exception {     final int numOfTMs = 3.     final int slotsPerTM = 7.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(numOfTMs).setNumSlotsPerTaskManager(slotsPerTM).setRpcServiceSharing(RpcServiceSharing.DEDICATED).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         miniCluster.executeJobBlocking(getSimpleJob(numOfTMs * slotsPerTM)).     } }
false;public;0;11;;@Test public void testHandleStreamingJobsWhenNotEnoughSlot() throws Exception {     try {         setupAndRunHandleJobsWhenNotEnoughSlots(ScheduleMode.EAGER).         fail("Job should fail.").     } catch (JobExecutionException e) {         assertTrue(findThrowableWithMessage(e, "Job execution failed.").isPresent()).         assertTrue(findThrowable(e, NoResourceAvailableException.class).isPresent()).         assertTrue(findThrowableWithMessage(e, "Slots required: 2, slots allocated: 1").isPresent()).     } }
false;public;0;11;;@Test public void testHandleBatchJobsWhenNotEnoughSlot() throws Exception {     try {         setupAndRunHandleJobsWhenNotEnoughSlots(ScheduleMode.LAZY_FROM_SOURCES).         fail("Job should fail.").     } catch (JobExecutionException e) {         assertTrue(findThrowableWithMessage(e, "Job execution failed.").isPresent()).         assertTrue(findThrowable(e, NoResourceAvailableException.class).isPresent()).         assertTrue(findThrowableWithMessage(e, "Could not allocate enough slots").isPresent()).     } }
false;private;1;11;;private void setupAndRunHandleJobsWhenNotEnoughSlots(ScheduleMode scheduleMode) throws Exception {     final JobVertex vertex = new JobVertex("Test Vertex").     vertex.setParallelism(2).     vertex.setMaxParallelism(2).     vertex.setInvokableClass(BlockingNoOpInvokable.class).     final JobGraph jobGraph = new JobGraph("Test Job", vertex).     jobGraph.setScheduleMode(scheduleMode).     runHandleJobsWhenNotEnoughSlots(jobGraph). }
false;private;1;16;;private void runHandleJobsWhenNotEnoughSlots(final JobGraph jobGraph) throws Exception {     final Configuration configuration = getDefaultConfiguration().     configuration.setLong(JobManagerOptions.SLOT_REQUEST_TIMEOUT, 100L).     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(1).setConfiguration(configuration).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         miniCluster.executeJobBlocking(jobGraph).     } }
false;public;0;29;;@Test public void testForwardJob() throws Exception {     final int parallelism = 31.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex sender = new JobVertex("Sender").         sender.setInvokableClass(Sender.class).         sender.setParallelism(parallelism).         final JobVertex receiver = new JobVertex("Receiver").         receiver.setInvokableClass(Receiver.class).         receiver.setParallelism(parallelism).         receiver.connectNewDataSetAsInput(sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("Pointwise Job", sender, receiver).         miniCluster.executeJobBlocking(jobGraph).     } }
false;public;0;29;;@Test public void testBipartiteJob() throws Exception {     final int parallelism = 31.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex sender = new JobVertex("Sender").         sender.setInvokableClass(Sender.class).         sender.setParallelism(parallelism).         final JobVertex receiver = new JobVertex("Receiver").         receiver.setInvokableClass(AgnosticReceiver.class).         receiver.setParallelism(parallelism).         receiver.connectNewDataSetAsInput(sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("Bipartite Job", sender, receiver).         miniCluster.executeJobBlocking(jobGraph).     } }
false;public;0;42;;@Test public void testTwoInputJobFailingEdgeMismatch() throws Exception {     final int parallelism = 1.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(6 * parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex sender1 = new JobVertex("Sender1").         sender1.setInvokableClass(Sender.class).         sender1.setParallelism(parallelism).         final JobVertex sender2 = new JobVertex("Sender2").         sender2.setInvokableClass(Sender.class).         sender2.setParallelism(2 * parallelism).         final JobVertex receiver = new JobVertex("Receiver").         receiver.setInvokableClass(AgnosticTertiaryReceiver.class).         receiver.setParallelism(3 * parallelism).         receiver.connectNewDataSetAsInput(sender1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).         receiver.connectNewDataSetAsInput(sender2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("Bipartite Job", sender1, receiver, sender2).         try {             miniCluster.executeJobBlocking(jobGraph).             fail("Job should fail.").         } catch (JobExecutionException e) {             assertTrue(findThrowable(e, ArrayIndexOutOfBoundsException.class).isPresent()).             assertTrue(findThrowableWithMessage(e, "2").isPresent()).         }     } }
false;public;0;35;;@Test public void testTwoInputJob() throws Exception {     final int parallelism = 11.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(6 * parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex sender1 = new JobVertex("Sender1").         sender1.setInvokableClass(Sender.class).         sender1.setParallelism(parallelism).         final JobVertex sender2 = new JobVertex("Sender2").         sender2.setInvokableClass(Sender.class).         sender2.setParallelism(2 * parallelism).         final JobVertex receiver = new JobVertex("Receiver").         receiver.setInvokableClass(AgnosticBinaryReceiver.class).         receiver.setParallelism(3 * parallelism).         receiver.connectNewDataSetAsInput(sender1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).         receiver.connectNewDataSetAsInput(sender2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("Bipartite Job", sender1, receiver, sender2).         miniCluster.executeJobBlocking(jobGraph).     } }
false;public;0;42;;@Test public void testSchedulingAllAtOnce() throws Exception {     final int parallelism = 11.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex sender = new JobVertex("Sender").         sender.setInvokableClass(Sender.class).         sender.setParallelism(parallelism).         final JobVertex forwarder = new JobVertex("Forwarder").         forwarder.setInvokableClass(Forwarder.class).         forwarder.setParallelism(parallelism).         final JobVertex receiver = new JobVertex("Receiver").         receiver.setInvokableClass(AgnosticReceiver.class).         receiver.setParallelism(parallelism).         final SlotSharingGroup sharingGroup = new SlotSharingGroup(sender.getID(), receiver.getID()).         sender.setSlotSharingGroup(sharingGroup).         forwarder.setSlotSharingGroup(sharingGroup).         receiver.setSlotSharingGroup(sharingGroup).         forwarder.connectNewDataSetAsInput(sender, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED).         receiver.connectNewDataSetAsInput(forwarder, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("Forwarding Job", sender, forwarder, receiver).         jobGraph.setScheduleMode(ScheduleMode.EAGER).         miniCluster.executeJobBlocking(jobGraph).     } }
false;public;0;36;;@Test public void testJobWithAFailingSenderVertex() throws Exception {     final int parallelism = 11.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex sender = new JobVertex("Sender").         sender.setInvokableClass(ExceptionSender.class).         sender.setParallelism(parallelism).         final JobVertex receiver = new JobVertex("Receiver").         receiver.setInvokableClass(Receiver.class).         receiver.setParallelism(parallelism).         receiver.connectNewDataSetAsInput(sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("Pointwise Job", sender, receiver).         try {             miniCluster.executeJobBlocking(jobGraph).             fail("Job should fail.").         } catch (JobExecutionException e) {             assertTrue(findThrowable(e, Exception.class).isPresent()).             assertTrue(findThrowableWithMessage(e, "Test exception").isPresent()).         }     } }
false;public;0;39;;@Test public void testJobWithAnOccasionallyFailingSenderVertex() throws Exception {     final int parallelism = 11.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex sender = new JobVertex("Sender").         sender.setInvokableClass(SometimesExceptionSender.class).         sender.setParallelism(parallelism).         // set failing senders         SometimesExceptionSender.configFailingSenders(parallelism).         final JobVertex receiver = new JobVertex("Receiver").         receiver.setInvokableClass(Receiver.class).         receiver.setParallelism(parallelism).         receiver.connectNewDataSetAsInput(sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("Pointwise Job", sender, receiver).         try {             miniCluster.executeJobBlocking(jobGraph).             fail("Job should fail.").         } catch (JobExecutionException e) {             assertTrue(findThrowable(e, Exception.class).isPresent()).             assertTrue(findThrowableWithMessage(e, "Test exception").isPresent()).         }     } }
false;public;0;36;;@Test public void testJobWithAFailingReceiverVertex() throws Exception {     final int parallelism = 11.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex sender = new JobVertex("Sender").         sender.setInvokableClass(Sender.class).         sender.setParallelism(parallelism).         final JobVertex receiver = new JobVertex("Receiver").         receiver.setInvokableClass(ExceptionReceiver.class).         receiver.setParallelism(parallelism).         receiver.connectNewDataSetAsInput(sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("Pointwise Job", sender, receiver).         try {             miniCluster.executeJobBlocking(jobGraph).             fail("Job should fail.").         } catch (JobExecutionException e) {             assertTrue(findThrowable(e, Exception.class).isPresent()).             assertTrue(findThrowableWithMessage(e, "Test exception").isPresent()).         }     } }
false;public;0;36;;@Test public void testJobWithAllVerticesFailingDuringInstantiation() throws Exception {     final int parallelism = 11.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex sender = new JobVertex("Sender").         sender.setInvokableClass(InstantiationErrorSender.class).         sender.setParallelism(parallelism).         final JobVertex receiver = new JobVertex("Receiver").         receiver.setInvokableClass(Receiver.class).         receiver.setParallelism(parallelism).         receiver.connectNewDataSetAsInput(sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("Pointwise Job", sender, receiver).         try {             miniCluster.executeJobBlocking(jobGraph).             fail("Job should fail.").         } catch (JobExecutionException e) {             assertTrue(findThrowable(e, Exception.class).isPresent()).             assertTrue(findThrowableWithMessage(e, "Test exception in constructor").isPresent()).         }     } }
false;public;0;39;;@Test public void testJobWithSomeVerticesFailingDuringInstantiation() throws Exception {     final int parallelism = 11.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex sender = new JobVertex("Sender").         sender.setInvokableClass(SometimesInstantiationErrorSender.class).         sender.setParallelism(parallelism).         // set failing senders         SometimesInstantiationErrorSender.configFailingSenders(parallelism).         final JobVertex receiver = new JobVertex("Receiver").         receiver.setInvokableClass(Receiver.class).         receiver.setParallelism(parallelism).         receiver.connectNewDataSetAsInput(sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("Pointwise Job", sender, receiver).         try {             miniCluster.executeJobBlocking(jobGraph).             fail("Job should fail.").         } catch (JobExecutionException e) {             assertTrue(findThrowable(e, Exception.class).isPresent()).             assertTrue(findThrowableWithMessage(e, "Test exception in constructor").isPresent()).         }     } }
false;public;0;36;;@Test public void testCallFinalizeOnMasterBeforeJobCompletes() throws Exception {     final int parallelism = 11.     final MiniClusterConfiguration cfg = new MiniClusterConfiguration.Builder().setNumTaskManagers(1).setNumSlotsPerTaskManager(parallelism).setConfiguration(getDefaultConfiguration()).build().     try (final MiniCluster miniCluster = new MiniCluster(cfg)) {         miniCluster.start().         final JobVertex source = new JobVertex("Source").         source.setInvokableClass(WaitingNoOpInvokable.class).         source.setParallelism(parallelism).         final WaitOnFinalizeJobVertex sink = new WaitOnFinalizeJobVertex("Sink", 20L).         sink.setInvokableClass(NoOpInvokable.class).         sink.setParallelism(parallelism).         sink.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).         final JobGraph jobGraph = new JobGraph("SubtaskInFinalStateRaceCondition", source, sink).         final CompletableFuture<JobSubmissionResult> submissionFuture = miniCluster.submitJob(jobGraph).         final CompletableFuture<JobResult> jobResultFuture = submissionFuture.thenCompose((JobSubmissionResult ignored) -> miniCluster.requestJobResult(jobGraph.getJobID())).         jobResultFuture.get().toJobExecutionResult(getClass().getClassLoader()).         assertTrue(sink.finalizedOnMaster.get()).     } }
false;private;0;6;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ private Configuration getDefaultConfiguration() {     final Configuration configuration = new Configuration().     configuration.setString(RestOptions.BIND_PORT, "0").     return configuration. }
false;private,static;1;15;;private static JobGraph getSimpleJob(int parallelism) throws IOException {     final JobVertex task = new JobVertex("Test task").     task.setParallelism(parallelism).     task.setMaxParallelism(parallelism).     task.setInvokableClass(NoOpInvokable.class).     final JobGraph jg = new JobGraph(new JobID(), "Test Job", task).     jg.setScheduleMode(ScheduleMode.EAGER).     final ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 1000)).     jg.setExecutionConfig(executionConfig).     return jg. }
false;public;1;5;;@Override public void finalizeOnMaster(ClassLoader loader) throws Exception {     Thread.sleep(waitingTime).     finalizedOnMaster.set(true). }
