# id;timestamp;commentText;codeText;commentWords;codeWords
PartitionRequestQueueTest -> @Test 	public void testDefaultBufferWriting() throws Exception;1516291532;Tests {@link PartitionRequestQueue} buffer writing with default buffers.;@Test_	public void testDefaultBufferWriting() throws Exception {_		testBufferWriting(new DefaultBufferResultSubpartitionView(2))__	};tests,link,partition,request,queue,buffer,writing,with,default,buffers;test,public,void,test,default,buffer,writing,throws,exception,test,buffer,writing,new,default,buffer,result,subpartition,view,2
PartitionRequestQueueTest -> @Test 	public void testDefaultBufferWriting() throws Exception;1518785736;Tests {@link PartitionRequestQueue} buffer writing with default buffers.;@Test_	public void testDefaultBufferWriting() throws Exception {_		testBufferWriting(new DefaultBufferResultSubpartitionView(2))__	};tests,link,partition,request,queue,buffer,writing,with,default,buffers;test,public,void,test,default,buffer,writing,throws,exception,test,buffer,writing,new,default,buffer,result,subpartition,view,2
PartitionRequestQueueTest -> @Test 	public void testDefaultBufferWriting() throws Exception;1518785736;Tests {@link PartitionRequestQueue} buffer writing with default buffers.;@Test_	public void testDefaultBufferWriting() throws Exception {_		testBufferWriting(new DefaultBufferResultSubpartitionView(2))__	};tests,link,partition,request,queue,buffer,writing,with,default,buffers;test,public,void,test,default,buffer,writing,throws,exception,test,buffer,writing,new,default,buffer,result,subpartition,view,2
PartitionRequestQueueTest -> @Test 	public void testDefaultBufferWriting() throws Exception;1519039301;Tests {@link PartitionRequestQueue} buffer writing with default buffers.;@Test_	public void testDefaultBufferWriting() throws Exception {_		testBufferWriting(new DefaultBufferResultSubpartitionView(1))__	};tests,link,partition,request,queue,buffer,writing,with,default,buffers;test,public,void,test,default,buffer,writing,throws,exception,test,buffer,writing,new,default,buffer,result,subpartition,view,1
PartitionRequestQueueTest -> @Test 	public void testDefaultBufferWriting() throws Exception;1519834372;Tests {@link PartitionRequestQueue} buffer writing with default buffers.;@Test_	public void testDefaultBufferWriting() throws Exception {_		testBufferWriting(new DefaultBufferResultSubpartitionView(1))__	};tests,link,partition,request,queue,buffer,writing,with,default,buffers;test,public,void,test,default,buffer,writing,throws,exception,test,buffer,writing,new,default,buffer,result,subpartition,view,1
PartitionRequestQueueTest -> @Test 	public void testDefaultBufferWriting() throws Exception;1522825145;Tests {@link PartitionRequestQueue} buffer writing with default buffers.;@Test_	public void testDefaultBufferWriting() throws Exception {_		testBufferWriting(new DefaultBufferResultSubpartitionView(1))__	};tests,link,partition,request,queue,buffer,writing,with,default,buffers;test,public,void,test,default,buffer,writing,throws,exception,test,buffer,writing,new,default,buffer,result,subpartition,view,1
PartitionRequestQueueTest -> @Test 	public void testNotifyReaderNonEmptyOnEmptyReaders() throws Exception;1519039301;In case of enqueuing an empty reader and a reader that actually has some buffers when channel is not writable,_on channelWritability change event should result in reading all of the messages.;@Test_	public void testNotifyReaderNonEmptyOnEmptyReaders() throws Exception {_		final int buffersToWrite = 5__		PartitionRequestQueue queue = new PartitionRequestQueue()__		EmbeddedChannel channel = new EmbeddedChannel(queue)___		CreditBasedSequenceNumberingViewReader reader1 = new CreditBasedSequenceNumberingViewReader(new InputChannelID(0, 0), 10, queue)__		CreditBasedSequenceNumberingViewReader reader2 = new CreditBasedSequenceNumberingViewReader(new InputChannelID(1, 1), 10, queue)___		reader1.requestSubpartitionView((partitionId, index, availabilityListener) -> new NotReleasedResultSubpartitionView(), new ResultPartitionID(), 0)__		reader1.notifyDataAvailable()__		assertTrue(reader1.isAvailable())__		assertFalse(reader1.isRegisteredAsAvailable())___		channel.unsafe().outboundBuffer().setUserDefinedWritability(1, false)__		assertFalse(channel.isWritable())___		reader1.notifyDataAvailable()__		channel.runPendingTasks()___		reader2.notifyDataAvailable()__		reader2.requestSubpartitionView((partitionId, index, availabilityListener) -> new DefaultBufferResultSubpartitionView(buffersToWrite), new ResultPartitionID(), 0)__		assertTrue(reader2.isAvailable())__		assertFalse(reader2.isRegisteredAsAvailable())___		reader2.notifyDataAvailable()___		_		channel.unsafe().outboundBuffer().setUserDefinedWritability(1, true)__		channel.runPendingTasks()__		assertEquals(buffersToWrite, channel.outboundMessages().size())__	};in,case,of,enqueuing,an,empty,reader,and,a,reader,that,actually,has,some,buffers,when,channel,is,not,writable,on,channel,writability,change,event,should,result,in,reading,all,of,the,messages;test,public,void,test,notify,reader,non,empty,on,empty,readers,throws,exception,final,int,buffers,to,write,5,partition,request,queue,queue,new,partition,request,queue,embedded,channel,channel,new,embedded,channel,queue,credit,based,sequence,numbering,view,reader,reader1,new,credit,based,sequence,numbering,view,reader,new,input,channel,id,0,0,10,queue,credit,based,sequence,numbering,view,reader,reader2,new,credit,based,sequence,numbering,view,reader,new,input,channel,id,1,1,10,queue,reader1,request,subpartition,view,partition,id,index,availability,listener,new,not,released,result,subpartition,view,new,result,partition,id,0,reader1,notify,data,available,assert,true,reader1,is,available,assert,false,reader1,is,registered,as,available,channel,unsafe,outbound,buffer,set,user,defined,writability,1,false,assert,false,channel,is,writable,reader1,notify,data,available,channel,run,pending,tasks,reader2,notify,data,available,reader2,request,subpartition,view,partition,id,index,availability,listener,new,default,buffer,result,subpartition,view,buffers,to,write,new,result,partition,id,0,assert,true,reader2,is,available,assert,false,reader2,is,registered,as,available,reader2,notify,data,available,channel,unsafe,outbound,buffer,set,user,defined,writability,1,true,channel,run,pending,tasks,assert,equals,buffers,to,write,channel,outbound,messages,size
PartitionRequestQueueTest -> @Test 	public void testNotifyReaderNonEmptyOnEmptyReaders() throws Exception;1519834372;In case of enqueuing an empty reader and a reader that actually has some buffers when channel is not writable,_on channelWritability change event should result in reading all of the messages.;@Test_	public void testNotifyReaderNonEmptyOnEmptyReaders() throws Exception {_		final int buffersToWrite = 5__		PartitionRequestQueue queue = new PartitionRequestQueue()__		EmbeddedChannel channel = new EmbeddedChannel(queue)___		CreditBasedSequenceNumberingViewReader reader1 = new CreditBasedSequenceNumberingViewReader(new InputChannelID(0, 0), 10, queue)__		CreditBasedSequenceNumberingViewReader reader2 = new CreditBasedSequenceNumberingViewReader(new InputChannelID(1, 1), 10, queue)___		reader1.requestSubpartitionView((partitionId, index, availabilityListener) -> new EmptyAlwaysAvailableResultSubpartitionView(), new ResultPartitionID(), 0)__		reader1.notifyDataAvailable()__		assertTrue(reader1.isAvailable())__		assertFalse(reader1.isRegisteredAsAvailable())___		channel.unsafe().outboundBuffer().setUserDefinedWritability(1, false)__		assertFalse(channel.isWritable())___		reader1.notifyDataAvailable()__		channel.runPendingTasks()___		reader2.notifyDataAvailable()__		reader2.requestSubpartitionView((partitionId, index, availabilityListener) -> new DefaultBufferResultSubpartitionView(buffersToWrite), new ResultPartitionID(), 0)__		assertTrue(reader2.isAvailable())__		assertFalse(reader2.isRegisteredAsAvailable())___		reader2.notifyDataAvailable()___		_		channel.unsafe().outboundBuffer().setUserDefinedWritability(1, true)__		channel.runPendingTasks()__		assertEquals(buffersToWrite, channel.outboundMessages().size())__	};in,case,of,enqueuing,an,empty,reader,and,a,reader,that,actually,has,some,buffers,when,channel,is,not,writable,on,channel,writability,change,event,should,result,in,reading,all,of,the,messages;test,public,void,test,notify,reader,non,empty,on,empty,readers,throws,exception,final,int,buffers,to,write,5,partition,request,queue,queue,new,partition,request,queue,embedded,channel,channel,new,embedded,channel,queue,credit,based,sequence,numbering,view,reader,reader1,new,credit,based,sequence,numbering,view,reader,new,input,channel,id,0,0,10,queue,credit,based,sequence,numbering,view,reader,reader2,new,credit,based,sequence,numbering,view,reader,new,input,channel,id,1,1,10,queue,reader1,request,subpartition,view,partition,id,index,availability,listener,new,empty,always,available,result,subpartition,view,new,result,partition,id,0,reader1,notify,data,available,assert,true,reader1,is,available,assert,false,reader1,is,registered,as,available,channel,unsafe,outbound,buffer,set,user,defined,writability,1,false,assert,false,channel,is,writable,reader1,notify,data,available,channel,run,pending,tasks,reader2,notify,data,available,reader2,request,subpartition,view,partition,id,index,availability,listener,new,default,buffer,result,subpartition,view,buffers,to,write,new,result,partition,id,0,assert,true,reader2,is,available,assert,false,reader2,is,registered,as,available,reader2,notify,data,available,channel,unsafe,outbound,buffer,set,user,defined,writability,1,true,channel,run,pending,tasks,assert,equals,buffers,to,write,channel,outbound,messages,size
PartitionRequestQueueTest -> @Test 	public void testNotifyReaderNonEmptyOnEmptyReaders() throws Exception;1522825145;In case of enqueuing an empty reader and a reader that actually has some buffers when channel is not writable,_on channelWritability change event should result in reading all of the messages.;@Test_	public void testNotifyReaderNonEmptyOnEmptyReaders() throws Exception {_		final int buffersToWrite = 5__		PartitionRequestQueue queue = new PartitionRequestQueue()__		EmbeddedChannel channel = new EmbeddedChannel(queue)___		CreditBasedSequenceNumberingViewReader reader1 = new CreditBasedSequenceNumberingViewReader(new InputChannelID(0, 0), 10, queue)__		CreditBasedSequenceNumberingViewReader reader2 = new CreditBasedSequenceNumberingViewReader(new InputChannelID(1, 1), 10, queue)___		reader1.requestSubpartitionView((partitionId, index, availabilityListener) -> new EmptyAlwaysAvailableResultSubpartitionView(), new ResultPartitionID(), 0)__		reader1.notifyDataAvailable()__		assertTrue(reader1.isAvailable())__		assertFalse(reader1.isRegisteredAsAvailable())___		channel.unsafe().outboundBuffer().setUserDefinedWritability(1, false)__		assertFalse(channel.isWritable())___		reader1.notifyDataAvailable()__		channel.runPendingTasks()___		reader2.notifyDataAvailable()__		reader2.requestSubpartitionView((partitionId, index, availabilityListener) -> new DefaultBufferResultSubpartitionView(buffersToWrite), new ResultPartitionID(), 0)__		assertTrue(reader2.isAvailable())__		assertFalse(reader2.isRegisteredAsAvailable())___		reader2.notifyDataAvailable()___		_		channel.unsafe().outboundBuffer().setUserDefinedWritability(1, true)__		channel.runPendingTasks()__		assertEquals(buffersToWrite, channel.outboundMessages().size())__	};in,case,of,enqueuing,an,empty,reader,and,a,reader,that,actually,has,some,buffers,when,channel,is,not,writable,on,channel,writability,change,event,should,result,in,reading,all,of,the,messages;test,public,void,test,notify,reader,non,empty,on,empty,readers,throws,exception,final,int,buffers,to,write,5,partition,request,queue,queue,new,partition,request,queue,embedded,channel,channel,new,embedded,channel,queue,credit,based,sequence,numbering,view,reader,reader1,new,credit,based,sequence,numbering,view,reader,new,input,channel,id,0,0,10,queue,credit,based,sequence,numbering,view,reader,reader2,new,credit,based,sequence,numbering,view,reader,new,input,channel,id,1,1,10,queue,reader1,request,subpartition,view,partition,id,index,availability,listener,new,empty,always,available,result,subpartition,view,new,result,partition,id,0,reader1,notify,data,available,assert,true,reader1,is,available,assert,false,reader1,is,registered,as,available,channel,unsafe,outbound,buffer,set,user,defined,writability,1,false,assert,false,channel,is,writable,reader1,notify,data,available,channel,run,pending,tasks,reader2,notify,data,available,reader2,request,subpartition,view,partition,id,index,availability,listener,new,default,buffer,result,subpartition,view,buffers,to,write,new,result,partition,id,0,assert,true,reader2,is,available,assert,false,reader2,is,registered,as,available,reader2,notify,data,available,channel,unsafe,outbound,buffer,set,user,defined,writability,1,true,channel,run,pending,tasks,assert,equals,buffers,to,write,channel,outbound,messages,size
PartitionRequestQueueTest -> @Test 	public void testEnqueueReaderByNotifyingEventBuffer() throws Exception;1518785736;Tests {@link PartitionRequestQueue#enqueueAvailableReader(SequenceNumberingViewReader)},_verifying the reader would be enqueued in the pipeline if the next sending buffer is an event_even though it has no available credits.;@Test_	public void testEnqueueReaderByNotifyingEventBuffer() throws Exception {_		_		final ResultSubpartitionView view = new NextIsEventResultSubpartitionView()___		ResultPartitionProvider partitionProvider =_			(partitionId, index, availabilityListener) -> view___		final InputChannelID receiverId = new InputChannelID()__		final PartitionRequestQueue queue = new PartitionRequestQueue()__		final SequenceNumberingViewReader reader = new SequenceNumberingViewReader(receiverId, 0, queue)__		final EmbeddedChannel channel = new EmbeddedChannel(queue)___		reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0)___		_		ByteBuf channelBlockingBuffer = blockChannel(channel)__		assertNull(channel.readOutbound())___		_		reader.notifyBuffersAvailable(1)___		channel.runPendingTasks()___		_		assertThat(queue.getAvailableReaders(), contains(reader))_ _		assertEquals(0, reader.getNumCreditsAvailable())___		_		channel.flush()__		assertSame(channelBlockingBuffer, channel.readOutbound())___		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(0, reader.getNumCreditsAvailable())__		assertNull(channel.readOutbound())__	};tests,link,partition,request,queue,enqueue,available,reader,sequence,numbering,view,reader,verifying,the,reader,would,be,enqueued,in,the,pipeline,if,the,next,sending,buffer,is,an,event,even,though,it,has,no,available,credits;test,public,void,test,enqueue,reader,by,notifying,event,buffer,throws,exception,final,result,subpartition,view,view,new,next,is,event,result,subpartition,view,result,partition,provider,partition,provider,partition,id,index,availability,listener,view,final,input,channel,id,receiver,id,new,input,channel,id,final,partition,request,queue,queue,new,partition,request,queue,final,sequence,numbering,view,reader,reader,new,sequence,numbering,view,reader,receiver,id,0,queue,final,embedded,channel,channel,new,embedded,channel,queue,reader,request,subpartition,view,partition,provider,new,result,partition,id,0,byte,buf,channel,blocking,buffer,block,channel,channel,assert,null,channel,read,outbound,reader,notify,buffers,available,1,channel,run,pending,tasks,assert,that,queue,get,available,readers,contains,reader,assert,equals,0,reader,get,num,credits,available,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,assert,equals,0,queue,get,available,readers,size,assert,equals,0,reader,get,num,credits,available,assert,null,channel,read,outbound
PartitionRequestQueueTest -> @Test 	public void testEnqueueReaderByNotifyingEventBuffer() throws Exception;1518785736;Tests {@link PartitionRequestQueue#enqueueAvailableReader(NetworkSequenceViewReader)},_verifying the reader would be enqueued in the pipeline if the next sending buffer is an event_even though it has no available credits.;@Test_	public void testEnqueueReaderByNotifyingEventBuffer() throws Exception {_		_		final ResultSubpartitionView view = new NextIsEventResultSubpartitionView()___		ResultPartitionProvider partitionProvider =_			(partitionId, index, availabilityListener) -> view___		final InputChannelID receiverId = new InputChannelID()__		final PartitionRequestQueue queue = new PartitionRequestQueue()__		final CreditBasedSequenceNumberingViewReader reader = new CreditBasedSequenceNumberingViewReader(receiverId, 0, queue)__		final EmbeddedChannel channel = new EmbeddedChannel(queue)___		reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0)___		_		ByteBuf channelBlockingBuffer = blockChannel(channel)__		assertNull(channel.readOutbound())___		_		reader.notifyBuffersAvailable(1)___		channel.runPendingTasks()___		_		assertThat(queue.getAvailableReaders(), contains(reader))_ _		assertEquals(0, reader.getNumCreditsAvailable())___		_		channel.flush()__		assertSame(channelBlockingBuffer, channel.readOutbound())___		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(0, reader.getNumCreditsAvailable())__		assertNull(channel.readOutbound())__	};tests,link,partition,request,queue,enqueue,available,reader,network,sequence,view,reader,verifying,the,reader,would,be,enqueued,in,the,pipeline,if,the,next,sending,buffer,is,an,event,even,though,it,has,no,available,credits;test,public,void,test,enqueue,reader,by,notifying,event,buffer,throws,exception,final,result,subpartition,view,view,new,next,is,event,result,subpartition,view,result,partition,provider,partition,provider,partition,id,index,availability,listener,view,final,input,channel,id,receiver,id,new,input,channel,id,final,partition,request,queue,queue,new,partition,request,queue,final,credit,based,sequence,numbering,view,reader,reader,new,credit,based,sequence,numbering,view,reader,receiver,id,0,queue,final,embedded,channel,channel,new,embedded,channel,queue,reader,request,subpartition,view,partition,provider,new,result,partition,id,0,byte,buf,channel,blocking,buffer,block,channel,channel,assert,null,channel,read,outbound,reader,notify,buffers,available,1,channel,run,pending,tasks,assert,that,queue,get,available,readers,contains,reader,assert,equals,0,reader,get,num,credits,available,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,assert,equals,0,queue,get,available,readers,size,assert,equals,0,reader,get,num,credits,available,assert,null,channel,read,outbound
PartitionRequestQueueTest -> @Test 	public void testEnqueueReaderByNotifyingEventBuffer() throws Exception;1519039301;Tests {@link PartitionRequestQueue#enqueueAvailableReader(NetworkSequenceViewReader)},_verifying the reader would be enqueued in the pipeline if the next sending buffer is an event_even though it has no available credits.;@Test_	public void testEnqueueReaderByNotifyingEventBuffer() throws Exception {_		_		final ResultSubpartitionView view = new NextIsEventResultSubpartitionView()___		ResultPartitionProvider partitionProvider =_			(partitionId, index, availabilityListener) -> view___		final InputChannelID receiverId = new InputChannelID()__		final PartitionRequestQueue queue = new PartitionRequestQueue()__		final CreditBasedSequenceNumberingViewReader reader = new CreditBasedSequenceNumberingViewReader(receiverId, 0, queue)__		final EmbeddedChannel channel = new EmbeddedChannel(queue)___		reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0)___		_		ByteBuf channelBlockingBuffer = blockChannel(channel)__		assertNull(channel.readOutbound())___		_		reader.notifyDataAvailable()___		channel.runPendingTasks()___		_		assertThat(queue.getAvailableReaders(), contains(reader))_ _		assertEquals(0, reader.getNumCreditsAvailable())___		_		channel.flush()__		assertSame(channelBlockingBuffer, channel.readOutbound())___		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(0, reader.getNumCreditsAvailable())__		assertNull(channel.readOutbound())__	};tests,link,partition,request,queue,enqueue,available,reader,network,sequence,view,reader,verifying,the,reader,would,be,enqueued,in,the,pipeline,if,the,next,sending,buffer,is,an,event,even,though,it,has,no,available,credits;test,public,void,test,enqueue,reader,by,notifying,event,buffer,throws,exception,final,result,subpartition,view,view,new,next,is,event,result,subpartition,view,result,partition,provider,partition,provider,partition,id,index,availability,listener,view,final,input,channel,id,receiver,id,new,input,channel,id,final,partition,request,queue,queue,new,partition,request,queue,final,credit,based,sequence,numbering,view,reader,reader,new,credit,based,sequence,numbering,view,reader,receiver,id,0,queue,final,embedded,channel,channel,new,embedded,channel,queue,reader,request,subpartition,view,partition,provider,new,result,partition,id,0,byte,buf,channel,blocking,buffer,block,channel,channel,assert,null,channel,read,outbound,reader,notify,data,available,channel,run,pending,tasks,assert,that,queue,get,available,readers,contains,reader,assert,equals,0,reader,get,num,credits,available,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,assert,equals,0,queue,get,available,readers,size,assert,equals,0,reader,get,num,credits,available,assert,null,channel,read,outbound
PartitionRequestQueueTest -> @Test 	public void testEnqueueReaderByNotifyingEventBuffer() throws Exception;1519834372;Tests {@link PartitionRequestQueue#enqueueAvailableReader(NetworkSequenceViewReader)},_verifying the reader would be enqueued in the pipeline if the next sending buffer is an event_even though it has no available credits.;@Test_	public void testEnqueueReaderByNotifyingEventBuffer() throws Exception {_		_		final ResultSubpartitionView view = new NextIsEventResultSubpartitionView()___		ResultPartitionProvider partitionProvider =_			(partitionId, index, availabilityListener) -> view___		final InputChannelID receiverId = new InputChannelID()__		final PartitionRequestQueue queue = new PartitionRequestQueue()__		final CreditBasedSequenceNumberingViewReader reader = new CreditBasedSequenceNumberingViewReader(receiverId, 0, queue)__		final EmbeddedChannel channel = new EmbeddedChannel(queue)___		reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0)___		_		ByteBuf channelBlockingBuffer = blockChannel(channel)__		assertNull(channel.readOutbound())___		_		reader.notifyDataAvailable()___		channel.runPendingTasks()___		_		assertThat(queue.getAvailableReaders(), contains(reader))_ _		assertEquals(0, reader.getNumCreditsAvailable())___		_		channel.flush()__		assertSame(channelBlockingBuffer, channel.readOutbound())___		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(0, reader.getNumCreditsAvailable())__		assertNull(channel.readOutbound())__	};tests,link,partition,request,queue,enqueue,available,reader,network,sequence,view,reader,verifying,the,reader,would,be,enqueued,in,the,pipeline,if,the,next,sending,buffer,is,an,event,even,though,it,has,no,available,credits;test,public,void,test,enqueue,reader,by,notifying,event,buffer,throws,exception,final,result,subpartition,view,view,new,next,is,event,result,subpartition,view,result,partition,provider,partition,provider,partition,id,index,availability,listener,view,final,input,channel,id,receiver,id,new,input,channel,id,final,partition,request,queue,queue,new,partition,request,queue,final,credit,based,sequence,numbering,view,reader,reader,new,credit,based,sequence,numbering,view,reader,receiver,id,0,queue,final,embedded,channel,channel,new,embedded,channel,queue,reader,request,subpartition,view,partition,provider,new,result,partition,id,0,byte,buf,channel,blocking,buffer,block,channel,channel,assert,null,channel,read,outbound,reader,notify,data,available,channel,run,pending,tasks,assert,that,queue,get,available,readers,contains,reader,assert,equals,0,reader,get,num,credits,available,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,assert,equals,0,queue,get,available,readers,size,assert,equals,0,reader,get,num,credits,available,assert,null,channel,read,outbound
PartitionRequestQueueTest -> @Test 	public void testEnqueueReaderByNotifyingEventBuffer() throws Exception;1522825145;Tests {@link PartitionRequestQueue#enqueueAvailableReader(NetworkSequenceViewReader)},_verifying the reader would be enqueued in the pipeline if the next sending buffer is an event_even though it has no available credits.;@Test_	public void testEnqueueReaderByNotifyingEventBuffer() throws Exception {_		_		final ResultSubpartitionView view = new NextIsEventResultSubpartitionView()___		ResultPartitionProvider partitionProvider =_			(partitionId, index, availabilityListener) -> view___		final InputChannelID receiverId = new InputChannelID()__		final PartitionRequestQueue queue = new PartitionRequestQueue()__		final CreditBasedSequenceNumberingViewReader reader = new CreditBasedSequenceNumberingViewReader(receiverId, 0, queue)__		final EmbeddedChannel channel = new EmbeddedChannel(queue)___		reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0)___		_		ByteBuf channelBlockingBuffer = blockChannel(channel)__		assertNull(channel.readOutbound())___		_		reader.notifyDataAvailable()___		channel.runPendingTasks()___		_		assertThat(queue.getAvailableReaders(), contains(reader))_ _		assertEquals(0, reader.getNumCreditsAvailable())___		_		channel.flush()__		assertSame(channelBlockingBuffer, channel.readOutbound())___		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(0, reader.getNumCreditsAvailable())__		assertNull(channel.readOutbound())__	};tests,link,partition,request,queue,enqueue,available,reader,network,sequence,view,reader,verifying,the,reader,would,be,enqueued,in,the,pipeline,if,the,next,sending,buffer,is,an,event,even,though,it,has,no,available,credits;test,public,void,test,enqueue,reader,by,notifying,event,buffer,throws,exception,final,result,subpartition,view,view,new,next,is,event,result,subpartition,view,result,partition,provider,partition,provider,partition,id,index,availability,listener,view,final,input,channel,id,receiver,id,new,input,channel,id,final,partition,request,queue,queue,new,partition,request,queue,final,credit,based,sequence,numbering,view,reader,reader,new,credit,based,sequence,numbering,view,reader,receiver,id,0,queue,final,embedded,channel,channel,new,embedded,channel,queue,reader,request,subpartition,view,partition,provider,new,result,partition,id,0,byte,buf,channel,blocking,buffer,block,channel,channel,assert,null,channel,read,outbound,reader,notify,data,available,channel,run,pending,tasks,assert,that,queue,get,available,readers,contains,reader,assert,equals,0,reader,get,num,credits,available,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,assert,equals,0,queue,get,available,readers,size,assert,equals,0,reader,get,num,credits,available,assert,null,channel,read,outbound
PartitionRequestQueueTest -> static ByteBuf blockChannel(EmbeddedChannel channel);1518785736;Blocks the given channel by adding a buffer that is bigger than the high watermark.__<p>The channel may be unblocked with:_<pre>_channel.flush()__assertSame(channelBlockingBuffer, channel.readOutbound())__</pre>__@param channel the channel to block_@return the created blocking buffer;static ByteBuf blockChannel(EmbeddedChannel channel) {_		final int highWaterMark = channel.config().getWriteBufferHighWaterMark()__		_		_		ByteBuf channelBlockingBuffer = Unpooled.buffer(highWaterMark).writerIndex(highWaterMark)__		channel.write(channelBlockingBuffer)__		assertFalse(channel.isWritable())___		return channelBlockingBuffer__	};blocks,the,given,channel,by,adding,a,buffer,that,is,bigger,than,the,high,watermark,p,the,channel,may,be,unblocked,with,pre,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,pre,param,channel,the,channel,to,block,return,the,created,blocking,buffer;static,byte,buf,block,channel,embedded,channel,channel,final,int,high,water,mark,channel,config,get,write,buffer,high,water,mark,byte,buf,channel,blocking,buffer,unpooled,buffer,high,water,mark,writer,index,high,water,mark,channel,write,channel,blocking,buffer,assert,false,channel,is,writable,return,channel,blocking,buffer
PartitionRequestQueueTest -> static ByteBuf blockChannel(EmbeddedChannel channel);1518785736;Blocks the given channel by adding a buffer that is bigger than the high watermark.__<p>The channel may be unblocked with:_<pre>_channel.flush()__assertSame(channelBlockingBuffer, channel.readOutbound())__</pre>__@param channel the channel to block_@return the created blocking buffer;static ByteBuf blockChannel(EmbeddedChannel channel) {_		final int highWaterMark = channel.config().getWriteBufferHighWaterMark()__		_		_		ByteBuf channelBlockingBuffer = Unpooled.buffer(highWaterMark).writerIndex(highWaterMark)__		channel.write(channelBlockingBuffer)__		assertFalse(channel.isWritable())___		return channelBlockingBuffer__	};blocks,the,given,channel,by,adding,a,buffer,that,is,bigger,than,the,high,watermark,p,the,channel,may,be,unblocked,with,pre,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,pre,param,channel,the,channel,to,block,return,the,created,blocking,buffer;static,byte,buf,block,channel,embedded,channel,channel,final,int,high,water,mark,channel,config,get,write,buffer,high,water,mark,byte,buf,channel,blocking,buffer,unpooled,buffer,high,water,mark,writer,index,high,water,mark,channel,write,channel,blocking,buffer,assert,false,channel,is,writable,return,channel,blocking,buffer
PartitionRequestQueueTest -> static ByteBuf blockChannel(EmbeddedChannel channel);1519039301;Blocks the given channel by adding a buffer that is bigger than the high watermark.__<p>The channel may be unblocked with:_<pre>_channel.flush()__assertSame(channelBlockingBuffer, channel.readOutbound())__</pre>__@param channel the channel to block_@return the created blocking buffer;static ByteBuf blockChannel(EmbeddedChannel channel) {_		final int highWaterMark = channel.config().getWriteBufferHighWaterMark()__		_		_		ByteBuf channelBlockingBuffer = Unpooled.buffer(highWaterMark).writerIndex(highWaterMark)__		channel.write(channelBlockingBuffer)__		assertFalse(channel.isWritable())___		return channelBlockingBuffer__	};blocks,the,given,channel,by,adding,a,buffer,that,is,bigger,than,the,high,watermark,p,the,channel,may,be,unblocked,with,pre,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,pre,param,channel,the,channel,to,block,return,the,created,blocking,buffer;static,byte,buf,block,channel,embedded,channel,channel,final,int,high,water,mark,channel,config,get,write,buffer,high,water,mark,byte,buf,channel,blocking,buffer,unpooled,buffer,high,water,mark,writer,index,high,water,mark,channel,write,channel,blocking,buffer,assert,false,channel,is,writable,return,channel,blocking,buffer
PartitionRequestQueueTest -> static ByteBuf blockChannel(EmbeddedChannel channel);1519834372;Blocks the given channel by adding a buffer that is bigger than the high watermark.__<p>The channel may be unblocked with:_<pre>_channel.flush()__assertSame(channelBlockingBuffer, channel.readOutbound())__</pre>__@param channel the channel to block_@return the created blocking buffer;static ByteBuf blockChannel(EmbeddedChannel channel) {_		final int highWaterMark = channel.config().getWriteBufferHighWaterMark()__		_		_		ByteBuf channelBlockingBuffer = Unpooled.buffer(highWaterMark).writerIndex(highWaterMark)__		channel.write(channelBlockingBuffer)__		assertFalse(channel.isWritable())___		return channelBlockingBuffer__	};blocks,the,given,channel,by,adding,a,buffer,that,is,bigger,than,the,high,watermark,p,the,channel,may,be,unblocked,with,pre,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,pre,param,channel,the,channel,to,block,return,the,created,blocking,buffer;static,byte,buf,block,channel,embedded,channel,channel,final,int,high,water,mark,channel,config,get,write,buffer,high,water,mark,byte,buf,channel,blocking,buffer,unpooled,buffer,high,water,mark,writer,index,high,water,mark,channel,write,channel,blocking,buffer,assert,false,channel,is,writable,return,channel,blocking,buffer
PartitionRequestQueueTest -> static ByteBuf blockChannel(EmbeddedChannel channel);1522825145;Blocks the given channel by adding a buffer that is bigger than the high watermark.__<p>The channel may be unblocked with:_<pre>_channel.flush()__assertSame(channelBlockingBuffer, channel.readOutbound())__</pre>__@param channel the channel to block_@return the created blocking buffer;static ByteBuf blockChannel(EmbeddedChannel channel) {_		final int highWaterMark = channel.config().getWriteBufferHighWaterMark()__		_		_		ByteBuf channelBlockingBuffer = Unpooled.buffer(highWaterMark).writerIndex(highWaterMark)__		channel.write(channelBlockingBuffer)__		assertFalse(channel.isWritable())___		return channelBlockingBuffer__	};blocks,the,given,channel,by,adding,a,buffer,that,is,bigger,than,the,high,watermark,p,the,channel,may,be,unblocked,with,pre,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,pre,param,channel,the,channel,to,block,return,the,created,blocking,buffer;static,byte,buf,block,channel,embedded,channel,channel,final,int,high,water,mark,channel,config,get,write,buffer,high,water,mark,byte,buf,channel,blocking,buffer,unpooled,buffer,high,water,mark,writer,index,high,water,mark,channel,write,channel,blocking,buffer,assert,false,channel,is,writable,return,channel,blocking,buffer
PartitionRequestQueueTest -> @Test 	public void testReadOnlyBufferWriting() throws Exception;1516291532;Tests {@link PartitionRequestQueue} buffer writing with read-only buffers.;@Test_	public void testReadOnlyBufferWriting() throws Exception {_		testBufferWriting(new ReadOnlyBufferResultSubpartitionView(2))__	};tests,link,partition,request,queue,buffer,writing,with,read,only,buffers;test,public,void,test,read,only,buffer,writing,throws,exception,test,buffer,writing,new,read,only,buffer,result,subpartition,view,2
PartitionRequestQueueTest -> @Test 	public void testReadOnlyBufferWriting() throws Exception;1518785736;Tests {@link PartitionRequestQueue} buffer writing with read-only buffers.;@Test_	public void testReadOnlyBufferWriting() throws Exception {_		testBufferWriting(new ReadOnlyBufferResultSubpartitionView(2))__	};tests,link,partition,request,queue,buffer,writing,with,read,only,buffers;test,public,void,test,read,only,buffer,writing,throws,exception,test,buffer,writing,new,read,only,buffer,result,subpartition,view,2
PartitionRequestQueueTest -> @Test 	public void testReadOnlyBufferWriting() throws Exception;1518785736;Tests {@link PartitionRequestQueue} buffer writing with read-only buffers.;@Test_	public void testReadOnlyBufferWriting() throws Exception {_		testBufferWriting(new ReadOnlyBufferResultSubpartitionView(2))__	};tests,link,partition,request,queue,buffer,writing,with,read,only,buffers;test,public,void,test,read,only,buffer,writing,throws,exception,test,buffer,writing,new,read,only,buffer,result,subpartition,view,2
PartitionRequestQueueTest -> @Test 	public void testReadOnlyBufferWriting() throws Exception;1519039301;Tests {@link PartitionRequestQueue} buffer writing with read-only buffers.;@Test_	public void testReadOnlyBufferWriting() throws Exception {_		testBufferWriting(new ReadOnlyBufferResultSubpartitionView(1))__	};tests,link,partition,request,queue,buffer,writing,with,read,only,buffers;test,public,void,test,read,only,buffer,writing,throws,exception,test,buffer,writing,new,read,only,buffer,result,subpartition,view,1
PartitionRequestQueueTest -> @Test 	public void testReadOnlyBufferWriting() throws Exception;1519834372;Tests {@link PartitionRequestQueue} buffer writing with read-only buffers.;@Test_	public void testReadOnlyBufferWriting() throws Exception {_		testBufferWriting(new ReadOnlyBufferResultSubpartitionView(1))__	};tests,link,partition,request,queue,buffer,writing,with,read,only,buffers;test,public,void,test,read,only,buffer,writing,throws,exception,test,buffer,writing,new,read,only,buffer,result,subpartition,view,1
PartitionRequestQueueTest -> @Test 	public void testReadOnlyBufferWriting() throws Exception;1522825145;Tests {@link PartitionRequestQueue} buffer writing with read-only buffers.;@Test_	public void testReadOnlyBufferWriting() throws Exception {_		testBufferWriting(new ReadOnlyBufferResultSubpartitionView(1))__	};tests,link,partition,request,queue,buffer,writing,with,read,only,buffers;test,public,void,test,read,only,buffer,writing,throws,exception,test,buffer,writing,new,read,only,buffer,result,subpartition,view,1
PartitionRequestQueueTest -> @Test 	public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception;1518785736;Tests {@link PartitionRequestQueue#enqueueAvailableReader(SequenceNumberingViewReader)},_verifying the reader would be enqueued in the pipeline iff it has both available credits and buffers.;@Test_	public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception {_		_		final ResultSubpartitionView view = new DefaultBufferResultSubpartitionView(2)___		ResultPartitionProvider partitionProvider =_			(partitionId, index, availabilityListener) -> view___		final InputChannelID receiverId = new InputChannelID()__		final PartitionRequestQueue queue = new PartitionRequestQueue()__		final SequenceNumberingViewReader reader = new SequenceNumberingViewReader(receiverId, 0, queue)__		final EmbeddedChannel channel = new EmbeddedChannel(queue)___		reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0)__		queue.notifyReaderCreated(reader)___		_		ByteBuf channelBlockingBuffer = blockChannel(channel)__		assertNull(channel.readOutbound())___		_		final int notifyNumBuffers = 5__		for (int i = 0_ i < notifyNumBuffers_ i++) {_			reader.notifyBuffersAvailable(1)__		}__		channel.runPendingTasks()___		_		_		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(notifyNumBuffers, reader.getNumBuffersAvailable())__		assertFalse(reader.isRegisteredAsAvailable())__		assertEquals(0, reader.getNumCreditsAvailable())___		_		final int notifyNumCredits = 3__		for (int i = 1_ i <= notifyNumCredits_ i++) {_			queue.addCredit(receiverId, 1)___			_			_			_			assertTrue(reader.isRegisteredAsAvailable())__			assertThat(queue.getAvailableReaders(), contains(reader))_ _			assertEquals(i, reader.getNumCreditsAvailable())__			assertEquals(notifyNumBuffers, reader.getNumBuffersAvailable())__		}__		_		channel.flush()__		assertSame(channelBlockingBuffer, channel.readOutbound())___		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(0, reader.getNumCreditsAvailable())__		assertEquals(notifyNumBuffers - notifyNumCredits, reader.getNumBuffersAvailable())__		assertFalse(reader.isRegisteredAsAvailable())__		for (int i = 1_ i <= notifyNumCredits_ i++) {_			assertThat(channel.readOutbound(), instanceOf(NettyMessage.BufferResponse.class))__		}_		assertNull(channel.readOutbound())__	};tests,link,partition,request,queue,enqueue,available,reader,sequence,numbering,view,reader,verifying,the,reader,would,be,enqueued,in,the,pipeline,iff,it,has,both,available,credits,and,buffers;test,public,void,test,enqueue,reader,by,notifying,buffer,and,credit,throws,exception,final,result,subpartition,view,view,new,default,buffer,result,subpartition,view,2,result,partition,provider,partition,provider,partition,id,index,availability,listener,view,final,input,channel,id,receiver,id,new,input,channel,id,final,partition,request,queue,queue,new,partition,request,queue,final,sequence,numbering,view,reader,reader,new,sequence,numbering,view,reader,receiver,id,0,queue,final,embedded,channel,channel,new,embedded,channel,queue,reader,request,subpartition,view,partition,provider,new,result,partition,id,0,queue,notify,reader,created,reader,byte,buf,channel,blocking,buffer,block,channel,channel,assert,null,channel,read,outbound,final,int,notify,num,buffers,5,for,int,i,0,i,notify,num,buffers,i,reader,notify,buffers,available,1,channel,run,pending,tasks,assert,equals,0,queue,get,available,readers,size,assert,equals,notify,num,buffers,reader,get,num,buffers,available,assert,false,reader,is,registered,as,available,assert,equals,0,reader,get,num,credits,available,final,int,notify,num,credits,3,for,int,i,1,i,notify,num,credits,i,queue,add,credit,receiver,id,1,assert,true,reader,is,registered,as,available,assert,that,queue,get,available,readers,contains,reader,assert,equals,i,reader,get,num,credits,available,assert,equals,notify,num,buffers,reader,get,num,buffers,available,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,assert,equals,0,queue,get,available,readers,size,assert,equals,0,reader,get,num,credits,available,assert,equals,notify,num,buffers,notify,num,credits,reader,get,num,buffers,available,assert,false,reader,is,registered,as,available,for,int,i,1,i,notify,num,credits,i,assert,that,channel,read,outbound,instance,of,netty,message,buffer,response,class,assert,null,channel,read,outbound
PartitionRequestQueueTest -> @Test 	public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception;1518785736;Tests {@link PartitionRequestQueue#enqueueAvailableReader(NetworkSequenceViewReader)},_verifying the reader would be enqueued in the pipeline iff it has both available credits and buffers.;@Test_	public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception {_		_		final ResultSubpartitionView view = new DefaultBufferResultSubpartitionView(2)___		ResultPartitionProvider partitionProvider =_			(partitionId, index, availabilityListener) -> view___		final InputChannelID receiverId = new InputChannelID()__		final PartitionRequestQueue queue = new PartitionRequestQueue()__		final CreditBasedSequenceNumberingViewReader reader = new CreditBasedSequenceNumberingViewReader(receiverId, 0, queue)__		final EmbeddedChannel channel = new EmbeddedChannel(queue)___		reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0)__		queue.notifyReaderCreated(reader)___		_		ByteBuf channelBlockingBuffer = blockChannel(channel)__		assertNull(channel.readOutbound())___		_		final int notifyNumBuffers = 5__		for (int i = 0_ i < notifyNumBuffers_ i++) {_			reader.notifyBuffersAvailable(1)__		}__		channel.runPendingTasks()___		_		_		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(notifyNumBuffers, reader.getNumBuffersAvailable())__		assertFalse(reader.isRegisteredAsAvailable())__		assertEquals(0, reader.getNumCreditsAvailable())___		_		final int notifyNumCredits = 3__		for (int i = 1_ i <= notifyNumCredits_ i++) {_			queue.addCredit(receiverId, 1)___			_			_			_			assertTrue(reader.isRegisteredAsAvailable())__			assertThat(queue.getAvailableReaders(), contains(reader))_ _			assertEquals(i, reader.getNumCreditsAvailable())__			assertEquals(notifyNumBuffers, reader.getNumBuffersAvailable())__		}__		_		channel.flush()__		assertSame(channelBlockingBuffer, channel.readOutbound())___		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(0, reader.getNumCreditsAvailable())__		assertEquals(notifyNumBuffers - notifyNumCredits, reader.getNumBuffersAvailable())__		assertFalse(reader.isRegisteredAsAvailable())__		for (int i = 1_ i <= notifyNumCredits_ i++) {_			assertThat(channel.readOutbound(), instanceOf(NettyMessage.BufferResponse.class))__		}_		assertNull(channel.readOutbound())__	};tests,link,partition,request,queue,enqueue,available,reader,network,sequence,view,reader,verifying,the,reader,would,be,enqueued,in,the,pipeline,iff,it,has,both,available,credits,and,buffers;test,public,void,test,enqueue,reader,by,notifying,buffer,and,credit,throws,exception,final,result,subpartition,view,view,new,default,buffer,result,subpartition,view,2,result,partition,provider,partition,provider,partition,id,index,availability,listener,view,final,input,channel,id,receiver,id,new,input,channel,id,final,partition,request,queue,queue,new,partition,request,queue,final,credit,based,sequence,numbering,view,reader,reader,new,credit,based,sequence,numbering,view,reader,receiver,id,0,queue,final,embedded,channel,channel,new,embedded,channel,queue,reader,request,subpartition,view,partition,provider,new,result,partition,id,0,queue,notify,reader,created,reader,byte,buf,channel,blocking,buffer,block,channel,channel,assert,null,channel,read,outbound,final,int,notify,num,buffers,5,for,int,i,0,i,notify,num,buffers,i,reader,notify,buffers,available,1,channel,run,pending,tasks,assert,equals,0,queue,get,available,readers,size,assert,equals,notify,num,buffers,reader,get,num,buffers,available,assert,false,reader,is,registered,as,available,assert,equals,0,reader,get,num,credits,available,final,int,notify,num,credits,3,for,int,i,1,i,notify,num,credits,i,queue,add,credit,receiver,id,1,assert,true,reader,is,registered,as,available,assert,that,queue,get,available,readers,contains,reader,assert,equals,i,reader,get,num,credits,available,assert,equals,notify,num,buffers,reader,get,num,buffers,available,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,assert,equals,0,queue,get,available,readers,size,assert,equals,0,reader,get,num,credits,available,assert,equals,notify,num,buffers,notify,num,credits,reader,get,num,buffers,available,assert,false,reader,is,registered,as,available,for,int,i,1,i,notify,num,credits,i,assert,that,channel,read,outbound,instance,of,netty,message,buffer,response,class,assert,null,channel,read,outbound
PartitionRequestQueueTest -> @Test 	public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception;1519039301;Tests {@link PartitionRequestQueue#enqueueAvailableReader(NetworkSequenceViewReader)},_verifying the reader would be enqueued in the pipeline iff it has both available credits and buffers.;@Test_	public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception {_		_		final ResultSubpartitionView view = new DefaultBufferResultSubpartitionView(10)___		ResultPartitionProvider partitionProvider =_			(partitionId, index, availabilityListener) -> view___		final InputChannelID receiverId = new InputChannelID()__		final PartitionRequestQueue queue = new PartitionRequestQueue()__		final CreditBasedSequenceNumberingViewReader reader = new CreditBasedSequenceNumberingViewReader(receiverId, 0, queue)__		final EmbeddedChannel channel = new EmbeddedChannel(queue)___		reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0)__		queue.notifyReaderCreated(reader)___		_		ByteBuf channelBlockingBuffer = blockChannel(channel)__		assertNull(channel.readOutbound())___		_		final int notifyNumBuffers = 5__		for (int i = 0_ i < notifyNumBuffers_ i++) {_			reader.notifyDataAvailable()__		}__		channel.runPendingTasks()___		_		_		assertEquals(0, queue.getAvailableReaders().size())__		assertTrue(reader.hasBuffersAvailable())__		assertFalse(reader.isRegisteredAsAvailable())__		assertEquals(0, reader.getNumCreditsAvailable())___		_		final int notifyNumCredits = 3__		for (int i = 1_ i <= notifyNumCredits_ i++) {_			queue.addCredit(receiverId, 1)___			_			_			_			assertTrue(reader.isRegisteredAsAvailable())__			assertThat(queue.getAvailableReaders(), contains(reader))_ _			assertEquals(i, reader.getNumCreditsAvailable())__			assertTrue(reader.hasBuffersAvailable())__		}__		_		channel.flush()__		assertSame(channelBlockingBuffer, channel.readOutbound())___		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(0, reader.getNumCreditsAvailable())__		assertTrue(reader.hasBuffersAvailable())__		assertFalse(reader.isRegisteredAsAvailable())__		for (int i = 1_ i <= notifyNumCredits_ i++) {_			assertThat(channel.readOutbound(), instanceOf(NettyMessage.BufferResponse.class))__		}_		assertNull(channel.readOutbound())__	};tests,link,partition,request,queue,enqueue,available,reader,network,sequence,view,reader,verifying,the,reader,would,be,enqueued,in,the,pipeline,iff,it,has,both,available,credits,and,buffers;test,public,void,test,enqueue,reader,by,notifying,buffer,and,credit,throws,exception,final,result,subpartition,view,view,new,default,buffer,result,subpartition,view,10,result,partition,provider,partition,provider,partition,id,index,availability,listener,view,final,input,channel,id,receiver,id,new,input,channel,id,final,partition,request,queue,queue,new,partition,request,queue,final,credit,based,sequence,numbering,view,reader,reader,new,credit,based,sequence,numbering,view,reader,receiver,id,0,queue,final,embedded,channel,channel,new,embedded,channel,queue,reader,request,subpartition,view,partition,provider,new,result,partition,id,0,queue,notify,reader,created,reader,byte,buf,channel,blocking,buffer,block,channel,channel,assert,null,channel,read,outbound,final,int,notify,num,buffers,5,for,int,i,0,i,notify,num,buffers,i,reader,notify,data,available,channel,run,pending,tasks,assert,equals,0,queue,get,available,readers,size,assert,true,reader,has,buffers,available,assert,false,reader,is,registered,as,available,assert,equals,0,reader,get,num,credits,available,final,int,notify,num,credits,3,for,int,i,1,i,notify,num,credits,i,queue,add,credit,receiver,id,1,assert,true,reader,is,registered,as,available,assert,that,queue,get,available,readers,contains,reader,assert,equals,i,reader,get,num,credits,available,assert,true,reader,has,buffers,available,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,assert,equals,0,queue,get,available,readers,size,assert,equals,0,reader,get,num,credits,available,assert,true,reader,has,buffers,available,assert,false,reader,is,registered,as,available,for,int,i,1,i,notify,num,credits,i,assert,that,channel,read,outbound,instance,of,netty,message,buffer,response,class,assert,null,channel,read,outbound
PartitionRequestQueueTest -> @Test 	public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception;1519834372;Tests {@link PartitionRequestQueue#enqueueAvailableReader(NetworkSequenceViewReader)},_verifying the reader would be enqueued in the pipeline iff it has both available credits and buffers.;@Test_	public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception {_		_		final ResultSubpartitionView view = new DefaultBufferResultSubpartitionView(10)___		ResultPartitionProvider partitionProvider =_			(partitionId, index, availabilityListener) -> view___		final InputChannelID receiverId = new InputChannelID()__		final PartitionRequestQueue queue = new PartitionRequestQueue()__		final CreditBasedSequenceNumberingViewReader reader = new CreditBasedSequenceNumberingViewReader(receiverId, 0, queue)__		final EmbeddedChannel channel = new EmbeddedChannel(queue)___		reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0)__		queue.notifyReaderCreated(reader)___		_		ByteBuf channelBlockingBuffer = blockChannel(channel)__		assertNull(channel.readOutbound())___		_		final int notifyNumBuffers = 5__		for (int i = 0_ i < notifyNumBuffers_ i++) {_			reader.notifyDataAvailable()__		}__		channel.runPendingTasks()___		_		_		assertEquals(0, queue.getAvailableReaders().size())__		assertTrue(reader.hasBuffersAvailable())__		assertFalse(reader.isRegisteredAsAvailable())__		assertEquals(0, reader.getNumCreditsAvailable())___		_		final int notifyNumCredits = 3__		for (int i = 1_ i <= notifyNumCredits_ i++) {_			queue.addCredit(receiverId, 1)___			_			_			_			assertTrue(reader.isRegisteredAsAvailable())__			assertThat(queue.getAvailableReaders(), contains(reader))_ _			assertEquals(i, reader.getNumCreditsAvailable())__			assertTrue(reader.hasBuffersAvailable())__		}__		_		channel.flush()__		assertSame(channelBlockingBuffer, channel.readOutbound())___		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(0, reader.getNumCreditsAvailable())__		assertTrue(reader.hasBuffersAvailable())__		assertFalse(reader.isRegisteredAsAvailable())__		for (int i = 1_ i <= notifyNumCredits_ i++) {_			assertThat(channel.readOutbound(), instanceOf(NettyMessage.BufferResponse.class))__		}_		assertNull(channel.readOutbound())__	};tests,link,partition,request,queue,enqueue,available,reader,network,sequence,view,reader,verifying,the,reader,would,be,enqueued,in,the,pipeline,iff,it,has,both,available,credits,and,buffers;test,public,void,test,enqueue,reader,by,notifying,buffer,and,credit,throws,exception,final,result,subpartition,view,view,new,default,buffer,result,subpartition,view,10,result,partition,provider,partition,provider,partition,id,index,availability,listener,view,final,input,channel,id,receiver,id,new,input,channel,id,final,partition,request,queue,queue,new,partition,request,queue,final,credit,based,sequence,numbering,view,reader,reader,new,credit,based,sequence,numbering,view,reader,receiver,id,0,queue,final,embedded,channel,channel,new,embedded,channel,queue,reader,request,subpartition,view,partition,provider,new,result,partition,id,0,queue,notify,reader,created,reader,byte,buf,channel,blocking,buffer,block,channel,channel,assert,null,channel,read,outbound,final,int,notify,num,buffers,5,for,int,i,0,i,notify,num,buffers,i,reader,notify,data,available,channel,run,pending,tasks,assert,equals,0,queue,get,available,readers,size,assert,true,reader,has,buffers,available,assert,false,reader,is,registered,as,available,assert,equals,0,reader,get,num,credits,available,final,int,notify,num,credits,3,for,int,i,1,i,notify,num,credits,i,queue,add,credit,receiver,id,1,assert,true,reader,is,registered,as,available,assert,that,queue,get,available,readers,contains,reader,assert,equals,i,reader,get,num,credits,available,assert,true,reader,has,buffers,available,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,assert,equals,0,queue,get,available,readers,size,assert,equals,0,reader,get,num,credits,available,assert,true,reader,has,buffers,available,assert,false,reader,is,registered,as,available,for,int,i,1,i,notify,num,credits,i,assert,that,channel,read,outbound,instance,of,netty,message,buffer,response,class,assert,null,channel,read,outbound
PartitionRequestQueueTest -> @Test 	public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception;1522825145;Tests {@link PartitionRequestQueue#enqueueAvailableReader(NetworkSequenceViewReader)},_verifying the reader would be enqueued in the pipeline iff it has both available credits and buffers.;@Test_	public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception {_		_		final ResultSubpartitionView view = new DefaultBufferResultSubpartitionView(10)___		ResultPartitionProvider partitionProvider =_			(partitionId, index, availabilityListener) -> view___		final InputChannelID receiverId = new InputChannelID()__		final PartitionRequestQueue queue = new PartitionRequestQueue()__		final CreditBasedSequenceNumberingViewReader reader = new CreditBasedSequenceNumberingViewReader(receiverId, 0, queue)__		final EmbeddedChannel channel = new EmbeddedChannel(queue)___		reader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0)__		queue.notifyReaderCreated(reader)___		_		ByteBuf channelBlockingBuffer = blockChannel(channel)__		assertNull(channel.readOutbound())___		_		final int notifyNumBuffers = 5__		for (int i = 0_ i < notifyNumBuffers_ i++) {_			reader.notifyDataAvailable()__		}__		channel.runPendingTasks()___		_		_		assertEquals(0, queue.getAvailableReaders().size())__		assertTrue(reader.hasBuffersAvailable())__		assertFalse(reader.isRegisteredAsAvailable())__		assertEquals(0, reader.getNumCreditsAvailable())___		_		final int notifyNumCredits = 3__		for (int i = 1_ i <= notifyNumCredits_ i++) {_			queue.addCredit(receiverId, 1)___			_			_			_			assertTrue(reader.isRegisteredAsAvailable())__			assertThat(queue.getAvailableReaders(), contains(reader))_ _			assertEquals(i, reader.getNumCreditsAvailable())__			assertTrue(reader.hasBuffersAvailable())__		}__		_		channel.flush()__		assertSame(channelBlockingBuffer, channel.readOutbound())___		assertEquals(0, queue.getAvailableReaders().size())__		assertEquals(0, reader.getNumCreditsAvailable())__		assertTrue(reader.hasBuffersAvailable())__		assertFalse(reader.isRegisteredAsAvailable())__		for (int i = 1_ i <= notifyNumCredits_ i++) {_			assertThat(channel.readOutbound(), instanceOf(NettyMessage.BufferResponse.class))__		}_		assertNull(channel.readOutbound())__	};tests,link,partition,request,queue,enqueue,available,reader,network,sequence,view,reader,verifying,the,reader,would,be,enqueued,in,the,pipeline,iff,it,has,both,available,credits,and,buffers;test,public,void,test,enqueue,reader,by,notifying,buffer,and,credit,throws,exception,final,result,subpartition,view,view,new,default,buffer,result,subpartition,view,10,result,partition,provider,partition,provider,partition,id,index,availability,listener,view,final,input,channel,id,receiver,id,new,input,channel,id,final,partition,request,queue,queue,new,partition,request,queue,final,credit,based,sequence,numbering,view,reader,reader,new,credit,based,sequence,numbering,view,reader,receiver,id,0,queue,final,embedded,channel,channel,new,embedded,channel,queue,reader,request,subpartition,view,partition,provider,new,result,partition,id,0,queue,notify,reader,created,reader,byte,buf,channel,blocking,buffer,block,channel,channel,assert,null,channel,read,outbound,final,int,notify,num,buffers,5,for,int,i,0,i,notify,num,buffers,i,reader,notify,data,available,channel,run,pending,tasks,assert,equals,0,queue,get,available,readers,size,assert,true,reader,has,buffers,available,assert,false,reader,is,registered,as,available,assert,equals,0,reader,get,num,credits,available,final,int,notify,num,credits,3,for,int,i,1,i,notify,num,credits,i,queue,add,credit,receiver,id,1,assert,true,reader,is,registered,as,available,assert,that,queue,get,available,readers,contains,reader,assert,equals,i,reader,get,num,credits,available,assert,true,reader,has,buffers,available,channel,flush,assert,same,channel,blocking,buffer,channel,read,outbound,assert,equals,0,queue,get,available,readers,size,assert,equals,0,reader,get,num,credits,available,assert,true,reader,has,buffers,available,assert,false,reader,is,registered,as,available,for,int,i,1,i,notify,num,credits,i,assert,that,channel,read,outbound,instance,of,netty,message,buffer,response,class,assert,null,channel,read,outbound
