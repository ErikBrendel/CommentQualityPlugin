commented;modifiers;parameterAmount;loc;comment;code
false;;0;33;;void testNonConcurrentSnapshotTransformerAccess() throws Exception {     List<TestState> testStates = Arrays.asList(new TestValueState(), new TestListState(), new TestMapState()).     for (TestState state : testStates) {         for (int i = 0. i < 100. i++) {             backend.setCurrentKey(i).             state.setToRandomValue().         }         CheckpointOptions checkpointOptions = CheckpointOptions.forCheckpointWithDefaultLocation().         RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot1 = backend.snapshot(1L, 0L, streamFactory, checkpointOptions).         RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot2 = backend.snapshot(2L, 0L, streamFactory, checkpointOptions).         Thread runner1 = new Thread(snapshot1, "snapshot1").         runner1.start().         Thread runner2 = new Thread(snapshot2, "snapshot2").         runner2.start().         runner1.join().         runner2.join().         snapshot1.get().         snapshot2.get().     } }
false;abstract;0;1;;abstract void setToRandomValue() throws Exception.
false;;0;3;;String getRandomString() {     return StringUtils.getRandomString(rnd, 5, 10). }
false;;0;4;;@Override void setToRandomValue() throws Exception {     state.update(getRandomString()). }
false;;0;7;;@Override void setToRandomValue() throws Exception {     int length = rnd.nextInt(10).     for (int i = 0. i < length. i++) {         state.add(getRandomString()).     } }
false;;0;7;;@Override void setToRandomValue() throws Exception {     int length = rnd.nextInt(10).     for (int i = 0. i < length. i++) {         state.put(getRandomString(), getRandomString()).     } }
false;static;0;3;;static <T> StateSnapshotTransformFactory<T> create() {     return new SingleThreadAccessCheckingSnapshotTransformFactory<>(). }
false;public;0;5;;@Override public Optional<StateSnapshotTransformer<T>> createForDeserializedState() {     singleThreadAccessChecker.checkSingleThreadAccess().     return createStateSnapshotTransformer(). }
false;public;0;5;;@Override public Optional<StateSnapshotTransformer<byte[]>> createForSerializedState() {     singleThreadAccessChecker.checkSingleThreadAccess().     return createStateSnapshotTransformer(). }
false;public;1;6;;@Nullable @Override public T1 filterOrTransform(@Nullable T1 value) {     singleThreadAccessChecker.checkSingleThreadAccess().     return value. }
false;private;0;12;;private <T1> Optional<StateSnapshotTransformer<T1>> createStateSnapshotTransformer() {     return Optional.of(new StateSnapshotTransformer<T1>() {          private final SingleThreadAccessChecker singleThreadAccessChecker = new SingleThreadAccessChecker().          @Nullable         @Override         public T1 filterOrTransform(@Nullable T1 value) {             singleThreadAccessChecker.checkSingleThreadAccess().             return value.         }     }). }
false;;0;4;;void checkSingleThreadAccess() {     currentThreadRef.compareAndSet(null, Thread.currentThread()).     assert (Thread.currentThread().equals(currentThreadRef.get())) : "Concurrent access from another thread". }
