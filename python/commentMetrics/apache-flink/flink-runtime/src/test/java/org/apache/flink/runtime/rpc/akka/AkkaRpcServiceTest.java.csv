commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;5;;@BeforeClass public static void setup() {     actorSystem = AkkaUtils.createDefaultActorSystem().     akkaRpcService = new AkkaRpcService(actorSystem, AkkaRpcServiceConfiguration.defaultConfiguration()). }
false;public,static;0;12;;@AfterClass public static void shutdown() throws InterruptedException, ExecutionException, TimeoutException {     final CompletableFuture<Void> rpcTerminationFuture = akkaRpcService.stopService().     final CompletableFuture<Terminated> actorSystemTerminationFuture = FutureUtils.toJava(actorSystem.terminate()).     FutureUtils.waitForAll(Arrays.asList(rpcTerminationFuture, actorSystemTerminationFuture)).get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).     actorSystem = null.     akkaRpcService = null. }
false;public;0;15;;// ------------------------------------------------------------------------ // tests // ------------------------------------------------------------------------ @Test public void testScheduleRunnable() throws Exception {     final OneShotLatch latch = new OneShotLatch().     final long delay = 100L.     final long start = System.nanoTime().     ScheduledFuture<?> scheduledFuture = akkaRpcService.scheduleRunnable(latch::trigger, delay, TimeUnit.MILLISECONDS).     scheduledFuture.get().     assertTrue(latch.isTriggered()).     final long stop = System.nanoTime().     assertTrue("call was not properly delayed", ((stop - start) / 1000000) >= delay). }
true;public;0;8;/**  * Tests that the {@link AkkaRpcService} can execute runnables.  */ ;/**  * Tests that the {@link AkkaRpcService} can execute runnables.  */ @Test public void testExecuteRunnable() throws Exception {     final OneShotLatch latch = new OneShotLatch().     akkaRpcService.execute(latch::trigger).     latch.await(30L, TimeUnit.SECONDS). }
true;public;0;15;/**  * Tests that the {@link AkkaRpcService} can execute callables and returns their result as  * a {@link CompletableFuture}.  */ ;/**  * Tests that the {@link AkkaRpcService} can execute callables and returns their result as  * a {@link CompletableFuture}.  */ @Test public void testExecuteCallable() throws Exception {     final OneShotLatch latch = new OneShotLatch().     final int expected = 42.     CompletableFuture<Integer> result = akkaRpcService.execute(() -> {         latch.trigger().         return expected.     }).     int actual = result.get(30L, TimeUnit.SECONDS).     assertEquals(expected, actual).     assertTrue(latch.isTriggered()). }
false;public;0;4;;@Test public void testGetAddress() {     assertEquals(AkkaUtils.getAddress(actorSystem).host().get(), akkaRpcService.getAddress()). }
false;public;0;4;;@Test public void testGetPort() {     assertEquals(AkkaUtils.getAddress(actorSystem).port().get(), akkaRpcService.getPort()). }
true;public;0;12;/**  * Tests that we can wait for the termination of the rpc service.  */ ;/**  * Tests that we can wait for the termination of the rpc service.  */ @Test(timeout = 60000) public void testTerminationFuture() throws Exception {     final AkkaRpcService rpcService = startAkkaRpcService().     CompletableFuture<Void> terminationFuture = rpcService.getTerminationFuture().     assertFalse(terminationFuture.isDone()).     rpcService.stopService().     terminationFuture.get(). }
true;public;0;16;/**  * Tests a simple scheduled runnable being executed by the RPC services scheduled executor  * service.  */ ;/**  * Tests a simple scheduled runnable being executed by the RPC services scheduled executor  * service.  */ @Test(timeout = 60000) public void testScheduledExecutorServiceSimpleSchedule() throws Exception {     ScheduledExecutor scheduledExecutor = akkaRpcService.getScheduledExecutor().     final OneShotLatch latch = new OneShotLatch().     ScheduledFuture<?> future = scheduledExecutor.schedule(latch::trigger, 10L, TimeUnit.MILLISECONDS).     future.get().     // once the future is completed, then the latch should have been triggered     assertTrue(latch.isTriggered()). }
true;public;0;30;/**  * Tests that the RPC service's scheduled executor service can execute runnables at a fixed  * rate.  */ ;/**  * Tests that the RPC service's scheduled executor service can execute runnables at a fixed  * rate.  */ @Test(timeout = 60000) public void testScheduledExecutorServicePeriodicSchedule() throws Exception {     ScheduledExecutor scheduledExecutor = akkaRpcService.getScheduledExecutor().     final int tries = 4.     final long delay = 10L.     final CountDownLatch countDownLatch = new CountDownLatch(tries).     long currentTime = System.nanoTime().     ScheduledFuture<?> future = scheduledExecutor.scheduleAtFixedRate(countDownLatch::countDown, delay, delay, TimeUnit.MILLISECONDS).     assertTrue(!future.isDone()).     countDownLatch.await().     // the future should not complete since we have a periodic task     assertTrue(!future.isDone()).     long finalTime = System.nanoTime() - currentTime.     // the processing should have taken at least delay times the number of count downs.     assertTrue(finalTime >= tries * delay).     future.cancel(true). }
true;public;0;30;/**  * Tests that the RPC service's scheduled executor service can execute runnable with a fixed  * delay.  */ ;/**  * Tests that the RPC service's scheduled executor service can execute runnable with a fixed  * delay.  */ @Test(timeout = 60000) public void testScheduledExecutorServiceWithFixedDelaySchedule() throws Exception {     ScheduledExecutor scheduledExecutor = akkaRpcService.getScheduledExecutor().     final int tries = 4.     final long delay = 10L.     final CountDownLatch countDownLatch = new CountDownLatch(tries).     long currentTime = System.nanoTime().     ScheduledFuture<?> future = scheduledExecutor.scheduleWithFixedDelay(countDownLatch::countDown, delay, delay, TimeUnit.MILLISECONDS).     assertTrue(!future.isDone()).     countDownLatch.await().     // the future should not complete since we have a periodic task     assertTrue(!future.isDone()).     long finalTime = System.nanoTime() - currentTime.     // the processing should have taken at least delay times the number of count downs.     assertTrue(finalTime >= tries * delay).     future.cancel(true). }
true;public;0;43;/**  * Tests that canceling the returned future will stop the execution of the scheduled runnable.  */ ;/**  * Tests that canceling the returned future will stop the execution of the scheduled runnable.  */ @Test public void testScheduledExecutorServiceCancelWithFixedDelay() throws InterruptedException {     ScheduledExecutor scheduledExecutor = akkaRpcService.getScheduledExecutor().     long delay = 10L.     final OneShotLatch futureTask = new OneShotLatch().     final OneShotLatch latch = new OneShotLatch().     final OneShotLatch shouldNotBeTriggeredLatch = new OneShotLatch().     ScheduledFuture<?> future = scheduledExecutor.scheduleWithFixedDelay(() -> {         try {             if (futureTask.isTriggered()) {                 shouldNotBeTriggeredLatch.trigger().             } else {                 // first run                 futureTask.trigger().                 latch.await().             }         } catch (InterruptedException ignored) {         // ignore         }     }, delay, delay, TimeUnit.MILLISECONDS).     // wait until we're in the runnable     futureTask.await().     // cancel the scheduled future     future.cancel(false).     latch.trigger().     try {         shouldNotBeTriggeredLatch.await(5 * delay, TimeUnit.MILLISECONDS).         fail("The shouldNotBeTriggeredLatch should never be triggered.").     } catch (TimeoutException e) {     // expected     } }
true;public;0;21;/**  * Tests that the {@link AkkaRpcService} terminates all its RpcEndpoints when shutting down.  */ ;/**  * Tests that the {@link AkkaRpcService} terminates all its RpcEndpoints when shutting down.  */ @Test public void testAkkaRpcServiceShutDownWithRpcEndpoints() throws Exception {     final AkkaRpcService akkaRpcService = startAkkaRpcService().     try {         final int numberActors = 5.         CompletableFuture<Void> terminationFuture = akkaRpcService.getTerminationFuture().         final Collection<CompletableFuture<Void>> onStopFutures = startStopNCountingAsynchronousOnStopEndpoints(akkaRpcService, numberActors).         for (CompletableFuture<Void> onStopFuture : onStopFutures) {             onStopFuture.complete(null).         }         terminationFuture.get().         assertThat(akkaRpcService.getActorSystem().isTerminated(), is(true)).     } finally {         RpcUtils.terminateRpcService(akkaRpcService, TIMEOUT).     } }
true;public;0;31;/**  * Tests that {@link AkkaRpcService} terminates all its RpcEndpoints and also stops  * the underlying {@link ActorSystem} if one of the RpcEndpoints fails while stopping.  */ ;/**  * Tests that {@link AkkaRpcService} terminates all its RpcEndpoints and also stops  * the underlying {@link ActorSystem} if one of the RpcEndpoints fails while stopping.  */ @Test public void testAkkaRpcServiceShutDownWithFailingRpcEndpoints() throws Exception {     final AkkaRpcService akkaRpcService = startAkkaRpcService().     final int numberActors = 5.     CompletableFuture<Void> terminationFuture = akkaRpcService.getTerminationFuture().     final Collection<CompletableFuture<Void>> onStopFutures = startStopNCountingAsynchronousOnStopEndpoints(akkaRpcService, numberActors).     Iterator<CompletableFuture<Void>> iterator = onStopFutures.iterator().     for (int i = 0. i < numberActors - 1. i++) {         iterator.next().complete(null).     }     iterator.next().completeExceptionally(new OnStopException("onStop exception occurred.")).     for (CompletableFuture<Void> onStopFuture : onStopFutures) {         onStopFuture.complete(null).     }     try {         terminationFuture.get().         fail("Expected the termination future to complete exceptionally.").     } catch (ExecutionException e) {         assertThat(ExceptionUtils.findThrowable(e, OnStopException.class).isPresent(), is(true)).     }     assertThat(akkaRpcService.getActorSystem().isTerminated(), is(true)). }
false;private;2;21;;private Collection<CompletableFuture<Void>> startStopNCountingAsynchronousOnStopEndpoints(AkkaRpcService akkaRpcService, int numberActors) throws Exception {     final Collection<CompletableFuture<Void>> onStopFutures = new ArrayList<>(numberActors).     final CountDownLatch countDownLatch = new CountDownLatch(numberActors).     for (int i = 0. i < numberActors. i++) {         CompletableFuture<Void> onStopFuture = new CompletableFuture<>().         final CountingAsynchronousOnStopEndpoint endpoint = new CountingAsynchronousOnStopEndpoint(akkaRpcService, onStopFuture, countDownLatch).         endpoint.start().         onStopFutures.add(onStopFuture).     }     CompletableFuture<Void> terminationFuture = akkaRpcService.stopService().     assertThat(terminationFuture.isDone(), is(false)).     assertThat(akkaRpcService.getActorSystem().isTerminated(), is(false)).     countDownLatch.await().     return onStopFutures. }
false;private;0;5;;@Nonnull private AkkaRpcService startAkkaRpcService() {     final ActorSystem actorSystem = AkkaUtils.createDefaultActorSystem().     return new AkkaRpcService(actorSystem, AkkaRpcServiceConfiguration.defaultConfiguration()). }
false;public;0;5;;@Override public CompletableFuture<Void> onStop() {     countDownLatch.countDown().     return super.onStop(). }
