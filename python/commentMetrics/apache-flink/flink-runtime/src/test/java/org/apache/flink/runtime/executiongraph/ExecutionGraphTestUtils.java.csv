commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;21;/**  * Waits until the Job has reached a certain state.  *  * <p>This method is based on polling and might miss very fast state transitions!  */ ;// ------------------------------------------------------------------------ // reaching states // ------------------------------------------------------------------------ /**  * Waits until the Job has reached a certain state.  *  * <p>This method is based on polling and might miss very fast state transitions!  */ public static void waitUntilJobStatus(ExecutionGraph eg, JobStatus status, long maxWaitMillis) throws TimeoutException {     checkNotNull(eg).     checkNotNull(status).     checkArgument(maxWaitMillis >= 0).     // this is a poor implementation - we may want to improve it eventually     final long deadline = maxWaitMillis == 0 ? Long.MAX_VALUE : System.nanoTime() + (maxWaitMillis * 1_000_000).     while (eg.getState() != status && System.nanoTime() < deadline) {         try {             Thread.sleep(2).         } catch (InterruptedException ignored) {         }     }     if (System.nanoTime() >= deadline) {         throw new TimeoutException(String.format("The job did not reach status %s in time. Current status is %s.", status, eg.getState())).     } }
true;public,static;3;21;/**  * Waits until the Execution has reached a certain state.  *  * <p>This method is based on polling and might miss very fast state transitions!  */ ;/**  * Waits until the Execution has reached a certain state.  *  * <p>This method is based on polling and might miss very fast state transitions!  */ public static void waitUntilExecutionState(Execution execution, ExecutionState state, long maxWaitMillis) throws TimeoutException {     checkNotNull(execution).     checkNotNull(state).     checkArgument(maxWaitMillis >= 0).     // this is a poor implementation - we may want to improve it eventually     final long deadline = maxWaitMillis == 0 ? Long.MAX_VALUE : System.nanoTime() + (maxWaitMillis * 1_000_000).     while (execution.getState() != state && System.nanoTime() < deadline) {         try {             Thread.sleep(2).         } catch (InterruptedException ignored) {         }     }     if (System.nanoTime() >= deadline) {         throw new TimeoutException(String.format("The execution did not reach state %s in time. Current state is %s.", state, execution.getState())).     } }
true;public,static;3;32;/**  * Waits until the ExecutionVertex has reached a certain state.  *  * <p>This method is based on polling and might miss very fast state transitions!  */ ;/**  * Waits until the ExecutionVertex has reached a certain state.  *  * <p>This method is based on polling and might miss very fast state transitions!  */ public static void waitUntilExecutionVertexState(ExecutionVertex executionVertex, ExecutionState state, long maxWaitMillis) throws TimeoutException {     checkNotNull(executionVertex).     checkNotNull(state).     checkArgument(maxWaitMillis >= 0).     // this is a poor implementation - we may want to improve it eventually     final long deadline = maxWaitMillis == 0 ? Long.MAX_VALUE : System.nanoTime() + (maxWaitMillis * 1_000_000).     while (true) {         Execution execution = executionVertex.getCurrentExecutionAttempt().         if (execution == null || (execution.getState() != state && System.nanoTime() < deadline)) {             try {                 Thread.sleep(2).             } catch (InterruptedException ignored) {             }         } else {             break.         }         if (System.nanoTime() >= deadline) {             if (execution != null) {                 throw new TimeoutException(String.format("The execution vertex did not reach state %s in time. Current state is %s.", state, execution.getState())).             } else {                 throw new TimeoutException("Cannot get current execution attempt of " + executionVertex + '.').             }         }     } }
true;public,static;3;24;/**  * Waits until all executions fulfill the given predicate.  *  * @param executionGraph for which to check the executions  * @param executionPredicate predicate which is to be fulfilled  * @param maxWaitMillis timeout for the wait operation  * @throws TimeoutException if the executions did not reach the target state in time  */ ;/**  * Waits until all executions fulfill the given predicate.  *  * @param executionGraph for which to check the executions  * @param executionPredicate predicate which is to be fulfilled  * @param maxWaitMillis timeout for the wait operation  * @throws TimeoutException if the executions did not reach the target state in time  */ public static void waitForAllExecutionsPredicate(ExecutionGraph executionGraph, Predicate<AccessExecution> executionPredicate, long maxWaitMillis) throws TimeoutException {     final Predicate<AccessExecutionGraph> allExecutionsPredicate = allExecutionsPredicate(executionPredicate).     final Deadline deadline = Deadline.fromNow(Duration.ofMillis(maxWaitMillis)).     boolean predicateResult.     do {         predicateResult = allExecutionsPredicate.test(executionGraph).         if (!predicateResult) {             try {                 Thread.sleep(2L).             } catch (InterruptedException ignored) {                 Thread.currentThread().interrupt().             }         }     } while (!predicateResult && deadline.hasTimeLeft()).     if (!predicateResult) {         throw new TimeoutException("Not all executions fulfilled the predicate in time.").     } }
false;public,static;1;15;;public static Predicate<AccessExecutionGraph> allExecutionsPredicate(final Predicate<AccessExecution> executionPredicate) {     return accessExecutionGraph -> {         final Iterable<? extends AccessExecutionVertex> allExecutionVertices = accessExecutionGraph.getAllExecutionVertices().         for (AccessExecutionVertex executionVertex : allExecutionVertices) {             final AccessExecution currentExecutionAttempt = executionVertex.getCurrentExecutionAttempt().             if (currentExecutionAttempt == null || !executionPredicate.test(currentExecutionAttempt)) {                 return false.             }         }         return true.     }. }
false;public,static;1;3;;public static Predicate<AccessExecution> isInExecutionState(ExecutionState executionState) {     return (AccessExecution execution) -> execution.getState() == executionState. }
false;public,static;3;19;;public static void waitUntilFailoverRegionState(FailoverRegion region, JobStatus status, long maxWaitMillis) throws TimeoutException {     checkNotNull(region).     checkNotNull(status).     checkArgument(maxWaitMillis >= 0).     // this is a poor implementation - we may want to improve it eventually     final long deadline = maxWaitMillis == 0 ? Long.MAX_VALUE : System.nanoTime() + (maxWaitMillis * 1_000_000).     while (region.getState() != status && System.nanoTime() < deadline) {         try {             Thread.sleep(2).         } catch (InterruptedException ignored) {         }     }     if (System.nanoTime() >= deadline) {         throw new TimeoutException().     } }
false;public,static;2;8;;public static void failExecutionGraph(ExecutionGraph executionGraph, Exception cause) {     executionGraph.getAllExecutionVertices().iterator().next().fail(cause).     assertEquals(JobStatus.FAILING, executionGraph.getState()).     for (ExecutionVertex vertex : executionGraph.getAllExecutionVertices()) {         vertex.getCurrentExecutionAttempt().completeCancelling().     } }
true;public,static;1;5;/**  * Takes all vertices in the given ExecutionGraph and switches their current  * execution to RUNNING.  */ ;/**  * Takes all vertices in the given ExecutionGraph and switches their current  * execution to RUNNING.  */ public static void switchAllVerticesToRunning(ExecutionGraph eg) {     for (ExecutionVertex vertex : eg.getAllExecutionVertices()) {         vertex.getCurrentExecutionAttempt().switchToRunning().     } }
true;public,static;1;5;/**  * Takes all vertices in the given ExecutionGraph and attempts to move them  * from CANCELING to CANCELED.  */ ;/**  * Takes all vertices in the given ExecutionGraph and attempts to move them  * from CANCELING to CANCELED.  */ public static void completeCancellingForAllVertices(ExecutionGraph eg) {     for (ExecutionVertex vertex : eg.getAllExecutionVertices()) {         vertex.getCurrentExecutionAttempt().completeCancelling().     } }
true;public,static;1;5;/**  * Takes all vertices in the given ExecutionGraph and switches their current  * execution to FINISHED.  */ ;/**  * Takes all vertices in the given ExecutionGraph and switches their current  * execution to FINISHED.  */ public static void finishAllVertices(ExecutionGraph eg) {     for (ExecutionVertex vertex : eg.getAllExecutionVertices()) {         vertex.getCurrentExecutionAttempt().markFinished().     } }
true;public,static;1;14;/**  * Checks that all execution are in state DEPLOYING and then switches them  * to state RUNNING  */ ;/**  * Checks that all execution are in state DEPLOYING and then switches them  * to state RUNNING  */ public static void switchToRunning(ExecutionGraph eg) {     // check that all execution are in state DEPLOYING     for (ExecutionVertex ev : eg.getAllExecutionVertices()) {         final Execution exec = ev.getCurrentExecutionAttempt().         final ExecutionState executionState = exec.getState().         assert executionState == ExecutionState.DEPLOYING : "Expected executionState to be DEPLOYING, was: " + executionState.     }     // switch executions to RUNNING     for (ExecutionVertex ev : eg.getAllExecutionVertices()) {         final Execution exec = ev.getCurrentExecutionAttempt().         exec.switchToRunning().     } }
false;public,static;2;12;;// ------------------------------------------------------------------------ // state modifications // ------------------------------------------------------------------------ public static void setVertexState(ExecutionVertex vertex, ExecutionState state) {     try {         Execution exec = vertex.getCurrentExecutionAttempt().         Field f = Execution.class.getDeclaredField("state").         f.setAccessible(true).         f.set(exec, state).     } catch (Exception e) {         throw new RuntimeException("Modifying the state failed", e).     } }
false;public,static;2;7;;public static void setVertexResource(ExecutionVertex vertex, LogicalSlot slot) {     Execution exec = vertex.getCurrentExecutionAttempt().     if (!exec.tryAssignResource(slot)) {         throw new RuntimeException("Could not assign resource.").     } }
false;public,static;1;15;;// ------------------------------------------------------------------------ // Mocking Slots // ------------------------------------------------------------------------ public static SimpleSlot createMockSimpleSlot(TaskManagerGateway gateway) {     final TaskManagerLocation location = new TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 6572).     final SimpleSlotContext allocatedSlot = new SimpleSlotContext(new AllocationID(), location, 0, gateway).     return new SimpleSlot(allocatedSlot, mock(SlotOwner.class), 0). }
true;public,static;0;3;/**  * Creates an execution graph with on job vertex of parallelism 10 that does no restarts.  */ ;// ------------------------------------------------------------------------ // Mocking ExecutionGraph // ------------------------------------------------------------------------ /**  * Creates an execution graph with on job vertex of parallelism 10 that does no restarts.  */ public static ExecutionGraph createSimpleTestGraph() throws Exception {     return createSimpleTestGraph(new NoRestartStrategy()). }
true;public,static;1;5;/**  * Creates an execution graph with on job vertex of parallelism 10, using the given  * restart strategy.  */ ;/**  * Creates an execution graph with on job vertex of parallelism 10, using the given  * restart strategy.  */ public static ExecutionGraph createSimpleTestGraph(RestartStrategy restartStrategy) throws Exception {     JobVertex vertex = createNoOpVertex(10).     return createSimpleTestGraph(new JobID(), new SimpleAckingTaskManagerGateway(), restartStrategy, vertex). }
true;public,static;2;3;/**  * Creates an execution graph containing the given vertices.  *  * <p>The execution graph uses {@link NoRestartStrategy} as the restart strategy.  */ ;/**  * Creates an execution graph containing the given vertices.  *  * <p>The execution graph uses {@link NoRestartStrategy} as the restart strategy.  */ public static ExecutionGraph createSimpleTestGraph(JobID jid, JobVertex... vertices) throws Exception {     return createSimpleTestGraph(jid, new SimpleAckingTaskManagerGateway(), new NoRestartStrategy(), vertices). }
true;public,static;4;15;/**  * Creates an execution graph containing the given vertices and the given restart strategy.  */ ;/**  * Creates an execution graph containing the given vertices and the given restart strategy.  */ public static ExecutionGraph createSimpleTestGraph(JobID jid, TaskManagerGateway taskManagerGateway, RestartStrategy restartStrategy, JobVertex... vertices) throws Exception {     int numSlotsNeeded = 0.     for (JobVertex vertex : vertices) {         numSlotsNeeded += vertex.getParallelism().     }     SlotProvider slotProvider = new SimpleSlotProvider(jid, numSlotsNeeded, taskManagerGateway).     return createSimpleTestGraph(jid, slotProvider, restartStrategy, vertices). }
false;public,static;4;8;;public static ExecutionGraph createSimpleTestGraph(JobID jid, SlotProvider slotProvider, RestartStrategy restartStrategy, JobVertex... vertices) throws Exception {     return createExecutionGraph(jid, slotProvider, restartStrategy, TestingUtils.defaultExecutor(), vertices). }
false;public,static;5;9;;public static ExecutionGraph createExecutionGraph(JobID jid, SlotProvider slotProvider, RestartStrategy restartStrategy, ScheduledExecutorService executor, JobVertex... vertices) throws Exception {     return createExecutionGraph(jid, slotProvider, restartStrategy, executor, Time.seconds(10L), vertices). }
false;public,static;6;30;;public static ExecutionGraph createExecutionGraph(JobID jid, SlotProvider slotProvider, RestartStrategy restartStrategy, ScheduledExecutorService executor, Time timeout, JobVertex... vertices) throws Exception {     checkNotNull(jid).     checkNotNull(restartStrategy).     checkNotNull(vertices).     checkNotNull(timeout).     return ExecutionGraphBuilder.buildGraph(null, new JobGraph(jid, "test job", vertices), new Configuration(), executor, executor, slotProvider, ExecutionGraphTestUtils.class.getClassLoader(), new StandaloneCheckpointRecoveryFactory(), timeout, restartStrategy, new UnregisteredMetricsGroup(), 1, VoidBlobWriter.getInstance(), timeout, TEST_LOGGER). }
false;public,static;1;6;;public static JobVertex createNoOpVertex(int parallelism) {     JobVertex vertex = new JobVertex("vertex").     vertex.setInvokableClass(NoOpInvokable.class).     vertex.setParallelism(parallelism).     return vertex. }
false;public,static;1;3;;// ------------------------------------------------------------------------ // utility mocking methods // ------------------------------------------------------------------------ public static Instance getInstance(final TaskManagerGateway gateway) throws Exception {     return getInstance(gateway, 1). }
false;public,static;2;8;;public static Instance getInstance(final TaskManagerGateway gateway, final int numberOfSlots) throws Exception {     ResourceID resourceID = ResourceID.generate().     HardwareDescription hardwareDescription = new HardwareDescription(4, 2L * 1024 * 1024 * 1024, 1024 * 1024 * 1024, 512 * 1024 * 1024).     InetAddress address = InetAddress.getByName("127.0.0.1").     TaskManagerLocation connection = new TaskManagerLocation(resourceID, address, 10001).     return new Instance(gateway, connection, new InstanceID(), hardwareDescription, numberOfSlots). }
false;public,static;3;6;;public static JobVertex createJobVertex(String task1, int numTasks, Class<NoOpInvokable> invokable) {     JobVertex groupVertex = new JobVertex(task1).     groupVertex.setInvokableClass(invokable).     groupVertex.setParallelism(numTasks).     return groupVertex. }
false;public;1;13;;@Override public Object handleMessage(Object message) {     if (message instanceof SubmitTask) {         SubmitTask submitTask = (SubmitTask) message.         return Acknowledge.get().     } else if (message instanceof CancelTask) {         return Acknowledge.get().     } else if (message instanceof FailIntermediateResultPartitions) {         return new Object().     } else {         return null.     } }
false;public,static;2;22;;public static ExecutionJobVertex getExecutionVertex(JobVertexID id, ScheduledExecutorService executor) throws Exception {     JobVertex ajv = new JobVertex("TestVertex", id).     ajv.setInvokableClass(mock(AbstractInvokable.class).getClass()).     ExecutionGraph graph = new ExecutionGraph(executor, executor, new JobID(), "test job", new Configuration(), new SerializedValue<>(new ExecutionConfig()), AkkaUtils.getDefaultTimeout(), new NoRestartStrategy(), new TestingSlotProvider(ignored -> new CompletableFuture<>())).     graph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread()).     return spy(new ExecutionJobVertex(graph, ajv, 1, AkkaUtils.getDefaultTimeout())). }
false;public,static;1;3;;public static ExecutionJobVertex getExecutionVertex(JobVertexID id) throws Exception {     return getExecutionVertex(id, new DirectScheduledExecutorService()). }
true;public,static;4;59;/**  * Verifies the generated {@link ExecutionJobVertex} for a given {@link JobVertex} in a {@link ExecutionGraph}  *  * @param executionGraph the generated execution graph  * @param originJobVertex the vertex to verify for  * @param inputJobVertices upstream vertices of the verified vertex, used to check inputs of generated vertex  * @param outputJobVertices downstream vertices of the verified vertex, used to  *                          check produced data sets of generated vertex  */ ;// ------------------------------------------------------------------------ // graph vertex verifications // ------------------------------------------------------------------------ /**  * Verifies the generated {@link ExecutionJobVertex} for a given {@link JobVertex} in a {@link ExecutionGraph}  *  * @param executionGraph the generated execution graph  * @param originJobVertex the vertex to verify for  * @param inputJobVertices upstream vertices of the verified vertex, used to check inputs of generated vertex  * @param outputJobVertices downstream vertices of the verified vertex, used to  *                          check produced data sets of generated vertex  */ public static void verifyGeneratedExecutionJobVertex(ExecutionGraph executionGraph, JobVertex originJobVertex, @Nullable List<JobVertex> inputJobVertices, @Nullable List<JobVertex> outputJobVertices) {     ExecutionJobVertex ejv = executionGraph.getAllVertices().get(originJobVertex.getID()).     assertNotNull(ejv).     // verify basic properties     assertEquals(originJobVertex.getParallelism(), ejv.getParallelism()).     assertEquals(executionGraph.getJobID(), ejv.getJobId()).     assertEquals(originJobVertex.getID(), ejv.getJobVertexId()).     assertEquals(originJobVertex, ejv.getJobVertex()).     // verify produced data sets     if (outputJobVertices == null) {         assertEquals(0, ejv.getProducedDataSets().length).     } else {         assertEquals(outputJobVertices.size(), ejv.getProducedDataSets().length).         for (int i = 0. i < outputJobVertices.size(). i++) {             assertEquals(originJobVertex.getProducedDataSets().get(i).getId(), ejv.getProducedDataSets()[i].getId()).             assertEquals(originJobVertex.getParallelism(), ejv.getProducedDataSets()[0].getPartitions().length).         }     }     // verify task vertices for their basic properties and their inputs     assertEquals(originJobVertex.getParallelism(), ejv.getTaskVertices().length).     int subtaskIndex = 0.     for (ExecutionVertex ev : ejv.getTaskVertices()) {         assertEquals(executionGraph.getJobID(), ev.getJobId()).         assertEquals(originJobVertex.getID(), ev.getJobvertexId()).         assertEquals(originJobVertex.getParallelism(), ev.getTotalNumberOfParallelSubtasks()).         assertEquals(subtaskIndex, ev.getParallelSubtaskIndex()).         if (inputJobVertices == null) {             assertEquals(0, ev.getNumberOfInputs()).         } else {             assertEquals(inputJobVertices.size(), ev.getNumberOfInputs()).             for (int i = 0. i < inputJobVertices.size(). i++) {                 ExecutionEdge[] inputEdges = ev.getInputEdges(i).                 assertEquals(inputJobVertices.get(i).getParallelism(), inputEdges.length).                 int expectedPartitionNum = 0.                 for (ExecutionEdge inEdge : inputEdges) {                     assertEquals(i, inEdge.getInputNum()).                     assertEquals(expectedPartitionNum, inEdge.getSource().getPartitionNumber()).                     expectedPartitionNum++.                 }             }         }         subtaskIndex++.     } }
