commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;22;;@Parameterized.Parameters public static Collection<Object[]> data() {     final Configuration config = getBaseConfig().     final String truststorePath = getTestResource("local127.truststore").getAbsolutePath().     final String keystorePath = getTestResource("local127.keystore").getAbsolutePath().     final Configuration sslConfig = new Configuration(config).     sslConfig.setBoolean(SecurityOptions.SSL_REST_ENABLED, true).     sslConfig.setString(SecurityOptions.SSL_REST_TRUSTSTORE, truststorePath).     sslConfig.setString(SecurityOptions.SSL_REST_TRUSTSTORE_PASSWORD, "password").     sslConfig.setString(SecurityOptions.SSL_REST_KEYSTORE, keystorePath).     sslConfig.setString(SecurityOptions.SSL_REST_KEYSTORE_PASSWORD, "password").     sslConfig.setString(SecurityOptions.SSL_REST_KEY_PASSWORD, "password").     final Configuration sslRestAuthConfig = new Configuration(sslConfig).     sslRestAuthConfig.setBoolean(SecurityOptions.SSL_REST_AUTHENTICATION_ENABLED, true).     return Arrays.asList(new Object[][] { { config }, { sslConfig }, { sslRestAuthConfig } }). }
false;private,static;0;11;;private static Configuration getBaseConfig() {     final String loopbackAddress = InetAddress.getLoopbackAddress().getHostAddress().     final Configuration config = new Configuration().     config.setString(RestOptions.BIND_PORT, "0").     config.setString(RestOptions.BIND_ADDRESS, loopbackAddress).     config.setString(RestOptions.ADDRESS, loopbackAddress).     config.setInteger(RestOptions.SERVER_MAX_CONTENT_LENGTH, TEST_REST_MAX_CONTENT_LENGTH).     config.setInteger(RestOptions.CLIENT_MAX_CONTENT_LENGTH, TEST_REST_MAX_CONTENT_LENGTH).     return config. }
false;public;0;59;;@Before public void setup() throws Exception {     config.setString(WebOptions.UPLOAD_DIR, temporaryFolder.newFolder().getCanonicalPath()).     defaultSSLContext = SSLContext.getDefault().     defaultSSLSocketFactory = HttpsURLConnection.getDefaultSSLSocketFactory().     final SSLContext sslClientContext = SSLUtils.createRestClientSSLContext(config).     if (sslClientContext != null) {         SSLContext.setDefault(sslClientContext).         HttpsURLConnection.setDefaultSSLSocketFactory(sslClientContext.getSocketFactory()).     }     RestServerEndpointConfiguration serverConfig = RestServerEndpointConfiguration.fromConfiguration(config).     RestClientConfiguration clientConfig = RestClientConfiguration.fromConfiguration(config).     RestfulGateway mockRestfulGateway = mock(RestfulGateway.class).     final GatewayRetriever<RestfulGateway> mockGatewayRetriever = () -> CompletableFuture.completedFuture(mockRestfulGateway).     testHandler = new TestHandler(mockGatewayRetriever, RpcUtils.INF_TIMEOUT).     TestVersionHandler testVersionHandler = new TestVersionHandler(mockGatewayRetriever, RpcUtils.INF_TIMEOUT).     TestVersionSelectionHandler1 testVersionSelectionHandler1 = new TestVersionSelectionHandler1(mockGatewayRetriever, RpcUtils.INF_TIMEOUT).     TestVersionSelectionHandler2 testVersionSelectionHandler2 = new TestVersionSelectionHandler2(mockGatewayRetriever, RpcUtils.INF_TIMEOUT).     testUploadHandler = new TestUploadHandler(mockGatewayRetriever, RpcUtils.INF_TIMEOUT).     final StaticFileServerHandler<RestfulGateway> staticFileServerHandler = new StaticFileServerHandler<>(mockGatewayRetriever, RpcUtils.INF_TIMEOUT, temporaryFolder.getRoot()).     final List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = Arrays.asList(Tuple2.of(new TestHeaders(), testHandler), Tuple2.of(TestUploadHeaders.INSTANCE, testUploadHandler), Tuple2.of(testVersionHandler.getMessageHeaders(), testVersionHandler), Tuple2.of(testVersionSelectionHandler1.getMessageHeaders(), testVersionSelectionHandler1), Tuple2.of(testVersionSelectionHandler2.getMessageHeaders(), testVersionSelectionHandler2), Tuple2.of(WebContentHandlerSpecification.getInstance(), staticFileServerHandler)).     serverEndpoint = new TestRestServerEndpoint(serverConfig, handlers).     restClient = new TestRestClient(clientConfig).     serverEndpoint.start().     serverAddress = serverEndpoint.getServerAddress(). }
false;public;0;17;;@After public void teardown() throws Exception {     if (defaultSSLContext != null) {         SSLContext.setDefault(defaultSSLContext).         HttpsURLConnection.setDefaultSSLSocketFactory(defaultSSLSocketFactory).     }     if (restClient != null) {         restClient.shutdown(timeout).         restClient = null.     }     if (serverEndpoint != null) {         serverEndpoint.closeAsync().get(timeout.getSize(), timeout.getUnit()).         serverEndpoint = null.     } }
true;public;0;24;/**  * Tests that request are handled as individual units which don't interfere with each other.  * This means that request responses can overtake each other.  */ ;/**  * Tests that request are handled as individual units which don't interfere with each other.  * This means that request responses can overtake each other.  */ @Test public void testRequestInterleaving() throws Exception {     final HandlerBlocker handlerBlocker = new HandlerBlocker(timeout).     testHandler.handlerBody = id -> {         if (id == 1) {             handlerBlocker.arriveAndBlock().         }         return CompletableFuture.completedFuture(new TestResponse(id)).     }.     // send first request and wait until the handler blocks     final CompletableFuture<TestResponse> response1 = sendRequestToTestHandler(new TestRequest(1)).     handlerBlocker.awaitRequestToArrive().     // send second request and verify response     final CompletableFuture<TestResponse> response2 = sendRequestToTestHandler(new TestRequest(2)).     assertEquals(2, response2.get().id).     // wake up blocked handler     handlerBlocker.unblockRequest().     // verify response to first request     assertEquals(1, response1.get().id). }
true;public;0;28;/**  * Tests that a bad handler request (HandlerRequest cannot be created) is reported as a BAD_REQUEST  * and not an internal server error.  *  * <p>See FLINK-7663  */ ;/**  * Tests that a bad handler request (HandlerRequest cannot be created) is reported as a BAD_REQUEST  * and not an internal server error.  *  * <p>See FLINK-7663  */ @Test public void testBadHandlerRequest() throws Exception {     final FaultyTestParameters parameters = new FaultyTestParameters().     parameters.faultyJobIDPathParameter.resolve(PATH_JOB_ID).     ((TestParameters) parameters).jobIDQueryParameter.resolve(Collections.singletonList(QUERY_JOB_ID)).     CompletableFuture<TestResponse> response = restClient.sendRequest(serverAddress.getHostName(), serverAddress.getPort(), new TestHeaders(), parameters, new TestRequest(2)).     try {         response.get().         fail("The request should fail with a bad request return code.").     } catch (ExecutionException ee) {         Throwable t = ExceptionUtils.stripExecutionException(ee).         assertTrue(t instanceof RestClientException).         RestClientException rce = (RestClientException) t.         assertEquals(HttpResponseStatus.BAD_REQUEST, rce.getHttpResponseStatus()).     } }
true;public;0;15;/**  * Tests that requests larger than {@link #TEST_REST_MAX_CONTENT_LENGTH} are rejected.  */ ;/**  * Tests that requests larger than {@link #TEST_REST_MAX_CONTENT_LENGTH} are rejected.  */ @Test public void testShouldRespectMaxContentLengthLimitForRequests() throws Exception {     testHandler.handlerBody = id -> {         throw new AssertionError("Request should not arrive at server.").     }.     try {         sendRequestToTestHandler(new TestRequest(2, createStringOfSize(TEST_REST_MAX_CONTENT_LENGTH))).get().         fail("Expected exception not thrown").     } catch (final ExecutionException e) {         final Throwable throwable = ExceptionUtils.stripExecutionException(e).         assertThat(throwable, instanceOf(RestClientException.class)).         assertThat(throwable.getMessage(), containsString("Try to raise")).     } }
true;public;0;14;/**  * Tests that responses larger than {@link #TEST_REST_MAX_CONTENT_LENGTH} are rejected.  */ ;/**  * Tests that responses larger than {@link #TEST_REST_MAX_CONTENT_LENGTH} are rejected.  */ @Test public void testShouldRespectMaxContentLengthLimitForResponses() throws Exception {     testHandler.handlerBody = id -> CompletableFuture.completedFuture(new TestResponse(id, createStringOfSize(TEST_REST_MAX_CONTENT_LENGTH))).     try {         sendRequestToTestHandler(new TestRequest(1)).get().         fail("Expected exception not thrown").     } catch (final ExecutionException e) {         final Throwable throwable = ExceptionUtils.stripExecutionException(e).         assertThat(throwable, instanceOf(TooLongFrameException.class)).         assertThat(throwable.getMessage(), containsString("Try to raise")).     } }
true;public;0;24;/**  * Tests that multipart/form-data uploads work correctly.  *  * @see FileUploadHandler  */ ;/**  * Tests that multipart/form-data uploads work correctly.  *  * @see FileUploadHandler  */ @Test public void testFileUpload() throws Exception {     final String boundary = generateMultiPartBoundary().     final String crlf = "\r\n".     final String uploadedContent = "hello".     final HttpURLConnection connection = openHttpConnectionForUpload(boundary).     try (OutputStream output = connection.getOutputStream().         PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8), true)) {         writer.append("--" + boundary).append(crlf).         writer.append("Content-Disposition: form-data. name=\"foo\". filename=\"bar\"").append(crlf).         writer.append("Content-Type: plain/text. charset=utf8").append(crlf).         writer.append(crlf).flush().         output.write(uploadedContent.getBytes(StandardCharsets.UTF_8)).         output.flush().         writer.append(crlf).flush().         writer.append("--" + boundary + "--").append(crlf).flush().     }     assertEquals(200, connection.getResponseCode()).     final byte[] lastUploadedFileContents = testUploadHandler.getLastUploadedFileContents().     assertEquals(uploadedContent, new String(lastUploadedFileContents, StandardCharsets.UTF_8)). }
true;public;0;20;/**  * Sending multipart/form-data without a file should result in a bad request if the handler  * expects a file upload.  */ ;/**  * Sending multipart/form-data without a file should result in a bad request if the handler  * expects a file upload.  */ @Test public void testMultiPartFormDataWithoutFileUpload() throws Exception {     final String boundary = generateMultiPartBoundary().     final String crlf = "\r\n".     final HttpURLConnection connection = openHttpConnectionForUpload(boundary).     try (OutputStream output = connection.getOutputStream().         PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8), true)) {         writer.append("--" + boundary).append(crlf).         writer.append("Content-Disposition: form-data. name=\"foo\"").append(crlf).         writer.append(crlf).flush().         output.write("test".getBytes(StandardCharsets.UTF_8)).         output.flush().         writer.append(crlf).flush().         writer.append("--" + boundary + "--").append(crlf).flush().     }     assertEquals(400, connection.getResponseCode()). }
true;public;0;12;/**  * Tests that files can be served with the {@link StaticFileServerHandler}.  */ ;/**  * Tests that files can be served with the {@link StaticFileServerHandler}.  */ @Test public void testStaticFileServerHandler() throws Exception {     final File file = temporaryFolder.newFile().     Files.write(file.toPath(), Collections.singletonList("foobar")).     final URL url = new URL(serverEndpoint.getRestBaseUrl() + "/" + file.getName()).     final HttpURLConnection connection = (HttpURLConnection) url.openConnection().     connection.setRequestMethod("GET").     final String fileContents = IOUtils.toString(connection.getInputStream()).     assertEquals("foobar", fileContents.trim()). }
false;public;0;25;;@Test public void testVersioning() throws Exception {     CompletableFuture<EmptyResponseBody> unspecifiedVersionResponse = restClient.sendRequest(serverAddress.getHostName(), serverAddress.getPort(), TestVersionHeaders.INSTANCE, EmptyMessageParameters.getInstance(), EmptyRequestBody.getInstance(), Collections.emptyList()).     unspecifiedVersionResponse.get(5, TimeUnit.SECONDS).     CompletableFuture<EmptyResponseBody> specifiedVersionResponse = restClient.sendRequest(serverAddress.getHostName(), serverAddress.getPort(), TestVersionHeaders.INSTANCE, EmptyMessageParameters.getInstance(), EmptyRequestBody.getInstance(), Collections.emptyList(), RestAPIVersion.V1).     specifiedVersionResponse.get(5, TimeUnit.SECONDS). }
false;public;0;38;;@Test public void testVersionSelection() throws Exception {     CompletableFuture<EmptyResponseBody> version1Response = restClient.sendRequest(serverAddress.getHostName(), serverAddress.getPort(), TestVersionSelectionHeaders1.INSTANCE, EmptyMessageParameters.getInstance(), EmptyRequestBody.getInstance(), Collections.emptyList(), RestAPIVersion.V0).     try {         version1Response.get(5, TimeUnit.SECONDS).         fail().     } catch (ExecutionException ee) {         RestClientException rce = (RestClientException) ee.getCause().         assertEquals(HttpResponseStatus.OK, rce.getHttpResponseStatus()).     }     CompletableFuture<EmptyResponseBody> version2Response = restClient.sendRequest(serverAddress.getHostName(), serverAddress.getPort(), TestVersionSelectionHeaders2.INSTANCE, EmptyMessageParameters.getInstance(), EmptyRequestBody.getInstance(), Collections.emptyList(), RestAPIVersion.V1).     try {         version2Response.get(5, TimeUnit.SECONDS).         fail().     } catch (ExecutionException ee) {         RestClientException rce = (RestClientException) ee.getCause().         assertEquals(HttpResponseStatus.ACCEPTED, rce.getHttpResponseStatus()).     } }
false;public;0;16;;@Test public void testDefaultVersionRouting() throws Exception {     Assume.assumeFalse("Ignoring SSL-enabled test to keep OkHttp usage simple.", config.getBoolean(SecurityOptions.SSL_REST_ENABLED)).     OkHttpClient client = new OkHttpClient().     final Request request = new Request.Builder().url(serverEndpoint.getRestBaseUrl() + TestVersionSelectionHeaders2.INSTANCE.getTargetRestEndpointURL()).build().     try (final Response response = client.newCall(request).execute()) {         assertEquals(HttpResponseStatus.ACCEPTED.code(), response.code()).     } }
false;public;0;13;;@Test public void testNonSslRedirectForEnabledSsl() throws Exception {     Assume.assumeTrue(config.getBoolean(SecurityOptions.SSL_REST_ENABLED)).     OkHttpClient client = new OkHttpClient.Builder().followRedirects(false).build().     String httpsUrl = serverEndpoint.getRestBaseUrl() + "/path".     String httpUrl = httpsUrl.replace("https://", "http://").     Request request = new Request.Builder().url(httpUrl).build().     try (final Response response = client.newCall(request).execute()) {         assertEquals(HttpResponseStatus.MOVED_PERMANENTLY.code(), response.code()).         assertThat(response.headers().names(), hasItems("Location")).         assertEquals(httpsUrl, response.header("Location")).     } }
true;public;0;31;/**  * Tests that after calling {@link RestServerEndpoint#closeAsync()}, the handlers are closed  * first, and we wait for in-flight requests to finish. As long as not all handlers are closed,  * HTTP requests should be served.  */ ;/**  * Tests that after calling {@link RestServerEndpoint#closeAsync()}, the handlers are closed  * first, and we wait for in-flight requests to finish. As long as not all handlers are closed,  * HTTP requests should be served.  */ @Test public void testShouldWaitForHandlersWhenClosing() throws Exception {     testHandler.closeFuture = new CompletableFuture<>().     final HandlerBlocker handlerBlocker = new HandlerBlocker(timeout).     testHandler.handlerBody = id -> {         // handlers where the CompletableFuture is finished by the RPC framework.         return CompletableFuture.supplyAsync(() -> {             handlerBlocker.arriveAndBlock().             return new TestResponse(id).         }).     }.     // Initiate closing RestServerEndpoint but the test handler should block.     final CompletableFuture<Void> closeRestServerEndpointFuture = serverEndpoint.closeAsync().     assertThat(closeRestServerEndpointFuture.isDone(), is(false)).     final CompletableFuture<TestResponse> request = sendRequestToTestHandler(new TestRequest(1)).     handlerBlocker.awaitRequestToArrive().     // Allow handler to close but there is still one in-flight request which should prevent     // the RestServerEndpoint from closing.     testHandler.closeFuture.complete(null).     assertThat(closeRestServerEndpointFuture.isDone(), is(false)).     // Finish the in-flight request.     handlerBlocker.unblockRequest().     request.get(timeout.getSize(), timeout.getUnit()).     closeRestServerEndpointFuture.get(timeout.getSize(), timeout.getUnit()). }
false;public;0;25;;@Test public void testRestServerBindPort() throws Exception {     final int portRangeStart = 52300.     final int portRangeEnd = 52400.     final Configuration config = new Configuration().     config.setString(RestOptions.ADDRESS, "localhost").     config.setString(RestOptions.BIND_PORT, portRangeStart + "-" + portRangeEnd).     final RestServerEndpointConfiguration serverConfig = RestServerEndpointConfiguration.fromConfiguration(config).     try (RestServerEndpoint serverEndpoint1 = new TestRestServerEndpoint(serverConfig, Collections.emptyList()).         RestServerEndpoint serverEndpoint2 = new TestRestServerEndpoint(serverConfig, Collections.emptyList())) {         serverEndpoint1.start().         serverEndpoint2.start().         assertNotEquals(serverEndpoint1.getServerAddress().getPort(), serverEndpoint2.getServerAddress().getPort()).         assertThat(serverEndpoint1.getServerAddress().getPort(), is(greaterThanOrEqualTo(portRangeStart))).         assertThat(serverEndpoint1.getServerAddress().getPort(), is(lessThanOrEqualTo(portRangeEnd))).         assertThat(serverEndpoint2.getServerAddress().getPort(), is(greaterThanOrEqualTo(portRangeStart))).         assertThat(serverEndpoint2.getServerAddress().getPort(), is(lessThanOrEqualTo(portRangeEnd))).     } }
false;private,static;1;8;;private static File getTestResource(final String fileName) {     final ClassLoader classLoader = ClassLoader.getSystemClassLoader().     final URL resource = classLoader.getResource(fileName).     if (resource == null) {         throw new IllegalArgumentException(String.format("Test resource %s does not exist", fileName)).     }     return new File(resource.getFile()). }
false;private;1;7;;private HttpURLConnection openHttpConnectionForUpload(final String boundary) throws IOException {     final HttpURLConnection connection = (HttpURLConnection) new URL(serverEndpoint.getRestBaseUrl() + "/upload").openConnection().     connection.setDoOutput(true).     connection.setRequestProperty("Content-Type", "multipart/form-data. boundary=" + boundary).     return connection. }
false;private,static;0;3;;private static String generateMultiPartBoundary() {     return Long.toHexString(System.currentTimeMillis()). }
false;private,static;1;7;;private static String createStringOfSize(int size) {     StringBuilder sb = new StringBuilder(size).     for (int i = 0. i < size. i++) {         sb.append('a').     }     return sb.toString(). }
false;protected;1;4;;@Override protected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(final CompletableFuture<String> localAddressFuture) {     return handlers. }
false;protected;0;2;;@Override protected void startInternal() { }
false;protected;2;8;;@Override protected CompletableFuture<TestResponse> handleRequest(@Nonnull HandlerRequest<TestRequest, TestParameters> request, RestfulGateway gateway) {     assertEquals(request.getPathParameter(JobIDPathParameter.class), PATH_JOB_ID).     assertEquals(request.getQueryParameter(JobIDQueryParameter.class).get(0), QUERY_JOB_ID).     final int id = request.getRequestBody().id.     return handlerBody.apply(id). }
false;public;0;4;;@Override public CompletableFuture<Void> closeHandlerAsync() {     return closeFuture. }
false;private;1;12;;private CompletableFuture<TestResponse> sendRequestToTestHandler(final TestRequest testRequest) {     try {         return restClient.sendRequest(serverAddress.getHostName(), serverAddress.getPort(), new TestHeaders(), createTestParameters(), testRequest).     } catch (final IOException e) {         throw new RuntimeException(e).     } }
false;private,static;0;6;;private static TestParameters createTestParameters() {     final TestParameters parameters = new TestParameters().     parameters.jobIDPathParameter.resolve(PATH_JOB_ID).     parameters.jobIDQueryParameter.resolve(Collections.singletonList(QUERY_JOB_ID)).     return parameters. }
true;public;0;7;/**  * Waits until {@link #arriveAndBlock()} is called.  */ ;/**  * Waits until {@link #arriveAndBlock()} is called.  */ public void awaitRequestToArrive() {     try {         assertTrue(requestArrivedLatch.await(timeout.getSize(), timeout.getUnit())).     } catch (final InterruptedException e) {         Thread.currentThread().interrupt().     } }
true;public;0;8;/**  * Signals that the request arrived. This method blocks until {@link #unblockRequest()} is  * called.  */ ;/**  * Signals that the request arrived. This method blocks until {@link #unblockRequest()} is  * called.  */ public void arriveAndBlock() {     markRequestArrived().     try {         assertTrue(finishRequestLatch.await(timeout.getSize(), timeout.getUnit())).     } catch (final InterruptedException e) {         Thread.currentThread().interrupt().     } }
true;public;0;3;/**  * @see #arriveAndBlock()  */ ;/**  * @see #arriveAndBlock()  */ public void unblockRequest() {     finishRequestLatch.countDown(). }
false;private;0;3;;private void markRequestArrived() {     requestArrivedLatch.countDown(). }
false;public;0;4;;@Override public HttpMethodWrapper getHttpMethod() {     return HttpMethodWrapper.POST. }
false;public;0;4;;@Override public String getTargetRestEndpointURL() {     return "/test/:jobid". }
false;public;0;4;;@Override public Class<TestRequest> getRequestClass() {     return TestRequest.class. }
false;public;0;4;;@Override public Class<TestResponse> getResponseClass() {     return TestResponse.class. }
false;public;0;4;;@Override public HttpResponseStatus getResponseStatusCode() {     return HttpResponseStatus.OK. }
false;public;0;4;;@Override public String getDescription() {     return "". }
false;public;0;4;;@Override public TestParameters getUnresolvedMessageParameters() {     return new TestParameters(). }
false;public;0;4;;@Override public Collection<MessagePathParameter<?>> getPathParameters() {     return Collections.singleton(jobIDPathParameter). }
false;public;0;4;;@Override public Collection<MessageQueryParameter<?>> getQueryParameters() {     return Collections.singleton(jobIDQueryParameter). }
false;public;0;4;;@Override public Collection<MessagePathParameter<?>> getPathParameters() {     return Collections.singleton(faultyJobIDPathParameter). }
false;public;1;4;;@Override public JobID convertFromString(String value) {     return JobID.fromHexString(value). }
false;protected;1;4;;@Override protected String convertToString(JobID value) {     return value.toString(). }
false;public;0;4;;@Override public String getDescription() {     return "correct JobID parameter". }
false;protected;1;4;;@Override protected JobID convertFromString(String value) throws ConversionException {     return JobID.fromHexString(value). }
false;protected;1;4;;@Override protected String convertToString(JobID value) {     return "foobar". }
false;public;0;4;;@Override public String getDescription() {     return "faulty JobID parameter". }
false;public;1;4;;@Override public JobID convertStringToValue(String value) {     return JobID.fromHexString(value). }
false;public;1;4;;@Override public String convertValueToString(JobID value) {     return value.toString(). }
false;public;0;4;;@Override public String getDescription() {     return "query JobID parameter". }
false;protected;2;14;;@Override protected CompletableFuture<EmptyResponseBody> handleRequest(@Nonnull final HandlerRequest<EmptyRequestBody, EmptyMessageParameters> request, @Nonnull final RestfulGateway gateway) throws RestHandlerException {     Collection<Path> uploadedFiles = request.getUploadedFiles().stream().map(File::toPath).collect(Collectors.toList()).     if (uploadedFiles.size() != 1) {         throw new RestHandlerException("Expected 1 file, received " + uploadedFiles.size() + '.', HttpResponseStatus.BAD_REQUEST).     }     try {         lastUploadedFileContents = Files.readAllBytes(uploadedFiles.iterator().next()).     } catch (IOException e) {         throw new RestHandlerException("Could not read contents of uploaded file.", HttpResponseStatus.INTERNAL_SERVER_ERROR, e).     }     return CompletableFuture.completedFuture(EmptyResponseBody.getInstance()). }
false;public;0;3;;public byte[] getLastUploadedFileContents() {     return lastUploadedFileContents. }
false;protected;2;4;;@Override protected CompletableFuture<EmptyResponseBody> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, EmptyMessageParameters> request, @Nonnull RestfulGateway gateway) throws RestHandlerException {     return CompletableFuture.completedFuture(EmptyResponseBody.getInstance()). }
false;public;0;4;;@Override public Class<EmptyRequestBody> getRequestClass() {     return EmptyRequestBody.class. }
false;public;0;4;;@Override public HttpMethodWrapper getHttpMethod() {     return HttpMethodWrapper.GET. }
false;public;0;4;;@Override public String getTargetRestEndpointURL() {     return "/test/versioning". }
false;public;0;4;;@Override public Class<EmptyResponseBody> getResponseClass() {     return EmptyResponseBody.class. }
false;public;0;4;;@Override public HttpResponseStatus getResponseStatusCode() {     return HttpResponseStatus.OK. }
false;public;0;4;;@Override public String getDescription() {     return null. }
false;public;0;4;;@Override public EmptyMessageParameters getUnresolvedMessageParameters() {     return EmptyMessageParameters.getInstance(). }
false;public;0;4;;@Override public Collection<RestAPIVersion> getSupportedAPIVersions() {     return Collections.singleton(RestAPIVersion.V1). }
false;default;0;4;;@Override default Class<EmptyRequestBody> getRequestClass() {     return EmptyRequestBody.class. }
false;default;0;4;;@Override default HttpMethodWrapper getHttpMethod() {     return HttpMethodWrapper.GET. }
false;default;0;4;;@Override default String getTargetRestEndpointURL() {     return "/test/select-version". }
false;default;0;4;;@Override default Class<EmptyResponseBody> getResponseClass() {     return EmptyResponseBody.class. }
false;default;0;4;;@Override default HttpResponseStatus getResponseStatusCode() {     return HttpResponseStatus.OK. }
false;default;0;4;;@Override default String getDescription() {     return null. }
false;default;0;4;;@Override default EmptyMessageParameters getUnresolvedMessageParameters() {     return EmptyMessageParameters.getInstance(). }
false;public;0;4;;@Override public Collection<RestAPIVersion> getSupportedAPIVersions() {     return Collections.singleton(RestAPIVersion.V0). }
false;public;0;4;;@Override public Collection<RestAPIVersion> getSupportedAPIVersions() {     return Collections.singleton(RestAPIVersion.V1). }
false;protected;2;4;;@Override protected CompletableFuture<EmptyResponseBody> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, EmptyMessageParameters> request, @Nonnull RestfulGateway gateway) throws RestHandlerException {     throw new RestHandlerException("test failure 1", HttpResponseStatus.OK). }
false;protected;2;4;;@Override protected CompletableFuture<EmptyResponseBody> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, EmptyMessageParameters> request, @Nonnull RestfulGateway gateway) throws RestHandlerException {     throw new RestHandlerException("test failure 2", HttpResponseStatus.ACCEPTED). }
false;public;0;4;;@Override public Class<EmptyResponseBody> getResponseClass() {     return EmptyResponseBody.class. }
false;public;0;4;;@Override public HttpResponseStatus getResponseStatusCode() {     return HttpResponseStatus.OK. }
false;public;0;4;;@Override public Class<EmptyRequestBody> getRequestClass() {     return EmptyRequestBody.class. }
false;public;0;4;;@Override public EmptyMessageParameters getUnresolvedMessageParameters() {     return EmptyMessageParameters.getInstance(). }
false;public;0;4;;@Override public HttpMethodWrapper getHttpMethod() {     return HttpMethodWrapper.POST. }
false;public;0;4;;@Override public String getTargetRestEndpointURL() {     return "/upload". }
false;public;0;4;;@Override public String getDescription() {     return "". }
false;public;0;4;;@Override public boolean acceptsFileUploads() {     return true. }
