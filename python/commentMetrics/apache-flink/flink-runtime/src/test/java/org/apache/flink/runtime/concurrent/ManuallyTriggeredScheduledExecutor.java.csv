commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void execute(@Nonnull Runnable command) {     synchronized (queuedRunnables) {         queuedRunnables.addLast(command).     } }
true;public;0;13;/**  * Triggers the next queued runnable and executes it synchronously.  * This method throws an exception if no Runnable is currently queued.  */ ;/**  * Triggers the next queued runnable and executes it synchronously.  * This method throws an exception if no Runnable is currently queued.  */ public void trigger() {     final Runnable next.     synchronized (queuedRunnables) {         next = queuedRunnables.removeFirst().     }     if (next != null) {         CompletableFuture.runAsync(next, executorDelegate).join().     } else {         throw new IllegalStateException("No runnable available").     } }
true;public;0;5;/**  * Gets the number of Runnables currently queued.  */ ;/**  * Gets the number of Runnables currently queued.  */ public int numQueuedRunnables() {     synchronized (queuedRunnables) {         return queuedRunnables.size().     } }
false;public;3;4;;@Override public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {     return insertRunnable(command, false). }
false;public;3;8;;@Override public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {     final ScheduledTask<V> scheduledTask = new ScheduledTask<>(callable, false).     scheduledTasks.offer(scheduledTask).     return scheduledTask. }
false;public;4;4;;@Override public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {     return insertRunnable(command, true). }
false;public;4;4;;@Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {     return insertRunnable(command, true). }
false;public;0;3;;public Collection<ScheduledFuture<?>> getScheduledTasks() {     return new ArrayList<>(scheduledTasks). }
true;public;0;13;/**  * Triggers all registered tasks.  */ ;/**  * Triggers all registered tasks.  */ public void triggerScheduledTasks() {     final Iterator<ScheduledTask<?>> iterator = scheduledTasks.iterator().     while (iterator.hasNext()) {         final ScheduledTask<?> scheduledTask = iterator.next().         scheduledTask.execute().         if (!scheduledTask.isPeriodic) {             iterator.remove().         }     } }
false;private;2;12;;private ScheduledFuture<?> insertRunnable(Runnable command, boolean isPeriodic) {     final ScheduledTask<?> scheduledTask = new ScheduledTask<>(() -> {         command.run().         return null.     }, isPeriodic).     scheduledTasks.offer(scheduledTask).     return scheduledTask. }
false;public;0;3;;@Override public void assertRunningInMainThread() { }
false;public;0;17;;public void execute() {     if (!result.isDone()) {         if (!isPeriodic) {             try {                 result.complete(callable.call()).             } catch (Exception e) {                 result.completeExceptionally(e).             }         } else {             try {                 callable.call().             } catch (Exception e) {                 result.completeExceptionally(e).             }         }     } }
false;public;1;4;;@Override public long getDelay(TimeUnit unit) {     return 0. }
false;public;1;4;;@Override public int compareTo(Delayed o) {     return 0. }
false;public;1;4;;@Override public boolean cancel(boolean mayInterruptIfRunning) {     return result.cancel(mayInterruptIfRunning). }
false;public;0;4;;@Override public boolean isCancelled() {     return result.isCancelled(). }
false;public;0;4;;@Override public boolean isDone() {     return result.isDone(). }
false;public;0;4;;@Override public T get() throws InterruptedException, ExecutionException {     return result.get(). }
false;public;2;4;;@Override public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {     return result.get(timeout, unit). }
