commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;18;;@BeforeClass public static void setupClass() {     libraryCacheManager = new BlobLibraryCacheManager(FailingPermanentBlobService.INSTANCE, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[] {}).     defaultJobMasterServiceFactory = new TestingJobMasterServiceFactory().     final JobVertex jobVertex = new JobVertex("Test vertex").     jobVertex.setInvokableClass(NoOpInvokable.class).     jobGraph = new JobGraph(jobVertex).     archivedExecutionGraph = new ArchivedExecutionGraphBuilder().setJobID(jobGraph.getJobID()).setState(JobStatus.FINISHED).build(). }
false;public;0;10;;@Before public void setup() {     leaderElectionService = new TestingLeaderElectionService().     haServices = new TestingHighAvailabilityServices().     haServices.setJobMasterLeaderElectionService(jobGraph.getJobID(), leaderElectionService).     haServices.setResourceManagerLeaderRetriever(new SettableLeaderRetrievalService()).     haServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory()).     fatalErrorHandler = new TestingFatalErrorHandler(). }
false;public;0;4;;@After public void tearDown() throws Exception {     fatalErrorHandler.rethrowError(). }
false;public,static;0;6;;@AfterClass public static void tearDownClass() {     if (libraryCacheManager != null) {         libraryCacheManager.shutdown().     } }
false;public;0;18;;@Test public void testJobCompletion() throws Exception {     final JobManagerRunner jobManagerRunner = createJobManagerRunner().     try {         jobManagerRunner.start().         final CompletableFuture<ArchivedExecutionGraph> resultFuture = jobManagerRunner.getResultFuture().         assertThat(resultFuture.isDone(), is(false)).         jobManagerRunner.jobReachedGloballyTerminalState(archivedExecutionGraph).         assertThat(resultFuture.get(), is(archivedExecutionGraph)).     } finally {         jobManagerRunner.close().     } }
false;public;0;23;;@Test public void testJobFinishedByOther() throws Exception {     final JobManagerRunner jobManagerRunner = createJobManagerRunner().     try {         jobManagerRunner.start().         final CompletableFuture<ArchivedExecutionGraph> resultFuture = jobManagerRunner.getResultFuture().         assertThat(resultFuture.isDone(), is(false)).         jobManagerRunner.jobFinishedByOther().         try {             resultFuture.get().             fail("Should have failed.").         } catch (ExecutionException ee) {             assertThat(ExceptionUtils.stripExecutionException(ee), instanceOf(JobNotFinishedException.class)).         }     } finally {         jobManagerRunner.close().     } }
false;public;0;23;;@Test public void testShutDown() throws Exception {     final JobManagerRunner jobManagerRunner = createJobManagerRunner().     try {         jobManagerRunner.start().         final CompletableFuture<ArchivedExecutionGraph> resultFuture = jobManagerRunner.getResultFuture().         assertThat(resultFuture.isDone(), is(false)).         jobManagerRunner.closeAsync().         try {             resultFuture.get().             fail("Should have failed.").         } catch (ExecutionException ee) {             assertThat(ExceptionUtils.stripExecutionException(ee), instanceOf(JobNotFinishedException.class)).         }     } finally {         jobManagerRunner.close().     } }
false;public;0;21;;@Test public void testLibraryCacheManagerRegistration() throws Exception {     final BlobLibraryCacheManager libraryCacheManager = new BlobLibraryCacheManager(VoidPermanentBlobService.INSTANCE, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[] {}).     final JobManagerRunner jobManagerRunner = createJobManagerRunner(libraryCacheManager).     try {         jobManagerRunner.start().         final JobID jobID = jobGraph.getJobID().         assertThat(libraryCacheManager.hasClassLoader(jobID), is(true)).         jobManagerRunner.close().         assertThat(libraryCacheManager.hasClassLoader(jobID), is(false)).     } finally {         jobManagerRunner.close().     } }
true;public;0;32;/**  * Tests that the {@link JobManagerRunner} always waits for the previous leadership operation  * (granting or revoking leadership) to finish before starting a new leadership operation.  */ ;/**  * Tests that the {@link JobManagerRunner} always waits for the previous leadership operation  * (granting or revoking leadership) to finish before starting a new leadership operation.  */ @Test public void testConcurrentLeadershipOperationsBlockingSuspend() throws Exception {     final CompletableFuture<Acknowledge> suspendedFuture = new CompletableFuture<>().     TestingJobMasterServiceFactory jobMasterServiceFactory = new TestingJobMasterServiceFactory(() -> new TestingJobMasterService("localhost", e -> suspendedFuture)).     JobManagerRunner jobManagerRunner = createJobManagerRunner(jobMasterServiceFactory).     jobManagerRunner.start().     leaderElectionService.isLeader(UUID.randomUUID()).get().     leaderElectionService.notLeader().     final CompletableFuture<UUID> leaderFuture = leaderElectionService.isLeader(UUID.randomUUID()).     // the new leadership should wait first for the suspension to happen     assertThat(leaderFuture.isDone(), is(false)).     try {         leaderFuture.get(1L, TimeUnit.MILLISECONDS).         fail("Granted leadership even though the JobMaster has not been suspended.").     } catch (TimeoutException expected) {     // expected     }     suspendedFuture.complete(Acknowledge.get()).     leaderFuture.get(). }
true;public;0;35;/**  * Tests that the {@link JobManagerRunner} always waits for the previous leadership operation  * (granting or revoking leadership) to finish before starting a new leadership operation.  */ ;/**  * Tests that the {@link JobManagerRunner} always waits for the previous leadership operation  * (granting or revoking leadership) to finish before starting a new leadership operation.  */ @Test public void testConcurrentLeadershipOperationsBlockingGainLeadership() throws Exception {     final CompletableFuture<Exception> suspendFuture = new CompletableFuture<>().     final CompletableFuture<Acknowledge> startFuture = new CompletableFuture<>().     TestingJobMasterServiceFactory jobMasterServiceFactory = new TestingJobMasterServiceFactory(() -> new TestingJobMasterService("localhost", e -> {         suspendFuture.complete(e).         return CompletableFuture.completedFuture(Acknowledge.get()).     }, ignored -> startFuture)).     JobManagerRunner jobManagerRunner = createJobManagerRunner(jobMasterServiceFactory).     jobManagerRunner.start().     leaderElectionService.isLeader(UUID.randomUUID()).     leaderElectionService.notLeader().     // suspending should wait for the start to happen first     assertThat(suspendFuture.isDone(), is(false)).     try {         suspendFuture.get(1L, TimeUnit.MILLISECONDS).         fail("Suspended leadership even though the JobMaster has not been started.").     } catch (TimeoutException expected) {     // expected     }     startFuture.complete(Acknowledge.get()).     suspendFuture.get(). }
false;private;1;4;;@Nonnull private JobManagerRunner createJobManagerRunner(LibraryCacheManager libraryCacheManager) throws Exception {     return createJobManagerRunner(defaultJobMasterServiceFactory, libraryCacheManager). }
false;private;0;4;;@Nonnull private JobManagerRunner createJobManagerRunner() throws Exception {     return createJobManagerRunner(defaultJobMasterServiceFactory, libraryCacheManager). }
false;private;1;4;;@Nonnull private JobManagerRunner createJobManagerRunner(JobMasterServiceFactory jobMasterServiceFactory) throws Exception {     return createJobManagerRunner(jobMasterServiceFactory, libraryCacheManager). }
false;private;2;10;;@Nonnull private JobManagerRunner createJobManagerRunner(JobMasterServiceFactory jobMasterServiceFactory, LibraryCacheManager libraryCacheManager) throws Exception {     return new JobManagerRunner(jobGraph, jobMasterServiceFactory, haServices, libraryCacheManager, TestingUtils.defaultExecutor(), fatalErrorHandler). }
