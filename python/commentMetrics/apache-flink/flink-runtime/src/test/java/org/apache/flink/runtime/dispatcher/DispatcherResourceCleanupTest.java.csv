commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setupClass() {     rpcService = new TestingRpcService(). }
false;public;0;71;;@Before public void setup() throws Exception {     final JobVertex testVertex = new JobVertex("testVertex").     testVertex.setInvokableClass(NoOpInvokable.class).     jobId = new JobID().     jobGraph = new JobGraph(jobId, "testJob", testVertex).     jobGraph.setAllowQueuedScheduling(true).     configuration = new Configuration().     configuration.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath()).     highAvailabilityServices = new TestingHighAvailabilityServices().     dispatcherLeaderElectionService = new TestingLeaderElectionService().     highAvailabilityServices.setDispatcherLeaderElectionService(dispatcherLeaderElectionService).     clearedJobLatch = new OneShotLatch().     runningJobsRegistry = new SingleRunningJobsRegistry(jobId, clearedJobLatch).     highAvailabilityServices.setRunningJobsRegistry(runningJobsRegistry).     submittedJobGraphStore = new FaultySubmittedJobGraphStore().     highAvailabilityServices.setSubmittedJobGraphStore(submittedJobGraphStore).     storedHABlobFuture = new CompletableFuture<>().     deleteAllHABlobsFuture = new CompletableFuture<>().     final TestingBlobStore testingBlobStore = new TestingBlobStoreBuilder().setPutFunction(putArguments -> storedHABlobFuture.complete(putArguments.f2)).setDeleteAllFunction(deleteAllHABlobsFuture::complete).createTestingBlobStore().     cleanupJobFuture = new CompletableFuture<>().     terminationFuture = new CompletableFuture<>().     blobServer = new TestingBlobServer(configuration, testingBlobStore, cleanupJobFuture).     // upload a blob to the blob server     permanentBlobKey = blobServer.putPermanent(jobId, new byte[256]).     jobGraph.addUserJarBlobKey(permanentBlobKey).     blobFile = blobServer.getStorageLocation(jobId, permanentBlobKey).     resultFuture = new CompletableFuture<>().     fatalErrorHandler = new TestingFatalErrorHandler().     failJobMasterCreationWith = new AtomicReference<>().     TestingResourceManagerGateway resourceManagerGateway = new TestingResourceManagerGateway().     dispatcher = new TestingDispatcher(rpcService, Dispatcher.DISPATCHER_NAME + UUID.randomUUID(), configuration, highAvailabilityServices, () -> CompletableFuture.completedFuture(resourceManagerGateway), blobServer, new HeartbeatServices(1000L, 1000L), UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(), null, new MemoryArchivedExecutionGraphStore(), new TestingJobManagerRunnerFactory(new CompletableFuture<>(), resultFuture, terminationFuture, failJobMasterCreationWith), fatalErrorHandler).     dispatcher.start().     dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     assertThat(blobFile.exists(), is(true)).     // verify that we stored the blob also in the BlobStore     assertThat(storedHABlobFuture.get(), equalTo(permanentBlobKey)). }
false;public;0;10;;@After public void teardown() throws Exception {     if (dispatcher != null) {         dispatcher.close().     }     if (fatalErrorHandler != null) {         fatalErrorHandler.rethrowError().     } }
false;public,static;0;6;;@AfterClass public static void teardownClass() throws ExecutionException, InterruptedException {     if (rpcService != null) {         rpcService.stopService().get().     } }
false;public;0;10;;@Test public void testBlobServerCleanupWhenJobFinished() throws Exception {     submitJob().     // complete the job     resultFuture.complete(new ArchivedExecutionGraphBuilder().setJobID(jobId).setState(JobStatus.FINISHED).build()).     terminationFuture.complete(null).     assertThatHABlobsHaveBeenRemoved(). }
false;private;0;8;;private void assertThatHABlobsHaveBeenRemoved() throws InterruptedException, ExecutionException {     assertThat(cleanupJobFuture.get(), equalTo(jobId)).     // verify that we also cleared the BlobStore     assertThat(deleteAllHABlobsFuture.get(), equalTo(jobId)).     assertThat(blobFile.exists(), is(false)). }
false;private;0;4;;private void submitJob() throws InterruptedException, ExecutionException {     final CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(jobGraph, timeout).     submissionFuture.get(). }
false;public;0;22;;@Test public void testBlobServerCleanupWhenJobNotFinished() throws Exception {     submitJob().     // job not finished     resultFuture.completeExceptionally(new JobNotFinishedException(jobId)).     terminationFuture.complete(null).     assertThat(cleanupJobFuture.get(), equalTo(jobId)).     assertThat(blobFile.exists(), is(false)).     // verify that we did not clear the BlobStore     try {         deleteAllHABlobsFuture.get(50L, TimeUnit.MILLISECONDS).         fail("We should not delete the HA blobs.").     } catch (TimeoutException ignored) {     // expected     }     assertThat(deleteAllHABlobsFuture.isDone(), is(false)). }
true;public;0;14;/**  * Tests that the uploaded blobs are being cleaned up in case of a job submission failure.  */ ;/**  * Tests that the uploaded blobs are being cleaned up in case of a job submission failure.  */ @Test public void testBlobServerCleanupWhenJobSubmissionFails() throws Exception {     failJobMasterCreationWith.set(() -> new FlinkException("Test exception.")).     final CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(jobGraph, timeout).     try {         submissionFuture.get().         fail("Job submission was expected to fail.").     } catch (ExecutionException ee) {         assertThat(ExceptionUtils.findThrowable(ee, JobSubmissionException.class).isPresent(), is(true)).     }     assertThatHABlobsHaveBeenRemoved(). }
false;public;0;22;;@Test public void testBlobServerCleanupWhenClosingDispatcher() throws Exception {     submitJob().     dispatcher.closeAsync().     terminationFuture.complete(null).     dispatcher.getTerminationFuture().get().     assertThat(cleanupJobFuture.get(), equalTo(jobId)).     assertThat(blobFile.exists(), is(false)).     // verify that we did not clear the BlobStore     try {         deleteAllHABlobsFuture.get(50L, TimeUnit.MILLISECONDS).         fail("We should not delete the HA blobs.").     } catch (TimeoutException ignored) {     // expected     }     assertThat(deleteAllHABlobsFuture.isDone(), is(false)). }
true;public;0;15;/**  * Tests that the {@link RunningJobsRegistry} entries are cleared after the  * job reached a terminal state.  */ ;/**  * Tests that the {@link RunningJobsRegistry} entries are cleared after the  * job reached a terminal state.  */ @Test public void testRunningJobsRegistryCleanup() throws Exception {     submitJob().     runningJobsRegistry.setJobRunning(jobId).     assertThat(runningJobsRegistry.contains(jobId), is(true)).     resultFuture.complete(new ArchivedExecutionGraphBuilder().setState(JobStatus.FINISHED).setJobID(jobId).build()).     terminationFuture.complete(null).     // wait for the clearing     clearedJobLatch.await().     assertThat(runningJobsRegistry.contains(jobId), is(false)). }
true;public;0;21;/**  * Tests that the previous JobManager needs to be completely terminated  * before a new job with the same {@link JobID} is started.  */ ;/**  * Tests that the previous JobManager needs to be completely terminated  * before a new job with the same {@link JobID} is started.  */ @Test public void testJobSubmissionUnderSameJobId() throws Exception {     submitJob().     runningJobsRegistry.setJobRunning(jobId).     resultFuture.completeExceptionally(new JobNotFinishedException(jobId)).     final CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(jobGraph, timeout).     try {         submissionFuture.get(10L, TimeUnit.MILLISECONDS).         fail("The job submission future should not complete until the previous JobManager " + "termination future has been completed.").     } catch (TimeoutException ignored) {     // expected     } finally {         terminationFuture.complete(null).     }     assertThat(submissionFuture.get(), equalTo(Acknowledge.get())). }
true;public;0;20;/**  * Tests that recovered jobs will only be started after the complete termination of any  * other previously running JobMasters for the same job.  */ ;/**  * Tests that recovered jobs will only be started after the complete termination of any  * other previously running JobMasters for the same job.  */ @Test public void testJobRecoveryWithPendingTermination() throws Exception {     submitJob().     runningJobsRegistry.setJobRunning(jobId).     dispatcherLeaderElectionService.notLeader().     final UUID leaderSessionId = UUID.randomUUID().     final CompletableFuture<UUID> leaderFuture = dispatcherLeaderElectionService.isLeader(leaderSessionId).     try {         leaderFuture.get(10L, TimeUnit.MILLISECONDS).         fail("We should not become leader before all previously running JobMasters have terminated.").     } catch (TimeoutException ignored) {     // expected     } finally {         terminationFuture.complete(null).     }     assertThat(leaderFuture.get(), equalTo(leaderSessionId)). }
false;public;1;6;;@Override public void setJobRunning(JobID jobID) {     checkJobId(jobID).     containsJob = true.     jobSchedulingStatus = JobSchedulingStatus.RUNNING. }
false;private;1;3;;private void checkJobId(JobID jobID) {     Preconditions.checkArgument(expectedJobId.equals(jobID)). }
false;public;1;6;;@Override public void setJobFinished(JobID jobID) {     checkJobId(jobID).     containsJob = true.     jobSchedulingStatus = JobSchedulingStatus.DONE. }
false;public;1;5;;@Override public JobSchedulingStatus getJobSchedulingStatus(JobID jobID) {     checkJobId(jobID).     return jobSchedulingStatus. }
false;public;1;4;;public boolean contains(JobID jobId) {     checkJobId(jobId).     return containsJob. }
false;public;1;6;;@Override public void clearJob(JobID jobID) {     checkJobId(jobID).     containsJob = false.     clearedJobLatch.trigger(). }
false;public;0;16;;@Test public void testHABlobsAreNotRemovedIfHAJobGraphRemovalFails() throws Exception {     submittedJobGraphStore.setRemovalFailure(new Exception("Failed to Remove future")).     submitJob().     ArchivedExecutionGraph executionGraph = new ArchivedExecutionGraphBuilder().setJobID(jobId).setState(JobStatus.CANCELED).build().     resultFuture.complete(executionGraph).     terminationFuture.complete(null).     assertThat(cleanupJobFuture.get(), equalTo(jobId)).     assertThat(deleteAllHABlobsFuture.isDone(), is(false)). }
false;public;0;15;;@Test public void testHABlobsAreRemovedIfHAJobGraphRemovalSucceeds() throws Exception {     submitJob().     ArchivedExecutionGraph executionGraph = new ArchivedExecutionGraphBuilder().setJobID(jobId).setState(JobStatus.CANCELED).build().     resultFuture.complete(executionGraph).     terminationFuture.complete(null).     assertThat(cleanupJobFuture.get(), equalTo(jobId)).     assertThat(deleteAllHABlobsFuture.get(), equalTo(jobId)). }
false;public;2;6;;@Override public boolean cleanupJob(JobID jobId, boolean cleanupBlobStoreFiles) {     final boolean result = super.cleanupJob(jobId, cleanupBlobStoreFiles).     cleanupJobFuture.complete(jobId).     return result. }
