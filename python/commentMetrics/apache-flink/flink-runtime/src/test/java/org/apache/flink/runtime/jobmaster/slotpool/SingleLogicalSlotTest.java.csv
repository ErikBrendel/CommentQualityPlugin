commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Test public void testPayloadAssignment() {     final SingleLogicalSlot singleLogicalSlot = createSingleLogicalSlot().     final DummyPayload dummyPayload1 = new DummyPayload().     final DummyPayload dummyPayload2 = new DummyPayload().     assertThat(singleLogicalSlot.tryAssignPayload(dummyPayload1), is(true)).     assertThat(singleLogicalSlot.tryAssignPayload(dummyPayload2), is(false)).     assertThat(singleLogicalSlot.getPayload(), sameInstance(dummyPayload1)). }
false;private;0;3;;private SingleLogicalSlot createSingleLogicalSlot() {     return createSingleLogicalSlot(new DummySlotOwner()). }
false;private;1;8;;private SingleLogicalSlot createSingleLogicalSlot(SlotOwner slotOwner) {     return new SingleLogicalSlot(new SlotRequestId(), new DummySlotContext(), null, Locality.LOCAL, slotOwner). }
false;public;0;18;;@Test public void testAlive() throws Exception {     final SingleLogicalSlot singleLogicalSlot = createSingleLogicalSlot().     final DummyPayload dummyPayload = new DummyPayload().     assertThat(singleLogicalSlot.isAlive(), is(true)).     assertThat(singleLogicalSlot.tryAssignPayload(dummyPayload), is(true)).     assertThat(singleLogicalSlot.isAlive(), is(true)).     final CompletableFuture<?> releaseFuture = singleLogicalSlot.releaseSlot(new FlinkException("Test exception")).     assertThat(singleLogicalSlot.isAlive(), is(false)).     releaseFuture.get().     assertThat(singleLogicalSlot.isAlive(), is(false)). }
false;public;0;9;;@Test public void testPayloadAssignmentAfterRelease() {     final SingleLogicalSlot singleLogicalSlot = createSingleLogicalSlot().     final DummyPayload dummyPayload = new DummyPayload().     singleLogicalSlot.releaseSlot(new FlinkException("Test exception")).     assertThat(singleLogicalSlot.tryAssignPayload(dummyPayload), is(false)). }
true;public;0;19;/**  * Tests that the {@link PhysicalSlot.Payload#release(Throwable)} does not wait  * for the payload to reach a terminal state.  */ ;/**  * Tests that the {@link PhysicalSlot.Payload#release(Throwable)} does not wait  * for the payload to reach a terminal state.  */ @Test public void testAllocatedSlotRelease() {     final CompletableFuture<LogicalSlot> returnSlotFuture = new CompletableFuture<>().     final WaitingSlotOwner waitingSlotOwner = new WaitingSlotOwner(returnSlotFuture, new CompletableFuture<>()).     final SingleLogicalSlot singleLogicalSlot = createSingleLogicalSlot(waitingSlotOwner).     final CompletableFuture<?> terminalStateFuture = new CompletableFuture<>().     final CompletableFuture<?> failFuture = new CompletableFuture<>().     final ManualTestingPayload dummyPayload = new ManualTestingPayload(failFuture, terminalStateFuture).     assertThat(singleLogicalSlot.tryAssignPayload(dummyPayload), is(true)).     singleLogicalSlot.release(new FlinkException("Test exception")).     assertThat(failFuture.isDone(), is(true)).     // we don't require the logical slot to return to the owner because     // the release call should only come from the owner     assertThat(returnSlotFuture.isDone(), is(false)). }
true;public;0;27;/**  * Tests that the slot release is only signaled after the owner has  * taken it back.  */ ;/**  * Tests that the slot release is only signaled after the owner has  * taken it back.  */ @Test public void testSlotRelease() {     final CompletableFuture<LogicalSlot> returnedSlotFuture = new CompletableFuture<>().     final CompletableFuture<Boolean> returnSlotResponseFuture = new CompletableFuture<>().     final WaitingSlotOwner waitingSlotOwner = new WaitingSlotOwner(returnedSlotFuture, returnSlotResponseFuture).     final CompletableFuture<?> terminalStateFuture = new CompletableFuture<>().     final CompletableFuture<?> failFuture = new CompletableFuture<>().     final ManualTestingPayload dummyPayload = new ManualTestingPayload(failFuture, terminalStateFuture).     final SingleLogicalSlot singleLogicalSlot = createSingleLogicalSlot(waitingSlotOwner).     assertThat(singleLogicalSlot.tryAssignPayload(dummyPayload), is(true)).     final CompletableFuture<?> releaseFuture = singleLogicalSlot.releaseSlot(new FlinkException("Test exception")).     assertThat(releaseFuture.isDone(), is(false)).     assertThat(returnedSlotFuture.isDone(), is(false)).     assertThat(failFuture.isDone(), is(true)).     terminalStateFuture.complete(null).     assertThat(returnedSlotFuture.isDone(), is(true)).     returnSlotResponseFuture.complete(true).     assertThat(releaseFuture.isDone(), is(true)). }
true;public;0;38;/**  * Tests that concurrent release operations only trigger the failing of the payload and  * the return of the slot once.  */ ;/**  * Tests that concurrent release operations only trigger the failing of the payload and  * the return of the slot once.  */ @Test public void testConcurrentReleaseOperations() throws Exception {     final CountingSlotOwner countingSlotOwner = new CountingSlotOwner().     final CountingFailPayload countingFailPayload = new CountingFailPayload().     final SingleLogicalSlot singleLogicalSlot = createSingleLogicalSlot(countingSlotOwner).     singleLogicalSlot.tryAssignPayload(countingFailPayload).     final ExecutorService executorService = Executors.newFixedThreadPool(4).     try {         final int numberConcurrentOperations = 10.         final Collection<CompletableFuture<?>> releaseOperationFutures = new ArrayList<>(numberConcurrentOperations).         for (int i = 0. i < numberConcurrentOperations. i++) {             final CompletableFuture<Void> releaseOperationFuture = CompletableFuture.runAsync(() -> {                 try {                     singleLogicalSlot.releaseSlot(new FlinkException("Test exception")).get().                 } catch (InterruptedException | ExecutionException e) {                     ExceptionUtils.checkInterrupted(e).                     throw new CompletionException(e).                 }             }).             releaseOperationFutures.add(releaseOperationFuture).         }         final FutureUtils.ConjunctFuture<Void> releaseOperationsFuture = FutureUtils.waitForAll(releaseOperationFutures).         releaseOperationsFuture.get().         assertThat(countingSlotOwner.getReleaseCount(), is(1)).         assertThat(countingFailPayload.getFailCount(), is(1)).     } finally {         executorService.shutdownNow().     } }
false;;0;3;;int getFailCount() {     return failCounter.get(). }
false;public;1;4;;@Override public void fail(Throwable cause) {     failCounter.incrementAndGet(). }
false;public;0;4;;@Override public CompletableFuture<?> getTerminalStateFuture() {     return CompletableFuture.completedFuture(null). }
false;public;0;3;;public int getReleaseCount() {     return counter.get(). }
false;public;1;4;;@Override public void returnLogicalSlot(LogicalSlot logicalSlot) {     counter.incrementAndGet(). }
false;public;1;4;;@Override public void fail(Throwable cause) {     failFuture.completeExceptionally(cause). }
false;public;0;4;;@Override public CompletableFuture<?> getTerminalStateFuture() {     return terminalStateFuture. }
false;public;1;4;;@Override public void returnLogicalSlot(LogicalSlot logicalSlot) {     returnAllocatedSlotFuture.complete(logicalSlot). }
false;public;0;4;;@Override public AllocationID getAllocationId() {     return allocationId. }
false;public;0;4;;@Override public TaskManagerLocation getTaskManagerLocation() {     return taskManagerLocation. }
false;public;0;4;;@Override public int getPhysicalSlotNumber() {     return 0. }
false;public;0;4;;@Override public ResourceProfile getResourceProfile() {     return ResourceProfile.UNKNOWN. }
false;public;0;4;;@Override public TaskManagerGateway getTaskManagerGateway() {     return taskManagerGateway. }
