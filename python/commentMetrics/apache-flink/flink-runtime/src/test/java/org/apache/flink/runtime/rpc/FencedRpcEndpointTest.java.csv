# id;timestamp;commentText;codeText;commentWords;codeWords
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1504474506;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, initialFencingToken, value)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,initial,fencing,token,value,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1506034747;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1506417942;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1515481550;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1519406526;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1519406528;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1522681180;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1526494919;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1549365080;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1550005039;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testUnfencedRemoteGateway() throws Exception;1550005040;Tests that all calls from an unfenced remote gateway are ignored and that one cannot obtain_the fencing token from such a gateway.;@Test_	public void testUnfencedRemoteGateway() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway unfencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			try {_				unfencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we have an unfenced gateway.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof RpcException)__			}__			try {_				unfencedGateway.getFencingToken()__				fail("We should not be able to call getFencingToken on an unfenced gateway.")__			} catch (UnsupportedOperationException ignored) {_				_			}_		} finally {_			RpcUtils.terminateRpcEndpoint(fencedTestingEndpoint, timeout)__		}_	};tests,that,all,calls,from,an,unfenced,remote,gateway,are,ignored,and,that,one,cannot,obtain,the,fencing,token,from,such,a,gateway;test,public,void,test,unfenced,remote,gateway,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,unfenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,try,unfenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,have,an,unfenced,gateway,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,rpc,exception,try,unfenced,gateway,get,fencing,token,fail,we,should,not,be,able,to,call,get,fencing,token,on,an,unfenced,gateway,catch,unsupported,operation,exception,ignored,finally,rpc,utils,terminate,rpc,endpoint,fenced,testing,endpoint,timeout
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1504474506;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, initialFencingToken, value)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenMismatchException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = properFencedGateway.rpcSetFencingToken(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenMismatchException)__			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,initial,fencing,token,value,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,mismatch,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,proper,fenced,gateway,rpc,set,fencing,token,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,mismatch,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1506034747;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID fencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, fencingToken)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), fencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fencing,token,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1506417942;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID fencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, fencingToken)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), fencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fencing,token,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1515481550;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID fencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, fencingToken)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), fencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fencing,token,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1519406526;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID fencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, fencingToken)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), fencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fencing,token,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1519406528;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID fencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, fencingToken)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), fencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fencing,token,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1522681180;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID fencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, fencingToken)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), fencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fencing,token,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1526494919;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID fencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, fencingToken)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), fencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fencing,token,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1549365080;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID fencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, fencingToken)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), fencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fencing,token,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1550005039;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID fencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, fencingToken)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), fencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fencing,token,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencing() throws Exception;1550005040;Tests that messages with the wrong fencing token are filtered out.;@Test_	public void testFencing() throws Exception {_		final UUID fencingToken = UUID.randomUUID()__		final UUID wrongFencingToken = UUID.randomUUID()__		final String value = "barfoo"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, fencingToken)___		try {_			fencedTestingEndpoint.start()___			final FencedTestingGateway properFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), fencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__			final FencedTestingGateway wronglyFencedGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), wrongFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(value, properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				wronglyFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should fail since we have the wrong fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__			final UUID newFencingToken = UUID.randomUUID()___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				properFencedGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___				fail("This should fail since we have the wrong fencing token by now.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}__		} finally {_			RpcUtils.terminateRpcEndpoint(fencedTestingEndpoint, timeout)__		}_	};tests,that,messages,with,the,wrong,fencing,token,are,filtered,out;test,public,void,test,fencing,throws,exception,final,uuid,fencing,token,uuid,random,uuid,final,uuid,wrong,fencing,token,uuid,random,uuid,final,string,value,barfoo,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fencing,token,try,fenced,testing,endpoint,start,final,fenced,testing,gateway,proper,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,final,fenced,testing,gateway,wrongly,fenced,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,wrong,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,wrongly,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,proper,fenced,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,fail,since,we,have,the,wrong,fencing,token,by,now,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,rpc,utils,terminate,rpc,endpoint,fenced,testing,endpoint,timeout
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1504474506;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, initialFencingToken, value)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = selfGateway.rpcSetFencingToken(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,initial,fencing,token,value,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,self,gateway,rpc,set,fencing,token,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1506034747;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1506417942;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1515481550;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1519406526;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1519406528;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1522681180;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1526494919;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1549365080;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1550005039;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception;1550005040;Tests that call via the MainThreadExecutor fail after the fencing token changes.;@Test_	public void testMainThreadExecutorUnderChangingFencingToken() throws Exception {_		final Time shortTimeout = Time.milliseconds(100L)__		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___			CompletableFuture<Acknowledge> mainThreadExecutorComputation = selfGateway.triggerMainThreadExecutorComputation(timeout)___			_			_			_			final UUID newFencingToken = UUID.randomUUID()__			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			CompletableFuture<Acknowledge> triggerFuture = selfGateway.triggerComputationLatch(timeout)___			triggerFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			try {_				mainThreadExecutorComputation.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("The MainThreadExecutor computation should be able to complete because it was filtered out leading to a timeout exception.")__			} catch (TimeoutException ignored) {_				_			}__		} finally {_			RpcUtils.terminateRpcEndpoint(fencedTestingEndpoint, timeout)__		}_	};tests,that,call,via,the,main,thread,executor,fail,after,the,fencing,token,changes;test,public,void,test,main,thread,executor,under,changing,fencing,token,throws,exception,final,time,short,timeout,time,milliseconds,100l,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,completable,future,acknowledge,main,thread,executor,computation,self,gateway,trigger,main,thread,executor,computation,timeout,final,uuid,new,fencing,token,uuid,random,uuid,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,trigger,future,self,gateway,trigger,computation,latch,timeout,trigger,future,get,timeout,to,milliseconds,time,unit,milliseconds,try,main,thread,executor,computation,get,short,timeout,to,milliseconds,time,unit,milliseconds,fail,the,main,thread,executor,computation,should,be,able,to,complete,because,it,was,filtered,out,leading,to,a,timeout,exception,catch,timeout,exception,ignored,finally,rpc,utils,terminate,rpc,endpoint,fenced,testing,endpoint,timeout
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1504474506;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, initialFencingToken, value)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = selfGateway.rpcSetFencingToken(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenMismatchException)__			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,initial,fencing,token,value,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,self,gateway,rpc,set,fencing,token,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,mismatch,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1506034747;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1506417942;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1515481550;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1519406526;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1519406528;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1522681180;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1526494919;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1549365080;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1550005039;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}_		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testRemoteAndSelfGateways() throws Exception;1550005040;Tests that the self gateway always uses the current fencing token whereas the remote_gateway has a fixed fencing token.;@Test_	public void testRemoteAndSelfGateways() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final UUID newFencingToken = UUID.randomUUID()__		final String value = "foobar"___		final FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value, initialFencingToken)___		try {_			fencedTestingEndpoint.start()___			FencedTestingGateway selfGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__			FencedTestingGateway remoteGateway = rpcService.connect(fencedTestingEndpoint.getAddress(), initialFencingToken, FencedTestingGateway.class)_				.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(initialFencingToken, selfGateway.getFencingToken())__			assertEquals(initialFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))__			assertEquals(value, remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			assertEquals(newFencingToken, selfGateway.getFencingToken())__			assertNotEquals(newFencingToken, remoteGateway.getFencingToken())___			assertEquals(value, selfGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS))___			try {_				remoteGateway.foobar(timeout).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__				fail("This should have failed because we don't have the right fencing token.")__			} catch (ExecutionException e) {_				assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException)__			}_		} finally {_			RpcUtils.terminateRpcEndpoint(fencedTestingEndpoint, timeout)__		}_	};tests,that,the,self,gateway,always,uses,the,current,fencing,token,whereas,the,remote,gateway,has,a,fixed,fencing,token;test,public,void,test,remote,and,self,gateways,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,uuid,new,fencing,token,uuid,random,uuid,final,string,value,foobar,final,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,initial,fencing,token,try,fenced,testing,endpoint,start,fenced,testing,gateway,self,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,remote,gateway,rpc,service,connect,fenced,testing,endpoint,get,address,initial,fencing,token,fenced,testing,gateway,class,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,initial,fencing,token,self,gateway,get,fencing,token,assert,equals,initial,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,value,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,completable,future,acknowledge,new,fencing,token,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,new,fencing,token,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,self,gateway,get,fencing,token,assert,not,equals,new,fencing,token,remote,gateway,get,fencing,token,assert,equals,value,self,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,try,remote,gateway,foobar,timeout,get,timeout,to,milliseconds,time,unit,milliseconds,fail,this,should,have,failed,because,we,don,t,have,the,right,fencing,token,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,fencing,token,exception,finally,rpc,utils,terminate,rpc,endpoint,fenced,testing,endpoint,timeout
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1504474506;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final UUID initialFencingToken = UUID.randomUUID()__		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, initialFencingToken, value)__		FencedTestingGateway fencedTestingGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertEquals(initialFencingToken, fencedGateway.getFencingToken())__			assertEquals(initialFencingToken, fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				fail("Fencing token can only be set from within the main thread.")__			} catch (AssertionError ignored) {_				_			}__			assertEquals(initialFencingToken, fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingGateway.rpcSetFencingToken(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,uuid,initial,fencing,token,uuid,random,uuid,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,initial,fencing,token,value,fenced,testing,gateway,fenced,testing,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,equals,initial,fencing,token,fenced,gateway,get,fencing,token,assert,equals,initial,fencing,token,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,fail,fencing,token,can,only,be,set,from,within,the,main,thread,catch,assertion,error,ignored,assert,equals,initial,fencing,token,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,gateway,rpc,set,fencing,token,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1506034747;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertNull(fencedGateway.getFencingToken())__			assertNull(fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				fail("Fencing token can only be set from within the main thread.")__			} catch (AssertionError ignored) {_				_			}__			assertNull(fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,null,fenced,gateway,get,fencing,token,assert,null,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,fail,fencing,token,can,only,be,set,from,within,the,main,thread,catch,assertion,error,ignored,assert,null,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1506417942;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertNull(fencedGateway.getFencingToken())__			assertNull(fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				fail("Fencing token can only be set from within the main thread.")__			} catch (AssertionError ignored) {_				_			}__			assertNull(fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,null,fenced,gateway,get,fencing,token,assert,null,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,fail,fencing,token,can,only,be,set,from,within,the,main,thread,catch,assertion,error,ignored,assert,null,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1515481550;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertNull(fencedGateway.getFencingToken())__			assertNull(fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				fail("Fencing token can only be set from within the main thread.")__			} catch (AssertionError ignored) {_				_			}__			assertNull(fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,null,fenced,gateway,get,fencing,token,assert,null,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,fail,fencing,token,can,only,be,set,from,within,the,main,thread,catch,assertion,error,ignored,assert,null,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1519406526;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertNull(fencedGateway.getFencingToken())__			assertNull(fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				fail("Fencing token can only be set from within the main thread.")__			} catch (AssertionError ignored) {_				_			}__			assertNull(fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,null,fenced,gateway,get,fencing,token,assert,null,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,fail,fencing,token,can,only,be,set,from,within,the,main,thread,catch,assertion,error,ignored,assert,null,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1519406528;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertNull(fencedGateway.getFencingToken())__			assertNull(fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				fail("Fencing token can only be set from within the main thread.")__			} catch (AssertionError ignored) {_				_			}__			assertNull(fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,null,fenced,gateway,get,fencing,token,assert,null,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,fail,fencing,token,can,only,be,set,from,within,the,main,thread,catch,assertion,error,ignored,assert,null,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1522681180;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertNull(fencedGateway.getFencingToken())__			assertNull(fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				fail("Fencing token can only be set from within the main thread.")__			} catch (AssertionError ignored) {_				_			}__			assertNull(fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,null,fenced,gateway,get,fencing,token,assert,null,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,fail,fencing,token,can,only,be,set,from,within,the,main,thread,catch,assertion,error,ignored,assert,null,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1526494919;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertNull(fencedGateway.getFencingToken())__			assertNull(fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				fail("Fencing token can only be set from within the main thread.")__			} catch (AssertionError ignored) {_				_			}__			assertNull(fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,null,fenced,gateway,get,fencing,token,assert,null,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,fail,fencing,token,can,only,be,set,from,within,the,main,thread,catch,assertion,error,ignored,assert,null,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1549365080;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertNull(fencedGateway.getFencingToken())__			assertNull(fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			boolean failed = false__			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				failed = true__			} catch (AssertionError ignored) {_				_			}__			assertFalse("Setting fencing token from outside the main thread did not fail as expected.", failed)__			assertNull(fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,null,fenced,gateway,get,fencing,token,assert,null,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,boolean,failed,false,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,failed,true,catch,assertion,error,ignored,assert,false,setting,fencing,token,from,outside,the,main,thread,did,not,fail,as,expected,failed,assert,null,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1550005039;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertNull(fencedGateway.getFencingToken())__			assertNull(fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			boolean failed = false__			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				failed = true__			} catch (AssertionError ignored) {_				_			}__			assertFalse("Setting fencing token from outside the main thread did not fail as expected.", failed)__			assertNull(fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			fencedTestingEndpoint.shutDown()__			fencedTestingEndpoint.getTerminationFuture().get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,null,fenced,gateway,get,fencing,token,assert,null,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,boolean,failed,false,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,failed,true,catch,assertion,error,ignored,assert,false,setting,fencing,token,from,outside,the,main,thread,did,not,fail,as,expected,failed,assert,null,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,fenced,testing,endpoint,shut,down,fenced,testing,endpoint,get,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
FencedRpcEndpointTest -> @Test 	public void testFencingTokenSetting() throws Exception;1550005040;Tests that the fencing token can be retrieved from the FencedRpcEndpoint and self_FencedRpcGateway. Moreover it tests that you can only set the fencing token from_the main thread.;@Test_	public void testFencingTokenSetting() throws Exception {_		final String value = "foobar"__		FencedTestingEndpoint fencedTestingEndpoint = new FencedTestingEndpoint(rpcService, value)__		FencedTestingGateway fencedGateway = fencedTestingEndpoint.getSelfGateway(FencedTestingGateway.class)___		try {_			fencedTestingEndpoint.start()___			assertNull(fencedGateway.getFencingToken())__			assertNull(fencedTestingEndpoint.getFencingToken())___			final UUID newFencingToken = UUID.randomUUID()___			boolean failed = false__			try {_				fencedTestingEndpoint.setFencingToken(newFencingToken)__				failed = true__			} catch (AssertionError ignored) {_				_			}__			assertFalse("Setting fencing token from outside the main thread did not fail as expected.", failed)__			assertNull(fencedTestingEndpoint.getFencingToken())___			CompletableFuture<Acknowledge> setFencingFuture = fencedTestingEndpoint.setFencingTokenInMainThread(newFencingToken, timeout)___			_			setFencingFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___			_			assertEquals(newFencingToken, fencedGateway.getFencingToken())__			assertEquals(newFencingToken, fencedTestingEndpoint.getFencingToken())__		} finally {_			RpcUtils.terminateRpcEndpoint(fencedTestingEndpoint, timeout)__		}_	};tests,that,the,fencing,token,can,be,retrieved,from,the,fenced,rpc,endpoint,and,self,fenced,rpc,gateway,moreover,it,tests,that,you,can,only,set,the,fencing,token,from,the,main,thread;test,public,void,test,fencing,token,setting,throws,exception,final,string,value,foobar,fenced,testing,endpoint,fenced,testing,endpoint,new,fenced,testing,endpoint,rpc,service,value,fenced,testing,gateway,fenced,gateway,fenced,testing,endpoint,get,self,gateway,fenced,testing,gateway,class,try,fenced,testing,endpoint,start,assert,null,fenced,gateway,get,fencing,token,assert,null,fenced,testing,endpoint,get,fencing,token,final,uuid,new,fencing,token,uuid,random,uuid,boolean,failed,false,try,fenced,testing,endpoint,set,fencing,token,new,fencing,token,failed,true,catch,assertion,error,ignored,assert,false,setting,fencing,token,from,outside,the,main,thread,did,not,fail,as,expected,failed,assert,null,fenced,testing,endpoint,get,fencing,token,completable,future,acknowledge,set,fencing,future,fenced,testing,endpoint,set,fencing,token,in,main,thread,new,fencing,token,timeout,set,fencing,future,get,timeout,to,milliseconds,time,unit,milliseconds,assert,equals,new,fencing,token,fenced,gateway,get,fencing,token,assert,equals,new,fencing,token,fenced,testing,endpoint,get,fencing,token,finally,rpc,utils,terminate,rpc,endpoint,fenced,testing,endpoint,timeout
