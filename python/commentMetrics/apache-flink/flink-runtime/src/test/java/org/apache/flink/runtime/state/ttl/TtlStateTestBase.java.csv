commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void setup() {     timeProvider = new MockTtlTimeProvider().     sbetc = createStateBackendTestContext(timeProvider). }
false;protected,abstract;1;1;;protected abstract StateBackendTestContext createStateBackendTestContext(TtlTimeProvider timeProvider).
false;public,static;0;13;;@Parameterized.Parameters(name = "{0}") public static List<TtlStateTestContextBase<?, ?, ?>> testContexts() {     return Arrays.asList(new TtlValueStateTestContext(), new TtlFixedLenElemListStateTestContext(), new TtlNonFixedLenElemListStateTestContext(), new TtlMapStateAllEntriesTestContext(), new TtlMapStatePerElementTestContext(), new TtlMapStatePerNullElementTestContext(), new TtlAggregatingStateTestContext(), new TtlReducingStateTestContext(), new TtlFoldingStateTestContext()). }
false;public;0;3;;public boolean fullSnapshot() {     return true. }
false;protected;0;4;;@SuppressWarnings("unchecked") protected <S extends InternalKvState<?, String, ?>, UV> TtlStateTestContextBase<S, UV, ?> ctx() {     return (TtlStateTestContextBase<S, UV, ?>) ctx. }
false;private;0;4;;@SuppressWarnings("unchecked") private <UV> TtlMergingStateTestContext<?, UV, ?> mctx() {     return (TtlMergingStateTestContext<?, UV, ?>) ctx. }
false;private;0;3;;private void initTest() throws Exception {     initTest(StateTtlConfig.UpdateType.OnCreateAndWrite, StateTtlConfig.StateVisibility.NeverReturnExpired). }
false;private;2;5;;private void initTest(StateTtlConfig.UpdateType updateType, StateTtlConfig.StateVisibility visibility) throws Exception {     initTest(updateType, visibility, TTL). }
false;private;3;9;;private void initTest(StateTtlConfig.UpdateType updateType, StateTtlConfig.StateVisibility visibility, long ttl) throws Exception {     initTest(getConfBuilder(ttl).setUpdateType(updateType).setStateVisibility(visibility).build()). }
false;protected,static;1;3;;protected static StateTtlConfig.Builder getConfBuilder(long ttl) {     return StateTtlConfig.newBuilder(Time.milliseconds(ttl)). }
false;protected;1;9;;protected <S extends State> StateDescriptor<S, Object> initTest(StateTtlConfig ttlConfig) throws Exception {     this.ttlConfig = ttlConfig.     sbetc.createAndRestoreKeyedStateBackend(null).     sbetc.restoreSnapshot(null).     sbetc.setCurrentKey("defaultKey").     StateDescriptor<S, Object> stateDesc = createState().     ctx().initTestValues().     return stateDesc. }
false;private;0;8;;@SuppressWarnings("unchecked") private <S extends State> StateDescriptor<S, Object> createState() throws Exception {     StateDescriptor<S, Object> stateDescriptor = ctx().createStateDescriptor().     stateDescriptor.enableTimeToLive(ttlConfig).     ctx().ttlState = (InternalKvState<?, String, ?>) sbetc.createState(stateDescriptor, "defaultNamespace").     return stateDescriptor. }
false;private;0;3;;private void takeAndRestoreSnapshot() throws Exception {     restoreSnapshot(sbetc.takeSnapshot(), StateBackendTestContext.NUMBER_OF_KEY_GROUPS). }
false;protected;1;3;;protected void takeAndRestoreSnapshot(int numberOfKeyGroupsAfterRestore) throws Exception {     restoreSnapshot(sbetc.takeSnapshot(), numberOfKeyGroupsAfterRestore). }
false;private;2;6;;private void restoreSnapshot(KeyedStateHandle snapshot, int numberOfKeyGroups) throws Exception {     sbetc.createAndRestoreKeyedStateBackend(numberOfKeyGroups, snapshot).     sbetc.restoreSnapshot(snapshot).     sbetc.setCurrentKey("defaultKey").     createState(). }
false;protected;0;3;;protected boolean incrementalCleanupSupported() {     return false. }
false;public;0;5;;@Test public void testNonExistentValue() throws Exception {     initTest().     assertEquals("Non-existing state should be empty", ctx().emptyValue, ctx().get()). }
false;public;0;40;;@Test public void testExactExpirationOnWrite() throws Exception {     initTest(StateTtlConfig.UpdateType.OnCreateAndWrite, StateTtlConfig.StateVisibility.NeverReturnExpired).     takeAndRestoreSnapshot().     timeProvider.time = 0.     ctx().update(ctx().updateEmpty).     takeAndRestoreSnapshot().     timeProvider.time = 20.     assertEquals(UNEXPIRED_AVAIL, ctx().getUpdateEmpty, ctx().get()).     takeAndRestoreSnapshot().     timeProvider.time = 50.     ctx().update(ctx().updateUnexpired).     takeAndRestoreSnapshot().     timeProvider.time = 120.     assertEquals(UPDATED_UNEXPIRED_AVAIL, ctx().getUnexpired, ctx().get()).     takeAndRestoreSnapshot().     timeProvider.time = 170.     ctx().update(ctx().updateExpired).     takeAndRestoreSnapshot().     timeProvider.time = 220.     assertEquals(UPDATED_UNEXPIRED_AVAIL, ctx().getUpdateExpired, ctx().get()).     takeAndRestoreSnapshot().     timeProvider.time = 300.     assertEquals(EXPIRED_UNAVAIL, ctx().emptyValue, ctx().get()).     assertEquals("Original state should be cleared on access", ctx().emptyValue, ctx().getOriginal()). }
false;public;0;14;;@Test public void testRelaxedExpirationOnWrite() throws Exception {     initTest(StateTtlConfig.UpdateType.OnCreateAndWrite, StateTtlConfig.StateVisibility.ReturnExpiredIfNotCleanedUp).     timeProvider.time = 0.     ctx().update(ctx().updateEmpty).     takeAndRestoreSnapshot().     timeProvider.time = 120.     assertEquals(EXPIRED_AVAIL, ctx().getUpdateEmpty, ctx().get()).     assertEquals("Original state should be cleared on access", ctx().emptyValue, ctx().getOriginal()).     assertEquals("Expired state should be cleared on access", ctx().emptyValue, ctx().get()). }
false;public;0;23;;@Test public void testExactExpirationOnRead() throws Exception {     initTest(StateTtlConfig.UpdateType.OnReadAndWrite, StateTtlConfig.StateVisibility.NeverReturnExpired).     timeProvider.time = 0.     ctx().update(ctx().updateEmpty).     takeAndRestoreSnapshot().     timeProvider.time = 50.     assertEquals(UNEXPIRED_AVAIL, ctx().getUpdateEmpty, ctx().get()).     takeAndRestoreSnapshot().     timeProvider.time = 120.     assertEquals("Unexpired state should be available after read", ctx().getUpdateEmpty, ctx().get()).     takeAndRestoreSnapshot().     timeProvider.time = 250.     assertEquals(EXPIRED_UNAVAIL, ctx().emptyValue, ctx().get()).     assertEquals("Original state should be cleared on access", ctx().emptyValue, ctx().getOriginal()). }
false;public;0;18;;@Test public void testRelaxedExpirationOnRead() throws Exception {     initTest(StateTtlConfig.UpdateType.OnReadAndWrite, StateTtlConfig.StateVisibility.ReturnExpiredIfNotCleanedUp).     timeProvider.time = 0.     ctx().update(ctx().updateEmpty).     takeAndRestoreSnapshot().     timeProvider.time = 50.     assertEquals(UNEXPIRED_AVAIL, ctx().getUpdateEmpty, ctx().get()).     takeAndRestoreSnapshot().     timeProvider.time = 170.     assertEquals(EXPIRED_AVAIL, ctx().getUpdateEmpty, ctx().get()).     assertEquals("Expired state should be cleared on access", ctx().emptyValue, ctx().get()). }
false;public;0;12;;@Test public void testExpirationTimestampOverflow() throws Exception {     initTest(StateTtlConfig.UpdateType.OnCreateAndWrite, StateTtlConfig.StateVisibility.NeverReturnExpired, Long.MAX_VALUE).     timeProvider.time = 10.     ctx().update(ctx().updateEmpty).     takeAndRestoreSnapshot().     timeProvider.time = 50.     assertEquals(UNEXPIRED_AVAIL, ctx().getUpdateEmpty, ctx().get()). }
false;public;0;30;;@Test public void testMergeNamespaces() throws Exception {     assumeThat(ctx, instanceOf(TtlMergingStateTestContext.class)).     initTest().     timeProvider.time = 0.     List<Tuple2<String, Object>> expiredUpdatesToMerge = mctx().generateExpiredUpdatesToMerge().     mctx().applyStateUpdates(expiredUpdatesToMerge).     takeAndRestoreSnapshot().     timeProvider.time = 120.     List<Tuple2<String, Object>> unexpiredUpdatesToMerge = mctx().generateUnexpiredUpdatesToMerge().     mctx().applyStateUpdates(unexpiredUpdatesToMerge).     takeAndRestoreSnapshot().     timeProvider.time = 150.     List<Tuple2<String, Object>> finalUpdatesToMerge = mctx().generateFinalUpdatesToMerge().     mctx().applyStateUpdates(finalUpdatesToMerge).     takeAndRestoreSnapshot().     timeProvider.time = 230.     mctx().ttlState.mergeNamespaces("targetNamespace", TtlMergingStateTestContext.NAMESPACES).     mctx().ttlState.setCurrentNamespace("targetNamespace").     assertEquals("Unexpected result of merge operation", mctx().getMergeResult(unexpiredUpdatesToMerge, finalUpdatesToMerge), mctx().get()). }
false;public;0;5;;@Test public void testMultipleKeys() throws Exception {     initTest().     testMultipleStateIds(id -> sbetc.setCurrentKey(id), false). }
false;public;0;7;;@Test public void testMultipleKeysWithSnapshotCleanup() throws Exception {     assumeTrue("full snapshot strategy", fullSnapshot()).     initTest(getConfBuilder(TTL).cleanupFullSnapshot().build()).     // set time back after restore to see entry unexpired if it was not cleaned up in snapshot properly     testMultipleStateIds(id -> sbetc.setCurrentKey(id), true). }
false;public;0;5;;@Test public void testMultipleNamespaces() throws Exception {     initTest().     testMultipleStateIds(id -> ctx().ttlState.setCurrentNamespace(id), false). }
false;public;0;7;;@Test public void testMultipleNamespacesWithSnapshotCleanup() throws Exception {     assumeTrue("full snapshot strategy", fullSnapshot()).     initTest(getConfBuilder(TTL).cleanupFullSnapshot().build()).     // set time back after restore to see entry unexpired if it was not cleaned up in snapshot properly     testMultipleStateIds(id -> ctx().ttlState.setCurrentNamespace(id), true). }
false;private;2;48;;private void testMultipleStateIds(Consumer<String> idChanger, boolean timeBackAfterRestore) throws Exception {     // test empty storage snapshot/restore     takeAndRestoreSnapshot().     timeProvider.time = 0.     idChanger.accept("id2").     ctx().update(ctx().updateEmpty).     takeAndRestoreSnapshot().     timeProvider.time = 50.     idChanger.accept("id1").     ctx().update(ctx().updateEmpty).     idChanger.accept("id2").     ctx().update(ctx().updateUnexpired).     timeProvider.time = 120.     takeAndRestoreSnapshot().     idChanger.accept("id1").     assertEquals(UNEXPIRED_AVAIL, ctx().getUpdateEmpty, ctx().get()).     idChanger.accept("id2").     assertEquals(UPDATED_UNEXPIRED_AVAIL, ctx().getUnexpired, ctx().get()).     takeAndRestoreSnapshot().     timeProvider.time = 170.     idChanger.accept("id2").     ctx().update(ctx().updateExpired).     timeProvider.time = 230.     takeAndRestoreSnapshot().     timeProvider.time = timeBackAfterRestore ? 170 : timeProvider.time.     idChanger.accept("id1").     assertEquals(EXPIRED_UNAVAIL, ctx().emptyValue, ctx().get()).     idChanger.accept("id2").     assertEquals(UPDATED_UNEXPIRED_AVAIL, ctx().getUpdateExpired, ctx().get()).     timeProvider.time = 300.     takeAndRestoreSnapshot().     timeProvider.time = timeBackAfterRestore ? 230 : timeProvider.time.     idChanger.accept("id1").     assertEquals(EXPIRED_UNAVAIL, ctx().emptyValue, ctx().get()).     idChanger.accept("id2").     assertEquals(EXPIRED_UNAVAIL, ctx().emptyValue, ctx().get()). }
false;public;0;32;;@Test public void testSnapshotChangeRestore() throws Exception {     initTest().     timeProvider.time = 0.     sbetc.setCurrentKey("k1").     ctx().update(ctx().updateEmpty).     timeProvider.time = 50.     sbetc.setCurrentKey("k1").     ctx().update(ctx().updateUnexpired).     timeProvider.time = 100.     sbetc.setCurrentKey("k2").     ctx().update(ctx().updateEmpty).     KeyedStateHandle snapshot = sbetc.takeSnapshot().     timeProvider.time = 170.     sbetc.setCurrentKey("k1").     ctx().update(ctx().updateExpired).     sbetc.setCurrentKey("k2").     ctx().update(ctx().updateUnexpired).     restoreSnapshot(snapshot, StateBackendTestContext.NUMBER_OF_KEY_GROUPS).     timeProvider.time = 180.     sbetc.setCurrentKey("k1").     assertEquals(EXPIRED_UNAVAIL, ctx().emptyValue, ctx().get()).     sbetc.setCurrentKey("k2").     assertEquals(UNEXPIRED_AVAIL, ctx().getUpdateEmpty, ctx().get()). }
false;public;0;16;;@Test(expected = StateMigrationException.class) public void testRestoreTtlAndRegisterNonTtlStateCompatFailure() throws Exception {     assumeThat(this, not(instanceOf(MockTtlStateTest.class))).     initTest().     timeProvider.time = 0.     ctx().update(ctx().updateEmpty).     KeyedStateHandle snapshot = sbetc.takeSnapshot().     sbetc.createAndRestoreKeyedStateBackend(snapshot).     sbetc.restoreSnapshot(snapshot).     sbetc.setCurrentKey("defaultKey").     sbetc.createState(ctx().createStateDescriptor(), ""). }
false;public;0;52;;@Test public void testIncrementalCleanup() throws Exception {     assumeTrue(incrementalCleanupSupported()).     initTest(getConfBuilder(TTL).cleanupIncrementally(5, true).build()).     final int keysToUpdate = CopyOnWriteStateTable.DEFAULT_CAPACITY >> 3.     timeProvider.time = 0.     // create enough keys to trigger incremental rehash     updateKeys(0, INC_CLEANUP_ALL_KEYS, ctx().updateEmpty).     timeProvider.time = 50.     // update some     updateKeys(0, keysToUpdate, ctx().updateUnexpired).     RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshotRunnableFuture = sbetc.triggerSnapshot().     // update more concurrently with snapshotting     updateKeys(keysToUpdate, keysToUpdate * 2, ctx().updateUnexpired).     // expire rest     timeProvider.time = 120.     triggerMoreIncrementalCleanupByOtherOps().     // check rest expired and cleanup updated     checkExpiredKeys(keysToUpdate * 2, INC_CLEANUP_ALL_KEYS).     KeyedStateHandle snapshot = snapshotRunnableFuture.get().getJobManagerOwnedSnapshot().     // restore snapshot which should discard concurrent updates     timeProvider.time = 50.     restoreSnapshot(snapshot, StateBackendTestContext.NUMBER_OF_KEY_GROUPS).     // check rest unexpired, also after restore which should discard concurrent updates     checkUnexpiredKeys(keysToUpdate, INC_CLEANUP_ALL_KEYS, ctx().getUpdateEmpty).     timeProvider.time = 120.     // remove some     for (int i = keysToUpdate >> 1. i < keysToUpdate + (keysToUpdate >> 2). i++) {         sbetc.setCurrentKey(Integer.toString(i)).         ctx().ttlState.clear().     }     // check updated not expired     checkUnexpiredKeys(0, keysToUpdate >> 1, ctx().getUnexpired).     triggerMoreIncrementalCleanupByOtherOps().     // check that concurrently updated and then restored with original values are expired     checkExpiredKeys(keysToUpdate, keysToUpdate * 2).     timeProvider.time = 170.     // check rest expired and cleanup updated     checkExpiredKeys(keysToUpdate >> 1, INC_CLEANUP_ALL_KEYS).     // check updated expired     checkExpiredKeys(0, keysToUpdate >> 1). }
false;private;3;6;;private <T> void updateKeys(int startKey, int endKey, T value) throws Exception {     for (int i = startKey. i < endKey. i++) {         sbetc.setCurrentKey(Integer.toString(i)).         ctx().update(value).     } }
false;private;3;6;;private <T> void checkUnexpiredKeys(int startKey, int endKey, T value) throws Exception {     for (int i = startKey. i < endKey. i++) {         sbetc.setCurrentKey(Integer.toString(i)).         assertEquals(UNEXPIRED_AVAIL, value, ctx().get()).     } }
false;private;2;6;;private void checkExpiredKeys(int startKey, int endKey) throws Exception {     for (int i = startKey. i < endKey. i++) {         sbetc.setCurrentKey(Integer.toString(i)).         assertEquals("Original state should be cleared", ctx().emptyValue, ctx().getOriginal()).     } }
false;private;0;11;;private void triggerMoreIncrementalCleanupByOtherOps() throws Exception {     // trigger more cleanup by doing something out side of INC_CLEANUP_ALL_KEYS     for (int i = INC_CLEANUP_ALL_KEYS. i < INC_CLEANUP_ALL_KEYS * 2. i++) {         sbetc.setCurrentKey(Integer.toString(i)).         if (i / 2 == 0) {             ctx().get().         } else {             ctx().update(ctx().updateEmpty).         }     } }
false;public;0;4;;@After public void tearDown() throws Exception {     sbetc.dispose(). }
