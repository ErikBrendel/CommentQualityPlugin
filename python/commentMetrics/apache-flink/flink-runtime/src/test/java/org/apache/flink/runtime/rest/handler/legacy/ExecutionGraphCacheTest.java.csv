commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setup() {     expectedExecutionGraph = new ArchivedExecutionGraphBuilder().build(). }
true;public;0;19;/**  * Tests that we can cache AccessExecutionGraphs over multiple accesses.  */ ;/**  * Tests that we can cache AccessExecutionGraphs over multiple accesses.  */ @Test public void testExecutionGraphCaching() throws Exception {     final Time timeout = Time.milliseconds(100L).     final Time timeToLive = Time.hours(1L).     final CountingRestfulGateway restfulGateway = createCountingRestfulGateway(expectedJobId, CompletableFuture.completedFuture(expectedExecutionGraph)).     try (ExecutionGraphCache executionGraphCache = new ExecutionGraphCache(timeout, timeToLive)) {         CompletableFuture<AccessExecutionGraph> accessExecutionGraphFuture = executionGraphCache.getExecutionGraph(expectedJobId, restfulGateway).         assertEquals(expectedExecutionGraph, accessExecutionGraphFuture.get()).         accessExecutionGraphFuture = executionGraphCache.getExecutionGraph(expectedJobId, restfulGateway).         assertEquals(expectedExecutionGraph, accessExecutionGraphFuture.get()).         assertThat(restfulGateway.getNumRequestJobCalls(), Matchers.equalTo(1)).     } }
true;public;0;25;/**  * Tests that an AccessExecutionGraph is invalidated after its TTL expired.  */ ;/**  * Tests that an AccessExecutionGraph is invalidated after its TTL expired.  */ @Test public void testExecutionGraphEntryInvalidation() throws Exception {     final Time timeout = Time.milliseconds(100L).     final Time timeToLive = Time.milliseconds(1L).     final CountingRestfulGateway restfulGateway = createCountingRestfulGateway(expectedJobId, CompletableFuture.completedFuture(expectedExecutionGraph), CompletableFuture.completedFuture(expectedExecutionGraph)).     try (ExecutionGraphCache executionGraphCache = new ExecutionGraphCache(timeout, timeToLive)) {         CompletableFuture<AccessExecutionGraph> executionGraphFuture = executionGraphCache.getExecutionGraph(expectedJobId, restfulGateway).         assertEquals(expectedExecutionGraph, executionGraphFuture.get()).         // sleep for the TTL         Thread.sleep(timeToLive.toMilliseconds() * 5L).         CompletableFuture<AccessExecutionGraph> executionGraphFuture2 = executionGraphCache.getExecutionGraph(expectedJobId, restfulGateway).         assertEquals(expectedExecutionGraph, executionGraphFuture2.get()).         assertThat(restfulGateway.getNumRequestJobCalls(), Matchers.equalTo(2)).     } }
true;public;0;27;/**  * Tests that a failure in requesting an AccessExecutionGraph from the gateway, will not create  * a cache entry --> another cache request will trigger a new gateway request.  */ ;/**  * Tests that a failure in requesting an AccessExecutionGraph from the gateway, will not create  * a cache entry --> another cache request will trigger a new gateway request.  */ @Test public void testImmediateCacheInvalidationAfterFailure() throws Exception {     final Time timeout = Time.milliseconds(100L).     final Time timeToLive = Time.hours(1L).     // let's first answer with a JobNotFoundException and then only with the correct result     final CountingRestfulGateway restfulGateway = createCountingRestfulGateway(expectedJobId, FutureUtils.completedExceptionally(new FlinkJobNotFoundException(expectedJobId)), CompletableFuture.completedFuture(expectedExecutionGraph)).     try (ExecutionGraphCache executionGraphCache = new ExecutionGraphCache(timeout, timeToLive)) {         CompletableFuture<AccessExecutionGraph> executionGraphFuture = executionGraphCache.getExecutionGraph(expectedJobId, restfulGateway).         try {             executionGraphFuture.get().             fail("The execution graph future should have been completed exceptionally.").         } catch (ExecutionException ee) {             assertTrue(ee.getCause() instanceof FlinkException).         }         CompletableFuture<AccessExecutionGraph> executionGraphFuture2 = executionGraphCache.getExecutionGraph(expectedJobId, restfulGateway).         assertEquals(expectedExecutionGraph, executionGraphFuture2.get()).     } }
true;public;0;42;/**  * Tests that cache entries are cleaned up when their TTL has expired upon  * calling {@link ExecutionGraphCache#cleanup()}.  */ ;/**  * Tests that cache entries are cleaned up when their TTL has expired upon  * calling {@link ExecutionGraphCache#cleanup()}.  */ @Test public void testCacheEntryCleanup() throws Exception {     final Time timeout = Time.milliseconds(100L).     final Time timeToLive = Time.milliseconds(1L).     final JobID expectedJobId2 = new JobID().     final ArchivedExecutionGraph expectedExecutionGraph2 = new ArchivedExecutionGraphBuilder().build().     final AtomicInteger requestJobCalls = new AtomicInteger(0).     final TestingRestfulGateway restfulGateway = TestingRestfulGateway.newBuilder().setRequestJobFunction(jobId -> {         requestJobCalls.incrementAndGet().         if (jobId.equals(expectedJobId)) {             return CompletableFuture.completedFuture(expectedExecutionGraph).         } else if (jobId.equals(expectedJobId2)) {             return CompletableFuture.completedFuture(expectedExecutionGraph2).         } else {             throw new AssertionError("Invalid job id received.").         }     }).build().     try (ExecutionGraphCache executionGraphCache = new ExecutionGraphCache(timeout, timeToLive)) {         CompletableFuture<AccessExecutionGraph> executionGraph1Future = executionGraphCache.getExecutionGraph(expectedJobId, restfulGateway).         CompletableFuture<AccessExecutionGraph> executionGraph2Future = executionGraphCache.getExecutionGraph(expectedJobId2, restfulGateway).         assertEquals(expectedExecutionGraph, executionGraph1Future.get()).         assertEquals(expectedExecutionGraph2, executionGraph2Future.get()).         assertThat(requestJobCalls.get(), Matchers.equalTo(2)).         Thread.sleep(timeToLive.toMilliseconds()).         executionGraphCache.cleanup().         assertTrue(executionGraphCache.size() == 0).     } }
true;public;0;37;/**  * Tests that concurrent accesses only trigger a single AccessExecutionGraph request.  */ ;/**  * Tests that concurrent accesses only trigger a single AccessExecutionGraph request.  */ @Test public void testConcurrentAccess() throws Exception {     final Time timeout = Time.milliseconds(100L).     final Time timeToLive = Time.hours(1L).     final CountingRestfulGateway restfulGateway = createCountingRestfulGateway(expectedJobId, CompletableFuture.completedFuture(expectedExecutionGraph)).     final int numConcurrentAccesses = 10.     final ArrayList<CompletableFuture<AccessExecutionGraph>> executionGraphFutures = new ArrayList<>(numConcurrentAccesses).     final ExecutorService executor = java.util.concurrent.Executors.newFixedThreadPool(numConcurrentAccesses).     try (ExecutionGraphCache executionGraphCache = new ExecutionGraphCache(timeout, timeToLive)) {         for (int i = 0. i < numConcurrentAccesses. i++) {             CompletableFuture<AccessExecutionGraph> executionGraphFuture = CompletableFuture.supplyAsync(() -> executionGraphCache.getExecutionGraph(expectedJobId, restfulGateway), executor).thenCompose(Function.identity()).             executionGraphFutures.add(executionGraphFuture).         }         final CompletableFuture<Collection<AccessExecutionGraph>> allExecutionGraphFutures = FutureUtils.combineAll(executionGraphFutures).         Collection<AccessExecutionGraph> allExecutionGraphs = allExecutionGraphFutures.get().         for (AccessExecutionGraph executionGraph : allExecutionGraphs) {             assertEquals(expectedExecutionGraph, executionGraph).         }         assertThat(restfulGateway.getNumRequestJobCalls(), Matchers.equalTo(1)).     } finally {         ExecutorUtils.gracefulShutdown(5000L, TimeUnit.MILLISECONDS, executor).     } }
false;private;2;6;;private CountingRestfulGateway createCountingRestfulGateway(JobID jobId, CompletableFuture<ArchivedExecutionGraph>... accessExecutionGraphs) {     final ConcurrentLinkedQueue<CompletableFuture<ArchivedExecutionGraph>> queue = new ConcurrentLinkedQueue<>(Arrays.asList(accessExecutionGraphs)).     return new CountingRestfulGateway(jobId, ignored -> queue.poll()). }
false;public;2;6;;@Override public CompletableFuture<ArchivedExecutionGraph> requestJob(JobID jobId, Time timeout) {     assertThat(jobId, Matchers.equalTo(expectedJobId)).     numRequestJobCalls.incrementAndGet().     return super.requestJob(jobId, timeout). }
false;public;0;3;;public int getNumRequestJobCalls() {     return numRequestJobCalls.get(). }
false;public;0;4;;@Override public JobStatus getState() {     return jobStatus. }
false;public;1;3;;public void setJobStatus(JobStatus jobStatus) {     this.jobStatus = jobStatus. }
