# id;timestamp;commentText;codeText;commentWords;codeWords
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentInstanceFromOneSource() throws Exception;1494099604;Tests that validates that a single pipelined component instance from one source_works correctly.__<p>Non-parallelized view:_<pre>_+--(1)_+--(5)-+_|      +--(2)_(7)--+_|      +--(3)_+--(6)-+_+--(4)_..._</pre>;@Test_	public void testOneComponentInstanceFromOneSource() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex1.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex2.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex3.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex4.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex5.connectNewDataSetAsInput(vertex7, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex7, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex7, vertex5, vertex6, vertex1, vertex2, vertex3, vertex4)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		Iterator<ExecutionVertex> evs = eg.getAllExecutionVertices().iterator()___		FailoverRegion preRegion = failoverStrategy.getFailoverRegion(evs.next())___		while (evs.hasNext()) {_			FailoverRegion region = failoverStrategy.getFailoverRegion(evs.next())__			assertTrue(preRegion == region)__		}_	};tests,that,validates,that,a,single,pipelined,component,instance,from,one,source,works,correctly,p,non,parallelized,view,pre,1,5,2,7,3,6,4,pre;test,public,void,test,one,component,instance,from,one,source,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex1,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex2,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,vertex4,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex7,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex7,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex7,vertex5,vertex6,vertex1,vertex2,vertex3,vertex4,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,iterator,execution,vertex,evs,eg,get,all,execution,vertices,iterator,failover,region,pre,region,failover,strategy,get,failover,region,evs,next,while,evs,has,next,failover,region,region,failover,strategy,get,failover,region,evs,next,assert,true,pre,region,region
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentInstanceFromOneSource() throws Exception;1508861310;Tests that validates that a single pipelined component instance from one source_works correctly.__<p>Non-parallelized view:_<pre>_+--(1)_+--(5)-+_|      +--(2)_(7)--+_|      +--(3)_+--(6)-+_+--(4)_..._</pre>;@Test_	public void testOneComponentInstanceFromOneSource() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex1.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex2.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex3.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex4.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex5.connectNewDataSetAsInput(vertex7, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex7, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex7, vertex5, vertex6, vertex1, vertex2, vertex3, vertex4)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		Iterator<ExecutionVertex> evs = eg.getAllExecutionVertices().iterator()___		FailoverRegion preRegion = failoverStrategy.getFailoverRegion(evs.next())___		while (evs.hasNext()) {_			FailoverRegion region = failoverStrategy.getFailoverRegion(evs.next())__			assertTrue(preRegion == region)__		}_	};tests,that,validates,that,a,single,pipelined,component,instance,from,one,source,works,correctly,p,non,parallelized,view,pre,1,5,2,7,3,6,4,pre;test,public,void,test,one,component,instance,from,one,source,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex1,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex2,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,vertex4,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex7,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex7,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex7,vertex5,vertex6,vertex1,vertex2,vertex3,vertex4,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,iterator,execution,vertex,evs,eg,get,all,execution,vertices,iterator,failover,region,pre,region,failover,strategy,get,failover,region,evs,next,while,evs,has,next,failover,region,region,failover,strategy,get,failover,region,evs,next,assert,true,pre,region,region
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentInstanceFromOneSource() throws Exception;1508861311;Tests that validates that a single pipelined component instance from one source_works correctly.__<p>Non-parallelized view:_<pre>_+--(1)_+--(5)-+_|      +--(2)_(7)--+_|      +--(3)_+--(6)-+_+--(4)_..._</pre>;@Test_	public void testOneComponentInstanceFromOneSource() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex1.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex2.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex3.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex4.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex5.connectNewDataSetAsInput(vertex7, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex7, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex7, vertex5, vertex6, vertex1, vertex2, vertex3, vertex4)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		Iterator<ExecutionVertex> evs = eg.getAllExecutionVertices().iterator()___		FailoverRegion preRegion = failoverStrategy.getFailoverRegion(evs.next())___		while (evs.hasNext()) {_			FailoverRegion region = failoverStrategy.getFailoverRegion(evs.next())__			assertTrue(preRegion == region)__		}_	};tests,that,validates,that,a,single,pipelined,component,instance,from,one,source,works,correctly,p,non,parallelized,view,pre,1,5,2,7,3,6,4,pre;test,public,void,test,one,component,instance,from,one,source,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex1,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex2,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,vertex4,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex7,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex7,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex7,vertex5,vertex6,vertex1,vertex2,vertex3,vertex4,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,iterator,execution,vertex,evs,eg,get,all,execution,vertices,iterator,failover,region,pre,region,failover,strategy,get,failover,region,evs,next,while,evs,has,next,failover,region,region,failover,strategy,get,failover,region,evs,next,assert,true,pre,region,region
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentInstanceFromOneSource() throws Exception;1513261599;Tests that validates that a single pipelined component instance from one source_works correctly.__<p>Non-parallelized view:_<pre>_+--(1)_+--(5)-+_|      +--(2)_(7)--+_|      +--(3)_+--(6)-+_+--(4)_..._</pre>;@Test_	public void testOneComponentInstanceFromOneSource() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex1.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex2.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex3.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex4.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex5.connectNewDataSetAsInput(vertex7, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex7, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex7, vertex5, vertex6, vertex1, vertex2, vertex3, vertex4)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		Iterator<ExecutionVertex> evs = eg.getAllExecutionVertices().iterator()___		FailoverRegion preRegion = failoverStrategy.getFailoverRegion(evs.next())___		while (evs.hasNext()) {_			FailoverRegion region = failoverStrategy.getFailoverRegion(evs.next())__			assertTrue(preRegion == region)__		}_	};tests,that,validates,that,a,single,pipelined,component,instance,from,one,source,works,correctly,p,non,parallelized,view,pre,1,5,2,7,3,6,4,pre;test,public,void,test,one,component,instance,from,one,source,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex1,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex2,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,vertex4,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex7,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex7,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex7,vertex5,vertex6,vertex1,vertex2,vertex3,vertex4,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,iterator,execution,vertex,evs,eg,get,all,execution,vertices,iterator,failover,region,pre,region,failover,strategy,get,failover,region,evs,next,while,evs,has,next,failover,region,region,failover,strategy,get,failover,region,evs,next,assert,true,pre,region,region
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentInstanceFromOneSource() throws Exception;1518680774;Tests that validates that a single pipelined component instance from one source_works correctly.__<p>Non-parallelized view:_<pre>_+--(1)_+--(5)-+_|      +--(2)_(7)--+_|      +--(3)_+--(6)-+_+--(4)_..._</pre>;@Test_	public void testOneComponentInstanceFromOneSource() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex1.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex2.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex3.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex4.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex5.connectNewDataSetAsInput(vertex7, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex7, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex7, vertex5, vertex6, vertex1, vertex2, vertex3, vertex4)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		Iterator<ExecutionVertex> evs = eg.getAllExecutionVertices().iterator()___		FailoverRegion preRegion = failoverStrategy.getFailoverRegion(evs.next())___		while (evs.hasNext()) {_			FailoverRegion region = failoverStrategy.getFailoverRegion(evs.next())__			assertTrue(preRegion == region)__		}_	};tests,that,validates,that,a,single,pipelined,component,instance,from,one,source,works,correctly,p,non,parallelized,view,pre,1,5,2,7,3,6,4,pre;test,public,void,test,one,component,instance,from,one,source,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex1,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex2,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,vertex4,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex7,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex7,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex7,vertex5,vertex6,vertex1,vertex2,vertex3,vertex4,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,iterator,execution,vertex,evs,eg,get,all,execution,vertices,iterator,failover,region,pre,region,failover,strategy,get,failover,region,evs,next,while,evs,has,next,failover,region,region,failover,strategy,get,failover,region,evs,next,assert,true,pre,region,region
PipelinedFailoverRegionBuildingTest -> @Test 	public void testBlockingAllToAllTopologyWithCoLocation() throws Exception;1494099604;This test checks that are strictly co-located vertices are in the same failover region,_even through they are connected via a blocking pattern._This is currently an assumption / limitation of the scheduler.;@Test_	public void testBlockingAllToAllTopologyWithCoLocation() throws Exception {_		final JobVertex source = new JobVertex("source")__		source.setInvokableClass(NoOpInvokable.class)__		source.setParallelism(10)___		final JobVertex target = new JobVertex("target")__		target.setInvokableClass(NoOpInvokable.class)__		target.setParallelism(13)___		target.connectNewDataSetAsInput(source, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final SlotSharingGroup sharingGroup = new SlotSharingGroup()__		source.setSlotSharingGroup(sharingGroup)__		target.setSlotSharingGroup(sharingGroup)___		source.setStrictlyCoLocatedWith(target)___		final JobGraph jobGraph = new JobGraph("test job", source, target)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0])___		_		_		assertTrue(region1 == region2)__	};this,test,checks,that,are,strictly,co,located,vertices,are,in,the,same,failover,region,even,through,they,are,connected,via,a,blocking,pattern,this,is,currently,an,assumption,limitation,of,the,scheduler;test,public,void,test,blocking,all,to,all,topology,with,co,location,throws,exception,final,job,vertex,source,new,job,vertex,source,source,set,invokable,class,no,op,invokable,class,source,set,parallelism,10,final,job,vertex,target,new,job,vertex,target,target,set,invokable,class,no,op,invokable,class,target,set,parallelism,13,target,connect,new,data,set,as,input,source,distribution,pattern,result,partition,type,blocking,final,slot,sharing,group,sharing,group,new,slot,sharing,group,source,set,slot,sharing,group,sharing,group,target,set,slot,sharing,group,sharing,group,source,set,strictly,co,located,with,target,final,job,graph,job,graph,new,job,graph,test,job,source,target,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,0,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,0,assert,true,region1,region2
PipelinedFailoverRegionBuildingTest -> @Test 	public void testBlockingAllToAllTopologyWithCoLocation() throws Exception;1508861310;This test checks that are strictly co-located vertices are in the same failover region,_even through they are connected via a blocking pattern._This is currently an assumption / limitation of the scheduler.;@Test_	public void testBlockingAllToAllTopologyWithCoLocation() throws Exception {_		final JobVertex source = new JobVertex("source")__		source.setInvokableClass(NoOpInvokable.class)__		source.setParallelism(10)___		final JobVertex target = new JobVertex("target")__		target.setInvokableClass(NoOpInvokable.class)__		target.setParallelism(13)___		target.connectNewDataSetAsInput(source, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final SlotSharingGroup sharingGroup = new SlotSharingGroup()__		source.setSlotSharingGroup(sharingGroup)__		target.setSlotSharingGroup(sharingGroup)___		source.setStrictlyCoLocatedWith(target)___		final JobGraph jobGraph = new JobGraph("test job", source, target)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0])___		_		_		assertTrue(region1 == region2)__	};this,test,checks,that,are,strictly,co,located,vertices,are,in,the,same,failover,region,even,through,they,are,connected,via,a,blocking,pattern,this,is,currently,an,assumption,limitation,of,the,scheduler;test,public,void,test,blocking,all,to,all,topology,with,co,location,throws,exception,final,job,vertex,source,new,job,vertex,source,source,set,invokable,class,no,op,invokable,class,source,set,parallelism,10,final,job,vertex,target,new,job,vertex,target,target,set,invokable,class,no,op,invokable,class,target,set,parallelism,13,target,connect,new,data,set,as,input,source,distribution,pattern,result,partition,type,blocking,final,slot,sharing,group,sharing,group,new,slot,sharing,group,source,set,slot,sharing,group,sharing,group,target,set,slot,sharing,group,sharing,group,source,set,strictly,co,located,with,target,final,job,graph,job,graph,new,job,graph,test,job,source,target,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,0,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,0,assert,true,region1,region2
PipelinedFailoverRegionBuildingTest -> @Test 	public void testBlockingAllToAllTopologyWithCoLocation() throws Exception;1508861311;This test checks that are strictly co-located vertices are in the same failover region,_even through they are connected via a blocking pattern._This is currently an assumption / limitation of the scheduler.;@Test_	public void testBlockingAllToAllTopologyWithCoLocation() throws Exception {_		final JobVertex source = new JobVertex("source")__		source.setInvokableClass(NoOpInvokable.class)__		source.setParallelism(10)___		final JobVertex target = new JobVertex("target")__		target.setInvokableClass(NoOpInvokable.class)__		target.setParallelism(13)___		target.connectNewDataSetAsInput(source, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final SlotSharingGroup sharingGroup = new SlotSharingGroup()__		source.setSlotSharingGroup(sharingGroup)__		target.setSlotSharingGroup(sharingGroup)___		source.setStrictlyCoLocatedWith(target)___		final JobGraph jobGraph = new JobGraph("test job", source, target)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0])___		_		_		assertTrue(region1 == region2)__	};this,test,checks,that,are,strictly,co,located,vertices,are,in,the,same,failover,region,even,through,they,are,connected,via,a,blocking,pattern,this,is,currently,an,assumption,limitation,of,the,scheduler;test,public,void,test,blocking,all,to,all,topology,with,co,location,throws,exception,final,job,vertex,source,new,job,vertex,source,source,set,invokable,class,no,op,invokable,class,source,set,parallelism,10,final,job,vertex,target,new,job,vertex,target,target,set,invokable,class,no,op,invokable,class,target,set,parallelism,13,target,connect,new,data,set,as,input,source,distribution,pattern,result,partition,type,blocking,final,slot,sharing,group,sharing,group,new,slot,sharing,group,source,set,slot,sharing,group,sharing,group,target,set,slot,sharing,group,sharing,group,source,set,strictly,co,located,with,target,final,job,graph,job,graph,new,job,graph,test,job,source,target,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,0,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,0,assert,true,region1,region2
PipelinedFailoverRegionBuildingTest -> @Test 	public void testBlockingAllToAllTopologyWithCoLocation() throws Exception;1513261599;This test checks that are strictly co-located vertices are in the same failover region,_even through they are connected via a blocking pattern._This is currently an assumption / limitation of the scheduler.;@Test_	public void testBlockingAllToAllTopologyWithCoLocation() throws Exception {_		final JobVertex source = new JobVertex("source")__		source.setInvokableClass(NoOpInvokable.class)__		source.setParallelism(10)___		final JobVertex target = new JobVertex("target")__		target.setInvokableClass(NoOpInvokable.class)__		target.setParallelism(13)___		target.connectNewDataSetAsInput(source, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final SlotSharingGroup sharingGroup = new SlotSharingGroup()__		source.setSlotSharingGroup(sharingGroup)__		target.setSlotSharingGroup(sharingGroup)___		source.setStrictlyCoLocatedWith(target)___		final JobGraph jobGraph = new JobGraph("test job", source, target)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0])___		_		_		assertTrue(region1 == region2)__	};this,test,checks,that,are,strictly,co,located,vertices,are,in,the,same,failover,region,even,through,they,are,connected,via,a,blocking,pattern,this,is,currently,an,assumption,limitation,of,the,scheduler;test,public,void,test,blocking,all,to,all,topology,with,co,location,throws,exception,final,job,vertex,source,new,job,vertex,source,source,set,invokable,class,no,op,invokable,class,source,set,parallelism,10,final,job,vertex,target,new,job,vertex,target,target,set,invokable,class,no,op,invokable,class,target,set,parallelism,13,target,connect,new,data,set,as,input,source,distribution,pattern,result,partition,type,blocking,final,slot,sharing,group,sharing,group,new,slot,sharing,group,source,set,slot,sharing,group,sharing,group,target,set,slot,sharing,group,sharing,group,source,set,strictly,co,located,with,target,final,job,graph,job,graph,new,job,graph,test,job,source,target,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,0,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,0,assert,true,region1,region2
PipelinedFailoverRegionBuildingTest -> @Test 	public void testBlockingAllToAllTopologyWithCoLocation() throws Exception;1518680774;This test checks that are strictly co-located vertices are in the same failover region,_even through they are connected via a blocking pattern._This is currently an assumption / limitation of the scheduler.;@Test_	public void testBlockingAllToAllTopologyWithCoLocation() throws Exception {_		final JobVertex source = new JobVertex("source")__		source.setInvokableClass(NoOpInvokable.class)__		source.setParallelism(10)___		final JobVertex target = new JobVertex("target")__		target.setInvokableClass(NoOpInvokable.class)__		target.setParallelism(13)___		target.connectNewDataSetAsInput(source, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final SlotSharingGroup sharingGroup = new SlotSharingGroup()__		source.setSlotSharingGroup(sharingGroup)__		target.setSlotSharingGroup(sharingGroup)___		source.setStrictlyCoLocatedWith(target)___		final JobGraph jobGraph = new JobGraph("test job", source, target)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0])___		_		_		assertTrue(region1 == region2)__	};this,test,checks,that,are,strictly,co,located,vertices,are,in,the,same,failover,region,even,through,they,are,connected,via,a,blocking,pattern,this,is,currently,an,assumption,limitation,of,the,scheduler;test,public,void,test,blocking,all,to,all,topology,with,co,location,throws,exception,final,job,vertex,source,new,job,vertex,source,source,set,invokable,class,no,op,invokable,class,source,set,parallelism,10,final,job,vertex,target,new,job,vertex,target,target,set,invokable,class,no,op,invokable,class,target,set,parallelism,13,target,connect,new,data,set,as,input,source,distribution,pattern,result,partition,type,blocking,final,slot,sharing,group,sharing,group,new,slot,sharing,group,source,set,slot,sharing,group,sharing,group,target,set,slot,sharing,group,sharing,group,source,set,strictly,co,located,with,target,final,job,graph,job,graph,new,job,graph,test,job,source,target,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,0,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,0,assert,true,region1,region2
PipelinedFailoverRegionBuildingTest -> @Test 	public void testIndividualVertices() throws Exception;1494099604;Tests that validates that a graph with single unconnected vertices works correctly.__<pre>_(v1)__(v2)__(v3)__..._</pre>;@Test_	public void testIndividualVertices() throws Exception {_		final JobVertex source1 = new JobVertex("source1")__		source1.setInvokableClass(NoOpInvokable.class)__		source1.setParallelism(2)___		final JobVertex source2 = new JobVertex("source2")__		source2.setInvokableClass(NoOpInvokable.class)__		source2.setParallelism(2)___		final JobGraph jobGraph = new JobGraph("test job", source1, source2)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion sourceRegion11 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source1.getID()).getTaskVertices()[0])__		FailoverRegion sourceRegion12 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source1.getID()).getTaskVertices()[1])__		FailoverRegion targetRegion21 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source2.getID()).getTaskVertices()[0])__		FailoverRegion targetRegion22 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source2.getID()).getTaskVertices()[1])___		assertTrue(sourceRegion11 != sourceRegion12)__		assertTrue(sourceRegion12 != targetRegion21)__		assertTrue(targetRegion21 != targetRegion22)__	};tests,that,validates,that,a,graph,with,single,unconnected,vertices,works,correctly,pre,v1,v2,v3,pre;test,public,void,test,individual,vertices,throws,exception,final,job,vertex,source1,new,job,vertex,source1,source1,set,invokable,class,no,op,invokable,class,source1,set,parallelism,2,final,job,vertex,source2,new,job,vertex,source2,source2,set,invokable,class,no,op,invokable,class,source2,set,parallelism,2,final,job,graph,job,graph,new,job,graph,test,job,source1,source2,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,source,region11,failover,strategy,get,failover,region,eg,get,job,vertex,source1,get,id,get,task,vertices,0,failover,region,source,region12,failover,strategy,get,failover,region,eg,get,job,vertex,source1,get,id,get,task,vertices,1,failover,region,target,region21,failover,strategy,get,failover,region,eg,get,job,vertex,source2,get,id,get,task,vertices,0,failover,region,target,region22,failover,strategy,get,failover,region,eg,get,job,vertex,source2,get,id,get,task,vertices,1,assert,true,source,region11,source,region12,assert,true,source,region12,target,region21,assert,true,target,region21,target,region22
PipelinedFailoverRegionBuildingTest -> @Test 	public void testIndividualVertices() throws Exception;1508861310;Tests that validates that a graph with single unconnected vertices works correctly.__<pre>_(v1)__(v2)__(v3)__..._</pre>;@Test_	public void testIndividualVertices() throws Exception {_		final JobVertex source1 = new JobVertex("source1")__		source1.setInvokableClass(NoOpInvokable.class)__		source1.setParallelism(2)___		final JobVertex source2 = new JobVertex("source2")__		source2.setInvokableClass(NoOpInvokable.class)__		source2.setParallelism(2)___		final JobGraph jobGraph = new JobGraph("test job", source1, source2)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion sourceRegion11 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source1.getID()).getTaskVertices()[0])__		FailoverRegion sourceRegion12 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source1.getID()).getTaskVertices()[1])__		FailoverRegion targetRegion21 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source2.getID()).getTaskVertices()[0])__		FailoverRegion targetRegion22 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source2.getID()).getTaskVertices()[1])___		assertTrue(sourceRegion11 != sourceRegion12)__		assertTrue(sourceRegion12 != targetRegion21)__		assertTrue(targetRegion21 != targetRegion22)__	};tests,that,validates,that,a,graph,with,single,unconnected,vertices,works,correctly,pre,v1,v2,v3,pre;test,public,void,test,individual,vertices,throws,exception,final,job,vertex,source1,new,job,vertex,source1,source1,set,invokable,class,no,op,invokable,class,source1,set,parallelism,2,final,job,vertex,source2,new,job,vertex,source2,source2,set,invokable,class,no,op,invokable,class,source2,set,parallelism,2,final,job,graph,job,graph,new,job,graph,test,job,source1,source2,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,source,region11,failover,strategy,get,failover,region,eg,get,job,vertex,source1,get,id,get,task,vertices,0,failover,region,source,region12,failover,strategy,get,failover,region,eg,get,job,vertex,source1,get,id,get,task,vertices,1,failover,region,target,region21,failover,strategy,get,failover,region,eg,get,job,vertex,source2,get,id,get,task,vertices,0,failover,region,target,region22,failover,strategy,get,failover,region,eg,get,job,vertex,source2,get,id,get,task,vertices,1,assert,true,source,region11,source,region12,assert,true,source,region12,target,region21,assert,true,target,region21,target,region22
PipelinedFailoverRegionBuildingTest -> @Test 	public void testIndividualVertices() throws Exception;1508861311;Tests that validates that a graph with single unconnected vertices works correctly.__<pre>_(v1)__(v2)__(v3)__..._</pre>;@Test_	public void testIndividualVertices() throws Exception {_		final JobVertex source1 = new JobVertex("source1")__		source1.setInvokableClass(NoOpInvokable.class)__		source1.setParallelism(2)___		final JobVertex source2 = new JobVertex("source2")__		source2.setInvokableClass(NoOpInvokable.class)__		source2.setParallelism(2)___		final JobGraph jobGraph = new JobGraph("test job", source1, source2)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion sourceRegion11 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source1.getID()).getTaskVertices()[0])__		FailoverRegion sourceRegion12 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source1.getID()).getTaskVertices()[1])__		FailoverRegion targetRegion21 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source2.getID()).getTaskVertices()[0])__		FailoverRegion targetRegion22 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source2.getID()).getTaskVertices()[1])___		assertTrue(sourceRegion11 != sourceRegion12)__		assertTrue(sourceRegion12 != targetRegion21)__		assertTrue(targetRegion21 != targetRegion22)__	};tests,that,validates,that,a,graph,with,single,unconnected,vertices,works,correctly,pre,v1,v2,v3,pre;test,public,void,test,individual,vertices,throws,exception,final,job,vertex,source1,new,job,vertex,source1,source1,set,invokable,class,no,op,invokable,class,source1,set,parallelism,2,final,job,vertex,source2,new,job,vertex,source2,source2,set,invokable,class,no,op,invokable,class,source2,set,parallelism,2,final,job,graph,job,graph,new,job,graph,test,job,source1,source2,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,source,region11,failover,strategy,get,failover,region,eg,get,job,vertex,source1,get,id,get,task,vertices,0,failover,region,source,region12,failover,strategy,get,failover,region,eg,get,job,vertex,source1,get,id,get,task,vertices,1,failover,region,target,region21,failover,strategy,get,failover,region,eg,get,job,vertex,source2,get,id,get,task,vertices,0,failover,region,target,region22,failover,strategy,get,failover,region,eg,get,job,vertex,source2,get,id,get,task,vertices,1,assert,true,source,region11,source,region12,assert,true,source,region12,target,region21,assert,true,target,region21,target,region22
PipelinedFailoverRegionBuildingTest -> @Test 	public void testIndividualVertices() throws Exception;1513261599;Tests that validates that a graph with single unconnected vertices works correctly.__<pre>_(v1)__(v2)__(v3)__..._</pre>;@Test_	public void testIndividualVertices() throws Exception {_		final JobVertex source1 = new JobVertex("source1")__		source1.setInvokableClass(NoOpInvokable.class)__		source1.setParallelism(2)___		final JobVertex source2 = new JobVertex("source2")__		source2.setInvokableClass(NoOpInvokable.class)__		source2.setParallelism(2)___		final JobGraph jobGraph = new JobGraph("test job", source1, source2)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion sourceRegion11 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source1.getID()).getTaskVertices()[0])__		FailoverRegion sourceRegion12 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source1.getID()).getTaskVertices()[1])__		FailoverRegion targetRegion21 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source2.getID()).getTaskVertices()[0])__		FailoverRegion targetRegion22 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source2.getID()).getTaskVertices()[1])___		assertTrue(sourceRegion11 != sourceRegion12)__		assertTrue(sourceRegion12 != targetRegion21)__		assertTrue(targetRegion21 != targetRegion22)__	};tests,that,validates,that,a,graph,with,single,unconnected,vertices,works,correctly,pre,v1,v2,v3,pre;test,public,void,test,individual,vertices,throws,exception,final,job,vertex,source1,new,job,vertex,source1,source1,set,invokable,class,no,op,invokable,class,source1,set,parallelism,2,final,job,vertex,source2,new,job,vertex,source2,source2,set,invokable,class,no,op,invokable,class,source2,set,parallelism,2,final,job,graph,job,graph,new,job,graph,test,job,source1,source2,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,source,region11,failover,strategy,get,failover,region,eg,get,job,vertex,source1,get,id,get,task,vertices,0,failover,region,source,region12,failover,strategy,get,failover,region,eg,get,job,vertex,source1,get,id,get,task,vertices,1,failover,region,target,region21,failover,strategy,get,failover,region,eg,get,job,vertex,source2,get,id,get,task,vertices,0,failover,region,target,region22,failover,strategy,get,failover,region,eg,get,job,vertex,source2,get,id,get,task,vertices,1,assert,true,source,region11,source,region12,assert,true,source,region12,target,region21,assert,true,target,region21,target,region22
PipelinedFailoverRegionBuildingTest -> @Test 	public void testIndividualVertices() throws Exception;1518680774;Tests that validates that a graph with single unconnected vertices works correctly.__<pre>_(v1)__(v2)__(v3)__..._</pre>;@Test_	public void testIndividualVertices() throws Exception {_		final JobVertex source1 = new JobVertex("source1")__		source1.setInvokableClass(NoOpInvokable.class)__		source1.setParallelism(2)___		final JobVertex source2 = new JobVertex("source2")__		source2.setInvokableClass(NoOpInvokable.class)__		source2.setParallelism(2)___		final JobGraph jobGraph = new JobGraph("test job", source1, source2)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion sourceRegion11 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source1.getID()).getTaskVertices()[0])__		FailoverRegion sourceRegion12 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source1.getID()).getTaskVertices()[1])__		FailoverRegion targetRegion21 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source2.getID()).getTaskVertices()[0])__		FailoverRegion targetRegion22 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source2.getID()).getTaskVertices()[1])___		assertTrue(sourceRegion11 != sourceRegion12)__		assertTrue(sourceRegion12 != targetRegion21)__		assertTrue(targetRegion21 != targetRegion22)__	};tests,that,validates,that,a,graph,with,single,unconnected,vertices,works,correctly,pre,v1,v2,v3,pre;test,public,void,test,individual,vertices,throws,exception,final,job,vertex,source1,new,job,vertex,source1,source1,set,invokable,class,no,op,invokable,class,source1,set,parallelism,2,final,job,vertex,source2,new,job,vertex,source2,source2,set,invokable,class,no,op,invokable,class,source2,set,parallelism,2,final,job,graph,job,graph,new,job,graph,test,job,source1,source2,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,source,region11,failover,strategy,get,failover,region,eg,get,job,vertex,source1,get,id,get,task,vertices,0,failover,region,source,region12,failover,strategy,get,failover,region,eg,get,job,vertex,source1,get,id,get,task,vertices,1,failover,region,target,region21,failover,strategy,get,failover,region,eg,get,job,vertex,source2,get,id,get,task,vertices,0,failover,region,target,region22,failover,strategy,get,failover,region,eg,get,job,vertex,source2,get,id,get,task,vertices,1,assert,true,source,region11,source,region12,assert,true,source,region12,target,region21,assert,true,target,region21,target,region22
PipelinedFailoverRegionBuildingTest -> @Test 	public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception;1494099604;This test checks that are strictly co-located vertices are in the same failover region,_even through they are connected via a blocking pattern._This is currently an assumption / limitation of the scheduler.;@Test_	public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception {_		final JobVertex source = new JobVertex("source")__		source.setInvokableClass(NoOpInvokable.class)__		source.setParallelism(10)___		final JobVertex target = new JobVertex("target")__		target.setInvokableClass(NoOpInvokable.class)__		target.setParallelism(10)___		target.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final SlotSharingGroup sharingGroup = new SlotSharingGroup()__		source.setSlotSharingGroup(sharingGroup)__		target.setSlotSharingGroup(sharingGroup)___		source.setStrictlyCoLocatedWith(target)___		final JobGraph jobGraph = new JobGraph("test job", source, target)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion sourceRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0])__		FailoverRegion sourceRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[1])__		FailoverRegion targetRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0])__		FailoverRegion targetRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[1])___		_		_		assertTrue(sourceRegion1 == sourceRegion2)__		assertTrue(sourceRegion2 == targetRegion1)__		assertTrue(targetRegion1 == targetRegion2)__	};this,test,checks,that,are,strictly,co,located,vertices,are,in,the,same,failover,region,even,through,they,are,connected,via,a,blocking,pattern,this,is,currently,an,assumption,limitation,of,the,scheduler;test,public,void,test,pipelined,one,to,one,topology,with,co,location,throws,exception,final,job,vertex,source,new,job,vertex,source,source,set,invokable,class,no,op,invokable,class,source,set,parallelism,10,final,job,vertex,target,new,job,vertex,target,target,set,invokable,class,no,op,invokable,class,target,set,parallelism,10,target,connect,new,data,set,as,input,source,distribution,pattern,pointwise,result,partition,type,pipelined,final,slot,sharing,group,sharing,group,new,slot,sharing,group,source,set,slot,sharing,group,sharing,group,target,set,slot,sharing,group,sharing,group,source,set,strictly,co,located,with,target,final,job,graph,job,graph,new,job,graph,test,job,source,target,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,source,region1,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,0,failover,region,source,region2,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,1,failover,region,target,region1,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,0,failover,region,target,region2,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,1,assert,true,source,region1,source,region2,assert,true,source,region2,target,region1,assert,true,target,region1,target,region2
PipelinedFailoverRegionBuildingTest -> @Test 	public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception;1508861310;This test checks that are strictly co-located vertices are in the same failover region,_even through they are connected via a blocking pattern._This is currently an assumption / limitation of the scheduler.;@Test_	public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception {_		final JobVertex source = new JobVertex("source")__		source.setInvokableClass(NoOpInvokable.class)__		source.setParallelism(10)___		final JobVertex target = new JobVertex("target")__		target.setInvokableClass(NoOpInvokable.class)__		target.setParallelism(10)___		target.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final SlotSharingGroup sharingGroup = new SlotSharingGroup()__		source.setSlotSharingGroup(sharingGroup)__		target.setSlotSharingGroup(sharingGroup)___		source.setStrictlyCoLocatedWith(target)___		final JobGraph jobGraph = new JobGraph("test job", source, target)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion sourceRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0])__		FailoverRegion sourceRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[1])__		FailoverRegion targetRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0])__		FailoverRegion targetRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[1])___		_		_		assertTrue(sourceRegion1 == sourceRegion2)__		assertTrue(sourceRegion2 == targetRegion1)__		assertTrue(targetRegion1 == targetRegion2)__	};this,test,checks,that,are,strictly,co,located,vertices,are,in,the,same,failover,region,even,through,they,are,connected,via,a,blocking,pattern,this,is,currently,an,assumption,limitation,of,the,scheduler;test,public,void,test,pipelined,one,to,one,topology,with,co,location,throws,exception,final,job,vertex,source,new,job,vertex,source,source,set,invokable,class,no,op,invokable,class,source,set,parallelism,10,final,job,vertex,target,new,job,vertex,target,target,set,invokable,class,no,op,invokable,class,target,set,parallelism,10,target,connect,new,data,set,as,input,source,distribution,pattern,pointwise,result,partition,type,pipelined,final,slot,sharing,group,sharing,group,new,slot,sharing,group,source,set,slot,sharing,group,sharing,group,target,set,slot,sharing,group,sharing,group,source,set,strictly,co,located,with,target,final,job,graph,job,graph,new,job,graph,test,job,source,target,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,source,region1,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,0,failover,region,source,region2,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,1,failover,region,target,region1,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,0,failover,region,target,region2,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,1,assert,true,source,region1,source,region2,assert,true,source,region2,target,region1,assert,true,target,region1,target,region2
PipelinedFailoverRegionBuildingTest -> @Test 	public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception;1508861311;This test checks that are strictly co-located vertices are in the same failover region,_even through they are connected via a blocking pattern._This is currently an assumption / limitation of the scheduler.;@Test_	public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception {_		final JobVertex source = new JobVertex("source")__		source.setInvokableClass(NoOpInvokable.class)__		source.setParallelism(10)___		final JobVertex target = new JobVertex("target")__		target.setInvokableClass(NoOpInvokable.class)__		target.setParallelism(10)___		target.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final SlotSharingGroup sharingGroup = new SlotSharingGroup()__		source.setSlotSharingGroup(sharingGroup)__		target.setSlotSharingGroup(sharingGroup)___		source.setStrictlyCoLocatedWith(target)___		final JobGraph jobGraph = new JobGraph("test job", source, target)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion sourceRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0])__		FailoverRegion sourceRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[1])__		FailoverRegion targetRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0])__		FailoverRegion targetRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[1])___		_		_		assertTrue(sourceRegion1 == sourceRegion2)__		assertTrue(sourceRegion2 == targetRegion1)__		assertTrue(targetRegion1 == targetRegion2)__	};this,test,checks,that,are,strictly,co,located,vertices,are,in,the,same,failover,region,even,through,they,are,connected,via,a,blocking,pattern,this,is,currently,an,assumption,limitation,of,the,scheduler;test,public,void,test,pipelined,one,to,one,topology,with,co,location,throws,exception,final,job,vertex,source,new,job,vertex,source,source,set,invokable,class,no,op,invokable,class,source,set,parallelism,10,final,job,vertex,target,new,job,vertex,target,target,set,invokable,class,no,op,invokable,class,target,set,parallelism,10,target,connect,new,data,set,as,input,source,distribution,pattern,pointwise,result,partition,type,pipelined,final,slot,sharing,group,sharing,group,new,slot,sharing,group,source,set,slot,sharing,group,sharing,group,target,set,slot,sharing,group,sharing,group,source,set,strictly,co,located,with,target,final,job,graph,job,graph,new,job,graph,test,job,source,target,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,source,region1,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,0,failover,region,source,region2,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,1,failover,region,target,region1,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,0,failover,region,target,region2,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,1,assert,true,source,region1,source,region2,assert,true,source,region2,target,region1,assert,true,target,region1,target,region2
PipelinedFailoverRegionBuildingTest -> @Test 	public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception;1513261599;This test checks that are strictly co-located vertices are in the same failover region,_even through they are connected via a blocking pattern._This is currently an assumption / limitation of the scheduler.;@Test_	public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception {_		final JobVertex source = new JobVertex("source")__		source.setInvokableClass(NoOpInvokable.class)__		source.setParallelism(10)___		final JobVertex target = new JobVertex("target")__		target.setInvokableClass(NoOpInvokable.class)__		target.setParallelism(10)___		target.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final SlotSharingGroup sharingGroup = new SlotSharingGroup()__		source.setSlotSharingGroup(sharingGroup)__		target.setSlotSharingGroup(sharingGroup)___		source.setStrictlyCoLocatedWith(target)___		final JobGraph jobGraph = new JobGraph("test job", source, target)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion sourceRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0])__		FailoverRegion sourceRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[1])__		FailoverRegion targetRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0])__		FailoverRegion targetRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[1])___		_		_		assertTrue(sourceRegion1 == sourceRegion2)__		assertTrue(sourceRegion2 == targetRegion1)__		assertTrue(targetRegion1 == targetRegion2)__	};this,test,checks,that,are,strictly,co,located,vertices,are,in,the,same,failover,region,even,through,they,are,connected,via,a,blocking,pattern,this,is,currently,an,assumption,limitation,of,the,scheduler;test,public,void,test,pipelined,one,to,one,topology,with,co,location,throws,exception,final,job,vertex,source,new,job,vertex,source,source,set,invokable,class,no,op,invokable,class,source,set,parallelism,10,final,job,vertex,target,new,job,vertex,target,target,set,invokable,class,no,op,invokable,class,target,set,parallelism,10,target,connect,new,data,set,as,input,source,distribution,pattern,pointwise,result,partition,type,pipelined,final,slot,sharing,group,sharing,group,new,slot,sharing,group,source,set,slot,sharing,group,sharing,group,target,set,slot,sharing,group,sharing,group,source,set,strictly,co,located,with,target,final,job,graph,job,graph,new,job,graph,test,job,source,target,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,source,region1,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,0,failover,region,source,region2,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,1,failover,region,target,region1,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,0,failover,region,target,region2,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,1,assert,true,source,region1,source,region2,assert,true,source,region2,target,region1,assert,true,target,region1,target,region2
PipelinedFailoverRegionBuildingTest -> @Test 	public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception;1518680774;This test checks that are strictly co-located vertices are in the same failover region,_even through they are connected via a blocking pattern._This is currently an assumption / limitation of the scheduler.;@Test_	public void testPipelinedOneToOneTopologyWithCoLocation() throws Exception {_		final JobVertex source = new JobVertex("source")__		source.setInvokableClass(NoOpInvokable.class)__		source.setParallelism(10)___		final JobVertex target = new JobVertex("target")__		target.setInvokableClass(NoOpInvokable.class)__		target.setParallelism(10)___		target.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final SlotSharingGroup sharingGroup = new SlotSharingGroup()__		source.setSlotSharingGroup(sharingGroup)__		target.setSlotSharingGroup(sharingGroup)___		source.setStrictlyCoLocatedWith(target)___		final JobGraph jobGraph = new JobGraph("test job", source, target)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion sourceRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[0])__		FailoverRegion sourceRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(source.getID()).getTaskVertices()[1])__		FailoverRegion targetRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[0])__		FailoverRegion targetRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(target.getID()).getTaskVertices()[1])___		_		_		assertTrue(sourceRegion1 == sourceRegion2)__		assertTrue(sourceRegion2 == targetRegion1)__		assertTrue(targetRegion1 == targetRegion2)__	};this,test,checks,that,are,strictly,co,located,vertices,are,in,the,same,failover,region,even,through,they,are,connected,via,a,blocking,pattern,this,is,currently,an,assumption,limitation,of,the,scheduler;test,public,void,test,pipelined,one,to,one,topology,with,co,location,throws,exception,final,job,vertex,source,new,job,vertex,source,source,set,invokable,class,no,op,invokable,class,source,set,parallelism,10,final,job,vertex,target,new,job,vertex,target,target,set,invokable,class,no,op,invokable,class,target,set,parallelism,10,target,connect,new,data,set,as,input,source,distribution,pattern,pointwise,result,partition,type,pipelined,final,slot,sharing,group,sharing,group,new,slot,sharing,group,source,set,slot,sharing,group,sharing,group,target,set,slot,sharing,group,sharing,group,source,set,strictly,co,located,with,target,final,job,graph,job,graph,new,job,graph,test,job,source,target,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,source,region1,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,0,failover,region,source,region2,failover,strategy,get,failover,region,eg,get,job,vertex,source,get,id,get,task,vertices,1,failover,region,target,region1,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,0,failover,region,target,region2,failover,strategy,get,failover,region,eg,get,job,vertex,target,get,id,get,task,vertices,1,assert,true,source,region1,source,region2,assert,true,source,region2,target,region1,assert,true,target,region1,target,region2
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentViaTwoExchanges() throws Exception;1494099604;Tests that validates that a single pipelined component via a sequence of all-to-all_connections works correctly.__<pre>_(a1) -+-> (b1) -+-> (c1)_X         X_(a2) -+-> (b2) -+-> (c2)_X         X_(a3) -+-> (b3) -+-> (c3)__..._</pre>;@Test_	public void testOneComponentViaTwoExchanges() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(5)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[4])__		FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])___		assertTrue(region1 == region2)__		assertTrue(region2 == region3)__	};tests,that,validates,that,a,single,pipelined,component,via,a,sequence,of,all,to,all,connections,works,correctly,pre,a1,b1,c1,x,x,a2,b2,c2,x,x,a3,b3,c3,pre;test,public,void,test,one,component,via,two,exchanges,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,5,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,4,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,assert,true,region1,region2,assert,true,region2,region3
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentViaTwoExchanges() throws Exception;1508861310;Tests that validates that a single pipelined component via a sequence of all-to-all_connections works correctly.__<pre>_(a1) -+-> (b1) -+-> (c1)_X         X_(a2) -+-> (b2) -+-> (c2)_X         X_(a3) -+-> (b3) -+-> (c3)__..._</pre>;@Test_	public void testOneComponentViaTwoExchanges() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(5)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[4])__		FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])___		assertTrue(region1 == region2)__		assertTrue(region2 == region3)__	};tests,that,validates,that,a,single,pipelined,component,via,a,sequence,of,all,to,all,connections,works,correctly,pre,a1,b1,c1,x,x,a2,b2,c2,x,x,a3,b3,c3,pre;test,public,void,test,one,component,via,two,exchanges,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,5,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,4,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,assert,true,region1,region2,assert,true,region2,region3
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentViaTwoExchanges() throws Exception;1508861311;Tests that validates that a single pipelined component via a sequence of all-to-all_connections works correctly.__<pre>_(a1) -+-> (b1) -+-> (c1)_X         X_(a2) -+-> (b2) -+-> (c2)_X         X_(a3) -+-> (b3) -+-> (c3)__..._</pre>;@Test_	public void testOneComponentViaTwoExchanges() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(5)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[4])__		FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])___		assertTrue(region1 == region2)__		assertTrue(region2 == region3)__	};tests,that,validates,that,a,single,pipelined,component,via,a,sequence,of,all,to,all,connections,works,correctly,pre,a1,b1,c1,x,x,a2,b2,c2,x,x,a3,b3,c3,pre;test,public,void,test,one,component,via,two,exchanges,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,5,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,4,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,assert,true,region1,region2,assert,true,region2,region3
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentViaTwoExchanges() throws Exception;1513261599;Tests that validates that a single pipelined component via a sequence of all-to-all_connections works correctly.__<pre>_(a1) -+-> (b1) -+-> (c1)_X         X_(a2) -+-> (b2) -+-> (c2)_X         X_(a3) -+-> (b3) -+-> (c3)__..._</pre>;@Test_	public void testOneComponentViaTwoExchanges() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(5)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[4])__		FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])___		assertTrue(region1 == region2)__		assertTrue(region2 == region3)__	};tests,that,validates,that,a,single,pipelined,component,via,a,sequence,of,all,to,all,connections,works,correctly,pre,a1,b1,c1,x,x,a2,b2,c2,x,x,a3,b3,c3,pre;test,public,void,test,one,component,via,two,exchanges,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,5,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,4,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,assert,true,region1,region2,assert,true,region2,region3
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentViaTwoExchanges() throws Exception;1518680774;Tests that validates that a single pipelined component via a sequence of all-to-all_connections works correctly.__<pre>_(a1) -+-> (b1) -+-> (c1)_X         X_(a2) -+-> (b2) -+-> (c2)_X         X_(a3) -+-> (b3) -+-> (c3)__..._</pre>;@Test_	public void testOneComponentViaTwoExchanges() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(5)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[4])__		FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])___		assertTrue(region1 == region2)__		assertTrue(region2 == region3)__	};tests,that,validates,that,a,single,pipelined,component,via,a,sequence,of,all,to,all,connections,works,correctly,pre,a1,b1,c1,x,x,a2,b2,c2,x,x,a3,b3,c3,pre;test,public,void,test,one,component,via,two,exchanges,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,5,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,4,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,assert,true,region1,region2,assert,true,region2,region3
PipelinedFailoverRegionBuildingTest -> @Test 	public void testTwoComponentsViaBlockingExchange2() throws Exception;1494099604;<pre>_(a1) -+-> (b1) -+-> (c1)_X         X_(a2) -+-> (b2) -+-> (c2)_X         X_(a3) -+-> (b3) -+-> (c3)__^         ^_|         |_(pipelined) (blocking)_</pre>;@Test_	public void testTwoComponentsViaBlockingExchange2() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(2)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion region31 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region32 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[1])___		assertTrue(region1 == region2)__		assertTrue(region2 != region31)__		assertTrue(region32 != region31)__	};pre,a1,b1,c1,x,x,a2,b2,c2,x,x,a3,b3,c3,pipelined,blocking,pre;test,public,void,test,two,components,via,blocking,exchange2,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,2,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,region31,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region32,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,1,assert,true,region1,region2,assert,true,region2,region31,assert,true,region32,region31
PipelinedFailoverRegionBuildingTest -> @Test 	public void testTwoComponentsViaBlockingExchange2() throws Exception;1508861310;<pre>_(a1) -+-> (b1) -+-> (c1)_X         X_(a2) -+-> (b2) -+-> (c2)_X         X_(a3) -+-> (b3) -+-> (c3)__^         ^_|         |_(pipelined) (blocking)_</pre>;@Test_	public void testTwoComponentsViaBlockingExchange2() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(2)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion region31 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region32 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[1])___		assertTrue(region1 == region2)__		assertTrue(region2 != region31)__		assertTrue(region32 != region31)__	};pre,a1,b1,c1,x,x,a2,b2,c2,x,x,a3,b3,c3,pipelined,blocking,pre;test,public,void,test,two,components,via,blocking,exchange2,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,2,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,region31,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region32,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,1,assert,true,region1,region2,assert,true,region2,region31,assert,true,region32,region31
PipelinedFailoverRegionBuildingTest -> @Test 	public void testTwoComponentsViaBlockingExchange2() throws Exception;1508861311;<pre>_(a1) -+-> (b1) -+-> (c1)_X         X_(a2) -+-> (b2) -+-> (c2)_X         X_(a3) -+-> (b3) -+-> (c3)__^         ^_|         |_(pipelined) (blocking)_</pre>;@Test_	public void testTwoComponentsViaBlockingExchange2() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(2)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion region31 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region32 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[1])___		assertTrue(region1 == region2)__		assertTrue(region2 != region31)__		assertTrue(region32 != region31)__	};pre,a1,b1,c1,x,x,a2,b2,c2,x,x,a3,b3,c3,pipelined,blocking,pre;test,public,void,test,two,components,via,blocking,exchange2,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,2,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,region31,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region32,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,1,assert,true,region1,region2,assert,true,region2,region31,assert,true,region32,region31
PipelinedFailoverRegionBuildingTest -> @Test 	public void testTwoComponentsViaBlockingExchange2() throws Exception;1513261599;<pre>_(a1) -+-> (b1) -+-> (c1)_X         X_(a2) -+-> (b2) -+-> (c2)_X         X_(a3) -+-> (b3) -+-> (c3)__^         ^_|         |_(pipelined) (blocking)_</pre>;@Test_	public void testTwoComponentsViaBlockingExchange2() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(2)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion region31 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region32 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[1])___		assertTrue(region1 == region2)__		assertTrue(region2 != region31)__		assertTrue(region32 != region31)__	};pre,a1,b1,c1,x,x,a2,b2,c2,x,x,a3,b3,c3,pipelined,blocking,pre;test,public,void,test,two,components,via,blocking,exchange2,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,2,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,region31,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region32,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,1,assert,true,region1,region2,assert,true,region2,region31,assert,true,region32,region31
PipelinedFailoverRegionBuildingTest -> @Test 	public void testTwoComponentsViaBlockingExchange2() throws Exception;1518680774;<pre>_(a1) -+-> (b1) -+-> (c1)_X         X_(a2) -+-> (b2) -+-> (c2)_X         X_(a3) -+-> (b3) -+-> (c3)__^         ^_|         |_(pipelined) (blocking)_</pre>;@Test_	public void testTwoComponentsViaBlockingExchange2() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(2)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion region31 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region32 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[1])___		assertTrue(region1 == region2)__		assertTrue(region2 != region31)__		assertTrue(region32 != region31)__	};pre,a1,b1,c1,x,x,a2,b2,c2,x,x,a3,b3,c3,pipelined,blocking,pre;test,public,void,test,two,components,via,blocking,exchange2,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,2,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,region31,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region32,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,1,assert,true,region1,region2,assert,true,region2,region31,assert,true,region32,region31
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentViaCascadeOfJoins() throws Exception;1494099604;Tests that validates that a single pipelined component via a cascade of joins_works correctly.__<p>Non-parallelized view:_<pre>_(1)--+_+--(5)-+_(2)--+      |_+--(7)_(3)--+      |_+--(6)-+_(4)--+_..._</pre>;@Test_	public void testOneComponentViaCascadeOfJoins() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex5.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex5.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex6.connectNewDataSetAsInput(vertex3, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex4, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex7.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex7.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex7)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		Iterator<ExecutionVertex> evs = eg.getAllExecutionVertices().iterator()___		FailoverRegion preRegion = failoverStrategy.getFailoverRegion(evs.next())___		while (evs.hasNext()) {_			FailoverRegion region = failoverStrategy.getFailoverRegion(evs.next())__			assertTrue(preRegion == region)__		}_	};tests,that,validates,that,a,single,pipelined,component,via,a,cascade,of,joins,works,correctly,p,non,parallelized,view,pre,1,5,2,7,3,6,4,pre;test,public,void,test,one,component,via,cascade,of,joins,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex5,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex3,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex4,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,vertex4,vertex5,vertex6,vertex7,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,iterator,execution,vertex,evs,eg,get,all,execution,vertices,iterator,failover,region,pre,region,failover,strategy,get,failover,region,evs,next,while,evs,has,next,failover,region,region,failover,strategy,get,failover,region,evs,next,assert,true,pre,region,region
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentViaCascadeOfJoins() throws Exception;1508861310;Tests that validates that a single pipelined component via a cascade of joins_works correctly.__<p>Non-parallelized view:_<pre>_(1)--+_+--(5)-+_(2)--+      |_+--(7)_(3)--+      |_+--(6)-+_(4)--+_..._</pre>;@Test_	public void testOneComponentViaCascadeOfJoins() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex5.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex5.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex6.connectNewDataSetAsInput(vertex3, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex4, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex7.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex7.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex7)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		Iterator<ExecutionVertex> evs = eg.getAllExecutionVertices().iterator()___		FailoverRegion preRegion = failoverStrategy.getFailoverRegion(evs.next())___		while (evs.hasNext()) {_			FailoverRegion region = failoverStrategy.getFailoverRegion(evs.next())__			assertTrue(preRegion == region)__		}_	};tests,that,validates,that,a,single,pipelined,component,via,a,cascade,of,joins,works,correctly,p,non,parallelized,view,pre,1,5,2,7,3,6,4,pre;test,public,void,test,one,component,via,cascade,of,joins,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex5,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex3,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex4,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,vertex4,vertex5,vertex6,vertex7,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,iterator,execution,vertex,evs,eg,get,all,execution,vertices,iterator,failover,region,pre,region,failover,strategy,get,failover,region,evs,next,while,evs,has,next,failover,region,region,failover,strategy,get,failover,region,evs,next,assert,true,pre,region,region
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentViaCascadeOfJoins() throws Exception;1508861311;Tests that validates that a single pipelined component via a cascade of joins_works correctly.__<p>Non-parallelized view:_<pre>_(1)--+_+--(5)-+_(2)--+      |_+--(7)_(3)--+      |_+--(6)-+_(4)--+_..._</pre>;@Test_	public void testOneComponentViaCascadeOfJoins() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex5.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex5.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex6.connectNewDataSetAsInput(vertex3, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex4, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex7.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex7.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex7)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		Iterator<ExecutionVertex> evs = eg.getAllExecutionVertices().iterator()___		FailoverRegion preRegion = failoverStrategy.getFailoverRegion(evs.next())___		while (evs.hasNext()) {_			FailoverRegion region = failoverStrategy.getFailoverRegion(evs.next())__			assertTrue(preRegion == region)__		}_	};tests,that,validates,that,a,single,pipelined,component,via,a,cascade,of,joins,works,correctly,p,non,parallelized,view,pre,1,5,2,7,3,6,4,pre;test,public,void,test,one,component,via,cascade,of,joins,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex5,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex3,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex4,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,vertex4,vertex5,vertex6,vertex7,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,iterator,execution,vertex,evs,eg,get,all,execution,vertices,iterator,failover,region,pre,region,failover,strategy,get,failover,region,evs,next,while,evs,has,next,failover,region,region,failover,strategy,get,failover,region,evs,next,assert,true,pre,region,region
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentViaCascadeOfJoins() throws Exception;1513261599;Tests that validates that a single pipelined component via a cascade of joins_works correctly.__<p>Non-parallelized view:_<pre>_(1)--+_+--(5)-+_(2)--+      |_+--(7)_(3)--+      |_+--(6)-+_(4)--+_..._</pre>;@Test_	public void testOneComponentViaCascadeOfJoins() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex5.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex5.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex6.connectNewDataSetAsInput(vertex3, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex4, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex7.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex7.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex7)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		Iterator<ExecutionVertex> evs = eg.getAllExecutionVertices().iterator()___		FailoverRegion preRegion = failoverStrategy.getFailoverRegion(evs.next())___		while (evs.hasNext()) {_			FailoverRegion region = failoverStrategy.getFailoverRegion(evs.next())__			assertTrue(preRegion == region)__		}_	};tests,that,validates,that,a,single,pipelined,component,via,a,cascade,of,joins,works,correctly,p,non,parallelized,view,pre,1,5,2,7,3,6,4,pre;test,public,void,test,one,component,via,cascade,of,joins,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex5,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex3,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex4,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,vertex4,vertex5,vertex6,vertex7,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,iterator,execution,vertex,evs,eg,get,all,execution,vertices,iterator,failover,region,pre,region,failover,strategy,get,failover,region,evs,next,while,evs,has,next,failover,region,region,failover,strategy,get,failover,region,evs,next,assert,true,pre,region,region
PipelinedFailoverRegionBuildingTest -> @Test 	public void testOneComponentViaCascadeOfJoins() throws Exception;1518680774;Tests that validates that a single pipelined component via a cascade of joins_works correctly.__<p>Non-parallelized view:_<pre>_(1)--+_+--(5)-+_(2)--+      |_+--(7)_(3)--+      |_+--(6)-+_(4)--+_..._</pre>;@Test_	public void testOneComponentViaCascadeOfJoins() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex5.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex5.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex6.connectNewDataSetAsInput(vertex3, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex4, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex7.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex7.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex7)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		Iterator<ExecutionVertex> evs = eg.getAllExecutionVertices().iterator()___		FailoverRegion preRegion = failoverStrategy.getFailoverRegion(evs.next())___		while (evs.hasNext()) {_			FailoverRegion region = failoverStrategy.getFailoverRegion(evs.next())__			assertTrue(preRegion == region)__		}_	};tests,that,validates,that,a,single,pipelined,component,via,a,cascade,of,joins,works,correctly,p,non,parallelized,view,pre,1,5,2,7,3,6,4,pre;test,public,void,test,one,component,via,cascade,of,joins,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex5,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex3,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex4,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,vertex4,vertex5,vertex6,vertex7,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,iterator,execution,vertex,evs,eg,get,all,execution,vertices,iterator,failover,region,pre,region,failover,strategy,get,failover,region,evs,next,while,evs,has,next,failover,region,region,failover,strategy,get,failover,region,evs,next,assert,true,pre,region,region
PipelinedFailoverRegionBuildingTest -> @Test 	public void testTwoComponentsViaBlockingExchange() throws Exception;1494099604;<pre>_(a1) -+-> (b1) -+-> (c1)__(a2) -+-> (b2) -+-> (c2)__(a3) -+-> (b3) -+-> (c3)__^         ^_|         |_(pipelined) (blocking)__</pre>;@Test_	public void testTwoComponentsViaBlockingExchange() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(2)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion region31 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region32 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[1])___		assertTrue(region1 == region2)__		assertTrue(region2 != region31)__		assertTrue(region32 != region31)__	};pre,a1,b1,c1,a2,b2,c2,a3,b3,c3,pipelined,blocking,pre;test,public,void,test,two,components,via,blocking,exchange,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,2,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,pointwise,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,region31,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region32,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,1,assert,true,region1,region2,assert,true,region2,region31,assert,true,region32,region31
PipelinedFailoverRegionBuildingTest -> @Test 	public void testTwoComponentsViaBlockingExchange() throws Exception;1508861310;<pre>_(a1) -+-> (b1) -+-> (c1)__(a2) -+-> (b2) -+-> (c2)__(a3) -+-> (b3) -+-> (c3)__^         ^_|         |_(pipelined) (blocking)__</pre>;@Test_	public void testTwoComponentsViaBlockingExchange() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(2)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion region31 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region32 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[1])___		assertTrue(region1 == region2)__		assertTrue(region2 != region31)__		assertTrue(region32 != region31)__	};pre,a1,b1,c1,a2,b2,c2,a3,b3,c3,pipelined,blocking,pre;test,public,void,test,two,components,via,blocking,exchange,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,2,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,pointwise,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,region31,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region32,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,1,assert,true,region1,region2,assert,true,region2,region31,assert,true,region32,region31
PipelinedFailoverRegionBuildingTest -> @Test 	public void testTwoComponentsViaBlockingExchange() throws Exception;1508861311;<pre>_(a1) -+-> (b1) -+-> (c1)__(a2) -+-> (b2) -+-> (c2)__(a3) -+-> (b3) -+-> (c3)__^         ^_|         |_(pipelined) (blocking)__</pre>;@Test_	public void testTwoComponentsViaBlockingExchange() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(2)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion region31 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region32 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[1])___		assertTrue(region1 == region2)__		assertTrue(region2 != region31)__		assertTrue(region32 != region31)__	};pre,a1,b1,c1,a2,b2,c2,a3,b3,c3,pipelined,blocking,pre;test,public,void,test,two,components,via,blocking,exchange,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,2,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,pointwise,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,region31,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region32,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,1,assert,true,region1,region2,assert,true,region2,region31,assert,true,region32,region31
PipelinedFailoverRegionBuildingTest -> @Test 	public void testTwoComponentsViaBlockingExchange() throws Exception;1513261599;<pre>_(a1) -+-> (b1) -+-> (c1)__(a2) -+-> (b2) -+-> (c2)__(a3) -+-> (b3) -+-> (c3)__^         ^_|         |_(pipelined) (blocking)__</pre>;@Test_	public void testTwoComponentsViaBlockingExchange() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(2)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion region31 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region32 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[1])___		assertTrue(region1 == region2)__		assertTrue(region2 != region31)__		assertTrue(region32 != region31)__	};pre,a1,b1,c1,a2,b2,c2,a3,b3,c3,pipelined,blocking,pre;test,public,void,test,two,components,via,blocking,exchange,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,2,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,pointwise,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,region31,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region32,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,1,assert,true,region1,region2,assert,true,region2,region31,assert,true,region32,region31
PipelinedFailoverRegionBuildingTest -> @Test 	public void testTwoComponentsViaBlockingExchange() throws Exception;1518680774;<pre>_(a1) -+-> (b1) -+-> (c1)__(a2) -+-> (b2) -+-> (c2)__(a3) -+-> (b3) -+-> (c3)__^         ^_|         |_(pipelined) (blocking)__</pre>;@Test_	public void testTwoComponentsViaBlockingExchange() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(3)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(2)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(2)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[1])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion region31 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region32 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[1])___		assertTrue(region1 == region2)__		assertTrue(region2 != region31)__		assertTrue(region32 != region31)__	};pre,a1,b1,c1,a2,b2,c2,a3,b3,c3,pipelined,blocking,pre;test,public,void,test,two,components,via,blocking,exchange,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,3,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,2,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,2,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,pointwise,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,1,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,region31,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region32,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,1,assert,true,region1,region2,assert,true,region2,region31,assert,true,region32,region31
PipelinedFailoverRegionBuildingTest -> @Test 	public void testEmbarrassinglyParallelCase() throws Exception;1494099604;Tests that validates that embarrassingly parallel chains of vertices work correctly.__<pre>_(a1) --> (b1)__(a2) --> (b2)__(a3) --> (b3)__..._</pre>;@Test_	public void testEmbarrassinglyParallelCase() throws Exception {_		int parallelism = 10000__		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(parallelism)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(parallelism)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(parallelism)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion preRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[0])__		FailoverRegion preRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion preRegion3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])___		assertTrue(preRegion1 == preRegion2)__		assertTrue(preRegion2 == preRegion3)___		for (int i = 1_ i < parallelism_ ++i) {_			FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[i])__			FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[i])__			FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[i])___			assertTrue(region1 == region2)__			assertTrue(region2 == region3)___			assertTrue(preRegion1 != region1)__		}_	};tests,that,validates,that,embarrassingly,parallel,chains,of,vertices,work,correctly,pre,a1,b1,a2,b2,a3,b3,pre;test,public,void,test,embarrassingly,parallel,case,throws,exception,int,parallelism,10000,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,parallelism,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,parallelism,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,parallelism,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,pointwise,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,pre,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,0,failover,region,pre,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,pre,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,assert,true,pre,region1,pre,region2,assert,true,pre,region2,pre,region3,for,int,i,1,i,parallelism,i,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,i,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,i,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,i,assert,true,region1,region2,assert,true,region2,region3,assert,true,pre,region1,region1
PipelinedFailoverRegionBuildingTest -> @Test 	public void testEmbarrassinglyParallelCase() throws Exception;1508861310;Tests that validates that embarrassingly parallel chains of vertices work correctly.__<pre>_(a1) --> (b1)__(a2) --> (b2)__(a3) --> (b3)__..._</pre>;@Test_	public void testEmbarrassinglyParallelCase() throws Exception {_		int parallelism = 10000__		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(parallelism)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(parallelism)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(parallelism)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion preRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[0])__		FailoverRegion preRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion preRegion3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])___		assertTrue(preRegion1 == preRegion2)__		assertTrue(preRegion2 == preRegion3)___		for (int i = 1_ i < parallelism_ ++i) {_			FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[i])__			FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[i])__			FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[i])___			assertTrue(region1 == region2)__			assertTrue(region2 == region3)___			assertTrue(preRegion1 != region1)__		}_	};tests,that,validates,that,embarrassingly,parallel,chains,of,vertices,work,correctly,pre,a1,b1,a2,b2,a3,b3,pre;test,public,void,test,embarrassingly,parallel,case,throws,exception,int,parallelism,10000,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,parallelism,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,parallelism,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,parallelism,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,pointwise,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,pre,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,0,failover,region,pre,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,pre,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,assert,true,pre,region1,pre,region2,assert,true,pre,region2,pre,region3,for,int,i,1,i,parallelism,i,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,i,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,i,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,i,assert,true,region1,region2,assert,true,region2,region3,assert,true,pre,region1,region1
PipelinedFailoverRegionBuildingTest -> @Test 	public void testEmbarrassinglyParallelCase() throws Exception;1508861311;Tests that validates that embarrassingly parallel chains of vertices work correctly.__<pre>_(a1) --> (b1)__(a2) --> (b2)__(a3) --> (b3)__..._</pre>;@Test_	public void testEmbarrassinglyParallelCase() throws Exception {_		int parallelism = 10000__		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(parallelism)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(parallelism)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(parallelism)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion preRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[0])__		FailoverRegion preRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion preRegion3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])___		assertTrue(preRegion1 == preRegion2)__		assertTrue(preRegion2 == preRegion3)___		for (int i = 1_ i < parallelism_ ++i) {_			FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[i])__			FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[i])__			FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[i])___			assertTrue(region1 == region2)__			assertTrue(region2 == region3)___			assertTrue(preRegion1 != region1)__		}_	};tests,that,validates,that,embarrassingly,parallel,chains,of,vertices,work,correctly,pre,a1,b1,a2,b2,a3,b3,pre;test,public,void,test,embarrassingly,parallel,case,throws,exception,int,parallelism,10000,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,parallelism,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,parallelism,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,parallelism,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,pointwise,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,pre,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,0,failover,region,pre,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,pre,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,assert,true,pre,region1,pre,region2,assert,true,pre,region2,pre,region3,for,int,i,1,i,parallelism,i,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,i,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,i,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,i,assert,true,region1,region2,assert,true,region2,region3,assert,true,pre,region1,region1
PipelinedFailoverRegionBuildingTest -> @Test 	public void testEmbarrassinglyParallelCase() throws Exception;1513261599;Tests that validates that embarrassingly parallel chains of vertices work correctly.__<pre>_(a1) --> (b1)__(a2) --> (b2)__(a3) --> (b3)__..._</pre>;@Test_	public void testEmbarrassinglyParallelCase() throws Exception {_		int parallelism = 10000__		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(parallelism)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(parallelism)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(parallelism)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion preRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[0])__		FailoverRegion preRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion preRegion3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])___		assertTrue(preRegion1 == preRegion2)__		assertTrue(preRegion2 == preRegion3)___		for (int i = 1_ i < parallelism_ ++i) {_			FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[i])__			FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[i])__			FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[i])___			assertTrue(region1 == region2)__			assertTrue(region2 == region3)___			assertTrue(preRegion1 != region1)__		}_	};tests,that,validates,that,embarrassingly,parallel,chains,of,vertices,work,correctly,pre,a1,b1,a2,b2,a3,b3,pre;test,public,void,test,embarrassingly,parallel,case,throws,exception,int,parallelism,10000,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,parallelism,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,parallelism,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,parallelism,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,pointwise,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,pre,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,0,failover,region,pre,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,pre,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,assert,true,pre,region1,pre,region2,assert,true,pre,region2,pre,region3,for,int,i,1,i,parallelism,i,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,i,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,i,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,i,assert,true,region1,region2,assert,true,region2,region3,assert,true,pre,region1,region1
PipelinedFailoverRegionBuildingTest -> @Test 	public void testEmbarrassinglyParallelCase() throws Exception;1518680774;Tests that validates that embarrassingly parallel chains of vertices work correctly.__<pre>_(a1) --> (b1)__(a2) --> (b2)__(a3) --> (b3)__..._</pre>;@Test_	public void testEmbarrassinglyParallelCase() throws Exception {_		int parallelism = 10000__		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(parallelism)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(parallelism)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(parallelism)___		vertex2.connectNewDataSetAsInput(vertex1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)__		vertex3.connectNewDataSetAsInput(vertex2, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()__		FailoverRegion preRegion1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[0])__		FailoverRegion preRegion2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[0])__		FailoverRegion preRegion3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])___		assertTrue(preRegion1 == preRegion2)__		assertTrue(preRegion2 == preRegion3)___		for (int i = 1_ i < parallelism_ ++i) {_			FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[i])__			FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[i])__			FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[i])___			assertTrue(region1 == region2)__			assertTrue(region2 == region3)___			assertTrue(preRegion1 != region1)__		}_	};tests,that,validates,that,embarrassingly,parallel,chains,of,vertices,work,correctly,pre,a1,b1,a2,b2,a3,b3,pre;test,public,void,test,embarrassingly,parallel,case,throws,exception,int,parallelism,10000,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,parallelism,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,parallelism,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,parallelism,vertex2,connect,new,data,set,as,input,vertex1,distribution,pattern,pointwise,result,partition,type,pipelined,vertex3,connect,new,data,set,as,input,vertex2,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,pre,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,0,failover,region,pre,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,0,failover,region,pre,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,assert,true,pre,region1,pre,region2,assert,true,pre,region2,pre,region3,for,int,i,1,i,parallelism,i,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,i,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,i,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,i,assert,true,region1,region2,assert,true,region2,region3,assert,true,pre,region1,region1
PipelinedFailoverRegionBuildingTest -> @Test 	public void testMultipleComponentsViaCascadeOfJoins() throws Exception;1494099604;Cascades of joins with partially blocking, partially pipelined exchanges:_<pre>_(1)--+_+--(5)-+_(2)--+      |_(block)__+--(7)__(block)_(3)--+      |_+--(6)-+_(4)--+_..._</pre>__Component 1: 1, 2, 5_ component 2: 3,4,6_ component 3: 7;@Test_	public void testMultipleComponentsViaCascadeOfJoins() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex5.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex5.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex6.connectNewDataSetAsInput(vertex3, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex4, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex7.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)__		vertex7.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex7)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[0])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[5])__		FailoverRegion region5 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex5.getID()).getTaskVertices()[2])___		assertTrue(region1 == region2)__		assertTrue(region1 == region5)___		FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region4 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex4.getID()).getTaskVertices()[5])__		FailoverRegion region6 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex6.getID()).getTaskVertices()[2])___		assertTrue(region3 == region4)__		assertTrue(region3 == region6)___		FailoverRegion region71 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex7.getID()).getTaskVertices()[0])__		FailoverRegion region72 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex7.getID()).getTaskVertices()[1])___		assertTrue(region71 != region72)__		assertTrue(region1 != region71)__		assertTrue(region1 != region72)__		assertTrue(region3 != region71)__		assertTrue(region3 != region72)__	};cascades,of,joins,with,partially,blocking,partially,pipelined,exchanges,pre,1,5,2,block,7,block,3,6,4,pre,component,1,1,2,5,component,2,3,4,6,component,3,7;test,public,void,test,multiple,components,via,cascade,of,joins,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex5,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex3,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex4,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,blocking,vertex7,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,vertex4,vertex5,vertex6,vertex7,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,0,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,5,failover,region,region5,failover,strategy,get,failover,region,eg,get,job,vertex,vertex5,get,id,get,task,vertices,2,assert,true,region1,region2,assert,true,region1,region5,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region4,failover,strategy,get,failover,region,eg,get,job,vertex,vertex4,get,id,get,task,vertices,5,failover,region,region6,failover,strategy,get,failover,region,eg,get,job,vertex,vertex6,get,id,get,task,vertices,2,assert,true,region3,region4,assert,true,region3,region6,failover,region,region71,failover,strategy,get,failover,region,eg,get,job,vertex,vertex7,get,id,get,task,vertices,0,failover,region,region72,failover,strategy,get,failover,region,eg,get,job,vertex,vertex7,get,id,get,task,vertices,1,assert,true,region71,region72,assert,true,region1,region71,assert,true,region1,region72,assert,true,region3,region71,assert,true,region3,region72
PipelinedFailoverRegionBuildingTest -> @Test 	public void testMultipleComponentsViaCascadeOfJoins() throws Exception;1508861310;Cascades of joins with partially blocking, partially pipelined exchanges:_<pre>_(1)--+_+--(5)-+_(2)--+      |_(block)__+--(7)__(block)_(3)--+      |_+--(6)-+_(4)--+_..._</pre>__Component 1: 1, 2, 5_ component 2: 3,4,6_ component 3: 7;@Test_	public void testMultipleComponentsViaCascadeOfJoins() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex5.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex5.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex6.connectNewDataSetAsInput(vertex3, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex4, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex7.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)__		vertex7.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex7)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[0])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[5])__		FailoverRegion region5 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex5.getID()).getTaskVertices()[2])___		assertTrue(region1 == region2)__		assertTrue(region1 == region5)___		FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region4 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex4.getID()).getTaskVertices()[5])__		FailoverRegion region6 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex6.getID()).getTaskVertices()[2])___		assertTrue(region3 == region4)__		assertTrue(region3 == region6)___		FailoverRegion region71 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex7.getID()).getTaskVertices()[0])__		FailoverRegion region72 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex7.getID()).getTaskVertices()[1])___		assertTrue(region71 != region72)__		assertTrue(region1 != region71)__		assertTrue(region1 != region72)__		assertTrue(region3 != region71)__		assertTrue(region3 != region72)__	};cascades,of,joins,with,partially,blocking,partially,pipelined,exchanges,pre,1,5,2,block,7,block,3,6,4,pre,component,1,1,2,5,component,2,3,4,6,component,3,7;test,public,void,test,multiple,components,via,cascade,of,joins,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex5,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex3,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex4,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,blocking,vertex7,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,vertex4,vertex5,vertex6,vertex7,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,0,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,5,failover,region,region5,failover,strategy,get,failover,region,eg,get,job,vertex,vertex5,get,id,get,task,vertices,2,assert,true,region1,region2,assert,true,region1,region5,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region4,failover,strategy,get,failover,region,eg,get,job,vertex,vertex4,get,id,get,task,vertices,5,failover,region,region6,failover,strategy,get,failover,region,eg,get,job,vertex,vertex6,get,id,get,task,vertices,2,assert,true,region3,region4,assert,true,region3,region6,failover,region,region71,failover,strategy,get,failover,region,eg,get,job,vertex,vertex7,get,id,get,task,vertices,0,failover,region,region72,failover,strategy,get,failover,region,eg,get,job,vertex,vertex7,get,id,get,task,vertices,1,assert,true,region71,region72,assert,true,region1,region71,assert,true,region1,region72,assert,true,region3,region71,assert,true,region3,region72
PipelinedFailoverRegionBuildingTest -> @Test 	public void testMultipleComponentsViaCascadeOfJoins() throws Exception;1508861311;Cascades of joins with partially blocking, partially pipelined exchanges:_<pre>_(1)--+_+--(5)-+_(2)--+      |_(block)__+--(7)__(block)_(3)--+      |_+--(6)-+_(4)--+_..._</pre>__Component 1: 1, 2, 5_ component 2: 3,4,6_ component 3: 7;@Test_	public void testMultipleComponentsViaCascadeOfJoins() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex5.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex5.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex6.connectNewDataSetAsInput(vertex3, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex4, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex7.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)__		vertex7.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex7)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[0])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[5])__		FailoverRegion region5 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex5.getID()).getTaskVertices()[2])___		assertTrue(region1 == region2)__		assertTrue(region1 == region5)___		FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region4 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex4.getID()).getTaskVertices()[5])__		FailoverRegion region6 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex6.getID()).getTaskVertices()[2])___		assertTrue(region3 == region4)__		assertTrue(region3 == region6)___		FailoverRegion region71 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex7.getID()).getTaskVertices()[0])__		FailoverRegion region72 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex7.getID()).getTaskVertices()[1])___		assertTrue(region71 != region72)__		assertTrue(region1 != region71)__		assertTrue(region1 != region72)__		assertTrue(region3 != region71)__		assertTrue(region3 != region72)__	};cascades,of,joins,with,partially,blocking,partially,pipelined,exchanges,pre,1,5,2,block,7,block,3,6,4,pre,component,1,1,2,5,component,2,3,4,6,component,3,7;test,public,void,test,multiple,components,via,cascade,of,joins,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex5,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex3,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex4,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,blocking,vertex7,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,vertex4,vertex5,vertex6,vertex7,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,0,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,5,failover,region,region5,failover,strategy,get,failover,region,eg,get,job,vertex,vertex5,get,id,get,task,vertices,2,assert,true,region1,region2,assert,true,region1,region5,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region4,failover,strategy,get,failover,region,eg,get,job,vertex,vertex4,get,id,get,task,vertices,5,failover,region,region6,failover,strategy,get,failover,region,eg,get,job,vertex,vertex6,get,id,get,task,vertices,2,assert,true,region3,region4,assert,true,region3,region6,failover,region,region71,failover,strategy,get,failover,region,eg,get,job,vertex,vertex7,get,id,get,task,vertices,0,failover,region,region72,failover,strategy,get,failover,region,eg,get,job,vertex,vertex7,get,id,get,task,vertices,1,assert,true,region71,region72,assert,true,region1,region71,assert,true,region1,region72,assert,true,region3,region71,assert,true,region3,region72
PipelinedFailoverRegionBuildingTest -> @Test 	public void testMultipleComponentsViaCascadeOfJoins() throws Exception;1513261599;Cascades of joins with partially blocking, partially pipelined exchanges:_<pre>_(1)--+_+--(5)-+_(2)--+      |_(block)__+--(7)__(block)_(3)--+      |_+--(6)-+_(4)--+_..._</pre>__Component 1: 1, 2, 5_ component 2: 3,4,6_ component 3: 7;@Test_	public void testMultipleComponentsViaCascadeOfJoins() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex5.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex5.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex6.connectNewDataSetAsInput(vertex3, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex4, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex7.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)__		vertex7.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex7)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[0])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[5])__		FailoverRegion region5 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex5.getID()).getTaskVertices()[2])___		assertTrue(region1 == region2)__		assertTrue(region1 == region5)___		FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region4 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex4.getID()).getTaskVertices()[5])__		FailoverRegion region6 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex6.getID()).getTaskVertices()[2])___		assertTrue(region3 == region4)__		assertTrue(region3 == region6)___		FailoverRegion region71 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex7.getID()).getTaskVertices()[0])__		FailoverRegion region72 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex7.getID()).getTaskVertices()[1])___		assertTrue(region71 != region72)__		assertTrue(region1 != region71)__		assertTrue(region1 != region72)__		assertTrue(region3 != region71)__		assertTrue(region3 != region72)__	};cascades,of,joins,with,partially,blocking,partially,pipelined,exchanges,pre,1,5,2,block,7,block,3,6,4,pre,component,1,1,2,5,component,2,3,4,6,component,3,7;test,public,void,test,multiple,components,via,cascade,of,joins,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex5,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex3,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex4,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,blocking,vertex7,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,vertex4,vertex5,vertex6,vertex7,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,0,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,5,failover,region,region5,failover,strategy,get,failover,region,eg,get,job,vertex,vertex5,get,id,get,task,vertices,2,assert,true,region1,region2,assert,true,region1,region5,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region4,failover,strategy,get,failover,region,eg,get,job,vertex,vertex4,get,id,get,task,vertices,5,failover,region,region6,failover,strategy,get,failover,region,eg,get,job,vertex,vertex6,get,id,get,task,vertices,2,assert,true,region3,region4,assert,true,region3,region6,failover,region,region71,failover,strategy,get,failover,region,eg,get,job,vertex,vertex7,get,id,get,task,vertices,0,failover,region,region72,failover,strategy,get,failover,region,eg,get,job,vertex,vertex7,get,id,get,task,vertices,1,assert,true,region71,region72,assert,true,region1,region71,assert,true,region1,region72,assert,true,region3,region71,assert,true,region3,region72
PipelinedFailoverRegionBuildingTest -> @Test 	public void testMultipleComponentsViaCascadeOfJoins() throws Exception;1518680774;Cascades of joins with partially blocking, partially pipelined exchanges:_<pre>_(1)--+_+--(5)-+_(2)--+      |_(block)__+--(7)__(block)_(3)--+      |_+--(6)-+_(4)--+_..._</pre>__Component 1: 1, 2, 5_ component 2: 3,4,6_ component 3: 7;@Test_	public void testMultipleComponentsViaCascadeOfJoins() throws Exception {_		final JobVertex vertex1 = new JobVertex("vertex1")__		vertex1.setInvokableClass(NoOpInvokable.class)__		vertex1.setParallelism(8)___		final JobVertex vertex2 = new JobVertex("vertex2")__		vertex2.setInvokableClass(NoOpInvokable.class)__		vertex2.setParallelism(8)___		final JobVertex vertex3 = new JobVertex("vertex3")__		vertex3.setInvokableClass(NoOpInvokable.class)__		vertex3.setParallelism(8)___		final JobVertex vertex4 = new JobVertex("vertex4")__		vertex4.setInvokableClass(NoOpInvokable.class)__		vertex4.setParallelism(8)___		final JobVertex vertex5 = new JobVertex("vertex5")__		vertex5.setInvokableClass(NoOpInvokable.class)__		vertex5.setParallelism(4)___		final JobVertex vertex6 = new JobVertex("vertex6")__		vertex6.setInvokableClass(NoOpInvokable.class)__		vertex6.setParallelism(4)___		final JobVertex vertex7 = new JobVertex("vertex7")__		vertex7.setInvokableClass(NoOpInvokable.class)__		vertex7.setParallelism(2)___		vertex5.connectNewDataSetAsInput(vertex1, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex5.connectNewDataSetAsInput(vertex2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex6.connectNewDataSetAsInput(vertex3, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)__		vertex6.connectNewDataSetAsInput(vertex4, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		vertex7.connectNewDataSetAsInput(vertex5, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)__		vertex7.connectNewDataSetAsInput(vertex6, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING)___		final JobGraph jobGraph = new JobGraph("test job", vertex1, vertex2, vertex3, vertex4, vertex5, vertex6, vertex7)__		final ExecutionGraph eg = createExecutionGraph(jobGraph)___		RestartPipelinedRegionStrategy failoverStrategy = (RestartPipelinedRegionStrategy) eg.getFailoverStrategy()___		FailoverRegion region1 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex1.getID()).getTaskVertices()[0])__		FailoverRegion region2 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex2.getID()).getTaskVertices()[5])__		FailoverRegion region5 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex5.getID()).getTaskVertices()[2])___		assertTrue(region1 == region2)__		assertTrue(region1 == region5)___		FailoverRegion region3 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex3.getID()).getTaskVertices()[0])__		FailoverRegion region4 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex4.getID()).getTaskVertices()[5])__		FailoverRegion region6 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex6.getID()).getTaskVertices()[2])___		assertTrue(region3 == region4)__		assertTrue(region3 == region6)___		FailoverRegion region71 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex7.getID()).getTaskVertices()[0])__		FailoverRegion region72 = failoverStrategy.getFailoverRegion(eg.getJobVertex(vertex7.getID()).getTaskVertices()[1])___		assertTrue(region71 != region72)__		assertTrue(region1 != region71)__		assertTrue(region1 != region72)__		assertTrue(region3 != region71)__		assertTrue(region3 != region72)__	};cascades,of,joins,with,partially,blocking,partially,pipelined,exchanges,pre,1,5,2,block,7,block,3,6,4,pre,component,1,1,2,5,component,2,3,4,6,component,3,7;test,public,void,test,multiple,components,via,cascade,of,joins,throws,exception,final,job,vertex,vertex1,new,job,vertex,vertex1,vertex1,set,invokable,class,no,op,invokable,class,vertex1,set,parallelism,8,final,job,vertex,vertex2,new,job,vertex,vertex2,vertex2,set,invokable,class,no,op,invokable,class,vertex2,set,parallelism,8,final,job,vertex,vertex3,new,job,vertex,vertex3,vertex3,set,invokable,class,no,op,invokable,class,vertex3,set,parallelism,8,final,job,vertex,vertex4,new,job,vertex,vertex4,vertex4,set,invokable,class,no,op,invokable,class,vertex4,set,parallelism,8,final,job,vertex,vertex5,new,job,vertex,vertex5,vertex5,set,invokable,class,no,op,invokable,class,vertex5,set,parallelism,4,final,job,vertex,vertex6,new,job,vertex,vertex6,vertex6,set,invokable,class,no,op,invokable,class,vertex6,set,parallelism,4,final,job,vertex,vertex7,new,job,vertex,vertex7,vertex7,set,invokable,class,no,op,invokable,class,vertex7,set,parallelism,2,vertex5,connect,new,data,set,as,input,vertex1,distribution,pattern,result,partition,type,pipelined,vertex5,connect,new,data,set,as,input,vertex2,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex3,distribution,pattern,result,partition,type,pipelined,vertex6,connect,new,data,set,as,input,vertex4,distribution,pattern,result,partition,type,pipelined,vertex7,connect,new,data,set,as,input,vertex5,distribution,pattern,result,partition,type,blocking,vertex7,connect,new,data,set,as,input,vertex6,distribution,pattern,result,partition,type,blocking,final,job,graph,job,graph,new,job,graph,test,job,vertex1,vertex2,vertex3,vertex4,vertex5,vertex6,vertex7,final,execution,graph,eg,create,execution,graph,job,graph,restart,pipelined,region,strategy,failover,strategy,restart,pipelined,region,strategy,eg,get,failover,strategy,failover,region,region1,failover,strategy,get,failover,region,eg,get,job,vertex,vertex1,get,id,get,task,vertices,0,failover,region,region2,failover,strategy,get,failover,region,eg,get,job,vertex,vertex2,get,id,get,task,vertices,5,failover,region,region5,failover,strategy,get,failover,region,eg,get,job,vertex,vertex5,get,id,get,task,vertices,2,assert,true,region1,region2,assert,true,region1,region5,failover,region,region3,failover,strategy,get,failover,region,eg,get,job,vertex,vertex3,get,id,get,task,vertices,0,failover,region,region4,failover,strategy,get,failover,region,eg,get,job,vertex,vertex4,get,id,get,task,vertices,5,failover,region,region6,failover,strategy,get,failover,region,eg,get,job,vertex,vertex6,get,id,get,task,vertices,2,assert,true,region3,region4,assert,true,region3,region6,failover,region,region71,failover,strategy,get,failover,region,eg,get,job,vertex,vertex7,get,id,get,task,vertices,0,failover,region,region72,failover,strategy,get,failover,region,eg,get,job,vertex,vertex7,get,id,get,task,vertices,1,assert,true,region71,region72,assert,true,region1,region71,assert,true,region1,region72,assert,true,region3,region71,assert,true,region3,region72
