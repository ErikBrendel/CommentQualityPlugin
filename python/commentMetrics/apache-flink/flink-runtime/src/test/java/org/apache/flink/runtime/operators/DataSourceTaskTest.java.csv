commented;modifiers;parameterAmount;loc;comment;code
false;public;0;61;;@Test public void testDataSourceTask() throws IOException {     int keyCnt = 100.     int valCnt = 20.     this.outList = new ArrayList<Record>().     File tempTestFile = new File(tempFolder.getRoot(), UUID.randomUUID().toString()).     InputFilePreparator.prepareInputFile(new UniformRecordGenerator(keyCnt, valCnt, false), tempTestFile, true).     super.initEnvironment(MEMORY_MANAGER_SIZE, NETWORK_BUFFER_SIZE).     super.addOutput(this.outList).     DataSourceTask<Record> testTask = new DataSourceTask<>(this.mockEnv).     super.registerFileInputTask(testTask, MockInputFormat.class, tempTestFile.toURI().toString(), "\n").     try {         testTask.invoke().     } catch (Exception e) {         System.err.println(e).         Assert.fail("Invoke method caused exception.").     }     try {         Field formatField = DataSourceTask.class.getDeclaredField("format").         formatField.setAccessible(true).         MockInputFormat inputFormat = (MockInputFormat) formatField.get(testTask).         Assert.assertTrue("Invalid status of the input format. Expected for opened: true, Actual: " + inputFormat.opened, inputFormat.opened).         Assert.assertTrue("Invalid status of the input format. Expected for closed: true, Actual: " + inputFormat.closed, inputFormat.closed).     } catch (Exception e) {         System.err.println(e).         Assert.fail("Reflection error while trying to validate inputFormat status.").     }     Assert.assertTrue("Invalid output size. Expected: " + (keyCnt * valCnt) + " Actual: " + this.outList.size(), this.outList.size() == keyCnt * valCnt).     HashMap<Integer, HashSet<Integer>> keyValueCountMap = new HashMap<>(keyCnt).     for (Record kvp : this.outList) {         int key = kvp.getField(0, IntValue.class).getValue().         int val = kvp.getField(1, IntValue.class).getValue().         if (!keyValueCountMap.containsKey(key)) {             keyValueCountMap.put(key, new HashSet<Integer>()).         }         keyValueCountMap.get(key).add(val).     }     Assert.assertTrue("Invalid key count in out file. Expected: " + keyCnt + " Actual: " + keyValueCountMap.keySet().size(), keyValueCountMap.keySet().size() == keyCnt).     for (Integer mapKey : keyValueCountMap.keySet()) {         Assert.assertTrue("Invalid value count for key: " + mapKey + ". Expected: " + valCnt + " Actual: " + keyValueCountMap.get(mapKey).size(), keyValueCountMap.get(mapKey).size() == valCnt).     } }
false;public;0;30;;@Test public void testFailingDataSourceTask() throws IOException {     int keyCnt = 20.     int valCnt = 10.     this.outList = new NirvanaOutputList().     File tempTestFile = new File(tempFolder.getRoot(), UUID.randomUUID().toString()).     InputFilePreparator.prepareInputFile(new UniformRecordGenerator(keyCnt, valCnt, false), tempTestFile, false).     super.initEnvironment(MEMORY_MANAGER_SIZE, NETWORK_BUFFER_SIZE).     super.addOutput(this.outList).     DataSourceTask<Record> testTask = new DataSourceTask<>(this.mockEnv).     super.registerFileInputTask(testTask, MockFailingInputFormat.class, tempTestFile.toURI().toString(), "\n").     boolean stubFailed = false.     try {         testTask.invoke().     } catch (Exception e) {         stubFailed = true.     }     Assert.assertTrue("Function exception was not forwarded.", stubFailed).     // assert that temp file was created     Assert.assertTrue("Temp output file does not exist", tempTestFile.exists()). }
false;public;0;9;;@Override public void run() {     try {         testTask.invoke().     } catch (Exception ie) {         ie.printStackTrace().         Assert.fail("Task threw exception although it was properly canceled").     } }
false;public;0;41;;@Test public void testCancelDataSourceTask() throws IOException {     int keyCnt = 20.     int valCnt = 4.     super.initEnvironment(MEMORY_MANAGER_SIZE, NETWORK_BUFFER_SIZE).     super.addOutput(new NirvanaOutputList()).     File tempTestFile = new File(tempFolder.getRoot(), UUID.randomUUID().toString()).     InputFilePreparator.prepareInputFile(new UniformRecordGenerator(keyCnt, valCnt, false), tempTestFile, false).     final DataSourceTask<Record> testTask = new DataSourceTask<>(this.mockEnv).     super.registerFileInputTask(testTask, MockDelayingInputFormat.class, tempTestFile.toURI().toString(), "\n").     Thread taskRunner = new Thread() {          @Override         public void run() {             try {                 testTask.invoke().             } catch (Exception ie) {                 ie.printStackTrace().                 Assert.fail("Task threw exception although it was properly canceled").             }         }     }.     taskRunner.start().     TaskCancelThread tct = new TaskCancelThread(1, taskRunner, testTask).     tct.start().     try {         tct.join().         taskRunner.join().     } catch (InterruptedException ie) {         Assert.fail("Joining threads failed").     }     // assert that temp file was created     Assert.assertTrue("Temp output file does not exist", tempTestFile.exists()). }
false;public,static;3;22;;public static void prepareInputFile(MutableObjectIterator<Record> inIt, File inputFile, boolean insertInvalidData) throws IOException {     try (BufferedWriter bw = new BufferedWriter(new FileWriter(inputFile))) {         if (insertInvalidData) {             bw.write("####_I_AM_INVALID_########\n").         }         Record rec = new Record().         while ((rec = inIt.next(rec)) != null) {             IntValue key = rec.getField(0, IntValue.class).             IntValue value = rec.getField(1, IntValue.class).             bw.write(key.getValue() + "_" + value.getValue() + "\n").         }         if (insertInvalidData) {             bw.write("####_I_AM_INVALID_########\n").         }         bw.flush().     } }
false;public;4;17;;@Override public Record readRecord(Record target, byte[] record, int offset, int numBytes) {     String line = new String(record, offset, numBytes, ConfigConstants.DEFAULT_CHARSET).     try {         this.key.setValue(Integer.parseInt(line.substring(0, line.indexOf("_")))).         this.value.setValue(Integer.parseInt(line.substring(line.indexOf("_") + 1, line.length()))).     } catch (RuntimeException re) {         return null.     }     target.setField(0, this.key).     target.setField(1, this.value).     return target. }
false;public;0;5;;public void openInputFormat() {     // ensure this is called only once     Assert.assertFalse("Invalid status of the input format. Expected for opened: false, Actual: " + opened, opened).     opened = true. }
false;public;0;5;;public void closeInputFormat() {     // ensure this is called only once     Assert.assertFalse("Invalid status of the input format. Expected for closed: false, Actual: " + closed, closed).     closed = true. }
false;public;4;23;;@Override public Record readRecord(Record target, byte[] record, int offset, int numBytes) {     try {         Thread.sleep(100).     } catch (InterruptedException e) {         return null.     }     String line = new String(record, offset, numBytes, ConfigConstants.DEFAULT_CHARSET).     try {         this.key.setValue(Integer.parseInt(line.substring(0, line.indexOf("_")))).         this.value.setValue(Integer.parseInt(line.substring(line.indexOf("_") + 1, line.length()))).     } catch (RuntimeException re) {         return null.     }     target.setField(0, this.key).     target.setField(1, this.value).     return target. }
false;public;4;23;;@Override public Record readRecord(Record target, byte[] record, int offset, int numBytes) {     if (this.cnt == 10) {         throw new RuntimeException("Excpected Test Exception.").     }     this.cnt++.     String line = new String(record, offset, numBytes, ConfigConstants.DEFAULT_CHARSET).     try {         this.key.setValue(Integer.parseInt(line.substring(0, line.indexOf("_")))).         this.value.setValue(Integer.parseInt(line.substring(line.indexOf("_") + 1, line.length()))).     } catch (RuntimeException re) {         return null.     }     target.setField(0, this.key).     target.setField(1, this.value).     return target. }
