commented;modifiers;parameterAmount;loc;comment;code
false;public;0;34;;@Before public void setup() throws Exception {     rpcService = new TestingRpcService().     jobId = new JobID().     createAndRegisterJobMasterGateway().     jobMasterResourceId = ResourceID.generate().     jobMasterLeaderRetrievalService = new SettableLeaderRetrievalService(jobMasterGateway.getAddress(), jobMasterGateway.getFencingToken().toUUID()).     resourceManagerLeaderElectionService = new TestingLeaderElectionService().     haServices = new TestingHighAvailabilityServicesBuilder().setJobMasterLeaderRetrieverFunction(requestedJobId -> {         if (requestedJobId.equals(jobId)) {             return jobMasterLeaderRetrievalService.         } else {             throw new FlinkRuntimeException(String.format("Unknown job id %s", jobId)).         }     }).setResourceManagerLeaderElectionService(resourceManagerLeaderElectionService).build().     testingFatalErrorHandler = new TestingFatalErrorHandler().     resourceManager = createAndStartResourceManager().     // wait until the leader election has been completed     resourceManagerLeaderElectionService.isLeader(UUID.randomUUID()).get().     resourceManagerGateway = resourceManager.getSelfGateway(ResourceManagerGateway.class). }
false;private;0;4;;private void createAndRegisterJobMasterGateway() {     jobMasterGateway = new TestingJobMasterGatewayBuilder().build().     rpcService.registerGateway(jobMasterGateway.getAddress(), jobMasterGateway). }
false;private;0;33;;private ResourceManager<?> createAndStartResourceManager() throws Exception {     ResourceID rmResourceId = ResourceID.generate().     HeartbeatServices heartbeatServices = new HeartbeatServices(1000L, 1000L).     JobLeaderIdService jobLeaderIdService = new JobLeaderIdService(haServices, rpcService.getScheduledExecutor(), Time.minutes(5L)).     final SlotManager slotManager = new SlotManager(rpcService.getScheduledExecutor(), TestingUtils.infiniteTime(), TestingUtils.infiniteTime(), TestingUtils.infiniteTime()).     ResourceManager<?> resourceManager = new StandaloneResourceManager(rpcService, ResourceManager.RESOURCE_MANAGER_NAME, rmResourceId, haServices, heartbeatServices, slotManager, NoOpMetricRegistry.INSTANCE, jobLeaderIdService, new ClusterInformation("localhost", 1234), testingFatalErrorHandler, UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup()).     resourceManager.start().     return resourceManager. }
false;public;0;18;;@After public void teardown() throws Exception {     if (resourceManager != null) {         RpcUtils.terminateRpcEndpoint(resourceManager, TIMEOUT).     }     if (haServices != null) {         haServices.closeAndCleanupAllData().     }     if (rpcService != null) {         RpcUtils.terminateRpcService(rpcService, TIMEOUT).     }     if (testingFatalErrorHandler != null && testingFatalErrorHandler.hasExceptionOccurred()) {         testingFatalErrorHandler.rethrowError().     } }
true;public;0;12;/**  * Test receive normal registration from job master and receive duplicate  * registration from job master.  */ ;/**  * Test receive normal registration from job master and receive duplicate  * registration from job master.  */ @Test public void testRegisterJobMaster() throws Exception {     // test response successful     CompletableFuture<RegistrationResponse> successfulFuture = resourceManagerGateway.registerJobManager(jobMasterGateway.getFencingToken(), jobMasterResourceId, jobMasterGateway.getAddress(), jobId, TIMEOUT).     RegistrationResponse response = successfulFuture.get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).     assertTrue(response instanceof JobMasterRegistrationSuccess). }
true;public;0;20;/**  * Test receive registration with unmatched leadershipId from job master.  */ ;/**  * Test receive registration with unmatched leadershipId from job master.  */ @Test public void testRegisterJobMasterWithUnmatchedLeaderSessionId1() throws Exception {     final ResourceManagerGateway wronglyFencedGateway = rpcService.connect(resourceManager.getAddress(), ResourceManagerId.generate(), ResourceManagerGateway.class).get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).     // test throw exception when receive a registration from job master which takes unmatched leaderSessionId     CompletableFuture<RegistrationResponse> unMatchedLeaderFuture = wronglyFencedGateway.registerJobManager(jobMasterGateway.getFencingToken(), jobMasterResourceId, jobMasterGateway.getAddress(), jobId, TIMEOUT).     try {         unMatchedLeaderFuture.get(5L, TimeUnit.SECONDS).         fail("Should fail because we are using the wrong fencing token.").     } catch (ExecutionException e) {         assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException).     } }
true;public;0;12;/**  * Test receive registration with unmatched leadershipId from job master.  */ ;/**  * Test receive registration with unmatched leadershipId from job master.  */ @Test public void testRegisterJobMasterWithUnmatchedLeaderSessionId2() throws Exception {     // test throw exception when receive a registration from job master which takes unmatched leaderSessionId     JobMasterId differentJobMasterId = JobMasterId.generate().     CompletableFuture<RegistrationResponse> unMatchedLeaderFuture = resourceManagerGateway.registerJobManager(differentJobMasterId, jobMasterResourceId, jobMasterGateway.getAddress(), jobId, TIMEOUT).     assertTrue(unMatchedLeaderFuture.get() instanceof RegistrationResponse.Decline). }
true;public;0;12;/**  * Test receive registration with invalid address from job master.  */ ;/**  * Test receive registration with invalid address from job master.  */ @Test public void testRegisterJobMasterFromInvalidAddress() throws Exception {     // test throw exception when receive a registration from job master which takes invalid address     String invalidAddress = "/jobMasterAddress2".     CompletableFuture<RegistrationResponse> invalidAddressFuture = resourceManagerGateway.registerJobManager(new JobMasterId(HighAvailabilityServices.DEFAULT_LEADER_ID), jobMasterResourceId, invalidAddress, jobId, TIMEOUT).     assertTrue(invalidAddressFuture.get(5, TimeUnit.SECONDS) instanceof RegistrationResponse.Decline). }
true;public;0;22;/**  * Check and verify return RegistrationResponse. Decline when failed to start a  * job master Leader retrieval listener.  */ ;/**  * Check and verify return RegistrationResponse. Decline when failed to start a  * job master Leader retrieval listener.  */ @Test public void testRegisterJobMasterWithFailureLeaderListener() throws Exception {     JobID unknownJobIDToHAServices = new JobID().     // this should fail because we try to register a job leader listener for an unknown job id     CompletableFuture<RegistrationResponse> registrationFuture = resourceManagerGateway.registerJobManager(jobMasterGateway.getFencingToken(), jobMasterResourceId, jobMasterGateway.getAddress(), unknownJobIDToHAServices, TIMEOUT).     try {         registrationFuture.get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).         fail("Expected to fail with a ResourceManagerException.").     } catch (ExecutionException e) {         assertTrue(ExceptionUtils.stripExecutionException(e) instanceof ResourceManagerException).     }     // ignore the reported error     testingFatalErrorHandler.clearError(). }
