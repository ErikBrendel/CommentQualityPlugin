commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Verify low and high watermarks being set correctly for larger memory segment sizes which  * trigger <a href="https://issues.apache.org/jira/browse/FLINK-7258">FLINK-7258</a>.  */ ;/**  * Verify low and high watermarks being set correctly for larger memory segment sizes which  * trigger <a href="https://issues.apache.org/jira/browse/FLINK-7258">FLINK-7258</a>.  */ @Test public void testLargeLowAndHighWatermarks() throws Throwable {     testLowAndHighWatermarks(65536). }
true;public;0;4;/**  * Verify low and high watermarks being set correctly for smaller memory segment sizes than  * Netty's defaults.  */ ;/**  * Verify low and high watermarks being set correctly for smaller memory segment sizes than  * Netty's defaults.  */ @Test public void testSmallLowAndHighWatermarks() throws Throwable {     testLowAndHighWatermarks(1024). }
false;public;0;6;;@Override public ChannelHandler[] getServerChannelHandlers() {     // The channel handler implements the test     return new ChannelHandler[] { new TestLowAndHighWatermarkHandler(pageSize, expectedLowWatermark, expectedHighWatermark, error) }. }
false;public;0;4;;@Override public ChannelHandler[] getClientChannelHandlers() {     return new ChannelHandler[0]. }
true;private;1;40;/**  * Verifies that the high and low watermark are set in relation to the page size.  *  * <p>The high and low water marks control the data flow to the wire. If the Netty write buffer  * has size greater or equal to the high water mark, the channel state becomes not-writable.  * Only when the size falls below the low water mark again, the state changes to writable again.  *  * <p>The Channel writability state needs to be checked by the handler when writing to the  * channel and is not enforced in the sense that you cannot write a channel, which is in  * not-writable state.  *  * @param pageSize memory segment size to test with (influences high and low watermarks)  */ ;/**  * Verifies that the high and low watermark are set in relation to the page size.  *  * <p>The high and low water marks control the data flow to the wire. If the Netty write buffer  * has size greater or equal to the high water mark, the channel state becomes not-writable.  * Only when the size falls below the low water mark again, the state changes to writable again.  *  * <p>The Channel writability state needs to be checked by the handler when writing to the  * channel and is not enforced in the sense that you cannot write a channel, which is in  * not-writable state.  *  * @param pageSize memory segment size to test with (influences high and low watermarks)  */ private void testLowAndHighWatermarks(int pageSize) throws Throwable {     final int expectedLowWatermark = pageSize + 1.     final int expectedHighWatermark = 2 * pageSize.     final AtomicReference<Throwable> error = new AtomicReference<Throwable>().     final NettyProtocol protocol = new NettyProtocol(null, null, true) {          @Override         public ChannelHandler[] getServerChannelHandlers() {             // The channel handler implements the test             return new ChannelHandler[] { new TestLowAndHighWatermarkHandler(pageSize, expectedLowWatermark, expectedHighWatermark, error) }.         }          @Override         public ChannelHandler[] getClientChannelHandlers() {             return new ChannelHandler[0].         }     }.     final NettyConfig conf = createConfig(pageSize).     final NettyServerAndClient serverAndClient = initServerAndClient(protocol, conf).     try {         // We can't just check the config of this channel as it is the client's channel. We need         // to check the server channel, because it is doing the data transfers.         final Channel ch = connect(serverAndClient).         // Wait for the channel to be closed         awaitClose(ch).         final Throwable t = error.get().         if (t != null) {             throw t.         }     } finally {         shutdown(serverAndClient).     } }
false;public;1;22;;@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {     final Channel ch = ctx.channel().     assertEquals("Low watermark", expectedLowWatermark, ch.config().getWriteBufferLowWaterMark()).     assertEquals("High watermark", expectedHighWatermark, ch.config().getWriteBufferHighWaterMark()).     // Start with a writable channel     assertTrue(ch.isWritable()).     // First buffer should not change writability     ch.write(buffer()).     assertTrue(ch.isWritable()).     // ...second buffer should though     ch.write(buffer()).     assertFalse(ch.isWritable()).     // Flush everything and close the channel after the writability changed event is fired.     hasFlushed = true.     ch.flush(). }
false;public;1;12;;@Override public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {     if (hasFlushed) {         // After flushing the writability should change back to writable         assertTrue(ctx.channel().isWritable()).         // Close the channel. This will terminate the main test Thread.         ctx.close().     }     super.channelWritabilityChanged(ctx). }
false;public;2;10;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {     if (error.get() == null) {         error.set(cause).     }     ctx.close().     super.exceptionCaught(ctx, cause). }
false;private;0;3;;private ByteBuf buffer() {     return NettyServerLowAndHighWatermarkTest.buffer(pageSize). }
true;private,static;1;5;/**  * Creates a new buffer of the given size.  */ ;// --------------------------------------------------------------------------------------------- /**  * Creates a new buffer of the given size.  */ private static ByteBuf buffer(int size) {     // although the buffer is "empty".     return Unpooled.buffer(size).writerIndex(size). }
