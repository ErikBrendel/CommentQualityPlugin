commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;@Test public void testSerialIncrementAndDecrement() {     AtomicDisposableReferenceCounter counter = new AtomicDisposableReferenceCounter().     assertTrue(counter.increment()).     assertTrue(counter.decrement()).     assertFalse(counter.increment()).     assertFalse(counter.decrement()). }
false;public;0;12;;@Test public void testSerialIncrementAndDecrementWithCustomDisposeCount() {     AtomicDisposableReferenceCounter counter = new AtomicDisposableReferenceCounter(-2).     assertTrue(counter.increment()).     assertFalse(counter.decrement()).     assertFalse(counter.decrement()).     assertTrue(counter.decrement()). }
false;public;0;33;;@Test public void testConcurrentIncrementAndDecrement() throws InterruptedException, ExecutionException, TimeoutException {     final Random random = new Random().     final ExecutorService executor = Executors.newFixedThreadPool(2).     try {         final MockIncrementer incrementer = new MockIncrementer().         final MockDecrementer decrementer = new MockDecrementer().         // Repeat this to provoke races         for (int i = 0. i < 256. i++) {             final AtomicDisposableReferenceCounter counter = new AtomicDisposableReferenceCounter().             incrementer.setCounter(counter).             decrementer.setCounter(counter).             counter.increment().             // Randomly decide which one should be first as the first task usually will win the race             boolean incrementFirst = random.nextBoolean().             Future<Boolean> success1 = executor.submit(incrementFirst ? incrementer : decrementer).             Future<Boolean> success2 = executor.submit(incrementFirst ? decrementer : incrementer).             // Only one of the two should win the race and return true             assertTrue(success1.get() ^ success2.get()).         }     } finally {         executor.shutdownNow().     } }
false;;1;3;;void setCounter(AtomicDisposableReferenceCounter counter) {     this.counter = counter. }
false;public;0;4;;@Override public Boolean call() throws Exception {     return counter.increment(). }
false;;1;3;;void setCounter(AtomicDisposableReferenceCounter counter) {     this.counter = counter. }
false;public;0;4;;@Override public Boolean call() throws Exception {     return counter.decrement(). }
