commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;13;;@BeforeClass public static void setupClass() throws Exception {     highAvailabilityServices = new TestingEmbeddedHaServices(TestingUtils.defaultExecutor()).     miniCluster = new TestingMiniCluster(new TestingMiniClusterConfiguration.Builder().setNumTaskManagers(NUM_TMS).setNumSlotsPerTaskManager(SLOTS_PER_TM).build(), () -> highAvailabilityServices).     miniCluster.start(). }
false;public;0;5;;@Before public void setup() throws Exception {     jobGraph = createJobGraph(PARALLELISM).     jobId = jobGraph.getJobID(). }
false;public,static;0;6;;@AfterClass public static void teardownClass() throws Exception {     if (miniCluster != null) {         miniCluster.close().     } }
false;public;0;31;;@Test public void testReelectionOfDispatcher() throws Exception {     final CompletableFuture<JobSubmissionResult> submissionFuture = miniCluster.submitJob(jobGraph).     submissionFuture.get().     CompletableFuture<JobResult> jobResultFuture = miniCluster.requestJobResult(jobId).     highAvailabilityServices.revokeDispatcherLeadership().get().     try {         jobResultFuture.get().         fail("Expected JobNotFinishedException").     } catch (ExecutionException ee) {         assertThat(ExceptionUtils.findThrowable(ee, JobNotFinishedException.class).isPresent(), is(true)).     }     highAvailabilityServices.grantDispatcherLeadership().     BlockingOperator.isBlocking = false.     final CompletableFuture<JobSubmissionResult> submissionFuture2 = miniCluster.submitJob(jobGraph).     submissionFuture2.get().     final CompletableFuture<JobResult> jobResultFuture2 = miniCluster.requestJobResult(jobId).     JobResult jobResult = jobResultFuture2.get().     assertThat(jobResult.isSuccess(), is(true)). }
false;public;0;19;;@Test public void testReelectionOfJobMaster() throws Exception {     final CompletableFuture<JobSubmissionResult> submissionFuture = miniCluster.submitJob(jobGraph).     submissionFuture.get().     CompletableFuture<JobResult> jobResultFuture = miniCluster.requestJobResult(jobId).     highAvailabilityServices.revokeJobMasterLeadership(jobId).get().     assertThat(jobResultFuture.isDone(), is(false)).     BlockingOperator.isBlocking = false.     highAvailabilityServices.grantJobMasterLeadership(jobId).     JobResult jobResult = jobResultFuture.get().     assertThat(jobResult.isSuccess(), is(true)). }
false;public;0;12;;@Test public void testTaskExecutorsReconnectToClusterWithLeadershipChange() throws Exception {     final Deadline deadline = Deadline.fromNow(TESTING_TIMEOUT).     waitUntilTaskExecutorsHaveConnected(NUM_TMS, deadline).     highAvailabilityServices.revokeResourceManagerLeadership().get().     highAvailabilityServices.grantResourceManagerLeadership().     // wait for the ResourceManager to confirm the leadership     assertThat(LeaderRetrievalUtils.retrieveLeaderConnectionInfo(highAvailabilityServices.getResourceManagerLeaderRetriever(), Time.minutes(TESTING_TIMEOUT.toMinutes())).getLeaderSessionID(), is(notNullValue())).     waitUntilTaskExecutorsHaveConnected(NUM_TMS, deadline). }
false;private;2;6;;private void waitUntilTaskExecutorsHaveConnected(int numTaskExecutors, Deadline deadline) throws Exception {     CommonTestUtils.waitUntilCondition(() -> miniCluster.requestClusterOverview().get().getNumTaskManagersConnected() == numTaskExecutors, deadline, 10L). }
false;private;1;8;;private JobGraph createJobGraph(int parallelism) {     BlockingOperator.isBlocking = true.     final JobVertex vertex = new JobVertex("blocking operator").     vertex.setParallelism(parallelism).     vertex.setInvokableClass(BlockingOperator.class).     return new JobGraph("Blocking test job", vertex). }
false;public;0;10;;@Override public void invoke() throws Exception {     if (isBlocking) {         synchronized (this) {             while (true) {                 wait().             }         }     } }
