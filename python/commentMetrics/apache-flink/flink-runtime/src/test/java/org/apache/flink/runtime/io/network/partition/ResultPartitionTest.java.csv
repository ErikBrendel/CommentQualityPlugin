commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@AfterClass public static void shutdown() {     ioManager.shutdown(). }
true;public;0;38;/**  * Tests the schedule or update consumers message sending behaviour depending on the relevant flags.  */ ;/**  * Tests the schedule or update consumers message sending behaviour depending on the relevant flags.  */ @Test public void testSendScheduleOrUpdateConsumersMessage() throws Exception {     {         // Pipelined, send message => notify         ResultPartitionConsumableNotifier notifier = mock(ResultPartitionConsumableNotifier.class).         ResultPartition partition = createPartition(notifier, ResultPartitionType.PIPELINED, true).         partition.addBufferConsumer(createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE), 0).         verify(notifier, times(1)).notifyPartitionConsumable(eq(partition.getJobId()), eq(partition.getPartitionId()), any(TaskActions.class)).     }     {         // Pipelined, don't send message => don't notify         ResultPartitionConsumableNotifier notifier = mock(ResultPartitionConsumableNotifier.class).         ResultPartition partition = createPartition(notifier, ResultPartitionType.PIPELINED, false).         partition.addBufferConsumer(createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE), 0).         verify(notifier, never()).notifyPartitionConsumable(any(JobID.class), any(ResultPartitionID.class), any(TaskActions.class)).     }     {         // Blocking, send message => don't notify         ResultPartitionConsumableNotifier notifier = mock(ResultPartitionConsumableNotifier.class).         ResultPartition partition = createPartition(notifier, ResultPartitionType.BLOCKING, true).         partition.addBufferConsumer(createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE), 0).         verify(notifier, never()).notifyPartitionConsumable(any(JobID.class), any(ResultPartitionID.class), any(TaskActions.class)).     }     {         // Blocking, don't send message => don't notify         ResultPartitionConsumableNotifier notifier = mock(ResultPartitionConsumableNotifier.class).         ResultPartition partition = createPartition(notifier, ResultPartitionType.BLOCKING, false).         partition.addBufferConsumer(createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE), 0).         verify(notifier, never()).notifyPartitionConsumable(any(JobID.class), any(ResultPartitionID.class), any(TaskActions.class)).     } }
false;public;0;4;;@Test public void testAddOnFinishedPipelinedPartition() throws Exception {     testAddOnFinishedPartition(ResultPartitionType.PIPELINED). }
false;public;0;4;;@Test public void testAddOnFinishedBlockingPartition() throws Exception {     testAddOnFinishedPartition(ResultPartitionType.BLOCKING). }
true;protected;1;22;/**  * Tests {@link ResultPartition#addBufferConsumer} on a partition which has already finished.  *  * @param pipelined the result partition type to set up  */ ;/**  * Tests {@link ResultPartition#addBufferConsumer} on a partition which has already finished.  *  * @param pipelined the result partition type to set up  */ protected void testAddOnFinishedPartition(final ResultPartitionType pipelined) throws Exception {     BufferConsumer bufferConsumer = createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE).     ResultPartitionConsumableNotifier notifier = mock(ResultPartitionConsumableNotifier.class).     try {         ResultPartition partition = createPartition(notifier, pipelined, true).         partition.finish().         reset(notifier).         // partition.add() should fail         partition.addBufferConsumer(bufferConsumer, 0).         Assert.fail("exception expected").     } catch (IllegalStateException e) {     // expected => ignored     } finally {         if (!bufferConsumer.isRecycled()) {             bufferConsumer.close().             Assert.fail("bufferConsumer not recycled").         }         // should not have notified either         verify(notifier, never()).notifyPartitionConsumable(any(JobID.class), any(ResultPartitionID.class), any(TaskActions.class)).     } }
false;public;0;4;;@Test public void testAddOnReleasedPipelinedPartition() throws Exception {     testAddOnReleasedPartition(ResultPartitionType.PIPELINED). }
false;public;0;4;;@Test public void testAddOnReleasedBlockingPartition() throws Exception {     testAddOnReleasedPartition(ResultPartitionType.BLOCKING). }
true;protected;1;18;/**  * Tests {@link ResultPartition#addBufferConsumer} on a partition which has already been released.  *  * @param pipelined the result partition type to set up  */ ;/**  * Tests {@link ResultPartition#addBufferConsumer} on a partition which has already been released.  *  * @param pipelined the result partition type to set up  */ protected void testAddOnReleasedPartition(final ResultPartitionType pipelined) throws Exception {     BufferConsumer bufferConsumer = createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE).     ResultPartitionConsumableNotifier notifier = mock(ResultPartitionConsumableNotifier.class).     try {         ResultPartition partition = createPartition(notifier, pipelined, true).         partition.release().         // partition.add() silently drops the bufferConsumer but recycles it         partition.addBufferConsumer(bufferConsumer, 0).     } finally {         if (!bufferConsumer.isRecycled()) {             bufferConsumer.close().             Assert.fail("bufferConsumer not recycled").         }         // should not have notified either         verify(notifier, never()).notifyPartitionConsumable(any(JobID.class), any(ResultPartitionID.class), any(TaskActions.class)).     } }
false;public;0;4;;@Test public void testAddOnPipelinedPartition() throws Exception {     testAddOnPartition(ResultPartitionType.PIPELINED). }
false;public;0;4;;@Test public void testAddOnBlockingPartition() throws Exception {     testAddOnPartition(ResultPartitionType.BLOCKING). }
true;protected;1;23;/**  * Tests {@link ResultPartition#addBufferConsumer(BufferConsumer, int)} on a working partition.  *  * @param pipelined the result partition type to set up  */ ;/**  * Tests {@link ResultPartition#addBufferConsumer(BufferConsumer, int)} on a working partition.  *  * @param pipelined the result partition type to set up  */ protected void testAddOnPartition(final ResultPartitionType pipelined) throws Exception {     ResultPartitionConsumableNotifier notifier = mock(ResultPartitionConsumableNotifier.class).     ResultPartition partition = createPartition(notifier, pipelined, true).     BufferConsumer bufferConsumer = createFilledBufferConsumer(BufferBuilderTestUtils.BUFFER_SIZE).     try {         // partition.add() adds the bufferConsumer without recycling it (if not spilling)         partition.addBufferConsumer(bufferConsumer, 0).         assertFalse("bufferConsumer should not be recycled (still in the queue)", bufferConsumer.isRecycled()).     } finally {         if (!bufferConsumer.isRecycled()) {             bufferConsumer.close().         }         // should have been notified for pipelined partitions         if (pipelined.isPipelined()) {             verify(notifier, times(1)).notifyPartitionConsumable(eq(partition.getJobId()), eq(partition.getPartitionId()), any(TaskActions.class)).         }     } }
false;public;0;4;;@Test public void testReleaseMemoryOnBlockingPartition() throws Exception {     testReleaseMemory(ResultPartitionType.BLOCKING). }
false;public;0;4;;@Test public void testReleaseMemoryOnPipelinedPartition() throws Exception {     testReleaseMemory(ResultPartitionType.PIPELINED). }
true;private;1;32;/**  * Tests {@link ResultPartition#releaseMemory(int)} on a working partition.  *  * @param resultPartitionType the result partition type to set up  */ ;/**  * Tests {@link ResultPartition#releaseMemory(int)} on a working partition.  *  * @param resultPartitionType the result partition type to set up  */ private void testReleaseMemory(final ResultPartitionType resultPartitionType) throws Exception {     final int numAllBuffers = 10.     final NetworkEnvironment network = new NetworkEnvironment(numAllBuffers, 128, 0, 0, 2, 8, true).     final ResultPartitionConsumableNotifier notifier = new NoOpResultPartitionConsumableNotifier().     final ResultPartition resultPartition = createPartition(notifier, resultPartitionType, false).     try {         network.setupPartition(resultPartition).         // take all buffers (more than the minimum required)         for (int i = 0. i < numAllBuffers. ++i) {             BufferBuilder bufferBuilder = resultPartition.getBufferPool().requestBufferBuilderBlocking().             resultPartition.addBufferConsumer(bufferBuilder.createBufferConsumer(), 0).         }         resultPartition.finish().         assertEquals(0, resultPartition.getBufferPool().getNumberOfAvailableMemorySegments()).         // reset the pool size less than the number of requested buffers         final int numLocalBuffers = 4.         resultPartition.getBufferPool().setNumBuffers(numLocalBuffers).         // partition with blocking type should release excess buffers         if (!resultPartitionType.hasBackPressure()) {             assertEquals(numLocalBuffers, resultPartition.getBufferPool().getNumberOfAvailableMemorySegments()).         } else {             assertEquals(0, resultPartition.getBufferPool().getNumberOfAvailableMemorySegments()).         }     } finally {         resultPartition.release().         network.shutdown().     } }
false;private,static;3;17;;// ------------------------------------------------------------------------ private static ResultPartition createPartition(ResultPartitionConsumableNotifier notifier, ResultPartitionType type, boolean sendScheduleOrUpdateConsumersMessage) {     return new ResultPartition("TestTask", mock(TaskActions.class), new JobID(), new ResultPartitionID(), type, 1, 1, mock(ResultPartitionManager.class), notifier, ioManager, sendScheduleOrUpdateConsumersMessage). }
