# id;timestamp;commentText;codeText;commentWords;codeWords
BlobCacheCorruptionTest -> private static void testGetFailsFromCorruptFile( 			@Nullable JobID jobId, BlobKey.BlobType blobType, boolean corruptOnHAStore, 			Configuration config, BlobStore blobStore, ExpectedException expectedException) 			throws IOException;1507212387;Checks the GET operation fails when the downloaded file (from {@link BlobServer} or HA store)_is corrupt, i.e. its content's hash does not match the {@link BlobKey}'s hash.__@param jobId_job ID or <tt>null</tt> if job-unrelated_@param blobType_whether the BLOB should become permanent or transient_@param corruptOnHAStore_whether the file should be corrupt in the HA store (<tt>true</tt>, required_<tt>highAvailability</tt> to be set) or on the {@link BlobServer}'s local store_(<tt>false</tt>)_@param config_blob server configuration (including HA settings like {@link HighAvailabilityOptions#HA_STORAGE_PATH}_and {@link HighAvailabilityOptions#HA_CLUSTER_ID}) used to set up <tt>blobStore</tt>_@param blobStore_shared HA blob store to use_@param expectedException_expected exception rule to use;private static void testGetFailsFromCorruptFile(_			@Nullable JobID jobId, BlobKey.BlobType blobType, boolean corruptOnHAStore,_			Configuration config, BlobStore blobStore, ExpectedException expectedException)_			throws IOException {__		assertTrue("corrupt HA file requires a HA setup",_			!corruptOnHAStore || blobType == PERMANENT_BLOB)___		Random rnd = new Random()___		try (_			BlobServer server = new BlobServer(config, blobStore)__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, corruptOnHAStore ? blobStore : new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			BlobKey key = put(server, jobId, data, blobType)__			assertNotNull(key)___			_			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1__			if (corruptOnHAStore) {_				File tmpFile = Files.createTempFile("blob", ".jar").toFile()__				try {_					FileUtils.writeByteArrayToFile(tmpFile, data2)__					blobStore.put(tmpFile, jobId, key)__				} finally {_					_					tmpFile.delete()__				}__				_				_				File blobFile = server.getStorageLocation(jobId, key)__				assertTrue(blobFile.delete())__			} else {_				File blobFile = server.getStorageLocation(jobId, key)__				assertTrue(blobFile.exists())__				FileUtils.writeByteArrayToFile(blobFile, data2)__			}__			_			expectedException.expect(IOException.class)__			expectedException.expectCause(CoreMatchers.allOf(instanceOf(IOException.class),_				hasProperty("message", containsString("data corruption"))))___			get(cache, jobId, key)__		}_	};checks,the,get,operation,fails,when,the,downloaded,file,from,link,blob,server,or,ha,store,is,corrupt,i,e,its,content,s,hash,does,not,match,the,link,blob,key,s,hash,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,blob,type,whether,the,blob,should,become,permanent,or,transient,param,corrupt,on,hastore,whether,the,file,should,be,corrupt,in,the,ha,store,tt,true,tt,required,tt,high,availability,tt,to,be,set,or,on,the,link,blob,server,s,local,store,tt,false,tt,param,config,blob,server,configuration,including,ha,settings,like,link,high,availability,options,and,link,high,availability,options,used,to,set,up,tt,blob,store,tt,param,blob,store,shared,ha,blob,store,to,use,param,expected,exception,expected,exception,rule,to,use;private,static,void,test,get,fails,from,corrupt,file,nullable,job,id,job,id,blob,key,blob,type,blob,type,boolean,corrupt,on,hastore,configuration,config,blob,store,blob,store,expected,exception,expected,exception,throws,ioexception,assert,true,corrupt,ha,file,requires,a,ha,setup,corrupt,on,hastore,blob,type,random,rnd,new,random,try,blob,server,server,new,blob,server,config,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,corrupt,on,hastore,blob,store,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,key,put,server,job,id,data,blob,type,assert,not,null,key,byte,data2,arrays,copy,of,data,data,length,data2,0,1,if,corrupt,on,hastore,file,tmp,file,files,create,temp,file,blob,jar,to,file,try,file,utils,write,byte,array,to,file,tmp,file,data2,blob,store,put,tmp,file,job,id,key,finally,tmp,file,delete,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,else,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,exists,file,utils,write,byte,array,to,file,blob,file,data2,expected,exception,expect,ioexception,class,expected,exception,expect,cause,core,matchers,all,of,instance,of,ioexception,class,has,property,message,contains,string,data,corruption,get,cache,job,id,key
BlobCacheCorruptionTest -> private static void testGetFailsFromCorruptFile( 			@Nullable JobID jobId, BlobKey.BlobType blobType, boolean corruptOnHAStore, 			Configuration config, BlobStore blobStore, ExpectedException expectedException) 			throws IOException;1517915730;Checks the GET operation fails when the downloaded file (from {@link BlobServer} or HA store)_is corrupt, i.e. its content's hash does not match the {@link BlobKey}'s hash.__@param jobId_job ID or <tt>null</tt> if job-unrelated_@param blobType_whether the BLOB should become permanent or transient_@param corruptOnHAStore_whether the file should be corrupt in the HA store (<tt>true</tt>, required_<tt>highAvailability</tt> to be set) or on the {@link BlobServer}'s local store_(<tt>false</tt>)_@param config_blob server configuration (including HA settings like {@link HighAvailabilityOptions#HA_STORAGE_PATH}_and {@link HighAvailabilityOptions#HA_CLUSTER_ID}) used to set up <tt>blobStore</tt>_@param blobStore_shared HA blob store to use_@param expectedException_expected exception rule to use;private static void testGetFailsFromCorruptFile(_			@Nullable JobID jobId, BlobKey.BlobType blobType, boolean corruptOnHAStore,_			Configuration config, BlobStore blobStore, ExpectedException expectedException)_			throws IOException {__		assertTrue("corrupt HA file requires a HA setup",_			!corruptOnHAStore || blobType == PERMANENT_BLOB)___		Random rnd = new Random()___		try (_			BlobServer server = new BlobServer(config, blobStore)__			BlobCacheService cache = new BlobCacheService(config, corruptOnHAStore ? blobStore : new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			BlobKey key = put(server, jobId, data, blobType)__			assertNotNull(key)___			_			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1__			if (corruptOnHAStore) {_				File tmpFile = Files.createTempFile("blob", ".jar").toFile()__				try {_					FileUtils.writeByteArrayToFile(tmpFile, data2)__					blobStore.put(tmpFile, jobId, key)__				} finally {_					_					tmpFile.delete()__				}__				_				_				File blobFile = server.getStorageLocation(jobId, key)__				assertTrue(blobFile.delete())__			} else {_				File blobFile = server.getStorageLocation(jobId, key)__				assertTrue(blobFile.exists())__				FileUtils.writeByteArrayToFile(blobFile, data2)__			}__			_			expectedException.expect(IOException.class)__			expectedException.expectCause(CoreMatchers.allOf(instanceOf(IOException.class),_				hasProperty("message", containsString("data corruption"))))___			get(cache, jobId, key)__		}_	};checks,the,get,operation,fails,when,the,downloaded,file,from,link,blob,server,or,ha,store,is,corrupt,i,e,its,content,s,hash,does,not,match,the,link,blob,key,s,hash,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,blob,type,whether,the,blob,should,become,permanent,or,transient,param,corrupt,on,hastore,whether,the,file,should,be,corrupt,in,the,ha,store,tt,true,tt,required,tt,high,availability,tt,to,be,set,or,on,the,link,blob,server,s,local,store,tt,false,tt,param,config,blob,server,configuration,including,ha,settings,like,link,high,availability,options,and,link,high,availability,options,used,to,set,up,tt,blob,store,tt,param,blob,store,shared,ha,blob,store,to,use,param,expected,exception,expected,exception,rule,to,use;private,static,void,test,get,fails,from,corrupt,file,nullable,job,id,job,id,blob,key,blob,type,blob,type,boolean,corrupt,on,hastore,configuration,config,blob,store,blob,store,expected,exception,expected,exception,throws,ioexception,assert,true,corrupt,ha,file,requires,a,ha,setup,corrupt,on,hastore,blob,type,random,rnd,new,random,try,blob,server,server,new,blob,server,config,blob,store,blob,cache,service,cache,new,blob,cache,service,config,corrupt,on,hastore,blob,store,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,key,put,server,job,id,data,blob,type,assert,not,null,key,byte,data2,arrays,copy,of,data,data,length,data2,0,1,if,corrupt,on,hastore,file,tmp,file,files,create,temp,file,blob,jar,to,file,try,file,utils,write,byte,array,to,file,tmp,file,data2,blob,store,put,tmp,file,job,id,key,finally,tmp,file,delete,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,else,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,exists,file,utils,write,byte,array,to,file,blob,file,data2,expected,exception,expect,ioexception,class,expected,exception,expect,cause,core,matchers,all,of,instance,of,ioexception,class,has,property,message,contains,string,data,corruption,get,cache,job,id,key
BlobCacheCorruptionTest -> private void testGetFailsFromCorruptFile(final JobID jobId, BlobKey.BlobType blobType, 			boolean corruptOnHAStore) throws IOException;1507212387;Checks the GET operation fails when the downloaded file (from {@link BlobServer} or HA store)_is corrupt, i.e. its content's hash does not match the {@link BlobKey}'s hash.__@param jobId_job ID or <tt>null</tt> if job-unrelated_@param blobType_whether the BLOB should become permanent or transient_@param corruptOnHAStore_whether the file should be corrupt in the HA store (<tt>true</tt>, required_<tt>highAvailability</tt> to be set) or on the {@link BlobServer}'s local store_(<tt>false</tt>);private void testGetFailsFromCorruptFile(final JobID jobId, BlobKey.BlobType blobType,_			boolean corruptOnHAStore) throws IOException {__		final Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.newFolder().getPath())___		BlobStoreService blobStoreService = null___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			testGetFailsFromCorruptFile(jobId, blobType, corruptOnHAStore, config,_				blobStoreService, exception)__		} finally {_			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};checks,the,get,operation,fails,when,the,downloaded,file,from,link,blob,server,or,ha,store,is,corrupt,i,e,its,content,s,hash,does,not,match,the,link,blob,key,s,hash,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,blob,type,whether,the,blob,should,become,permanent,or,transient,param,corrupt,on,hastore,whether,the,file,should,be,corrupt,in,the,ha,store,tt,true,tt,required,tt,high,availability,tt,to,be,set,or,on,the,link,blob,server,s,local,store,tt,false,tt;private,void,test,get,fails,from,corrupt,file,final,job,id,job,id,blob,key,blob,type,blob,type,boolean,corrupt,on,hastore,throws,ioexception,final,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,path,blob,store,service,blob,store,service,null,try,blob,store,service,blob,utils,create,blob,store,from,config,config,test,get,fails,from,corrupt,file,job,id,blob,type,corrupt,on,hastore,config,blob,store,service,exception,finally,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobCacheCorruptionTest -> private void testGetFailsFromCorruptFile(final JobID jobId, BlobKey.BlobType blobType, 			boolean corruptOnHAStore) throws IOException;1517915730;Checks the GET operation fails when the downloaded file (from {@link BlobServer} or HA store)_is corrupt, i.e. its content's hash does not match the {@link BlobKey}'s hash.__@param jobId_job ID or <tt>null</tt> if job-unrelated_@param blobType_whether the BLOB should become permanent or transient_@param corruptOnHAStore_whether the file should be corrupt in the HA store (<tt>true</tt>, required_<tt>highAvailability</tt> to be set) or on the {@link BlobServer}'s local store_(<tt>false</tt>);private void testGetFailsFromCorruptFile(final JobID jobId, BlobKey.BlobType blobType,_			boolean corruptOnHAStore) throws IOException {__		final Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.newFolder().getPath())___		BlobStoreService blobStoreService = null___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			testGetFailsFromCorruptFile(jobId, blobType, corruptOnHAStore, config,_				blobStoreService, exception)__		} finally {_			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};checks,the,get,operation,fails,when,the,downloaded,file,from,link,blob,server,or,ha,store,is,corrupt,i,e,its,content,s,hash,does,not,match,the,link,blob,key,s,hash,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,blob,type,whether,the,blob,should,become,permanent,or,transient,param,corrupt,on,hastore,whether,the,file,should,be,corrupt,in,the,ha,store,tt,true,tt,required,tt,high,availability,tt,to,be,set,or,on,the,link,blob,server,s,local,store,tt,false,tt;private,void,test,get,fails,from,corrupt,file,final,job,id,job,id,blob,key,blob,type,blob,type,boolean,corrupt,on,hastore,throws,ioexception,final,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,path,blob,store,service,blob,store,service,null,try,blob,store,service,blob,utils,create,blob,store,from,config,config,test,get,fails,from,corrupt,file,job,id,blob,type,corrupt,on,hastore,config,blob,store,service,exception,finally,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobCacheCorruptionTest -> public static void testGetFailsFromCorruptFile( 			JobID jobId, Configuration config, BlobStore blobStore, 			ExpectedException expectedException) throws IOException;1507212387;Checks the GET operation fails when the downloaded file (from HA store)_is corrupt, i.e. its content's hash does not match the {@link BlobKey}'s hash, using a_permanent BLOB.__@param jobId_job ID_@param config_blob server configuration (including HA settings like {@link HighAvailabilityOptions#HA_STORAGE_PATH}_and {@link HighAvailabilityOptions#HA_CLUSTER_ID}) used to set up <tt>blobStore</tt>_@param blobStore_shared HA blob store to use_@param expectedException_expected exception rule to use;public static void testGetFailsFromCorruptFile(_			JobID jobId, Configuration config, BlobStore blobStore,_			ExpectedException expectedException) throws IOException {__		testGetFailsFromCorruptFile(jobId, PERMANENT_BLOB, true, config, blobStore,_			expectedException)__	};checks,the,get,operation,fails,when,the,downloaded,file,from,ha,store,is,corrupt,i,e,its,content,s,hash,does,not,match,the,link,blob,key,s,hash,using,a,permanent,blob,param,job,id,job,id,param,config,blob,server,configuration,including,ha,settings,like,link,high,availability,options,and,link,high,availability,options,used,to,set,up,tt,blob,store,tt,param,blob,store,shared,ha,blob,store,to,use,param,expected,exception,expected,exception,rule,to,use;public,static,void,test,get,fails,from,corrupt,file,job,id,job,id,configuration,config,blob,store,blob,store,expected,exception,expected,exception,throws,ioexception,test,get,fails,from,corrupt,file,job,id,true,config,blob,store,expected,exception
BlobCacheCorruptionTest -> public static void testGetFailsFromCorruptFile( 			JobID jobId, Configuration config, BlobStore blobStore, 			ExpectedException expectedException) throws IOException;1517915730;Checks the GET operation fails when the downloaded file (from HA store)_is corrupt, i.e. its content's hash does not match the {@link BlobKey}'s hash, using a_permanent BLOB.__@param jobId_job ID_@param config_blob server configuration (including HA settings like {@link HighAvailabilityOptions#HA_STORAGE_PATH}_and {@link HighAvailabilityOptions#HA_CLUSTER_ID}) used to set up <tt>blobStore</tt>_@param blobStore_shared HA blob store to use_@param expectedException_expected exception rule to use;public static void testGetFailsFromCorruptFile(_			JobID jobId, Configuration config, BlobStore blobStore,_			ExpectedException expectedException) throws IOException {__		testGetFailsFromCorruptFile(jobId, PERMANENT_BLOB, true, config, blobStore,_			expectedException)__	};checks,the,get,operation,fails,when,the,downloaded,file,from,ha,store,is,corrupt,i,e,its,content,s,hash,does,not,match,the,link,blob,key,s,hash,using,a,permanent,blob,param,job,id,job,id,param,config,blob,server,configuration,including,ha,settings,like,link,high,availability,options,and,link,high,availability,options,used,to,set,up,tt,blob,store,tt,param,blob,store,shared,ha,blob,store,to,use,param,expected,exception,expected,exception,rule,to,use;public,static,void,test,get,fails,from,corrupt,file,job,id,job,id,configuration,config,blob,store,blob,store,expected,exception,expected,exception,throws,ioexception,test,get,fails,from,corrupt,file,job,id,true,config,blob,store,expected,exception
