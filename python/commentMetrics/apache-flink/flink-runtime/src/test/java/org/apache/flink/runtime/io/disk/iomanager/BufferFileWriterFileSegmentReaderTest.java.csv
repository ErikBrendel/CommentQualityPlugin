commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@AfterClass public static void shutdown() {     ioManager.shutdown(). }
false;public;0;20;;@Before public void setUpWriterAndReader() {     final FileIOChannel.ID channel = ioManager.createChannel().     try {         writer = ioManager.createBufferFileWriter(channel).         reader = (AsynchronousBufferFileSegmentReader) ioManager.createBufferFileSegmentReader(channel, new QueuingCallback<>(returnedFileSegments)).     } catch (IOException e) {         if (writer != null) {             writer.deleteChannel().         }         if (reader != null) {             reader.deleteChannel().         }         fail("Failed to setup writer and reader.").     } }
false;public;0;12;;@After public void tearDownWriterAndReader() {     if (writer != null) {         writer.deleteChannel().     }     if (reader != null) {         reader.deleteChannel().     }     returnedFileSegments.clear(). }
false;public;0;4;;@Override public void onNotification() {     sync.countDown(). }
false;public;0;63;;@Test public void testWriteRead() throws IOException, InterruptedException {     int numBuffers = 1024.     int currentNumber = 0.     final int minBufferSize = BUFFER_SIZE / 4.     // Write buffers filled with ascending numbers...     for (int i = 0. i < numBuffers. i++) {         final Buffer buffer = createBuffer().         int size = getNextMultipleOf(getRandomNumberInRange(minBufferSize, BUFFER_SIZE), 4).         currentNumber = fillBufferWithAscendingNumbers(buffer, currentNumber, size).         writer.writeBlock(buffer).     }     // Make sure that the writes are finished     writer.close().     // Read buffers back in...     for (int i = 0. i < numBuffers. i++) {         assertFalse(reader.hasReachedEndOfFile()).         reader.read().     }     // Wait for all requests to be finished     final CountDownLatch sync = new CountDownLatch(1).     final NotificationListener listener = new NotificationListener() {          @Override         public void onNotification() {             sync.countDown().         }     }.     if (reader.registerAllRequestsProcessedListener(listener)) {         sync.await().     }     assertTrue(reader.hasReachedEndOfFile()).     // Verify that the content is the same     assertEquals("Read less buffers than written.", numBuffers, returnedFileSegments.size()).     currentNumber = 0.     FileSegment fileSegment.     ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE).     while ((fileSegment = returnedFileSegments.poll()) != null) {         buffer.position(0).         buffer.limit(fileSegment.getLength()).         fileSegment.getFileChannel().read(buffer, fileSegment.getPosition()).         Buffer buffer1 = new NetworkBuffer(MemorySegmentFactory.wrap(buffer.array()), BUFFER_RECYCLER).         buffer1.setSize(fileSegment.getLength()).         currentNumber = verifyBufferFilledWithAscendingNumbers(buffer1, currentNumber).     }     reader.close(). }
false;private;2;3;;// ------------------------------------------------------------------------ private int getRandomNumberInRange(int min, int max) {     return random.nextInt((max - min) + 1) + min. }
false;private;2;9;;private int getNextMultipleOf(int number, int multiple) {     final int mod = number % multiple.     if (mod == 0) {         return number.     }     return number + multiple - mod. }
false;private;0;3;;private Buffer createBuffer() {     return new NetworkBuffer(MemorySegmentFactory.allocateUnpooledSegment(BUFFER_SIZE), BUFFER_RECYCLER). }
