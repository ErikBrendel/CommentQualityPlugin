commented;modifiers;parameterAmount;loc;comment;code
false;public;0;30;;// ------------------------------------------------------------------------ // tests // ------------------------------------------------------------------------ @Test public void testSlotAllocationNoResourceManager() throws Exception {     final JobID jid = new JobID().     try (SlotPool pool = new SlotPoolImpl(jid, SystemClock.getInstance(), TestingUtils.infiniteTime(), TestingUtils.infiniteTime())) {         pool.start(JobMasterId.generate(), "foobar", testMainThreadExecutor.getMainThreadExecutor()).         Scheduler scheduler = new SchedulerImpl(LocationPreferenceSlotSelectionStrategy.INSTANCE, pool).         scheduler.start(testMainThreadExecutor.getMainThreadExecutor()).         CompletableFuture<LogicalSlot> future = testMainThreadExecutor.execute(() -> scheduler.allocateSlot(new SlotRequestId(), new ScheduledUnit(SchedulerTestUtils.getDummyTask()), SlotProfile.noLocality(DEFAULT_TESTING_PROFILE), true, fastTimeout)).         try {             future.get().             fail("We expected an ExecutionException.").         } catch (ExecutionException e) {             assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException).         }     } }
false;public;0;37;;@Test public void testCancelSlotAllocationWithoutResourceManager() throws Exception {     final JobID jid = new JobID().     try (TestingSlotPool pool = new TestingSlotPool(jid, SystemClock.getInstance(), TestingUtils.infiniteTime(), TestingUtils.infiniteTime())) {         final CompletableFuture<SlotRequestId> timeoutFuture = new CompletableFuture<>().         pool.setTimeoutPendingSlotRequestConsumer(timeoutFuture::complete).         pool.start(JobMasterId.generate(), "foobar", testMainThreadExecutor.getMainThreadExecutor()).         Scheduler scheduler = new SchedulerImpl(LocationPreferenceSlotSelectionStrategy.INSTANCE, pool).         scheduler.start(testMainThreadExecutor.getMainThreadExecutor()).         SlotRequestId requestId = new SlotRequestId().         CompletableFuture<LogicalSlot> future = testMainThreadExecutor.execute(() -> scheduler.allocateSlot(requestId, new ScheduledUnit(SchedulerTestUtils.getDummyTask()), SlotProfile.noLocality(DEFAULT_TESTING_PROFILE), true, fastTimeout)).         try {             future.get().             fail("We expected a TimeoutException.").         } catch (ExecutionException e) {             assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException).         }         // wait for the timeout of the pending slot request         timeoutFuture.get().         assertEquals(0L, pool.getNumberOfWaitingForResourceRequests()).     } }
true;public;0;42;/**  * Tests that a slot allocation times out wrt to the specified time out.  */ ;/**  * Tests that a slot allocation times out wrt to the specified time out.  */ @Test public void testSlotAllocationTimeout() throws Exception {     final JobID jid = new JobID().     try (TestingSlotPool pool = new TestingSlotPool(jid, SystemClock.getInstance(), TestingUtils.infiniteTime(), TestingUtils.infiniteTime())) {         pool.start(JobMasterId.generate(), "foobar", testMainThreadExecutor.getMainThreadExecutor()).         final CompletableFuture<SlotRequestId> slotRequestTimeoutFuture = new CompletableFuture<>().         pool.setTimeoutPendingSlotRequestConsumer(slotRequestTimeoutFuture::complete).         ResourceManagerGateway resourceManagerGateway = new TestingResourceManagerGateway().         pool.connectToResourceManager(resourceManagerGateway).         Scheduler scheduler = new SchedulerImpl(LocationPreferenceSlotSelectionStrategy.INSTANCE, pool).         scheduler.start(testMainThreadExecutor.getMainThreadExecutor()).         SlotRequestId requestId = new SlotRequestId().         CompletableFuture<LogicalSlot> future = testMainThreadExecutor.execute(() -> scheduler.allocateSlot(requestId, new DummyScheduledUnit(), SlotProfile.noLocality(DEFAULT_TESTING_PROFILE), true, fastTimeout)).         try {             future.get().             fail("We expected a TimeoutException.").         } catch (ExecutionException e) {             assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException).         }         // wait until we have timed out the slot request         slotRequestTimeoutFuture.get().         assertEquals(0L, pool.getNumberOfPendingRequests()).     } }
true;public;0;61;/**  * Tests that extra slots are kept by the {@link SlotPoolImpl}.  */ ;/**  * Tests that extra slots are kept by the {@link SlotPoolImpl}.  */ @Test public void testExtraSlotsAreKept() throws Exception {     final JobID jid = new JobID().     try (TestingSlotPool pool = new TestingSlotPool(jid, SystemClock.getInstance(), TestingUtils.infiniteTime(), TestingUtils.infiniteTime())) {         pool.start(JobMasterId.generate(), "foobar", testMainThreadExecutor.getMainThreadExecutor()).         Scheduler scheduler = new SchedulerImpl(LocationPreferenceSlotSelectionStrategy.INSTANCE, pool).         scheduler.start(testMainThreadExecutor.getMainThreadExecutor()).         final CompletableFuture<AllocationID> allocationIdFuture = new CompletableFuture<>().         TestingResourceManagerGateway resourceManagerGateway = new TestingResourceManagerGateway().         resourceManagerGateway.setRequestSlotConsumer((SlotRequest slotRequest) -> allocationIdFuture.complete(slotRequest.getAllocationId())).         final CompletableFuture<SlotRequestId> slotRequestTimeoutFuture = new CompletableFuture<>().         pool.setTimeoutPendingSlotRequestConsumer(slotRequestTimeoutFuture::complete).         pool.connectToResourceManager(resourceManagerGateway).         SlotRequestId requestId = new SlotRequestId().         CompletableFuture<LogicalSlot> future = testMainThreadExecutor.execute(() -> scheduler.allocateSlot(requestId, new ScheduledUnit(SchedulerTestUtils.getDummyTask()), SlotProfile.noLocality(DEFAULT_TESTING_PROFILE), true, fastTimeout)).         try {             future.get().             fail("We expected a TimeoutException.").         } catch (ExecutionException e) {             assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException).         }         // wait until we have timed out the slot request         slotRequestTimeoutFuture.get().         assertEquals(0L, pool.getNumberOfPendingRequests()).         AllocationID allocationId = allocationIdFuture.get().         final SlotOffer slotOffer = new SlotOffer(allocationId, 0, DEFAULT_TESTING_PROFILE).         final TaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation().         final TaskManagerGateway taskManagerGateway = new SimpleAckingTaskManagerGateway().         testMainThreadExecutor.execute(() -> pool.registerTaskManager(taskManagerLocation.getResourceID())).         assertTrue(testMainThreadExecutor.execute(() -> pool.offerSlot(taskManagerLocation, taskManagerGateway, slotOffer))).         assertTrue(pool.containsAvailableSlot(allocationId)).     } }
true;public;0;40;/**  * This case make sure when allocateSlot in ProviderAndOwner timeout,  * it will automatically call cancelSlotAllocation as will inject future.whenComplete in ProviderAndOwner.  */ ;/**  * This case make sure when allocateSlot in ProviderAndOwner timeout,  * it will automatically call cancelSlotAllocation as will inject future.whenComplete in ProviderAndOwner.  */ @Test public void testProviderAndOwnerSlotAllocationTimeout() throws Exception {     final JobID jid = new JobID().     try (TestingSlotPool pool = new TestingSlotPool(jid, SystemClock.getInstance(), TestingUtils.infiniteTime(), TestingUtils.infiniteTime())) {         final CompletableFuture<SlotRequestId> releaseSlotFuture = new CompletableFuture<>().         pool.setReleaseSlotConsumer(releaseSlotFuture::complete).         pool.start(JobMasterId.generate(), "foobar", testMainThreadExecutor.getMainThreadExecutor()).         ResourceManagerGateway resourceManagerGateway = new TestingResourceManagerGateway().         pool.connectToResourceManager(resourceManagerGateway).         Scheduler scheduler = new SchedulerImpl(LocationPreferenceSlotSelectionStrategy.INSTANCE, pool).         scheduler.start(testMainThreadExecutor.getMainThreadExecutor()).         // test the pending request is clear when timed out         CompletableFuture<LogicalSlot> future = testMainThreadExecutor.execute(() -> scheduler.allocateSlot(new DummyScheduledUnit(), true, SlotProfile.noRequirements(), fastTimeout)).         try {             future.get().             fail("We expected a TimeoutException.").         } catch (ExecutionException e) {             assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException).         }         // wait for the cancel call on the SlotPoolImpl         releaseSlotFuture.get().         assertEquals(0L, pool.getNumberOfPendingRequests()).     } }
false;public;1;3;;public void setReleaseSlotConsumer(Consumer<SlotRequestId> releaseSlotConsumer) {     this.releaseSlotConsumer = Preconditions.checkNotNull(releaseSlotConsumer). }
false;public;1;3;;public void setTimeoutPendingSlotRequestConsumer(Consumer<SlotRequestId> timeoutPendingSlotRequestConsumer) {     this.timeoutPendingSlotRequestConsumer = Preconditions.checkNotNull(timeoutPendingSlotRequestConsumer). }
false;public;2;12;;@Override public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwable cause) {     final Consumer<SlotRequestId> currentReleaseSlotConsumer = releaseSlotConsumer.     super.releaseSlot(slotRequestId, cause).     if (currentReleaseSlotConsumer != null) {         currentReleaseSlotConsumer.accept(slotRequestId).     } }
false;protected;1;10;;@Override protected void timeoutPendingSlotRequest(SlotRequestId slotRequestId) {     final Consumer<SlotRequestId> currentTimeoutPendingSlotRequestConsumer = timeoutPendingSlotRequestConsumer.     if (currentTimeoutPendingSlotRequestConsumer != null) {         currentTimeoutPendingSlotRequestConsumer.accept(slotRequestId).     }     super.timeoutPendingSlotRequest(slotRequestId). }
false;;1;3;;boolean containsAllocatedSlot(AllocationID allocationId) {     return getAllocatedSlots().contains(allocationId). }
false;;1;3;;boolean containsAvailableSlot(AllocationID allocationId) {     return getAvailableSlots().contains(allocationId). }
false;;0;3;;int getNumberOfPendingRequests() {     return getPendingRequests().size(). }
false;;0;3;;int getNumberOfWaitingForResourceRequests() {     return getWaitingForResourceManager().size(). }
