commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Before public void setup() throws Exception {     miniCluster = new TestingMiniCluster(new TestingMiniClusterConfiguration.Builder().setNumTaskManagers(NUM_TMS).setNumSlotsPerTaskManager(SLOTS_PER_TM).build(), null).     miniCluster.start(). }
false;public;0;6;;@After public void teardown() throws Exception {     if (miniCluster != null) {         miniCluster.close().     } }
true;public;0;21;/**  * Tests that a job can be re-executed after the job has failed due  * to a TaskExecutor termination.  */ ;/**  * Tests that a job can be re-executed after the job has failed due  * to a TaskExecutor termination.  */ @Test public void testJobReExecutionAfterTaskExecutorTermination() throws Exception {     final JobGraph jobGraph = createJobGraph(PARALLELISM).     final CompletableFuture<JobResult> jobResultFuture = submitJobAndWaitUntilRunning(jobGraph).     // kill one TaskExecutor which should fail the job execution     miniCluster.terminateTaskExecutor(0).     final JobResult jobResult = jobResultFuture.get().     assertThat(jobResult.isSuccess(), is(false)).     miniCluster.startTaskExecutor().     BlockingOperator.unblock().     miniCluster.submitJob(jobGraph).get().     miniCluster.requestJobResult(jobGraph.getJobID()).get(). }
true;public;0;15;/**  * Tests that the job can recover from a failing {@link TaskExecutor}.  */ ;/**  * Tests that the job can recover from a failing {@link TaskExecutor}.  */ @Test public void testJobRecoveryWithFailingTaskExecutor() throws Exception {     final JobGraph jobGraph = createJobGraphWithRestartStrategy(PARALLELISM).     final CompletableFuture<JobResult> jobResultFuture = submitJobAndWaitUntilRunning(jobGraph).     // start an additional TaskExecutor     miniCluster.startTaskExecutor().     // this should fail the job     miniCluster.terminateTaskExecutor(0).get().     BlockingOperator.unblock().     assertThat(jobResultFuture.get().isSuccess(), is(true)). }
false;private;1;14;;private CompletableFuture<JobResult> submitJobAndWaitUntilRunning(JobGraph jobGraph) throws Exception {     miniCluster.submitJob(jobGraph).get().     final CompletableFuture<JobResult> jobResultFuture = miniCluster.requestJobResult(jobGraph.getJobID()).     assertThat(jobResultFuture.isDone(), is(false)).     CommonTestUtils.waitUntilCondition(jobIsRunning(() -> miniCluster.getExecutionGraph(jobGraph.getJobID())), Deadline.fromNow(TESTING_TIMEOUT), 50L).     return jobResultFuture. }
false;private;1;9;;private SupplierWithException<Boolean, Exception> jobIsRunning(Supplier<CompletableFuture<? extends AccessExecutionGraph>> executionGraphFutureSupplier) {     final Predicate<AccessExecution> runningOrFinished = ExecutionGraphTestUtils.isInExecutionState(ExecutionState.RUNNING).or(ExecutionGraphTestUtils.isInExecutionState(ExecutionState.FINISHED)).     final Predicate<AccessExecutionGraph> allExecutionsRunning = ExecutionGraphTestUtils.allExecutionsPredicate(runningOrFinished).     return () -> {         final AccessExecutionGraph executionGraph = executionGraphFutureSupplier.get().join().         return allExecutionsRunning.test(executionGraph).     }. }
false;private;1;8;;private JobGraph createJobGraphWithRestartStrategy(int parallelism) throws IOException {     final JobGraph jobGraph = createJobGraph(parallelism).     final ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0L)).     jobGraph.setExecutionConfig(executionConfig).     return jobGraph. }
false;private;1;18;;private JobGraph createJobGraph(int parallelism) {     final JobVertex sender = new JobVertex("Sender").     sender.setParallelism(parallelism).     sender.setInvokableClass(TestingAbstractInvokables.Sender.class).     final JobVertex receiver = new JobVertex("Blocking receiver").     receiver.setParallelism(parallelism).     receiver.setInvokableClass(BlockingOperator.class).     BlockingOperator.reset().     receiver.connectNewDataSetAsInput(sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).     final SlotSharingGroup slotSharingGroup = new SlotSharingGroup().     sender.setSlotSharingGroup(slotSharingGroup).     receiver.setSlotSharingGroup(slotSharingGroup).     return new JobGraph("Blocking test job with slot sharing", sender, receiver). }
false;public;0;5;;@Override public void invoke() throws Exception {     countDownLatch.await().     super.invoke(). }
false;public,static;0;3;;public static void unblock() {     countDownLatch.countDown(). }
false;public,static;0;3;;public static void reset() {     countDownLatch = new CountDownLatch(1). }
