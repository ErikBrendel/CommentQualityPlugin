commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {     BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2].     listener.notifyDataAvailable().     return view. }
true;public;0;50;/**  * Verifies that requests for non-existing (failed/cancelled) input channels are properly  * cancelled. The receiver receives data, but there is no input channel to receive the data.  * This should cancel the request.  */ ;/**  * Verifies that requests for non-existing (failed/cancelled) input channels are properly  * cancelled. The receiver receives data, but there is no input channel to receive the data.  * This should cancel the request.  */ @Test public void testCancelPartitionRequest() throws Exception {     NettyServerAndClient serverAndClient = null.     try {         TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16).         ResultPartitionManager partitions = mock(ResultPartitionManager.class).         ResultPartitionID pid = new ResultPartitionID().         CountDownLatch sync = new CountDownLatch(1).         final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync)).         // Return infinite subpartition         when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class))).thenAnswer(new Answer<ResultSubpartitionView>() {              @Override             public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {                 BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2].                 listener.notifyDataAvailable().                 return view.             }         }).         NettyProtocol protocol = new NettyProtocol(partitions, mock(TaskEventDispatcher.class), true).         serverAndClient = initServerAndClient(protocol).         Channel ch = connect(serverAndClient).         // Request for non-existing input channel => results in cancel request         ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID(), Integer.MAX_VALUE)).await().         // Wait for the notification         if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {             fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() + " ms to be notified about cancelled partition.").         }         verify(view, times(1)).releaseAllResources().         verify(view, times(0)).notifySubpartitionConsumed().     } finally {         shutdown(serverAndClient).     } }
false;public;1;6;;@Override public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {     BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2].     listener.notifyDataAvailable().     return view. }
false;public;0;58;;@Test public void testDuplicateCancel() throws Exception {     NettyServerAndClient serverAndClient = null.     try {         final TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16).         ResultPartitionManager partitions = mock(ResultPartitionManager.class).         ResultPartitionID pid = new ResultPartitionID().         final CountDownLatch sync = new CountDownLatch(1).         final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync)).         // Return infinite subpartition         when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class))).thenAnswer(new Answer<ResultSubpartitionView>() {              @Override             public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {                 BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2].                 listener.notifyDataAvailable().                 return view.             }         }).         NettyProtocol protocol = new NettyProtocol(partitions, mock(TaskEventDispatcher.class), true).         serverAndClient = initServerAndClient(protocol).         Channel ch = connect(serverAndClient).         // Request for non-existing input channel => results in cancel request         InputChannelID inputChannelId = new InputChannelID().         ch.writeAndFlush(new PartitionRequest(pid, 0, inputChannelId, Integer.MAX_VALUE)).await().         // Wait for the notification         if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {             fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() + " ms to be notified about cancelled partition.").         }         ch.writeAndFlush(new CancelPartitionRequest(inputChannelId)).await().         ch.close().         NettyTestUtil.awaitClose(ch).         verify(view, times(1)).releaseAllResources().         verify(view, times(0)).notifySubpartitionConsumed().     } finally {         shutdown(serverAndClient).     } }
false;public;0;7;;@Nullable @Override public BufferAndBacklog getNextBuffer() throws IOException, InterruptedException {     Buffer buffer = bufferProvider.requestBufferBlocking().     // fake some data     buffer.setSize(buffer.getMaxCapacity()).     return new BufferAndBacklog(buffer, true, 0, false). }
false;public;0;3;;@Override public void notifyDataAvailable() { }
false;public;0;4;;@Override public void releaseAllResources() throws IOException {     sync.countDown(). }
false;public;0;3;;@Override public void notifySubpartitionConsumed() throws IOException { }
false;public;0;4;;@Override public boolean isReleased() {     return false. }
false;public;0;4;;@Override public boolean nextBufferIsEvent() {     return false. }
false;public;0;4;;@Override public boolean isAvailable() {     return true. }
false;public;0;4;;@Override public Throwable getFailureCause() {     return null. }
