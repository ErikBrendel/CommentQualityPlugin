commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Test public void testExitJvmOnOutOfMemory() throws Exception {     // this test works only on linux     assumeTrue(OperatingSystem.isLinux()).     // to check what went wrong (when the test hangs) uncomment this line     // ProcessEntryPoint.main(new String[0]).     final KillOnFatalErrorProcess testProcess = new KillOnFatalErrorProcess().     try {         testProcess.startProcess().         testProcess.waitFor().     } finally {         testProcess.destroy().     } }
false;public;0;4;;@Override public String getName() {     return "KillOnFatalErrorProcess". }
false;public;0;4;;@Override public String[] getJvmArgs() {     return new String[0]. }
false;public;0;4;;@Override public String getEntryPointClassName() {     return ProcessEntryPoint.class.getName(). }
false;public,static;1;100;;public static void main(String[] args) throws Exception {     System.err.println("creating task").     // have a test that exits accidentally due to a programming error     try {         final Configuration taskManagerConfig = new Configuration().         taskManagerConfig.setBoolean(TaskManagerOptions.KILL_ON_OUT_OF_MEMORY, true).         final JobID jid = new JobID().         final AllocationID allocationID = new AllocationID().         final JobVertexID jobVertexId = new JobVertexID().         final ExecutionAttemptID executionAttemptID = new ExecutionAttemptID().         final AllocationID slotAllocationId = new AllocationID().         final SerializedValue<ExecutionConfig> execConfig = new SerializedValue<>(new ExecutionConfig()).         final JobInformation jobInformation = new JobInformation(jid, "Test Job", execConfig, new Configuration(), Collections.emptyList(), Collections.emptyList()).         final TaskInformation taskInformation = new TaskInformation(jobVertexId, "Test Task", 1, 1, OomInvokable.class.getName(), new Configuration()).         final MemoryManager memoryManager = new MemoryManager(1024 * 1024, 1).         final IOManager ioManager = new IOManagerAsync().         final NetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class).         when(networkEnvironment.createKvStateTaskRegistry(jid, jobVertexId)).thenReturn(mock(TaskKvStateRegistry.class)).         TaskEventDispatcher taskEventDispatcher = mock(TaskEventDispatcher.class).         when(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher).         final TaskManagerRuntimeInfo tmInfo = TaskManagerConfiguration.fromConfiguration(taskManagerConfig).         final Executor executor = Executors.newCachedThreadPool().         BlobCacheService blobService = new BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class)).         final TaskLocalStateStore localStateStore = new TaskLocalStateStoreImpl(jid, allocationID, jobVertexId, 0, TestLocalRecoveryConfig.disabled(), executor).         final TaskStateManager slotStateManager = new TaskStateManagerImpl(jid, executionAttemptID, localStateStore, null, mock(CheckpointResponder.class)).         Task task = new Task(jobInformation, taskInformation, executionAttemptID, slotAllocationId, // subtaskIndex         0, // attemptNumber         0, Collections.<ResultPartitionDeploymentDescriptor>emptyList(), Collections.<InputGateDeploymentDescriptor>emptyList(), // targetSlotNumber         0, memoryManager, ioManager, networkEnvironment, new BroadcastVariableManager(), slotStateManager, new NoOpTaskManagerActions(), new NoOpInputSplitProvider(), new NoOpCheckpointResponder(), new TestGlobalAggregateManager(), blobService, new BlobLibraryCacheManager(blobService.getPermanentBlobService(), FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0]), new FileCache(tmInfo.getTmpDirectories(), blobService.getPermanentBlobService()), tmInfo, UnregisteredMetricGroups.createUnregisteredTaskMetricGroup(), new NoOpResultPartitionConsumableNotifier(), new NoOpPartitionProducerStateChecker(), executor).         System.err.println("starting task thread").         task.startTaskThread().     } catch (Throwable t) {         System.err.println("ERROR STARTING TASK").         t.printStackTrace().     }     System.err.println("parking the main thread").     CommonTestUtils.blockForeverNonInterruptibly(). }
false;public;0;4;;@Override public void invoke() throws Exception {     throw new OutOfMemoryError(). }
false;public;1;4;;@Override public InputSplit getNextInputSplit(ClassLoader userCodeClassLoader) {     return null. }
false;public;5;2;;@Override public void acknowledgeCheckpoint(JobID j, ExecutionAttemptID e, long i, CheckpointMetrics c, TaskStateSnapshot s) { }
false;public;4;2;;@Override public void declineCheckpoint(JobID j, ExecutionAttemptID e, long l, Throwable t) { }
false;public;3;5;;@Override public CompletableFuture<ExecutionState> requestPartitionProducerState(JobID jobId, IntermediateDataSetID intermediateDataSetId, ResultPartitionID r) {     return null. }
