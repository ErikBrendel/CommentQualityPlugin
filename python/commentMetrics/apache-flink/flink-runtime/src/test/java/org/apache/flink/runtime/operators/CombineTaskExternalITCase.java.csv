commented;modifiers;parameterAmount;loc;comment;code
false;public;0;53;;@Test public void testSingleLevelMergeCombineTask() {     final int keyCnt = 40000.     final int valCnt = 8.     addInput(new UniformRecordGenerator(keyCnt, valCnt, false)).     addDriverComparator(this.comparator).     addDriverComparator(this.comparator).     setOutput(this.outList).     getTaskConfig().setDriverStrategy(DriverStrategy.SORTED_GROUP_COMBINE).     getTaskConfig().setRelativeMemoryDriver(combine_frac).     getTaskConfig().setFilehandlesDriver(2).     final GroupReduceCombineDriver<Record, Record> testTask = new GroupReduceCombineDriver<>().     try {         testDriver(testTask, MockCombiningReduceStub.class).     } catch (Exception e) {         e.printStackTrace().         Assert.fail("Invoke method caused exception.").     }     int expSum = 0.     for (int i = 1. i < valCnt. i++) {         expSum += i.     }     // wee need to do the final aggregation manually in the test, because the     // combiner is not guaranteed to do that     final HashMap<IntValue, IntValue> aggMap = new HashMap<>().     for (Record record : this.outList) {         IntValue key = new IntValue().         IntValue value = new IntValue().         key = record.getField(0, key).         value = record.getField(1, value).         IntValue prevVal = aggMap.get(key).         if (prevVal != null) {             aggMap.put(key, new IntValue(prevVal.getValue() + value.getValue())).         } else {             aggMap.put(key, value).         }     }     Assert.assertTrue("Resultset size was " + aggMap.size() + ". Expected was " + keyCnt, aggMap.size() == keyCnt).     for (IntValue integer : aggMap.values()) {         Assert.assertTrue("Incorrect result", integer.getValue() == expSum).     }     this.outList.clear(). }
false;public;0;53;;@Test public void testMultiLevelMergeCombineTask() throws Exception {     final int keyCnt = 100000.     final int valCnt = 8.     addInput(new UniformRecordGenerator(keyCnt, valCnt, false)).     addDriverComparator(this.comparator).     addDriverComparator(this.comparator).     setOutput(this.outList).     getTaskConfig().setDriverStrategy(DriverStrategy.SORTED_GROUP_COMBINE).     getTaskConfig().setRelativeMemoryDriver(combine_frac).     getTaskConfig().setFilehandlesDriver(2).     final GroupReduceCombineDriver<Record, Record> testTask = new GroupReduceCombineDriver<>().     try {         testDriver(testTask, MockCombiningReduceStub.class).     } catch (Exception e) {         e.printStackTrace().         Assert.fail("Invoke method caused exception.").     }     int expSum = 0.     for (int i = 1. i < valCnt. i++) {         expSum += i.     }     // wee need to do the final aggregation manually in the test, because the     // combiner is not guaranteed to do that     final HashMap<IntValue, IntValue> aggMap = new HashMap<>().     for (Record record : this.outList) {         IntValue key = new IntValue().         IntValue value = new IntValue().         key = record.getField(0, key).         value = record.getField(1, value).         IntValue prevVal = aggMap.get(key).         if (prevVal != null) {             aggMap.put(key, new IntValue(prevVal.getValue() + value.getValue())).         } else {             aggMap.put(key, value).         }     }     Assert.assertTrue("Resultset size was " + aggMap.size() + ". Expected was " + keyCnt, aggMap.size() == keyCnt).     for (IntValue integer : aggMap.values()) {         Assert.assertTrue("Incorrect result", integer.getValue() == expSum).     }     this.outList.clear(). }
false;public;2;15;;@Override public void reduce(Iterable<Record> records, Collector<Record> out) {     Record element = null.     int sum = 0.     for (Record next : records) {         element = next.         element.getField(1, this.theInteger).         sum += this.theInteger.getValue().     }     this.theInteger.setValue(sum).     element.setField(1, this.theInteger).     out.collect(element). }
false;public;2;4;;@Override public void combine(Iterable<Record> records, Collector<Record> out) throws Exception {     reduce(records, out). }
false;public;2;16;;@Override public void reduce(Iterable<Record> records, Collector<Record> out) {     Record element = null.     int sum = 0.     for (Record next : records) {         element = next.         element.getField(1, this.value).         sum += this.value.getValue().     }     element.getField(0, this.key).     this.value.setValue(sum - this.key.getValue()).     element.setField(1, this.value).     out.collect(element). }
false;public;2;20;;@Override public void combine(Iterable<Record> records, Collector<Record> out) {     Record element = null.     int sum = 0.     for (Record next : records) {         element = next.         element.getField(1, this.combineValue).         sum += this.combineValue.getValue().     }     if (++this.cnt >= 10) {         throw new ExpectedTestException().     }     this.combineValue.setValue(sum).     element.setField(1, this.combineValue).     out.collect(element). }
