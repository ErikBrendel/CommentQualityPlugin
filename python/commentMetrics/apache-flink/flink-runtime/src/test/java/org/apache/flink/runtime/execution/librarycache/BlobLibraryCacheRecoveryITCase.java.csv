# id;timestamp;commentText;codeText;commentWords;codeWords
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1445293012;Tests that with {@link RecoveryMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		try {_			Configuration config = new Configuration()__			config.setString(ConfigConstants.RECOVERY_MODE, "ZOOKEEPER")__			config.setString(ConfigConstants.STATE_BACKEND, "FILESYSTEM")__			config.setString(ConfigConstants.STATE_BACKEND_FS_RECOVERY_PATH, recoveryDir.getPath())___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0])) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}_		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}__		_		File[] recoveryFiles = recoveryDir.listFiles()__		assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__	};tests,that,with,link,recovery,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,try,configuration,config,new,configuration,config,set,string,config,constants,zookeeper,config,set,string,config,constants,filesystem,config,set,string,config,constants,recovery,dir,get,path,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown,file,recovery,files,recovery,dir,list,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1445327854;Tests that with {@link RecoveryMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		try {_			Configuration config = new Configuration()__			config.setString(ConfigConstants.RECOVERY_MODE, "ZOOKEEPER")__			config.setString(ConfigConstants.STATE_BACKEND, "FILESYSTEM")__			config.setString(ConfigConstants.STATE_BACKEND_FS_RECOVERY_PATH, temporaryFolder.getRoot().getAbsolutePath())___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0])) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}_		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}__		_		File[] recoveryFiles = temporaryFolder.getRoot().listFiles()__		assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__	};tests,that,with,link,recovery,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,try,configuration,config,new,configuration,config,set,string,config,constants,zookeeper,config,set,string,config,constants,filesystem,config,set,string,config,constants,temporary,folder,get,root,get,absolute,path,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown,file,recovery,files,temporary,folder,get,root,list,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1445598182;Tests that with {@link RecoveryMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		try {_			Configuration config = new Configuration()__			config.setString(ConfigConstants.RECOVERY_MODE, "ZOOKEEPER")__			config.setString(ConfigConstants.STATE_BACKEND, "FILESYSTEM")__			config.setString(ConfigConstants.ZOOKEEPER_RECOVERY_PATH, temporaryFolder.getRoot().getAbsolutePath())___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0])) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}_		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}__		_		File[] recoveryFiles = temporaryFolder.getRoot().listFiles()__		assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__	};tests,that,with,link,recovery,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,try,configuration,config,new,configuration,config,set,string,config,constants,zookeeper,config,set,string,config,constants,filesystem,config,set,string,config,constants,temporary,folder,get,root,get,absolute,path,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown,file,recovery,files,temporary,folder,get,root,list,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1469452826;Tests that with {@link RecoveryMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		try {_			Configuration config = new Configuration()__			config.setString(ConfigConstants.RECOVERY_MODE, "ZOOKEEPER")__			config.setString(ConfigConstants.STATE_BACKEND, "FILESYSTEM")__			config.setString(ConfigConstants.ZOOKEEPER_RECOVERY_PATH, temporaryFolder.getRoot().getAbsolutePath())___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0])) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1])) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}_		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}__		_		File[] recoveryFiles = temporaryFolder.getRoot().listFiles()__		assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__	};tests,that,with,link,recovery,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,try,configuration,config,new,configuration,config,set,string,config,constants,zookeeper,config,set,string,config,constants,filesystem,config,set,string,config,constants,temporary,folder,get,root,get,absolute,path,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,client,delete,keys,get,0,client,delete,keys,get,1,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown,file,recovery,files,temporary,folder,get,root,list,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1472033364;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		try {_			Configuration config = new Configuration()__			config.setString(ConfigConstants.HIGH_AVAILABILITY, "ZOOKEEPER")__			config.setString(ConfigConstants.STATE_BACKEND, "FILESYSTEM")__			config.setString(ConfigConstants.ZOOKEEPER_HA_PATH, temporaryFolder.getRoot().getAbsolutePath())___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0])) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1])) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}_		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}__		_		File[] recoveryFiles = temporaryFolder.getRoot().listFiles()__		assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,try,configuration,config,new,configuration,config,set,string,config,constants,zookeeper,config,set,string,config,constants,filesystem,config,set,string,config,constants,temporary,folder,get,root,get,absolute,path,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,client,delete,keys,get,0,client,delete,keys,get,1,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown,file,recovery,files,temporary,folder,get,root,list,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1472033371;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		try {_			Configuration config = new Configuration()__			config.setString(ConfigConstants.HA_MODE, "ZOOKEEPER")__			config.setString(ConfigConstants.STATE_BACKEND, "FILESYSTEM")__			config.setString(ConfigConstants.HA_ZOOKEEPER_STORAGE_PATH, temporaryFolder.getRoot().getAbsolutePath())___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0])) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1])) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}_		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}__		_		File[] recoveryFiles = temporaryFolder.getRoot().listFiles()__		assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,try,configuration,config,new,configuration,config,set,string,config,constants,zookeeper,config,set,string,config,constants,filesystem,config,set,string,config,constants,temporary,folder,get,root,get,absolute,path,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,client,delete,keys,get,0,client,delete,keys,get,1,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown,file,recovery,files,temporary,folder,get,root,list,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1476095826;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		try {_			Configuration config = new Configuration()__			config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__			config.setString(ConfigConstants.STATE_BACKEND, "FILESYSTEM")__			config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.getRoot().getAbsolutePath())___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0])) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1])) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}_		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}__		_		File[] recoveryFiles = temporaryFolder.getRoot().listFiles()__		assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,try,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,config,constants,filesystem,config,set,string,high,availability,options,temporary,folder,get,root,get,absolute,path,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,client,delete,keys,get,0,client,delete,keys,get,1,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown,file,recovery,files,temporary,folder,get,root,list,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1476696544;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		try {_			Configuration config = new Configuration()__			config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__			config.setString(ConfigConstants.STATE_BACKEND, "FILESYSTEM")__			config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.getRoot().getAbsolutePath())___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}_		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}__		_		File[] recoveryFiles = temporaryFolder.getRoot().listFiles()__		assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,try,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,config,constants,filesystem,config,set,string,high,availability,options,temporary,folder,get,root,get,absolute,path,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,keys,get,0,client,delete,keys,get,1,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown,file,recovery,files,temporary,folder,get,root,list,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1485510281;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		try {_			Configuration config = new Configuration()__			config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__			config.setString(ConfigConstants.STATE_BACKEND, "FILESYSTEM")__			config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.getRoot().getAbsolutePath())___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}__			_			File[] recoveryFiles = temporaryFolder.getRoot().listFiles()__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,try,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,config,constants,filesystem,config,set,string,high,availability,options,temporary,folder,get,root,get,absolute,path,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,keys,get,0,client,delete,keys,get,1,file,recovery,files,temporary,folder,get,root,list,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1487441974;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(ConfigConstants.STATE_BACKEND, "FILESYSTEM")__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.getRoot().getAbsolutePath())___		try {_			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}__			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			File haBlobStoreDir = new File(temporaryFolder.getRoot(), clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,config,constants,filesystem,config,set,string,high,availability,options,temporary,folder,get,root,get,absolute,path,try,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,keys,get,0,client,delete,keys,get,1,final,string,cluster,id,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,temporary,folder,get,root,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1487622556;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(CoreOptions.STATE_BACKEND, "FILESYSTEM")__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.getRoot().getAbsolutePath())___		try {_			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}__			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			File haBlobStoreDir = new File(temporaryFolder.getRoot(), clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,core,options,filesystem,config,set,string,high,availability,options,temporary,folder,get,root,get,absolute,path,try,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,keys,get,0,client,delete,keys,get,1,final,string,cluster,id,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,temporary,folder,get,root,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1492256211;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(CoreOptions.STATE_BACKEND, "FILESYSTEM")__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.getRoot().getAbsolutePath())___		try {_			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.shutdown()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}__			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			File haBlobStoreDir = new File(temporaryFolder.getRoot(), clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.shutdown()__				}_			}__			if (cache != null) {_				cache.shutdown()__			}__			if (libCache != null) {_				libCache.shutdown()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,core,options,filesystem,config,set,string,high,availability,options,temporary,folder,get,root,get,absolute,path,try,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,shutdown,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,keys,get,0,client,delete,keys,get,1,final,string,cluster,id,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,temporary,folder,get,root,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,server,s,server,if,s,null,s,shutdown,if,cache,null,cache,shutdown,if,lib,cache,null,lib,cache,shutdown
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1495001929;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(CoreOptions.STATE_BACKEND, "FILESYSTEM")__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.getRoot().getAbsolutePath())___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config, blobStoreService)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config, blobStoreService)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}__			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			File haBlobStoreDir = new File(temporaryFolder.getRoot(), clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (libCache != null) {_				libCache.shutdown()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,core,options,filesystem,config,set,string,high,availability,options,temporary,folder,get,root,get,absolute,path,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,blob,store,service,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,blob,store,service,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,keys,get,0,client,delete,keys,get,1,final,string,cluster,id,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,temporary,folder,get,root,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,lib,cache,null,lib,cache,shutdown,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1502100084;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(CoreOptions.STATE_BACKEND, "FILESYSTEM")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config, blobStoreService)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config, blobStoreService)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = libCache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = libCache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}__			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (libCache != null) {_				libCache.shutdown()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,core,options,filesystem,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,blob,store,service,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,blob,store,service,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,lib,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,lib,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,keys,get,0,client,delete,keys,get,1,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,lib,cache,null,lib,cache,shutdown,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1502201311;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(CoreOptions.STATE_BACKEND, "FILESYSTEM")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config, blobStoreService)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = new File(cache.getURL(keys.get(0)).toURI())__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config, blobStoreService)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = new File(cache.getURL(keys.get(0)).toURI())__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = new File(cache.getURL(keys.get(1)).toURI())__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}__			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (libCache != null) {_				libCache.shutdown()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,core,options,filesystem,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,blob,store,service,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,new,file,cache,get,url,keys,get,0,to,uri,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,blob,store,service,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,new,file,cache,get,url,keys,get,0,to,uri,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,new,file,cache,get,url,keys,get,1,to,uri,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,keys,get,0,client,delete,keys,get,1,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,lib,cache,null,lib,cache,shutdown,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1502692653;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(CoreOptions.STATE_BACKEND, "FILESYSTEM")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(expected))_ _				keys.add(client.put(expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config, blobStoreService)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			JobID jobId = new JobID()__			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = cache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config, blobStoreService)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = cache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = cache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}__			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (libCache != null) {_				libCache.shutdown()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,core,options,filesystem,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,expected,keys,add,client,put,expected,32,256,cache,new,blob,cache,server,address,0,config,blob,store,service,lib,cache,new,blob,library,cache,manager,cache,3600,1000,job,id,job,id,new,job,id,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,blob,store,service,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,keys,get,0,client,delete,keys,get,1,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,lib,cache,null,lib,cache,shutdown,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1502701584;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(CoreOptions.STATE_BACKEND, "FILESYSTEM")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], 3600 * 1000)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			JobID jobId = new JobID()__			_			JobID blobJobId = null___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(blobJobId, expected))_ _				keys.add(client.put(blobJobId, expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config, blobStoreService)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = cache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()__			libCache.shutdown()___			cache = new BlobCache(serverAddress[1], config, blobStoreService)__			libCache = new BlobLibraryCacheManager(cache, 3600 * 1000)___			_			f = cache.getFile(keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = cache.getFile(keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(keys.get(0))__				client.delete(keys.get(1))__			}__			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (libCache != null) {_				libCache.shutdown()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,core,options,filesystem,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,3600,1000,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,job,id,job,id,new,job,id,job,id,blob,job,id,null,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,blob,job,id,expected,keys,add,client,put,blob,job,id,expected,32,256,cache,new,blob,cache,server,address,0,config,blob,store,service,lib,cache,new,blob,library,cache,manager,cache,3600,1000,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,lib,cache,shutdown,cache,new,blob,cache,server,address,1,config,blob,store,service,lib,cache,new,blob,library,cache,manager,cache,3600,1000,f,cache,get,file,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,cache,get,file,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,keys,get,0,client,delete,keys,get,1,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,lib,cache,null,lib,cache,shutdown,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1503041372;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(CoreOptions.STATE_BACKEND, "FILESYSTEM")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600L)___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i])__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			JobID jobId = new JobID()___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(jobId, expected))_ _				keys.add(client.put(jobId, expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config, blobStoreService)___			_			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()___			cache = new BlobCache(serverAddress[1], config, blobStoreService)___			_			f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = cache.getFile(jobId, keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(jobId, keys.get(0))__				client.delete(jobId, keys.get(1))__			}__			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobLibraryCacheManager s : libServer) {_				if (s != null) {_					s.shutdown()__				}_			}_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,core,options,filesystem,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,job,id,job,id,new,job,id,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,job,id,expected,keys,add,client,put,job,id,expected,32,256,cache,new,blob,cache,server,address,0,config,blob,store,service,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,cache,new,blob,cache,server,address,1,config,blob,store,service,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,cache,get,file,job,id,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,job,id,keys,get,0,client,delete,job,id,keys,get,1,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,library,cache,manager,s,lib,server,if,s,null,s,shutdown,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1505998908;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		BlobCache cache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(CoreOptions.STATE_BACKEND, "FILESYSTEM")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600L)___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			JobID jobId = new JobID()___			_			try (BlobClient client = new BlobClient(serverAddress[0], config)) {_				keys.add(client.put(jobId, expected))_ _				keys.add(client.put(jobId, expected, 32, 256))_ _			}__			_			cache = new BlobCache(serverAddress[0], config, blobStoreService)___			_			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()___			cache = new BlobCache(serverAddress[1], config, blobStoreService)___			_			f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = cache.getFile(jobId, keys.get(1))__			assertEquals(256, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected[32 + i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			try (BlobClient client = new BlobClient(serverAddress[1], config)) {_				client.delete(jobId, keys.get(0))__				client.delete(jobId, keys.get(1))__			}__			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobLibraryCacheManager s : libServer) {_				if (s != null) {_					s.shutdown()__				}_			}_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,blob,cache,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,core,options,filesystem,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,flink,user,code,class,loaders,resolve,order,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,job,id,job,id,new,job,id,try,blob,client,client,new,blob,client,server,address,0,config,keys,add,client,put,job,id,expected,keys,add,client,put,job,id,expected,32,256,cache,new,blob,cache,server,address,0,config,blob,store,service,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,cache,new,blob,cache,server,address,1,config,blob,store,service,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,cache,get,file,job,id,keys,get,1,assert,equals,256,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected,32,i,byte,fis,read,assert,equals,0,fis,available,try,blob,client,client,new,blob,client,server,address,1,config,client,delete,job,id,keys,get,0,client,delete,job,id,keys,get,1,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,library,cache,manager,s,lib,server,if,s,null,s,shutdown,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1507212387;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		PermanentBlobCache cache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(CoreOptions.STATE_BACKEND, "FILESYSTEM")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600L)___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				server[i].start()__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			List<BlobKey> keys = new ArrayList<>(2)___			JobID jobId = new JobID()___			_			keys.add(server[0].putHA(jobId, expected))_ _			byte[] expected2 = Arrays.copyOfRange(expected, 32, 288)__			keys.add(server[0].putHA(jobId, expected2))_ __			_			cache = new PermanentBlobCache(serverAddress[0], config, blobStoreService)___			_			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = cache.getHAFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()___			cache = new PermanentBlobCache(serverAddress[1], config, blobStoreService)___			_			f = cache.getHAFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = cache.getHAFile(jobId, keys.get(1))__			assertEquals(expected2.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected2[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			server[1].cleanupJob(jobId)___			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobLibraryCacheManager s : libServer) {_				if (s != null) {_					s.shutdown()__				}_			}_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,permanent,blob,cache,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,core,options,filesystem,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,i,start,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,flink,user,code,class,loaders,resolve,order,byte,expected,new,byte,1024,rand,next,bytes,expected,list,blob,key,keys,new,array,list,2,job,id,job,id,new,job,id,keys,add,server,0,put,ha,job,id,expected,byte,expected2,arrays,copy,of,range,expected,32,288,keys,add,server,0,put,ha,job,id,expected2,cache,new,permanent,blob,cache,server,address,0,config,blob,store,service,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,cache,get,hafile,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,cache,new,permanent,blob,cache,server,address,1,config,blob,store,service,f,cache,get,hafile,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,cache,get,hafile,job,id,keys,get,1,assert,equals,expected2,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected2,i,byte,fis,read,assert,equals,0,fis,available,server,1,cleanup,job,job,id,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,library,cache,manager,s,lib,server,if,s,null,s,shutdown,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1507212387;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		PermanentBlobCache cache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600L)___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				server[i].start()__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			ArrayList<PermanentBlobKey> keys = new ArrayList<>(2)___			JobID jobId = new JobID()___			_			keys.add(server[0].putPermanent(jobId, expected))_ _			byte[] expected2 = Arrays.copyOfRange(expected, 32, 288)__			keys.add(server[0].putPermanent(jobId, expected2))_ __			_			cache = new PermanentBlobCache(serverAddress[0], config, blobStoreService)___			_			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()___			cache = new PermanentBlobCache(serverAddress[1], config, blobStoreService)___			_			f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = cache.getFile(jobId, keys.get(1))__			assertEquals(expected2.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected2[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			server[1].cleanupJob(jobId)___			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobLibraryCacheManager s : libServer) {_				if (s != null) {_					s.shutdown()__				}_			}_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,permanent,blob,cache,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,i,start,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,flink,user,code,class,loaders,resolve,order,byte,expected,new,byte,1024,rand,next,bytes,expected,array,list,permanent,blob,key,keys,new,array,list,2,job,id,job,id,new,job,id,keys,add,server,0,put,permanent,job,id,expected,byte,expected2,arrays,copy,of,range,expected,32,288,keys,add,server,0,put,permanent,job,id,expected2,cache,new,permanent,blob,cache,server,address,0,config,blob,store,service,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,cache,new,permanent,blob,cache,server,address,1,config,blob,store,service,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,cache,get,file,job,id,keys,get,1,assert,equals,expected2,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected2,i,byte,fis,read,assert,equals,0,fis,available,server,1,cleanup,job,job,id,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,library,cache,manager,s,lib,server,if,s,null,s,shutdown,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1508939746;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		PermanentBlobCache cache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600L)___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				server[i].start()__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0])__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			ArrayList<PermanentBlobKey> keys = new ArrayList<>(2)___			JobID jobId = new JobID()___			_			keys.add(server[0].putPermanent(jobId, expected))_ _			byte[] expected2 = Arrays.copyOfRange(expected, 32, 288)__			keys.add(server[0].putPermanent(jobId, expected2))_ __			_			cache = new PermanentBlobCache(serverAddress[0], config, blobStoreService)___			_			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()___			cache = new PermanentBlobCache(serverAddress[1], config, blobStoreService)___			_			f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = cache.getFile(jobId, keys.get(1))__			assertEquals(expected2.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected2[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			server[1].cleanupJob(jobId)___			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobLibraryCacheManager s : libServer) {_				if (s != null) {_					s.shutdown()__				}_			}_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,permanent,blob,cache,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,i,start,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,flink,user,code,class,loaders,resolve,order,new,string,0,byte,expected,new,byte,1024,rand,next,bytes,expected,array,list,permanent,blob,key,keys,new,array,list,2,job,id,job,id,new,job,id,keys,add,server,0,put,permanent,job,id,expected,byte,expected2,arrays,copy,of,range,expected,32,288,keys,add,server,0,put,permanent,job,id,expected2,cache,new,permanent,blob,cache,server,address,0,config,blob,store,service,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,cache,new,permanent,blob,cache,server,address,1,config,blob,store,service,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,cache,get,file,job,id,keys,get,1,assert,equals,expected2,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected2,i,byte,fis,read,assert,equals,0,fis,available,server,1,cleanup,job,job,id,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,library,cache,manager,s,lib,server,if,s,null,s,shutdown,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1517915730;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		PermanentBlobCache cache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600L)___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				server[i].start()__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0])__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			ArrayList<PermanentBlobKey> keys = new ArrayList<>(2)___			JobID jobId = new JobID()___			_			keys.add(server[0].putPermanent(jobId, expected))_ _			byte[] expected2 = Arrays.copyOfRange(expected, 32, 288)__			keys.add(server[0].putPermanent(jobId, expected2))_ __			_			cache = new PermanentBlobCache(config, blobStoreService, serverAddress[0])___			_			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()___			cache = new PermanentBlobCache(config, blobStoreService, serverAddress[1])___			_			f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = cache.getFile(jobId, keys.get(1))__			assertEquals(expected2.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected2[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			server[1].cleanupJob(jobId)___			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobLibraryCacheManager s : libServer) {_				if (s != null) {_					s.shutdown()__				}_			}_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,permanent,blob,cache,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,i,start,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,flink,user,code,class,loaders,resolve,order,new,string,0,byte,expected,new,byte,1024,rand,next,bytes,expected,array,list,permanent,blob,key,keys,new,array,list,2,job,id,job,id,new,job,id,keys,add,server,0,put,permanent,job,id,expected,byte,expected2,arrays,copy,of,range,expected,32,288,keys,add,server,0,put,permanent,job,id,expected2,cache,new,permanent,blob,cache,config,blob,store,service,server,address,0,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,cache,new,permanent,blob,cache,config,blob,store,service,server,address,1,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,cache,get,file,job,id,keys,get,1,assert,equals,expected2,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected2,i,byte,fis,read,assert,equals,0,fis,available,server,1,cleanup,job,job,id,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,library,cache,manager,s,lib,server,if,s,null,s,shutdown,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
BlobLibraryCacheRecoveryITCase -> @Test 	public void testRecoveryRegisterAndDownload() throws Exception;1526549506;Tests that with {@link HighAvailabilityMode#ZOOKEEPER} distributed JARs are recoverable from any_participating BlobLibraryCacheManager.;@Test_	public void testRecoveryRegisterAndDownload() throws Exception {_		Random rand = new Random()___		BlobServer[] server = new BlobServer[2]__		InetSocketAddress[] serverAddress = new InetSocketAddress[2]__		BlobLibraryCacheManager[] libServer = new BlobLibraryCacheManager[2]__		PermanentBlobCache cache = null__		BlobStoreService blobStoreService = null___		Configuration config = new Configuration()__		config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER")__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setString(HighAvailabilityOptions.HA_STORAGE_PATH,_			temporaryFolder.newFolder().getAbsolutePath())__		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600L)___		try {_			blobStoreService = BlobUtils.createBlobStoreFromConfig(config)___			for (int i = 0_ i < server.length_ i++) {_				server[i] = new BlobServer(config, blobStoreService)__				server[i].start()__				serverAddress[i] = new InetSocketAddress("localhost", server[i].getPort())__				libServer[i] = new BlobLibraryCacheManager(server[i], FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0])__			}__			_			byte[] expected = new byte[1024]__			rand.nextBytes(expected)___			ArrayList<PermanentBlobKey> keys = new ArrayList<>(2)___			JobID jobId = new JobID()___			_			keys.add(server[0].putPermanent(jobId, expected))_ _			byte[] expected2 = Arrays.copyOfRange(expected, 32, 288)__			keys.add(server[0].putPermanent(jobId, expected2))_ __			_			cache = new PermanentBlobCache(config, blobStoreService, serverAddress[0])___			_			ExecutionAttemptID executionId = new ExecutionAttemptID()__			libServer[0].registerTask(jobId, executionId, keys, Collections.<URL>emptyList())___			_			File f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			cache.close()___			cache = new PermanentBlobCache(config, blobStoreService, serverAddress[1])___			_			f = cache.getFile(jobId, keys.get(0))__			assertEquals(expected.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < expected.length && fis.available() > 0_ i++) {_					assertEquals(expected[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			f = cache.getFile(jobId, keys.get(1))__			assertEquals(expected2.length, f.length())___			try (FileInputStream fis = new FileInputStream(f)) {_				for (int i = 0_ i < 256 && fis.available() > 0_ i++) {_					assertEquals(expected2[i], (byte) fis.read())__				}__				assertEquals(0, fis.available())__			}__			_			server[1].cleanupJob(jobId, true)___			_			final String clusterId = config.getString(HighAvailabilityOptions.HA_CLUSTER_ID)__			String haBlobStorePath = config.getString(HighAvailabilityOptions.HA_STORAGE_PATH)__			File haBlobStoreDir = new File(haBlobStorePath, clusterId)__			File[] recoveryFiles = haBlobStoreDir.listFiles()__			assertNotNull("HA storage directory does not exist", recoveryFiles)__			assertEquals("Unclean state backend: " + Arrays.toString(recoveryFiles), 0, recoveryFiles.length)__		}_		finally {_			for (BlobLibraryCacheManager s : libServer) {_				if (s != null) {_					s.shutdown()__				}_			}_			for (BlobServer s : server) {_				if (s != null) {_					s.close()__				}_			}__			if (cache != null) {_				cache.close()__			}__			if (blobStoreService != null) {_				blobStoreService.closeAndCleanupAllData()__			}_		}_	};tests,that,with,link,high,availability,mode,zookeeper,distributed,jars,are,recoverable,from,any,participating,blob,library,cache,manager;test,public,void,test,recovery,register,and,download,throws,exception,random,rand,new,random,blob,server,server,new,blob,server,2,inet,socket,address,server,address,new,inet,socket,address,2,blob,library,cache,manager,lib,server,new,blob,library,cache,manager,2,permanent,blob,cache,cache,null,blob,store,service,blob,store,service,null,configuration,config,new,configuration,config,set,string,high,availability,options,zookeeper,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,string,high,availability,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,try,blob,store,service,blob,utils,create,blob,store,from,config,config,for,int,i,0,i,server,length,i,server,i,new,blob,server,config,blob,store,service,server,i,start,server,address,i,new,inet,socket,address,localhost,server,i,get,port,lib,server,i,new,blob,library,cache,manager,server,i,flink,user,code,class,loaders,resolve,order,new,string,0,byte,expected,new,byte,1024,rand,next,bytes,expected,array,list,permanent,blob,key,keys,new,array,list,2,job,id,job,id,new,job,id,keys,add,server,0,put,permanent,job,id,expected,byte,expected2,arrays,copy,of,range,expected,32,288,keys,add,server,0,put,permanent,job,id,expected2,cache,new,permanent,blob,cache,config,blob,store,service,server,address,0,execution,attempt,id,execution,id,new,execution,attempt,id,lib,server,0,register,task,job,id,execution,id,keys,collections,url,empty,list,file,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,cache,close,cache,new,permanent,blob,cache,config,blob,store,service,server,address,1,f,cache,get,file,job,id,keys,get,0,assert,equals,expected,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,expected,length,fis,available,0,i,assert,equals,expected,i,byte,fis,read,assert,equals,0,fis,available,f,cache,get,file,job,id,keys,get,1,assert,equals,expected2,length,f,length,try,file,input,stream,fis,new,file,input,stream,f,for,int,i,0,i,256,fis,available,0,i,assert,equals,expected2,i,byte,fis,read,assert,equals,0,fis,available,server,1,cleanup,job,job,id,true,final,string,cluster,id,config,get,string,high,availability,options,string,ha,blob,store,path,config,get,string,high,availability,options,file,ha,blob,store,dir,new,file,ha,blob,store,path,cluster,id,file,recovery,files,ha,blob,store,dir,list,files,assert,not,null,ha,storage,directory,does,not,exist,recovery,files,assert,equals,unclean,state,backend,arrays,to,string,recovery,files,0,recovery,files,length,finally,for,blob,library,cache,manager,s,lib,server,if,s,null,s,shutdown,for,blob,server,s,server,if,s,null,s,close,if,cache,null,cache,close,if,blob,store,service,null,blob,store,service,close,and,cleanup,all,data
