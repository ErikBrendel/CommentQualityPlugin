commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;// -------------------------------------------------------------------------------------------- @Before public void beforeTest() {     memManager = new MemoryManager(NUM_MEMORY_SEGMENTS * MEMORY_PAGE_SIZE, 1, MEMORY_PAGE_SIZE, MemoryType.HEAP, true).     ioManager = new IOManagerAsync(). }
false;public;0;6;;@After public void afterTest() {     ioManager.shutdown().     assertTrue("I/O Manager was not properly shut down.", ioManager.isProperlyShutDown()).     assertTrue("The memory has not been properly released", memManager.verifyEmpty()). }
false;public;0;43;;// -------------------------------------------------------------------------------------------- @Test public void testWriteReadSmallRecords() {     try {         List<MemorySegment> memory = memManager.allocatePages(new DummyInvokable(), NUM_MEMORY_SEGMENTS).         final PairGenerator generator = new PairGenerator(SEED, KEY_MAX, VALUE_SHORT_LENGTH, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final FileIOChannel.ID channel = ioManager.createChannel().         // create the writer output view         final BlockChannelWriter<MemorySegment> writer = ioManager.createBlockChannelWriter(channel).         final FileChannelOutputView outView = new FileChannelOutputView(writer, memManager, memory, MEMORY_PAGE_SIZE).         // write a number of pairs         Pair pair = new Pair().         for (int i = 0. i < NUM_PAIRS_SHORT. i++) {             generator.next(pair).             pair.write(outView).         }         outView.close().         // create the reader input view         List<MemorySegment> readMemory = memManager.allocatePages(new DummyInvokable(), NUM_MEMORY_SEGMENTS).         final BlockChannelReader<MemorySegment> reader = ioManager.createBlockChannelReader(channel).         final FileChannelInputView inView = new FileChannelInputView(reader, memManager, readMemory, outView.getBytesInLatestSegment()).         generator.reset().         // read and re-generate all records and compare them         Pair readPair = new Pair().         for (int i = 0. i < NUM_PAIRS_SHORT. i++) {             generator.next(pair).             readPair.read(inView).             assertEquals("The re-generated and the read record do not match.", pair, readPair).         }         inView.close().         reader.deleteChannel().     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;43;;@Test public void testWriteAndReadLongRecords() {     try {         final List<MemorySegment> memory = memManager.allocatePages(new DummyInvokable(), NUM_MEMORY_SEGMENTS).         final PairGenerator generator = new PairGenerator(SEED, KEY_MAX, VALUE_LONG_LENGTH, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final FileIOChannel.ID channel = this.ioManager.createChannel().         // create the writer output view         final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel).         final FileChannelOutputView outView = new FileChannelOutputView(writer, memManager, memory, MEMORY_PAGE_SIZE).         // write a number of pairs         Pair pair = new Pair().         for (int i = 0. i < NUM_PAIRS_LONG. i++) {             generator.next(pair).             pair.write(outView).         }         outView.close().         // create the reader input view         List<MemorySegment> readMemory = memManager.allocatePages(new DummyInvokable(), NUM_MEMORY_SEGMENTS).         final BlockChannelReader<MemorySegment> reader = ioManager.createBlockChannelReader(channel).         final FileChannelInputView inView = new FileChannelInputView(reader, memManager, readMemory, outView.getBytesInLatestSegment()).         generator.reset().         // read and re-generate all records and compare them         Pair readPair = new Pair().         for (int i = 0. i < NUM_PAIRS_LONG. i++) {             generator.next(pair).             readPair.read(inView).             assertEquals("The re-generated and the read record do not match.", pair, readPair).         }         inView.close().         reader.deleteChannel().     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;49;;@Test public void testReadTooMany() {     try {         final List<MemorySegment> memory = memManager.allocatePages(new DummyInvokable(), NUM_MEMORY_SEGMENTS).         final PairGenerator generator = new PairGenerator(SEED, KEY_MAX, VALUE_SHORT_LENGTH, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final FileIOChannel.ID channel = this.ioManager.createChannel().         // create the writer output view         final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel).         final FileChannelOutputView outView = new FileChannelOutputView(writer, memManager, memory, MEMORY_PAGE_SIZE).         // write a number of pairs         Pair pair = new Pair().         for (int i = 0. i < NUM_PAIRS_SHORT. i++) {             generator.next(pair).             pair.write(outView).         }         outView.close().         // create the reader input view         List<MemorySegment> readMemory = memManager.allocatePages(new DummyInvokable(), NUM_MEMORY_SEGMENTS).         final BlockChannelReader<MemorySegment> reader = ioManager.createBlockChannelReader(channel).         final FileChannelInputView inView = new FileChannelInputView(reader, memManager, readMemory, outView.getBytesInLatestSegment()).         generator.reset().         // read and re-generate all records and compare them         try {             Pair readPair = new Pair().             for (int i = 0. i < NUM_PAIRS_SHORT + 1. i++) {                 generator.next(pair).                 readPair.read(inView).                 assertEquals("The re-generated and the read record do not match.", pair, readPair).             }             fail("Expected an EOFException which did not occur.").         } catch (EOFException eofex) {         // expected         }         inView.close().         reader.deleteChannel().     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;43;;@Test public void testWriteReadOneBufferOnly() {     try {         final List<MemorySegment> memory = memManager.allocatePages(new DummyInvokable(), 1).         final PairGenerator generator = new PairGenerator(SEED, KEY_MAX, VALUE_SHORT_LENGTH, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final FileIOChannel.ID channel = this.ioManager.createChannel().         // create the writer output view         final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel).         final FileChannelOutputView outView = new FileChannelOutputView(writer, memManager, memory, MEMORY_PAGE_SIZE).         // write a number of pairs         Pair pair = new Pair().         for (int i = 0. i < NUM_PAIRS_SHORT. i++) {             generator.next(pair).             pair.write(outView).         }         outView.close().         // create the reader input view         List<MemorySegment> readMemory = memManager.allocatePages(new DummyInvokable(), 1).         final BlockChannelReader<MemorySegment> reader = ioManager.createBlockChannelReader(channel).         final FileChannelInputView inView = new FileChannelInputView(reader, memManager, readMemory, outView.getBytesInLatestSegment()).         generator.reset().         // read and re-generate all records and compare them         Pair readPair = new Pair().         for (int i = 0. i < NUM_PAIRS_SHORT. i++) {             generator.next(pair).             readPair.read(inView).             assertEquals("The re-generated and the read record do not match.", pair, readPair).         }         inView.close().         reader.deleteChannel().     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;43;;@Test public void testWriteReadNotAll() {     try {         final List<MemorySegment> memory = memManager.allocatePages(new DummyInvokable(), NUM_MEMORY_SEGMENTS).         final PairGenerator generator = new PairGenerator(SEED, KEY_MAX, VALUE_SHORT_LENGTH, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final FileIOChannel.ID channel = this.ioManager.createChannel().         // create the writer output view         final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channel).         final FileChannelOutputView outView = new FileChannelOutputView(writer, memManager, memory, MEMORY_PAGE_SIZE).         // write a number of pairs         Pair pair = new Pair().         for (int i = 0. i < NUM_PAIRS_SHORT. i++) {             generator.next(pair).             pair.write(outView).         }         outView.close().         // create the reader input view         List<MemorySegment> readMemory = memManager.allocatePages(new DummyInvokable(), NUM_MEMORY_SEGMENTS).         final BlockChannelReader<MemorySegment> reader = ioManager.createBlockChannelReader(channel).         final FileChannelInputView inView = new FileChannelInputView(reader, memManager, readMemory, outView.getBytesInLatestSegment()).         generator.reset().         // read and re-generate all records and compare them         Pair readPair = new Pair().         for (int i = 0. i < NUM_PAIRS_SHORT / 2. i++) {             generator.next(pair).             readPair.read(inView).             assertEquals("The re-generated and the read record do not match.", pair, readPair).         }         inView.close().         reader.deleteChannel().     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
