commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Before public void createQueuesAndActors() {     numCalls = 1000.     awaitLatch = new OneShotLatch().     triggerLatch = new OneShotLatch().     notifyCheckpointCompleteLatch = new OneShotLatch().     stopLatch = new OneShotLatch().     classLoaders.clear(). }
false;public;0;20;;// ------------------------------------------------------------------------ // Tests // ------------------------------------------------------------------------ @Test public void testCheckpointCallsInOrder() throws Exception {     Task task = createTask(CheckpointsInOrderInvokable.class).     try (TaskCleaner ignored = new TaskCleaner(task)) {         task.startTaskThread().         awaitLatch.await().         for (int i = 1. i <= numCalls. i++) {             task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpointWithDefaultLocation()).         }         triggerLatch.await().         assertFalse(task.isCanceledOrFailed()).         ExecutionState currentState = task.getExecutionState().         assertThat(currentState, isOneOf(ExecutionState.RUNNING, ExecutionState.FINISHED)).     } }
false;public;0;21;;@Test public void testMixedAsyncCallsInOrder() throws Exception {     Task task = createTask(CheckpointsInOrderInvokable.class).     try (TaskCleaner ignored = new TaskCleaner(task)) {         task.startTaskThread().         awaitLatch.await().         for (int i = 1. i <= numCalls. i++) {             task.triggerCheckpointBarrier(i, 156865867234L, CheckpointOptions.forCheckpointWithDefaultLocation()).             task.notifyCheckpointComplete(i).         }         triggerLatch.await().         assertFalse(task.isCanceledOrFailed()).         ExecutionState currentState = task.getExecutionState().         assertThat(currentState, isOneOf(ExecutionState.RUNNING, ExecutionState.FINISHED)).     } }
false;public;0;15;;@Test public void testThrowExceptionIfStopInvokedWithNotStoppableTask() throws Exception {     Task task = createTask(CheckpointsInOrderInvokable.class).     try (TaskCleaner ignored = new TaskCleaner(task)) {         task.startTaskThread().         awaitLatch.await().         try {             task.stopExecution().             fail("Expected exception not thrown").         } catch (UnsupportedOperationException e) {             assertThat(e.getMessage(), containsString("Stopping not supported by task")).         }     } }
true;public;0;22;/**  * Asserts that {@link AbstractInvokable#triggerCheckpoint(CheckpointMetaData, CheckpointOptions)},  * {@link AbstractInvokable#notifyCheckpointComplete(long)}, and {@link StoppableTask#stop()} are  * invoked by a thread whose context class loader is set to the user code class loader.  */ ;/**  * Asserts that {@link AbstractInvokable#triggerCheckpoint(CheckpointMetaData, CheckpointOptions)},  * {@link AbstractInvokable#notifyCheckpointComplete(long)}, and {@link StoppableTask#stop()} are  * invoked by a thread whose context class loader is set to the user code class loader.  */ @Test public void testSetsUserCodeClassLoader() throws Exception {     numCalls = 1.     Task task = createTask(ContextClassLoaderInterceptingInvokable.class).     try (TaskCleaner ignored = new TaskCleaner(task)) {         task.startTaskThread().         awaitLatch.await().         task.triggerCheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()).         task.notifyCheckpointComplete(1).         task.stopExecution().         triggerLatch.await().         notifyCheckpointCompleteLatch.await().         stopLatch.await().         assertThat(classLoaders, hasSize(greaterThanOrEqualTo(3))).         assertThat(classLoaders, everyItem(instanceOf(TestUserCodeClassLoader.class))).     } }
false;private;1;66;;private Task createTask(Class<? extends AbstractInvokable> invokableClass) throws Exception {     BlobCacheService blobService = new BlobCacheService(mock(PermanentBlobCache.class), mock(TransientBlobCache.class)).     LibraryCacheManager libCache = mock(LibraryCacheManager.class).     when(libCache.getClassLoader(any(JobID.class))).thenReturn(new TestUserCodeClassLoader()).     ResultPartitionManager partitionManager = mock(ResultPartitionManager.class).     ResultPartitionConsumableNotifier consumableNotifier = new NoOpResultPartitionConsumableNotifier().     PartitionProducerStateChecker partitionProducerStateChecker = mock(PartitionProducerStateChecker.class).     Executor executor = mock(Executor.class).     TaskEventDispatcher taskEventDispatcher = mock(TaskEventDispatcher.class).     NetworkEnvironment networkEnvironment = mock(NetworkEnvironment.class).     when(networkEnvironment.getResultPartitionManager()).thenReturn(partitionManager).     when(networkEnvironment.getDefaultIOMode()).thenReturn(IOManager.IOMode.SYNC).     when(networkEnvironment.createKvStateTaskRegistry(any(JobID.class), any(JobVertexID.class))).thenReturn(mock(TaskKvStateRegistry.class)).     when(networkEnvironment.getTaskEventDispatcher()).thenReturn(taskEventDispatcher).     TaskMetricGroup taskMetricGroup = mock(TaskMetricGroup.class).     when(taskMetricGroup.getIOMetricGroup()).thenReturn(mock(TaskIOMetricGroup.class)).     JobInformation jobInformation = new JobInformation(new JobID(), "Job Name", new SerializedValue<>(new ExecutionConfig()), new Configuration(), Collections.emptyList(), Collections.emptyList()).     TaskInformation taskInformation = new TaskInformation(new JobVertexID(), "Test Task", 1, 1, invokableClass.getName(), new Configuration()).     return new Task(jobInformation, taskInformation, new ExecutionAttemptID(), new AllocationID(), 0, 0, Collections.<ResultPartitionDeploymentDescriptor>emptyList(), Collections.<InputGateDeploymentDescriptor>emptyList(), 0, mock(MemoryManager.class), mock(IOManager.class), networkEnvironment, mock(BroadcastVariableManager.class), new TestTaskStateManager(), mock(TaskManagerActions.class), mock(InputSplitProvider.class), mock(CheckpointResponder.class), new TestGlobalAggregateManager(), blobService, libCache, mock(FileCache.class), new TestingTaskManagerRuntimeInfo(), taskMetricGroup, consumableNotifier, partitionProducerStateChecker, executor). }
false;public;0;20;;@Override public void invoke() throws Exception {     awaitLatch.trigger().     // wait forever (until canceled)     synchronized (this) {         while (error == null) {             wait().         }     }     if (error != null) {         // exit method prematurely due to error but make sure that the tests can finish         triggerLatch.trigger().         notifyCheckpointCompleteLatch.trigger().         stopLatch.trigger().         throw error.     } }
false;public;2;16;;@Override public boolean triggerCheckpoint(CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions) {     lastCheckpointId++.     if (checkpointMetaData.getCheckpointId() == lastCheckpointId) {         if (lastCheckpointId == numCalls) {             triggerLatch.trigger().         }     } else if (this.error == null) {         this.error = new Exception("calls out of order").         synchronized (this) {             notifyAll().         }     }     return true. }
false;public;3;4;;@Override public void triggerCheckpointOnBarrier(CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions, CheckpointMetrics checkpointMetrics) throws Exception {     throw new UnsupportedOperationException("Should not be called"). }
false;public;2;4;;@Override public void abortCheckpointOnBarrier(long checkpointId, Throwable cause) {     throw new UnsupportedOperationException("Should not be called"). }
false;public;1;11;;@Override public void notifyCheckpointComplete(long checkpointId) {     if (checkpointId != lastCheckpointId && this.error == null) {         this.error = new Exception("calls out of order").         synchronized (this) {             notifyAll().         }     } else if (lastCheckpointId == numCalls) {         notifyCheckpointCompleteLatch.trigger().     } }
false;public;2;6;;@Override public boolean triggerCheckpoint(CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions) {     classLoaders.add(Thread.currentThread().getContextClassLoader()).     return super.triggerCheckpoint(checkpointMetaData, checkpointOptions). }
false;public;1;6;;@Override public void notifyCheckpointComplete(long checkpointId) {     classLoaders.add(Thread.currentThread().getContextClassLoader()).     super.notifyCheckpointComplete(checkpointId). }
false;public;0;5;;@Override public void stop() {     classLoaders.add(Thread.currentThread().getContextClassLoader()).     stopLatch.trigger(). }
false;public;0;5;;@Override public void close() throws Exception {     task.cancelExecution().     task.getExecutingThread().join(5000). }
