# id;timestamp;commentText;codeText;commentWords;codeWords
InPlaceMutableHashTableTest -> @Test 	public void testHashTableGrowthWithInsertOrReplace();1468441547;This test validates that records are not lost via "insertOrReplace()" as in bug [FLINK-2361]__This has to be duplicated in InPlaceMutableHashTableTest and CompactingHashTableTest_because of the different constructor calls.;@Test_	public void testHashTableGrowthWithInsertOrReplace() {_		try {_			final int numElements = 1000000___			List<MemorySegment> memory = getMemory(1000, 32 * 1024)___			InPlaceMutableHashTable<Tuple2<Long, String>> table = new InPlaceMutableHashTable<Tuple2<Long, String>>(_				serializer, comparator, memory)__			table.open()___			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, String.valueOf(i)))__			}__			_			{_				BitSet bitSet = new BitSet(numElements)__				MutableObjectIterator<Tuple2<Long, String>> iter = table.getEntryIterator()__				Tuple2<Long, String> next__				while ((next = iter.next()) != null) {_					assertNotNull(next.f0)__					assertNotNull(next.f1)__					assertEquals(next.f0.longValue(), Long.parseLong(next.f1))___					bitSet.set(next.f0.intValue())__				}__				assertEquals(numElements, bitSet.cardinality())__			}__			_			{_				InPlaceMutableHashTable<Tuple2<Long, String>>.HashTableProber<Long> proper =_					table.getProber(probeComparator, pairComparator)___				Tuple2<Long, String> reuse = new Tuple2<>()___				for (long i = 0_ i < numElements_ i++) {_					assertNotNull(proper.getMatchFor(i, reuse))__					assertNull(proper.getMatchFor(i + numElements, reuse))__				}_			}__			table.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,validates,that,records,are,not,lost,via,insert,or,replace,as,in,bug,flink,2361,this,has,to,be,duplicated,in,in,place,mutable,hash,table,test,and,compacting,hash,table,test,because,of,the,different,constructor,calls;test,public,void,test,hash,table,growth,with,insert,or,replace,try,final,int,num,elements,1000000,list,memory,segment,memory,get,memory,1000,32,1024,in,place,mutable,hash,table,tuple2,long,string,table,new,in,place,mutable,hash,table,tuple2,long,string,serializer,comparator,memory,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,string,value,of,i,bit,set,bit,set,new,bit,set,num,elements,mutable,object,iterator,tuple2,long,string,iter,table,get,entry,iterator,tuple2,long,string,next,while,next,iter,next,null,assert,not,null,next,f0,assert,not,null,next,f1,assert,equals,next,f0,long,value,long,parse,long,next,f1,bit,set,set,next,f0,int,value,assert,equals,num,elements,bit,set,cardinality,in,place,mutable,hash,table,tuple2,long,string,hash,table,prober,long,proper,table,get,prober,probe,comparator,pair,comparator,tuple2,long,string,reuse,new,tuple2,for,long,i,0,i,num,elements,i,assert,not,null,proper,get,match,for,i,reuse,assert,null,proper,get,match,for,i,num,elements,reuse,table,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
InPlaceMutableHashTableTest -> @Test 	public void testHashTableGrowthWithInsertOrReplace();1502726910;This test validates that records are not lost via "insertOrReplace()" as in bug [FLINK-2361]__This has to be duplicated in InPlaceMutableHashTableTest and CompactingHashTableTest_because of the different constructor calls.;@Test_	public void testHashTableGrowthWithInsertOrReplace() {_		try {_			final int numElements = 1000000___			List<MemorySegment> memory = getMemory(1000, 32 * 1024)___			InPlaceMutableHashTable<Tuple2<Long, String>> table = new InPlaceMutableHashTable<Tuple2<Long, String>>(_				serializer, comparator, memory)__			table.open()___			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, String.valueOf(i)))__			}__			_			{_				BitSet bitSet = new BitSet(numElements)__				MutableObjectIterator<Tuple2<Long, String>> iter = table.getEntryIterator()__				Tuple2<Long, String> next__				while ((next = iter.next()) != null) {_					assertNotNull(next.f0)__					assertNotNull(next.f1)__					assertEquals(next.f0.longValue(), Long.parseLong(next.f1))___					bitSet.set(next.f0.intValue())__				}__				assertEquals(numElements, bitSet.cardinality())__			}__			_			{_				InPlaceMutableHashTable<Tuple2<Long, String>>.HashTableProber<Long> proper =_					table.getProber(probeComparator, pairComparator)___				Tuple2<Long, String> reuse = new Tuple2<>()___				for (long i = 0_ i < numElements_ i++) {_					assertNotNull(proper.getMatchFor(i, reuse))__					assertNull(proper.getMatchFor(i + numElements, reuse))__				}_			}__			table.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,validates,that,records,are,not,lost,via,insert,or,replace,as,in,bug,flink,2361,this,has,to,be,duplicated,in,in,place,mutable,hash,table,test,and,compacting,hash,table,test,because,of,the,different,constructor,calls;test,public,void,test,hash,table,growth,with,insert,or,replace,try,final,int,num,elements,1000000,list,memory,segment,memory,get,memory,1000,32,1024,in,place,mutable,hash,table,tuple2,long,string,table,new,in,place,mutable,hash,table,tuple2,long,string,serializer,comparator,memory,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,string,value,of,i,bit,set,bit,set,new,bit,set,num,elements,mutable,object,iterator,tuple2,long,string,iter,table,get,entry,iterator,tuple2,long,string,next,while,next,iter,next,null,assert,not,null,next,f0,assert,not,null,next,f1,assert,equals,next,f0,long,value,long,parse,long,next,f1,bit,set,set,next,f0,int,value,assert,equals,num,elements,bit,set,cardinality,in,place,mutable,hash,table,tuple2,long,string,hash,table,prober,long,proper,table,get,prober,probe,comparator,pair,comparator,tuple2,long,string,reuse,new,tuple2,for,long,i,0,i,num,elements,i,assert,not,null,proper,get,match,for,i,reuse,assert,null,proper,get,match,for,i,num,elements,reuse,table,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
InPlaceMutableHashTableTest -> @Test 	public void testHashTableGrowthWithInsertOrReplace();1544572562;This test validates that records are not lost via "insertOrReplace()" as in bug [FLINK-2361]__This has to be duplicated in InPlaceMutableHashTableTest and CompactingHashTableTest_because of the different constructor calls.;@Test_	public void testHashTableGrowthWithInsertOrReplace() {_		try {_			final int numElements = 1000000___			List<MemorySegment> memory = getMemory(1000, 32 * 1024)___			InPlaceMutableHashTable<Tuple2<Long, String>> table = new InPlaceMutableHashTable<Tuple2<Long, String>>(_				serializer, comparator, memory)__			table.open()___			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, String.valueOf(i)))__			}__			_			{_				BitSet bitSet = new BitSet(numElements)__				MutableObjectIterator<Tuple2<Long, String>> iter = table.getEntryIterator()__				Tuple2<Long, String> next__				while ((next = iter.next()) != null) {_					assertNotNull(next.f0)__					assertNotNull(next.f1)__					assertEquals(next.f0.longValue(), Long.parseLong(next.f1))___					bitSet.set(next.f0.intValue())__				}__				assertEquals(numElements, bitSet.cardinality())__			}__			_			{_				InPlaceMutableHashTable<Tuple2<Long, String>>.HashTableProber<Long> proper =_					table.getProber(probeComparator, pairComparator)___				Tuple2<Long, String> reuse = new Tuple2<>()___				for (long i = 0_ i < numElements_ i++) {_					assertNotNull(proper.getMatchFor(i, reuse))__					assertNull(proper.getMatchFor(i + numElements, reuse))__				}_			}__			table.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,validates,that,records,are,not,lost,via,insert,or,replace,as,in,bug,flink,2361,this,has,to,be,duplicated,in,in,place,mutable,hash,table,test,and,compacting,hash,table,test,because,of,the,different,constructor,calls;test,public,void,test,hash,table,growth,with,insert,or,replace,try,final,int,num,elements,1000000,list,memory,segment,memory,get,memory,1000,32,1024,in,place,mutable,hash,table,tuple2,long,string,table,new,in,place,mutable,hash,table,tuple2,long,string,serializer,comparator,memory,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,string,value,of,i,bit,set,bit,set,new,bit,set,num,elements,mutable,object,iterator,tuple2,long,string,iter,table,get,entry,iterator,tuple2,long,string,next,while,next,iter,next,null,assert,not,null,next,f0,assert,not,null,next,f1,assert,equals,next,f0,long,value,long,parse,long,next,f1,bit,set,set,next,f0,int,value,assert,equals,num,elements,bit,set,cardinality,in,place,mutable,hash,table,tuple2,long,string,hash,table,prober,long,proper,table,get,prober,probe,comparator,pair,comparator,tuple2,long,string,reuse,new,tuple2,for,long,i,0,i,num,elements,i,assert,not,null,proper,get,match,for,i,reuse,assert,null,proper,get,match,for,i,num,elements,reuse,table,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
InPlaceMutableHashTableTest -> @Test 	public void testLargeRecordsWithManyCompactions();1468441547;The records are larger than one segment. Additionally, there is just barely enough memory,_so lots of compactions will happen.;@Test_	public void testLargeRecordsWithManyCompactions() {_		try {_			final int numElements = 1000___			final String longString1 = getLongString(100000), longString2 = getLongString(110000)__			List<MemorySegment> memory = getMemory(3800, 32 * 1024)___			InPlaceMutableHashTable<Tuple2<Long, String>> table =_				new InPlaceMutableHashTable<>(serializer, comparator, memory)__			table.open()___			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, longString1))__			}__			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, longString2))__			}__			_			InPlaceMutableHashTable<Tuple2<Long, String>>.HashTableProber<Tuple2<Long, String>> prober =_				table.getProber(comparator, new SameTypePairComparator<>(comparator))__			Tuple2<Long, String> reuse = new Tuple2<>()__			for (long i = 0_ i < numElements_ i++) {_				assertNotNull(prober.getMatchFor(Tuple2.of(i, longString2), reuse))__			}__			table.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};the,records,are,larger,than,one,segment,additionally,there,is,just,barely,enough,memory,so,lots,of,compactions,will,happen;test,public,void,test,large,records,with,many,compactions,try,final,int,num,elements,1000,final,string,long,string1,get,long,string,100000,long,string2,get,long,string,110000,list,memory,segment,memory,get,memory,3800,32,1024,in,place,mutable,hash,table,tuple2,long,string,table,new,in,place,mutable,hash,table,serializer,comparator,memory,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,long,string1,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,long,string2,in,place,mutable,hash,table,tuple2,long,string,hash,table,prober,tuple2,long,string,prober,table,get,prober,comparator,new,same,type,pair,comparator,comparator,tuple2,long,string,reuse,new,tuple2,for,long,i,0,i,num,elements,i,assert,not,null,prober,get,match,for,tuple2,of,i,long,string2,reuse,table,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
InPlaceMutableHashTableTest -> @Test 	public void testLargeRecordsWithManyCompactions();1502726910;The records are larger than one segment. Additionally, there is just barely enough memory,_so lots of compactions will happen.;@Test_	public void testLargeRecordsWithManyCompactions() {_		try {_			final int numElements = 1000___			final String longString1 = getLongString(100000), longString2 = getLongString(110000)__			List<MemorySegment> memory = getMemory(3800, 32 * 1024)___			InPlaceMutableHashTable<Tuple2<Long, String>> table =_				new InPlaceMutableHashTable<>(serializer, comparator, memory)__			table.open()___			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, longString1))__			}__			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, longString2))__			}__			_			InPlaceMutableHashTable<Tuple2<Long, String>>.HashTableProber<Tuple2<Long, String>> prober =_				table.getProber(comparator, new SameTypePairComparator<>(comparator))__			Tuple2<Long, String> reuse = new Tuple2<>()__			for (long i = 0_ i < numElements_ i++) {_				assertNotNull(prober.getMatchFor(Tuple2.of(i, longString2), reuse))__			}__			table.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};the,records,are,larger,than,one,segment,additionally,there,is,just,barely,enough,memory,so,lots,of,compactions,will,happen;test,public,void,test,large,records,with,many,compactions,try,final,int,num,elements,1000,final,string,long,string1,get,long,string,100000,long,string2,get,long,string,110000,list,memory,segment,memory,get,memory,3800,32,1024,in,place,mutable,hash,table,tuple2,long,string,table,new,in,place,mutable,hash,table,serializer,comparator,memory,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,long,string1,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,long,string2,in,place,mutable,hash,table,tuple2,long,string,hash,table,prober,tuple2,long,string,prober,table,get,prober,comparator,new,same,type,pair,comparator,comparator,tuple2,long,string,reuse,new,tuple2,for,long,i,0,i,num,elements,i,assert,not,null,prober,get,match,for,tuple2,of,i,long,string2,reuse,table,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
InPlaceMutableHashTableTest -> @Test 	public void testLargeRecordsWithManyCompactions();1544572562;The records are larger than one segment. Additionally, there is just barely enough memory,_so lots of compactions will happen.;@Test_	public void testLargeRecordsWithManyCompactions() {_		try {_			final int numElements = 1000___			final String longString1 = getLongString(100000), longString2 = getLongString(110000)__			List<MemorySegment> memory = getMemory(3800, 32 * 1024)___			InPlaceMutableHashTable<Tuple2<Long, String>> table =_				new InPlaceMutableHashTable<>(serializer, comparator, memory)__			table.open()___			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, longString1))__			}__			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, longString2))__			}__			_			InPlaceMutableHashTable<Tuple2<Long, String>>.HashTableProber<Tuple2<Long, String>> prober =_				table.getProber(comparator, new SameTypePairComparator<>(comparator))__			Tuple2<Long, String> reuse = new Tuple2<>()__			for (long i = 0_ i < numElements_ i++) {_				assertNotNull(prober.getMatchFor(Tuple2.of(i, longString2), reuse))__			}__			table.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};the,records,are,larger,than,one,segment,additionally,there,is,just,barely,enough,memory,so,lots,of,compactions,will,happen;test,public,void,test,large,records,with,many,compactions,try,final,int,num,elements,1000,final,string,long,string1,get,long,string,100000,long,string2,get,long,string,110000,list,memory,segment,memory,get,memory,3800,32,1024,in,place,mutable,hash,table,tuple2,long,string,table,new,in,place,mutable,hash,table,serializer,comparator,memory,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,long,string1,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,long,string2,in,place,mutable,hash,table,tuple2,long,string,hash,table,prober,tuple2,long,string,prober,table,get,prober,comparator,new,same,type,pair,comparator,comparator,tuple2,long,string,reuse,new,tuple2,for,long,i,0,i,num,elements,i,assert,not,null,prober,get,match,for,tuple2,of,i,long,string2,reuse,table,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
InPlaceMutableHashTableTest -> @Test 	public void testHashTableGrowthWithInsert();1468441547;This has to be duplicated in InPlaceMutableHashTableTest and CompactingHashTableTest_because of the different constructor calls.;@Test_	public void testHashTableGrowthWithInsert() {_		try {_			final int numElements = 1000000___			List<MemorySegment> memory = getMemory(10000, 32 * 1024)___			InPlaceMutableHashTable<Tuple2<Long, String>> table = new InPlaceMutableHashTable<Tuple2<Long, String>>(_				serializer, comparator, memory)__			table.open()___			for (long i = 0_ i < numElements_ i++) {_				table.insert(new Tuple2<Long, String>(i, String.valueOf(i)))__			}__			_			{_				BitSet bitSet = new BitSet(numElements)__				MutableObjectIterator<Tuple2<Long, String>> iter = table.getEntryIterator()__				Tuple2<Long, String> next__				while ((next = iter.next()) != null) {_					assertNotNull(next.f0)__					assertNotNull(next.f1)__					assertEquals(next.f0.longValue(), Long.parseLong(next.f1))___					bitSet.set(next.f0.intValue())__				}__				assertEquals(numElements, bitSet.cardinality())__			}__			_			{_				InPlaceMutableHashTable<Tuple2<Long, String>>.HashTableProber<Long> proper =_					table.getProber(probeComparator, pairComparator)___				Tuple2<Long, String> reuse = new Tuple2<>()___				for (long i = 0_ i < numElements_ i++) {_					assertNotNull(proper.getMatchFor(i, reuse))__					assertNull(proper.getMatchFor(i + numElements, reuse))__				}_			}__			table.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,has,to,be,duplicated,in,in,place,mutable,hash,table,test,and,compacting,hash,table,test,because,of,the,different,constructor,calls;test,public,void,test,hash,table,growth,with,insert,try,final,int,num,elements,1000000,list,memory,segment,memory,get,memory,10000,32,1024,in,place,mutable,hash,table,tuple2,long,string,table,new,in,place,mutable,hash,table,tuple2,long,string,serializer,comparator,memory,table,open,for,long,i,0,i,num,elements,i,table,insert,new,tuple2,long,string,i,string,value,of,i,bit,set,bit,set,new,bit,set,num,elements,mutable,object,iterator,tuple2,long,string,iter,table,get,entry,iterator,tuple2,long,string,next,while,next,iter,next,null,assert,not,null,next,f0,assert,not,null,next,f1,assert,equals,next,f0,long,value,long,parse,long,next,f1,bit,set,set,next,f0,int,value,assert,equals,num,elements,bit,set,cardinality,in,place,mutable,hash,table,tuple2,long,string,hash,table,prober,long,proper,table,get,prober,probe,comparator,pair,comparator,tuple2,long,string,reuse,new,tuple2,for,long,i,0,i,num,elements,i,assert,not,null,proper,get,match,for,i,reuse,assert,null,proper,get,match,for,i,num,elements,reuse,table,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
InPlaceMutableHashTableTest -> @Test 	public void testHashTableGrowthWithInsert();1502726910;This has to be duplicated in InPlaceMutableHashTableTest and CompactingHashTableTest_because of the different constructor calls.;@Test_	public void testHashTableGrowthWithInsert() {_		try {_			final int numElements = 1000000___			List<MemorySegment> memory = getMemory(10000, 32 * 1024)___			InPlaceMutableHashTable<Tuple2<Long, String>> table = new InPlaceMutableHashTable<Tuple2<Long, String>>(_				serializer, comparator, memory)__			table.open()___			for (long i = 0_ i < numElements_ i++) {_				table.insert(new Tuple2<Long, String>(i, String.valueOf(i)))__			}__			_			{_				BitSet bitSet = new BitSet(numElements)__				MutableObjectIterator<Tuple2<Long, String>> iter = table.getEntryIterator()__				Tuple2<Long, String> next__				while ((next = iter.next()) != null) {_					assertNotNull(next.f0)__					assertNotNull(next.f1)__					assertEquals(next.f0.longValue(), Long.parseLong(next.f1))___					bitSet.set(next.f0.intValue())__				}__				assertEquals(numElements, bitSet.cardinality())__			}__			_			{_				InPlaceMutableHashTable<Tuple2<Long, String>>.HashTableProber<Long> proper =_					table.getProber(probeComparator, pairComparator)___				Tuple2<Long, String> reuse = new Tuple2<>()___				for (long i = 0_ i < numElements_ i++) {_					assertNotNull(proper.getMatchFor(i, reuse))__					assertNull(proper.getMatchFor(i + numElements, reuse))__				}_			}__			table.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,has,to,be,duplicated,in,in,place,mutable,hash,table,test,and,compacting,hash,table,test,because,of,the,different,constructor,calls;test,public,void,test,hash,table,growth,with,insert,try,final,int,num,elements,1000000,list,memory,segment,memory,get,memory,10000,32,1024,in,place,mutable,hash,table,tuple2,long,string,table,new,in,place,mutable,hash,table,tuple2,long,string,serializer,comparator,memory,table,open,for,long,i,0,i,num,elements,i,table,insert,new,tuple2,long,string,i,string,value,of,i,bit,set,bit,set,new,bit,set,num,elements,mutable,object,iterator,tuple2,long,string,iter,table,get,entry,iterator,tuple2,long,string,next,while,next,iter,next,null,assert,not,null,next,f0,assert,not,null,next,f1,assert,equals,next,f0,long,value,long,parse,long,next,f1,bit,set,set,next,f0,int,value,assert,equals,num,elements,bit,set,cardinality,in,place,mutable,hash,table,tuple2,long,string,hash,table,prober,long,proper,table,get,prober,probe,comparator,pair,comparator,tuple2,long,string,reuse,new,tuple2,for,long,i,0,i,num,elements,i,assert,not,null,proper,get,match,for,i,reuse,assert,null,proper,get,match,for,i,num,elements,reuse,table,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
InPlaceMutableHashTableTest -> @Test 	public void testHashTableGrowthWithInsert();1544572562;This has to be duplicated in InPlaceMutableHashTableTest and CompactingHashTableTest_because of the different constructor calls.;@Test_	public void testHashTableGrowthWithInsert() {_		try {_			final int numElements = 1000000___			List<MemorySegment> memory = getMemory(10000, 32 * 1024)___			InPlaceMutableHashTable<Tuple2<Long, String>> table = new InPlaceMutableHashTable<Tuple2<Long, String>>(_				serializer, comparator, memory)__			table.open()___			for (long i = 0_ i < numElements_ i++) {_				table.insert(new Tuple2<Long, String>(i, String.valueOf(i)))__			}__			_			{_				BitSet bitSet = new BitSet(numElements)__				MutableObjectIterator<Tuple2<Long, String>> iter = table.getEntryIterator()__				Tuple2<Long, String> next__				while ((next = iter.next()) != null) {_					assertNotNull(next.f0)__					assertNotNull(next.f1)__					assertEquals(next.f0.longValue(), Long.parseLong(next.f1))___					bitSet.set(next.f0.intValue())__				}__				assertEquals(numElements, bitSet.cardinality())__			}__			_			{_				InPlaceMutableHashTable<Tuple2<Long, String>>.HashTableProber<Long> proper =_					table.getProber(probeComparator, pairComparator)___				Tuple2<Long, String> reuse = new Tuple2<>()___				for (long i = 0_ i < numElements_ i++) {_					assertNotNull(proper.getMatchFor(i, reuse))__					assertNull(proper.getMatchFor(i + numElements, reuse))__				}_			}__			table.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,has,to,be,duplicated,in,in,place,mutable,hash,table,test,and,compacting,hash,table,test,because,of,the,different,constructor,calls;test,public,void,test,hash,table,growth,with,insert,try,final,int,num,elements,1000000,list,memory,segment,memory,get,memory,10000,32,1024,in,place,mutable,hash,table,tuple2,long,string,table,new,in,place,mutable,hash,table,tuple2,long,string,serializer,comparator,memory,table,open,for,long,i,0,i,num,elements,i,table,insert,new,tuple2,long,string,i,string,value,of,i,bit,set,bit,set,new,bit,set,num,elements,mutable,object,iterator,tuple2,long,string,iter,table,get,entry,iterator,tuple2,long,string,next,while,next,iter,next,null,assert,not,null,next,f0,assert,not,null,next,f1,assert,equals,next,f0,long,value,long,parse,long,next,f1,bit,set,set,next,f0,int,value,assert,equals,num,elements,bit,set,cardinality,in,place,mutable,hash,table,tuple2,long,string,hash,table,prober,long,proper,table,get,prober,probe,comparator,pair,comparator,tuple2,long,string,reuse,new,tuple2,for,long,i,0,i,num,elements,i,assert,not,null,proper,get,match,for,i,reuse,assert,null,proper,get,match,for,i,num,elements,reuse,table,close,catch,exception,e,e,print,stack,trace,fail,e,get,message
