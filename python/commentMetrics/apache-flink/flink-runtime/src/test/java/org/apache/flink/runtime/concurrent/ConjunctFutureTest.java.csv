commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@Parameterized.Parameters public static Collection<FutureFactory> parameters() {     return Arrays.asList(new ConjunctFutureFactory(), new WaitingFutureFactory()). }
false;public;0;15;;@Test public void testConjunctFutureFailsOnEmptyAndNull() throws Exception {     try {         futureFactory.createFuture(null).         fail().     } catch (NullPointerException ignored) {     }     try {         futureFactory.createFuture(Arrays.asList(new CompletableFuture<>(), null, new CompletableFuture<>())).         fail().     } catch (NullPointerException ignored) {     } }
false;public;0;44;;@Test public void testConjunctFutureCompletion() throws Exception {     // some futures that we combine     java.util.concurrent.CompletableFuture<Object> future1 = new java.util.concurrent.CompletableFuture<>().     java.util.concurrent.CompletableFuture<Object> future2 = new java.util.concurrent.CompletableFuture<>().     java.util.concurrent.CompletableFuture<Object> future3 = new java.util.concurrent.CompletableFuture<>().     java.util.concurrent.CompletableFuture<Object> future4 = new java.util.concurrent.CompletableFuture<>().     // some future is initially completed     future2.complete(new Object()).     // build the conjunct future     ConjunctFuture<?> result = futureFactory.createFuture(Arrays.asList(future1, future2, future3, future4)).     CompletableFuture<?> resultMapped = result.thenAccept(value -> {     }).     assertEquals(4, result.getNumFuturesTotal()).     assertEquals(1, result.getNumFuturesCompleted()).     assertFalse(result.isDone()).     assertFalse(resultMapped.isDone()).     // complete two more futures     future4.complete(new Object()).     assertEquals(2, result.getNumFuturesCompleted()).     assertFalse(result.isDone()).     assertFalse(resultMapped.isDone()).     future1.complete(new Object()).     assertEquals(3, result.getNumFuturesCompleted()).     assertFalse(result.isDone()).     assertFalse(resultMapped.isDone()).     // complete one future again     future1.complete(new Object()).     assertEquals(3, result.getNumFuturesCompleted()).     assertFalse(result.isDone()).     assertFalse(resultMapped.isDone()).     // complete the final future     future3.complete(new Object()).     assertEquals(4, result.getNumFuturesCompleted()).     assertTrue(result.isDone()).     assertTrue(resultMapped.isDone()). }
false;public;0;38;;@Test public void testConjunctFutureFailureOnFirst() throws Exception {     java.util.concurrent.CompletableFuture<Object> future1 = new java.util.concurrent.CompletableFuture<>().     java.util.concurrent.CompletableFuture<Object> future2 = new java.util.concurrent.CompletableFuture<>().     java.util.concurrent.CompletableFuture<Object> future3 = new java.util.concurrent.CompletableFuture<>().     java.util.concurrent.CompletableFuture<Object> future4 = new java.util.concurrent.CompletableFuture<>().     // build the conjunct future     ConjunctFuture<?> result = futureFactory.createFuture(Arrays.asList(future1, future2, future3, future4)).     CompletableFuture<?> resultMapped = result.thenAccept(value -> {     }).     assertEquals(4, result.getNumFuturesTotal()).     assertEquals(0, result.getNumFuturesCompleted()).     assertFalse(result.isDone()).     assertFalse(resultMapped.isDone()).     future2.completeExceptionally(new IOException()).     assertEquals(0, result.getNumFuturesCompleted()).     assertTrue(result.isDone()).     assertTrue(resultMapped.isDone()).     try {         result.get().         fail().     } catch (ExecutionException e) {         assertTrue(e.getCause() instanceof IOException).     }     try {         resultMapped.get().         fail().     } catch (ExecutionException e) {         assertTrue(e.getCause() instanceof IOException).     } }
false;public;0;38;;@Test public void testConjunctFutureFailureOnSuccessive() throws Exception {     java.util.concurrent.CompletableFuture<Object> future1 = new java.util.concurrent.CompletableFuture<>().     java.util.concurrent.CompletableFuture<Object> future2 = new java.util.concurrent.CompletableFuture<>().     java.util.concurrent.CompletableFuture<Object> future3 = new java.util.concurrent.CompletableFuture<>().     java.util.concurrent.CompletableFuture<Object> future4 = new java.util.concurrent.CompletableFuture<>().     // build the conjunct future     ConjunctFuture<?> result = futureFactory.createFuture(Arrays.asList(future1, future2, future3, future4)).     assertEquals(4, result.getNumFuturesTotal()).     java.util.concurrent.CompletableFuture<?> resultMapped = result.thenAccept(value -> {     }).     future1.complete(new Object()).     future3.complete(new Object()).     future4.complete(new Object()).     future2.completeExceptionally(new IOException()).     assertEquals(3, result.getNumFuturesCompleted()).     assertTrue(result.isDone()).     assertTrue(resultMapped.isDone()).     try {         result.get().         fail().     } catch (ExecutionException e) {         assertTrue(e.getCause() instanceof IOException).     }     try {         resultMapped.get().         fail().     } catch (ExecutionException e) {         assertTrue(e.getCause() instanceof IOException).     } }
true;public;0;16;/**  * Tests that the conjunct future returns upon completion the collection of all future values.  */ ;/**  * Tests that the conjunct future returns upon completion the collection of all future values.  */ @Test public void testConjunctFutureValue() throws ExecutionException, InterruptedException {     java.util.concurrent.CompletableFuture<Integer> future1 = java.util.concurrent.CompletableFuture.completedFuture(1).     java.util.concurrent.CompletableFuture<Long> future2 = java.util.concurrent.CompletableFuture.completedFuture(2L).     java.util.concurrent.CompletableFuture<Double> future3 = new java.util.concurrent.CompletableFuture<>().     ConjunctFuture<Collection<Number>> result = FutureUtils.combineAll(Arrays.asList(future1, future2, future3)).     assertFalse(result.isDone()).     future3.complete(.1).     assertTrue(result.isDone()).     assertThat(result.get(), IsIterableContainingInAnyOrder.<Number>containsInAnyOrder(1, 2L, .1)). }
false;public;0;8;;@Test public void testConjunctOfNone() throws Exception {     final ConjunctFuture<?> result = futureFactory.createFuture(Collections.<java.util.concurrent.CompletableFuture<Object>>emptyList()).     assertEquals(0, result.getNumFuturesTotal()).     assertEquals(0, result.getNumFuturesCompleted()).     assertTrue(result.isDone()). }
false;;1;1;;ConjunctFuture<?> createFuture(Collection<? extends java.util.concurrent.CompletableFuture<?>> futures).
false;public;1;4;;@Override public ConjunctFuture<?> createFuture(Collection<? extends java.util.concurrent.CompletableFuture<?>> futures) {     return FutureUtils.combineAll(futures). }
false;public;1;4;;@Override public ConjunctFuture<?> createFuture(Collection<? extends java.util.concurrent.CompletableFuture<?>> futures) {     return FutureUtils.waitForAll(futures). }
