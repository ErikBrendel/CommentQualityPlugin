commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;3;;public static MockEnvironmentBuilder builder() {     return new MockEnvironmentBuilder(). }
false;public;1;12;;public IteratorWrappingTestSingleInputGate<Record> addInput(MutableObjectIterator<Record> inputIterator) {     try {         final IteratorWrappingTestSingleInputGate<Record> reader = new IteratorWrappingTestSingleInputGate<Record>(bufferSize, Record.class, inputIterator).         inputs.add(reader.getInputGate()).         return reader.     } catch (Throwable t) {         throw new RuntimeException("Error setting up mock readers: " + t.getMessage(), t).     } }
false;public;1;9;;public void addOutput(final List<Record> outputList) {     try {         outputs.add(new RecordCollectingResultPartitionWriter(outputList, new TestPooledBufferProvider(Integer.MAX_VALUE))).     } catch (Throwable t) {         t.printStackTrace().         fail(t.getMessage()).     } }
false;public;0;4;;@Override public Configuration getTaskConfiguration() {     return this.taskConfiguration. }
false;public;0;4;;@Override public MemoryManager getMemoryManager() {     return this.memManager. }
false;public;0;4;;@Override public IOManager getIOManager() {     return this.ioManager. }
false;public;0;4;;@Override public ExecutionConfig getExecutionConfig() {     return this.executionConfig. }
false;public;0;4;;@Override public JobID getJobID() {     return this.jobID. }
false;public;0;4;;@Override public Configuration getJobConfiguration() {     return this.jobConfiguration. }
false;public;0;4;;@Override public TaskManagerRuntimeInfo getTaskManagerInfo() {     return this.taskManagerRuntimeInfo. }
false;public;0;4;;@Override public TaskMetricGroup getMetricGroup() {     return taskMetricGroup. }
false;public;0;4;;@Override public InputSplitProvider getInputSplitProvider() {     return this.inputSplitProvider. }
false;public;0;4;;@Override public TaskInfo getTaskInfo() {     return taskInfo. }
false;public;0;4;;@Override public ClassLoader getUserClassLoader() {     return userCodeClassLoader. }
false;public;0;4;;@Override public Map<String, Future<Path>> getDistributedCacheEntries() {     return Collections.emptyMap(). }
false;public;1;4;;@Override public ResultPartitionWriter getWriter(int index) {     return outputs.get(index). }
false;public;0;4;;@Override public ResultPartitionWriter[] getAllWriters() {     return outputs.toArray(new ResultPartitionWriter[outputs.size()]). }
false;public;1;4;;@Override public InputGate getInputGate(int index) {     return inputs.get(index). }
false;public;0;6;;@Override public InputGate[] getAllInputGates() {     InputGate[] gates = new InputGate[inputs.size()].     inputs.toArray(gates).     return gates. }
false;public;0;4;;@Override public TaskEventDispatcher getTaskEventDispatcher() {     return taskEventDispatcher. }
false;public;0;4;;@Override public JobVertexID getJobVertexId() {     return jobVertexID. }
false;public;0;4;;@Override public ExecutionAttemptID getExecutionId() {     return new ExecutionAttemptID(0L, 0L). }
false;public;0;4;;@Override public BroadcastVariableManager getBroadcastVariableManager() {     return this.bcVarManager. }
false;public;0;4;;@Override public TaskStateManager getTaskStateManager() {     return taskStateManager. }
false;public;0;4;;@Override public GlobalAggregateManager getGlobalAggregateManager() {     return aggregateManager. }
false;public;0;4;;@Override public AccumulatorRegistry getAccumulatorRegistry() {     return this.accumulatorRegistry. }
false;public;0;4;;@Override public TaskKvStateRegistry getTaskKvStateRegistry() {     return kvStateRegistry. }
false;public;2;4;;@Override public void acknowledgeCheckpoint(long checkpointId, CheckpointMetrics checkpointMetrics) {     throw new UnsupportedOperationException(). }
false;public;3;4;;@Override public void acknowledgeCheckpoint(long checkpointId, CheckpointMetrics checkpointMetrics, TaskStateSnapshot subtaskState) {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public void declineCheckpoint(long checkpointId, Throwable cause) {     throw new UnsupportedOperationException(). }
false;public;1;9;;@Override public void failExternally(Throwable cause) {     if (!expectedExternalFailureCause.isPresent()) {         throw new UnsupportedOperationException("MockEnvironment does not support external task failure.").     }     checkArgument(expectedExternalFailureCause.get().isInstance(checkNotNull(cause))).     checkState(!actualExternalFailureCause.isPresent()).     actualExternalFailureCause = Optional.of(cause). }
false;public;0;12;;@Override public void close() {     // close() method should be idempotent and calling memManager.verifyEmpty() will throw after it was shutdown.     if (!memManager.isShutdown()) {         checkState(memManager.verifyEmpty(), "Memory Manager managed memory was not completely freed.").     }     memManager.shutdown().     ioManager.shutdown().     checkState(ioManager.isProperlyShutDown(), "IO Manager has not properly shut down."). }
false;public;1;3;;public void setExpectedExternalFailureCause(Class<Throwable> expectedThrowableClass) {     this.expectedExternalFailureCause = Optional.of(expectedThrowableClass). }
false;public;0;3;;public Optional<Throwable> getActualExternalFailureCause() {     return actualExternalFailureCause. }
