commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@AfterClass public static void shutdown() {     ioManager.shutdown(). }
false;public;0;20;;@Before public void setUpWriterAndReader() {     final FileIOChannel.ID channel = ioManager.createChannel().     try {         writer = ioManager.createBufferFileWriter(channel).         reader = ioManager.createBufferFileReader(channel, new QueuingCallback<>(returnedBuffers)).     } catch (IOException e) {         if (writer != null) {             writer.deleteChannel().         }         if (reader != null) {             reader.deleteChannel().         }         fail("Failed to setup writer and reader.").     } }
false;public;0;12;;@After public void tearDownWriterAndReader() {     if (writer != null) {         writer.deleteChannel().     }     if (reader != null) {         reader.deleteChannel().     }     returnedBuffers.clear(). }
false;public;0;41;;@Test public void testWriteRead() throws IOException {     int numBuffers = 1024.     int currentNumber = 0.     final int minBufferSize = BUFFER_SIZE / 4.     // Write buffers filled with ascending numbers...     for (int i = 0. i < numBuffers. i++) {         final Buffer buffer = createBuffer().         int size = getNextMultipleOf(getRandomNumberInRange(minBufferSize, BUFFER_SIZE), 4).         currentNumber = fillBufferWithAscendingNumbers(buffer, currentNumber, size).         writer.writeBlock(buffer).     }     // Make sure that the writes are finished     writer.close().     // Read buffers back in...     for (int i = 0. i < numBuffers. i++) {         assertFalse(reader.hasReachedEndOfFile()).         reader.readInto(createBuffer()).     }     reader.close().     assertTrue(reader.hasReachedEndOfFile()).     // Verify that the content is the same     assertEquals("Read less buffers than written.", numBuffers, returnedBuffers.size()).     currentNumber = 0.     Buffer buffer.     while ((buffer = returnedBuffers.poll()) != null) {         currentNumber = verifyBufferFilledWithAscendingNumbers(buffer, currentNumber).     } }
false;public;0;45;;@Test public void testWriteSkipRead() throws IOException {     int numBuffers = 1024.     int currentNumber = 0.     // Write buffers filled with ascending numbers...     for (int i = 0. i < numBuffers. i++) {         final Buffer buffer = createBuffer().         currentNumber = fillBufferWithAscendingNumbers(buffer, currentNumber, buffer.getMaxCapacity()).         writer.writeBlock(buffer).     }     // Make sure that the writes are finished     writer.close().     final int toSkip = 32.     // Skip first buffers...     reader.seekToPosition((8 + BUFFER_SIZE) * toSkip).     numBuffers -= toSkip.     // Read buffers back in...     for (int i = 0. i < numBuffers. i++) {         assertFalse(reader.hasReachedEndOfFile()).         reader.readInto(createBuffer()).     }     reader.close().     assertTrue(reader.hasReachedEndOfFile()).     // Verify that the content is the same     assertEquals("Read less buffers than written.", numBuffers, returnedBuffers.size()).     // Start number after skipped buffers...     currentNumber = (BUFFER_SIZE / 4) * toSkip.     Buffer buffer.     while ((buffer = returnedBuffers.poll()) != null) {         currentNumber = verifyBufferFilledWithAscendingNumbers(buffer, currentNumber).     } }
false;private;2;3;;// ------------------------------------------------------------------------ private int getRandomNumberInRange(int min, int max) {     return random.nextInt((max - min) + 1) + min. }
false;private;2;9;;private int getNextMultipleOf(int number, int multiple) {     final int mod = number % multiple.     if (mod == 0) {         return number.     }     return number + multiple - mod. }
false;private;0;3;;private Buffer createBuffer() {     return new NetworkBuffer(MemorySegmentFactory.allocateUnpooledSegment(BUFFER_SIZE), BUFFER_RECYCLER). }
false;static;3;12;;static int fillBufferWithAscendingNumbers(Buffer buffer, int currentNumber, int size) {     checkArgument(size % 4 == 0).     MemorySegment segment = buffer.getMemorySegment().     for (int i = 0. i < size. i += 4) {         segment.putInt(i, currentNumber++).     }     buffer.setSize(size).     return currentNumber. }
false;static;2;13;;static int verifyBufferFilledWithAscendingNumbers(Buffer buffer, int currentNumber) {     MemorySegment segment = buffer.getMemorySegment().     int size = buffer.getSize().     for (int i = 0. i < size. i += 4) {         if (segment.getInt(i) != currentNumber++) {             throw new IllegalStateException("Read unexpected number from buffer.").         }     }     return currentNumber. }
