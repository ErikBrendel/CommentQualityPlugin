commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@AfterClass public static void shutdown() {     ioManager.shutdown(). }
false;public;0;4;;@Before public void setUp() throws IOException {     writer = new AsynchronousBufferFileWriter(ioManager.createChannel(), new RequestQueue<WriteRequest>()). }
false;public;0;8;;@Test public void testAddAndHandleRequest() throws Exception {     addRequest().     assertEquals("Didn't increment number of outstanding requests.", 1, writer.getNumberOfOutstandingRequests()).     handleRequest().     assertEquals("Didn't decrement number of outstanding requests.", 0, writer.getNumberOfOutstandingRequests()). }
false;public;0;20;;@Test public void testAddWithFailingWriter() throws Exception {     AsynchronousBufferFileWriter writer = new AsynchronousBufferFileWriter(ioManager.createChannel(), new RequestQueue<>()).     writer.close().     exception.expect(IOException.class).     Buffer buffer = new NetworkBuffer(MemorySegmentFactory.allocateUnpooledSegment(4096), FreeingBufferRecycler.INSTANCE).     try {         writer.writeBlock(buffer).     } finally {         if (!buffer.isRecycled()) {             buffer.recycleBuffer().             Assert.fail("buffer not recycled").         }         assertEquals("Shouln't increment number of outstanding requests.", 0, writer.getNumberOfOutstandingRequests()).     } }
false;public;0;16;;@Test public void testSubscribe() throws Exception {     final TestNotificationListener listener = new TestNotificationListener().     // Unsuccessful subscription, because no outstanding requests     assertFalse("Allowed to subscribe w/o any outstanding requests.", writer.registerAllRequestsProcessedListener(listener)).     // Successful subscription     addRequest().     assertTrue("Didn't allow to subscribe.", writer.registerAllRequestsProcessedListener(listener)).     // Test notification     handleRequest().     assertEquals("Listener was not notified.", 1, listener.getNumberOfNotifications()). }
false;public;0;12;;@Override public void run() {     try {         writer.close().     } catch (Throwable t) {         error.set(t).     } finally {         sync.countDown().     } }
false;public;0;37;;@Test public void testSubscribeAndClose() throws IOException, InterruptedException {     final TestNotificationListener listener = new TestNotificationListener().     final AtomicReference<Throwable> error = new AtomicReference<Throwable>().     final CountDownLatch sync = new CountDownLatch(1).     addRequest().     addRequest().     writer.registerAllRequestsProcessedListener(listener).     final Thread asyncCloseThread = new Thread(new Runnable() {          @Override         public void run() {             try {                 writer.close().             } catch (Throwable t) {                 error.set(t).             } finally {                 sync.countDown().             }         }     }).     asyncCloseThread.start().     handleRequest().     handleRequest().     sync.await().     assertEquals("Listener was not notified.", 1, listener.getNumberOfNotifications()). }
false;public;0;4;;@Override public Boolean call() throws Exception {     return writer.registerAllRequestsProcessedListener(listener). }
false;public;0;5;;@Override public Void call() throws Exception {     handleRequest().     return null. }
false;public;0;51;;@Test public void testConcurrentSubscribeAndHandleRequest() throws Exception {     final ExecutorService executor = Executors.newFixedThreadPool(2).     final TestNotificationListener listener = new TestNotificationListener().     final Callable<Boolean> subscriber = new Callable<Boolean>() {          @Override         public Boolean call() throws Exception {             return writer.registerAllRequestsProcessedListener(listener).         }     }.     final Callable<Void> requestHandler = new Callable<Void>() {          @Override         public Void call() throws Exception {             handleRequest().             return null.         }     }.     try {         // Repeat this to provoke races         for (int i = 0. i < 50000. i++) {             listener.reset().             addRequest().             Future<Void> handleRequestFuture = executor.submit(requestHandler).             Future<Boolean> subscribeFuture = executor.submit(subscriber).             handleRequestFuture.get().             try {                 if (subscribeFuture.get()) {                     assertEquals("Race: Successfully subscribed, but was never notified.", 1, listener.getNumberOfNotifications()).                 } else {                     assertEquals("Race: Never subscribed successfully, but was notified.", 0, listener.getNumberOfNotifications()).                 }             } catch (Throwable t) {                 System.out.println(i).                 Assert.fail(t.getMessage()).             }         }     } finally {         executor.shutdownNow().     } }
false;private;0;3;;// ------------------------------------------------------------------------ private void addRequest() throws IOException {     writer.writeBlock(mockBuffer). }
false;private;0;3;;private void handleRequest() {     writer.handleProcessedBuffer(mockBuffer, null). }
