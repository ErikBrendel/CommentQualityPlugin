commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;0;1;;protected abstract CheckpointIDCounter createCompletedCheckpoints() throws Exception.
false;protected;0;4;;@Override protected CheckpointIDCounter createCompletedCheckpoints() throws Exception {     return new StandaloneCheckpointIDCounter(). }
false;public,static;0;4;;@AfterClass public static void tearDown() throws Exception {     ZooKeeper.shutdown(). }
false;public;0;4;;@Before public void cleanUp() throws Exception {     ZooKeeper.deleteAll(). }
true;public;0;11;/**  * Tests that counter node is removed from ZooKeeper after shutdown.  */ ;/**  * Tests that counter node is removed from ZooKeeper after shutdown.  */ @Test public void testShutdownRemovesState() throws Exception {     CheckpointIDCounter counter = createCompletedCheckpoints().     counter.start().     CuratorFramework client = ZooKeeper.getClient().     assertNotNull(client.checkExists().forPath("/checkpoint-id-counter")).     counter.shutdown(JobStatus.FINISHED).     assertNull(client.checkExists().forPath("/checkpoint-id-counter")). }
true;public;0;11;/**  * Tests that counter node is NOT removed from ZooKeeper after suspend.  */ ;/**  * Tests that counter node is NOT removed from ZooKeeper after suspend.  */ @Test public void testSuspendKeepsState() throws Exception {     CheckpointIDCounter counter = createCompletedCheckpoints().     counter.start().     CuratorFramework client = ZooKeeper.getClient().     assertNotNull(client.checkExists().forPath("/checkpoint-id-counter")).     counter.shutdown(JobStatus.SUSPENDED).     assertNotNull(client.checkExists().forPath("/checkpoint-id-counter")). }
false;protected;0;5;;@Override protected CheckpointIDCounter createCompletedCheckpoints() throws Exception {     return new ZooKeeperCheckpointIDCounter(ZooKeeper.getClient(), "/checkpoint-id-counter"). }
true;public;0;16;/**  * Tests serial increment and get calls.  */ ;// --------------------------------------------------------------------------------------------- /**  * Tests serial increment and get calls.  */ @Test public void testSerialIncrementAndGet() throws Exception {     final CheckpointIDCounter counter = createCompletedCheckpoints().     try {         counter.start().         assertEquals(1, counter.getAndIncrement()).         assertEquals(2, counter.getAndIncrement()).         assertEquals(3, counter.getAndIncrement()).         assertEquals(4, counter.getAndIncrement()).     } finally {         counter.shutdown(JobStatus.FINISHED).     } }
true;public;0;58;/**  * Tests concurrent increment and get calls from multiple Threads and verifies that the numbers  * counts strictly increasing.  */ ;/**  * Tests concurrent increment and get calls from multiple Threads and verifies that the numbers  * counts strictly increasing.  */ @Test public void testConcurrentGetAndIncrement() throws Exception {     // Config     final int numThreads = 8.     // Setup     final CountDownLatch startLatch = new CountDownLatch(1).     final CheckpointIDCounter counter = createCompletedCheckpoints().     counter.start().     ExecutorService executor = null.     try {         executor = Executors.newFixedThreadPool(numThreads).         List<Future<List<Long>>> resultFutures = new ArrayList<>(numThreads).         for (int i = 0. i < numThreads. i++) {             resultFutures.add(executor.submit(new Incrementer(startLatch, counter))).         }         // Kick off the incrementing         startLatch.countDown().         final int expectedTotal = numThreads * Incrementer.NumIncrements.         List<Long> all = new ArrayList<>(expectedTotal).         // Get the counts         for (Future<List<Long>> result : resultFutures) {             List<Long> counts = result.get().             for (long val : counts) {                 all.add(val).             }         }         // Verify         Collections.sort(all).         assertEquals(expectedTotal, all.size()).         long current = 0.         for (long val : all) {             // Incrementing counts             assertEquals(++current, val).         }         // The final count         assertEquals(expectedTotal + 1, counter.getAndIncrement()).     } finally {         if (executor != null) {             executor.shutdown().         }         counter.shutdown(JobStatus.FINISHED).     } }
true;public;0;12;/**  * Tests a simple {@link CheckpointIDCounter#setCount(long)} operation.  */ ;/**  * Tests a simple {@link CheckpointIDCounter#setCount(long)} operation.  */ @Test public void testSetCount() throws Exception {     final CheckpointIDCounter counter = createCompletedCheckpoints().     counter.start().     // Test setCount     counter.setCount(1337).     assertEquals(1337, counter.getAndIncrement()).     assertEquals(1338, counter.getAndIncrement()).     counter.shutdown(JobStatus.FINISHED). }
false;public;0;17;;@Override public List<Long> call() throws Exception {     final Random rand = new Random().     final List<Long> counts = new ArrayList<>().     // Wait for the main thread to kick off execution     this.startLatch.await().     for (int i = 0. i < NumIncrements. i++) {         counts.add(counter.getAndIncrement()).         // To get some "random" interleaving .)         Thread.sleep(rand.nextInt(20)).     }     return counts. }
