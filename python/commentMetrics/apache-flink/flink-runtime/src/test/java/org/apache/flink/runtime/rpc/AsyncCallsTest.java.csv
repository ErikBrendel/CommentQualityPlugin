commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;9;;@AfterClass public static void shutdown() throws InterruptedException, ExecutionException, TimeoutException {     final CompletableFuture<Void> rpcTerminationFuture = akkaRpcService.stopService().     final CompletableFuture<Terminated> actorSystemTerminationFuture = FutureUtils.toJava(actorSystem.terminate()).     FutureUtils.waitForAll(Arrays.asList(rpcTerminationFuture, actorSystemTerminationFuture)).get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS). }
false;public;0;4;;// ------------------------------------------------------------------------ // tests // ------------------------------------------------------------------------ @Test public void testScheduleWithNoDelay() throws Exception {     runScheduleWithNoDelayTest(TestEndpoint::new). }
false;public;0;4;;@Test public void testFencedScheduleWithNoDelay() throws Exception {     runScheduleWithNoDelayTest(FencedTestEndpoint::new). }
false;private;1;49;;private void runScheduleWithNoDelayTest(RpcEndpointFactory factory) throws Exception {     // to collect all the thread references     final ReentrantLock lock = new ReentrantLock().     final AtomicBoolean concurrentAccess = new AtomicBoolean(false).     RpcEndpoint rpcEndpoint = factory.create(akkaRpcService, lock, concurrentAccess).     rpcEndpoint.start().     try {         TestGateway gateway = rpcEndpoint.getSelfGateway(TestGateway.class).         // a bunch of gateway calls         gateway.someCall().         gateway.anotherCall().         gateway.someCall().         // run something asynchronously         for (int i = 0. i < 10000. i++) {             rpcEndpoint.runAsync(() -> {                 boolean holdsLock = lock.tryLock().                 if (holdsLock) {                     lock.unlock().                 } else {                     concurrentAccess.set(true).                 }             }).         }         CompletableFuture<String> result = rpcEndpoint.callAsync(() -> {             boolean holdsLock = lock.tryLock().             if (holdsLock) {                 lock.unlock().             } else {                 concurrentAccess.set(true).             }             return "test".         }, Time.seconds(30L)).         String str = result.get(30, TimeUnit.SECONDS).         assertEquals("test", str).         // validate that no concurrent access happened         assertFalse("Rpc Endpoint had concurrent access", concurrentAccess.get()).     } finally {         RpcUtils.terminateRpcEndpoint(rpcEndpoint, timeout).     } }
false;public;0;4;;@Test public void testScheduleWithDelay() throws Exception {     runScheduleWithDelayTest(TestEndpoint::new). }
false;public;0;4;;@Test public void testFencedScheduleWithDelay() throws Exception {     runScheduleWithDelayTest(FencedTestEndpoint::new). }
false;private;1;45;;private void runScheduleWithDelayTest(RpcEndpointFactory factory) throws Exception {     // to collect all the thread references     final ReentrantLock lock = new ReentrantLock().     final AtomicBoolean concurrentAccess = new AtomicBoolean(false).     final OneShotLatch latch = new OneShotLatch().     final long delay = 10L.     RpcEndpoint rpcEndpoint = factory.create(akkaRpcService, lock, concurrentAccess).     rpcEndpoint.start().     try {         // run something asynchronously         rpcEndpoint.runAsync(() -> {             boolean holdsLock = lock.tryLock().             if (holdsLock) {                 lock.unlock().             } else {                 concurrentAccess.set(true).             }         }).         final long start = System.nanoTime().         rpcEndpoint.scheduleRunAsync(() -> {             boolean holdsLock = lock.tryLock().             if (holdsLock) {                 lock.unlock().             } else {                 concurrentAccess.set(true).             }             latch.trigger().         }, delay, TimeUnit.MILLISECONDS).         latch.await().         final long stop = System.nanoTime().         // validate that no concurrent access happened         assertFalse("Rpc Endpoint had concurrent access", concurrentAccess.get()).         assertTrue("call was not properly delayed", ((stop - start) / 1_000_000) >= delay).     } finally {         RpcUtils.terminateRpcEndpoint(rpcEndpoint, timeout).     } }
false;;3;1;;RpcEndpoint create(RpcService rpcService, ReentrantLock lock, AtomicBoolean concurrentAccess).
true;public;0;21;/**  * Tests that async code is not executed if the fencing token changes.  */ ;/**  * Tests that async code is not executed if the fencing token changes.  */ @Test public void testRunAsyncWithFencing() throws Exception {     final Time shortTimeout = Time.milliseconds(100L).     final UUID newFencingToken = UUID.randomUUID().     final CompletableFuture<UUID> resultFuture = new CompletableFuture<>().     testRunAsync(endpoint -> {         endpoint.runAsync(() -> resultFuture.complete(endpoint.getFencingToken())).         return resultFuture.     }, newFencingToken).     try {         resultFuture.get(shortTimeout.toMilliseconds(), TimeUnit.MILLISECONDS).         fail("The async run operation should not complete since it is filtered out due to the changed fencing token.").     } catch (TimeoutException ignored) {     } }
true;public;0;15;/**  * Tests that code can be executed in the main thread without respecting the fencing token.  */ ;/**  * Tests that code can be executed in the main thread without respecting the fencing token.  */ @Test public void testRunAsyncWithoutFencing() throws Exception {     final CompletableFuture<UUID> resultFuture = new CompletableFuture<>().     final UUID newFencingToken = UUID.randomUUID().     testRunAsync(endpoint -> {         endpoint.runAsyncWithoutFencing(() -> resultFuture.complete(endpoint.getFencingToken())).         return resultFuture.     }, newFencingToken).     assertEquals(newFencingToken, resultFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)). }
true;public;0;16;/**  * Tests that async callables are not executed if the fencing token changes.  */ ;/**  * Tests that async callables are not executed if the fencing token changes.  */ @Test public void testCallAsyncWithFencing() throws Exception {     final UUID newFencingToken = UUID.randomUUID().     CompletableFuture<Boolean> resultFuture = testRunAsync(endpoint -> endpoint.callAsync(() -> true, timeout), newFencingToken).     try {         resultFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS).         fail("The async call operation should fail due to the changed fencing token.").     } catch (ExecutionException e) {         assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException).     } }
true;public;0;10;/**  * Tests that async callables can be executed in the main thread without checking the fencing token.  */ ;/**  * Tests that async callables can be executed in the main thread without checking the fencing token.  */ @Test public void testCallAsyncWithoutFencing() throws Exception {     final UUID newFencingToken = UUID.randomUUID().     CompletableFuture<Boolean> resultFuture = testRunAsync(endpoint -> endpoint.callAsyncWithoutFencing(() -> true, timeout), newFencingToken).     assertTrue(resultFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)). }
false;public;0;11;;@Test public void testUnfencedMainThreadExecutor() throws Exception {     final UUID newFencingToken = UUID.randomUUID().     final boolean value = true.     final CompletableFuture<Boolean> resultFuture = testRunAsync(endpoint -> CompletableFuture.supplyAsync(() -> value, endpoint.getUnfencedMainThreadExecutor()), newFencingToken).     assertThat(resultFuture.get(), is(value)). }
false;private,static;2;33;;private static <T> CompletableFuture<T> testRunAsync(Function<FencedTestEndpoint, CompletableFuture<T>> runAsyncCall, UUID newFencingToken) throws Exception {     final UUID initialFencingToken = UUID.randomUUID().     final OneShotLatch enterSetNewFencingToken = new OneShotLatch().     final OneShotLatch triggerSetNewFencingToken = new OneShotLatch().     final FencedTestEndpoint fencedTestEndpoint = new FencedTestEndpoint(akkaRpcService, initialFencingToken, enterSetNewFencingToken, triggerSetNewFencingToken).     final FencedTestGateway fencedTestGateway = fencedTestEndpoint.getSelfGateway(FencedTestGateway.class).     try {         fencedTestEndpoint.start().         CompletableFuture<Acknowledge> newFencingTokenFuture = fencedTestGateway.setNewFencingToken(newFencingToken, timeout).         assertFalse(newFencingTokenFuture.isDone()).         assertEquals(initialFencingToken, fencedTestEndpoint.getFencingToken()).         CompletableFuture<T> result = runAsyncCall.apply(fencedTestEndpoint).         enterSetNewFencingToken.await().         triggerSetNewFencingToken.trigger().         newFencingTokenFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS).         return result.     } finally {         RpcUtils.terminateRpcEndpoint(fencedTestEndpoint, timeout).     } }
false;;0;1;;void someCall().
false;;0;1;;void anotherCall().
false;public;0;9;;@Override public void someCall() {     boolean holdsLock = lock.tryLock().     if (holdsLock) {         lock.unlock().     } else {         concurrentAccess.set(true).     } }
false;public;0;9;;@Override public void anotherCall() {     boolean holdsLock = lock.tryLock().     if (holdsLock) {         lock.unlock().     } else {         concurrentAccess.set(true).     } }
false;;2;1;;CompletableFuture<Acknowledge> setNewFencingToken(UUID fencingToken, @RpcTimeout Time timeout).
false;public;2;13;;@Override public CompletableFuture<Acknowledge> setNewFencingToken(UUID fencingToken, Time timeout) {     enteringSetNewFencingToken.trigger().     try {         triggerSetNewFencingToken.await().     } catch (InterruptedException e) {         throw new RuntimeException("TriggerSetNewFencingToken OneShotLatch was interrupted.").     }     setFencingToken(fencingToken).     return CompletableFuture.completedFuture(Acknowledge.get()). }
false;public;0;9;;@Override public void someCall() {     boolean holdsLock = lock.tryLock().     if (holdsLock) {         lock.unlock().     } else {         concurrentAccess.set(true).     } }
false;public;0;9;;@Override public void anotherCall() {     boolean holdsLock = lock.tryLock().     if (holdsLock) {         lock.unlock().     } else {         concurrentAccess.set(true).     } }
