commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setupClass() {     rpcService = new TestingRpcService(). }
false;public,static;0;8;;@AfterClass public static void teardownClass() throws Exception {     if (rpcService != null) {         RpcUtils.terminateRpcService(rpcService, TIMEOUT).         rpcService = null.     } }
false;public;0;31;;@Before public void setUp() throws Exception {     final JobVertex testVertex = new JobVertex("testVertex").     testVertex.setInvokableClass(NoOpInvokable.class).     jobGraph = new JobGraph(TEST_JOB_ID, "testJob", testVertex).     jobGraph.setAllowQueuedScheduling(true).     fatalErrorHandler = new TestingFatalErrorHandler().     heartbeatServices = new HeartbeatServices(1000L, 10000L).     submittedJobGraphStore = new FaultySubmittedJobGraphStore().     dispatcherLeaderElectionService = new TestingLeaderElectionService().     jobMasterLeaderElectionService = new TestingLeaderElectionService().     haServices = new TestingHighAvailabilityServices().     haServices.setDispatcherLeaderElectionService(dispatcherLeaderElectionService).     haServices.setSubmittedJobGraphStore(submittedJobGraphStore).     haServices.setJobMasterLeaderElectionService(TEST_JOB_ID, jobMasterLeaderElectionService).     haServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory()).     haServices.setResourceManagerLeaderRetriever(new SettableLeaderRetrievalService()).     runningJobsRegistry = haServices.getRunningJobsRegistry().     configuration = new Configuration().     configuration.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath()).     createdJobManagerRunnerLatch = new CountDownLatch(2).     blobServer = new BlobServer(configuration, new VoidBlobStore()). }
false;private;3;7;;@Nonnull private TestingDispatcher createAndStartDispatcher(HeartbeatServices heartbeatServices, TestingHighAvailabilityServices haServices, JobManagerRunnerFactory jobManagerRunnerFactory) throws Exception {     final TestingDispatcher dispatcher = createDispatcher(heartbeatServices, haServices, jobManagerRunnerFactory).     dispatcher.start().     return dispatcher. }
false;private;3;17;;@Nonnull private TestingDispatcher createDispatcher(HeartbeatServices heartbeatServices, TestingHighAvailabilityServices haServices, JobManagerRunnerFactory jobManagerRunnerFactory) throws Exception {     TestingResourceManagerGateway resourceManagerGateway = new TestingResourceManagerGateway().     return new TestingDispatcher(rpcService, Dispatcher.DISPATCHER_NAME + '_' + name.getMethodName(), configuration, haServices, () -> CompletableFuture.completedFuture(resourceManagerGateway), blobServer, heartbeatServices, UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(), null, new MemoryArchivedExecutionGraphStore(), jobManagerRunnerFactory, fatalErrorHandler). }
false;public;0;18;;@After public void tearDown() throws Exception {     try {         fatalErrorHandler.rethrowError().     } finally {         if (dispatcher != null) {             RpcUtils.terminateRpcEndpoint(dispatcher, TIMEOUT).         }     }     if (haServices != null) {         haServices.closeAndCleanupAllData().     }     if (blobServer != null) {         blobServer.close().     } }
true;public;0;19;/**  * Tests that we can submit a job to the Dispatcher which then spawns a  * new JobManagerRunner.  */ ;/**  * Tests that we can submit a job to the Dispatcher which then spawns a  * new JobManagerRunner.  */ @Test public void testJobSubmission() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     CompletableFuture<UUID> leaderFuture = dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).     // wait for the leader to be elected     leaderFuture.get().     DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     CompletableFuture<Acknowledge> acknowledgeFuture = dispatcherGateway.submitJob(jobGraph, TIMEOUT).     acknowledgeFuture.get().     assertTrue("jobManagerRunner was not started", dispatcherLeaderElectionService.getStartFuture().isDone()). }
true;public;0;16;/**  * Tests that the dispatcher takes part in the leader election.  */ ;/**  * Tests that the dispatcher takes part in the leader election.  */ @Test public void testLeaderElection() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     CompletableFuture<Void> jobIdsFuture = new CompletableFuture<>().     submittedJobGraphStore.setJobIdsFunction((Collection<JobID> jobIds) -> {         jobIdsFuture.complete(null).         return jobIds.     }).     electDispatcher().     // wait that we asked the SubmittedJobGraphStore for the stored jobs     jobIdsFuture.get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS). }
true;public;0;25;/**  * Test callbacks from  * {@link org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore.SubmittedJobGraphListener}.  */ ;/**  * Test callbacks from  * {@link org.apache.flink.runtime.jobmanager.SubmittedJobGraphStore.SubmittedJobGraphListener}.  */ @Test public void testSubmittedJobGraphListener() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     dispatcherGateway.submitJob(jobGraph, TIMEOUT).get().     jobMasterLeaderElectionService.isLeader(UUID.randomUUID()).get().     final SubmittedJobGraph submittedJobGraph = submittedJobGraphStore.recoverJobGraph(TEST_JOB_ID).     // pretend that other Dispatcher has removed job from submittedJobGraphStore     submittedJobGraphStore.removeJobGraph(TEST_JOB_ID).     dispatcher.onRemovedJobGraph(TEST_JOB_ID).     assertThat(dispatcherGateway.listJobs(TIMEOUT).get(), empty()).     // pretend that other Dispatcher has added a job to submittedJobGraphStore     runningJobsRegistry.clearJob(TEST_JOB_ID).     submittedJobGraphStore.putJobGraph(submittedJobGraph).     dispatcher.onAddedJobGraph(TEST_JOB_ID).     createdJobManagerRunnerLatch.await().     assertThat(dispatcherGateway.listJobs(TIMEOUT).get(), hasSize(1)). }
false;public;0;20;;@Test public void testOnAddedJobGraphRecoveryFailure() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     final FlinkException expectedFailure = new FlinkException("Expected failure").     submittedJobGraphStore.setRecoveryFailure(expectedFailure).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     submittedJobGraphStore.putJobGraph(new SubmittedJobGraph(jobGraph)).     dispatcher.onAddedJobGraph(TEST_JOB_ID).     final CompletableFuture<Throwable> errorFuture = fatalErrorHandler.getErrorFuture().     final Throwable throwable = errorFuture.get().     assertThat(ExceptionUtils.findThrowable(throwable, expectedFailure::equals).isPresent(), is(true)).     fatalErrorHandler.clearError(). }
false;public;0;18;;@Test public void testOnAddedJobGraphWithFinishedJob() throws Throwable {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     submittedJobGraphStore.putJobGraph(new SubmittedJobGraph(jobGraph)).     runningJobsRegistry.setJobFinished(TEST_JOB_ID).     dispatcher.onAddedJobGraph(TEST_JOB_ID).     // wait until the recovery is over     dispatcher.getRecoverOperationFuture(TIMEOUT).get().     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     // check that we did not start executing the added JobGraph     assertThat(dispatcherGateway.listJobs(TIMEOUT).get(), is(empty())). }
true;public;0;26;/**  * Test that {@link JobResult} is cached when the job finishes.  */ ;/**  * Test that {@link JobResult} is cached when the job finishes.  */ @Test public void testCacheJobExecutionResult() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     final JobID failedJobId = new JobID().     final JobStatus expectedState = JobStatus.FAILED.     final ArchivedExecutionGraph failedExecutionGraph = new ArchivedExecutionGraphBuilder().setJobID(failedJobId).setState(expectedState).setFailureCause(new ErrorInfo(new RuntimeException("expected"), 1L)).build().     dispatcher.completeJobExecution(failedExecutionGraph).     assertThat(dispatcherGateway.requestJobStatus(failedJobId, TIMEOUT).get(), equalTo(expectedState)).     assertThat(dispatcherGateway.requestJob(failedJobId, TIMEOUT).get(), equalTo(failedExecutionGraph)). }
false;public;0;14;;@Test public void testThrowExceptionIfJobExecutionResultNotFound() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     try {         dispatcherGateway.requestJob(new JobID(), TIMEOUT).get().     } catch (ExecutionException e) {         final Throwable throwable = ExceptionUtils.stripExecutionException(e).         assertThat(throwable, instanceOf(FlinkJobNotFoundException.class)).     } }
true;public;0;34;/**  * Tests that a reelected Dispatcher can recover jobs.  */ ;/**  * Tests that a reelected Dispatcher can recover jobs.  */ @Test public void testJobRecovery() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     // elect the initial dispatcher as the leader     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     // submit the job to the current leader     dispatcherGateway.submitJob(jobGraph, TIMEOUT).get().     // check that the job has been persisted     assertThat(submittedJobGraphStore.getJobIds(), contains(jobGraph.getJobID())).     jobMasterLeaderElectionService.isLeader(UUID.randomUUID()).get().     assertThat(runningJobsRegistry.getJobSchedulingStatus(jobGraph.getJobID()), is(RunningJobsRegistry.JobSchedulingStatus.RUNNING)).     // revoke the leadership which will stop all currently running jobs     dispatcherLeaderElectionService.notLeader().     // re-grant the leadership, this should trigger the job recovery     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     // wait until we have recovered the job     createdJobManagerRunnerLatch.await().     // check whether the job has been recovered     final Collection<JobID> jobIds = dispatcherGateway.listJobs(TIMEOUT).get().     assertThat(jobIds, hasSize(1)).     assertThat(jobIds, contains(jobGraph.getJobID())). }
true;public;0;17;/**  * Tests that we can dispose a savepoint.  */ ;/**  * Tests that we can dispose a savepoint.  */ @Test public void testSavepointDisposal() throws Exception {     final URI externalPointer = createTestingSavepoint().     final Path savepointPath = Paths.get(externalPointer).     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     assertThat(Files.exists(savepointPath), is(true)).     dispatcherGateway.disposeSavepoint(externalPointer.toString(), TIMEOUT).get().     assertThat(Files.exists(savepointPath), is(false)). }
false;private;0;17;;@Nonnull private URI createTestingSavepoint() throws IOException, URISyntaxException {     final StateBackend stateBackend = Checkpoints.loadStateBackend(configuration, Thread.currentThread().getContextClassLoader(), log).     final CheckpointStorage checkpointStorage = stateBackend.createCheckpointStorage(jobGraph.getJobID()).     final File savepointFile = temporaryFolder.newFolder().     final long checkpointId = 1L.     final CheckpointStorageLocation checkpointStorageLocation = checkpointStorage.initializeLocationForSavepoint(checkpointId, savepointFile.getAbsolutePath()).     final CheckpointMetadataOutputStream metadataOutputStream = checkpointStorageLocation.createMetadataOutputStream().     Checkpoints.storeCheckpointMetadata(new SavepointV2(checkpointId, Collections.emptyList(), Collections.emptyList()), metadataOutputStream).     final CompletedCheckpointStorageLocation completedCheckpointStorageLocation = metadataOutputStream.closeAndFinalizeCheckpoint().     return new URI(completedCheckpointStorageLocation.getExternalPointer()). }
true;public;0;25;/**  * Tests that we wait until the JobMaster has gained leader ship before sending requests  * to it. See FLINK-8887.  */ ;/**  * Tests that we wait until the JobMaster has gained leader ship before sending requests  * to it. See FLINK-8887.  */ @Test public void testWaitingForJobMasterLeadership() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     dispatcherGateway.submitJob(jobGraph, TIMEOUT).get().     final CompletableFuture<JobStatus> jobStatusFuture = dispatcherGateway.requestJobStatus(jobGraph.getJobID(), TIMEOUT).     assertThat(jobStatusFuture.isDone(), is(false)).     try {         jobStatusFuture.get(10, TimeUnit.MILLISECONDS).         fail("Should not complete.").     } catch (TimeoutException ignored) {     // ignored     }     jobMasterLeaderElectionService.isLeader(UUID.randomUUID()).get().     assertThat(jobStatusFuture.get(), notNullValue()). }
true;public;0;19;/**  * Tests that the {@link Dispatcher} terminates if it cannot recover jobs ids from  * the {@link SubmittedJobGraphStore}. See FLINK-8943.  */ ;/**  * Tests that the {@link Dispatcher} terminates if it cannot recover jobs ids from  * the {@link SubmittedJobGraphStore}. See FLINK-8943.  */ @Test public void testFatalErrorAfterJobIdRecoveryFailure() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     final FlinkException testException = new FlinkException("Test exception").     submittedJobGraphStore.setJobIdsFunction((Collection<JobID> jobIds) -> {         throw testException.     }).     electDispatcher().     // we expect that a fatal error occurred     final Throwable error = fatalErrorHandler.getErrorFuture().get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).     assertThat(ExceptionUtils.findThrowableWithMessage(error, testException.getMessage()).isPresent(), is(true)).     fatalErrorHandler.clearError(). }
true;public;0;25;/**  * Tests that the {@link Dispatcher} terminates if it cannot recover jobs from  * the {@link SubmittedJobGraphStore}. See FLINK-8943.  */ ;/**  * Tests that the {@link Dispatcher} terminates if it cannot recover jobs from  * the {@link SubmittedJobGraphStore}. See FLINK-8943.  */ @Test public void testFatalErrorAfterJobRecoveryFailure() throws Exception {     final FlinkException testException = new FlinkException("Test exception").     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     dispatcher.waitUntilStarted().     final SubmittedJobGraph submittedJobGraph = new SubmittedJobGraph(jobGraph).     submittedJobGraphStore.putJobGraph(submittedJobGraph).     submittedJobGraphStore.setRecoverJobGraphFunction((JobID jobId, Map<JobID, SubmittedJobGraph> submittedJobs) -> {         throw testException.     }).     electDispatcher().     // we expect that a fatal error occurred     final Throwable error = fatalErrorHandler.getErrorFuture().get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).     assertThat(ExceptionUtils.findThrowableWithMessage(error, testException.getMessage()).isPresent(), is(true)).     fatalErrorHandler.clearError(). }
true;public;0;21;/**  * Tests that the {@link Dispatcher} fails fatally if the job submission of a recovered job fails.  * See FLINK-9097.  */ ;/**  * Tests that the {@link Dispatcher} fails fatally if the job submission of a recovered job fails.  * See FLINK-9097.  */ @Test public void testJobSubmissionErrorAfterJobRecovery() throws Exception {     final FlinkException testException = new FlinkException("Test exception").     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     dispatcher.waitUntilStarted().     final JobGraph failingJobGraph = createFailingJobGraph(testException).     final SubmittedJobGraph submittedJobGraph = new SubmittedJobGraph(failingJobGraph).     submittedJobGraphStore.putJobGraph(submittedJobGraph).     electDispatcher().     final Throwable error = fatalErrorHandler.getErrorFuture().get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).     assertThat(ExceptionUtils.findThrowableWithMessage(error, testException.getMessage()).isPresent(), is(true)).     fatalErrorHandler.clearError(). }
true;public;0;26;/**  * Tests that a blocking {@link JobManagerRunner} creation, e.g. due to blocking FileSystem access,  * does not block the {@link Dispatcher}.  *  * <p>See FLINK-10314  */ ;/**  * Tests that a blocking {@link JobManagerRunner} creation, e.g. due to blocking FileSystem access,  * does not block the {@link Dispatcher}.  *  * <p>See FLINK-10314  */ @Test public void testBlockingJobManagerRunner() throws Exception {     final OneShotLatch jobManagerRunnerCreationLatch = new OneShotLatch().     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new BlockingJobManagerRunnerFactory(jobManagerRunnerCreationLatch::await)).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     final CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(jobGraph, TIMEOUT).     assertThat(submissionFuture.isDone(), is(false)).     final CompletableFuture<Collection<String>> metricQueryServicePathsFuture = dispatcherGateway.requestMetricQueryServicePaths(Time.seconds(5L)).     assertThat(metricQueryServicePathsFuture.get(), is(empty())).     assertThat(submissionFuture.isDone(), is(false)).     jobManagerRunnerCreationLatch.trigger().     submissionFuture.get(). }
true;public;0;40;/**  * Tests that a failing {@link JobManagerRunner} will be properly cleaned up.  */ ;/**  * Tests that a failing {@link JobManagerRunner} will be properly cleaned up.  */ @Test public void testFailingJobManagerRunnerCleanup() throws Exception {     final FlinkException testException = new FlinkException("Test exception.").     final ArrayBlockingQueue<Optional<Exception>> queue = new ArrayBlockingQueue<>(2).     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new BlockingJobManagerRunnerFactory(() -> {         final Optional<Exception> take = queue.take().         final Exception exception = take.orElse(null).         if (exception != null) {             throw exception.         }     })).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(jobGraph, TIMEOUT).     assertThat(submissionFuture.isDone(), is(false)).     queue.offer(Optional.of(testException)).     try {         submissionFuture.get().         fail("Should fail because we could not instantiate the JobManagerRunner.").     } catch (Exception e) {         assertThat(ExceptionUtils.findThrowable(e, t -> t.equals(testException)).isPresent(), is(true)).     }     submissionFuture = dispatcherGateway.submitJob(jobGraph, TIMEOUT).     queue.offer(Optional.empty()).     submissionFuture.get(). }
false;public;0;20;;@Test public void testPersistedJobGraphWhenDispatcherIsShutDown() throws Exception {     final InMemorySubmittedJobGraphStore submittedJobGraphStore = new InMemorySubmittedJobGraphStore().     haServices.setSubmittedJobGraphStore(submittedJobGraphStore).     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, DefaultJobManagerRunnerFactory.INSTANCE).     // grant leadership and submit a single job     final DispatcherId expectedDispatcherId = DispatcherId.generate().     dispatcherLeaderElectionService.isLeader(expectedDispatcherId.toUUID()).get().     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     final CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(jobGraph, TIMEOUT).     submissionFuture.get().     assertThat(dispatcher.getNumberJobs(TIMEOUT).get(), Matchers.is(1)).     dispatcher.close().     assertThat(submittedJobGraphStore.contains(jobGraph.getJobID()), Matchers.is(true)). }
true;public;0;23;/**  * Tests that a submitted job is suspended if the Dispatcher loses leadership.  */ ;/**  * Tests that a submitted job is suspended if the Dispatcher loses leadership.  */ @Test public void testJobSuspensionWhenDispatcherLosesLeadership() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch)).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     dispatcherGateway.submitJob(jobGraph, TIMEOUT).get().     final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), TIMEOUT).     assertThat(jobResultFuture.isDone(), is(false)).     dispatcherLeaderElectionService.notLeader().     try {         jobResultFuture.get().         fail("Expected the job result to throw an exception.").     } catch (ExecutionException ee) {         assertThat(ExceptionUtils.findThrowable(ee, JobNotFinishedException.class).isPresent(), is(true)).     } }
false;public;0;10;;@Test public void testShutDownClusterShouldTerminateDispatcher() throws Exception {     dispatcher = createAndStartDispatcher(heartbeatServices, haServices, DefaultJobManagerRunnerFactory.INSTANCE).     dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().     final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).     dispatcherGateway.shutDownCluster().get().     dispatcher.getTerminationFuture().get(). }
false;public;8;6;;@Override public JobManagerRunner createJobManagerRunner(JobGraph jobGraph, Configuration configuration, RpcService rpcService, HighAvailabilityServices highAvailabilityServices, HeartbeatServices heartbeatServices, JobManagerSharedServices jobManagerSharedServices, JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory, FatalErrorHandler fatalErrorHandler) throws Exception {     jobManagerRunnerCreationLatch.run().     return super.createJobManagerRunner(jobGraph, configuration, rpcService, highAvailabilityServices, heartbeatServices, jobManagerSharedServices, jobManagerJobMetricGroupFactory, fatalErrorHandler). }
false;private;0;7;;private void electDispatcher() {     UUID expectedLeaderSessionId = UUID.randomUUID().     assertNull(dispatcherLeaderElectionService.getConfirmationFuture()).     dispatcherLeaderElectionService.isLeader(expectedLeaderSessionId). }
false;private;1;5;;private JobGraph createFailingJobGraph(Exception failureCause) {     final FailingJobVertex jobVertex = new FailingJobVertex("Failing JobVertex", failureCause).     jobVertex.setInvokableClass(NoOpInvokable.class).     return new JobGraph(jobGraph.getJobID(), "Failing JobGraph", jobVertex). }
false;public;1;4;;@Override public void initializeOnMaster(ClassLoader loader) throws Exception {     throw failure. }
false;public;8;24;;@Override public JobManagerRunner createJobManagerRunner(JobGraph jobGraph, Configuration configuration, RpcService rpcService, HighAvailabilityServices highAvailabilityServices, HeartbeatServices heartbeatServices, JobManagerSharedServices jobManagerSharedServices, JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory, FatalErrorHandler fatalErrorHandler) throws Exception {     assertEquals(expectedJobId, jobGraph.getJobID()).     createdJobManagerRunnerLatch.countDown().     return DefaultJobManagerRunnerFactory.INSTANCE.createJobManagerRunner(jobGraph, configuration, rpcService, highAvailabilityServices, heartbeatServices, jobManagerSharedServices, jobManagerJobMetricGroupFactory, fatalErrorHandler). }
