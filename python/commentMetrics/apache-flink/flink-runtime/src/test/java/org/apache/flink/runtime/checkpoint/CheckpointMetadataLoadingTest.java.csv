commented;modifiers;parameterAmount;loc;comment;code
true;public;0;77;/**  * Tests loading and validation of savepoints with correct setup,  * parallelism mismatch, and a missing task.  */ ;/**  * Tests loading and validation of savepoints with correct setup,  * parallelism mismatch, and a missing task.  */ @Test public void testLoadAndValidateSavepoint() throws Exception {     File tmp = tmpFolder.newFolder().     int parallelism = 128128.     long checkpointId = Integer.MAX_VALUE + 123123L.     JobVertexID jobVertexID = new JobVertexID().     OperatorID operatorID = OperatorID.fromJobVertexID(jobVertexID).     OperatorSubtaskState subtaskState = new OperatorSubtaskState(new OperatorStreamStateHandle(Collections.emptyMap(), new ByteStreamStateHandle("testHandler", new byte[0])), null, null, null).     OperatorState state = new OperatorState(operatorID, parallelism, parallelism).     state.putState(0, subtaskState).     Map<OperatorID, OperatorState> taskStates = new HashMap<>().     taskStates.put(operatorID, state).     JobID jobId = new JobID().     // Store savepoint     final SavepointV2 savepoint = new SavepointV2(checkpointId, taskStates.values(), Collections.emptyList()).     final StreamStateHandle serializedMetadata.     try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {         Checkpoints.storeCheckpointMetadata(savepoint, os).         serializedMetadata = new ByteStreamStateHandle("checkpoint", os.toByteArray()).     }     final CompletedCheckpointStorageLocation storageLocation = new TestCompletedCheckpointStorageLocation(serializedMetadata, "dummy/pointer").     ExecutionJobVertex vertex = mock(ExecutionJobVertex.class).     when(vertex.getParallelism()).thenReturn(parallelism).     when(vertex.getMaxParallelism()).thenReturn(parallelism).     when(vertex.getOperatorIDs()).thenReturn(Collections.singletonList(operatorID)).     Map<JobVertexID, ExecutionJobVertex> tasks = new HashMap<>().     tasks.put(jobVertexID, vertex).     ClassLoader ucl = Thread.currentThread().getContextClassLoader().     // 1) Load and validate: everything correct     CompletedCheckpoint loaded = Checkpoints.loadAndValidateCheckpoint(jobId, tasks, storageLocation, ucl, false).     assertEquals(jobId, loaded.getJobId()).     assertEquals(checkpointId, loaded.getCheckpointID()).     // 2) Load and validate: max parallelism mismatch     when(vertex.getMaxParallelism()).thenReturn(222).     when(vertex.isMaxParallelismConfigured()).thenReturn(true).     try {         Checkpoints.loadAndValidateCheckpoint(jobId, tasks, storageLocation, ucl, false).         fail("Did not throw expected Exception").     } catch (IllegalStateException expected) {         assertTrue(expected.getMessage().contains("Max parallelism mismatch")).     }     // 3) Load and validate: missing vertex     assertNotNull(tasks.remove(jobVertexID)).     try {         Checkpoints.loadAndValidateCheckpoint(jobId, tasks, storageLocation, ucl, false).         fail("Did not throw expected Exception").     } catch (IllegalStateException expected) {         assertTrue(expected.getMessage().contains("allowNonRestoredState")).     }     // 4) Load and validate: ignore missing vertex     Checkpoints.loadAndValidateCheckpoint(jobId, tasks, storageLocation, ucl, true). }
