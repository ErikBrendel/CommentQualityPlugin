commented;modifiers;parameterAmount;loc;comment;code
false;public;1;18;;// -------------------------------------------------------------------------------------------- @Override public int hash(Record object) {     int i = 0.     try {         int code = 0.         for (. i < this.keyFields.length. i++) {             code ^= object.getField(this.keyFields[i], this.transientKeyHolders[i]).hashCode().             // salt code with (i % HASH_SALT.length)-th salt component             code *= HASH_SALT[i & 0x1F].         }         return code.     } catch (NullPointerException npex) {         throw new NullKeyFieldException(this.keyFields[i]).     } catch (IndexOutOfBoundsException iobex) {         throw new KeyFieldOutOfBoundsException(this.keyFields[i]).     } }
false;public;1;8;;@Override public void setReference(Record toCompare) {     for (int i = 0. i < this.keyFields.length. i++) {         if (!toCompare.getFieldInto(this.keyFields[i], this.keyHolders[i])) {             throw new NullKeyFieldException(this.keyFields[i]).         }     } }
false;public;1;12;;@Override public boolean equalToReference(Record candidate) {     for (int i = 0. i < this.keyFields.length. i++) {         final Value k = candidate.getField(this.keyFields[i], this.transientKeyHolders[i]).         if (k == null) {             throw new NullKeyFieldException(this.keyFields[i]).         } else if (!k.equals(this.keyHolders[i])) {             return false.         }     }     return true. }
false;public;1;13;;@Override public int compareToReference(TypeComparator<Record> referencedAccessors) {     final RecordComparator pra = (RecordComparator) referencedAccessors.     for (int i = 0. i < this.keyFields.length. i++) {         @SuppressWarnings("unchecked")         final int comp = ((Comparable) pra.keyHolders[i]).compareTo(this.keyHolders[i]).         if (comp != 0) {             return this.ascending[i] ? comp : -comp.         }     }     return 0. }
false;public;2;19;;@SuppressWarnings({ "rawtypes", "unchecked" }) @Override public int compare(Record first, Record second) {     int i = 0.     try {         for (. i < this.keyFields.length. i++) {             Comparable k1 = (Comparable) first.getField(this.keyFields[i], this.keyHolders[i]).             Comparable k2 = (Comparable) second.getField(this.keyFields[i], this.transientKeyHolders[i]).             int cmp = k1.compareTo(k2).             if (cmp != 0) {                 return cmp.             }         }         return 0.     } catch (NullPointerException e) {         throw new NullKeyFieldException(this.keyFields[i]).     } }
false;public;2;23;;@Override public int compareSerialized(DataInputView source1, DataInputView source2) throws IOException {     this.temp1.read(source1).     this.temp2.read(source2).     for (int i = 0. i < this.keyFields.length. i++) {         @SuppressWarnings("rawtypes")         final Comparable k1 = (Comparable) this.temp1.getField(this.keyFields[i], this.keyHolders[i]).         @SuppressWarnings("rawtypes")         final Comparable k2 = (Comparable) this.temp2.getField(this.keyFields[i], this.transientKeyHolders[i]).         if (k1 == null || k2 == null) {             throw new NullKeyFieldException(this.keyFields[i]).         }         @SuppressWarnings("unchecked")         final int comp = k1.compareTo(k2).         if (comp != 0) {             return this.ascending[i] ? comp : -comp.         }     }     return 0. }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public boolean supportsNormalizedKey() {     return this.numLeadingNormalizableKeys > 0. }
false;public;0;4;;@Override public int getNormalizeKeyLen() {     return this.normalizableKeyPrefixLen. }
false;public;1;6;;@Override public boolean isNormalizedKeyPrefixOnly(int keyBytes) {     return this.numLeadingNormalizableKeys < this.keyFields.length || this.normalizableKeyPrefixLen == Integer.MAX_VALUE || this.normalizableKeyPrefixLen > keyBytes. }
false;public;4;17;;@Override public void putNormalizedKey(Record record, MemorySegment target, int offset, int numBytes) {     int i = 0.     try {         for (. i < this.numLeadingNormalizableKeys & numBytes > 0. i++) {             int len = this.normalizedKeyLengths[i].             len = numBytes >= len ? len : numBytes.             ((NormalizableKey<?>) record.getField(this.keyFields[i], this.transientKeyHolders[i])).copyNormalizedKey(target, offset, len).             numBytes -= len.             offset += len.         }     } catch (NullPointerException npex) {         throw new NullKeyFieldException(this.keyFields[i]).     } }
false;public;0;4;;@Override public boolean invertNormalizedKey() {     return !this.ascending[0]. }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public boolean supportsSerializationWithKeyNormalization() {     return false. }
false;public;2;4;;@Override public void writeWithKeyNormalization(Record record, DataOutputView target) {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public Record readWithKeyDenormalization(Record reuse, DataInputView source) {     throw new UnsupportedOperationException(). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public RecordComparator duplicate() {     return new RecordComparator(this). }
false;public,final;0;3;;// -------------------------------------------------------------------------------------------- // Non Standard Comparator Methods // -------------------------------------------------------------------------------------------- public final int[] getKeyPositions() {     return this.keyFields. }
false;public,final;0;8;;@SuppressWarnings("unchecked") public final Class<? extends Value>[] getKeyTypes() {     final Class<? extends Value>[] keyTypes = new Class[this.keyHolders.length].     for (int i = 0. i < keyTypes.length. i++) {         keyTypes[i] = (Class<? extends Value>) this.keyHolders[i].getClass().     }     return keyTypes. }
false;public,final;1;15;;public final Value[] getKeysAsCopy(Record record) {     try {         final Value[] keys = new Value[this.keyFields.length].         for (int i = 0. i < keys.length. i++) {             keys[i] = this.keyHolders[i].getClass().newInstance().         }         if (!record.getFieldsInto(this.keyFields, keys)) {             throw new RuntimeException("Could not extract keys from record.").         }         return keys.     } catch (Exception ex) {         // this should never happen, because the classes have been instantiated before. Report for debugging.         throw new RuntimeException("Could not instantiate key classes when duplicating RecordComparator.", ex).     } }
false;public;3;5;;@Override public int extractKeys(Object record, Object[] target, int index) {     throw new UnsupportedOperationException("Record does not support extactKeys and " + "getComparators. This cannot be used with the GenericPairComparator."). }
false;public;0;5;;@Override public TypeComparator<?>[] getFlatComparators() {     throw new UnsupportedOperationException("Record does not support extactKeys and " + "getComparators. This cannot be used with the GenericPairComparator."). }
false;public;0;4;;@Override public boolean supportsCompareAgainstReference() {     return true. }
false;public,final;1;12;;@Override @SuppressWarnings({ "rawtypes", "unchecked" }) public final int compareAgainstReference(Comparable[] keys) {     for (int i = 0. i < this.keyFields.length. i++) {         final int comp = keys[i].compareTo(this.keyHolders[i]).         if (comp != 0) {             return this.ascending[i] ? comp : -comp.         }     }     return 0. }
