commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;// ------------------------------------------------------------------------ @Override public CompletableFuture<Void> stopService() {     final CompletableFuture<Void> terminationFuture = super.stopService().     terminationFuture.whenComplete((Void ignored, Throwable throwable) -> {         registeredConnections.clear().     }).     return terminationFuture. }
false;public;2;8;;// ------------------------------------------------------------------------ // connections // ------------------------------------------------------------------------ public void registerGateway(String address, RpcGateway gateway) {     checkNotNull(address).     checkNotNull(gateway).     if (registeredConnections.putIfAbsent(address, gateway) != null) {         throw new IllegalStateException("a gateway is already registered under " + address).     } }
false;public;2;16;;@Override public <C extends RpcGateway> CompletableFuture<C> connect(String address, Class<C> clazz) {     RpcGateway gateway = registeredConnections.get(address).     if (gateway != null) {         if (clazz.isAssignableFrom(gateway.getClass())) {             @SuppressWarnings("unchecked")             C typedGateway = (C) gateway.             return CompletableFuture.completedFuture(typedGateway).         } else {             return FutureUtils.completedExceptionally(new Exception("Gateway registered under " + address + " is not of type " + clazz)).         }     } else {         return super.connect(address, clazz).     } }
false;public;3;19;;@Override public <F extends Serializable, C extends FencedRpcGateway<F>> CompletableFuture<C> connect(String address, F fencingToken, Class<C> clazz) {     RpcGateway gateway = registeredConnections.get(address).     if (gateway != null) {         if (clazz.isAssignableFrom(gateway.getClass())) {             @SuppressWarnings("unchecked")             C typedGateway = (C) gateway.             return CompletableFuture.completedFuture(typedGateway).         } else {             return FutureUtils.completedExceptionally(new Exception("Gateway registered under " + address + " is not of type " + clazz)).         }     } else {         return super.connect(address, fencingToken, clazz).     } }
false;public;0;3;;public void clearGateways() {     registeredConnections.clear(). }
