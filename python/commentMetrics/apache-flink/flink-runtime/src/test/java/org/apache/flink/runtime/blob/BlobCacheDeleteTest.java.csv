# id;timestamp;commentText;codeText;commentWords;codeWords
BlobCacheDeleteTest -> private void testDeleteTransientLocalFails(@Nullable final JobID jobId) throws IOException;1507212387;Uploads a byte array for the given job and verifies that a delete operation (via the {@link_BlobCache}) does not fail even if the file is not deletable locally, e.g. via restricting_the permissions.__@param jobId_job id;private void testDeleteTransientLocalFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCache cache = new BlobCache(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				BlobKey key = put(server, jobId, data, false)__				assertNotNull(key)___				_				verifyContents(cache, jobId, key, data, false)___				blobFile = cache.getTransientBlobStore().getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				assertFalse(delete(cache, jobId, key))__				verifyDeleted(server, jobId, key, false)___				_				verifyContents(cache, jobId, key, data, false)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,delete,operation,via,the,link,blob,cache,does,not,fail,even,if,the,file,is,not,deletable,locally,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,delete,transient,local,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,cache,new,blob,cache,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,key,put,server,job,id,data,false,assert,not,null,key,verify,contents,cache,job,id,key,data,false,blob,file,cache,get,transient,blob,store,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,assert,false,delete,cache,job,id,key,verify,deleted,server,job,id,key,false,verify,contents,cache,job,id,key,data,false,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobCacheDeleteTest -> private void testDeleteTransientLocalFails(@Nullable final JobID jobId) throws IOException;1507212387;Uploads a byte array for the given job and verifies that a delete operation (via the {@link_BlobCacheService}) does not fail even if the file is not deletable locally, e.g. via_restricting the permissions.__@param jobId_job id;private void testDeleteTransientLocalFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				_				verifyContents(cache, jobId, key, data)___				blobFile = cache.getTransientBlobService().getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				assertFalse(delete(cache, jobId, key))__				verifyDeleted(server, jobId, key)___				_				verifyContents(cache, jobId, key, data)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,delete,operation,via,the,link,blob,cache,service,does,not,fail,even,if,the,file,is,not,deletable,locally,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,delete,transient,local,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,verify,contents,cache,job,id,key,data,blob,file,cache,get,transient,blob,service,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,assert,false,delete,cache,job,id,key,verify,deleted,server,job,id,key,verify,contents,cache,job,id,key,data,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobCacheDeleteTest -> private void testDeleteTransientLocalFails(@Nullable final JobID jobId) 		throws IOException, InterruptedException;1507313571;Uploads a byte array for the given job and verifies that a delete operation (via the {@link_BlobCacheService}) does not fail even if the file is not deletable locally, e.g. via_restricting the permissions.__@param jobId_job id;private void testDeleteTransientLocalFails(@Nullable final JobID jobId)_		throws IOException, InterruptedException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				_				verifyContents(cache, jobId, key, data)___				blobFile = cache.getTransientBlobService().getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				assertFalse(delete(cache, jobId, key))___				_				verifyContents(cache, jobId, key, data)__				_				verifyDeletedEventually(server, jobId, key)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,delete,operation,via,the,link,blob,cache,service,does,not,fail,even,if,the,file,is,not,deletable,locally,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,delete,transient,local,fails,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,verify,contents,cache,job,id,key,data,blob,file,cache,get,transient,blob,service,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,assert,false,delete,cache,job,id,key,verify,contents,cache,job,id,key,data,verify,deleted,eventually,server,job,id,key,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobCacheDeleteTest -> private void testDeleteTransientLocalFails(@Nullable final JobID jobId) 		throws IOException, InterruptedException;1508138617;Uploads a byte array for the given job and verifies that a delete operation (via the {@link_BlobCacheService}) does not fail even if the file is not deletable locally, e.g. via_restricting the permissions.__@param jobId_job id;private void testDeleteTransientLocalFails(@Nullable final JobID jobId)_		throws IOException, InterruptedException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				_				verifyContents(cache, jobId, key, data)___				blobFile = cache.getTransientBlobService().getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				assertFalse(delete(cache, jobId, key))___				_				verifyContents(cache, jobId, key, data)__				_				verifyDeletedEventually(server, jobId, key)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,delete,operation,via,the,link,blob,cache,service,does,not,fail,even,if,the,file,is,not,deletable,locally,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,delete,transient,local,fails,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,verify,contents,cache,job,id,key,data,blob,file,cache,get,transient,blob,service,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,assert,false,delete,cache,job,id,key,verify,contents,cache,job,id,key,data,verify,deleted,eventually,server,job,id,key,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobCacheDeleteTest -> private void testDeleteTransientLocalFails(@Nullable final JobID jobId) 		throws IOException, InterruptedException;1517915730;Uploads a byte array for the given job and verifies that a delete operation (via the {@link_BlobCacheService}) does not fail even if the file is not deletable locally, e.g. via_restricting the permissions.__@param jobId_job id;private void testDeleteTransientLocalFails(@Nullable final JobID jobId)_		throws IOException, InterruptedException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				_				verifyContents(cache, jobId, key, data)___				blobFile = cache.getTransientBlobService().getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				assertFalse(delete(cache, jobId, key))___				_				verifyContents(cache, jobId, key, data)__				_				verifyDeletedEventually(server, jobId, key)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,delete,operation,via,the,link,blob,cache,service,does,not,fail,even,if,the,file,is,not,deletable,locally,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,delete,transient,local,fails,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,verify,contents,cache,job,id,key,data,blob,file,cache,get,transient,blob,service,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,assert,false,delete,cache,job,id,key,verify,contents,cache,job,id,key,data,verify,deleted,eventually,server,job,id,key,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobCacheDeleteTest -> private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException;1507212387;Uploads a byte array for the given job and verifies that deleting it (via the {@link_BlobCache}) does not fail independent of whether the file exists.__@param jobId_job id;private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCache cache = new BlobCache(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			BlobKey key = put(server, jobId, data, false)__			assertNotNull(key)___			File blobFile = server.getStorageLocation(jobId, key)__			assertTrue(blobFile.delete())___			_			assertTrue(delete(cache, jobId, key))__			verifyDeleted(cache, jobId, key, false)___			_			assertTrue(delete(cache, jobId, key))__			verifyDeleted(cache, jobId, key, false)__		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,deleting,it,via,the,link,blob,cache,does,not,fail,independent,of,whether,the,file,exists,param,job,id,job,id;private,void,test,delete,transient,already,deleted,nullable,final,job,id,job,id,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,cache,new,blob,cache,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,key,put,server,job,id,data,false,assert,not,null,key,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,assert,true,delete,cache,job,id,key,verify,deleted,cache,job,id,key,false,assert,true,delete,cache,job,id,key,verify,deleted,cache,job,id,key,false
BlobCacheDeleteTest -> private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException;1507212387;Uploads a byte array for the given job and verifies that deleting it (via the {@link_BlobCacheService}) does not fail independent of whether the file exists.__@param jobId_job id;private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			assertNotNull(key)___			File blobFile = server.getStorageLocation(jobId, key)__			assertTrue(blobFile.delete())___			_			assertTrue(delete(cache, jobId, key))__			verifyDeleted(cache, jobId, key)___			_			assertTrue(delete(cache, jobId, key))__			verifyDeleted(cache, jobId, key)__		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,deleting,it,via,the,link,blob,cache,service,does,not,fail,independent,of,whether,the,file,exists,param,job,id,job,id;private,void,test,delete,transient,already,deleted,nullable,final,job,id,job,id,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,assert,true,delete,cache,job,id,key,verify,deleted,cache,job,id,key,assert,true,delete,cache,job,id,key,verify,deleted,cache,job,id,key
BlobCacheDeleteTest -> private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException;1507313571;Uploads a byte array for the given job and verifies that deleting it (via the {@link_BlobCacheService}) does not fail independent of whether the file exists.__@param jobId_job id;private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			assertNotNull(key)___			File blobFile = server.getStorageLocation(jobId, key)__			assertTrue(blobFile.delete())___			_			assertTrue(delete(cache, jobId, key))__			verifyDeleted(cache, jobId, key)___			_			assertTrue(delete(cache, jobId, key))__			verifyDeleted(cache, jobId, key)__		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,deleting,it,via,the,link,blob,cache,service,does,not,fail,independent,of,whether,the,file,exists,param,job,id,job,id;private,void,test,delete,transient,already,deleted,nullable,final,job,id,job,id,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,assert,true,delete,cache,job,id,key,verify,deleted,cache,job,id,key,assert,true,delete,cache,job,id,key,verify,deleted,cache,job,id,key
BlobCacheDeleteTest -> private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException;1508138617;Uploads a byte array for the given job and verifies that deleting it (via the {@link_BlobCacheService}) does not fail independent of whether the file exists.__@param jobId_job id;private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			assertNotNull(key)___			File blobFile = server.getStorageLocation(jobId, key)__			assertTrue(blobFile.delete())___			_			assertTrue(delete(cache, jobId, key))__			verifyDeleted(cache, jobId, key)___			_			assertTrue(delete(cache, jobId, key))__			verifyDeleted(cache, jobId, key)__		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,deleting,it,via,the,link,blob,cache,service,does,not,fail,independent,of,whether,the,file,exists,param,job,id,job,id;private,void,test,delete,transient,already,deleted,nullable,final,job,id,job,id,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,assert,true,delete,cache,job,id,key,verify,deleted,cache,job,id,key,assert,true,delete,cache,job,id,key,verify,deleted,cache,job,id,key
BlobCacheDeleteTest -> private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException;1517915730;Uploads a byte array for the given job and verifies that deleting it (via the {@link_BlobCacheService}) does not fail independent of whether the file exists.__@param jobId_job id;private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			assertNotNull(key)___			File blobFile = server.getStorageLocation(jobId, key)__			assertTrue(blobFile.delete())___			_			assertTrue(delete(cache, jobId, key))__			verifyDeleted(cache, jobId, key)___			_			assertTrue(delete(cache, jobId, key))__			verifyDeleted(cache, jobId, key)__		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,deleting,it,via,the,link,blob,cache,service,does,not,fail,independent,of,whether,the,file,exists,param,job,id,job,id;private,void,test,delete,transient,already,deleted,nullable,final,job,id,job,id,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,assert,true,delete,cache,job,id,key,verify,deleted,cache,job,id,key,assert,true,delete,cache,job,id,key,verify,deleted,cache,job,id,key
BlobCacheDeleteTest -> private void testDelete(@Nullable JobID jobId1, @Nullable JobID jobId2) 			throws IOException;1507212387;Uploads a (different) byte array for each of the given jobs and verifies that deleting one of_them (via the {@link BlobCacheService}) does not influence the other.__@param jobId1_first job id_@param jobId2_second job id;private void testDelete(@Nullable JobID jobId1, @Nullable JobID jobId2)_			throws IOException {_		final boolean sameJobId = (jobId1 == jobId2) || (jobId1 != null && jobId1.equals(jobId2))___		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			_			TransientBlobKey key1 = (TransientBlobKey) put(server, jobId1, data, TRANSIENT_BLOB)__			assertNotNull(key1)___			_			TransientBlobKey key2a = (TransientBlobKey) put(server, jobId2, data, TRANSIENT_BLOB)__			assertNotNull(key2a)__			assertEquals(key1, key2a)__			TransientBlobKey key2b = (TransientBlobKey) put(server, jobId2, data2, TRANSIENT_BLOB)__			assertNotNull(key2b)___			_			assertTrue(delete(cache, jobId1, key1))___			_			assertTrue(server.getStorageLocation(jobId1, key1).exists())__			_			assertTrue(server.deleteInternal(jobId1, key1))__			verifyDeleted(cache, jobId1, key1)__			_			if (!sameJobId) {_				verifyContents(server, jobId2, key2a, data)__			}_			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(cache, jobId2, key2a))__			_			assertTrue(sameJobId || server.getStorageLocation(jobId2, key2a).exists())__			_			assertTrue(server.deleteInternal(jobId2, key2a))__			verifyDeleted(cache, jobId2, key2a)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(cache, jobId2, key2b))__			_			assertTrue(server.getStorageLocation(jobId2, key2b).exists())__			_			assertTrue(server.deleteInternal(jobId2, key2b))__			verifyDeleted(cache, jobId2, key2b)__		}_	};uploads,a,different,byte,array,for,each,of,the,given,jobs,and,verifies,that,deleting,one,of,them,via,the,link,blob,cache,service,does,not,influence,the,other,param,job,id1,first,job,id,param,job,id2,second,job,id;private,void,test,delete,nullable,job,id,job,id1,nullable,job,id,job,id2,throws,ioexception,final,boolean,same,job,id,job,id1,job,id2,job,id1,null,job,id1,equals,job,id2,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,data,data,length,data2,0,1,transient,blob,key,key1,transient,blob,key,put,server,job,id1,data,assert,not,null,key1,transient,blob,key,key2a,transient,blob,key,put,server,job,id2,data,assert,not,null,key2a,assert,equals,key1,key2a,transient,blob,key,key2b,transient,blob,key,put,server,job,id2,data2,assert,not,null,key2b,assert,true,delete,cache,job,id1,key1,assert,true,server,get,storage,location,job,id1,key1,exists,assert,true,server,delete,internal,job,id1,key1,verify,deleted,cache,job,id1,key1,if,same,job,id,verify,contents,server,job,id2,key2a,data,verify,contents,server,job,id2,key2b,data2,assert,true,delete,cache,job,id2,key2a,assert,true,same,job,id,server,get,storage,location,job,id2,key2a,exists,assert,true,server,delete,internal,job,id2,key2a,verify,deleted,cache,job,id2,key2a,verify,contents,server,job,id2,key2b,data2,assert,true,delete,cache,job,id2,key2b,assert,true,server,get,storage,location,job,id2,key2b,exists,assert,true,server,delete,internal,job,id2,key2b,verify,deleted,cache,job,id2,key2b
BlobCacheDeleteTest -> private void testDelete(@Nullable JobID jobId1, @Nullable JobID jobId2) 			throws IOException;1507313571;Uploads a (different) byte array for each of the given jobs and verifies that deleting one of_them (via the {@link BlobCacheService}) does not influence the other.__@param jobId1_first job id_@param jobId2_second job id;private void testDelete(@Nullable JobID jobId1, @Nullable JobID jobId2)_			throws IOException {_		final boolean sameJobId = (jobId1 == jobId2) || (jobId1 != null && jobId1.equals(jobId2))___		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			_			TransientBlobKey key1 = (TransientBlobKey) put(server, jobId1, data, TRANSIENT_BLOB)__			assertNotNull(key1)___			_			TransientBlobKey key2a = (TransientBlobKey) put(server, jobId2, data, TRANSIENT_BLOB)__			assertNotNull(key2a)__			assertEquals(key1, key2a)__			TransientBlobKey key2b = (TransientBlobKey) put(server, jobId2, data2, TRANSIENT_BLOB)__			assertNotNull(key2b)___			_			assertTrue(delete(cache, jobId1, key1))___			_			assertTrue(server.getStorageLocation(jobId1, key1).exists())__			_			assertTrue(server.deleteInternal(jobId1, key1))__			verifyDeleted(cache, jobId1, key1)__			_			if (!sameJobId) {_				verifyContents(server, jobId2, key2a, data)__			}_			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(cache, jobId2, key2a))__			_			assertTrue(sameJobId || server.getStorageLocation(jobId2, key2a).exists())__			_			assertTrue(server.deleteInternal(jobId2, key2a))__			verifyDeleted(cache, jobId2, key2a)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(cache, jobId2, key2b))__			_			assertTrue(server.getStorageLocation(jobId2, key2b).exists())__			_			assertTrue(server.deleteInternal(jobId2, key2b))__			verifyDeleted(cache, jobId2, key2b)__		}_	};uploads,a,different,byte,array,for,each,of,the,given,jobs,and,verifies,that,deleting,one,of,them,via,the,link,blob,cache,service,does,not,influence,the,other,param,job,id1,first,job,id,param,job,id2,second,job,id;private,void,test,delete,nullable,job,id,job,id1,nullable,job,id,job,id2,throws,ioexception,final,boolean,same,job,id,job,id1,job,id2,job,id1,null,job,id1,equals,job,id2,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,data,data,length,data2,0,1,transient,blob,key,key1,transient,blob,key,put,server,job,id1,data,assert,not,null,key1,transient,blob,key,key2a,transient,blob,key,put,server,job,id2,data,assert,not,null,key2a,assert,equals,key1,key2a,transient,blob,key,key2b,transient,blob,key,put,server,job,id2,data2,assert,not,null,key2b,assert,true,delete,cache,job,id1,key1,assert,true,server,get,storage,location,job,id1,key1,exists,assert,true,server,delete,internal,job,id1,key1,verify,deleted,cache,job,id1,key1,if,same,job,id,verify,contents,server,job,id2,key2a,data,verify,contents,server,job,id2,key2b,data2,assert,true,delete,cache,job,id2,key2a,assert,true,same,job,id,server,get,storage,location,job,id2,key2a,exists,assert,true,server,delete,internal,job,id2,key2a,verify,deleted,cache,job,id2,key2a,verify,contents,server,job,id2,key2b,data2,assert,true,delete,cache,job,id2,key2b,assert,true,server,get,storage,location,job,id2,key2b,exists,assert,true,server,delete,internal,job,id2,key2b,verify,deleted,cache,job,id2,key2b
BlobCacheDeleteTest -> private void testDelete(@Nullable JobID jobId1, @Nullable JobID jobId2) 			throws IOException;1508138617;Uploads a (different) byte array for each of the given jobs and verifies that deleting one of_them (via the {@link BlobCacheService}) does not influence the other.__@param jobId1_first job id_@param jobId2_second job id;private void testDelete(@Nullable JobID jobId1, @Nullable JobID jobId2)_			throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			_			TransientBlobKey key1 = (TransientBlobKey) put(server, jobId1, data, TRANSIENT_BLOB)__			assertNotNull(key1)___			_			TransientBlobKey key2a = (TransientBlobKey) put(server, jobId2, data, TRANSIENT_BLOB)__			assertNotNull(key2a)__			BlobKeyTest.verifyKeyDifferentHashEquals(key1, key2a)__			TransientBlobKey key2b = (TransientBlobKey) put(server, jobId2, data2, TRANSIENT_BLOB)__			assertNotNull(key2b)__			BlobKeyTest.verifyKeyDifferentHashDifferent(key1, key2b)___			_			assertTrue(delete(cache, jobId1, key1))___			_			assertTrue(server.getStorageLocation(jobId1, key1).exists())__			_			assertTrue(server.deleteInternal(jobId1, key1))__			verifyDeleted(cache, jobId1, key1)__			_			_			verifyContents(server, jobId2, key2a, data)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(cache, jobId2, key2a))__			_			assertTrue(server.getStorageLocation(jobId2, key2a).exists())__			_			assertTrue(server.deleteInternal(jobId2, key2a))__			verifyDeleted(cache, jobId2, key2a)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(cache, jobId2, key2b))__			_			assertTrue(server.getStorageLocation(jobId2, key2b).exists())__			_			assertTrue(server.deleteInternal(jobId2, key2b))__			verifyDeleted(cache, jobId2, key2b)__		}_	};uploads,a,different,byte,array,for,each,of,the,given,jobs,and,verifies,that,deleting,one,of,them,via,the,link,blob,cache,service,does,not,influence,the,other,param,job,id1,first,job,id,param,job,id2,second,job,id;private,void,test,delete,nullable,job,id,job,id1,nullable,job,id,job,id2,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,data,data,length,data2,0,1,transient,blob,key,key1,transient,blob,key,put,server,job,id1,data,assert,not,null,key1,transient,blob,key,key2a,transient,blob,key,put,server,job,id2,data,assert,not,null,key2a,blob,key,test,verify,key,different,hash,equals,key1,key2a,transient,blob,key,key2b,transient,blob,key,put,server,job,id2,data2,assert,not,null,key2b,blob,key,test,verify,key,different,hash,different,key1,key2b,assert,true,delete,cache,job,id1,key1,assert,true,server,get,storage,location,job,id1,key1,exists,assert,true,server,delete,internal,job,id1,key1,verify,deleted,cache,job,id1,key1,verify,contents,server,job,id2,key2a,data,verify,contents,server,job,id2,key2b,data2,assert,true,delete,cache,job,id2,key2a,assert,true,server,get,storage,location,job,id2,key2a,exists,assert,true,server,delete,internal,job,id2,key2a,verify,deleted,cache,job,id2,key2a,verify,contents,server,job,id2,key2b,data2,assert,true,delete,cache,job,id2,key2b,assert,true,server,get,storage,location,job,id2,key2b,exists,assert,true,server,delete,internal,job,id2,key2b,verify,deleted,cache,job,id2,key2b
BlobCacheDeleteTest -> private void testDelete(@Nullable JobID jobId1, @Nullable JobID jobId2) 			throws IOException;1517915730;Uploads a (different) byte array for each of the given jobs and verifies that deleting one of_them (via the {@link BlobCacheService}) does not influence the other.__@param jobId1_first job id_@param jobId2_second job id;private void testDelete(@Nullable JobID jobId1, @Nullable JobID jobId2)_			throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			_			TransientBlobKey key1 = (TransientBlobKey) put(server, jobId1, data, TRANSIENT_BLOB)__			assertNotNull(key1)___			_			TransientBlobKey key2a = (TransientBlobKey) put(server, jobId2, data, TRANSIENT_BLOB)__			assertNotNull(key2a)__			BlobKeyTest.verifyKeyDifferentHashEquals(key1, key2a)__			TransientBlobKey key2b = (TransientBlobKey) put(server, jobId2, data2, TRANSIENT_BLOB)__			assertNotNull(key2b)__			BlobKeyTest.verifyKeyDifferentHashDifferent(key1, key2b)___			_			assertTrue(delete(cache, jobId1, key1))___			_			assertTrue(server.getStorageLocation(jobId1, key1).exists())__			_			assertTrue(server.deleteInternal(jobId1, key1))__			verifyDeleted(cache, jobId1, key1)__			_			_			verifyContents(server, jobId2, key2a, data)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(cache, jobId2, key2a))__			_			assertTrue(server.getStorageLocation(jobId2, key2a).exists())__			_			assertTrue(server.deleteInternal(jobId2, key2a))__			verifyDeleted(cache, jobId2, key2a)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(cache, jobId2, key2b))__			_			assertTrue(server.getStorageLocation(jobId2, key2b).exists())__			_			assertTrue(server.deleteInternal(jobId2, key2b))__			verifyDeleted(cache, jobId2, key2b)__		}_	};uploads,a,different,byte,array,for,each,of,the,given,jobs,and,verifies,that,deleting,one,of,them,via,the,link,blob,cache,service,does,not,influence,the,other,param,job,id1,first,job,id,param,job,id2,second,job,id;private,void,test,delete,nullable,job,id,job,id1,nullable,job,id,job,id2,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,data,data,length,data2,0,1,transient,blob,key,key1,transient,blob,key,put,server,job,id1,data,assert,not,null,key1,transient,blob,key,key2a,transient,blob,key,put,server,job,id2,data,assert,not,null,key2a,blob,key,test,verify,key,different,hash,equals,key1,key2a,transient,blob,key,key2b,transient,blob,key,put,server,job,id2,data2,assert,not,null,key2b,blob,key,test,verify,key,different,hash,different,key1,key2b,assert,true,delete,cache,job,id1,key1,assert,true,server,get,storage,location,job,id1,key1,exists,assert,true,server,delete,internal,job,id1,key1,verify,deleted,cache,job,id1,key1,verify,contents,server,job,id2,key2a,data,verify,contents,server,job,id2,key2b,data2,assert,true,delete,cache,job,id2,key2a,assert,true,server,get,storage,location,job,id2,key2a,exists,assert,true,server,delete,internal,job,id2,key2a,verify,deleted,cache,job,id2,key2a,verify,contents,server,job,id2,key2b,data2,assert,true,delete,cache,job,id2,key2b,assert,true,server,get,storage,location,job,id2,key2b,exists,assert,true,server,delete,internal,job,id2,key2b,verify,deleted,cache,job,id2,key2b
BlobCacheDeleteTest -> private void testConcurrentDeleteOperations(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1507212387;[FLINK-6020] Tests that concurrent delete operations don't interfere with each other.__<p>Note: This test checks that there cannot be two threads which have checked whether a given_blob file exist and then one of them fails deleting it. Without the introduced lock, this_situation should rarely happen and make this test fail. Thus, if this test should become_"unstable", then the delete atomicity is most likely broken.__@param jobId_job ID to use (or <tt>null</tt> if job-unrelated);private void testConcurrentDeleteOperations(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCache cache = new BlobCache(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			final BlobKey blobKey = put(server, jobId, data, false)___			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								assertTrue(delete(cache, jobId, blobKey))__								assertFalse(cache.getTransientBlobStore().getStorageLocation(jobId, blobKey).exists())__								assertFalse(server.getStorageLocation(jobId, blobKey).exists())__								return null__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not upload blob.", e))__							}_						}, executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(server.getStorageLocation(jobId, blobKey).exists())___		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,p,note,this,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated;private,void,test,concurrent,delete,operations,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,cache,new,blob,cache,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,final,blob,key,blob,key,put,server,job,id,data,false,assert,true,server,get,storage,location,job,id,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,assert,true,delete,cache,job,id,blob,key,assert,false,cache,get,transient,blob,store,get,storage,location,job,id,blob,key,exists,assert,false,server,get,storage,location,job,id,blob,key,exists,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,upload,blob,e,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,server,get,storage,location,job,id,blob,key,exists,finally,executor,shutdown,now
BlobCacheDeleteTest -> private void testConcurrentDeleteOperations(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1507212387;[FLINK-6020] Tests that concurrent delete operations don't interfere with each other.__<p>Note: This test checks that there cannot be two threads which have checked whether a given_blob file exist and then one of them fails deleting it. Without the introduced lock, this_situation should rarely happen and make this test fail. Thus, if this test should become_"unstable", then the delete atomicity is most likely broken._@param jobId_job ID to use (or <tt>null</tt> if job-unrelated);private void testConcurrentDeleteOperations(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			final TransientBlobKey blobKey =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)___			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								assertTrue(delete(cache, jobId, blobKey))__								assertFalse(cache.getTransientBlobService().getStorageLocation(jobId, blobKey).exists())__								_								assertTrue(server.getStorageLocation(jobId, blobKey).exists())__								return null__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not upload blob.", e))__							}_						}, executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			_			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,p,note,this,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated;private,void,test,concurrent,delete,operations,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,final,transient,blob,key,blob,key,transient,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,assert,true,delete,cache,job,id,blob,key,assert,false,cache,get,transient,blob,service,get,storage,location,job,id,blob,key,exists,assert,true,server,get,storage,location,job,id,blob,key,exists,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,upload,blob,e,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,executor,shutdown,now
BlobCacheDeleteTest -> private void testConcurrentDeleteOperations(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1507313571;[FLINK-6020] Tests that concurrent delete operations don't interfere with each other.__<p>Note: This test checks that there cannot be two threads which have checked whether a given_blob file exist and then one of them fails deleting it. Without the introduced lock, this_situation should rarely happen and make this test fail. Thus, if this test should become_"unstable", then the delete atomicity is most likely broken._@param jobId_job ID to use (or <tt>null</tt> if job-unrelated);private void testConcurrentDeleteOperations(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			final TransientBlobKey blobKey =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)___			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								assertTrue(delete(cache, jobId, blobKey))__								assertFalse(cache.getTransientBlobService().getStorageLocation(jobId, blobKey).exists())__								_								assertTrue(server.getStorageLocation(jobId, blobKey).exists())__								return null__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not upload blob.", e))__							}_						}, executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			_			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,p,note,this,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated;private,void,test,concurrent,delete,operations,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,final,transient,blob,key,blob,key,transient,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,assert,true,delete,cache,job,id,blob,key,assert,false,cache,get,transient,blob,service,get,storage,location,job,id,blob,key,exists,assert,true,server,get,storage,location,job,id,blob,key,exists,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,upload,blob,e,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,executor,shutdown,now
BlobCacheDeleteTest -> private void testConcurrentDeleteOperations(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1508138617;[FLINK-6020] Tests that concurrent delete operations don't interfere with each other.__<p>Note: This test checks that there cannot be two threads which have checked whether a given_blob file exist and then one of them fails deleting it. Without the introduced lock, this_situation should rarely happen and make this test fail. Thus, if this test should become_"unstable", then the delete atomicity is most likely broken._@param jobId_job ID to use (or <tt>null</tt> if job-unrelated);private void testConcurrentDeleteOperations(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			final TransientBlobKey blobKey =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)___			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								assertTrue(delete(cache, jobId, blobKey))__								assertFalse(cache.getTransientBlobService().getStorageLocation(jobId, blobKey).exists())__								_								assertTrue(server.getStorageLocation(jobId, blobKey).exists())__								return null__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not upload blob.", e))__							}_						}, executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			_			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,p,note,this,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated;private,void,test,concurrent,delete,operations,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,final,transient,blob,key,blob,key,transient,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,assert,true,delete,cache,job,id,blob,key,assert,false,cache,get,transient,blob,service,get,storage,location,job,id,blob,key,exists,assert,true,server,get,storage,location,job,id,blob,key,exists,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,upload,blob,e,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,executor,shutdown,now
BlobCacheDeleteTest -> private void testConcurrentDeleteOperations(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1517915730;[FLINK-6020] Tests that concurrent delete operations don't interfere with each other.__<p>Note: This test checks that there cannot be two threads which have checked whether a given_blob file exist and then one of them fails deleting it. Without the introduced lock, this_situation should rarely happen and make this test fail. Thus, if this test should become_"unstable", then the delete atomicity is most likely broken._@param jobId_job ID to use (or <tt>null</tt> if job-unrelated);private void testConcurrentDeleteOperations(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			final TransientBlobKey blobKey =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)___			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								assertTrue(delete(cache, jobId, blobKey))__								assertFalse(cache.getTransientBlobService().getStorageLocation(jobId, blobKey).exists())__								_								assertTrue(server.getStorageLocation(jobId, blobKey).exists())__								return null__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not upload blob.", e))__							}_						}, executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			_			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,p,note,this,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated;private,void,test,concurrent,delete,operations,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,server,start,final,transient,blob,key,blob,key,transient,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,assert,true,delete,cache,job,id,blob,key,assert,false,cache,get,transient,blob,service,get,storage,location,job,id,blob,key,exists,assert,true,server,get,storage,location,job,id,blob,key,exists,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,upload,blob,e,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,executor,shutdown,now
