commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setReference(Long reference) {     ref = reference. }
false;public;1;5;;@Override public boolean equalToReference(Tuple2<Long, byte[]> candidate) {     // noinspection UnnecessaryUnboxing     return candidate.f0.longValue() == ref. }
false;public;1;6;;@Override public int compareToReference(Tuple2<Long, byte[]> candidate) {     long x = ref.     long y = candidate.f0.     return (x < y) ? -1 : ((x == y) ? 0 : 1). }
true;public;0;47;/**  * This tests a combination of values that lead to a corner case situation where memory  * was missing and the computation deadlocked.  */ ;// ------------------------------------------------------------------------ // Tests // ------------------------------------------------------------------------ /**  * This tests a combination of values that lead to a corner case situation where memory  * was missing and the computation deadlocked.  */ @Test public void testBufferMissingForProbing() {     final IOManager ioMan = new IOManagerAsync().     try {         final int pageSize = 32 * 1024.         final int numSegments = 34.         final int numRecords = 3400.         final int recordLen = 270.         final byte[] payload = new byte[recordLen - 8 - 4].         List<MemorySegment> memory = getMemory(numSegments, pageSize).         MutableHashTable<Tuple2<Long, byte[]>, Long> table = new MutableHashTable<>(buildSerializer, probeSerializer, buildComparator, probeComparator, pairComparator, memory, ioMan, 16, false).         table.open(new TupleBytesIterator(payload, numRecords), new LongIterator(10000)).         try {             while (table.nextRecord()) {                 MutableObjectIterator<Tuple2<Long, byte[]>> matches = table.getBuildSideIterator().                 while (matches.next() != null) .             }         } catch (RuntimeException e) {             if (!e.getMessage().contains("exceeded maximum number of recursions")) {                 e.printStackTrace().                 fail("Test failed with unexpected exception").             }         } finally {             table.close().         }         checkNoTempFilesRemain(ioMan).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } finally {         ioMan.shutdown().     } }
true;public;0;35;/**  * This tests the case where no additional partition buffers are used at the point when spilling  * is triggered, testing that overflow bucket buffers are taken into account when deciding which  * partition to spill.  */ ;/**  * This tests the case where no additional partition buffers are used at the point when spilling  * is triggered, testing that overflow bucket buffers are taken into account when deciding which  * partition to spill.  */ @Test public void testSpillingFreesOnlyOverflowSegments() {     final IOManager ioMan = new IOManagerAsync().     final TypeSerializer<ByteValue> serializer = ByteValueSerializer.INSTANCE.     final TypeComparator<ByteValue> buildComparator = new ValueComparator<>(true, ByteValue.class).     final TypeComparator<ByteValue> probeComparator = new ValueComparator<>(true, ByteValue.class).     @SuppressWarnings("unchecked")     final TypePairComparator<ByteValue, ByteValue> pairComparator = Mockito.mock(TypePairComparator.class).     try {         final int pageSize = 32 * 1024.         final int numSegments = 34.         List<MemorySegment> memory = getMemory(numSegments, pageSize).         MutableHashTable<ByteValue, ByteValue> table = new MutableHashTable<>(serializer, serializer, buildComparator, probeComparator, pairComparator, memory, ioMan, 1, false).         table.open(new ByteValueIterator(100000000), new ByteValueIterator(1)).         table.close().         checkNoTempFilesRemain(ioMan).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } finally {         ioMan.shutdown().     } }
true;public;0;57;/**  * Tests that the MutableHashTable spills its partitions when creating the initial table  * without overflow segments in the partitions. This means that the records are large.  */ ;/**  * Tests that the MutableHashTable spills its partitions when creating the initial table  * without overflow segments in the partitions. This means that the records are large.  */ @Test public void testSpillingWhenBuildingTableWithoutOverflow() throws Exception {     final IOManager ioMan = new IOManagerAsync().     try {         final TypeSerializer<byte[]> serializer = BytePrimitiveArraySerializer.INSTANCE.         final TypeComparator<byte[]> buildComparator = new BytePrimitiveArrayComparator(true).         final TypeComparator<byte[]> probeComparator = new BytePrimitiveArrayComparator(true).         @SuppressWarnings("unchecked")         final TypePairComparator<byte[], byte[]> pairComparator = new GenericPairComparator<>(new BytePrimitiveArrayComparator(true), new BytePrimitiveArrayComparator(true)).         final int pageSize = 128.         final int numSegments = 33.         List<MemorySegment> memory = getMemory(numSegments, pageSize).         MutableHashTable<byte[], byte[]> table = new MutableHashTable<byte[], byte[]>(serializer, serializer, buildComparator, probeComparator, pairComparator, memory, ioMan, 1, false).         int numElements = 9.         table.open(new CombiningIterator<byte[]>(new ByteArrayIterator(numElements, 128, (byte) 0), new ByteArrayIterator(numElements, 128, (byte) 1)), new CombiningIterator<byte[]>(new ByteArrayIterator(1, 128, (byte) 0), new ByteArrayIterator(1, 128, (byte) 1))).         while (table.nextRecord()) {             MutableObjectIterator<byte[]> iterator = table.getBuildSideIterator().             int counter = 0.             while (iterator.next() != null) {                 counter++.             }             // check that we retrieve all our elements             Assert.assertEquals(numElements, counter).         }         table.close().     } finally {         ioMan.shutdown().     } }
false;private,static;2;7;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ private static List<MemorySegment> getMemory(int numSegments, int segmentSize) {     ArrayList<MemorySegment> list = new ArrayList<MemorySegment>(numSegments).     for (int i = 0. i < numSegments. i++) {         list.add(MemorySegmentFactory.allocateUnpooledSegment(segmentSize)).     }     return list. }
false;private,static;1;9;;private static void checkNoTempFilesRemain(IOManager ioManager) {     for (File dir : ioManager.getSpillingDirectories()) {         for (String file : dir.list()) {             if (file != null && !(file.equals(".") || file.equals(".."))) {                 fail("hash table did not clean up temp files. remaining file: " + file).             }         }     } }
false;public;1;4;;@Override public Tuple2<Long, byte[]> next(Tuple2<Long, byte[]> reuse) {     return next(). }
false;public;0;8;;@Override public Tuple2<Long, byte[]> next() {     if (count++ < numRecords) {         return new Tuple2<>(42L, payload).     } else {         return null.     } }
false;public;1;4;;@Override public byte[] next(byte[] array) {     return next(). }
false;public;0;8;;@Override public byte[] next() {     if (counter++ < numRecords) {         return arrayValue.     } else {         return null.     } }
false;public;1;4;;@Override public Long next(Long aLong) {     return next(). }
false;public;0;8;;@Override public Long next() {     if (value < numRecords) {         return value++.     } else {         return null.     } }
false;public;1;4;;@Override public ByteValue next(ByteValue aLong) {     return next(). }
false;public;0;8;;@Override public ByteValue next() {     if (value++ < numRecords) {         return new ByteValue((byte) 0).     } else {         return null.     } }
false;public;1;10;;@Override public T next(T reuse) throws IOException {     T value = left.next(reuse).     if (value == null) {         return right.next(reuse).     } else {         return value.     } }
false;public;0;10;;@Override public T next() throws IOException {     T value = left.next().     if (value == null) {         return right.next().     } else {         return value.     } }
