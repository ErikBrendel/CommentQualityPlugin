# id;timestamp;commentText;codeText;commentWords;codeWords
HashTableTest -> @Test 	public void testSpillingFreesOnlyOverflowSegments();1443528421;This tests the case where no additional partition buffers are used at the point when spilling_is triggered, testing that overflow bucket buffers are taken into account when deciding which_partition to spill.;@Test_	public void testSpillingFreesOnlyOverflowSegments() {_		final IOManager ioMan = new IOManagerAsync()__		_		final TypeSerializer<ByteValue> serializer = ByteValueSerializer.INSTANCE__		final TypeComparator<ByteValue> buildComparator = new ValueComparator<>(true, ByteValue.class)__		final TypeComparator<ByteValue> probeComparator = new ValueComparator<>(true, ByteValue.class)__		_		@SuppressWarnings("unchecked")_		final TypePairComparator<ByteValue, ByteValue> pairComparator = Mockito.mock(TypePairComparator.class)__		_		try {_			final int pageSize = 32*1024__			final int numSegments = 34___			List<MemorySegment> memory = getMemory(numSegments, pageSize)___			MutableHashTable<ByteValue, ByteValue> table = new MutableHashTable<>(_					serializer, serializer, buildComparator, probeComparator,_					pairComparator, memory, ioMan, 1, false)___			table.open(new ByteValueIterator(100000000), new ByteValueIterator(1))__			_			table.close()__			_			checkNoTempFilesRemain(ioMan)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			ioMan.shutdown()__		}_	};this,tests,the,case,where,no,additional,partition,buffers,are,used,at,the,point,when,spilling,is,triggered,testing,that,overflow,bucket,buffers,are,taken,into,account,when,deciding,which,partition,to,spill;test,public,void,test,spilling,frees,only,overflow,segments,final,iomanager,io,man,new,iomanager,async,final,type,serializer,byte,value,serializer,byte,value,serializer,instance,final,type,comparator,byte,value,build,comparator,new,value,comparator,true,byte,value,class,final,type,comparator,byte,value,probe,comparator,new,value,comparator,true,byte,value,class,suppress,warnings,unchecked,final,type,pair,comparator,byte,value,byte,value,pair,comparator,mockito,mock,type,pair,comparator,class,try,final,int,page,size,32,1024,final,int,num,segments,34,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,byte,value,byte,value,table,new,mutable,hash,table,serializer,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,1,false,table,open,new,byte,value,iterator,100000000,new,byte,value,iterator,1,table,close,check,no,temp,files,remain,io,man,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,io,man,shutdown
HashTableTest -> @Test 	public void testSpillingFreesOnlyOverflowSegments();1446633116;This tests the case where no additional partition buffers are used at the point when spilling_is triggered, testing that overflow bucket buffers are taken into account when deciding which_partition to spill.;@Test_	public void testSpillingFreesOnlyOverflowSegments() {_		final IOManager ioMan = new IOManagerAsync()__		_		final TypeSerializer<ByteValue> serializer = ByteValueSerializer.INSTANCE__		final TypeComparator<ByteValue> buildComparator = new ValueComparator<>(true, ByteValue.class)__		final TypeComparator<ByteValue> probeComparator = new ValueComparator<>(true, ByteValue.class)__		_		@SuppressWarnings("unchecked")_		final TypePairComparator<ByteValue, ByteValue> pairComparator = Mockito.mock(TypePairComparator.class)__		_		try {_			final int pageSize = 32*1024__			final int numSegments = 34___			List<MemorySegment> memory = getMemory(numSegments, pageSize)___			MutableHashTable<ByteValue, ByteValue> table = new MutableHashTable<>(_					serializer, serializer, buildComparator, probeComparator,_					pairComparator, memory, ioMan, 1, false)___			table.open(new ByteValueIterator(100000000), new ByteValueIterator(1))__			_			table.close()__			_			checkNoTempFilesRemain(ioMan)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			ioMan.shutdown()__		}_	};this,tests,the,case,where,no,additional,partition,buffers,are,used,at,the,point,when,spilling,is,triggered,testing,that,overflow,bucket,buffers,are,taken,into,account,when,deciding,which,partition,to,spill;test,public,void,test,spilling,frees,only,overflow,segments,final,iomanager,io,man,new,iomanager,async,final,type,serializer,byte,value,serializer,byte,value,serializer,instance,final,type,comparator,byte,value,build,comparator,new,value,comparator,true,byte,value,class,final,type,comparator,byte,value,probe,comparator,new,value,comparator,true,byte,value,class,suppress,warnings,unchecked,final,type,pair,comparator,byte,value,byte,value,pair,comparator,mockito,mock,type,pair,comparator,class,try,final,int,page,size,32,1024,final,int,num,segments,34,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,byte,value,byte,value,table,new,mutable,hash,table,serializer,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,1,false,table,open,new,byte,value,iterator,100000000,new,byte,value,iterator,1,table,close,check,no,temp,files,remain,io,man,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,io,man,shutdown
HashTableTest -> @Test 	public void testSpillingFreesOnlyOverflowSegments();1453866659;This tests the case where no additional partition buffers are used at the point when spilling_is triggered, testing that overflow bucket buffers are taken into account when deciding which_partition to spill.;@Test_	public void testSpillingFreesOnlyOverflowSegments() {_		final IOManager ioMan = new IOManagerAsync()__		_		final TypeSerializer<ByteValue> serializer = ByteValueSerializer.INSTANCE__		final TypeComparator<ByteValue> buildComparator = new ValueComparator<>(true, ByteValue.class)__		final TypeComparator<ByteValue> probeComparator = new ValueComparator<>(true, ByteValue.class)__		_		@SuppressWarnings("unchecked")_		final TypePairComparator<ByteValue, ByteValue> pairComparator = Mockito.mock(TypePairComparator.class)__		_		try {_			final int pageSize = 32*1024__			final int numSegments = 34___			List<MemorySegment> memory = getMemory(numSegments, pageSize)___			MutableHashTable<ByteValue, ByteValue> table = new MutableHashTable<>(_					serializer, serializer, buildComparator, probeComparator,_					pairComparator, memory, ioMan, 1, false)___			table.open(new ByteValueIterator(100000000), new ByteValueIterator(1))__			_			table.close()__			_			checkNoTempFilesRemain(ioMan)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			ioMan.shutdown()__		}_	};this,tests,the,case,where,no,additional,partition,buffers,are,used,at,the,point,when,spilling,is,triggered,testing,that,overflow,bucket,buffers,are,taken,into,account,when,deciding,which,partition,to,spill;test,public,void,test,spilling,frees,only,overflow,segments,final,iomanager,io,man,new,iomanager,async,final,type,serializer,byte,value,serializer,byte,value,serializer,instance,final,type,comparator,byte,value,build,comparator,new,value,comparator,true,byte,value,class,final,type,comparator,byte,value,probe,comparator,new,value,comparator,true,byte,value,class,suppress,warnings,unchecked,final,type,pair,comparator,byte,value,byte,value,pair,comparator,mockito,mock,type,pair,comparator,class,try,final,int,page,size,32,1024,final,int,num,segments,34,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,byte,value,byte,value,table,new,mutable,hash,table,serializer,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,1,false,table,open,new,byte,value,iterator,100000000,new,byte,value,iterator,1,table,close,check,no,temp,files,remain,io,man,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,io,man,shutdown
HashTableTest -> @Test 	public void testSpillingFreesOnlyOverflowSegments();1513075800;This tests the case where no additional partition buffers are used at the point when spilling_is triggered, testing that overflow bucket buffers are taken into account when deciding which_partition to spill.;@Test_	public void testSpillingFreesOnlyOverflowSegments() {_		final IOManager ioMan = new IOManagerAsync()__		_		final TypeSerializer<ByteValue> serializer = ByteValueSerializer.INSTANCE__		final TypeComparator<ByteValue> buildComparator = new ValueComparator<>(true, ByteValue.class)__		final TypeComparator<ByteValue> probeComparator = new ValueComparator<>(true, ByteValue.class)__		_		@SuppressWarnings("unchecked")_		final TypePairComparator<ByteValue, ByteValue> pairComparator = Mockito.mock(TypePairComparator.class)__		_		try {_			final int pageSize = 32*1024__			final int numSegments = 34___			List<MemorySegment> memory = getMemory(numSegments, pageSize)___			MutableHashTable<ByteValue, ByteValue> table = new MutableHashTable<>(_					serializer, serializer, buildComparator, probeComparator,_					pairComparator, memory, ioMan, 1, false)___			table.open(new ByteValueIterator(100000000), new ByteValueIterator(1))__			_			table.close()__			_			checkNoTempFilesRemain(ioMan)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			ioMan.shutdown()__		}_	};this,tests,the,case,where,no,additional,partition,buffers,are,used,at,the,point,when,spilling,is,triggered,testing,that,overflow,bucket,buffers,are,taken,into,account,when,deciding,which,partition,to,spill;test,public,void,test,spilling,frees,only,overflow,segments,final,iomanager,io,man,new,iomanager,async,final,type,serializer,byte,value,serializer,byte,value,serializer,instance,final,type,comparator,byte,value,build,comparator,new,value,comparator,true,byte,value,class,final,type,comparator,byte,value,probe,comparator,new,value,comparator,true,byte,value,class,suppress,warnings,unchecked,final,type,pair,comparator,byte,value,byte,value,pair,comparator,mockito,mock,type,pair,comparator,class,try,final,int,page,size,32,1024,final,int,num,segments,34,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,byte,value,byte,value,table,new,mutable,hash,table,serializer,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,1,false,table,open,new,byte,value,iterator,100000000,new,byte,value,iterator,1,table,close,check,no,temp,files,remain,io,man,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,io,man,shutdown
HashTableTest -> @Test 	public void testSpillingWhenBuildingTableWithoutOverflow() throws Exception;1446633116;Tests that the MutableHashTable spills its partitions when creating the initial table_without overflow segments in the partitions. This means that the records are large.;@Test_	public void testSpillingWhenBuildingTableWithoutOverflow() throws Exception {_		final IOManager ioMan = new IOManagerAsync()___		final TypeSerializer<byte[]> serializer = BytePrimitiveArraySerializer.INSTANCE__		final TypeComparator<byte[]> buildComparator = new BytePrimitiveArrayComparator(true)__		final TypeComparator<byte[]> probeComparator = new BytePrimitiveArrayComparator(true)___		@SuppressWarnings("unchecked")_		final TypePairComparator<byte[], byte[]> pairComparator = new GenericPairComparator<>(_			new BytePrimitiveArrayComparator(true), new BytePrimitiveArrayComparator(true))___		final int pageSize = 128__		final int numSegments = 33___		List<MemorySegment> memory = getMemory(numSegments, pageSize)___		MutableHashTable<byte[], byte[]> table = new MutableHashTable<byte[], byte[]>(_			serializer,_			serializer,_			buildComparator,_			probeComparator,_			pairComparator,_			memory,_			ioMan,_			1,_			false)___		int numElements = 9___		table.open(_			new CombiningIterator<byte[]>(_				new ByteArrayIterator(numElements, 128,(byte) 0),_				new ByteArrayIterator(numElements, 128,(byte) 1)),_			new CombiningIterator<byte[]>(_				new ByteArrayIterator(1, 128,(byte) 0),_				new ByteArrayIterator(1, 128,(byte) 1)))___		while(table.nextRecord()) {_			MutableHashTable.HashBucketIterator<byte[], byte[]> iterator = table.getBuildSideIterator()___			int counter = 0___			while(iterator.next() != null) {_				counter++__			}__			_			Assert.assertEquals(numElements, counter)__		}__		table.close()__	};tests,that,the,mutable,hash,table,spills,its,partitions,when,creating,the,initial,table,without,overflow,segments,in,the,partitions,this,means,that,the,records,are,large;test,public,void,test,spilling,when,building,table,without,overflow,throws,exception,final,iomanager,io,man,new,iomanager,async,final,type,serializer,byte,serializer,byte,primitive,array,serializer,instance,final,type,comparator,byte,build,comparator,new,byte,primitive,array,comparator,true,final,type,comparator,byte,probe,comparator,new,byte,primitive,array,comparator,true,suppress,warnings,unchecked,final,type,pair,comparator,byte,byte,pair,comparator,new,generic,pair,comparator,new,byte,primitive,array,comparator,true,new,byte,primitive,array,comparator,true,final,int,page,size,128,final,int,num,segments,33,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,byte,byte,table,new,mutable,hash,table,byte,byte,serializer,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,1,false,int,num,elements,9,table,open,new,combining,iterator,byte,new,byte,array,iterator,num,elements,128,byte,0,new,byte,array,iterator,num,elements,128,byte,1,new,combining,iterator,byte,new,byte,array,iterator,1,128,byte,0,new,byte,array,iterator,1,128,byte,1,while,table,next,record,mutable,hash,table,hash,bucket,iterator,byte,byte,iterator,table,get,build,side,iterator,int,counter,0,while,iterator,next,null,counter,assert,assert,equals,num,elements,counter,table,close
HashTableTest -> @Test 	public void testSpillingWhenBuildingTableWithoutOverflow() throws Exception;1453866659;Tests that the MutableHashTable spills its partitions when creating the initial table_without overflow segments in the partitions. This means that the records are large.;@Test_	public void testSpillingWhenBuildingTableWithoutOverflow() throws Exception {_		final IOManager ioMan = new IOManagerAsync()___		final TypeSerializer<byte[]> serializer = BytePrimitiveArraySerializer.INSTANCE__		final TypeComparator<byte[]> buildComparator = new BytePrimitiveArrayComparator(true)__		final TypeComparator<byte[]> probeComparator = new BytePrimitiveArrayComparator(true)___		@SuppressWarnings("unchecked")_		final TypePairComparator<byte[], byte[]> pairComparator = new GenericPairComparator<>(_			new BytePrimitiveArrayComparator(true), new BytePrimitiveArrayComparator(true))___		final int pageSize = 128__		final int numSegments = 33___		List<MemorySegment> memory = getMemory(numSegments, pageSize)___		MutableHashTable<byte[], byte[]> table = new MutableHashTable<byte[], byte[]>(_			serializer,_			serializer,_			buildComparator,_			probeComparator,_			pairComparator,_			memory,_			ioMan,_			1,_			false)___		int numElements = 9___		table.open(_			new CombiningIterator<byte[]>(_				new ByteArrayIterator(numElements, 128,(byte) 0),_				new ByteArrayIterator(numElements, 128,(byte) 1)),_			new CombiningIterator<byte[]>(_				new ByteArrayIterator(1, 128,(byte) 0),_				new ByteArrayIterator(1, 128,(byte) 1)))___		while(table.nextRecord()) {_			MutableObjectIterator<byte[]> iterator = table.getBuildSideIterator()___			int counter = 0___			while(iterator.next() != null) {_				counter++__			}__			_			Assert.assertEquals(numElements, counter)__		}__		table.close()__	};tests,that,the,mutable,hash,table,spills,its,partitions,when,creating,the,initial,table,without,overflow,segments,in,the,partitions,this,means,that,the,records,are,large;test,public,void,test,spilling,when,building,table,without,overflow,throws,exception,final,iomanager,io,man,new,iomanager,async,final,type,serializer,byte,serializer,byte,primitive,array,serializer,instance,final,type,comparator,byte,build,comparator,new,byte,primitive,array,comparator,true,final,type,comparator,byte,probe,comparator,new,byte,primitive,array,comparator,true,suppress,warnings,unchecked,final,type,pair,comparator,byte,byte,pair,comparator,new,generic,pair,comparator,new,byte,primitive,array,comparator,true,new,byte,primitive,array,comparator,true,final,int,page,size,128,final,int,num,segments,33,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,byte,byte,table,new,mutable,hash,table,byte,byte,serializer,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,1,false,int,num,elements,9,table,open,new,combining,iterator,byte,new,byte,array,iterator,num,elements,128,byte,0,new,byte,array,iterator,num,elements,128,byte,1,new,combining,iterator,byte,new,byte,array,iterator,1,128,byte,0,new,byte,array,iterator,1,128,byte,1,while,table,next,record,mutable,object,iterator,byte,iterator,table,get,build,side,iterator,int,counter,0,while,iterator,next,null,counter,assert,assert,equals,num,elements,counter,table,close
HashTableTest -> @Test 	public void testSpillingWhenBuildingTableWithoutOverflow() throws Exception;1513075800;Tests that the MutableHashTable spills its partitions when creating the initial table_without overflow segments in the partitions. This means that the records are large.;@Test_	public void testSpillingWhenBuildingTableWithoutOverflow() throws Exception {_		final IOManager ioMan = new IOManagerAsync()___		try {_			final TypeSerializer<byte[]> serializer = BytePrimitiveArraySerializer.INSTANCE__			final TypeComparator<byte[]> buildComparator = new BytePrimitiveArrayComparator(true)__			final TypeComparator<byte[]> probeComparator = new BytePrimitiveArrayComparator(true)___			@SuppressWarnings("unchecked") final TypePairComparator<byte[], byte[]> pairComparator =_				new GenericPairComparator<>(_					new BytePrimitiveArrayComparator(true), new BytePrimitiveArrayComparator(true))___			final int pageSize = 128__			final int numSegments = 33___			List<MemorySegment> memory = getMemory(numSegments, pageSize)___			MutableHashTable<byte[], byte[]> table = new MutableHashTable<byte[], byte[]>(_				serializer,_				serializer,_				buildComparator,_				probeComparator,_				pairComparator,_				memory,_				ioMan,_				1,_				false)___			int numElements = 9___			table.open(_				new CombiningIterator<byte[]>(_					new ByteArrayIterator(numElements, 128, (byte) 0),_					new ByteArrayIterator(numElements, 128, (byte) 1)),_				new CombiningIterator<byte[]>(_					new ByteArrayIterator(1, 128, (byte) 0),_					new ByteArrayIterator(1, 128, (byte) 1)))___			while (table.nextRecord()) {_				MutableObjectIterator<byte[]> iterator = table.getBuildSideIterator()___				int counter = 0___				while (iterator.next() != null) {_					counter++__				}__				_				Assert.assertEquals(numElements, counter)__			}__			table.close()__		} finally {_			ioMan.shutdown()__		}_	};tests,that,the,mutable,hash,table,spills,its,partitions,when,creating,the,initial,table,without,overflow,segments,in,the,partitions,this,means,that,the,records,are,large;test,public,void,test,spilling,when,building,table,without,overflow,throws,exception,final,iomanager,io,man,new,iomanager,async,try,final,type,serializer,byte,serializer,byte,primitive,array,serializer,instance,final,type,comparator,byte,build,comparator,new,byte,primitive,array,comparator,true,final,type,comparator,byte,probe,comparator,new,byte,primitive,array,comparator,true,suppress,warnings,unchecked,final,type,pair,comparator,byte,byte,pair,comparator,new,generic,pair,comparator,new,byte,primitive,array,comparator,true,new,byte,primitive,array,comparator,true,final,int,page,size,128,final,int,num,segments,33,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,byte,byte,table,new,mutable,hash,table,byte,byte,serializer,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,1,false,int,num,elements,9,table,open,new,combining,iterator,byte,new,byte,array,iterator,num,elements,128,byte,0,new,byte,array,iterator,num,elements,128,byte,1,new,combining,iterator,byte,new,byte,array,iterator,1,128,byte,0,new,byte,array,iterator,1,128,byte,1,while,table,next,record,mutable,object,iterator,byte,iterator,table,get,build,side,iterator,int,counter,0,while,iterator,next,null,counter,assert,assert,equals,num,elements,counter,table,close,finally,io,man,shutdown
HashTableTest -> @Test 	public void testBufferMissingForProbing();1440607697;This tests a combination of values that lead to a corner case situation where memory_was missing and the computation deadlocked.;@Test_	public void testBufferMissingForProbing() {__		final IOManager ioMan = new IOManagerAsync()___		try {_			final int pageSize = 32*1024__			final int numSegments = 34__			final int numRecords = 3400__			final int recordLen = 270___			final byte[] payload = new byte[recordLen - 8 - 4]__			_			List<MemorySegment> memory = getMemory(numSegments, pageSize)__			_			MutableHashTable<Tuple2<Long, byte[]>, Long> table = new MutableHashTable<>(_					buildSerializer, probeSerializer, buildComparator, probeComparator,_					pairComparator, memory, ioMan, 16, false)__			_			table.open(new TupleBytesIterator(payload, numRecords), new LongIterator(10000))__			_			try {_				while (table.nextRecord()) {_					MutableHashTable.HashBucketIterator<Tuple2<Long, byte[]>, Long> matches = table.getBuildSideIterator()__					while (matches.next() != null)__				}_			}_			catch (RuntimeException e) {_				if (!e.getMessage().contains("exceeded maximum number of recursions")) {_					e.printStackTrace()__					fail("Test failed with unexpected exception")__				} _			}_			finally {_				table.close()__			}_			_			checkNoTempFilesRemain(ioMan)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			ioMan.shutdown()__		}_	};this,tests,a,combination,of,values,that,lead,to,a,corner,case,situation,where,memory,was,missing,and,the,computation,deadlocked;test,public,void,test,buffer,missing,for,probing,final,iomanager,io,man,new,iomanager,async,try,final,int,page,size,32,1024,final,int,num,segments,34,final,int,num,records,3400,final,int,record,len,270,final,byte,payload,new,byte,record,len,8,4,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,tuple2,long,byte,long,table,new,mutable,hash,table,build,serializer,probe,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,16,false,table,open,new,tuple,bytes,iterator,payload,num,records,new,long,iterator,10000,try,while,table,next,record,mutable,hash,table,hash,bucket,iterator,tuple2,long,byte,long,matches,table,get,build,side,iterator,while,matches,next,null,catch,runtime,exception,e,if,e,get,message,contains,exceeded,maximum,number,of,recursions,e,print,stack,trace,fail,test,failed,with,unexpected,exception,finally,table,close,check,no,temp,files,remain,io,man,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,io,man,shutdown
HashTableTest -> @Test 	public void testBufferMissingForProbing();1441738685;This tests a combination of values that lead to a corner case situation where memory_was missing and the computation deadlocked.;@Test_	public void testBufferMissingForProbing() {__		final IOManager ioMan = new IOManagerAsync()___		try {_			final int pageSize = 32*1024__			final int numSegments = 34__			final int numRecords = 3400__			final int recordLen = 270___			final byte[] payload = new byte[recordLen - 8 - 4]__			_			List<MemorySegment> memory = getMemory(numSegments, pageSize)__			_			MutableHashTable<Tuple2<Long, byte[]>, Long> table = new MutableHashTable<>(_					buildSerializer, probeSerializer, buildComparator, probeComparator,_					pairComparator, memory, ioMan, 16, false)__			_			table.open(new TupleBytesIterator(payload, numRecords), new LongIterator(10000))__			_			try {_				while (table.nextRecord()) {_					MutableHashTable.HashBucketIterator<Tuple2<Long, byte[]>, Long> matches = table.getBuildSideIterator()__					while (matches.next() != null)__				}_			}_			catch (RuntimeException e) {_				if (!e.getMessage().contains("exceeded maximum number of recursions")) {_					e.printStackTrace()__					fail("Test failed with unexpected exception")__				} _			}_			finally {_				table.close()__			}_			_			checkNoTempFilesRemain(ioMan)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			ioMan.shutdown()__		}_	};this,tests,a,combination,of,values,that,lead,to,a,corner,case,situation,where,memory,was,missing,and,the,computation,deadlocked;test,public,void,test,buffer,missing,for,probing,final,iomanager,io,man,new,iomanager,async,try,final,int,page,size,32,1024,final,int,num,segments,34,final,int,num,records,3400,final,int,record,len,270,final,byte,payload,new,byte,record,len,8,4,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,tuple2,long,byte,long,table,new,mutable,hash,table,build,serializer,probe,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,16,false,table,open,new,tuple,bytes,iterator,payload,num,records,new,long,iterator,10000,try,while,table,next,record,mutable,hash,table,hash,bucket,iterator,tuple2,long,byte,long,matches,table,get,build,side,iterator,while,matches,next,null,catch,runtime,exception,e,if,e,get,message,contains,exceeded,maximum,number,of,recursions,e,print,stack,trace,fail,test,failed,with,unexpected,exception,finally,table,close,check,no,temp,files,remain,io,man,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,io,man,shutdown
HashTableTest -> @Test 	public void testBufferMissingForProbing();1443528421;This tests a combination of values that lead to a corner case situation where memory_was missing and the computation deadlocked.;@Test_	public void testBufferMissingForProbing() {__		final IOManager ioMan = new IOManagerAsync()___		try {_			final int pageSize = 32*1024__			final int numSegments = 34__			final int numRecords = 3400__			final int recordLen = 270___			final byte[] payload = new byte[recordLen - 8 - 4]__			_			List<MemorySegment> memory = getMemory(numSegments, pageSize)__			_			MutableHashTable<Tuple2<Long, byte[]>, Long> table = new MutableHashTable<>(_					buildSerializer, probeSerializer, buildComparator, probeComparator,_					pairComparator, memory, ioMan, 16, false)__			_			table.open(new TupleBytesIterator(payload, numRecords), new LongIterator(10000))__			_			try {_				while (table.nextRecord()) {_					MutableHashTable.HashBucketIterator<Tuple2<Long, byte[]>, Long> matches = table.getBuildSideIterator()__					while (matches.next() != null)__				}_			}_			catch (RuntimeException e) {_				if (!e.getMessage().contains("exceeded maximum number of recursions")) {_					e.printStackTrace()__					fail("Test failed with unexpected exception")__				} _			}_			finally {_				table.close()__			}_			_			checkNoTempFilesRemain(ioMan)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			ioMan.shutdown()__		}_	};this,tests,a,combination,of,values,that,lead,to,a,corner,case,situation,where,memory,was,missing,and,the,computation,deadlocked;test,public,void,test,buffer,missing,for,probing,final,iomanager,io,man,new,iomanager,async,try,final,int,page,size,32,1024,final,int,num,segments,34,final,int,num,records,3400,final,int,record,len,270,final,byte,payload,new,byte,record,len,8,4,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,tuple2,long,byte,long,table,new,mutable,hash,table,build,serializer,probe,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,16,false,table,open,new,tuple,bytes,iterator,payload,num,records,new,long,iterator,10000,try,while,table,next,record,mutable,hash,table,hash,bucket,iterator,tuple2,long,byte,long,matches,table,get,build,side,iterator,while,matches,next,null,catch,runtime,exception,e,if,e,get,message,contains,exceeded,maximum,number,of,recursions,e,print,stack,trace,fail,test,failed,with,unexpected,exception,finally,table,close,check,no,temp,files,remain,io,man,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,io,man,shutdown
HashTableTest -> @Test 	public void testBufferMissingForProbing();1446633116;This tests a combination of values that lead to a corner case situation where memory_was missing and the computation deadlocked.;@Test_	public void testBufferMissingForProbing() {__		final IOManager ioMan = new IOManagerAsync()___		try {_			final int pageSize = 32*1024__			final int numSegments = 34__			final int numRecords = 3400__			final int recordLen = 270___			final byte[] payload = new byte[recordLen - 8 - 4]__			_			List<MemorySegment> memory = getMemory(numSegments, pageSize)__			_			MutableHashTable<Tuple2<Long, byte[]>, Long> table = new MutableHashTable<>(_					buildSerializer, probeSerializer, buildComparator, probeComparator,_					pairComparator, memory, ioMan, 16, false)__			_			table.open(new TupleBytesIterator(payload, numRecords), new LongIterator(10000))__			_			try {_				while (table.nextRecord()) {_					MutableHashTable.HashBucketIterator<Tuple2<Long, byte[]>, Long> matches = table.getBuildSideIterator()__					while (matches.next() != null)__				}_			}_			catch (RuntimeException e) {_				if (!e.getMessage().contains("exceeded maximum number of recursions")) {_					e.printStackTrace()__					fail("Test failed with unexpected exception")__				} _			}_			finally {_				table.close()__			}_			_			checkNoTempFilesRemain(ioMan)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			ioMan.shutdown()__		}_	};this,tests,a,combination,of,values,that,lead,to,a,corner,case,situation,where,memory,was,missing,and,the,computation,deadlocked;test,public,void,test,buffer,missing,for,probing,final,iomanager,io,man,new,iomanager,async,try,final,int,page,size,32,1024,final,int,num,segments,34,final,int,num,records,3400,final,int,record,len,270,final,byte,payload,new,byte,record,len,8,4,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,tuple2,long,byte,long,table,new,mutable,hash,table,build,serializer,probe,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,16,false,table,open,new,tuple,bytes,iterator,payload,num,records,new,long,iterator,10000,try,while,table,next,record,mutable,hash,table,hash,bucket,iterator,tuple2,long,byte,long,matches,table,get,build,side,iterator,while,matches,next,null,catch,runtime,exception,e,if,e,get,message,contains,exceeded,maximum,number,of,recursions,e,print,stack,trace,fail,test,failed,with,unexpected,exception,finally,table,close,check,no,temp,files,remain,io,man,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,io,man,shutdown
HashTableTest -> @Test 	public void testBufferMissingForProbing();1453866659;This tests a combination of values that lead to a corner case situation where memory_was missing and the computation deadlocked.;@Test_	public void testBufferMissingForProbing() {__		final IOManager ioMan = new IOManagerAsync()___		try {_			final int pageSize = 32*1024__			final int numSegments = 34__			final int numRecords = 3400__			final int recordLen = 270___			final byte[] payload = new byte[recordLen - 8 - 4]__			_			List<MemorySegment> memory = getMemory(numSegments, pageSize)__			_			MutableHashTable<Tuple2<Long, byte[]>, Long> table = new MutableHashTable<>(_					buildSerializer, probeSerializer, buildComparator, probeComparator,_					pairComparator, memory, ioMan, 16, false)__			_			table.open(new TupleBytesIterator(payload, numRecords), new LongIterator(10000))__			_			try {_				while (table.nextRecord()) {_					MutableObjectIterator<Tuple2<Long, byte[]>> matches = table.getBuildSideIterator()__					while (matches.next() != null)__				}_			}_			catch (RuntimeException e) {_				if (!e.getMessage().contains("exceeded maximum number of recursions")) {_					e.printStackTrace()__					fail("Test failed with unexpected exception")__				} _			}_			finally {_				table.close()__			}_			_			checkNoTempFilesRemain(ioMan)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			ioMan.shutdown()__		}_	};this,tests,a,combination,of,values,that,lead,to,a,corner,case,situation,where,memory,was,missing,and,the,computation,deadlocked;test,public,void,test,buffer,missing,for,probing,final,iomanager,io,man,new,iomanager,async,try,final,int,page,size,32,1024,final,int,num,segments,34,final,int,num,records,3400,final,int,record,len,270,final,byte,payload,new,byte,record,len,8,4,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,tuple2,long,byte,long,table,new,mutable,hash,table,build,serializer,probe,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,16,false,table,open,new,tuple,bytes,iterator,payload,num,records,new,long,iterator,10000,try,while,table,next,record,mutable,object,iterator,tuple2,long,byte,matches,table,get,build,side,iterator,while,matches,next,null,catch,runtime,exception,e,if,e,get,message,contains,exceeded,maximum,number,of,recursions,e,print,stack,trace,fail,test,failed,with,unexpected,exception,finally,table,close,check,no,temp,files,remain,io,man,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,io,man,shutdown
HashTableTest -> @Test 	public void testBufferMissingForProbing();1513075800;This tests a combination of values that lead to a corner case situation where memory_was missing and the computation deadlocked.;@Test_	public void testBufferMissingForProbing() {__		final IOManager ioMan = new IOManagerAsync()___		try {_			final int pageSize = 32*1024__			final int numSegments = 34__			final int numRecords = 3400__			final int recordLen = 270___			final byte[] payload = new byte[recordLen - 8 - 4]__			_			List<MemorySegment> memory = getMemory(numSegments, pageSize)__			_			MutableHashTable<Tuple2<Long, byte[]>, Long> table = new MutableHashTable<>(_					buildSerializer, probeSerializer, buildComparator, probeComparator,_					pairComparator, memory, ioMan, 16, false)__			_			table.open(new TupleBytesIterator(payload, numRecords), new LongIterator(10000))__			_			try {_				while (table.nextRecord()) {_					MutableObjectIterator<Tuple2<Long, byte[]>> matches = table.getBuildSideIterator()__					while (matches.next() != null)__				}_			}_			catch (RuntimeException e) {_				if (!e.getMessage().contains("exceeded maximum number of recursions")) {_					e.printStackTrace()__					fail("Test failed with unexpected exception")__				} _			}_			finally {_				table.close()__			}_			_			checkNoTempFilesRemain(ioMan)__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			ioMan.shutdown()__		}_	};this,tests,a,combination,of,values,that,lead,to,a,corner,case,situation,where,memory,was,missing,and,the,computation,deadlocked;test,public,void,test,buffer,missing,for,probing,final,iomanager,io,man,new,iomanager,async,try,final,int,page,size,32,1024,final,int,num,segments,34,final,int,num,records,3400,final,int,record,len,270,final,byte,payload,new,byte,record,len,8,4,list,memory,segment,memory,get,memory,num,segments,page,size,mutable,hash,table,tuple2,long,byte,long,table,new,mutable,hash,table,build,serializer,probe,serializer,build,comparator,probe,comparator,pair,comparator,memory,io,man,16,false,table,open,new,tuple,bytes,iterator,payload,num,records,new,long,iterator,10000,try,while,table,next,record,mutable,object,iterator,tuple2,long,byte,matches,table,get,build,side,iterator,while,matches,next,null,catch,runtime,exception,e,if,e,get,message,contains,exceeded,maximum,number,of,recursions,e,print,stack,trace,fail,test,failed,with,unexpected,exception,finally,table,close,check,no,temp,files,remain,io,man,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,io,man,shutdown
