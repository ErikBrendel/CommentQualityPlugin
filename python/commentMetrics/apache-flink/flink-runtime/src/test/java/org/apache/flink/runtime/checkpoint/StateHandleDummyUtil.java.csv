commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;18;/**  * Creates a new test {@link OperatorStreamStateHandle} with a given number of randomly created named states.  */ ;/**  * Creates a new test {@link OperatorStreamStateHandle} with a given number of randomly created named states.  */ public static OperatorStateHandle createNewOperatorStateHandle(int numNamedStates, Random random) {     Map<String, OperatorStateHandle.StateMetaInfo> operatorStateMetaData = new HashMap<>(numNamedStates).     byte[] streamData = new byte[numNamedStates * 4].     random.nextBytes(streamData).     long off = 0.     for (int i = 0. i < numNamedStates. ++i) {         long[] offsets = new long[4].         for (int o = 0. o < offsets.length. ++o) {             offsets[o] = off++.         }         OperatorStateHandle.StateMetaInfo metaInfo = new OperatorStateHandle.StateMetaInfo(offsets, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE).         operatorStateMetaData.put(String.valueOf(UUID.randomUUID()), metaInfo).     }     ByteStreamStateHandle byteStreamStateHandle = new ByteStreamStateHandle(String.valueOf(UUID.randomUUID()), streamData).     return new OperatorStreamStateHandle(operatorStateMetaData, byteStreamStateHandle). }
true;public,static;1;3;/**  * Creates a new test {@link KeyedStateHandle} for the given key-group.  */ ;/**  * Creates a new test {@link KeyedStateHandle} for the given key-group.  */ public static KeyedStateHandle createNewKeyedStateHandle(KeyGroupRange keyGroupRange) {     return new DummyKeyedStateHandle(keyGroupRange). }
true;public,static;1;21;/**  * Creates a deep copy of the given {@link OperatorStreamStateHandle}.  */ ;/**  * Creates a deep copy of the given {@link OperatorStreamStateHandle}.  */ public static OperatorStateHandle deepDummyCopy(OperatorStateHandle original) {     if (original == null) {         return null.     }     ByteStreamStateHandle stateHandle = (ByteStreamStateHandle) original.getDelegateStateHandle().     ByteStreamStateHandle stateHandleCopy = new ByteStreamStateHandle(String.valueOf(stateHandle.getHandleName()), stateHandle.getData().clone()).     Map<String, OperatorStateHandle.StateMetaInfo> offsets = original.getStateNameToPartitionOffsets().     Map<String, OperatorStateHandle.StateMetaInfo> offsetsCopy = new HashMap<>(offsets.size()).     for (Map.Entry<String, OperatorStateHandle.StateMetaInfo> entry : offsets.entrySet()) {         OperatorStateHandle.StateMetaInfo metaInfo = entry.getValue().         OperatorStateHandle.StateMetaInfo metaInfoCopy = new OperatorStateHandle.StateMetaInfo(metaInfo.getOffsets(), metaInfo.getDistributionMode()).         offsetsCopy.put(String.valueOf(entry.getKey()), metaInfoCopy).     }     return new OperatorStreamStateHandle(offsetsCopy, stateHandleCopy). }
true;public,static;1;10;/**  * Creates deep copy of the given {@link KeyedStateHandle}.  */ ;/**  * Creates deep copy of the given {@link KeyedStateHandle}.  */ public static KeyedStateHandle deepDummyCopy(KeyedStateHandle original) {     if (original == null) {         return null.     }     KeyGroupRange keyGroupRange = original.getKeyGroupRange().     return new DummyKeyedStateHandle(new KeyGroupRange(keyGroupRange.getStartKeyGroup(), keyGroupRange.getEndKeyGroup())). }
false;public;0;4;;@Override public KeyGroupRange getKeyGroupRange() {     return keyGroupRange. }
false;public;1;4;;@Override public KeyedStateHandle getIntersection(KeyGroupRange keyGroupRange) {     return new DummyKeyedStateHandle(this.keyGroupRange.getIntersection(keyGroupRange)). }
false;public;1;3;;@Override public void registerSharedStates(SharedStateRegistry stateRegistry) { }
false;public;0;3;;@Override public void discardState() throws Exception { }
false;public;0;4;;@Override public long getStateSize() {     return 0L. }
