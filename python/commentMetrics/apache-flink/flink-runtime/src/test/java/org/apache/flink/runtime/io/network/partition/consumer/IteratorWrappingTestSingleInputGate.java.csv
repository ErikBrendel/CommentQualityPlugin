commented;modifiers;parameterAmount;loc;comment;code
false;public;0;19;;@Override public Optional<BufferAndAvailability> getBufferAvailability() throws IOException {     if (hasData) {         serializer.serializeRecord(reuse).         BufferBuilder bufferBuilder = createBufferBuilder(bufferSize).         serializer.copyToBufferBuilder(bufferBuilder).         hasData = inputIterator.next(reuse) != null.         // Call getCurrentBuffer to ensure size is set         return Optional.of(new BufferAndAvailability(buildSingleBuffer(bufferBuilder), true, 0)).     } else {         inputChannel.setReleased().         return Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(EndOfPartitionEvent.INSTANCE), false, 0)).     } }
false;private;1;37;;private IteratorWrappingTestSingleInputGate<T> wrapIterator(MutableObjectIterator<T> iterator) throws IOException, InterruptedException {     inputIterator = iterator.     serializer = new SpanningRecordSerializer<T>().     // The input iterator can produce an infinite stream. That's why we have to serialize each     // record on demand and cannot do it upfront.     final BufferAndAvailabilityProvider answer = new BufferAndAvailabilityProvider() {          private boolean hasData = inputIterator.next(reuse) != null.          @Override         public Optional<BufferAndAvailability> getBufferAvailability() throws IOException {             if (hasData) {                 serializer.serializeRecord(reuse).                 BufferBuilder bufferBuilder = createBufferBuilder(bufferSize).                 serializer.copyToBufferBuilder(bufferBuilder).                 hasData = inputIterator.next(reuse) != null.                 // Call getCurrentBuffer to ensure size is set                 return Optional.of(new BufferAndAvailability(buildSingleBuffer(bufferBuilder), true, 0)).             } else {                 inputChannel.setReleased().                 return Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(EndOfPartitionEvent.INSTANCE), false, 0)).             }         }     }.     inputChannel.addBufferAndAvailability(answer).     inputGate.setInputChannel(new IntermediateResultPartitionID(), inputChannel).     return this. }
false;public;0;5;;public IteratorWrappingTestSingleInputGate<T> notifyNonEmpty() {     inputGate.notifyChannelNonEmpty(inputChannel).     return this. }
