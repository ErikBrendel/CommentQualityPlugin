commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void setUp() {     this.memoryManager = new MemoryManager(MEMORY_SIZE, 1, PAGE_SIZE, MemoryType.HEAP, false).     this.random = new Random(RANDOM_SEED). }
false;public;0;8;;@After public void tearDown() {     if (!this.memoryManager.verifyEmpty()) {         fail("Memory manager is not complete empty and valid at the end of the test.").     }     this.memoryManager = null.     this.random = null. }
false;public;0;24;;@Test public void allocateAllSingle() {     try {         final AbstractInvokable mockInvoke = new DummyInvokable().         List<MemorySegment> segments = new ArrayList<MemorySegment>().         try {             for (int i = 0. i < NUM_PAGES. i++) {                 segments.add(this.memoryManager.allocatePages(mockInvoke, 1).get(0)).             }         } catch (MemoryAllocationException e) {             fail("Unable to allocate memory").         }         for (MemorySegment seg : segments) {             this.memoryManager.release(seg).         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;21;;@Test public void allocateAllMulti() {     try {         final AbstractInvokable mockInvoke = new DummyInvokable().         final List<MemorySegment> segments = new ArrayList<MemorySegment>().         try {             for (int i = 0. i < NUM_PAGES / 2. i++) {                 segments.addAll(this.memoryManager.allocatePages(mockInvoke, 2)).             }         } catch (MemoryAllocationException e) {             Assert.fail("Unable to allocate memory").         }         this.memoryManager.release(segments).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;39;;@Test public void allocateMultipleOwners() {     final int numOwners = 17.     try {         AbstractInvokable[] owners = new AbstractInvokable[numOwners].         @SuppressWarnings("unchecked")         List<MemorySegment>[] mems = (List<MemorySegment>[]) new List<?>[numOwners].         for (int i = 0. i < numOwners. i++) {             owners[i] = new DummyInvokable().             mems[i] = new ArrayList<MemorySegment>(64).         }         // allocate all memory to the different owners         for (int i = 0. i < NUM_PAGES. i++) {             final int owner = this.random.nextInt(numOwners).             mems[owner].addAll(this.memoryManager.allocatePages(owners[owner], 1)).         }         // free one owner at a time         for (int i = 0. i < numOwners. i++) {             this.memoryManager.releaseAll(owners[i]).             owners[i] = null.             Assert.assertTrue("Released memory segments have not been destroyed.", allMemorySegmentsFreed(mems[i])).             mems[i] = null.             // check that the owner owners were not affected             for (int k = i + 1. k < numOwners. k++) {                 Assert.assertTrue("Non-released memory segments are accidentaly destroyed.", allMemorySegmentsValid(mems[k])).             }         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;24;;@Test public void allocateTooMuch() {     try {         final AbstractInvokable mockInvoke = new DummyInvokable().         List<MemorySegment> segs = this.memoryManager.allocatePages(mockInvoke, NUM_PAGES).         try {             this.memoryManager.allocatePages(mockInvoke, 1).             Assert.fail("Expected MemoryAllocationException.").         } catch (MemoryAllocationException maex) {         // expected         }         Assert.assertTrue("The previously allocated segments were not valid any more.", allMemorySegmentsValid(segs)).         this.memoryManager.releaseAll(mockInvoke).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;private;1;8;;private boolean allMemorySegmentsValid(List<MemorySegment> memSegs) {     for (MemorySegment seg : memSegs) {         if (seg.isFreed()) {             return false.         }     }     return true. }
false;private;1;8;;private boolean allMemorySegmentsFreed(List<MemorySegment> memSegs) {     for (MemorySegment seg : memSegs) {         if (!seg.isFreed()) {             return false.         }     }     return true. }
