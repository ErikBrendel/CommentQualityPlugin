commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void setupLocalBufferPool() {     networkBufferPool = new NetworkBufferPool(numBuffers, memorySegmentSize).     localBufferPool = new LocalBufferPool(networkBufferPool, 1).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()). }
false;public;0;12;;@After public void destroyAndVerifyAllBuffersReturned() throws IOException {     if (!localBufferPool.isDestroyed()) {         localBufferPool.lazyDestroy().     }     String msg = "Did not return all buffers to memory segment pool after test.".     assertEquals(msg, numBuffers, networkBufferPool.getNumberOfAvailableMemorySegments()).     // no other local buffer pools used than the one above, but call just in case     networkBufferPool.destroyAllBufferPools().     networkBufferPool.destroy(). }
false;public,static;0;4;;@AfterClass public static void shutdownExecutor() {     executor.shutdownNow(). }
false;public;0;26;;@Test public void testRequestMoreThanAvailable() throws IOException {     localBufferPool.setNumBuffers(numBuffers).     List<Buffer> requests = new ArrayList<Buffer>(numBuffers).     for (int i = 1. i <= numBuffers. i++) {         Buffer buffer = localBufferPool.requestBuffer().         assertEquals(i, getNumRequestedFromMemorySegmentPool()).         assertNotNull(buffer).         requests.add(buffer).     }     {         // One more...         Buffer buffer = localBufferPool.requestBuffer().         assertEquals(numBuffers, getNumRequestedFromMemorySegmentPool()).         assertNull(buffer).     }     for (Buffer buffer : requests) {         buffer.recycleBuffer().     } }
false;public;0;12;;@Test public void testRequestAfterDestroy() throws IOException {     localBufferPool.lazyDestroy().     try {         localBufferPool.requestBuffer().         fail("Call should have failed with an IllegalStateException").     } catch (IllegalStateException e) {     // we expect exactly that     } }
false;public;0;20;;@Test public void testRecycleAfterDestroy() throws IOException {     localBufferPool.setNumBuffers(numBuffers).     List<Buffer> requests = new ArrayList<Buffer>(numBuffers).     for (int i = 0. i < numBuffers. i++) {         requests.add(localBufferPool.requestBuffer()).     }     localBufferPool.lazyDestroy().     // All buffers have been requested, but can not be returned yet.     assertEquals(numBuffers, getNumRequestedFromMemorySegmentPool()).     // Recycle should return buffers to memory segment pool     for (Buffer buffer : requests) {         buffer.recycleBuffer().     } }
false;public;0;28;;@Test public void testRecycleExcessBuffersAfterRecycling() throws Exception {     localBufferPool.setNumBuffers(numBuffers).     List<Buffer> requests = new ArrayList<Buffer>(numBuffers).     // Request all buffers     for (int i = 1. i <= numBuffers. i++) {         requests.add(localBufferPool.requestBuffer()).     }     assertEquals(numBuffers, getNumRequestedFromMemorySegmentPool()).     // Reduce the number of buffers in the local pool     localBufferPool.setNumBuffers(numBuffers / 2).     // Need to wait until we recycle the buffers     assertEquals(numBuffers, getNumRequestedFromMemorySegmentPool()).     for (int i = 1. i < numBuffers / 2. i++) {         requests.remove(0).recycleBuffer().         assertEquals(numBuffers - i, getNumRequestedFromMemorySegmentPool()).     }     for (Buffer buffer : requests) {         buffer.recycleBuffer().     } }
false;public;0;22;;@Test public void testRecycleExcessBuffersAfterChangingNumBuffers() throws Exception {     localBufferPool.setNumBuffers(numBuffers).     List<Buffer> requests = new ArrayList<Buffer>(numBuffers).     // Request all buffers     for (int i = 1. i <= numBuffers. i++) {         requests.add(localBufferPool.requestBuffer()).     }     // Recycle all     for (Buffer buffer : requests) {         buffer.recycleBuffer().     }     assertEquals(numBuffers, localBufferPool.getNumberOfAvailableMemorySegments()).     localBufferPool.setNumBuffers(numBuffers / 2).     assertEquals(numBuffers / 2, localBufferPool.getNumberOfAvailableMemorySegments()). }
false;public;0;6;;@Test(expected = IllegalArgumentException.class) public void testSetLessThanRequiredNumBuffers() throws IOException {     localBufferPool.setNumBuffers(1).     localBufferPool.setNumBuffers(0). }
false;public;0;29;;// ------------------------------------------------------------------------ // Pending requests and integration with buffer futures // ------------------------------------------------------------------------ @Test public void testPendingRequestWithListenersAfterRecycle() throws Exception {     BufferListener twoTimesListener = createBufferListener(2).     BufferListener oneTimeListener = createBufferListener(1).     localBufferPool.setNumBuffers(2).     Buffer available1 = localBufferPool.requestBuffer().     Buffer available2 = localBufferPool.requestBuffer().     assertNull(localBufferPool.requestBuffer()).     assertTrue(localBufferPool.addBufferListener(twoTimesListener)).     assertTrue(localBufferPool.addBufferListener(oneTimeListener)).     // Recycle the first buffer to notify both of the above listeners once     // and the twoTimesListener will be added into the registeredListeners     // queue of buffer pool again     available1.recycleBuffer().     verify(oneTimeListener, times(1)).notifyBufferAvailable(any(Buffer.class)).     verify(twoTimesListener, times(1)).notifyBufferAvailable(any(Buffer.class)).     // Recycle the second buffer to only notify the twoTimesListener     available2.recycleBuffer().     verify(oneTimeListener, times(1)).notifyBufferAvailable(any(Buffer.class)).     verify(twoTimesListener, times(2)).notifyBufferAvailable(any(Buffer.class)). }
false;public;0;20;;@Test @SuppressWarnings("unchecked") public void testCancelPendingRequestsAfterDestroy() throws IOException {     BufferListener listener = Mockito.mock(BufferListener.class).     localBufferPool.setNumBuffers(1).     Buffer available = localBufferPool.requestBuffer().     Buffer unavailable = localBufferPool.requestBuffer().     assertNull(unavailable).     localBufferPool.addBufferListener(listener).     localBufferPool.lazyDestroy().     available.recycleBuffer().     verify(listener, times(1)).notifyBufferDestroyed(). }
false;public;0;17;;// ------------------------------------------------------------------------ // Concurrent requests // ------------------------------------------------------------------------ @Test @SuppressWarnings("unchecked") public void testConcurrentRequestRecycle() throws ExecutionException, InterruptedException, IOException {     int numConcurrentTasks = 128.     int numBuffersToRequestPerTask = 1024.     localBufferPool.setNumBuffers(numConcurrentTasks).     Future<Boolean>[] taskResults = new Future[numConcurrentTasks].     for (int i = 0. i < numConcurrentTasks. i++) {         taskResults[i] = executor.submit(new BufferRequesterTask(localBufferPool, numBuffersToRequestPerTask)).     }     for (int i = 0. i < numConcurrentTasks. i++) {         assertTrue(taskResults[i].get()).     } }
true;public;0;24;// Request all buffers in a blocking manner. ;// Request all buffers in a blocking manner. @Override public List<Buffer> call() throws Exception {     final List<Buffer> requested = Lists.newArrayList().     // Request all available buffers     for (int i = 0. i < numberOfBuffers. i++) {         requested.add(localBufferPool.requestBufferBlocking()).     }     // Notify that we've requested all buffers     sync.countDown().     // the request or more likely during the request).     try {         localBufferPool.requestBufferBlocking().         fail("Call should have failed with an IllegalStateException").     } catch (IllegalStateException e) {     // we expect exactly that     }     return requested. }
false;public;0;54;;@Test public void testDestroyDuringBlockingRequest() throws Exception {     // Config     final int numberOfBuffers = 1.     localBufferPool.setNumBuffers(numberOfBuffers).     final CountDownLatch sync = new CountDownLatch(1).     final Callable<List<Buffer>> requester = new Callable<List<Buffer>>() {          // Request all buffers in a blocking manner.         @Override         public List<Buffer> call() throws Exception {             final List<Buffer> requested = Lists.newArrayList().             // Request all available buffers             for (int i = 0. i < numberOfBuffers. i++) {                 requested.add(localBufferPool.requestBufferBlocking()).             }             // Notify that we've requested all buffers             sync.countDown().             // the request or more likely during the request).             try {                 localBufferPool.requestBufferBlocking().                 fail("Call should have failed with an IllegalStateException").             } catch (IllegalStateException e) {             // we expect exactly that             }             return requested.         }     }.     Future<List<Buffer>> f = executor.submit(requester).     sync.await().     localBufferPool.lazyDestroy().     // Increase the likelihood that the requested is currently in the request call     Thread.sleep(50).     // This should return immediately if everything works as expected     List<Buffer> requestedBuffers = f.get(60, TimeUnit.SECONDS).     for (Buffer buffer : requestedBuffers) {         buffer.recycleBuffer().     } }
false;public;0;57;;@Test public void testBoundedBuffer() throws Exception {     localBufferPool.lazyDestroy().     localBufferPool = new LocalBufferPool(networkBufferPool, 1, 2).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()).     assertEquals(2, localBufferPool.getMaxNumberOfMemorySegments()).     Buffer buffer1, buffer2.     // check min number of buffers:     localBufferPool.setNumBuffers(1).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()).     assertNotNull(buffer1 = localBufferPool.requestBuffer()).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()).     assertNull(localBufferPool.requestBuffer()).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()).     buffer1.recycleBuffer().     assertEquals(1, localBufferPool.getNumberOfAvailableMemorySegments()).     // check max number of buffers:     localBufferPool.setNumBuffers(2).     assertEquals(1, localBufferPool.getNumberOfAvailableMemorySegments()).     assertNotNull(buffer1 = localBufferPool.requestBuffer()).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()).     assertNotNull(buffer2 = localBufferPool.requestBuffer()).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()).     assertNull(localBufferPool.requestBuffer()).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()).     buffer1.recycleBuffer().     assertEquals(1, localBufferPool.getNumberOfAvailableMemorySegments()).     buffer2.recycleBuffer().     assertEquals(2, localBufferPool.getNumberOfAvailableMemorySegments()).     // try to set too large buffer size:     localBufferPool.setNumBuffers(3).     assertEquals(2, localBufferPool.getNumberOfAvailableMemorySegments()).     assertNotNull(buffer1 = localBufferPool.requestBuffer()).     assertEquals(1, localBufferPool.getNumberOfAvailableMemorySegments()).     assertNotNull(buffer2 = localBufferPool.requestBuffer()).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()).     assertNull(localBufferPool.requestBuffer()).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()).     buffer1.recycleBuffer().     assertEquals(1, localBufferPool.getNumberOfAvailableMemorySegments()).     buffer2.recycleBuffer().     assertEquals(2, localBufferPool.getNumberOfAvailableMemorySegments()).     // decrease size again     localBufferPool.setNumBuffers(1).     assertEquals(1, localBufferPool.getNumberOfAvailableMemorySegments()).     assertNotNull(buffer1 = localBufferPool.requestBuffer()).     assertEquals(0, localBufferPool.getNumberOfAvailableMemorySegments()).     assertNull(localBufferPool.requestBuffer()).     buffer1.recycleBuffer().     assertEquals(1, localBufferPool.getNumberOfAvailableMemorySegments()). }
false;private;0;3;;// ------------------------------------------------------------------------ // Helpers // ------------------------------------------------------------------------ private int getNumRequestedFromMemorySegmentPool() {     return networkBufferPool.getTotalNumberOfMemorySegments() - networkBufferPool.getNumberOfAvailableMemorySegments(). }
false;public;1;10;;@Override public NotificationResult notifyBufferAvailable(Buffer buffer) {     int newCount = times.incrementAndGet().     buffer.recycleBuffer().     if (newCount < notificationTimes) {         return NotificationResult.BUFFER_USED_NEED_MORE.     } else {         return NotificationResult.BUFFER_USED_NO_NEED_MORE.     } }
false;public;0;3;;@Override public void notifyBufferDestroyed() { }
false;private;1;20;;private BufferListener createBufferListener(int notificationTimes) {     return spy(new BufferListener() {          AtomicInteger times = new AtomicInteger(0).          @Override         public NotificationResult notifyBufferAvailable(Buffer buffer) {             int newCount = times.incrementAndGet().             buffer.recycleBuffer().             if (newCount < notificationTimes) {                 return NotificationResult.BUFFER_USED_NEED_MORE.             } else {                 return NotificationResult.BUFFER_USED_NO_NEED_MORE.             }         }          @Override         public void notifyBufferDestroyed() {         }     }). }
false;public;0;14;;@Override public Boolean call() throws Exception {     try {         for (int i = 0. i < numBuffersToRequest. i++) {             Buffer buffer = bufferProvider.requestBufferBlocking().             buffer.recycleBuffer().         }     } catch (Throwable t) {         return false.     }     return true. }
