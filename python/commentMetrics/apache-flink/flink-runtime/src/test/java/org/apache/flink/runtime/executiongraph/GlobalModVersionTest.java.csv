commented;modifiers;parameterAmount;loc;comment;code
true;public;0;44;/**  * Tests that failures during a global cancellation are not handed to the local  * failover strategy.  */ ;/**  * Tests that failures during a global cancellation are not handed to the local  * failover strategy.  */ @Test public void testNoLocalFailoverWhileCancelling() throws Exception {     final FailoverStrategy mockStrategy = mock(FailoverStrategy.class).     final ExecutionGraph graph = createSampleGraph(mockStrategy).     final ExecutionVertex testVertex = getRandomVertex(graph).     graph.scheduleForExecution().     assertEquals(JobStatus.RUNNING, graph.getState()).     assertEquals(1L, graph.getGlobalModVersion()).     // wait until everything is running     for (ExecutionVertex v : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {         final Execution exec = v.getCurrentExecutionAttempt().         waitUntilExecutionState(exec, ExecutionState.DEPLOYING, 1000).         exec.switchToRunning().         assertEquals(ExecutionState.RUNNING, exec.getState()).     }     // now cancel the job     graph.cancel().     assertEquals(2L, graph.getGlobalModVersion()).     // everything should be cancelling     for (ExecutionVertex v : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {         final Execution exec = v.getCurrentExecutionAttempt().         assertEquals(ExecutionState.CANCELING, exec.getState()).     }     // let a vertex fail     testVertex.getCurrentExecutionAttempt().fail(new Exception("test exception")).     // all cancellations are done now     for (ExecutionVertex v : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {         final Execution exec = v.getCurrentExecutionAttempt().         exec.completeCancelling().     }     assertEquals(JobStatus.CANCELED, graph.getTerminationFuture().get()).     // no failure notification at all     verify(mockStrategy, times(0)).onTaskFailure(any(Execution.class), any(Throwable.class)). }
true;public;0;49;/**  * Tests that failures during a global failover are not handed to the local  * failover strategy.  */ ;/**  * Tests that failures during a global failover are not handed to the local  * failover strategy.  */ @Test public void testNoLocalFailoverWhileFailing() throws Exception {     final FailoverStrategy mockStrategy = mock(FailoverStrategy.class).     final ExecutionGraph graph = createSampleGraph(mockStrategy).     final ExecutionVertex testVertex = getRandomVertex(graph).     graph.scheduleForExecution().     assertEquals(JobStatus.RUNNING, graph.getState()).     // wait until everything is running     for (ExecutionVertex v : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {         final Execution exec = v.getCurrentExecutionAttempt().         waitUntilExecutionState(exec, ExecutionState.DEPLOYING, 1000).         exec.switchToRunning().         assertEquals(ExecutionState.RUNNING, exec.getState()).     }     // now send the job into global failover     graph.failGlobal(new Exception("global failover")).     assertEquals(JobStatus.FAILING, graph.getState()).     assertEquals(2L, graph.getGlobalModVersion()).     // another attempt to fail global should not do anything     graph.failGlobal(new Exception("should be ignored")).     assertEquals(JobStatus.FAILING, graph.getState()).     assertEquals(2L, graph.getGlobalModVersion()).     // everything should be cancelling     for (ExecutionVertex v : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {         final Execution exec = v.getCurrentExecutionAttempt().         assertEquals(ExecutionState.CANCELING, exec.getState()).     }     // let a vertex fail     testVertex.getCurrentExecutionAttempt().fail(new Exception("test exception")).     // all cancellations are done now     for (ExecutionVertex v : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {         final Execution exec = v.getCurrentExecutionAttempt().         exec.completeCancelling().     }     assertEquals(JobStatus.RESTARTING, graph.getState()).     // no failure notification at all     verify(mockStrategy, times(0)).onTaskFailure(any(Execution.class), any(Throwable.class)). }
false;private;1;30;;// ------------------------------------------------------------------------ // utilities // ------------------------------------------------------------------------ private ExecutionGraph createSampleGraph(FailoverStrategy failoverStrategy) throws Exception {     final JobID jid = new JobID().     final int parallelism = new Random().nextInt(10) + 1.     final SimpleSlotProvider slotProvider = new SimpleSlotProvider(jid, parallelism).     // build a simple execution graph with on job vertex, parallelism 2     final ExecutionGraph graph = new ExecutionGraph(new DummyJobInformation(jid, "test job"), TestingUtils.defaultExecutor(), TestingUtils.defaultExecutor(), Time.seconds(10), new InfiniteDelayRestartStrategy(), new CustomStrategy(failoverStrategy), slotProvider).     graph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread()).     JobVertex jv = new JobVertex("test vertex").     jv.setInvokableClass(NoOpInvokable.class).     jv.setParallelism(parallelism).     JobGraph jg = new JobGraph(jid, "testjob", jv).     graph.attachJobGraph(jg.getVerticesSortedTopologicallyFromSources()).     return graph. }
false;private,static;1;4;;private static ExecutionVertex getRandomVertex(ExecutionGraph eg) {     final ExecutionVertex[] vertices = eg.getVerticesTopologically().iterator().next().getTaskVertices().     return vertices[new Random().nextInt(vertices.length)]. }
false;public;1;4;;@Override public FailoverStrategy create(ExecutionGraph executionGraph) {     return failoverStrategy. }
