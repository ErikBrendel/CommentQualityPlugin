commented;modifiers;parameterAmount;loc;comment;code
false;public;0;26;;// -------------------------------------------------------------------------------------------- // Canceling in different states // -------------------------------------------------------------------------------------------- @Test public void testCancelFromCreated() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         assertEquals(ExecutionState.CREATED, vertex.getExecutionState()).         vertex.cancel().         assertEquals(ExecutionState.CANCELED, vertex.getExecutionState()).         assertNull(vertex.getFailureCause()).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELED) > 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;27;;@Test public void testCancelFromScheduled() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         setVertexState(vertex, ExecutionState.SCHEDULED).         assertEquals(ExecutionState.SCHEDULED, vertex.getExecutionState()).         vertex.cancel().         assertEquals(ExecutionState.CANCELED, vertex.getExecutionState()).         assertNull(vertex.getFailureCause()).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELED) > 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;33;;@Test public void testCancelFromRunning() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid, new DirectScheduledExecutorService()).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         LogicalSlot slot = new TestingLogicalSlot(new CancelSequenceSimpleAckingTaskManagerGateway(1)).         setVertexResource(vertex, slot).         setVertexState(vertex, ExecutionState.RUNNING).         assertEquals(ExecutionState.RUNNING, vertex.getExecutionState()).         vertex.cancel().         // response by task manager once actually canceled         vertex.getCurrentExecutionAttempt().completeCancelling().         assertEquals(ExecutionState.CANCELED, vertex.getExecutionState()).         assertFalse(slot.isAlive()).         assertNull(vertex.getFailureCause()).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELED) > 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;42;;@Test public void testRepeatedCancelFromRunning() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid, new DirectScheduledExecutorService()).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         LogicalSlot slot = new TestingLogicalSlot(new CancelSequenceSimpleAckingTaskManagerGateway(1)).         setVertexResource(vertex, slot).         setVertexState(vertex, ExecutionState.RUNNING).         assertEquals(ExecutionState.RUNNING, vertex.getExecutionState()).         vertex.cancel().         assertEquals(ExecutionState.CANCELING, vertex.getExecutionState()).         vertex.cancel().         assertEquals(ExecutionState.CANCELING, vertex.getExecutionState()).         // callback by TaskManager after canceling completes         vertex.getCurrentExecutionAttempt().completeCancelling().         assertEquals(ExecutionState.CANCELED, vertex.getExecutionState()).         assertFalse(slot.isAlive()).         assertNull(vertex.getFailureCause()).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELED) > 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;30;;@Test public void testCancelFromRunningDidNotFindTask() {     // this may happen when the task finished or failed while the call was in progress     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid, new DirectScheduledExecutorService()).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         LogicalSlot slot = new TestingLogicalSlot(new CancelSequenceSimpleAckingTaskManagerGateway(1)).         setVertexResource(vertex, slot).         setVertexState(vertex, ExecutionState.RUNNING).         assertEquals(ExecutionState.RUNNING, vertex.getExecutionState()).         vertex.cancel().         assertEquals(ExecutionState.CANCELING, vertex.getExecutionState()).         assertNull(vertex.getFailureCause()).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;30;;@Test public void testCancelCallFails() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid, new DirectScheduledExecutorService()).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         LogicalSlot slot = new TestingLogicalSlot(new CancelSequenceSimpleAckingTaskManagerGateway(0)).         setVertexResource(vertex, slot).         setVertexState(vertex, ExecutionState.RUNNING).         assertEquals(ExecutionState.RUNNING, vertex.getExecutionState()).         vertex.cancel().         // Callback fails, leading to CANCELED         assertEquals(ExecutionState.CANCELED, vertex.getExecutionState()).         assertFalse(slot.isAlive()).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.CANCELING) > 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;21;;@Test public void testSendCancelAndReceiveFail() throws Exception {     final ExecutionGraph graph = ExecutionGraphTestUtils.createSimpleTestGraph().     graph.scheduleForExecution().     ExecutionGraphTestUtils.switchAllVerticesToRunning(graph).     assertEquals(JobStatus.RUNNING, graph.getState()).     final ExecutionVertex[] vertices = graph.getVerticesTopologically().iterator().next().getTaskVertices().     assertEquals(vertices.length, graph.getRegisteredExecutions().size()).     final Execution exec = vertices[3].getCurrentExecutionAttempt().     exec.cancel().     assertEquals(ExecutionState.CANCELING, exec.getState()).     exec.markFailed(new Exception("test")).     assertTrue(exec.getState() == ExecutionState.FAILED || exec.getState() == ExecutionState.CANCELED).     assertFalse(exec.getAssignedResource().isAlive()).     assertEquals(vertices.length - 1, exec.getVertex().getExecutionGraph().getRegisteredExecutions().size()). }
false;public;0;40;;// -------------------------------------------------------------------------------------------- // Actions after a vertex has been canceled or while canceling // -------------------------------------------------------------------------------------------- @Test public void testScheduleOrDeployAfterCancel() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         setVertexState(vertex, ExecutionState.CANCELED).         assertEquals(ExecutionState.CANCELED, vertex.getExecutionState()).         // 1)         // scheduling after being canceled should be tolerated (no exception) because         // it can occur as the result of races         {             vertex.scheduleForExecution(new ProgrammedSlotProvider(1), false, LocationPreferenceConstraint.ALL, Collections.emptySet()).             assertEquals(ExecutionState.CANCELED, vertex.getExecutionState()).         }         // the scheduler (or any caller) needs to know that the slot should be released         try {             Instance instance = getInstance(new ActorTaskManagerGateway(DummyActorGateway.INSTANCE)).             SimpleSlot slot = instance.allocateSimpleSlot().             vertex.deployToSlot(slot).             fail("Method should throw an exception").         } catch (IllegalStateException e) {             assertEquals(ExecutionState.CANCELED, vertex.getExecutionState()).         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;59;;@Test public void testActionsWhileCancelling() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid).         // scheduling while canceling is an illegal state transition         try {             ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).             setVertexState(vertex, ExecutionState.CANCELING).             vertex.scheduleForExecution(new ProgrammedSlotProvider(1), false, LocationPreferenceConstraint.ALL, Collections.emptySet()).         } catch (Exception e) {             fail("should not throw an exception").         }         // deploying while in canceling state is illegal (should immediately go to canceled)         try {             ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).             setVertexState(vertex, ExecutionState.CANCELING).             Instance instance = getInstance(new ActorTaskManagerGateway(DummyActorGateway.INSTANCE)).             SimpleSlot slot = instance.allocateSimpleSlot().             vertex.deployToSlot(slot).             fail("Method should throw an exception").         } catch (IllegalStateException e) {         // that is what we expect         }         // fail while canceling         {             ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).             Instance instance = getInstance(new ActorTaskManagerGateway(DummyActorGateway.INSTANCE)).             SimpleSlot slot = instance.allocateSimpleSlot().             setVertexResource(vertex, slot).             setVertexState(vertex, ExecutionState.CANCELING).             Exception failureCause = new Exception("test exception").             vertex.fail(failureCause).             assertEquals(ExecutionState.CANCELED, vertex.getExecutionState()).             assertTrue(slot.isReleased()).         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;10;;@Override public CompletableFuture<Acknowledge> cancelTask(ExecutionAttemptID executionAttemptID, Time timeout) {     index++.     if (index >= successfulOperations) {         return FutureUtils.completedExceptionally(new IOException("Rpc call fails")).     } else {         return CompletableFuture.completedFuture(Acknowledge.get()).     } }
