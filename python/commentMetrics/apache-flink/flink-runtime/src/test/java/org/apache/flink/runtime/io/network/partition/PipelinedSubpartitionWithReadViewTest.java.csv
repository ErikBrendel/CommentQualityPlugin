commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void setup() throws IOException {     final ResultPartition parent = mock(ResultPartition.class).     subpartition = new PipelinedSubpartition(0, parent).     availablityListener = new AwaitableBufferAvailablityListener().     readView = subpartition.createReadView(availablityListener). }
false;public;0;5;;@After public void tearDown() {     readView.releaseAllResources().     subpartition.release(). }
false;public;0;6;;@Test(expected = IllegalStateException.class) public void testAddTwoNonFinishedBuffer() {     subpartition.add(createBufferBuilder().createBufferConsumer()).     subpartition.add(createBufferBuilder().createBufferConsumer()).     assertNull(readView.getNextBuffer()). }
false;public;0;18;;@Test public void testAddEmptyNonFinishedBuffer() {     assertEquals(0, availablityListener.getNumNotifications()).     BufferBuilder bufferBuilder = createBufferBuilder().     subpartition.add(bufferBuilder.createBufferConsumer()).     assertEquals(0, availablityListener.getNumNotifications()).     assertNull(readView.getNextBuffer()).     bufferBuilder.finish().     bufferBuilder = createBufferBuilder().     subpartition.add(bufferBuilder.createBufferConsumer()).     // notification from finishing previous buffer.     assertEquals(1, availablityListener.getNumNotifications()).     assertNull(readView.getNextBuffer()).     assertEquals(1, subpartition.getBuffersInBacklog()). }
false;public;0;12;;@Test public void testAddNonEmptyNotFinishedBuffer() throws Exception {     assertEquals(0, availablityListener.getNumNotifications()).     BufferBuilder bufferBuilder = createBufferBuilder().     bufferBuilder.appendAndCommit(ByteBuffer.allocate(1024)).     subpartition.add(bufferBuilder.createBufferConsumer()).     // note that since the buffer builder is not finished, there is still a retained instance!     assertNextBuffer(readView, 1024, false, 1, false, false).     assertEquals(1, subpartition.getBuffersInBacklog()). }
true;public;0;11;/**  * Normally moreAvailable flag from InputChannel should ignore non finished BufferConsumers, otherwise we would  * busy loop on the unfinished BufferConsumers.  */ ;/**  * Normally moreAvailable flag from InputChannel should ignore non finished BufferConsumers, otherwise we would  * busy loop on the unfinished BufferConsumers.  */ @Test public void testUnfinishedBufferBehindFinished() throws Exception {     // finished     subpartition.add(createFilledBufferConsumer(1025)).     // not finished     subpartition.add(createFilledBufferBuilder(1024).createBufferConsumer()).     assertThat(availablityListener.getNumNotifications(), greaterThan(0L)).     assertNextBuffer(readView, 1025, false, 1, false, true).     // not notified, but we could still access the unfinished buffer     assertNextBuffer(readView, 1024, false, 1, false, false).     assertNoNextBuffer(readView). }
true;public;0;14;/**  * After flush call unfinished BufferConsumers should be reported as available, otherwise we might not flush some  * of the data.  */ ;/**  * After flush call unfinished BufferConsumers should be reported as available, otherwise we might not flush some  * of the data.  */ @Test public void testFlushWithUnfinishedBufferBehindFinished() throws Exception {     // finished     subpartition.add(createFilledBufferConsumer(1025)).     // not finished     subpartition.add(createFilledBufferBuilder(1024).createBufferConsumer()).     long oldNumNotifications = availablityListener.getNumNotifications().     subpartition.flush().     // buffer queue is > 1, should already be notified, no further notification necessary     assertThat(oldNumNotifications, greaterThan(0L)).     assertEquals(oldNumNotifications, availablityListener.getNumNotifications()).     assertNextBuffer(readView, 1025, true, 1, false, true).     assertNextBuffer(readView, 1024, false, 1, false, false).     assertNoNextBuffer(readView). }
true;public;0;22;/**  * A flush call with a buffer size of 1 should always notify consumers (unless already flushed).  */ ;/**  * A flush call with a buffer size of 1 should always notify consumers (unless already flushed).  */ @Test public void testFlushWithUnfinishedBufferBehindFinished2() throws Exception {     // no buffers -> no notification or any other effects     subpartition.flush().     assertEquals(0, availablityListener.getNumNotifications()).     // finished     subpartition.add(createFilledBufferConsumer(1025)).     // not finished     subpartition.add(createFilledBufferBuilder(1024).createBufferConsumer()).     assertNextBuffer(readView, 1025, false, 1, false, true).     long oldNumNotifications = availablityListener.getNumNotifications().     subpartition.flush().     // buffer queue is 1 again -> need to flush     assertEquals(oldNumNotifications + 1, availablityListener.getNumNotifications()).     subpartition.flush().     // calling again should not flush again     assertEquals(oldNumNotifications + 1, availablityListener.getNumNotifications()).     assertNextBuffer(readView, 1024, false, 1, false, false).     assertNoNextBuffer(readView). }
false;public;0;19;;@Test public void testMultipleEmptyBuffers() throws Exception {     assertEquals(0, availablityListener.getNumNotifications()).     subpartition.add(createFilledBufferConsumer(0)).     assertEquals(1, availablityListener.getNumNotifications()).     subpartition.add(createFilledBufferConsumer(0)).     assertEquals(2, availablityListener.getNumNotifications()).     subpartition.add(createFilledBufferConsumer(0)).     assertEquals(2, availablityListener.getNumNotifications()).     assertEquals(3, subpartition.getBuffersInBacklog()).     subpartition.add(createFilledBufferConsumer(1024)).     assertEquals(2, availablityListener.getNumNotifications()).     assertNextBuffer(readView, 1024, false, 0, false, true). }
false;public;0;5;;@Test public void testEmptyFlush() {     subpartition.flush().     assertEquals(0, availablityListener.getNumNotifications()). }
false;public;0;79;;@Test public void testBasicPipelinedProduceConsumeLogic() throws Exception {     // Empty => should return null     assertFalse(readView.nextBufferIsEvent()).     assertNoNextBuffer(readView).     // also after getNextBuffer()     assertFalse(readView.nextBufferIsEvent()).     assertEquals(0, availablityListener.getNumNotifications()).     // Add data to the queue...     subpartition.add(createFilledBufferConsumer(BUFFER_SIZE)).     assertFalse(readView.nextBufferIsEvent()).     assertEquals(1, subpartition.getTotalNumberOfBuffers()).     assertEquals(1, subpartition.getBuffersInBacklog()).     // only updated when getting the buffer     assertEquals(0, subpartition.getTotalNumberOfBytes()).     // ...should have resulted in a notification     assertEquals(1, availablityListener.getNumNotifications()).     // ...and one available result     assertNextBuffer(readView, BUFFER_SIZE, false, subpartition.getBuffersInBacklog() - 1, false, true).     // only updated when getting the buffer     assertEquals(BUFFER_SIZE, subpartition.getTotalNumberOfBytes()).     assertEquals(0, subpartition.getBuffersInBacklog()).     assertNoNextBuffer(readView).     assertEquals(0, subpartition.getBuffersInBacklog()).     // Add data to the queue...     subpartition.add(createFilledBufferConsumer(BUFFER_SIZE)).     assertFalse(readView.nextBufferIsEvent()).     assertEquals(2, subpartition.getTotalNumberOfBuffers()).     assertEquals(1, subpartition.getBuffersInBacklog()).     // only updated when getting the buffer     assertEquals(BUFFER_SIZE, subpartition.getTotalNumberOfBytes()).     assertEquals(2, availablityListener.getNumNotifications()).     assertNextBuffer(readView, BUFFER_SIZE, false, subpartition.getBuffersInBacklog() - 1, false, true).     // only updated when getting the buffer     assertEquals(2 * BUFFER_SIZE, subpartition.getTotalNumberOfBytes()).     assertEquals(0, subpartition.getBuffersInBacklog()).     assertNoNextBuffer(readView).     assertEquals(0, subpartition.getBuffersInBacklog()).     // some tests with events     // fill with: buffer, event, and buffer     subpartition.add(createFilledBufferConsumer(BUFFER_SIZE)).     assertFalse(readView.nextBufferIsEvent()).     subpartition.add(createEventBufferConsumer(BUFFER_SIZE)).     assertFalse(readView.nextBufferIsEvent()).     subpartition.add(createFilledBufferConsumer(BUFFER_SIZE)).     assertFalse(readView.nextBufferIsEvent()).     assertEquals(5, subpartition.getTotalNumberOfBuffers()).     // two buffers (events don't count)     assertEquals(2, subpartition.getBuffersInBacklog()).     // only updated when getting the buffer     assertEquals(2 * BUFFER_SIZE, subpartition.getTotalNumberOfBytes()).     assertEquals(4, availablityListener.getNumNotifications()).     // the first buffer     assertNextBuffer(readView, BUFFER_SIZE, true, subpartition.getBuffersInBacklog() - 1, true, true).     // only updated when getting the buffer     assertEquals(3 * BUFFER_SIZE, subpartition.getTotalNumberOfBytes()).     assertEquals(1, subpartition.getBuffersInBacklog()).     // the event     assertNextEvent(readView, BUFFER_SIZE, null, true, subpartition.getBuffersInBacklog(), false, true).     // only updated when getting the buffer     assertEquals(4 * BUFFER_SIZE, subpartition.getTotalNumberOfBytes()).     assertEquals(1, subpartition.getBuffersInBacklog()).     // the remaining buffer     assertNextBuffer(readView, BUFFER_SIZE, false, subpartition.getBuffersInBacklog() - 1, false, true).     // only updated when getting the buffer     assertEquals(5 * BUFFER_SIZE, subpartition.getTotalNumberOfBytes()).     assertEquals(0, subpartition.getBuffersInBacklog()).     // nothing more     assertNoNextBuffer(readView).     assertEquals(0, subpartition.getBuffersInBacklog()).     assertEquals(5, subpartition.getTotalNumberOfBuffers()).     assertEquals(5 * BUFFER_SIZE, subpartition.getTotalNumberOfBytes()).     assertEquals(4, availablityListener.getNumNotifications()). }
