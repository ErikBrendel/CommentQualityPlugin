commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setupClass() {     rpcService = new TestingRpcService(). }
false;public;0;4;;@Before public void setup() {     testingFatalErrorHandler = new TestingFatalErrorHandler(). }
false;public;0;6;;@After public void teardown() throws Exception {     if (testingFatalErrorHandler != null) {         testingFatalErrorHandler.rethrowError().     } }
false;public,static;0;7;;@AfterClass public static void teardownClass() throws ExecutionException, InterruptedException {     if (rpcService != null) {         rpcService.stopService().get().         rpcService = null.     } }
true;public;0;40;/**  * Tests that interleaved granting and revoking of the leadership won't interfere  * with the job recovery and the resulting internal state of the Dispatcher.  */ ;/**  * Tests that interleaved granting and revoking of the leadership won't interfere  * with the job recovery and the resulting internal state of the Dispatcher.  */ @Test public void testGrantingRevokingLeadership() throws Exception {     final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices().     final JobGraph nonEmptyJobGraph = createNonEmptyJobGraph().     final SubmittedJobGraph submittedJobGraph = new SubmittedJobGraph(nonEmptyJobGraph).     final OneShotLatch enterGetJobIdsLatch = new OneShotLatch().     final OneShotLatch proceedGetJobIdsLatch = new OneShotLatch().     highAvailabilityServices.setSubmittedJobGraphStore(new BlockingSubmittedJobGraphStore(submittedJobGraph, enterGetJobIdsLatch, proceedGetJobIdsLatch)).     final TestingLeaderElectionService dispatcherLeaderElectionService = new TestingLeaderElectionService().     highAvailabilityServices.setDispatcherLeaderElectionService(dispatcherLeaderElectionService).     final BlockingQueue<DispatcherId> fencingTokens = new ArrayBlockingQueue<>(2).     final HATestingDispatcher dispatcher = createDispatcherWithObservableFencingTokens(highAvailabilityServices, fencingTokens).     dispatcher.start().     try {         // wait until the election service has been started         dispatcherLeaderElectionService.getStartFuture().get().         final UUID leaderId = UUID.randomUUID().         dispatcherLeaderElectionService.isLeader(leaderId).         dispatcherLeaderElectionService.notLeader().         final DispatcherId firstFencingToken = fencingTokens.take().         assertThat(firstFencingToken, equalTo(NULL_FENCING_TOKEN)).         enterGetJobIdsLatch.await().         proceedGetJobIdsLatch.trigger().         assertThat(dispatcher.getNumberJobs(timeout).get(), is(0)).     } finally {         RpcUtils.terminateRpcEndpoint(dispatcher, timeout).     } }
true;public;0;41;/**  * Tests that all JobManagerRunner are terminated if the leadership of the  * Dispatcher is revoked.  */ ;/**  * Tests that all JobManagerRunner are terminated if the leadership of the  * Dispatcher is revoked.  */ @Test public void testRevokeLeadershipTerminatesJobManagerRunners() throws Exception {     final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService().     final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServicesBuilder().setDispatcherLeaderElectionService(leaderElectionService).build().     final ArrayBlockingQueue<DispatcherId> fencingTokens = new ArrayBlockingQueue<>(2).     final HATestingDispatcher dispatcher = createDispatcherWithObservableFencingTokens(highAvailabilityServices, fencingTokens).     dispatcher.start().     try {         // grant leadership and submit a single job         final DispatcherId expectedDispatcherId = DispatcherId.generate().         leaderElectionService.isLeader(expectedDispatcherId.toUUID()).get().         assertThat(fencingTokens.take(), is(equalTo(expectedDispatcherId))).         final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).         final CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(createNonEmptyJobGraph(), timeout).         submissionFuture.get().         assertThat(dispatcher.getNumberJobs(timeout).get(), is(1)).         // revoke the leadership --> this should stop all running JobManagerRunners         leaderElectionService.notLeader().         assertThat(fencingTokens.take(), is(equalTo(NULL_FENCING_TOKEN))).         assertThat(dispatcher.getNumberJobs(timeout).get(), is(0)).     } finally {         RpcUtils.terminateRpcEndpoint(dispatcher, timeout).     } }
true;public;0;58;/**  * Tests that a Dispatcher does not remove the JobGraph from the submitted job graph store  * when losing leadership and recovers it when regaining leadership.  */ ;/**  * Tests that a Dispatcher does not remove the JobGraph from the submitted job graph store  * when losing leadership and recovers it when regaining leadership.  */ @Test public void testJobRecoveryWhenChangingLeadership() throws Exception {     final InMemorySubmittedJobGraphStore submittedJobGraphStore = new InMemorySubmittedJobGraphStore().     final CompletableFuture<JobID> recoveredJobFuture = new CompletableFuture<>().     submittedJobGraphStore.setRecoverJobGraphFunction((jobID, jobIDSubmittedJobGraphMap) -> {         recoveredJobFuture.complete(jobID).         return jobIDSubmittedJobGraphMap.get(jobID).     }).     final TestingLeaderElectionService leaderElectionService = new TestingLeaderElectionService().     final TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServicesBuilder().setSubmittedJobGraphStore(submittedJobGraphStore).setDispatcherLeaderElectionService(leaderElectionService).build().     final ArrayBlockingQueue<DispatcherId> fencingTokens = new ArrayBlockingQueue<>(2).     final HATestingDispatcher dispatcher = createDispatcherWithObservableFencingTokens(highAvailabilityServices, fencingTokens).     dispatcher.start().     try {         // grant leadership and submit a single job         final DispatcherId expectedDispatcherId = DispatcherId.generate().         leaderElectionService.isLeader(expectedDispatcherId.toUUID()).get().         assertThat(fencingTokens.take(), is(equalTo(expectedDispatcherId))).         final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class).         final JobGraph jobGraph = createNonEmptyJobGraph().         final CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(jobGraph, timeout).         submissionFuture.get().         final JobID jobId = jobGraph.getJobID().         assertThat(submittedJobGraphStore.contains(jobId), is(true)).         // revoke the leadership --> this should stop all running JobManagerRunners         leaderElectionService.notLeader().         assertThat(fencingTokens.take(), is(equalTo(NULL_FENCING_TOKEN))).         assertThat(submittedJobGraphStore.contains(jobId), is(true)).         assertThat(recoveredJobFuture.isDone(), is(false)).         // re-grant leadership         leaderElectionService.isLeader(DispatcherId.generate().toUUID()).         assertThat(recoveredJobFuture.get(), is(equalTo(jobId))).     } finally {         RpcUtils.terminateRpcEndpoint(dispatcher, timeout).     } }
true;public;0;17;/**  * Tests that a fatal error is reported if the job recovery fails.  */ ;/**  * Tests that a fatal error is reported if the job recovery fails.  */ @Test public void testFailingRecoveryIsAFatalError() throws Exception {     final String exceptionMessage = "Job recovery test failure.".     final Supplier<Exception> exceptionSupplier = () -> new FlinkException(exceptionMessage).     final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServicesBuilder().setSubmittedJobGraphStore(new FailingSubmittedJobGraphStore(exceptionSupplier)).build().     final HATestingDispatcher dispatcher = createDispatcher(haServices).     dispatcher.start().     final Throwable failure = testingFatalErrorHandler.getErrorFuture().get().     assertThat(ExceptionUtils.findThrowableWithMessage(failure, exceptionMessage).isPresent(), is(true)).     testingFatalErrorHandler.clearError(). }
false;private;2;4;;@Nonnull private HATestingDispatcher createDispatcherWithObservableFencingTokens(HighAvailabilityServices highAvailabilityServices, Queue<DispatcherId> fencingTokens) throws Exception {     return createDispatcher(highAvailabilityServices, fencingTokens, createTestingJobManagerRunnerFactory()). }
false;private;0;4;;@Nonnull private TestingJobManagerRunnerFactory createTestingJobManagerRunnerFactory() {     return new TestingJobManagerRunnerFactory(new CompletableFuture<>(), new CompletableFuture<>(), CompletableFuture.completedFuture(null)). }
false;private;1;6;;private HATestingDispatcher createDispatcher(HighAvailabilityServices haServices) throws Exception {     return createDispatcher(haServices, new ArrayDeque<>(1), createTestingJobManagerRunnerFactory()). }
false;private;3;23;;@Nonnull private HATestingDispatcher createDispatcher(HighAvailabilityServices highAvailabilityServices, @Nonnull Queue<DispatcherId> fencingTokens, JobManagerRunnerFactory jobManagerRunnerFactory) throws Exception {     final Configuration configuration = new Configuration().     TestingResourceManagerGateway resourceManagerGateway = new TestingResourceManagerGateway().     return new HATestingDispatcher(rpcService, UUID.randomUUID().toString(), configuration, highAvailabilityServices, () -> CompletableFuture.completedFuture(resourceManagerGateway), new BlobServer(configuration, new VoidBlobStore()), new HeartbeatServices(1000L, 1000L), UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(), null, new MemoryArchivedExecutionGraphStore(), jobManagerRunnerFactory, testingFatalErrorHandler, fencingTokens). }
false;static;0;9;;@Nonnull static JobGraph createNonEmptyJobGraph() {     final JobVertex noOpVertex = new JobVertex("NoOp vertex").     noOpVertex.setInvokableClass(NoOpInvokable.class).     final JobGraph jobGraph = new JobGraph(noOpVertex).     jobGraph.setAllowQueuedScheduling(true).     return jobGraph. }
false;protected;1;13;;@Override protected void setFencingToken(@Nullable DispatcherId newFencingToken) {     super.setFencingToken(newFencingToken).     final DispatcherId fencingToken.     if (newFencingToken == null) {         fencingToken = NULL_FENCING_TOKEN.     } else {         fencingToken = newFencingToken.     }     fencingTokens.offer(fencingToken). }
false;public;1;3;;@Override public void start(SubmittedJobGraphListener jobGraphListener) { }
false;public;0;3;;@Override public void stop() { }
false;public;1;7;;@Nullable @Override public SubmittedJobGraph recoverJobGraph(JobID jobId) {     Preconditions.checkArgument(jobId.equals(submittedJobGraph.getJobId())).     return submittedJobGraph. }
false;public;1;4;;@Override public void putJobGraph(SubmittedJobGraph jobGraph) {     throw new UnsupportedOperationException("Should not be called."). }
false;public;1;4;;@Override public void removeJobGraph(JobID jobId) {     throw new UnsupportedOperationException("Should not be called."). }
false;public;1;2;;@Override public void releaseJobGraph(JobID jobId) { }
false;public;0;6;;@Override public Collection<JobID> getJobIds() throws Exception {     enterGetJobIdsLatch.trigger().     proceedGetJobIdsLatch.await().     return Collections.singleton(submittedJobGraph.getJobId()). }
false;public;1;4;;@Override public void start(SubmittedJobGraphListener jobGraphListener) { }
false;public;0;4;;@Override public void stop() { }
false;public;1;5;;@Nullable @Override public SubmittedJobGraph recoverJobGraph(JobID jobId) throws Exception {     throw exceptionSupplier.get(). }
false;public;1;4;;@Override public void putJobGraph(SubmittedJobGraph jobGraph) { }
false;public;1;4;;@Override public void removeJobGraph(JobID jobId) { }
false;public;1;4;;@Override public void releaseJobGraph(JobID jobId) { }
false;public;0;4;;@Override public Collection<JobID> getJobIds() {     return Collections.singleton(jobId). }
