commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Test public void testIntRecordsSpanningMultipleSegments() throws Exception {     final int segmentSize = 1.     final int numValues = 10.     testSerializationRoundTrip(Util.randomRecords(numValues, SerializationTestTypeFactory.INT), segmentSize). }
false;public;0;7;;@Test public void testIntRecordsWithAlignedBuffers() throws Exception {     final int segmentSize = 64.     final int numValues = 64.     testSerializationRoundTrip(Util.randomRecords(numValues, SerializationTestTypeFactory.INT), segmentSize). }
false;public;0;7;;@Test public void testIntRecordsWithUnalignedBuffers() throws Exception {     final int segmentSize = 31.     final int numValues = 248.     testSerializationRoundTrip(Util.randomRecords(numValues, SerializationTestTypeFactory.INT), segmentSize). }
false;public;0;7;;@Test public void testRandomRecords() throws Exception {     final int segmentSize = 127.     final int numValues = 10000.     testSerializationRoundTrip(Util.randomRecords(numValues), segmentSize). }
false;public;0;19;;@Test public void testHandleMixedLargeRecords() throws Exception {     final int numValues = 99.     final int segmentSize = 32 * 1024.     List<SerializationTestType> originalRecords = new ArrayList<>((numValues + 1) / 2).     LargeObjectType genLarge = new LargeObjectType().     Random rnd = new Random().     for (int i = 0. i < numValues. i++) {         if (i % 2 == 0) {             originalRecords.add(new IntType(42)).         } else {             originalRecords.add(genLarge.getRandom(rnd)).         }     }     testSerializationRoundTrip(originalRecords, segmentSize). }
false;private;2;8;;// ----------------------------------------------------------------------------------------------------------------- private void testSerializationRoundTrip(Iterable<SerializationTestType> records, int segmentSize) throws Exception {     RecordSerializer<SerializationTestType> serializer = new SpanningRecordSerializer<>().     RecordDeserializer<SerializationTestType> deserializer = new SpillingAdaptiveSpanningRecordDeserializer<>(new String[] { tempFolder.getRoot().getAbsolutePath() }).     testSerializationRoundTrip(records, segmentSize, serializer, deserializer). }
true;private,static;4;53;/**  * Iterates over the provided records and tests whether {@link SpanningRecordSerializer} and {@link RecordDeserializer}  * interact as expected.  *  * <p>Only a single {@link MemorySegment} will be allocated.  *  * @param records records to test  * @param segmentSize size for the {@link MemorySegment}  */ ;/**  * Iterates over the provided records and tests whether {@link SpanningRecordSerializer} and {@link RecordDeserializer}  * interact as expected.  *  * <p>Only a single {@link MemorySegment} will be allocated.  *  * @param records records to test  * @param segmentSize size for the {@link MemorySegment}  */ private static void testSerializationRoundTrip(Iterable<SerializationTestType> records, int segmentSize, RecordSerializer<SerializationTestType> serializer, RecordDeserializer<SerializationTestType> deserializer) throws Exception {     final ArrayDeque<SerializationTestType> serializedRecords = new ArrayDeque<>().     // -------------------------------------------------------------------------------------------------------------     BufferAndSerializerResult serializationResult = setNextBufferForSerializer(serializer, segmentSize).     int numRecords = 0.     for (SerializationTestType record : records) {         serializedRecords.add(record).         numRecords++.         // serialize record         serializer.serializeRecord(record).         if (serializer.copyToBufferBuilder(serializationResult.getBufferBuilder()).isFullBuffer()) {             // buffer is full => start deserializing             deserializer.setNextBuffer(serializationResult.buildBuffer()).             numRecords -= DeserializationUtils.deserializeRecords(serializedRecords, deserializer).             // move buffers as long as necessary (for long records)             while ((serializationResult = setNextBufferForSerializer(serializer, segmentSize)).isFullBuffer()) {                 deserializer.setNextBuffer(serializationResult.buildBuffer()).             }         }     }     // deserialize left over records     deserializer.setNextBuffer(serializationResult.buildBuffer()).     while (!serializedRecords.isEmpty()) {         SerializationTestType expected = serializedRecords.poll().         SerializationTestType actual = expected.getClass().newInstance().         RecordDeserializer.DeserializationResult result = deserializer.getNextRecord(actual).         Assert.assertTrue(result.isFullRecord()).         Assert.assertEquals(expected, actual).         numRecords--.     }     // assert that all records have been serialized and deserialized     Assert.assertEquals(0, numRecords).     Assert.assertFalse(serializer.hasSerializedData()).     Assert.assertFalse(deserializer.hasUnfinishedData()). }
false;private,static;2;15;;private static BufferAndSerializerResult setNextBufferForSerializer(RecordSerializer<SerializationTestType> serializer, int segmentSize) throws IOException {     // create a bufferBuilder with some random starting offset to properly test handling buffer slices in the     // deserialization code.     int startingOffset = segmentSize > 2 ? RANDOM.nextInt(segmentSize / 2) : 0.     BufferBuilder bufferBuilder = createFilledBufferBuilder(segmentSize + startingOffset, startingOffset).     BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer().     bufferConsumer.build().recycleBuffer().     return new BufferAndSerializerResult(bufferBuilder, bufferConsumer, serializer.copyToBufferBuilder(bufferBuilder)). }
false;public;0;3;;public BufferBuilder getBufferBuilder() {     return bufferBuilder. }
false;public;0;3;;public Buffer buildBuffer() {     return buildSingleBuffer(bufferConsumer). }
false;public;0;3;;public boolean isFullBuffer() {     return serializationResult.isFullBuffer(). }
