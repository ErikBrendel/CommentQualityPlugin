commented;modifiers;parameterAmount;loc;comment;code
true;public;0;162;/**  * This test tests that the restarting time metric correctly displays restarting times.  */ ;/**  * This test tests that the restarting time metric correctly displays restarting times.  */ @Test public void testExecutionGraphRestartTimeMetric() throws JobException, IOException, InterruptedException {     final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor().     try {         // setup execution graph with mocked scheduling logic         int parallelism = 1.         JobVertex jobVertex = new JobVertex("TestVertex").         jobVertex.setParallelism(parallelism).         jobVertex.setInvokableClass(NoOpInvokable.class).         JobGraph jobGraph = new JobGraph("Test Job", jobVertex).         Configuration jobConfig = new Configuration().         Time timeout = Time.seconds(10L).         CompletableFuture<LogicalSlot> slotFuture1 = CompletableFuture.completedFuture(new TestingLogicalSlot()).         CompletableFuture<LogicalSlot> slotFuture2 = CompletableFuture.completedFuture(new TestingLogicalSlot()).         ArrayDeque<CompletableFuture<LogicalSlot>> slotFutures = new ArrayDeque<>().         slotFutures.addLast(slotFuture1).         slotFutures.addLast(slotFuture2).         TestRestartStrategy testingRestartStrategy = TestRestartStrategy.manuallyTriggered().         ExecutionGraph executionGraph = new ExecutionGraph(executor, executor, jobGraph.getJobID(), jobGraph.getName(), jobConfig, new SerializedValue<>(null), timeout, testingRestartStrategy, new TestingSlotProvider(ignore -> slotFutures.removeFirst())).         executionGraph.start(mainThreadExecutor).         RestartTimeGauge restartingTime = new RestartTimeGauge(executionGraph).         // check that the restarting time is 0 since it's the initial start         assertEquals(0L, restartingTime.getValue().longValue()).         executionGraph.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources()).         // start execution         executionGraph.scheduleForExecution().         assertEquals(0L, restartingTime.getValue().longValue()).         List<ExecutionAttemptID> executionIDs = new ArrayList<>().         for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {             executionIDs.add(executionVertex.getCurrentExecutionAttempt().getAttemptId()).         }         // tell execution graph that the tasks are in state running --> job status switches to state running         for (ExecutionAttemptID executionID : executionIDs) {             executionGraph.updateState(new TaskExecutionState(jobGraph.getJobID(), executionID, ExecutionState.RUNNING)).         }         assertEquals(JobStatus.RUNNING, executionGraph.getState()).         assertEquals(0L, restartingTime.getValue().longValue()).         // add some pause such that RUNNING and RESTARTING timestamps are not the same         Thread.sleep(1L).         // fail the job so that it goes into state restarting         for (ExecutionAttemptID executionID : executionIDs) {             executionGraph.updateState(new TaskExecutionState(jobGraph.getJobID(), executionID, ExecutionState.FAILED, new Exception())).         }         assertEquals(JobStatus.RESTARTING, executionGraph.getState()).         long firstRestartingTimestamp = executionGraph.getStatusTimestamp(JobStatus.RESTARTING).         long previousRestartingTime = restartingTime.getValue().         // check that the restarting time is monotonically increasing         for (int i = 0. i < 2. i++) {             // add some pause to let the currentRestartingTime increase             Thread.sleep(1L).             long currentRestartingTime = restartingTime.getValue().             assertTrue(currentRestartingTime >= previousRestartingTime).             previousRestartingTime = currentRestartingTime.         }         // check that we have measured some restarting time         assertTrue(previousRestartingTime > 0).         // restart job         testingRestartStrategy.triggerAll().join().         executionIDs.clear().         for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {             executionIDs.add(executionVertex.getCurrentExecutionAttempt().getAttemptId()).         }         for (ExecutionAttemptID executionID : executionIDs) {             executionGraph.updateState(new TaskExecutionState(jobGraph.getJobID(), executionID, ExecutionState.RUNNING)).         }         assertEquals(JobStatus.RUNNING, executionGraph.getState()).         assertTrue(firstRestartingTimestamp != 0).         previousRestartingTime = restartingTime.getValue().         // check that the restarting time does not increase after we've reached the running state         for (int i = 0. i < 2. i++) {             long currentRestartingTime = restartingTime.getValue().             assertTrue(currentRestartingTime == previousRestartingTime).             previousRestartingTime = currentRestartingTime.         }         // add some pause such that the RUNNING and RESTARTING timestamps are not the same         Thread.sleep(1L).         // fail job again         for (ExecutionAttemptID executionID : executionIDs) {             executionGraph.updateState(new TaskExecutionState(jobGraph.getJobID(), executionID, ExecutionState.FAILED, new Exception())).         }         assertEquals(JobStatus.RESTARTING, executionGraph.getState()).         long secondRestartingTimestamp = executionGraph.getStatusTimestamp(JobStatus.RESTARTING).         assertTrue(firstRestartingTimestamp != secondRestartingTimestamp).         previousRestartingTime = restartingTime.getValue().         // check that the restarting time is increasing again         for (int i = 0. i < 2. i++) {             // add some pause to the let currentRestartingTime increase             Thread.sleep(1L).             long currentRestartingTime = restartingTime.getValue().             assertTrue(currentRestartingTime >= previousRestartingTime).             previousRestartingTime = currentRestartingTime.         }         assertTrue(previousRestartingTime > 0).         // now lets fail the job while it is in restarting and see whether the restarting time then stops to increase         // for this to work, we have to use a SuppressRestartException         executionGraph.failGlobal(new SuppressRestartsException(new Exception())).         assertEquals(JobStatus.FAILED, executionGraph.getState()).         previousRestartingTime = restartingTime.getValue().         for (int i = 0. i < 10. i++) {             long currentRestartingTime = restartingTime.getValue().             assertTrue(currentRestartingTime == previousRestartingTime).             previousRestartingTime = currentRestartingTime.         }     } finally {         executor.shutdownNow().     } }
