commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@AfterClass public static void shutdownExecutorService() throws Exception {     executorService.shutdownNow(). }
false;;0;6;;@Override PipelinedSubpartition createSubpartition() {     final ResultPartition parent = mock(ResultPartition.class).     return new PipelinedSubpartition(0, parent). }
false;public;0;14;;@Test public void testIllegalReadViewRequest() throws Exception {     final PipelinedSubpartition subpartition = createSubpartition().     // Successful request     assertNotNull(subpartition.createReadView(new NoOpBufferAvailablityListener())).     try {         subpartition.createReadView(new NoOpBufferAvailablityListener()).         fail("Did not throw expected exception after duplicate notifyNonEmpty view request.").     } catch (IllegalStateException expected) {     } }
true;public;0;14;/**  * Verifies that the isReleased() check of the view checks the parent  * subpartition.  */ ;/**  * Verifies that the isReleased() check of the view checks the parent  * subpartition.  */ @Test public void testIsReleasedChecksParent() {     PipelinedSubpartition subpartition = mock(PipelinedSubpartition.class).     PipelinedSubpartitionView reader = new PipelinedSubpartitionView(subpartition, mock(BufferAvailabilityListener.class)).     assertFalse(reader.isReleased()).     verify(subpartition, times(1)).isReleased().     when(subpartition.isReleased()).thenReturn(true).     assertTrue(reader.isReleased()).     verify(subpartition, times(2)).isReleased(). }
false;public;0;4;;@Test public void testConcurrentFastProduceAndFastConsume() throws Exception {     testProduceConsume(false, false). }
false;public;0;4;;@Test public void testConcurrentFastProduceAndSlowConsume() throws Exception {     testProduceConsume(false, true). }
false;public;0;4;;@Test public void testConcurrentSlowProduceAndFastConsume() throws Exception {     testProduceConsume(true, false). }
false;public;0;4;;@Test public void testConcurrentSlowProduceAndSlowConsume() throws Exception {     testProduceConsume(true, true). }
false;public;0;25;;@Override public BufferConsumerAndChannel getNextBufferConsumer() throws Exception {     if (numberOfBuffers == producerNumberOfBuffersToProduce) {         return null.     }     final BufferBuilder bufferBuilder = bufferProvider.requestBufferBuilderBlocking().     int segmentSize = bufferBuilder.getMaxCapacity().     MemorySegment segment = MemorySegmentFactory.allocateUnpooledSegment(segmentSize).     int next = numberOfBuffers * (segmentSize / Integer.BYTES).     for (int i = 0. i < segmentSize. i += 4) {         segment.putInt(i, next).         next++.     }     checkState(bufferBuilder.appendAndCommit(ByteBuffer.wrap(segment.getArray())) == segmentSize).     bufferBuilder.finish().     numberOfBuffers++.     return new BufferConsumerAndChannel(bufferBuilder.createBufferConsumer(), 0). }
false;public;1;17;;@Override public void onBuffer(Buffer buffer) {     final MemorySegment segment = buffer.getMemorySegment().     assertEquals(segment.size(), buffer.getSize()).     int expected = numberOfBuffers * (segment.size() / 4).     for (int i = 0. i < segment.size(). i += 4) {         assertEquals(expected, segment.getInt(i)).         expected++.     }     numberOfBuffers++.     buffer.recycleBuffer(). }
false;public;1;4;;@Override public void onEvent(AbstractEvent event) { // Nothing to do in this test }
false;private;2;83;;private void testProduceConsume(boolean isSlowProducer, boolean isSlowConsumer) throws Exception {     // Config     final int producerBufferPoolSize = 8.     final int producerNumberOfBuffersToProduce = 128.     // Producer behaviour     final TestProducerSource producerSource = new TestProducerSource() {          private BufferProvider bufferProvider = new TestPooledBufferProvider(producerBufferPoolSize).          private int numberOfBuffers.          @Override         public BufferConsumerAndChannel getNextBufferConsumer() throws Exception {             if (numberOfBuffers == producerNumberOfBuffersToProduce) {                 return null.             }             final BufferBuilder bufferBuilder = bufferProvider.requestBufferBuilderBlocking().             int segmentSize = bufferBuilder.getMaxCapacity().             MemorySegment segment = MemorySegmentFactory.allocateUnpooledSegment(segmentSize).             int next = numberOfBuffers * (segmentSize / Integer.BYTES).             for (int i = 0. i < segmentSize. i += 4) {                 segment.putInt(i, next).                 next++.             }             checkState(bufferBuilder.appendAndCommit(ByteBuffer.wrap(segment.getArray())) == segmentSize).             bufferBuilder.finish().             numberOfBuffers++.             return new BufferConsumerAndChannel(bufferBuilder.createBufferConsumer(), 0).         }     }.     // Consumer behaviour     final TestConsumerCallback consumerCallback = new TestConsumerCallback() {          private int numberOfBuffers.          @Override         public void onBuffer(Buffer buffer) {             final MemorySegment segment = buffer.getMemorySegment().             assertEquals(segment.size(), buffer.getSize()).             int expected = numberOfBuffers * (segment.size() / 4).             for (int i = 0. i < segment.size(). i += 4) {                 assertEquals(expected, segment.getInt(i)).                 expected++.             }             numberOfBuffers++.             buffer.recycleBuffer().         }          @Override         public void onEvent(AbstractEvent event) {         // Nothing to do in this test         }     }.     final PipelinedSubpartition subpartition = createSubpartition().     TestSubpartitionProducer producer = new TestSubpartitionProducer(subpartition, isSlowProducer, producerSource).     TestSubpartitionConsumer consumer = new TestSubpartitionConsumer(isSlowConsumer, consumerCallback).     final PipelinedSubpartitionView view = subpartition.createReadView(consumer).     consumer.setSubpartitionView(view).     CompletableFuture<Boolean> producerResult = CompletableFuture.supplyAsync(CheckedSupplier.unchecked(producer::call), executorService).     CompletableFuture<Boolean> consumerResult = CompletableFuture.supplyAsync(CheckedSupplier.unchecked(consumer::call), executorService).     FutureUtils.waitForAll(Arrays.asList(producerResult, consumerResult)).get(60_000L, TimeUnit.MILLISECONDS). }
true;public;0;4;/**  * Tests cleanup of {@link PipelinedSubpartition#release()} with no read view attached.  */ ;/**  * Tests cleanup of {@link PipelinedSubpartition#release()} with no read view attached.  */ @Test public void testCleanupReleasedPartitionNoView() throws Exception {     testCleanupReleasedPartition(false). }
true;public;0;4;/**  * Tests cleanup of {@link PipelinedSubpartition#release()} with a read view attached.  */ ;/**  * Tests cleanup of {@link PipelinedSubpartition#release()} with a read view attached.  */ @Test public void testCleanupReleasedPartitionWithView() throws Exception {     testCleanupReleasedPartition(true). }
true;private;1;42;/**  * Tests cleanup of {@link PipelinedSubpartition#release()}.  *  * @param createView  * 		whether the partition should have a view attached to it (<tt>true</tt>) or not (<tt>false</tt>)  */ ;/**  * Tests cleanup of {@link PipelinedSubpartition#release()}.  *  * @param createView  * 		whether the partition should have a view attached to it (<tt>true</tt>) or not (<tt>false</tt>)  */ private void testCleanupReleasedPartition(boolean createView) throws Exception {     PipelinedSubpartition partition = createSubpartition().     BufferConsumer buffer1 = createFilledBufferConsumer(4096).     BufferConsumer buffer2 = createFilledBufferConsumer(4096).     boolean buffer1Recycled.     boolean buffer2Recycled.     try {         partition.add(buffer1).         partition.add(buffer2).         // create the read view first         ResultSubpartitionView view = null.         if (createView) {             view = partition.createReadView(new NoOpBufferAvailablityListener()).         }         partition.release().         assertTrue(partition.isReleased()).         if (createView) {             assertTrue(view.isReleased()).         }         assertTrue(buffer1.isRecycled()).     } finally {         buffer1Recycled = buffer1.isRecycled().         if (!buffer1Recycled) {             buffer1.close().         }         buffer2Recycled = buffer2.isRecycled().         if (!buffer2Recycled) {             buffer2.close().         }     }     if (!buffer1Recycled) {         Assert.fail("buffer 1 not recycled").     }     if (!buffer2Recycled) {         Assert.fail("buffer 2 not recycled").     }     assertEquals(2, partition.getTotalNumberOfBuffers()).     // buffer data is never consumed     assertEquals(0, partition.getTotalNumberOfBytes()). }
