commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@After public void shutdown() {     executor.shutdownNow(). }
false;public;0;17;;// ------------------------------------------------------------------------ @Test public void testNoManualRestart() throws Exception {     NoRestartStrategy restartStrategy = new NoRestartStrategy().     Tuple2<ExecutionGraph, Instance> executionGraphInstanceTuple = createExecutionGraph(restartStrategy).     ExecutionGraph eg = executionGraphInstanceTuple.f0.     eg.getAllExecutionVertices().iterator().next().fail(new Exception("Test Exception")).     completeCanceling(eg).     assertEquals(JobStatus.FAILED, eg.getState()).     // This should not restart the graph.     eg.restart(eg.getGlobalModVersion()).     assertEquals(JobStatus.FAILED, eg.getState()). }
false;private;1;3;;private void completeCanceling(ExecutionGraph eg) {     executeOperationForAllExecutions(eg, Execution::completeCancelling). }
false;private;2;5;;private void executeOperationForAllExecutions(ExecutionGraph eg, Consumer<Execution> operation) {     for (ExecutionVertex vertex : eg.getAllExecutionVertices()) {         operation.accept(vertex.getCurrentExecutionAttempt()).     } }
false;public;0;9;;@Test public void testRestartAutomatically() throws Exception {     Tuple2<ExecutionGraph, Instance> executionGraphInstanceTuple = createExecutionGraph(TestRestartStrategy.directExecuting()).     ExecutionGraph eg = executionGraphInstanceTuple.f0.     restartAfterFailure(eg, new FiniteDuration(2, TimeUnit.MINUTES), true). }
false;public;0;24;;@Test public void testCancelWhileRestarting() throws Exception {     // We want to manually control the restart and delay     RestartStrategy restartStrategy = new InfiniteDelayRestartStrategy().     Tuple2<ExecutionGraph, Instance> executionGraphInstanceTuple = createExecutionGraph(restartStrategy).     ExecutionGraph executionGraph = executionGraphInstanceTuple.f0.     Instance instance = executionGraphInstanceTuple.f1.     // Kill the instance and wait for the job to restart     instance.markDead().     Assert.assertEquals(JobStatus.RESTARTING, executionGraph.getState()).     assertEquals(JobStatus.RESTARTING, executionGraph.getState()).     // Canceling needs to abort the restart     executionGraph.cancel().     assertEquals(JobStatus.CANCELED, executionGraph.getState()).     // The restart has been aborted     executionGraph.restart(executionGraph.getGlobalModVersion()).     assertEquals(JobStatus.CANCELED, executionGraph.getState()). }
false;public;0;64;;@Test public void testFailWhileRestarting() throws Exception {     Scheduler scheduler = new Scheduler(TestingUtils.defaultExecutionContext()).     Instance instance = ExecutionGraphTestUtils.getInstance(new ActorTaskManagerGateway(new SimpleActorGateway(TestingUtils.directExecutionContext())), NUM_TASKS).     scheduler.newInstanceAvailable(instance).     // Blocking program     ExecutionGraph executionGraph = new ExecutionGraph(TestingUtils.defaultExecutor(), TestingUtils.defaultExecutor(), new JobID(), "TestJob", new Configuration(), new SerializedValue<>(new ExecutionConfig()), AkkaUtils.getDefaultTimeout(), // We want to manually control the restart and delay     new InfiniteDelayRestartStrategy(), scheduler).     executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread()).     JobVertex jobVertex = new JobVertex("NoOpInvokable").     jobVertex.setInvokableClass(NoOpInvokable.class).     jobVertex.setParallelism(NUM_TASKS).     JobGraph jobGraph = new JobGraph("TestJob", jobVertex).     executionGraph.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources()).     assertEquals(JobStatus.CREATED, executionGraph.getState()).     executionGraph.scheduleForExecution().     assertEquals(JobStatus.RUNNING, executionGraph.getState()).     // Kill the instance and wait for the job to restart     instance.markDead().     assertEquals(JobStatus.RESTARTING, executionGraph.getState()).     // If we fail when being in RESTARTING, then we should try to restart again     final long globalModVersion = executionGraph.getGlobalModVersion().     final Exception testException = new Exception("Test exception").     executionGraph.failGlobal(testException).     assertNotEquals(globalModVersion, executionGraph.getGlobalModVersion()).     assertEquals(JobStatus.RESTARTING, executionGraph.getState()).     // we should have updated the failure cause     assertEquals(testException, executionGraph.getFailureCause()).     // but it should fail when sending a SuppressRestartsException     executionGraph.failGlobal(new SuppressRestartsException(new Exception("Suppress restart exception"))).     assertEquals(JobStatus.FAILED, executionGraph.getState()).     // The restart has been aborted     executionGraph.restart(executionGraph.getGlobalModVersion()).     assertEquals(JobStatus.FAILED, executionGraph.getState()). }
false;public;0;25;;@Test public void testCancelWhileFailing() throws Exception {     final RestartStrategy restartStrategy = new InfiniteDelayRestartStrategy().     final ExecutionGraph graph = createExecutionGraph(restartStrategy).f0.     assertEquals(JobStatus.RUNNING, graph.getState()).     // switch all tasks to running     for (ExecutionVertex vertex : graph.getVerticesTopologically().iterator().next().getTaskVertices()) {         vertex.getCurrentExecutionAttempt().switchToRunning().     }     graph.failGlobal(new Exception("test")).     assertEquals(JobStatus.FAILING, graph.getState()).     graph.cancel().     assertEquals(JobStatus.CANCELLING, graph.getState()).     // let all tasks finish cancelling     completeCanceling(graph).     assertEquals(JobStatus.CANCELED, graph.getState()). }
false;public;0;21;;@Test public void testFailWhileCanceling() throws Exception {     final RestartStrategy restartStrategy = new NoRestartStrategy().     final ExecutionGraph graph = createExecutionGraph(restartStrategy).f0.     assertEquals(JobStatus.RUNNING, graph.getState()).     switchAllTasksToRunning(graph).     graph.cancel().     assertEquals(JobStatus.CANCELLING, graph.getState()).     graph.failGlobal(new Exception("test")).     assertEquals(JobStatus.FAILING, graph.getState()).     // let all tasks finish cancelling     completeCanceling(graph).     assertEquals(JobStatus.FAILED, graph.getState()). }
false;private;1;3;;private void switchAllTasksToRunning(ExecutionGraph graph) {     executeOperationForAllExecutions(graph, Execution::switchToRunning). }
false;public;0;20;;@Test public void testNoRestartOnSuppressException() throws Exception {     final ExecutionGraph eg = createExecutionGraph(new FixedDelayRestartStrategy(Integer.MAX_VALUE, 0)).f0.     // Fail with unrecoverable Exception     eg.getAllExecutionVertices().iterator().next().fail(new SuppressRestartsException(new Exception("Test Exception"))).     assertEquals(JobStatus.FAILING, eg.getState()).     completeCanceling(eg).     eg.waitUntilTerminal().     assertEquals(JobStatus.FAILED, eg.getState()).     RestartStrategy restartStrategy = eg.getRestartStrategy().     assertTrue(restartStrategy instanceof FixedDelayRestartStrategy).     assertEquals(0, ((FixedDelayRestartStrategy) restartStrategy).getCurrentRestartAttempt()). }
true;public;0;54;/**  * Tests that a failing execution does not affect a restarted job. This is important if a  * callback handler fails an execution after it has already reached a final state and the job  * has been restarted.  */ ;/**  * Tests that a failing execution does not affect a restarted job. This is important if a  * callback handler fails an execution after it has already reached a final state and the job  * has been restarted.  */ @Test public void testFailingExecutionAfterRestart() throws Exception {     Instance instance = ExecutionGraphTestUtils.getInstance(new ActorTaskManagerGateway(new SimpleActorGateway(TestingUtils.directExecutionContext())), 2).     Scheduler scheduler = new Scheduler(TestingUtils.defaultExecutionContext()).     scheduler.newInstanceAvailable(instance).     TestRestartStrategy restartStrategy = TestRestartStrategy.directExecuting().     JobVertex sender = ExecutionGraphTestUtils.createJobVertex("Task1", 1, NoOpInvokable.class).     JobVertex receiver = ExecutionGraphTestUtils.createJobVertex("Task2", 1, NoOpInvokable.class).     JobGraph jobGraph = new JobGraph("Pointwise job", sender, receiver).     ExecutionGraph eg = newExecutionGraph(restartStrategy, scheduler).     eg.start(mainThreadExecutor).     eg.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources()).     assertEquals(JobStatus.CREATED, eg.getState()).     eg.scheduleForExecution().     assertEquals(JobStatus.RUNNING, eg.getState()).     Iterator<ExecutionVertex> executionVertices = eg.getAllExecutionVertices().iterator().     Execution finishedExecution = executionVertices.next().getCurrentExecutionAttempt().     Execution failedExecution = executionVertices.next().getCurrentExecutionAttempt().     finishedExecution.markFinished().     failedExecution.fail(new Exception("Test Exception")).     failedExecution.completeCancelling().     assertEquals(JobStatus.RUNNING, eg.getState()).     // At this point all resources have been assigned     for (ExecutionVertex vertex : eg.getAllExecutionVertices()) {         assertNotNull("No assigned resource (test instability).", vertex.getCurrentAssignedResource()).         vertex.getCurrentExecutionAttempt().switchToRunning().     }     // fail old finished execution, this should not affect the execution     finishedExecution.fail(new Exception("This should have no effect")).     for (ExecutionVertex vertex : eg.getAllExecutionVertices()) {         vertex.getCurrentExecutionAttempt().markFinished().     }     // the state of the finished execution should have not changed since it is terminal     assertEquals(ExecutionState.FINISHED, finishedExecution.getState()).     assertEquals(JobStatus.FINISHED, eg.getState()). }
true;public;0;41;/**  * Tests that a graph is not restarted after cancellation via a call to  * {@link ExecutionGraph#failGlobal(Throwable)}. This can happen when a slot is  * released concurrently with cancellation.  */ ;/**  * Tests that a graph is not restarted after cancellation via a call to  * {@link ExecutionGraph#failGlobal(Throwable)}. This can happen when a slot is  * released concurrently with cancellation.  */ @Test public void testFailExecutionAfterCancel() throws Exception {     Instance instance = ExecutionGraphTestUtils.getInstance(new ActorTaskManagerGateway(new SimpleActorGateway(TestingUtils.directExecutionContext())), 2).     Scheduler scheduler = new Scheduler(TestingUtils.defaultExecutionContext()).     scheduler.newInstanceAvailable(instance).     JobVertex vertex = ExecutionGraphTestUtils.createJobVertex("Test Vertex", 1, NoOpInvokable.class).     ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, Integer.MAX_VALUE)).     JobGraph jobGraph = new JobGraph("Test Job", vertex).     jobGraph.setExecutionConfig(executionConfig).     ExecutionGraph eg = newExecutionGraph(new InfiniteDelayRestartStrategy(), scheduler).     eg.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources()).     assertEquals(JobStatus.CREATED, eg.getState()).     eg.scheduleForExecution().     assertEquals(JobStatus.RUNNING, eg.getState()).     // Fail right after cancel (for example with concurrent slot release)     eg.cancel().     for (ExecutionVertex v : eg.getAllExecutionVertices()) {         v.getCurrentExecutionAttempt().fail(new Exception("Test Exception")).     }     assertEquals(JobStatus.CANCELED, eg.getTerminationFuture().get()).     Execution execution = eg.getAllExecutionVertices().iterator().next().getCurrentExecutionAttempt().     execution.completeCancelling().     assertEquals(JobStatus.CANCELED, eg.getState()). }
true;public;0;39;/**  * Tests that it is possible to fail a graph via a call to  * {@link ExecutionGraph#failGlobal(Throwable)} after cancellation.  */ ;/**  * Tests that it is possible to fail a graph via a call to  * {@link ExecutionGraph#failGlobal(Throwable)} after cancellation.  */ @Test public void testFailExecutionGraphAfterCancel() throws Exception {     Instance instance = ExecutionGraphTestUtils.getInstance(new ActorTaskManagerGateway(new SimpleActorGateway(TestingUtils.directExecutionContext())), 2).     Scheduler scheduler = new Scheduler(TestingUtils.defaultExecutionContext()).     scheduler.newInstanceAvailable(instance).     JobVertex vertex = ExecutionGraphTestUtils.createJobVertex("Test Vertex", 1, NoOpInvokable.class).     ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, Integer.MAX_VALUE)).     JobGraph jobGraph = new JobGraph("Test Job", vertex).     jobGraph.setExecutionConfig(executionConfig).     ExecutionGraph eg = newExecutionGraph(new InfiniteDelayRestartStrategy(), scheduler).     eg.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources()).     assertEquals(JobStatus.CREATED, eg.getState()).     eg.scheduleForExecution().     assertEquals(JobStatus.RUNNING, eg.getState()).     // Fail right after cancel (for example with concurrent slot release)     eg.cancel().     assertEquals(JobStatus.CANCELLING, eg.getState()).     eg.failGlobal(new Exception("Test Exception")).     assertEquals(JobStatus.FAILING, eg.getState()).     Execution execution = eg.getAllExecutionVertices().iterator().next().getCurrentExecutionAttempt().     execution.completeCancelling().     assertEquals(JobStatus.RESTARTING, eg.getState()). }
true;public;0;53;/**  * Tests that a suspend call while restarting a job, will abort the restarting.  */ ;/**  * Tests that a suspend call while restarting a job, will abort the restarting.  */ @Test public void testSuspendWhileRestarting() throws Exception {     Instance instance = ExecutionGraphTestUtils.getInstance(new ActorTaskManagerGateway(new SimpleActorGateway(TestingUtils.directExecutionContext())), NUM_TASKS).     Scheduler scheduler = new Scheduler(TestingUtils.defaultExecutionContext()).     scheduler.newInstanceAvailable(instance).     JobVertex sender = new JobVertex("Task").     sender.setInvokableClass(NoOpInvokable.class).     sender.setParallelism(NUM_TASKS).     JobGraph jobGraph = new JobGraph("Pointwise job", sender).     TestRestartStrategy controllableRestartStrategy = TestRestartStrategy.manuallyTriggered().     ExecutionGraph eg = new ExecutionGraph(TestingUtils.defaultExecutor(), TestingUtils.defaultExecutor(), new JobID(), "Test job", new Configuration(), new SerializedValue<>(new ExecutionConfig()), AkkaUtils.getDefaultTimeout(), controllableRestartStrategy, scheduler).     eg.start(mainThreadExecutor).     eg.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources()).     assertEquals(JobStatus.CREATED, eg.getState()).     eg.scheduleForExecution().     assertEquals(JobStatus.RUNNING, eg.getState()).     instance.markDead().     Assert.assertEquals(1, controllableRestartStrategy.getNumberOfQueuedActions()).     assertEquals(JobStatus.RESTARTING, eg.getState()).     eg.suspend(new Exception("Test exception")).     assertEquals(JobStatus.SUSPENDED, eg.getState()).     controllableRestartStrategy.triggerAll().join().     assertEquals(JobStatus.SUSPENDED, eg.getState()). }
false;public;0;44;;@Test public void testLocalFailAndRestart() throws Exception {     final int parallelism = 10.     SimpleAckingTaskManagerGateway taskManagerGateway = new SimpleAckingTaskManagerGateway().     final TestRestartStrategy triggeredRestartStrategy = TestRestartStrategy.manuallyTriggered().     final ExecutionGraph eg = createSimpleTestGraph(new JobID(), taskManagerGateway, triggeredRestartStrategy, createNoOpVertex(parallelism)).     eg.start(mainThreadExecutor).     eg.setScheduleMode(ScheduleMode.EAGER).     eg.scheduleForExecution().     switchToRunning(eg).     final ExecutionJobVertex vertex = eg.getVerticesTopologically().iterator().next().     final Execution first = vertex.getTaskVertices()[0].getCurrentExecutionAttempt().     final Execution last = vertex.getTaskVertices()[vertex.getParallelism() - 1].getCurrentExecutionAttempt().     // Have two executions fail     first.fail(new Exception("intended test failure 1")).     last.fail(new Exception("intended test failure 2")).     Assert.assertEquals(JobStatus.FAILING, eg.getState()).     completeCancellingForAllVertices(eg).     // Now trigger the restart     Assert.assertEquals(1, triggeredRestartStrategy.getNumberOfQueuedActions()).     triggeredRestartStrategy.triggerAll().join().     Assert.assertEquals(JobStatus.RUNNING, eg.getState()).     switchToRunning(eg).     finishAllVertices(eg).     eg.waitUntilTerminal().     assertEquals(JobStatus.FINISHED, eg.getState()). }
false;public;0;42;;@Test public void testGlobalFailAndRestarts() throws Exception {     final int parallelism = 10.     final JobID jid = new JobID().     final JobVertex vertex = createNoOpVertex(parallelism).     final NotCancelAckingTaskGateway taskManagerGateway = new NotCancelAckingTaskGateway().     final SlotProvider slots = new SimpleSlotProvider(jid, parallelism, taskManagerGateway).     final TestRestartStrategy restartStrategy = TestRestartStrategy.manuallyTriggered().     final ExecutionGraph eg = createSimpleTestGraph(jid, slots, restartStrategy, vertex).     eg.start(mainThreadExecutor).     eg.setScheduleMode(ScheduleMode.EAGER).     eg.scheduleForExecution().     switchToRunning(eg).     // fail into 'RESTARTING'     eg.failGlobal(new Exception("intended test failure 1")).     assertEquals(JobStatus.FAILING, eg.getState()).     completeCancellingForAllVertices(eg).     assertEquals(JobStatus.RESTARTING, eg.getState()).     eg.failGlobal(new Exception("intended test failure 2")).     assertEquals(JobStatus.RESTARTING, eg.getState()).     restartStrategy.triggerAll().join().     assertEquals(JobStatus.RUNNING, eg.getState()).     switchToRunning(eg).     finishAllVertices(eg).     eg.waitUntilTerminal().     assertEquals(JobStatus.FINISHED, eg.getState()).     if (eg.getNumberOfFullRestarts() > 2) {         fail("Too many restarts: " + eg.getNumberOfFullRestarts()).     } }
false;public;0;55;;@Test public void testRestartWithEagerSchedulingAndSlotSharing() throws Exception {     // this test is inconclusive if not used with a proper multi-threaded executor     assertTrue("test assumptions violated", ((ThreadPoolExecutor) executor).getCorePoolSize() > 1).     SimpleAckingTaskManagerGateway taskManagerGateway = new SimpleAckingTaskManagerGateway().     final int parallelism = 20.     final Scheduler scheduler = createSchedulerWithInstances(parallelism, taskManagerGateway).     final SlotSharingGroup sharingGroup = new SlotSharingGroup().     final JobVertex source = new JobVertex("source").     source.setInvokableClass(NoOpInvokable.class).     source.setParallelism(parallelism).     source.setSlotSharingGroup(sharingGroup).     final JobVertex sink = new JobVertex("sink").     sink.setInvokableClass(NoOpInvokable.class).     sink.setParallelism(parallelism).     sink.setSlotSharingGroup(sharingGroup).     sink.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED_BOUNDED).     TestRestartStrategy restartStrategy = TestRestartStrategy.directExecuting().     final ExecutionGraph eg = ExecutionGraphTestUtils.createExecutionGraph(new JobID(), scheduler, restartStrategy, executor, source, sink).     eg.start(mainThreadExecutor).     eg.setScheduleMode(ScheduleMode.EAGER).     eg.scheduleForExecution().     switchToRunning(eg).     // fail into 'RESTARTING'     eg.getAllExecutionVertices().iterator().next().getCurrentExecutionAttempt().fail(new Exception("intended test failure")).     assertEquals(JobStatus.FAILING, eg.getState()).     completeCancellingForAllVertices(eg).     assertEquals(JobStatus.RUNNING, eg.getState()).     // clean termination     switchToRunning(eg).     finishAllVertices(eg).     assertEquals(JobStatus.FINISHED, eg.getState()). }
false;public;0;47;;@Test public void testRestartWithSlotSharingAndNotEnoughResources() throws Exception {     // this test is inconclusive if not used with a proper multi-threaded executor     assertTrue("test assumptions violated", ((ThreadPoolExecutor) executor).getCorePoolSize() > 1).     final int numRestarts = 10.     final int parallelism = 20.     TaskManagerGateway taskManagerGateway = new SimpleAckingTaskManagerGateway().     final Scheduler scheduler = createSchedulerWithInstances(parallelism - 1, taskManagerGateway).     final SlotSharingGroup sharingGroup = new SlotSharingGroup().     final JobVertex source = new JobVertex("source").     source.setInvokableClass(NoOpInvokable.class).     source.setParallelism(parallelism).     source.setSlotSharingGroup(sharingGroup).     final JobVertex sink = new JobVertex("sink").     sink.setInvokableClass(NoOpInvokable.class).     sink.setParallelism(parallelism).     sink.setSlotSharingGroup(sharingGroup).     sink.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED_BOUNDED).     TestRestartStrategy restartStrategy = new TestRestartStrategy(numRestarts, false).     final ExecutionGraph eg = ExecutionGraphTestUtils.createExecutionGraph(new JobID(), scheduler, restartStrategy, executor, source, sink).     eg.start(mainThreadExecutor).     eg.setScheduleMode(ScheduleMode.EAGER).     eg.scheduleForExecution().     // wait until no more changes happen     while (eg.getNumberOfFullRestarts() < numRestarts) {         Thread.sleep(1).     }     assertEquals(JobStatus.FAILED, eg.getState()).     final Throwable t = eg.getFailureCause().     if (!(t instanceof NoResourceAvailableException)) {         ExceptionUtils.rethrowException(t, t.getMessage()).     } }
true;public;0;22;/**  * Tests that the {@link ExecutionGraph} can handle failures while  * being in the RESTARTING state.  */ ;/**  * Tests that the {@link ExecutionGraph} can handle failures while  * being in the RESTARTING state.  */ @Test public void testFailureWhileRestarting() throws Exception {     final TestRestartStrategy restartStrategy = TestRestartStrategy.manuallyTriggered().     final ExecutionGraph executionGraph = createSimpleExecutionGraph(restartStrategy, new TestingSlotProvider(ignored -> new CompletableFuture<>())).     executionGraph.start(mainThreadExecutor).     executionGraph.setQueuedSchedulingAllowed(true).     executionGraph.scheduleForExecution().     assertThat(executionGraph.getState(), is(JobStatus.RUNNING)).     executionGraph.failGlobal(new FlinkException("Test exception")).     restartStrategy.triggerAll().join().     executionGraph.failGlobal(new FlinkException("Concurrent exception")).     restartStrategy.triggerAll().join().     assertEquals(JobStatus.RUNNING, executionGraph.getState()). }
false;private;2;11;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ private Scheduler createSchedulerWithInstances(int num, TaskManagerGateway taskManagerGateway) {     final Scheduler scheduler = new Scheduler(executor).     final Instance[] instances = new Instance[num].     for (int i = 0. i < instances.length. i++) {         instances[i] = createInstance(taskManagerGateway, 55443 + i).         scheduler.newInstanceAvailable(instances[i]).     }     return scheduler. }
false;private,static;2;6;;private static Instance createInstance(TaskManagerGateway taskManagerGateway, int port) {     final HardwareDescription resources = new HardwareDescription(4, 1_000_000_000, 500_000_000, 400_000_000).     final TaskManagerLocation location = new TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), port).     return new Instance(taskManagerGateway, location, new InstanceID(), resources, 1). }
false;private;1;17;;// ------------------------------------------------------------------------ private Tuple2<ExecutionGraph, Instance> createExecutionGraph(RestartStrategy restartStrategy) throws Exception {     Instance instance = ExecutionGraphTestUtils.getInstance(new ActorTaskManagerGateway(new SimpleActorGateway(TestingUtils.directExecutionContext())), NUM_TASKS).     Scheduler scheduler = new Scheduler(TestingUtils.defaultExecutionContext()).     scheduler.newInstanceAvailable(instance).     ExecutionGraph eg = createSimpleExecutionGraph(restartStrategy, scheduler).     assertEquals(JobStatus.CREATED, eg.getState()).     eg.scheduleForExecution().     assertEquals(JobStatus.RUNNING, eg.getState()).     return new Tuple2<>(eg, instance). }
false;private;2;9;;private ExecutionGraph createSimpleExecutionGraph(RestartStrategy restartStrategy, SlotProvider slotProvider) throws IOException, JobException {     JobGraph jobGraph = createJobGraph(NUM_TASKS).     ExecutionGraph eg = newExecutionGraph(restartStrategy, slotProvider).     eg.start(mainThreadExecutor).     eg.attachJobGraph(jobGraph.getVerticesSortedTopologicallyFromSources()).     return eg. }
false;private,static;1;6;;@Nonnull private static JobGraph createJobGraph(int parallelism) {     JobVertex sender = ExecutionGraphTestUtils.createJobVertex("Task", parallelism, NoOpInvokable.class).     return new JobGraph("Pointwise job", sender). }
false;private,static;2;16;;private static ExecutionGraph newExecutionGraph(RestartStrategy restartStrategy, SlotProvider slotProvider) throws IOException {     final ExecutionGraph executionGraph = new ExecutionGraph(TestingUtils.defaultExecutor(), TestingUtils.defaultExecutor(), new JobID(), "Test job", new Configuration(), new SerializedValue<>(new ExecutionConfig()), AkkaUtils.getDefaultTimeout(), restartStrategy, slotProvider).     executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread()).     return executionGraph. }
false;private;3;16;;private void restartAfterFailure(ExecutionGraph eg, FiniteDuration timeout, boolean haltAfterRestart) {     eg.start(mainThreadExecutor).     eg.getAllExecutionVertices().iterator().next().fail(new Exception("Test Exception")).     assertEquals(JobStatus.FAILING, eg.getState()).     for (ExecutionVertex vertex : eg.getAllExecutionVertices()) {         vertex.getCurrentExecutionAttempt().completeCancelling().     }     assertEquals(JobStatus.RUNNING, eg.getState()).     if (haltAfterRestart) {         haltExecution(eg).     } }
false;private,static;1;4;;private static void haltExecution(ExecutionGraph eg) {     finishAllVertices(eg).     assertEquals(JobStatus.FINISHED, eg.getState()). }
