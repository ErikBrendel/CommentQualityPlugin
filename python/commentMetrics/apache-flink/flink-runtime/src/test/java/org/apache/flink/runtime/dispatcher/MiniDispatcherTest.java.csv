# id;timestamp;commentText;codeText;commentWords;codeWords
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1518680659;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		_		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___		final JobGraph actualJobGraph = jobGraphFuture.get()___		assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1518862303;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1518945172;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1519406526;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1519406526;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1519510749;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1521379500;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1522249271;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1522249272;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1522339662;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1522681180;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1525339176;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1526334048;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1526336566;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1526494919;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1528982883;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1536954663;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1545326469;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testSingleJobRecovery() throws Exception;1549360057;Tests that the {@link MiniDispatcher} recovers the single job with which it_was started.;@Test_	public void testSingleJobRecovery() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			final JobGraph actualJobGraph = jobGraphFuture.get()___			assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID()))__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,recovers,the,single,job,with,which,it,was,started;test,public,void,test,single,job,recovery,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,final,job,graph,actual,job,graph,job,graph,future,get,assert,that,actual,job,graph,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1518862303;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			final Dispatcher.DispatcherOnCompleteActions completeActions = miniDispatcher.new DispatcherOnCompleteActions(jobGraph.getJobID())___			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			completeActions.jobReachedGloballyTerminalState(archivedExecutionGraph)___			final CompletableFuture<Boolean> terminationFuture = miniDispatcher.getTerminationFuture()___			assertThat(terminationFuture.isDone(), is(false))___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))___			terminationFuture.get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,final,dispatcher,dispatcher,on,complete,actions,complete,actions,mini,dispatcher,new,dispatcher,on,complete,actions,job,graph,get,job,id,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,complete,actions,job,reached,globally,terminal,state,archived,execution,graph,final,completable,future,boolean,termination,future,mini,dispatcher,get,termination,future,assert,that,termination,future,is,done,is,false,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1518945172;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			final CompletableFuture<Boolean> terminationFuture = miniDispatcher.getTerminationFuture()___			assertThat(terminationFuture.isDone(), is(false))___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))___			terminationFuture.get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,final,completable,future,boolean,termination,future,mini,dispatcher,get,termination,future,assert,that,termination,future,is,done,is,false,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1519406526;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			final CompletableFuture<Boolean> terminationFuture = miniDispatcher.getTerminationFuture()___			assertThat(terminationFuture.isDone(), is(false))___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))___			terminationFuture.get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,final,completable,future,boolean,termination,future,mini,dispatcher,get,termination,future,assert,that,termination,future,is,done,is,false,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1519406526;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			final CompletableFuture<Void> terminationFuture = miniDispatcher.getTerminationFuture()___			assertThat(terminationFuture.isDone(), is(false))___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))___			terminationFuture.get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,final,completable,future,void,termination,future,mini,dispatcher,get,termination,future,assert,that,termination,future,is,done,is,false,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1519510749;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			final CompletableFuture<Void> terminationFuture = miniDispatcher.getTerminationFuture()___			assertThat(terminationFuture.isDone(), is(false))___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))___			terminationFuture.get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,final,completable,future,void,termination,future,mini,dispatcher,get,termination,future,assert,that,termination,future,is,done,is,false,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1521379500;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			final CompletableFuture<Void> terminationFuture = miniDispatcher.getTerminationFuture()___			assertThat(terminationFuture.isDone(), is(false))___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))___			terminationFuture.get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,final,completable,future,void,termination,future,mini,dispatcher,get,termination,future,assert,that,termination,future,is,done,is,false,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1522249271;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			final CompletableFuture<Void> terminationFuture = miniDispatcher.getTerminationFuture()___			assertThat(terminationFuture.isDone(), is(false))___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))___			terminationFuture.get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,final,completable,future,void,termination,future,mini,dispatcher,get,termination,future,assert,that,termination,future,is,done,is,false,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1522249272;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			final CompletableFuture<Void> terminationFuture = miniDispatcher.getTerminationFuture()___			assertThat(terminationFuture.isDone(), is(false))___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))___			terminationFuture.get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,final,completable,future,void,termination,future,mini,dispatcher,get,termination,future,assert,that,termination,future,is,done,is,false,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1522339662;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			final CompletableFuture<Void> terminationFuture = miniDispatcher.getTerminationFuture()___			assertThat(terminationFuture.isDone(), is(false))___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))___			terminationFuture.get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,final,completable,future,void,termination,future,mini,dispatcher,get,termination,future,assert,that,termination,future,is,done,is,false,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1522681180;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			final CompletableFuture<Void> terminationFuture = miniDispatcher.getTerminationFuture()___			assertThat(terminationFuture.isDone(), is(false))___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))___			terminationFuture.get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,final,completable,future,void,termination,future,mini,dispatcher,get,termination,future,assert,that,termination,future,is,done,is,false,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1525339176;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			assertFalse(miniDispatcher.getTerminationFuture().isDone())___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))__		}_		finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,assert,false,mini,dispatcher,get,termination,future,is,done,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1526334048;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			assertFalse(miniDispatcher.getTerminationFuture().isDone())___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))__		}_		finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,assert,false,mini,dispatcher,get,termination,future,is,done,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1526336566;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			assertFalse(miniDispatcher.getTerminationFuture().isDone())___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))__		}_		finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,assert,false,mini,dispatcher,get,termination,future,is,done,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1526494919;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			assertFalse(miniDispatcher.getTerminationFuture().isDone())___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))__		}_		finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,assert,false,mini,dispatcher,get,termination,future,is,done,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1528982883;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			assertFalse(miniDispatcher.getTerminationFuture().isDone())___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))__		}_		finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,assert,false,mini,dispatcher,get,termination,future,is,done,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1536954663;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			assertFalse(miniDispatcher.getTerminationFuture().isDone())___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))__		}_		finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,assert,false,mini,dispatcher,get,termination,future,is,done,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1545326469;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			assertFalse(miniDispatcher.getTerminationFuture().isDone())___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))__		}_		finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,assert,false,mini,dispatcher,get,termination,future,is,done,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testJobResultRetrieval() throws Exception;1549360057;Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}_after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.;@Test_	public void testJobResultRetrieval() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			assertFalse(miniDispatcher.getTerminationFuture().isDone())___			final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class)___			final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout)___			final JobResult jobResult = jobResultFuture.get()___			assertThat(jobResult.getJobId(), is(jobGraph.getJobID()))__		}_		finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,the,link,mini,dispatcher,only,terminates,in,link,cluster,entrypoint,execution,mode,normal,after,it,has,served,the,link,org,apache,flink,runtime,jobmaster,job,result,once;test,public,void,test,job,result,retrieval,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,normal,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,assert,false,mini,dispatcher,get,termination,future,is,done,final,dispatcher,gateway,dispatcher,gateway,mini,dispatcher,get,self,gateway,dispatcher,gateway,class,final,completable,future,job,result,job,result,future,dispatcher,gateway,request,job,result,job,graph,get,job,id,timeout,final,job,result,job,result,job,result,future,get,assert,that,job,result,get,job,id,is,job,graph,get,job,id,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1518680659;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final Dispatcher.DispatcherOnCompleteActions completeActions = miniDispatcher.new DispatcherOnCompleteActions(jobGraph.getJobID())___		final ArchivedExecutionGraph archivedExecutionGraph = new ArchivedExecutionGraphBuilder()_			.setJobID(jobGraph.getJobID())_			.setState(JobStatus.FINISHED)_			.build()___		_		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___		_		jobGraphFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)___		completeActions.jobReachedGloballyTerminalState(archivedExecutionGraph)___		final CompletableFuture<Boolean> terminationFuture = miniDispatcher.getTerminationFuture()___		_		terminationFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS)__	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,dispatcher,dispatcher,on,complete,actions,complete,actions,mini,dispatcher,new,dispatcher,on,complete,actions,job,graph,get,job,id,final,archived,execution,graph,archived,execution,graph,new,archived,execution,graph,builder,set,job,id,job,graph,get,job,id,set,state,job,status,finished,build,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,timeout,to,milliseconds,time,unit,milliseconds,complete,actions,job,reached,globally,terminal,state,archived,execution,graph,final,completable,future,boolean,termination,future,mini,dispatcher,get,termination,future,termination,future,get,timeout,to,milliseconds,time,unit,milliseconds
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1518862303;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			final Dispatcher.DispatcherOnCompleteActions completeActions = miniDispatcher.new DispatcherOnCompleteActions(jobGraph.getJobID())___			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			completeActions.jobReachedGloballyTerminalState(archivedExecutionGraph)___			_			miniDispatcher.getTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,final,dispatcher,dispatcher,on,complete,actions,complete,actions,mini,dispatcher,new,dispatcher,on,complete,actions,job,graph,get,job,id,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,complete,actions,job,reached,globally,terminal,state,archived,execution,graph,mini,dispatcher,get,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1518945172;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1519406526;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1519406526;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1519510749;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1521379500;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1522249271;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1522249272;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1522339662;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1522681180;Tests that in detached mode, the {@link MiniDispatcher} will terminate after the job_has completed.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,terminate,after,the,job,has,completed;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1525339176;Tests that in detached mode, the {@link MiniDispatcher} will complete the future that_signals job termination.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getJobTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,complete,the,future,that,signals,job,termination;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,job,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1526334048;Tests that in detached mode, the {@link MiniDispatcher} will complete the future that_signals job termination.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getJobTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,complete,the,future,that,signals,job,termination;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,job,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1526336566;Tests that in detached mode, the {@link MiniDispatcher} will complete the future that_signals job termination.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getJobTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,complete,the,future,that,signals,job,termination;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,job,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1526494919;Tests that in detached mode, the {@link MiniDispatcher} will complete the future that_signals job termination.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getJobTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,complete,the,future,that,signals,job,termination;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,job,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1528982883;Tests that in detached mode, the {@link MiniDispatcher} will complete the future that_signals job termination.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getJobTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,complete,the,future,that,signals,job,termination;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,job,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1536954663;Tests that in detached mode, the {@link MiniDispatcher} will complete the future that_signals job termination.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getJobTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,complete,the,future,that,signals,job,termination;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,job,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1545326469;Tests that in detached mode, the {@link MiniDispatcher} will complete the future that_signals job termination.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getJobTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,complete,the,future,that,signals,job,termination;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,job,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
MiniDispatcherTest -> @Test 	public void testTerminationAfterJobCompletion() throws Exception;1549360057;Tests that in detached mode, the {@link MiniDispatcher} will complete the future that_signals job termination.;@Test_	public void testTerminationAfterJobCompletion() throws Exception {_		final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED)___		miniDispatcher.start()___		try {_			_			dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get()___			_			jobGraphFuture.get()___			resultFuture.complete(archivedExecutionGraph)___			_			miniDispatcher.getJobTerminationFuture().get()__		} finally {_			RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout)__		}_	};tests,that,in,detached,mode,the,link,mini,dispatcher,will,complete,the,future,that,signals,job,termination;test,public,void,test,termination,after,job,completion,throws,exception,final,mini,dispatcher,mini,dispatcher,create,mini,dispatcher,cluster,entrypoint,execution,mode,detached,mini,dispatcher,start,try,dispatcher,leader,election,service,is,leader,uuid,random,uuid,get,job,graph,future,get,result,future,complete,archived,execution,graph,mini,dispatcher,get,job,termination,future,get,finally,rpc,utils,terminate,rpc,endpoint,mini,dispatcher,timeout
