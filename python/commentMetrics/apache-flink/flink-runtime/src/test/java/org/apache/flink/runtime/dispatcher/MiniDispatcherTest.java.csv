commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;16;;@BeforeClass public static void setupClass() throws IOException {     jobGraph = new JobGraph().     archivedExecutionGraph = new ArchivedExecutionGraphBuilder().setJobID(jobGraph.getJobID()).setState(JobStatus.FINISHED).build().     rpcService = new TestingRpcService().     configuration = new Configuration().     configuration.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath()).     blobServer = new BlobServer(configuration, new VoidBlobStore()). }
false;public;0;13;;@Before public void setup() throws Exception {     dispatcherLeaderElectionService = new TestingLeaderElectionService().     highAvailabilityServices = new TestingHighAvailabilityServices().     testingFatalErrorHandler = new TestingFatalErrorHandler().     highAvailabilityServices.setDispatcherLeaderElectionService(dispatcherLeaderElectionService).     jobGraphFuture = new CompletableFuture<>().     resultFuture = new CompletableFuture<>().     testingJobManagerRunnerFactory = new TestingJobManagerRunnerFactory(jobGraphFuture, resultFuture, CompletableFuture.completedFuture(null)). }
false;public;0;4;;@After public void teardown() throws Exception {     testingFatalErrorHandler.rethrowError(). }
false;public,static;0;10;;@AfterClass public static void teardownClass() throws IOException, InterruptedException, ExecutionException, TimeoutException {     if (blobServer != null) {         blobServer.close().     }     if (rpcService != null) {         RpcUtils.terminateRpcService(rpcService, timeout).     } }
true;public;0;17;/**  * Tests that the {@link MiniDispatcher} recovers the single job with which it  * was started.  */ ;/**  * Tests that the {@link MiniDispatcher} recovers the single job with which it  * was started.  */ @Test public void testSingleJobRecovery() throws Exception {     final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED).     miniDispatcher.start().     try {         // wait until the Dispatcher is the leader         dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().         final JobGraph actualJobGraph = jobGraphFuture.get().         assertThat(actualJobGraph.getJobID(), is(jobGraph.getJobID())).     } finally {         RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout).     } }
true;public;0;21;/**  * Tests that in detached mode, the {@link MiniDispatcher} will complete the future that  * signals job termination.  */ ;/**  * Tests that in detached mode, the {@link MiniDispatcher} will complete the future that  * signals job termination.  */ @Test public void testTerminationAfterJobCompletion() throws Exception {     final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.DETACHED).     miniDispatcher.start().     try {         // wait until the Dispatcher is the leader         dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().         // wait until we have submitted the job         jobGraphFuture.get().         resultFuture.complete(archivedExecutionGraph).         // wait until we terminate         miniDispatcher.getJobTerminationFuture().get().     } finally {         RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout).     } }
true;public;0;29;/**  * Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}  * after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.  */ ;/**  * Tests that the {@link MiniDispatcher} only terminates in {@link ClusterEntrypoint.ExecutionMode#NORMAL}  * after it has served the {@link org.apache.flink.runtime.jobmaster.JobResult} once.  */ @Test public void testJobResultRetrieval() throws Exception {     final MiniDispatcher miniDispatcher = createMiniDispatcher(ClusterEntrypoint.ExecutionMode.NORMAL).     miniDispatcher.start().     try {         // wait until the Dispatcher is the leader         dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get().         // wait until we have submitted the job         jobGraphFuture.get().         resultFuture.complete(archivedExecutionGraph).         assertFalse(miniDispatcher.getTerminationFuture().isDone()).         final DispatcherGateway dispatcherGateway = miniDispatcher.getSelfGateway(DispatcherGateway.class).         final CompletableFuture<JobResult> jobResultFuture = dispatcherGateway.requestJobResult(jobGraph.getJobID(), timeout).         final JobResult jobResult = jobResultFuture.get().         assertThat(jobResult.getJobId(), is(jobGraph.getJobID())).     } finally {         RpcUtils.terminateRpcEndpoint(miniDispatcher, timeout).     } }
false;private;1;19;;// -------------------------------------------------------- // Utilities // -------------------------------------------------------- @Nonnull private MiniDispatcher createMiniDispatcher(ClusterEntrypoint.ExecutionMode executionMode) throws Exception {     return new MiniDispatcher(rpcService, UUID.randomUUID().toString(), configuration, highAvailabilityServices, () -> CompletableFuture.completedFuture(resourceManagerGateway), blobServer, heartbeatServices, UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(), null, archivedExecutionGraphStore, testingJobManagerRunnerFactory, testingFatalErrorHandler, VoidHistoryServerArchivist.INSTANCE, jobGraph, executionMode). }
