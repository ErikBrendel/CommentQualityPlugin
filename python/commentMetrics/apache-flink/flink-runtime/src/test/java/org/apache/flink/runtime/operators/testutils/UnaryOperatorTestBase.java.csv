commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;12;;@Parameterized.Parameters public static Collection<Object[]> getConfigurations() {     ExecutionConfig withReuse = new ExecutionConfig().     withReuse.enableObjectReuse().     ExecutionConfig withoutReuse = new ExecutionConfig().     withoutReuse.disableObjectReuse().     Object[] a = { withoutReuse }.     Object[] b = { withReuse }.     return Arrays.asList(a, b). }
false;public;2;5;;public void setInput(MutableObjectIterator<IN> input, TypeSerializer<IN> serializer) {     this.input = input.     this.inputSerializer = serializer.     this.sorter = null. }
false;public;3;14;;public void addInputSorted(MutableObjectIterator<IN> input, TypeSerializer<IN> serializer, TypeComparator<IN> comp) throws Exception {     this.input = null.     this.inputSerializer = serializer.     this.sorter = new UnilateralSortMerger<IN>(this.memManager, this.ioManager, input, this.owner, this.<IN>getInputSerializer(0), comp, this.perSortFractionMem, 32, 0.8f, true, /*use large record handler*/     false). }
false;public;1;3;;public void addDriverComparator(TypeComparator<IN> comparator) {     this.comparators.add(comparator). }
false;public;1;3;;public void setOutput(Collector<OUT> output) {     this.output = output. }
false;public;2;3;;public void setOutput(List<OUT> output, TypeSerializer<OUT> outSerializer) {     this.output = new ListOutputCollector<OUT>(output, outSerializer). }
false;public;0;3;;public int getNumFileHandlesForSort() {     return numFileHandles. }
false;public;1;3;;public void setNumFileHandlesForSort(int numFileHandles) {     this.numFileHandles = numFileHandles. }
false;public;2;4;;@SuppressWarnings("rawtypes") public void testDriver(Driver driver, Class stubClass) throws Exception {     testDriverInternal(driver, stubClass). }
false;public;2;72;;@SuppressWarnings({ "unchecked", "rawtypes" }) public void testDriverInternal(Driver driver, Class stubClass) throws Exception {     this.driver = driver.     driver.setup(this).     this.stub = (S) stubClass.newInstance().     // regular running logic     this.running = true.     boolean stubOpen = false.     try {         // run the data preparation         try {             driver.prepare().         } catch (Throwable t) {             throw new Exception("The data preparation caused an error: " + t.getMessage(), t).         }         // open stub implementation         try {             FunctionUtils.openFunction(this.stub, getTaskConfig().getStubParameters()).             stubOpen = true.         } catch (Throwable t) {             throw new Exception("The user defined 'open()' method caused an exception: " + t.getMessage(), t).         }         // run the user code         driver.run().         // close. We close here such that a regular close throwing an exception marks a task as failed.         if (this.running) {             FunctionUtils.closeFunction(this.stub).             stubOpen = false.         }         this.output.close().     } catch (Exception ex) {         // close the input, but do not report any exceptions, since we already have another root cause         if (stubOpen) {             try {                 FunctionUtils.closeFunction(this.stub).             } catch (Throwable t) {             // ignore             }         }         // if resettable driver invoke tear-down         if (this.driver instanceof ResettableDriver) {             final ResettableDriver<?, ?> resDriver = (ResettableDriver<?, ?>) this.driver.             try {                 resDriver.teardown().             } catch (Throwable t) {                 throw new Exception("Error while shutting down an iterative operator: " + t.getMessage(), t).             }         }         // drop exception, if the task was canceled         if (this.running) {             throw ex.         }     } finally {         driver.cleanup().     } }
false;public;3;16;;@SuppressWarnings({ "unchecked", "rawtypes" }) public void testResettableDriver(ResettableDriver driver, Class stubClass, int iterations) throws Exception {     driver.setup(this).     for (int i = 0. i < iterations. i++) {         if (i == 0) {             driver.initialize().         } else {             driver.reset().         }         testDriver(driver, stubClass).     }     driver.teardown(). }
false;public;0;4;;public void cancel() throws Exception {     this.running = false.     this.driver.cancel(). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public TaskConfig getTaskConfig() {     return this.taskConfig. }
false;public;0;4;;@Override public ExecutionConfig getExecutionConfig() {     return executionConfig. }
false;public;0;4;;@Override public ClassLoader getUserCodeClassLoader() {     return getClass().getClassLoader(). }
false;public;0;4;;@Override public IOManager getIOManager() {     return this.ioManager. }
false;public;0;4;;@Override public MemoryManager getMemoryManager() {     return this.memManager. }
false;public;0;4;;@Override public TaskManagerRuntimeInfo getTaskManagerInfo() {     return this.taskManageInfo. }
false;public;1;18;;@Override public <X> MutableObjectIterator<X> getInput(int index) {     MutableObjectIterator<IN> in = this.input.     if (in == null) {         // waiting from sorter         try {             in = this.sorter.getIterator().         } catch (InterruptedException e) {             throw new RuntimeException("Interrupted").         }         this.input = in.     }     @SuppressWarnings("unchecked")     MutableObjectIterator<X> input = (MutableObjectIterator<X>) this.input.     return input. }
false;public;1;10;;@Override public <X> TypeSerializerFactory<X> getInputSerializer(int index) {     if (index != 0) {         throw new IllegalArgumentException().     }     @SuppressWarnings("unchecked")     TypeSerializer<X> ser = (TypeSerializer<X>) inputSerializer.     return new RuntimeSerializerFactory<X>(ser, (Class<X>) ser.createInstance().getClass()). }
false;public;1;6;;@Override public <X> TypeComparator<X> getDriverComparator(int index) {     @SuppressWarnings("unchecked")     TypeComparator<X> comparator = (TypeComparator<X>) this.comparators.get(index).     return comparator. }
false;public;0;4;;@Override public S getStub() {     return this.stub. }
false;public;0;4;;@Override public Collector<OUT> getOutputCollector() {     return this.output. }
false;public;0;4;;@Override public AbstractInvokable getContainingTask() {     return this.owner. }
false;public;1;4;;@Override public String formatLogString(String message) {     return "Driver Tester: " + message. }
false;public;0;4;;@Override public OperatorMetricGroup getMetricGroup() {     return UnregisteredMetricGroups.createUnregisteredOperatorMetricGroup(). }
false;public;0;18;;// -------------------------------------------------------------------------------------------- @After public void shutdownAll() throws Exception {     // 1st, shutdown sorters     if (this.sorter != null) {         sorter.close().     }     // 2nd, shutdown I/O     this.ioManager.shutdown().     Assert.assertTrue("I/O Manager has not properly shut down.", this.ioManager.isProperlyShutDown()).     // last, verify all memory is returned and shutdown mem manager     MemoryManager memMan = getMemoryManager().     if (memMan != null) {         Assert.assertTrue("Memory Manager managed memory was not completely freed.", memMan.verifyEmpty()).         memMan.shutdown().     } }
false;public;1;4;;@Override public void collect(OUT record) {     this.output.add(serializer.copy(record)). }
false;public;0;2;;@Override public void close() { }
false;public;1;4;;@Override public void collect(OUT record) {     this.num++. }
false;public;0;2;;@Override public void close() { }
false;public;0;3;;public int getNumberOfRecords() {     return this.num. }
