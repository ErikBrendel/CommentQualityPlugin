commented;modifiers;parameterAmount;loc;comment;code
false;public;0;33;;@Test public void testDeployCall() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid).         final LogicalSlot slot = new TestingLogicalSlot().         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         assertEquals(ExecutionState.CREATED, vertex.getExecutionState()).         vertex.deployToSlot(slot).         assertEquals(ExecutionState.DEPLOYING, vertex.getExecutionState()).         // no repeated scheduling         try {             vertex.deployToSlot(slot).             fail("Scheduled from wrong state").         } catch (IllegalStateException e) {         // as expected         }         assertNull(vertex.getFailureCause()).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.DEPLOYING) > 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;36;;@Test public void testDeployWithSynchronousAnswer() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid, new DirectScheduledExecutorService()).         final LogicalSlot slot = new TestingLogicalSlot().         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         assertEquals(ExecutionState.CREATED, vertex.getExecutionState()).         vertex.deployToSlot(slot).         assertEquals(ExecutionState.DEPLOYING, vertex.getExecutionState()).         // no repeated scheduling         try {             vertex.deployToSlot(slot).             fail("Scheduled from wrong state").         } catch (IllegalStateException e) {         // as expected         }         assertNull(vertex.getFailureCause()).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.DEPLOYING) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.RUNNING) == 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;41;;@Test public void testDeployWithAsynchronousAnswer() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         final LogicalSlot slot = new TestingLogicalSlot().         assertEquals(ExecutionState.CREATED, vertex.getExecutionState()).         vertex.deployToSlot(slot).         // no repeated scheduling         try {             vertex.deployToSlot(slot).             fail("Scheduled from wrong state").         } catch (IllegalStateException e) {         // as expected         }         assertEquals(ExecutionState.DEPLOYING, vertex.getExecutionState()).         // no repeated scheduling         try {             vertex.deployToSlot(slot).             fail("Scheduled from wrong state").         } catch (IllegalStateException e) {         // as expected         }         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.DEPLOYING) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.RUNNING) == 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;27;;@Test public void testDeployFailedSynchronous() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid, new DirectScheduledExecutorService()).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         final LogicalSlot slot = new TestingLogicalSlot(new SubmitFailingSimpleAckingTaskManagerGateway()).         assertEquals(ExecutionState.CREATED, vertex.getExecutionState()).         vertex.deployToSlot(slot).         assertEquals(ExecutionState.FAILED, vertex.getExecutionState()).         assertNotNull(vertex.getFailureCause()).         assertTrue(vertex.getFailureCause().getMessage().contains(ERROR_MESSAGE)).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.DEPLOYING) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.FAILED) > 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;35;;@Test public void testDeployFailedAsynchronously() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         final LogicalSlot slot = new TestingLogicalSlot(new SubmitFailingSimpleAckingTaskManagerGateway()).         assertEquals(ExecutionState.CREATED, vertex.getExecutionState()).         vertex.deployToSlot(slot).         // wait until the state transition must be done         for (int i = 0. i < 100. i++) {             if (vertex.getExecutionState() == ExecutionState.FAILED && vertex.getFailureCause() != null) {                 break.             } else {                 Thread.sleep(10).             }         }         assertEquals(ExecutionState.FAILED, vertex.getExecutionState()).         assertNotNull(vertex.getFailureCause()).         assertTrue(vertex.getFailureCause().getMessage().contains(ERROR_MESSAGE)).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.DEPLOYING) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.FAILED) > 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;30;;@Test public void testFailExternallyDuringDeploy() {     try {         final JobVertexID jid = new JobVertexID().         final ExecutionJobVertex ejv = getExecutionVertex(jid, new DirectScheduledExecutorService()).         final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0], AkkaUtils.getDefaultTimeout()).         TestingLogicalSlot testingLogicalSlot = new TestingLogicalSlot(new SubmitBlockingSimpleAckingTaskManagerGateway()).         assertEquals(ExecutionState.CREATED, vertex.getExecutionState()).         vertex.deployToSlot(testingLogicalSlot).         assertEquals(ExecutionState.DEPLOYING, vertex.getExecutionState()).         Exception testError = new Exception("test error").         vertex.fail(testError).         assertEquals(ExecutionState.FAILED, vertex.getExecutionState()).         assertEquals(testError, vertex.getFailureCause()).         assertTrue(vertex.getStateTimestamp(ExecutionState.CREATED) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.DEPLOYING) > 0).         assertTrue(vertex.getStateTimestamp(ExecutionState.FAILED) > 0).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;6;;@Override public CompletableFuture<Acknowledge> submitTask(TaskDeploymentDescriptor tdd, Time timeout) {     CompletableFuture<Acknowledge> future = new CompletableFuture<>().     future.completeExceptionally(new Exception(ERROR_MESSAGE)).     return future. }
false;public;2;4;;@Override public CompletableFuture<Acknowledge> submitTask(TaskDeploymentDescriptor tdd, Time timeout) {     return new CompletableFuture<>(). }
true;public;0;33;/**  * Tests that the lazy scheduling flag is correctly forwarded to the produced partition descriptors.  */ ;/**  * Tests that the lazy scheduling flag is correctly forwarded to the produced partition descriptors.  */ @Test public void testTddProducedPartitionsLazyScheduling() throws Exception {     ExecutionJobVertex jobVertex = getExecutionVertex(new JobVertexID(), new DirectScheduledExecutorService()).     IntermediateResult result = new IntermediateResult(new IntermediateDataSetID(), jobVertex, 1, ResultPartitionType.PIPELINED).     ExecutionVertex vertex = new ExecutionVertex(jobVertex, 0, new IntermediateResult[] { result }, Time.minutes(1)).     ExecutionEdge mockEdge = createMockExecutionEdge(1).     result.getPartitions()[0].addConsumerGroup().     result.getPartitions()[0].addConsumer(mockEdge, 0).     SlotContext slotContext = mock(SlotContext.class).     when(slotContext.getAllocationId()).thenReturn(new AllocationID()).     LogicalSlot slot = mock(LogicalSlot.class).     when(slot.getAllocationId()).thenReturn(new AllocationID()).     for (ScheduleMode mode : ScheduleMode.values()) {         vertex.getExecutionGraph().setScheduleMode(mode).         TaskDeploymentDescriptor tdd = vertex.createDeploymentDescriptor(new ExecutionAttemptID(), slot, null, 1).         Collection<ResultPartitionDeploymentDescriptor> producedPartitions = tdd.getProducedPartitions().         assertEquals(1, producedPartitions.size()).         ResultPartitionDeploymentDescriptor desc = producedPartitions.iterator().next().         assertEquals(mode.allowLazyDeployment(), desc.sendScheduleOrUpdateConsumersMessage()).     } }
false;private;1;11;;private ExecutionEdge createMockExecutionEdge(int maxParallelism) {     ExecutionVertex targetVertex = mock(ExecutionVertex.class).     ExecutionJobVertex targetJobVertex = mock(ExecutionJobVertex.class).     when(targetVertex.getJobVertex()).thenReturn(targetJobVertex).     when(targetJobVertex.getMaxParallelism()).thenReturn(maxParallelism).     ExecutionEdge edge = mock(ExecutionEdge.class).     when(edge.getTarget()).thenReturn(targetVertex).     return edge. }
