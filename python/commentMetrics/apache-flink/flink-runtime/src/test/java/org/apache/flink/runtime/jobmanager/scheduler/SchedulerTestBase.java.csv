commented;modifiers;parameterAmount;loc;comment;code
false;public;0;17;;@Before public void setup() throws Exception {     final JobID jobId = new JobID().     final SlotPool slotPool = new SlotPoolImpl(jobId).     final TestingScheduler testingScheduler = new TestingScheduler(new HashMap<>(16), LocationPreferenceSlotSelectionStrategy.INSTANCE, slotPool).     testingSlotProvider = new TestingSlotPoolSlotProvider(slotPool, testingScheduler).     final JobMasterId jobMasterId = JobMasterId.generate().     final String jobManagerAddress = "localhost".     ComponentMainThreadExecutor executor = TestingComponentMainThreadExecutorServiceAdapter.forMainThread().     slotPool.start(jobMasterId, jobManagerAddress, executor).     testingScheduler.start(executor). }
false;public;0;7;;@After public void teardown() throws Exception {     if (testingSlotProvider != null) {         testingSlotProvider.shutdown().         testingSlotProvider = null.     } }
false;;1;1;;TaskManagerLocation addTaskManager(int numberSlots).
false;;1;1;;void releaseTaskManager(ResourceID resourceId).
false;;0;1;;int getNumberOfAvailableSlots().
false;;0;1;;int getNumberOfLocalizedAssignments().
false;;0;1;;int getNumberOfNonLocalizedAssignments().
false;;0;1;;int getNumberOfUnconstrainedAssignments().
false;;0;1;;int getNumberOfHostLocalizedAssignments().
false;;1;1;;int getNumberOfSlots(SlotSharingGroup slotSharingGroup).
false;;2;1;;int getNumberOfAvailableSlotsForGroup(SlotSharingGroup slotSharingGroup, JobVertexID jobVertexId).
false;;0;1;;void shutdown() throws Exception.
false;public;1;39;;@Override public TaskManagerLocation addTaskManager(int numberSlots) {     final TaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation().     final ResourceID resourceId = taskManagerLocation.getResourceID().     final SlotPool slotPoolGateway = slotPool.     try {         slotPoolGateway.registerTaskManager(resourceId).     } catch (Exception e) {         throw new RuntimeException("Unexpected exception occurred. This indicates a programming bug.", e).     }     final TaskManagerGateway taskManagerGateway = new SimpleAckingTaskManagerGateway().     final Collection<SlotOffer> slotOffers = new ArrayList<>(numberSlots).     for (int i = 0. i < numberSlots. i++) {         final SlotOffer slotOffer = new SlotOffer(new AllocationID(), i, ResourceProfile.UNKNOWN).         slotOffers.add(slotOffer).     }     final Collection<SlotOffer> acceptedSlotOffers.     try {         acceptedSlotOffers = slotPoolGateway.offerSlots(taskManagerLocation, taskManagerGateway, slotOffers).     } catch (Exception e) {         throw new RuntimeException("Unexpected exception occurred. This indicates a programming bug.", e).     }     Preconditions.checkState(acceptedSlotOffers.size() == numberSlots).     return taskManagerLocation. }
false;public;1;8;;@Override public void releaseTaskManager(ResourceID resourceId) {     try {         slotPool.releaseTaskManager(resourceId, null).     } catch (Exception e) {         throw new RuntimeException("Should not have happened.", e).     } }
false;public;0;4;;@Override public int getNumberOfAvailableSlots() {     return slotPool.getAvailableSlotsInformation().size(). }
false;public;0;4;;@Override public int getNumberOfLocalizedAssignments() {     return numberOfLocalizedAssignments.get(). }
false;public;0;4;;@Override public int getNumberOfNonLocalizedAssignments() {     return numberOfNonLocalizedAssignments.get(). }
false;public;0;4;;@Override public int getNumberOfUnconstrainedAssignments() {     return numberOfUnconstrainedAssignments.get(). }
false;public;0;4;;@Override public int getNumberOfHostLocalizedAssignments() {     return numberOfHostLocalizedAssignments.get(). }
false;public;1;4;;@Override public int getNumberOfSlots(SlotSharingGroup slotSharingGroup) {     return scheduler.getNumberOfSharedSlots(slotSharingGroup.getSlotSharingGroupId()). }
false;public;2;4;;@Override public int getNumberOfAvailableSlotsForGroup(SlotSharingGroup slotSharingGroup, JobVertexID jobVertexId) {     return scheduler.getNumberOfAvailableSlotsForGroup(slotSharingGroup.getSlotSharingGroupId(), jobVertexId). }
false;public;0;4;;@Override public void shutdown() {     slotPool.close(). }
false;public;5;29;;@Override public CompletableFuture<LogicalSlot> allocateSlot(SlotRequestId slotRequestId, ScheduledUnit task, SlotProfile slotProfile, boolean allowQueued, Time allocationTimeout) {     return scheduler.allocateSlot(task, allowQueued, slotProfile, allocationTimeout).thenApply((LogicalSlot logicalSlot) -> {         switch(logicalSlot.getLocality()) {             case LOCAL:                 numberOfLocalizedAssignments.incrementAndGet().                 break.             case UNCONSTRAINED:                 numberOfUnconstrainedAssignments.incrementAndGet().                 break.             case NON_LOCAL:                 numberOfNonLocalizedAssignments.incrementAndGet().                 break.             case HOST_LOCAL:                 numberOfHostLocalizedAssignments.incrementAndGet().                 break.             default:         }         return logicalSlot.     }). }
false;public;3;3;;@Override public void cancelSlotRequest(SlotRequestId slotRequestId, @Nullable SlotSharingGroupId slotSharingGroupId, Throwable cause) { }
false;public;1;9;;public int getNumberOfSharedSlots(SlotSharingGroupId slotSharingGroupId) {     final SlotSharingManager multiTaskSlotManager = slotSharingManagersMap.get(slotSharingGroupId).     if (multiTaskSlotManager != null) {         return multiTaskSlotManager.getResolvedRootSlots().size().     } else {         throw new FlinkRuntimeException("No MultiTaskSlotManager registered under " + slotSharingGroupId + '.').     } }
false;public;2;17;;public int getNumberOfAvailableSlotsForGroup(SlotSharingGroupId slotSharingGroupId, JobVertexID jobVertexId) {     final SlotSharingManager multiTaskSlotManager = slotSharingManagersMap.get(slotSharingGroupId).     if (multiTaskSlotManager != null) {         int availableSlots = 0.         for (SlotSharingManager.MultiTaskSlot multiTaskSlot : multiTaskSlotManager.getResolvedRootSlots()) {             if (!multiTaskSlot.contains(jobVertexId)) {                 availableSlots++.             }         }         return availableSlots.     } else {         throw new FlinkRuntimeException("No MultiTaskSlotmanager registered under " + slotSharingGroupId + '.').     } }
