commented;modifiers;parameterAmount;loc;comment;code
true;public;0;50;/**  * Tests that slots are released if we cannot assign the allocated resource to the  * Execution.  */ ;/**  * Tests that slots are released if we cannot assign the allocated resource to the  * Execution.  */ @Test public void testSlotReleaseOnFailedResourceAssignment() throws Exception {     final JobVertex jobVertex = createNoOpJobVertex().     final JobVertexID jobVertexId = jobVertex.getID().     final CompletableFuture<LogicalSlot> slotFuture = new CompletableFuture<>().     final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(1).     slotProvider.addSlot(jobVertexId, 0, slotFuture).     ExecutionGraph executionGraph = ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(), slotProvider, new NoRestartStrategy(), jobVertex).     executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread()).     ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId).     final Execution execution = executionJobVertex.getTaskVertices()[0].getCurrentExecutionAttempt().     final SingleSlotTestingSlotOwner slotOwner = new SingleSlotTestingSlotOwner().     final SimpleSlot slot = new SimpleSlot(slotOwner, new LocalTaskManagerLocation(), 0, new SimpleAckingTaskManagerGateway()).     final LogicalSlot otherSlot = new TestingLogicalSlot().     CompletableFuture<Execution> allocationFuture = execution.allocateAndAssignSlotForExecution(slotProvider, false, LocationPreferenceConstraint.ALL, Collections.emptySet(), TestingUtils.infiniteTime()).     assertFalse(allocationFuture.isDone()).     assertEquals(ExecutionState.SCHEDULED, execution.getState()).     // assign a different resource to the execution     assertTrue(execution.tryAssignResource(otherSlot)).     // completing now the future should cause the slot to be released     slotFuture.complete(slot).     assertEquals(slot, slotOwner.getReturnedSlotFuture().get()). }
true;public;0;47;/**  * Tests that the slot is released in case of a execution cancellation when having  * a slot assigned and being in state SCHEDULED.  */ ;/**  * Tests that the slot is released in case of a execution cancellation when having  * a slot assigned and being in state SCHEDULED.  */ @Test public void testSlotReleaseOnExecutionCancellationInScheduled() throws Exception {     final JobVertex jobVertex = createNoOpJobVertex().     final JobVertexID jobVertexId = jobVertex.getID().     final SingleSlotTestingSlotOwner slotOwner = new SingleSlotTestingSlotOwner().     final SimpleSlot slot = new SimpleSlot(slotOwner, new LocalTaskManagerLocation(), 0, new SimpleAckingTaskManagerGateway()).     final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(1).     slotProvider.addSlot(jobVertexId, 0, CompletableFuture.completedFuture(slot)).     ExecutionGraph executionGraph = ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(), slotProvider, new NoRestartStrategy(), jobVertex).     executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread()).     ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId).     final Execution execution = executionJobVertex.getTaskVertices()[0].getCurrentExecutionAttempt().     CompletableFuture<Execution> allocationFuture = execution.allocateAndAssignSlotForExecution(slotProvider, false, LocationPreferenceConstraint.ALL, Collections.emptySet(), TestingUtils.infiniteTime()).     assertTrue(allocationFuture.isDone()).     assertEquals(ExecutionState.SCHEDULED, execution.getState()).     assertEquals(slot, execution.getAssignedResource()).     // cancelling the execution should move it into state CANCELED     execution.cancel().     assertEquals(ExecutionState.CANCELED, execution.getState()).     assertEquals(slot, slotOwner.getReturnedSlotFuture().get()). }
true;public;0;51;/**  * Tests that the slot is released in case of a execution cancellation when being in state  * RUNNING.  */ ;/**  * Tests that the slot is released in case of a execution cancellation when being in state  * RUNNING.  */ @Test public void testSlotReleaseOnExecutionCancellationInRunning() throws Exception {     final JobVertex jobVertex = createNoOpJobVertex().     final JobVertexID jobVertexId = jobVertex.getID().     final SingleSlotTestingSlotOwner slotOwner = new SingleSlotTestingSlotOwner().     final SimpleSlot slot = new SimpleSlot(slotOwner, new LocalTaskManagerLocation(), 0, new SimpleAckingTaskManagerGateway()).     final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(1).     slotProvider.addSlot(jobVertexId, 0, CompletableFuture.completedFuture(slot)).     ExecutionGraph executionGraph = ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(), slotProvider, new NoRestartStrategy(), jobVertex).     ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId).     final Execution execution = executionJobVertex.getTaskVertices()[0].getCurrentExecutionAttempt().     CompletableFuture<Execution> allocationFuture = execution.allocateAndAssignSlotForExecution(slotProvider, false, LocationPreferenceConstraint.ALL, Collections.emptySet(), TestingUtils.infiniteTime()).     assertTrue(allocationFuture.isDone()).     assertEquals(ExecutionState.SCHEDULED, execution.getState()).     assertEquals(slot, execution.getAssignedResource()).     execution.deploy().     execution.switchToRunning().     // cancelling the execution should move it into state CANCELING     execution.cancel().     assertEquals(ExecutionState.CANCELING, execution.getState()).     execution.completeCancelling().     assertEquals(slot, slotOwner.getReturnedSlotFuture().get()). }
true;public;0;46;/**  * Tests that a slot allocation from a {@link SlotProvider} is cancelled if the  * {@link Execution} is cancelled.  */ ;/**  * Tests that a slot allocation from a {@link SlotProvider} is cancelled if the  * {@link Execution} is cancelled.  */ @Test public void testSlotAllocationCancellationWhenExecutionCancelled() throws Exception {     final JobVertexID jobVertexId = new JobVertexID().     final JobVertex jobVertex = new JobVertex("test vertex", jobVertexId).     jobVertex.setInvokableClass(NoOpInvokable.class).     final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(1).     final CompletableFuture<LogicalSlot> slotFuture = new CompletableFuture<>().     slotProvider.addSlot(jobVertexId, 0, slotFuture).     final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(), slotProvider, new NoRestartStrategy(), jobVertex).     executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread()).     final ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId).     final Execution currentExecutionAttempt = executionJobVertex.getTaskVertices()[0].getCurrentExecutionAttempt().     final CompletableFuture<Execution> allocationFuture = currentExecutionAttempt.allocateAndAssignSlotForExecution(slotProvider, false, LocationPreferenceConstraint.ALL, Collections.emptySet(), TestingUtils.infiniteTime()).     assertThat(allocationFuture.isDone(), is(false)).     assertThat(slotProvider.getSlotRequestedFuture(jobVertexId, 0).get(), is(true)).     final Set<SlotRequestId> slotRequests = slotProvider.getSlotRequests().     assertThat(slotRequests, hasSize(1)).     assertThat(currentExecutionAttempt.getState(), is(ExecutionState.SCHEDULED)).     currentExecutionAttempt.cancel().     assertThat(currentExecutionAttempt.getState(), is(ExecutionState.CANCELED)).     assertThat(allocationFuture.isCompletedExceptionally(), is(true)).     final Set<SlotRequestId> canceledSlotRequests = slotProvider.getCanceledSlotRequests().     assertThat(canceledSlotRequests, equalTo(slotRequests)). }
true;public;0;28;/**  * Tests that all preferred locations are calculated.  */ ;/**  * Tests that all preferred locations are calculated.  */ @Test public void testAllPreferredLocationCalculation() throws ExecutionException, InterruptedException {     final TaskManagerLocation taskManagerLocation1 = new LocalTaskManagerLocation().     final TaskManagerLocation taskManagerLocation2 = new LocalTaskManagerLocation().     final TaskManagerLocation taskManagerLocation3 = new LocalTaskManagerLocation().     final CompletableFuture<TaskManagerLocation> locationFuture1 = CompletableFuture.completedFuture(taskManagerLocation1).     final CompletableFuture<TaskManagerLocation> locationFuture2 = new CompletableFuture<>().     final CompletableFuture<TaskManagerLocation> locationFuture3 = new CompletableFuture<>().     final Execution execution = SchedulerTestUtils.getTestVertex(Arrays.asList(locationFuture1, locationFuture2, locationFuture3)).     CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = execution.calculatePreferredLocations(LocationPreferenceConstraint.ALL).     assertFalse(preferredLocationsFuture.isDone()).     locationFuture3.complete(taskManagerLocation3).     assertFalse(preferredLocationsFuture.isDone()).     locationFuture2.complete(taskManagerLocation2).     assertTrue(preferredLocationsFuture.isDone()).     final Collection<TaskManagerLocation> preferredLocations = preferredLocationsFuture.get().     assertThat(preferredLocations, containsInAnyOrder(taskManagerLocation1, taskManagerLocation2, taskManagerLocation3)). }
true;public;0;19;/**  * Tests that any preferred locations are calculated.  */ ;/**  * Tests that any preferred locations are calculated.  */ @Test public void testAnyPreferredLocationCalculation() throws ExecutionException, InterruptedException {     final TaskManagerLocation taskManagerLocation1 = new LocalTaskManagerLocation().     final TaskManagerLocation taskManagerLocation3 = new LocalTaskManagerLocation().     final CompletableFuture<TaskManagerLocation> locationFuture1 = CompletableFuture.completedFuture(taskManagerLocation1).     final CompletableFuture<TaskManagerLocation> locationFuture2 = new CompletableFuture<>().     final CompletableFuture<TaskManagerLocation> locationFuture3 = CompletableFuture.completedFuture(taskManagerLocation3).     final Execution execution = SchedulerTestUtils.getTestVertex(Arrays.asList(locationFuture1, locationFuture2, locationFuture3)).     CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = execution.calculatePreferredLocations(LocationPreferenceConstraint.ANY).     assertTrue(preferredLocationsFuture.isDone()).     final Collection<TaskManagerLocation> preferredLocations = preferredLocationsFuture.get().     assertThat(preferredLocations, containsInAnyOrder(taskManagerLocation1, taskManagerLocation3)). }
true;public;0;41;/**  * Checks that the {@link Execution} termination future is only completed after the  * assigned slot has been released.  *  * <p>NOTE: This test only fails spuriously without the fix of this commit. Thus, one has  * to execute this test multiple times to see the failure.  */ ;/**  * Checks that the {@link Execution} termination future is only completed after the  * assigned slot has been released.  *  * <p>NOTE: This test only fails spuriously without the fix of this commit. Thus, one has  * to execute this test multiple times to see the failure.  */ @Test public void testTerminationFutureIsCompletedAfterSlotRelease() throws Exception {     final JobVertex jobVertex = createNoOpJobVertex().     final JobVertexID jobVertexId = jobVertex.getID().     final SingleSlotTestingSlotOwner slotOwner = new SingleSlotTestingSlotOwner().     final ProgrammedSlotProvider slotProvider = createProgrammedSlotProvider(1, Collections.singleton(jobVertexId), slotOwner).     ExecutionGraph executionGraph = ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(), slotProvider, new NoRestartStrategy(), jobVertex).     executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread()).     ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId).     ExecutionVertex executionVertex = executionJobVertex.getTaskVertices()[0].     executionVertex.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY, Collections.emptySet()).get().     Execution currentExecutionAttempt = executionVertex.getCurrentExecutionAttempt().     CompletableFuture<LogicalSlot> returnedSlotFuture = slotOwner.getReturnedSlotFuture().     CompletableFuture<?> terminationFuture = executionVertex.cancel().     currentExecutionAttempt.completeCancelling().     CompletableFuture<Boolean> restartFuture = terminationFuture.thenApply(ignored -> {         assertTrue(returnedSlotFuture.isDone()).         return true.     }).     // check if the returned slot future was completed first     restartFuture.get(). }
true;public;0;33;/**  * Tests that the task restore state is nulled after the {@link Execution} has been  * deployed. See FLINK-9693.  */ ;/**  * Tests that the task restore state is nulled after the {@link Execution} has been  * deployed. See FLINK-9693.  */ @Test public void testTaskRestoreStateIsNulledAfterDeployment() throws Exception {     final JobVertex jobVertex = createNoOpJobVertex().     final JobVertexID jobVertexId = jobVertex.getID().     final SingleSlotTestingSlotOwner slotOwner = new SingleSlotTestingSlotOwner().     final ProgrammedSlotProvider slotProvider = createProgrammedSlotProvider(1, Collections.singleton(jobVertexId), slotOwner).     ExecutionGraph executionGraph = ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(), slotProvider, new NoRestartStrategy(), jobVertex).     ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId).     ExecutionVertex executionVertex = executionJobVertex.getTaskVertices()[0].     final Execution execution = executionVertex.getCurrentExecutionAttempt().     final JobManagerTaskRestore taskRestoreState = new JobManagerTaskRestore(1L, new TaskStateSnapshot()).     execution.setInitialState(taskRestoreState).     assertThat(execution.getTaskRestore(), is(notNullValue())).     // schedule the execution vertex and wait for its deployment     executionVertex.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY, Collections.emptySet()).get().     assertThat(execution.getTaskRestore(), is(nullValue())). }
false;public;0;70;;@Test public void testEagerSchedulingFailureReturnsSlot() throws Exception {     final JobVertex jobVertex = createNoOpJobVertex().     final JobVertexID jobVertexId = jobVertex.getID().     final SimpleAckingTaskManagerGateway taskManagerGateway = new SimpleAckingTaskManagerGateway().     final SingleSlotTestingSlotOwner slotOwner = new SingleSlotTestingSlotOwner().     final CompletableFuture<SlotRequestId> slotRequestIdFuture = new CompletableFuture<>().     final CompletableFuture<SlotRequestId> returnedSlotFuture = new CompletableFuture<>().     final TestingSlotProvider slotProvider = new TestingSlotProvider((SlotRequestId slotRequestId) -> {         slotRequestIdFuture.complete(slotRequestId).         return new CompletableFuture<>().     }).     slotProvider.setSlotCanceller(returnedSlotFuture::complete).     slotOwner.getReturnedSlotFuture().thenAccept((LogicalSlot logicalSlot) -> returnedSlotFuture.complete(logicalSlot.getSlotRequestId())).     ExecutionGraph executionGraph = ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(), slotProvider, new NoRestartStrategy(), jobVertex).     executionGraph.start(testMainThreadUtil.getMainThreadExecutor()).     ExecutionJobVertex executionJobVertex = executionGraph.getJobVertex(jobVertexId).     ExecutionVertex executionVertex = executionJobVertex.getTaskVertices()[0].     final Execution execution = executionVertex.getCurrentExecutionAttempt().     taskManagerGateway.setCancelConsumer(executionAttemptID -> {         if (execution.getAttemptId().equals(executionAttemptID)) {             execution.completeCancelling().         }     }).     slotRequestIdFuture.thenAcceptAsync((SlotRequestId slotRequestId) -> {         final SingleLogicalSlot singleLogicalSlot = ExecutionGraphSchedulingTest.createSingleLogicalSlot(slotOwner, taskManagerGateway, slotRequestId).         slotProvider.complete(slotRequestId, singleLogicalSlot).     }, testMainThreadUtil.getMainThreadExecutor()).     final CompletableFuture<Void> schedulingFuture = testMainThreadUtil.execute(() -> execution.scheduleForExecution(slotProvider, false, LocationPreferenceConstraint.ANY, Collections.emptySet())).     try {         schedulingFuture.get().         // cancel the execution in case we could schedule the execution         testMainThreadUtil.execute(execution::cancel).     } catch (ExecutionException ignored) {     }     assertThat(returnedSlotFuture.get(), is(equalTo(slotRequestIdFuture.get()))). }
true;public;0;38;/**  * Tests that a slot release will atomically release the assigned {@link Execution}.  */ ;/**  * Tests that a slot release will atomically release the assigned {@link Execution}.  */ @Test public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {     final JobVertex jobVertex = createNoOpJobVertex().     final SingleSlotTestingSlotOwner slotOwner = new SingleSlotTestingSlotOwner().     final SingleLogicalSlot slot = ExecutionGraphSchedulingTest.createSingleLogicalSlot(slotOwner, new SimpleAckingTaskManagerGateway(), new SlotRequestId()).     final CompletableFuture<LogicalSlot> slotFuture = CompletableFuture.completedFuture(slot).     final CountDownLatch slotRequestLatch = new CountDownLatch(1).     final TestingSlotProvider slotProvider = new TestingSlotProvider(slotRequestId -> {         slotRequestLatch.countDown().         return slotFuture.     }).     final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createSimpleTestGraph(new JobID(), slotProvider, new NoRestartStrategy(), jobVertex).     final Execution execution = executionGraph.getJobVertex(jobVertex.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().     executionGraph.start(testMainThreadUtil.getMainThreadExecutor()).     testMainThreadUtil.execute(executionGraph::scheduleForExecution).     // wait until the slot has been requested     slotRequestLatch.await().     testMainThreadUtil.execute(() -> {         assertThat(execution.getAssignedResource(), is(sameInstance(slot))).         slot.release(new FlinkException("Test exception")).         assertThat(execution.getReleaseFuture().isDone(), is(true)).     }). }
false;private;0;7;;@Nonnull private JobVertex createNoOpJobVertex() {     final JobVertex jobVertex = new JobVertex("Test vertex", new JobVertexID()).     jobVertex.setInvokableClass(NoOpInvokable.class).     return jobVertex. }
false;private;3;23;;@Nonnull private ProgrammedSlotProvider createProgrammedSlotProvider(int parallelism, Collection<JobVertexID> jobVertexIds, SlotOwner slotOwner) {     final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism).     for (JobVertexID jobVertexId : jobVertexIds) {         for (int i = 0. i < parallelism. i++) {             final SimpleSlot slot = new SimpleSlot(slotOwner, new LocalTaskManagerLocation(), 0, new SimpleAckingTaskManagerGateway(), null, null).             slotProvider.addSlot(jobVertexId, 0, CompletableFuture.completedFuture(slot)).         }     }     return slotProvider. }
false;public;0;3;;public CompletableFuture<LogicalSlot> getReturnedSlotFuture() {     return returnedSlot. }
false;public;1;4;;@Override public void returnLogicalSlot(LogicalSlot logicalSlot) {     returnedSlot.complete(logicalSlot). }
