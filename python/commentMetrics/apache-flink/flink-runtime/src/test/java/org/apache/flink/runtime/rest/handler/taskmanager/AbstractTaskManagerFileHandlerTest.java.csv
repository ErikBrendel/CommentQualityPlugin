commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;13;;@BeforeClass public static void setup() throws IOException, HandlerRequestException {     final Configuration configuration = new Configuration().     configuration.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath()).     blobServer = new BlobServer(configuration, new VoidBlobStore()).     handlerRequest = new HandlerRequest<>(EmptyRequestBody.getInstance(), new TaskManagerMessageParameters(), Collections.singletonMap(TaskManagerIdPathParameter.KEY, EXPECTED_TASK_MANAGER_ID.getResourceIdString()), Collections.emptyMap()). }
false;public;0;10;;@Before public void setupTest() throws IOException {     fileContent1 = UUID.randomUUID().toString().     final File file1 = createFileWithContent(fileContent1).     transientBlobKey1 = storeFileInBlobServer(file1).     fileContent2 = UUID.randomUUID().toString().     final File file2 = createFileWithContent(fileContent2).     transientBlobKey2 = storeFileInBlobServer(file2). }
false;public,static;0;7;;@AfterClass public static void teardown() throws IOException {     if (blobServer != null) {         blobServer.close().         blobServer = null.     } }
true;public;0;22;/**  * Tests that the {@link AbstractTaskManagerFileHandler} serves the requested file.  */ ;/**  * Tests that the {@link AbstractTaskManagerFileHandler} serves the requested file.  */ @Test public void testFileServing() throws Exception {     final Time cacheEntryDuration = Time.milliseconds(1000L).     final Queue<CompletableFuture<TransientBlobKey>> requestFileUploads = new ArrayDeque<>(1).     requestFileUploads.add(CompletableFuture.completedFuture(transientBlobKey1)).     final TestTaskManagerFileHandler testTaskManagerFileHandler = createTestTaskManagerFileHandler(cacheEntryDuration, requestFileUploads, EXPECTED_TASK_MANAGER_ID).     final File outputFile = temporaryFolder.newFile().     final TestingChannelHandlerContext testingContext = new TestingChannelHandlerContext(outputFile).     testTaskManagerFileHandler.respondToRequest(testingContext, HTTP_REQUEST, handlerRequest, null).     assertThat(outputFile.length(), is(greaterThan(0L))).     assertThat(FileUtils.readFileUtf8(outputFile), is(equalTo(fileContent1))). }
true;public;0;9;/**  * Tests that files are cached.  */ ;/**  * Tests that files are cached.  */ @Test public void testFileCaching() throws Exception {     final File outputFile = runFileCachingTest(Time.milliseconds(5000L), Time.milliseconds(0L)).     assertThat(outputFile.length(), is(greaterThan(0L))).     assertThat(FileUtils.readFileUtf8(outputFile), is(equalTo(fileContent1))). }
true;public;0;9;/**  * Tests that file cache entries expire.  */ ;/**  * Tests that file cache entries expire.  */ @Test public void testFileCacheExpiration() throws Exception {     final Time cacheEntryDuration = Time.milliseconds(5L).     final File outputFile = runFileCachingTest(cacheEntryDuration, cacheEntryDuration).     assertThat(outputFile.length(), is(greaterThan(0L))).     assertThat(FileUtils.readFileUtf8(outputFile), is(equalTo(fileContent2))). }
false;private;2;31;;private File runFileCachingTest(Time cacheEntryDuration, Time delayBetweenRequests) throws Exception {     final Queue<CompletableFuture<TransientBlobKey>> requestFileUploads = new ArrayDeque<>(2).     requestFileUploads.add(CompletableFuture.completedFuture(transientBlobKey1)).     requestFileUploads.add(CompletableFuture.completedFuture(transientBlobKey2)).     final TestTaskManagerFileHandler testTaskManagerFileHandler = createTestTaskManagerFileHandler(cacheEntryDuration, requestFileUploads, EXPECTED_TASK_MANAGER_ID).     final File outputFile = temporaryFolder.newFile().     final TestingChannelHandlerContext testingContext = new TestingChannelHandlerContext(outputFile).     testTaskManagerFileHandler.respondToRequest(testingContext, HTTP_REQUEST, handlerRequest, null).     Thread.sleep(delayBetweenRequests.toMilliseconds()).     // the handler should not trigger the file upload again because it is still cached     testTaskManagerFileHandler.respondToRequest(testingContext, HTTP_REQUEST, handlerRequest, null).     return outputFile. }
false;private;3;17;;private AbstractTaskManagerFileHandlerTest.TestTaskManagerFileHandler createTestTaskManagerFileHandler(Time cacheEntryDuration, Queue<CompletableFuture<TransientBlobKey>> requestFileUploads, ResourceID expectedTaskManagerId) {     final ResourceManagerGateway resourceManagerGateway = new TestingResourceManagerGateway().     return new TestTaskManagerFileHandler(() -> CompletableFuture.completedFuture(null), TestingUtils.infiniteTime(), Collections.emptyMap(), new TestUntypedMessageHeaders(), () -> CompletableFuture.completedFuture(resourceManagerGateway), blobServer, cacheEntryDuration, requestFileUploads, expectedTaskManagerId). }
false;private,static;1;10;;private static File createFileWithContent(String fileContent) throws IOException {     final File file = temporaryFolder.newFile().     // write random content into the file     try (FileOutputStream fileOutputStream = new FileOutputStream(file)) {         fileOutputStream.write(fileContent.getBytes("UTF-8")).     }     return file. }
false;private,static;1;6;;private static TransientBlobKey storeFileInBlobServer(File fileToStore) throws IOException {     // store the requested file in the BlobServer     try (FileInputStream fileInputStream = new FileInputStream(fileToStore)) {         return blobServer.getTransientBlobService().putTransient(fileInputStream).     } }
false;protected;2;11;;@Override protected CompletableFuture<TransientBlobKey> requestFileUpload(ResourceManagerGateway resourceManagerGateway, ResourceID taskManagerResourceId) {     assertThat(taskManagerResourceId, is(equalTo(expectedTaskManagerId))).     final CompletableFuture<TransientBlobKey> transientBlobKeyFuture = requestFileUploads.poll().     if (transientBlobKeyFuture != null) {         return transientBlobKeyFuture.     } else {         return FutureUtils.completedExceptionally(new FlinkException("Could not upload file.")).     } }
false;public;2;16;;@Override public ChannelFuture write(Object msg, ChannelPromise promise) {     if (msg instanceof DefaultFileRegion) {         final DefaultFileRegion defaultFileRegion = (DefaultFileRegion) msg.         try (final FileOutputStream fileOutputStream = new FileOutputStream(outputFile)) {             fileOutputStream.getChannel().             defaultFileRegion.transferTo(fileOutputStream.getChannel(), 0L).         } catch (IOException ioe) {             throw new RuntimeException(ioe).         }     }     return new DefaultChannelPromise(new EmbeddedChannel()). }
false;public;0;4;;@Override public EventExecutor executor() {     return ImmediateEventExecutor.INSTANCE. }
false;public;1;4;;@Override public ChannelFuture write(Object msg) {     return write(msg, null). }
false;public;2;6;;@Override public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {     final ChannelFuture channelFuture = write(msg, promise).     flush().     return channelFuture. }
false;public;1;4;;@Override public ChannelFuture writeAndFlush(Object msg) {     return writeAndFlush(msg, null). }
false;public;0;4;;@Override public ChannelPipeline pipeline() {     return mock(ChannelPipeline.class). }
false;public;0;4;;// ----------------------------------------------------- // Automatically generated implementation // ----------------------------------------------------- @Override public Channel channel() {     return null. }
false;public;0;4;;@Override public String name() {     return null. }
false;public;0;4;;@Override public ChannelHandler handler() {     return null. }
false;public;0;4;;@Override public boolean isRemoved() {     return false. }
false;public;0;4;;@Override public ChannelHandlerContext fireChannelRegistered() {     return null. }
false;public;0;4;;@Override public ChannelHandlerContext fireChannelUnregistered() {     return null. }
false;public;0;4;;@Override public ChannelHandlerContext fireChannelActive() {     return null. }
false;public;0;4;;@Override public ChannelHandlerContext fireChannelInactive() {     return null. }
false;public;1;4;;@Override public ChannelHandlerContext fireExceptionCaught(Throwable cause) {     return null. }
false;public;1;4;;@Override public ChannelHandlerContext fireUserEventTriggered(Object event) {     return null. }
false;public;1;4;;@Override public ChannelHandlerContext fireChannelRead(Object msg) {     return null. }
false;public;0;4;;@Override public ChannelHandlerContext fireChannelReadComplete() {     return null. }
false;public;0;4;;@Override public ChannelHandlerContext fireChannelWritabilityChanged() {     return null. }
false;public;1;4;;@Override public ChannelFuture bind(SocketAddress localAddress) {     return null. }
false;public;1;4;;@Override public ChannelFuture connect(SocketAddress remoteAddress) {     return null. }
false;public;2;4;;@Override public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {     return null. }
false;public;0;4;;@Override public ChannelFuture disconnect() {     return null. }
false;public;0;4;;@Override public ChannelFuture close() {     return null. }
false;public;0;4;;@Override public ChannelFuture deregister() {     return null. }
false;public;2;4;;@Override public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {     return null. }
false;public;2;4;;@Override public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {     return null. }
false;public;3;4;;@Override public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {     return null. }
false;public;1;4;;@Override public ChannelFuture disconnect(ChannelPromise promise) {     return null. }
false;public;1;4;;@Override public ChannelFuture close(ChannelPromise promise) {     return null. }
false;public;1;4;;@Override public ChannelFuture deregister(ChannelPromise promise) {     return null. }
false;public;0;4;;@Override public ChannelHandlerContext read() {     return null. }
false;public;0;4;;@Override public ChannelHandlerContext flush() {     return null. }
false;public;0;4;;@Override public ByteBufAllocator alloc() {     return null. }
false;public;0;4;;@Override public ChannelPromise newPromise() {     return null. }
false;public;0;4;;@Override public ChannelProgressivePromise newProgressivePromise() {     return null. }
false;public;0;4;;@Override public ChannelFuture newSucceededFuture() {     return null. }
false;public;1;4;;@Override public ChannelFuture newFailedFuture(Throwable cause) {     return null. }
false;public;0;4;;@Override public ChannelPromise voidPromise() {     return null. }
false;public;1;4;;@Override public <T> Attribute<T> attr(AttributeKey<T> key) {     return null. }
false;public;1;4;;@Override public <T> boolean hasAttr(AttributeKey<T> attributeKey) {     return false. }
false;public;0;4;;@Override public Class<EmptyRequestBody> getRequestClass() {     return EmptyRequestBody.class. }
false;public;0;4;;@Override public TaskManagerMessageParameters getUnresolvedMessageParameters() {     return new TaskManagerMessageParameters(). }
false;public;0;4;;@Override public HttpMethodWrapper getHttpMethod() {     return HttpMethodWrapper.GET. }
false;public;0;4;;@Override public String getTargetRestEndpointURL() {     return URL. }
