commented;modifiers;parameterAmount;loc;comment;code
false;public;0;40;;@Test public void testProcessShutdownBlocking() throws Exception {     // this test works only on linux     assumeTrue(OperatingSystem.isLinux()).     final File markerFile = new File(EnvironmentInformation.getTemporaryFileDirectory(), UUID.randomUUID() + ".marker").     final BlockingShutdownProcess blockingProcess = new BlockingShutdownProcess(markerFile.getAbsolutePath(), 0, false).     try {         blockingProcess.startProcess().         long pid = blockingProcess.getProcessId().         assertTrue("Cannot determine process ID", pid != -1).         // wait for the marker file to appear, which means the process is up properly         TestJvmProcess.waitForMarkerFile(markerFile, 30000).         // send it a regular kill command (SIG_TERM)         Process kill = Runtime.getRuntime().exec("kill " + pid).         kill.waitFor().         assertEquals("failed to send SIG_TERM to process", 0, kill.exitValue()).         // minimal delay until the Java process object notices that the process is gone         // this will not let the test fail predictably if the process is actually in fact going away,         // but it would create frequent failures. Not ideal, but the best we can do without         // severely prolonging the test         Thread.sleep(50).         // the process should not go away by itself         assertTrue("Test broken, process shutdown blocking does not work", blockingProcess.isAlive()).     } finally {         blockingProcess.destroy().         // noinspection ResultOfMethodCallIgnored         markerFile.delete().     } }
false;public;0;39;;@Test public void testProcessExitsDespiteBlockingShutdownHook() throws Exception {     // this test works only on linux     assumeTrue(OperatingSystem.isLinux()).     final File markerFile = new File(EnvironmentInformation.getTemporaryFileDirectory(), UUID.randomUUID() + ".marker").     final BlockingShutdownProcess blockingProcess = new BlockingShutdownProcess(markerFile.getAbsolutePath(), 100, true).     try {         blockingProcess.startProcess().         long pid = blockingProcess.getProcessId().         assertTrue("Cannot determine process ID", pid != -1).         // wait for the marker file to appear, which means the process is up properly         TestJvmProcess.waitForMarkerFile(markerFile, 30000).         // send it a regular kill command (SIG_TERM)         Process kill = Runtime.getRuntime().exec("kill " + pid).         kill.waitFor().         assertEquals("failed to send SIG_TERM to process", 0, kill.exitValue()).         // the process should eventually go away         // 30 secs in nanos         final long deadline = System.nanoTime() + 30_000_000_000L.         while (blockingProcess.isAlive() && System.nanoTime() < deadline) {             Thread.sleep(50).         }         assertFalse("shutdown blocking process does not properly terminate itself", blockingProcess.isAlive()).     } finally {         blockingProcess.destroy().         // noinspection ResultOfMethodCallIgnored         markerFile.delete().     } }
true;static;0;13;// a method that blocks indefinitely ;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ // a method that blocks indefinitely static void parkForever() {     // park this forever     final Object lock = new Object().     // noinspection InfiniteLoopStatement     while (true) {         try {             // noinspection SynchronizationOnLocalVariableOrMethodParameter             synchronized (lock) {                 lock.wait().             }         } catch (InterruptedException ignored) {         }     } }
false;public;0;4;;@Override public String getName() {     return "BlockingShutdownProcess". }
false;public;0;4;;@Override public String[] getJvmArgs() {     return new String[] { tempFilePath, String.valueOf(installSignalHandler), String.valueOf(selfKillDelay) }. }
false;public;0;4;;@Override public String getEntryPointClassName() {     return BlockingShutdownProcessEntryPoint.class.getName(). }
false;public,static;1;30;;public static void main(String[] args) throws Exception {     File touchFile = new File(args[0]).     boolean installHandler = Boolean.parseBoolean(args[1]).     long killDelay = Long.parseLong(args[2]).     // install the blocking shutdown hook     Thread shutdownHook = new Thread(new BlockingRunnable(), "Blocking ShutdownHook").     try {         // Add JVM shutdown hook to call shutdown of service         Runtime.getRuntime().addShutdownHook(shutdownHook).     } catch (IllegalStateException ignored) {     // JVM is already shutting down. No need to do this.     } catch (Throwable t) {         System.err.println("Cannot register process cleanup shutdown hook.").         t.printStackTrace().     }     // install the jvm terminator, if we want it     if (installHandler) {         JvmShutdownSafeguard.installAsShutdownHook(LOG, killDelay).     }     System.err.println("signaling process started").     TestJvmProcess.touchFile(touchFile).     System.err.println("parking the main thread").     parkForever(). }
false;public;0;5;;@Override public void run() {     System.err.println("starting shutdown hook").     parkForever(). }
