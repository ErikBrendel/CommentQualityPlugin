commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// ------------------------------------------------------------------------ // Setup & Shutdown // ------------------------------------------------------------------------ @Before public void beforeTest() {     ioManager = new IOManagerAsync(). }
false;public;0;5;;@After public void afterTest() {     this.ioManager.shutdown().     assertTrue("IO Manager has not properly shut down.", ioManager.isProperlyShutDown()). }
false;public;0;40;;// ------------------------------------------------------------------------ // Test Methods // ------------------------------------------------------------------------ @Test public void channelReadWriteOneSegment() {     final int NUM_IOS = 1111.     try {         final FileIOChannel.ID channelID = this.ioManager.createChannel().         final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channelID).         MemorySegment memSeg = MemorySegmentFactory.allocateUnpooledSegment(32 * 1024).         for (int i = 0. i < NUM_IOS. i++) {             for (int pos = 0. pos < memSeg.size(). pos += 4) {                 memSeg.putInt(pos, i).             }             writer.writeBlock(memSeg).             memSeg = writer.getNextReturnedBlock().         }         writer.close().         final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channelID).         for (int i = 0. i < NUM_IOS. i++) {             reader.readBlock(memSeg).             memSeg = reader.getNextReturnedBlock().             for (int pos = 0. pos < memSeg.size(). pos += 4) {                 if (memSeg.getInt(pos) != i) {                     fail("Read memory segment contains invalid data.").                 }             }         }         reader.closeAndDelete().     } catch (Exception ex) {         ex.printStackTrace().         fail("Test encountered an exception: " + ex.getMessage()).     } }
false;public;0;58;;@Test public void channelReadWriteMultipleSegments() {     final int NUM_IOS = 1111.     final int NUM_SEGS = 16.     try {         final List<MemorySegment> memSegs = new ArrayList<MemorySegment>().         for (int i = 0. i < NUM_SEGS. i++) {             memSegs.add(MemorySegmentFactory.allocateUnpooledSegment(32 * 1024)).         }         final FileIOChannel.ID channelID = this.ioManager.createChannel().         final BlockChannelWriter<MemorySegment> writer = this.ioManager.createBlockChannelWriter(channelID).         for (int i = 0. i < NUM_IOS. i++) {             final MemorySegment memSeg = memSegs.isEmpty() ? writer.getNextReturnedBlock() : memSegs.remove(memSegs.size() - 1).             for (int pos = 0. pos < memSeg.size(). pos += 4) {                 memSeg.putInt(pos, i).             }             writer.writeBlock(memSeg).         }         writer.close().         // get back the memory         while (memSegs.size() < NUM_SEGS) {             memSegs.add(writer.getNextReturnedBlock()).         }         final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(channelID).         while (!memSegs.isEmpty()) {             reader.readBlock(memSegs.remove(0)).         }         for (int i = 0. i < NUM_IOS. i++) {             final MemorySegment memSeg = reader.getNextReturnedBlock().             for (int pos = 0. pos < memSeg.size(). pos += 4) {                 if (memSeg.getInt(pos) != i) {                     fail("Read memory segment contains invalid data.").                 }             }             reader.readBlock(memSeg).         }         reader.closeAndDelete().         // get back the memory         while (memSegs.size() < NUM_SEGS) {             memSegs.add(reader.getNextReturnedBlock()).         }     } catch (Exception ex) {         ex.printStackTrace().         fail("TEst encountered an exception: " + ex.getMessage()).     } }
false;public;1;11;;@Override public void requestDone(IOException ioex) {     if (ioex instanceof TestIOException) {         exceptionForwarded.set(true).     }     synchronized (handlerCalled) {         handlerCalled.set(true).         handlerCalled.notifyAll().     } }
false;public;0;4;;@Override public void read() throws IOException {     throw new TestIOException(). }
false;public;0;46;;@Test public void testExceptionPropagationReader() {     try {         // use atomic boolean as a boolean reference         final AtomicBoolean handlerCalled = new AtomicBoolean().         final AtomicBoolean exceptionForwarded = new AtomicBoolean().         ReadRequest req = new ReadRequest() {              @Override             public void requestDone(IOException ioex) {                 if (ioex instanceof TestIOException) {                     exceptionForwarded.set(true).                 }                 synchronized (handlerCalled) {                     handlerCalled.set(true).                     handlerCalled.notifyAll().                 }             }              @Override             public void read() throws IOException {                 throw new TestIOException().             }         }.         // test the read queue         RequestQueue<ReadRequest> rq = ioManager.getReadRequestQueue(ioManager.createChannel()).         rq.add(req).         // wait until the asynchronous request has been handled         synchronized (handlerCalled) {             while (!handlerCalled.get()) {                 handlerCalled.wait().             }         }         assertTrue(exceptionForwarded.get()).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;1;11;;@Override public void requestDone(IOException ioex) {     if (ioex instanceof TestIOException) {         exceptionForwarded.set(true).     }     synchronized (handlerCalled) {         handlerCalled.set(true).         handlerCalled.notifyAll().     } }
false;public;0;4;;@Override public void write() throws IOException {     throw new TestIOException(). }
false;public;0;46;;@Test public void testExceptionPropagationWriter() {     try {         // use atomic boolean as a boolean reference         final AtomicBoolean handlerCalled = new AtomicBoolean().         final AtomicBoolean exceptionForwarded = new AtomicBoolean().         WriteRequest req = new WriteRequest() {              @Override             public void requestDone(IOException ioex) {                 if (ioex instanceof TestIOException) {                     exceptionForwarded.set(true).                 }                 synchronized (handlerCalled) {                     handlerCalled.set(true).                     handlerCalled.notifyAll().                 }             }              @Override             public void write() throws IOException {                 throw new TestIOException().             }         }.         // test the read queue         RequestQueue<WriteRequest> rq = ioManager.getWriteRequestQueue(ioManager.createChannel()).         rq.add(req).         // wait until the asynchronous request has been handled         synchronized (handlerCalled) {             while (!handlerCalled.get()) {                 handlerCalled.wait().             }         }         assertTrue(exceptionForwarded.get()).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;1;7;;@Override public void requestDone(IOException ioex) {     synchronized (handlerCalled) {         handlerCalled.set(true).         handlerCalled.notifyAll().     } }
false;public;0;2;;@Override public void read() { }
false;public;1;4;;@Override public void requestDone(IOException ioex) {     throw new RuntimeException(). }
false;public;0;2;;@Override public void read() { }
false;public;0;48;;@Test public void testExceptionInCallbackRead() {     try {         final AtomicBoolean handlerCalled = new AtomicBoolean().         ReadRequest regularRequest = new ReadRequest() {              @Override             public void requestDone(IOException ioex) {                 synchronized (handlerCalled) {                     handlerCalled.set(true).                     handlerCalled.notifyAll().                 }             }              @Override             public void read() {             }         }.         ReadRequest exceptionThrower = new ReadRequest() {              @Override             public void requestDone(IOException ioex) {                 throw new RuntimeException().             }              @Override             public void read() {             }         }.         RequestQueue<ReadRequest> rq = ioManager.getReadRequestQueue(ioManager.createChannel()).         // queue first an exception thrower, then a regular request.         // we check that the regular request gets successfully handled         rq.add(exceptionThrower).         rq.add(regularRequest).         synchronized (handlerCalled) {             while (!handlerCalled.get()) {                 handlerCalled.wait().             }         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;1;7;;@Override public void requestDone(IOException ioex) {     synchronized (handlerCalled) {         handlerCalled.set(true).         handlerCalled.notifyAll().     } }
false;public;0;2;;@Override public void write() { }
false;public;1;4;;@Override public void requestDone(IOException ioex) {     throw new RuntimeException(). }
false;public;0;2;;@Override public void write() { }
false;public;0;48;;@Test public void testExceptionInCallbackWrite() {     try {         final AtomicBoolean handlerCalled = new AtomicBoolean().         WriteRequest regularRequest = new WriteRequest() {              @Override             public void requestDone(IOException ioex) {                 synchronized (handlerCalled) {                     handlerCalled.set(true).                     handlerCalled.notifyAll().                 }             }              @Override             public void write() {             }         }.         WriteRequest exceptionThrower = new WriteRequest() {              @Override             public void requestDone(IOException ioex) {                 throw new RuntimeException().             }              @Override             public void write() {             }         }.         RequestQueue<WriteRequest> rq = ioManager.getWriteRequestQueue(ioManager.createChannel()).         // queue first an exception thrower, then a regular request.         // we check that the regular request gets successfully handled         rq.add(exceptionThrower).         rq.add(regularRequest).         synchronized (handlerCalled) {             while (!handlerCalled.get()) {                 handlerCalled.wait().             }         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
