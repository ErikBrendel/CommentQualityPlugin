commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;18;;@Parameterized.Parameters public static Collection<Object[]> getConfigurations() {     LinkedList<Object[]> configs = new LinkedList<Object[]>().     ExecutionConfig withReuse = new ExecutionConfig().     withReuse.enableObjectReuse().     ExecutionConfig withoutReuse = new ExecutionConfig().     withoutReuse.disableObjectReuse().     Object[] a = { withoutReuse }.     configs.add(a).     Object[] b = { withReuse }.     configs.add(b).     return configs. }
false;public;1;4;;public void addInput(MutableObjectIterator<Record> input) {     this.inputs.add(input).     this.sorters.add(null). }
false;public;2;7;;public void addInputSorted(MutableObjectIterator<Record> input, RecordComparator comp) throws Exception {     UnilateralSortMerger<Record> sorter = new UnilateralSortMerger<Record>(this.memManager, this.ioManager, input, this.owner, RecordSerializerFactory.get(), comp, this.perSortFractionMem, 32, 0.8f, true, /*use large record handler*/     true).     this.sorters.add(sorter).     this.inputs.add(null). }
false;public;1;3;;public void addDriverComparator(RecordComparator comparator) {     this.comparators.add(comparator). }
false;public;1;3;;public void setOutput(Collector<Record> output) {     this.output = output. }
false;public;1;3;;public void setOutput(List<Record> output) {     this.output = new ListOutputCollector(output). }
false;public;0;3;;public int getNumFileHandlesForSort() {     return numFileHandles. }
false;public;1;3;;public void setNumFileHandlesForSort(int numFileHandles) {     this.numFileHandles = numFileHandles. }
false;public;2;4;;@SuppressWarnings("rawtypes") public void testDriver(Driver driver, Class stubClass) throws Exception {     testDriverInternal(driver, stubClass). }
false;public;2;73;;@SuppressWarnings({ "unchecked", "rawtypes" }) public void testDriverInternal(Driver driver, Class stubClass) throws Exception {     this.driver = driver.     driver.setup(this).     this.stub = (S) stubClass.newInstance().     // regular running logic     boolean stubOpen = false.     try {         // run the data preparation         try {             driver.prepare().         } catch (Throwable t) {             throw new Exception("The data preparation caused an error: " + t.getMessage(), t).         }         // open stub implementation         try {             FunctionUtils.openFunction(this.stub, getTaskConfig().getStubParameters()).             stubOpen = true.         } catch (Throwable t) {             throw new Exception("The user defined 'open()' method caused an exception: " + t.getMessage(), t).         }         if (!running) {             return.         }         // run the user code         driver.run().         // close. We close here such that a regular close throwing an exception marks a task as failed.         if (this.running) {             FunctionUtils.closeFunction(this.stub).             stubOpen = false.         }         this.output.close().     } catch (Exception ex) {         // close the input, but do not report any exceptions, since we already have another root cause         if (stubOpen) {             try {                 FunctionUtils.closeFunction(this.stub).             } catch (Throwable ignored) {             }         }         // if resettable driver invoke tear down         if (this.driver instanceof ResettableDriver) {             final ResettableDriver<?, ?> resDriver = (ResettableDriver<?, ?>) this.driver.             try {                 resDriver.teardown().             } catch (Throwable t) {                 throw new Exception("Error while shutting down an iterative operator: " + t.getMessage(), t).             }         }         // drop exception, if the task was canceled         if (this.running) {             throw ex.         }     } finally {         driver.cleanup().     } }
false;public;3;20;;@SuppressWarnings({ "unchecked", "rawtypes" }) public void testResettableDriver(ResettableDriver driver, Class stubClass, int iterations) throws Exception {     driver.setup(this).     for (int i = 0. i < iterations. i++) {         if (i == 0) {             driver.initialize().         } else {             driver.reset().         }         testDriver(driver, stubClass).     }     driver.teardown(). }
false;public;0;11;;public void cancel() throws Exception {     this.running = false.     // of the basic properties is not separated from the invocation of the execution logic     while (this.driver == null) {         Thread.sleep(200).     }     this.driver.cancel(). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public TaskConfig getTaskConfig() {     return this.taskConfig. }
false;public;0;4;;@Override public TaskManagerRuntimeInfo getTaskManagerInfo() {     return this.taskManageInfo. }
false;public;0;4;;@Override public ExecutionConfig getExecutionConfig() {     return executionConfig. }
false;public;0;4;;@Override public ClassLoader getUserCodeClassLoader() {     return getClass().getClassLoader(). }
false;public;0;4;;@Override public IOManager getIOManager() {     return this.ioManager. }
false;public;0;4;;@Override public MemoryManager getMemoryManager() {     return this.memManager. }
false;public;1;17;;@Override public <X> MutableObjectIterator<X> getInput(int index) {     MutableObjectIterator<Record> in = this.inputs.get(index).     if (in == null) {         // waiting from sorter         try {             in = this.sorters.get(index).getIterator().         } catch (InterruptedException e) {             throw new RuntimeException("Interrupted").         }         this.inputs.set(index, in).     }     @SuppressWarnings("unchecked")     MutableObjectIterator<X> input = (MutableObjectIterator<X>) this.inputs.get(index).     return input. }
false;public;1;6;;@Override public <X> TypeSerializerFactory<X> getInputSerializer(int index) {     @SuppressWarnings("unchecked")     TypeSerializerFactory<X> factory = (TypeSerializerFactory<X>) RecordSerializerFactory.get().     return factory. }
false;public;1;6;;@Override public <X> TypeComparator<X> getDriverComparator(int index) {     @SuppressWarnings("unchecked")     TypeComparator<X> comparator = (TypeComparator<X>) this.comparators.get(index).     return comparator. }
false;public;0;4;;@Override public S getStub() {     return this.stub. }
false;public;0;4;;@Override public Collector<Record> getOutputCollector() {     return this.output. }
false;public;0;4;;@Override public AbstractInvokable getContainingTask() {     return this.owner. }
false;public;1;4;;@Override public String formatLogString(String message) {     return "Driver Tester: " + message. }
false;public;0;4;;@Override public OperatorMetricGroup getMetricGroup() {     return UnregisteredMetricGroups.createUnregisteredOperatorMetricGroup(). }
false;public;0;21;;// -------------------------------------------------------------------------------------------- @After public void shutdownAll() throws Exception {     // 1st, shutdown sorters     for (UnilateralSortMerger<?> sorter : this.sorters) {         if (sorter != null) {             sorter.close().         }     }     this.sorters.clear().     // 2nd, shutdown I/O     this.ioManager.shutdown().     Assert.assertTrue("I/O Manager has not properly shut down.", this.ioManager.isProperlyShutDown()).     // last, verify all memory is returned and shutdown mem manager     MemoryManager memMan = getMemoryManager().     if (memMan != null) {         Assert.assertTrue("Memory Manager managed memory was not completely freed.", memMan.verifyEmpty()).         memMan.shutdown().     } }
false;public;1;4;;@Override public void collect(Record record) {     this.output.add(record.createCopy()). }
false;public;0;2;;@Override public void close() { }
false;public;1;4;;@Override public void collect(Record record) {     this.num++. }
false;public;0;2;;@Override public void close() { }
false;public;0;3;;public int getNumberOfRecords() {     return this.num. }
