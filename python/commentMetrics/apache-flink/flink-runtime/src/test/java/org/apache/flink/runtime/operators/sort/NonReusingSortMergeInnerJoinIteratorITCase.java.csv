commented;modifiers;parameterAmount;loc;comment;code
false;public;0;22;;@SuppressWarnings("unchecked") @Before public void beforeTest() {     serializer1 = new TupleSerializer<Tuple2<Integer, String>>((Class<Tuple2<Integer, String>>) (Class<?>) Tuple2.class, new TypeSerializer<?>[] { IntSerializer.INSTANCE, StringSerializer.INSTANCE }).     serializer2 = new TupleSerializer<Tuple2<Integer, String>>((Class<Tuple2<Integer, String>>) (Class<?>) Tuple2.class, new TypeSerializer<?>[] { IntSerializer.INSTANCE, StringSerializer.INSTANCE }).     comparator1 = new TupleComparator<Tuple2<Integer, String>>(new int[] { 0 }, new TypeComparator<?>[] { new IntComparator(true) }, new TypeSerializer<?>[] { IntSerializer.INSTANCE }).     comparator2 = new TupleComparator<Tuple2<Integer, String>>(new int[] { 0 }, new TypeComparator<?>[] { new IntComparator(true) }, new TypeSerializer<?>[] { IntSerializer.INSTANCE }).     pairComparator = new GenericPairComparator<Tuple2<Integer, String>, Tuple2<Integer, String>>(comparator1, comparator2).     this.memoryManager = new MemoryManager(MEMORY_SIZE, 1).     this.ioManager = new IOManagerAsync(). }
false;public;0;17;;@After public void afterTest() {     if (this.ioManager != null) {         this.ioManager.shutdown().         if (!this.ioManager.isProperlyShutDown()) {             Assert.fail("I/O manager failed to properly shut down.").         }         this.ioManager = null.     }     if (this.memoryManager != null) {         Assert.assertTrue("Memory Leak: Not all memory has been returned to the memory manager.", this.memoryManager.verifyEmpty()).         this.memoryManager.shutdown().         this.memoryManager = null.     } }
false;public;0;48;;@Test public void testMerge() {     try {         final TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.SORTED, ValueMode.RANDOM_LENGTH).         final TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.SORTED, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<Match>> expectedMatchesMap = matchValues(collectData(input1), collectData(input2)).         final FlatJoinFunction<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> joinFunction = new MatchRemovingJoiner(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<Tuple2<Integer, String>>().         // reset the generators         generator1.reset().         generator2.reset().         input1.reset().         input2.reset().         // compare with iterator values         NonReusingMergeInnerJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingMergeInnerJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>>(input1, input2, this.serializer1, this.comparator1, this.serializer2, this.comparator2, this.pairComparator, this.memoryManager, this.ioManager, PAGES_FOR_BNLJN, this.parentTask).         iterator.open().         while (iterator.callWithNextKey(joinFunction, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<Match>> entry : expectedMatchesMap.entrySet()) {             Assert.assertTrue("Collection for key " + entry.getKey() + " is not empty", entry.getValue().isEmpty()).         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;88;;@Test public void testMergeWithHighNumberOfCommonKeys() {     // the size of the left and right inputs     final int INPUT_1_SIZE = 200.     final int INPUT_2_SIZE = 100.     final int INPUT_1_DUPLICATES = 10.     final int INPUT_2_DUPLICATES = 4000.     final int DUPLICATE_KEY = 13.     try {         final TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.SORTED, ValueMode.RANDOM_LENGTH).         final TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.SORTED, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator gen1Iter = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator gen2Iter = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         final TestData.TupleConstantValueIterator const1Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, "LEFT String for Duplicate Keys", INPUT_1_DUPLICATES).         final TestData.TupleConstantValueIterator const2Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, "RIGHT String for Duplicate Keys", INPUT_2_DUPLICATES).         final List<MutableObjectIterator<Tuple2<Integer, String>>> inList1 = new ArrayList<MutableObjectIterator<Tuple2<Integer, String>>>().         inList1.add(gen1Iter).         inList1.add(const1Iter).         final List<MutableObjectIterator<Tuple2<Integer, String>>> inList2 = new ArrayList<MutableObjectIterator<Tuple2<Integer, String>>>().         inList2.add(gen2Iter).         inList2.add(const2Iter).         MutableObjectIterator<Tuple2<Integer, String>> input1 = new MergeIterator<Tuple2<Integer, String>>(inList1, comparator1.duplicate()).         MutableObjectIterator<Tuple2<Integer, String>> input2 = new MergeIterator<Tuple2<Integer, String>>(inList2, comparator2.duplicate()).         // collect expected data         final Map<Integer, Collection<Match>> expectedMatchesMap = matchValues(collectData(input1), collectData(input2)).         // re-create the whole thing for actual processing         // reset the generators and iterators         generator1.reset().         generator2.reset().         const1Iter.reset().         const2Iter.reset().         gen1Iter.reset().         gen2Iter.reset().         inList1.clear().         inList1.add(gen1Iter).         inList1.add(const1Iter).         inList2.clear().         inList2.add(gen2Iter).         inList2.add(const2Iter).         input1 = new MergeIterator<Tuple2<Integer, String>>(inList1, comparator1.duplicate()).         input2 = new MergeIterator<Tuple2<Integer, String>>(inList2, comparator2.duplicate()).         final FlatJoinFunction<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> joinFunction = new MatchRemovingJoiner(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<Tuple2<Integer, String>>().         // we create this sort-merge iterator with little memory for the block-nested-loops fall-back to make sure it         // needs to spill for the duplicate keys         NonReusingMergeInnerJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingMergeInnerJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>>(input1, input2, this.serializer1, this.comparator1, this.serializer2, this.comparator2, this.pairComparator, this.memoryManager, this.ioManager, PAGES_FOR_BNLJN, this.parentTask).         iterator.open().         while (iterator.callWithNextKey(joinFunction, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<Match>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;private;2;29;;// -------------------------------------------------------------------------------------------- // Utilities // -------------------------------------------------------------------------------------------- private Map<Integer, Collection<Match>> matchValues(Map<Integer, Collection<String>> leftMap, Map<Integer, Collection<String>> rightMap) {     Map<Integer, Collection<Match>> map = new HashMap<Integer, Collection<Match>>().     for (Integer key : leftMap.keySet()) {         Collection<String> leftValues = leftMap.get(key).         Collection<String> rightValues = rightMap.get(key).         if (rightValues == null) {             continue.         }         if (!map.containsKey(key)) {             map.put(key, new ArrayList<Match>()).         }         Collection<Match> matchedValues = map.get(key).         for (String leftValue : leftValues) {             for (String rightValue : rightValues) {                 matchedValues.add(new Match(leftValue, rightValue)).             }         }     }     return map. }
false;private;1;20;;private Map<Integer, Collection<String>> collectData(MutableObjectIterator<Tuple2<Integer, String>> iter) throws Exception {     Map<Integer, Collection<String>> map = new HashMap<Integer, Collection<String>>().     Tuple2<Integer, String> pair = new Tuple2<Integer, String>().     while ((pair = iter.next(pair)) != null) {         final Integer key = pair.getField(0).         if (!map.containsKey(key)) {             map.put(key, new ArrayList<String>()).         }         Collection<String> values = map.get(key).         final String value = pair.getField(1).         values.add(value).     }     return map. }
