commented;modifiers;parameterAmount;loc;comment;code
false;public;0;41;;@Test public void testInputConsumable() throws Exception {     List<JobVertex> vertices = createOrderedVertices().     ExecutionGraph eg = createExecutionGraph(vertices, InputDependencyConstraint.ALL).     ExecutionVertex ev11 = eg.getJobVertex(vertices.get(0).getID()).getTaskVertices()[0].     ExecutionVertex ev21 = eg.getJobVertex(vertices.get(1).getID()).getTaskVertices()[0].     ExecutionVertex ev22 = eg.getJobVertex(vertices.get(1).getID()).getTaskVertices()[1].     ExecutionVertex ev31 = eg.getJobVertex(vertices.get(2).getID()).getTaskVertices()[0].     ExecutionVertex ev32 = eg.getJobVertex(vertices.get(2).getID()).getTaskVertices()[1].     eg.start(mainThreadExecutor).     eg.scheduleForExecution().     // Inputs not consumable on init     assertFalse(ev31.isInputConsumable(0)).     assertFalse(ev31.isInputConsumable(1)).     // One pipelined input consumable on data produced     IntermediateResultPartition partition11 = ev11.getProducedPartitions().values().iterator().next().     ev11.scheduleOrUpdateConsumers(new ResultPartitionID(partition11.getPartitionId(), ev11.getCurrentExecutionAttempt().getAttemptId())).     assertTrue(ev31.isInputConsumable(0)).     // Input0 of ev32 is not consumable. It consumes the same PIPELINED result with ev31 but not the same partition     assertFalse(ev32.isInputConsumable(0)).     // The blocking input not consumable if only one partition is FINISHED     ev21.getCurrentExecutionAttempt().markFinished().     assertFalse(ev31.isInputConsumable(1)).     // The blocking input consumable if all partitions are FINISHED     ev22.getCurrentExecutionAttempt().markFinished().     assertTrue(ev31.isInputConsumable(1)).     // Inputs not consumable after failover     ev11.fail(new Exception()).     waitUntilJobRestarted(eg).     assertFalse(ev31.isInputConsumable(0)).     assertFalse(ev31.isInputConsumable(1)). }
false;public;0;39;;@Test public void testInputConstraintANY() throws Exception {     List<JobVertex> vertices = createOrderedVertices().     ExecutionGraph eg = createExecutionGraph(vertices, InputDependencyConstraint.ANY).     ExecutionVertex ev11 = eg.getJobVertex(vertices.get(0).getID()).getTaskVertices()[0].     ExecutionVertex ev21 = eg.getJobVertex(vertices.get(1).getID()).getTaskVertices()[0].     ExecutionVertex ev22 = eg.getJobVertex(vertices.get(1).getID()).getTaskVertices()[1].     ExecutionVertex ev31 = eg.getJobVertex(vertices.get(2).getID()).getTaskVertices()[0].     eg.start(mainThreadExecutor).     eg.scheduleForExecution().     // Inputs constraint not satisfied on init     assertFalse(ev31.checkInputDependencyConstraints()).     // Input1 consumable satisfies the constraint     IntermediateResultPartition partition11 = ev11.getProducedPartitions().values().iterator().next().     ev11.scheduleOrUpdateConsumers(new ResultPartitionID(partition11.getPartitionId(), ev11.getCurrentExecutionAttempt().getAttemptId())).     assertTrue(ev31.checkInputDependencyConstraints()).     // Inputs constraint not satisfied after failover     ev11.fail(new Exception()).     waitUntilJobRestarted(eg).     assertFalse(ev31.checkInputDependencyConstraints()).     // Input2 consumable satisfies the constraint     waitUntilExecutionVertexState(ev21, ExecutionState.DEPLOYING, 2000L).     waitUntilExecutionVertexState(ev22, ExecutionState.DEPLOYING, 2000L).     ev21.getCurrentExecutionAttempt().markFinished().     ev22.getCurrentExecutionAttempt().markFinished().     assertTrue(ev31.checkInputDependencyConstraints()). }
false;public;0;35;;@Test public void testInputConstraintALL() throws Exception {     List<JobVertex> vertices = createOrderedVertices().     ExecutionGraph eg = createExecutionGraph(vertices, InputDependencyConstraint.ALL).     ExecutionVertex ev11 = eg.getJobVertex(vertices.get(0).getID()).getTaskVertices()[0].     ExecutionVertex ev21 = eg.getJobVertex(vertices.get(1).getID()).getTaskVertices()[0].     ExecutionVertex ev22 = eg.getJobVertex(vertices.get(1).getID()).getTaskVertices()[1].     ExecutionVertex ev31 = eg.getJobVertex(vertices.get(2).getID()).getTaskVertices()[0].     eg.start(mainThreadExecutor).     eg.scheduleForExecution().     // Inputs constraint not satisfied on init     assertFalse(ev31.checkInputDependencyConstraints()).     // Input1 consumable does not satisfy the constraint     IntermediateResultPartition partition11 = ev11.getProducedPartitions().values().iterator().next().     ev11.scheduleOrUpdateConsumers(new ResultPartitionID(partition11.getPartitionId(), ev11.getCurrentExecutionAttempt().getAttemptId())).     assertFalse(ev31.checkInputDependencyConstraints()).     // Input2 consumable satisfies the constraint     ev21.getCurrentExecutionAttempt().markFinished().     ev22.getCurrentExecutionAttempt().markFinished().     assertTrue(ev31.checkInputDependencyConstraints()).     // Inputs constraint not satisfied after failover     ev11.fail(new Exception()).     waitUntilJobRestarted(eg).     assertFalse(ev31.checkInputDependencyConstraints()). }
false;private,static;0;14;;private static List<JobVertex> createOrderedVertices() {     JobVertex v1 = new JobVertex("vertex1").     JobVertex v2 = new JobVertex("vertex2").     JobVertex v3 = new JobVertex("vertex3").     v1.setParallelism(2).     v2.setParallelism(2).     v3.setParallelism(2).     v1.setInvokableClass(AbstractInvokable.class).     v2.setInvokableClass(AbstractInvokable.class).     v3.setInvokableClass(AbstractInvokable.class).     v3.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).     v3.connectNewDataSetAsInput(v2, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING).     return Arrays.asList(v1, v2, v3). }
false;private,static;2;26;;private static ExecutionGraph createExecutionGraph(List<JobVertex> orderedVertices, InputDependencyConstraint inputDependencyConstraint) throws Exception {     final JobID jobId = new JobID().     final String jobName = "Test Job Sample Name".     final SlotProvider slotProvider = new SimpleSlotProvider(jobId, 20).     for (JobVertex vertex : orderedVertices) {         vertex.setInputDependencyConstraint(inputDependencyConstraint).     }     ExecutionGraph eg = new ExecutionGraph(new DummyJobInformation(jobId, jobName), TestingUtils.defaultExecutor(), TestingUtils.defaultExecutor(), AkkaUtils.getDefaultTimeout(), TestRestartStrategy.directExecuting(), new RestartAllStrategy.Factory(), slotProvider).     eg.attachJobGraph(orderedVertices).     return eg. }
false;private;1;16;;private void waitUntilJobRestarted(ExecutionGraph eg) throws Exception {     waitForAllExecutionsPredicate(eg, isInExecutionState(ExecutionState.CANCELING).or(isInExecutionState(ExecutionState.CANCELED)).or(isInExecutionState(ExecutionState.FAILED)).or(isInExecutionState(ExecutionState.FINISHED)), 2000L).     for (ExecutionVertex ev : eg.getAllExecutionVertices()) {         if (ev.getCurrentExecutionAttempt().getState() == ExecutionState.CANCELING) {             ev.getCurrentExecutionAttempt().completeCancelling().         }     }     waitUntilJobStatus(eg, JobStatus.RUNNING, 2000L). }
