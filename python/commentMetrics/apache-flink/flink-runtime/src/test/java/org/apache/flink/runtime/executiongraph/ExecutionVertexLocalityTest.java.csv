# id;timestamp;commentText;codeText;commentWords;codeWords
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1486122374;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution()__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateHandles.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,handles,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1486647395;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution()__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateHandles.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,handles,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1488453790;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution()__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateHandles.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,handles,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1489060856;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution()__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateHandles.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,handles,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1493831843;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion())__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateHandles.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,system,current,time,millis,graph,get,global,mod,version,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,handles,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1502801814;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion())__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateSnapshot.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,system,current,time,millis,graph,get,global,mod,version,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,snapshot,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1508861310;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion())__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateSnapshot.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,system,current,time,millis,graph,get,global,mod,version,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,snapshot,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1508861311;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion())__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateSnapshot.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,system,current,time,millis,graph,get,global,mod,version,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,snapshot,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1509638684;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion())__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateSnapshot.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,system,current,time,millis,graph,get,global,mod,version,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,snapshot,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1513258344;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion())__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateSnapshot.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,system,current,time,millis,graph,get,global,mod,version,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,snapshot,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1513258345;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion())__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateSnapshot.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,system,current,time,millis,graph,get,global,mod,version,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,snapshot,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1513261599;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion())__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(TaskStateSnapshot.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,system,current,time,millis,graph,get,global,mod,version,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,task,state,snapshot,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1516626377;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion())__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(JobManagerTaskRestore.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,system,current,time,millis,graph,get,global,mod,version,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,job,manager,task,restore,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityBasedOnState() throws Exception;1518680774;This test validates that stateful vertices schedule based in the state's location_(which is the prior execution's location).;@Test_	public void testLocalityBasedOnState() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			_			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i)___			locations[i] = location__			initializeLocation(source, randomLocation)__			initializeLocation(target, location)___			setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__			setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED)__		}__		_		for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {_			ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion())__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation randomLocation = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i)__			initializeLocation(source, randomLocation)___			_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			target.getCurrentExecutionAttempt().setInitialState(mock(JobManagerTaskRestore.class))__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,stateful,vertices,schedule,based,in,the,state,s,location,which,is,the,prior,execution,s,location;test,public,void,test,locality,based,on,state,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,20000,i,locations,i,location,initialize,location,source,random,location,initialize,location,target,location,set,state,source,get,current,execution,attempt,execution,state,canceled,set,state,target,get,current,execution,attempt,execution,state,canceled,for,execution,job,vertex,ejv,graph,get,vertices,topologically,ejv,reset,for,new,execution,system,current,time,millis,graph,get,global,mod,version,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,random,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,30000,i,initialize,location,source,random,location,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,target,get,current,execution,attempt,set,initial,state,mock,job,manager,task,restore,class,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1486122374;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1486647395;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1488453790;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1489060856;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1493831843;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1502801814;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1508861310;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1508861311;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1509638684;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1513258344;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1513258345;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1513261599;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1516626377;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testNoLocalityInputLargeAllToAll() throws Exception;1518680774;This test validates that vertices with too many input streams do not have a location_preference any more.;@Test_	public void testNoLocalityInputLargeAllToAll() throws Exception {_		final int parallelism = 100___		final ExecutionGraph graph = createTestGraph(parallelism, true)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]__			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]___			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,with,too,many,input,streams,do,not,have,a,location,preference,any,more;test,public,void,test,no,locality,input,large,all,to,all,throws,exception,final,int,parallelism,100,final,execution,graph,graph,create,test,graph,parallelism,true,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1486122374;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1486647395;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1488453790;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1489060856;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1493831843;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1502801814;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1508861310;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1508861311;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<TaskManagerLocation> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1509638684;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1513258344;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1513258345;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1513261599;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1516626377;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> @Test 	public void testLocalityInputBasedForward() throws Exception;1518680774;This test validates that vertices that have only one input stream try to_co-locate their tasks with the producer.;@Test_	public void testLocalityInputBasedForward() throws Exception {_		final int parallelism = 10__		final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism]___		final ExecutionGraph graph = createTestGraph(parallelism, false)___		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i]___			TaskManagerLocation location = new TaskManagerLocation(_					ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i)___			locations[i] = location__			initializeLocation(source, location)__		}__		_		for (int i = 0_ i < parallelism_ i++) {_			ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i]__			Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator()___			assertTrue(preference.hasNext())__			assertEquals(locations[i], preference.next().get())__			assertFalse(preference.hasNext())__		}_	};this,test,validates,that,vertices,that,have,only,one,input,stream,try,to,co,locate,their,tasks,with,the,producer;test,public,void,test,locality,input,based,forward,throws,exception,final,int,parallelism,10,final,task,manager,location,locations,new,task,manager,location,parallelism,final,execution,graph,graph,create,test,graph,parallelism,false,for,int,i,0,i,parallelism,i,execution,vertex,source,graph,get,all,vertices,get,source,vertex,id,get,task,vertices,i,task,manager,location,location,new,task,manager,location,resource,id,generate,inet,address,get,loopback,address,10000,i,locations,i,location,initialize,location,source,location,for,int,i,0,i,parallelism,i,execution,vertex,target,graph,get,all,vertices,get,target,vertex,id,get,task,vertices,i,iterator,completable,future,task,manager,location,preference,target,get,preferred,locations,iterator,assert,true,preference,has,next,assert,equals,locations,i,preference,next,get,assert,false,preference,has,next
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1486122374;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_				null,_				testJob,_				new Configuration(),_				Executors.directExecutor(),_				Executors.directExecutor(),_				getClass().getClassLoader(),_				new StandaloneCheckpointRecoveryFactory(),_				Time.of(10, TimeUnit.SECONDS),_				new FixedDelayRestartStrategy(10, 0L),_				new UnregisteredMetricsGroup(),_				1,_				log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,executors,direct,executor,executors,direct,executor,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1486647395;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_				null,_				testJob,_				new Configuration(),_				TestingUtils.defaultExecutor(),_				TestingUtils.defaultExecutor(),_				getClass().getClassLoader(),_				new StandaloneCheckpointRecoveryFactory(),_				Time.of(10, TimeUnit.SECONDS),_				new FixedDelayRestartStrategy(10, 0L),_				new UnregisteredMetricsGroup(),_				1,_				log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1488453790;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1489060856;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1493831843;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1502801814;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1508861310;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			null,_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,null,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1508861311;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			VoidBlobWriter.getInstance(),_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,void,blob,writer,get,instance,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1509638684;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			VoidBlobWriter.getInstance(),_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,void,blob,writer,get,instance,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1513258344;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			VoidBlobWriter.getInstance(),_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,void,blob,writer,get,instance,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1513258345;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			VoidBlobWriter.getInstance(),_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,void,blob,writer,get,instance,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1513261599;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			VoidBlobWriter.getInstance(),_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,void,blob,writer,get,instance,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1516626377;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			Time.of(10, TimeUnit.SECONDS),_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			VoidBlobWriter.getInstance(),_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,time,of,10,time,unit,seconds,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,void,blob,writer,get,instance,log
ExecutionVertexLocalityTest -> private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception;1518680774;Creates a simple 2 vertex graph with a parallel source and a parallel target.;private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {__		JobVertex source = new JobVertex("source", sourceVertexId)__		source.setParallelism(parallelism)__		source.setInvokableClass(NoOpInvokable.class)___		JobVertex target = new JobVertex("source", targetVertexId)__		target.setParallelism(parallelism)__		target.setInvokableClass(NoOpInvokable.class)___		DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE__		target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED)___		JobGraph testJob = new JobGraph(jobId, "test job", source, target)___		final Time timeout = Time.seconds(10L)__		return ExecutionGraphBuilder.buildGraph(_			null,_			testJob,_			new Configuration(),_			TestingUtils.defaultExecutor(),_			TestingUtils.defaultExecutor(),_			mock(SlotProvider.class),_			getClass().getClassLoader(),_			new StandaloneCheckpointRecoveryFactory(),_			timeout,_			new FixedDelayRestartStrategy(10, 0L),_			new UnregisteredMetricsGroup(),_			1,_			VoidBlobWriter.getInstance(),_			timeout,_			log)__	};creates,a,simple,2,vertex,graph,with,a,parallel,source,and,a,parallel,target;private,execution,graph,create,test,graph,int,parallelism,boolean,all,to,all,throws,exception,job,vertex,source,new,job,vertex,source,source,vertex,id,source,set,parallelism,parallelism,source,set,invokable,class,no,op,invokable,class,job,vertex,target,new,job,vertex,source,target,vertex,id,target,set,parallelism,parallelism,target,set,invokable,class,no,op,invokable,class,distribution,pattern,connection,pattern,all,to,all,distribution,pattern,distribution,pattern,pointwise,target,connect,new,data,set,as,input,source,connection,pattern,result,partition,type,pipelined,job,graph,test,job,new,job,graph,job,id,test,job,source,target,final,time,timeout,time,seconds,10l,return,execution,graph,builder,build,graph,null,test,job,new,configuration,testing,utils,default,executor,testing,utils,default,executor,mock,slot,provider,class,get,class,get,class,loader,new,standalone,checkpoint,recovery,factory,timeout,new,fixed,delay,restart,strategy,10,0l,new,unregistered,metrics,group,1,void,blob,writer,get,instance,timeout,log
