commented;modifiers;parameterAmount;loc;comment;code
true;public;0;28;/**  * This test validates that vertices that have only one input stream try to  * co-locate their tasks with the producer.  */ ;/**  * This test validates that vertices that have only one input stream try to  * co-locate their tasks with the producer.  */ @Test public void testLocalityInputBasedForward() throws Exception {     final int parallelism = 10.     final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism].     final ExecutionGraph graph = createTestGraph(parallelism, false).     // set the location for all sources to a distinct location     for (int i = 0. i < parallelism. i++) {         ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i].         TaskManagerLocation location = new TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i).         locations[i] = location.         initializeLocation(source, location).     }     // validate that the target vertices have no location preference     for (int i = 0. i < parallelism. i++) {         ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i].         Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator().         assertTrue(preference.hasNext()).         assertEquals(locations[i], preference.next().get()).         assertFalse(preference.hasNext()).     } }
true;public;0;22;/**  * This test validates that vertices with too many input streams do not have a location  * preference any more.  */ ;/**  * This test validates that vertices with too many input streams do not have a location  * preference any more.  */ @Test public void testNoLocalityInputLargeAllToAll() throws Exception {     final int parallelism = 100.     final ExecutionGraph graph = createTestGraph(parallelism, true).     // set the location for all sources to a distinct location     for (int i = 0. i < parallelism. i++) {         ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i].         TaskManagerLocation location = new TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i).         initializeLocation(source, location).     }     // validate that the target vertices have no location preference     for (int i = 0. i < parallelism. i++) {         ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i].         Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator().         assertFalse(preference.hasNext()).     } }
true;public;0;54;/**  * This test validates that stateful vertices schedule based in the state's location  * (which is the prior execution's location).  */ ;/**  * This test validates that stateful vertices schedule based in the state's location  * (which is the prior execution's location).  */ @Test public void testLocalityBasedOnState() throws Exception {     final int parallelism = 10.     final TaskManagerLocation[] locations = new TaskManagerLocation[parallelism].     final ExecutionGraph graph = createTestGraph(parallelism, false).     // set the location for all sources and targets     for (int i = 0. i < parallelism. i++) {         ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i].         ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i].         TaskManagerLocation randomLocation = new TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 10000 + i).         TaskManagerLocation location = new TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 20000 + i).         locations[i] = location.         initializeLocation(source, randomLocation).         initializeLocation(target, location).         setState(source.getCurrentExecutionAttempt(), ExecutionState.CANCELED).         setState(target.getCurrentExecutionAttempt(), ExecutionState.CANCELED).     }     // mimic a restart: all vertices get re-initialized without actually being executed     for (ExecutionJobVertex ejv : graph.getVerticesTopologically()) {         ejv.resetForNewExecution(System.currentTimeMillis(), graph.getGlobalModVersion()).     }     // set new location for the sources and some state for the targets     for (int i = 0. i < parallelism. i++) {         // source location         ExecutionVertex source = graph.getAllVertices().get(sourceVertexId).getTaskVertices()[i].         TaskManagerLocation randomLocation = new TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 30000 + i).         initializeLocation(source, randomLocation).         // target state         ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i].         target.getCurrentExecutionAttempt().setInitialState(mock(JobManagerTaskRestore.class)).     }     // validate that the target vertices have the state's location as the location preference     for (int i = 0. i < parallelism. i++) {         ExecutionVertex target = graph.getAllVertices().get(targetVertexId).getTaskVertices()[i].         Iterator<CompletableFuture<TaskManagerLocation>> preference = target.getPreferredLocations().iterator().         assertTrue(preference.hasNext()).         assertEquals(locations[i], preference.next().get()).         assertFalse(preference.hasNext()).     } }
true;private;2;33;/**  * Creates a simple 2 vertex graph with a parallel source and a parallel target.  */ ;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ /**  * Creates a simple 2 vertex graph with a parallel source and a parallel target.  */ private ExecutionGraph createTestGraph(int parallelism, boolean allToAll) throws Exception {     JobVertex source = new JobVertex("source", sourceVertexId).     source.setParallelism(parallelism).     source.setInvokableClass(NoOpInvokable.class).     JobVertex target = new JobVertex("source", targetVertexId).     target.setParallelism(parallelism).     target.setInvokableClass(NoOpInvokable.class).     DistributionPattern connectionPattern = allToAll ? DistributionPattern.ALL_TO_ALL : DistributionPattern.POINTWISE.     target.connectNewDataSetAsInput(source, connectionPattern, ResultPartitionType.PIPELINED).     JobGraph testJob = new JobGraph(jobId, "test job", source, target).     final Time timeout = Time.seconds(10L).     return ExecutionGraphBuilder.buildGraph(null, testJob, new Configuration(), TestingUtils.defaultExecutor(), TestingUtils.defaultExecutor(), mock(SlotProvider.class), getClass().getClassLoader(), new StandaloneCheckpointRecoveryFactory(), timeout, new FixedDelayRestartStrategy(10, 0L), new UnregisteredMetricsGroup(), 1, VoidBlobWriter.getInstance(), timeout, log). }
false;private;2;18;;private void initializeLocation(ExecutionVertex vertex, TaskManagerLocation location) throws Exception {     // we need a bit of reflection magic to initialize the location without going through     // scheduling paths. we choose to do that, rather than the alternatives:     // - mocking the scheduler created fragile tests that break whenever the scheduler is adjusted     // - exposing test methods in the ExecutionVertex leads to undesirable setters     SlotContext slot = new SimpleSlotContext(new AllocationID(), location, 0, mock(TaskManagerGateway.class)).     SimpleSlot simpleSlot = new SimpleSlot(slot, mock(SlotOwner.class), 0).     if (!vertex.getCurrentExecutionAttempt().tryAssignResource(simpleSlot)) {         throw new FlinkException("Could not assign resource.").     } }
false;private;2;6;;private void setState(Execution execution, ExecutionState state) throws Exception {     final Field stateField = Execution.class.getDeclaredField("state").     stateField.setAccessible(true).     stateField.set(execution, state). }
