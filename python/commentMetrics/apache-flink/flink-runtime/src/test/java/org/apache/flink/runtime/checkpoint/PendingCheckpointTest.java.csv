commented;modifiers;parameterAmount;loc;comment;code
true;public;0;19;/**  * Tests that pending checkpoints can be subsumed iff they are forced.  */ ;/**  * Tests that pending checkpoints can be subsumed iff they are forced.  */ @Test public void testCanBeSubsumed() throws Exception {     // Forced checkpoints cannot be subsumed     CheckpointProperties forced = new CheckpointProperties(true, CheckpointType.SAVEPOINT, false, false, false, false, false).     PendingCheckpoint pending = createPendingCheckpoint(forced).     assertFalse(pending.canBeSubsumed()).     try {         pending.abortSubsumed().         fail("Did not throw expected Exception").     } catch (IllegalStateException ignored) {     // Expected     }     // Non-forced checkpoints can be subsumed     CheckpointProperties subsumed = new CheckpointProperties(false, CheckpointType.SAVEPOINT, false, false, false, false, false).     pending = createPendingCheckpoint(subsumed).     assertTrue(pending.canBeSubsumed()). }
true;public;0;50;/**  * Tests that the completion future is succeeded on finalize and failed on  * abort and failures during finalize.  */ ;/**  * Tests that the completion future is succeeded on finalize and failed on  * abort and failures during finalize.  */ @Test public void testCompletionFuture() throws Exception {     CheckpointProperties props = new CheckpointProperties(false, CheckpointType.SAVEPOINT, false, false, false, false, false).     // Abort declined     PendingCheckpoint pending = createPendingCheckpoint(props).     CompletableFuture<CompletedCheckpoint> future = pending.getCompletionFuture().     assertFalse(future.isDone()).     pending.abortDeclined().     assertTrue(future.isDone()).     // Abort expired     pending = createPendingCheckpoint(props).     future = pending.getCompletionFuture().     assertFalse(future.isDone()).     pending.abortExpired().     assertTrue(future.isDone()).     // Abort subsumed     pending = createPendingCheckpoint(props).     future = pending.getCompletionFuture().     assertFalse(future.isDone()).     pending.abortSubsumed().     assertTrue(future.isDone()).     // Finalize (all ACK'd)     pending = createPendingCheckpoint(props).     future = pending.getCompletionFuture().     assertFalse(future.isDone()).     pending.acknowledgeTask(ATTEMPT_ID, null, new CheckpointMetrics()).     assertTrue(pending.isFullyAcknowledged()).     pending.finalizeCheckpoint().     assertTrue(future.isDone()).     // Finalize (missing ACKs)     pending = createPendingCheckpoint(props).     future = pending.getCompletionFuture().     assertFalse(future.isDone()).     try {         pending.finalizeCheckpoint().         fail("Did not throw expected Exception").     } catch (IllegalStateException ignored) {     // Expected     } }
true;public;0;51;/**  * Tests that abort discards state.  */ ;/**  * Tests that abort discards state.  */ @Test @SuppressWarnings("unchecked") public void testAbortDiscardsState() throws Exception {     CheckpointProperties props = new CheckpointProperties(false, CheckpointType.SAVEPOINT, false, false, false, false, false).     QueueExecutor executor = new QueueExecutor().     OperatorState state = mock(OperatorState.class).     doNothing().when(state).registerSharedStates(any(SharedStateRegistry.class)).     // Abort declined     PendingCheckpoint pending = createPendingCheckpoint(props, executor).     setTaskState(pending, state).     pending.abortDeclined().     // execute asynchronous discard operation     executor.runQueuedCommands().     verify(state, times(1)).discardState().     // Abort error     Mockito.reset(state).     pending = createPendingCheckpoint(props, executor).     setTaskState(pending, state).     pending.abortError(new Exception("Expected Test Exception")).     // execute asynchronous discard operation     executor.runQueuedCommands().     verify(state, times(1)).discardState().     // Abort expired     Mockito.reset(state).     pending = createPendingCheckpoint(props, executor).     setTaskState(pending, state).     pending.abortExpired().     // execute asynchronous discard operation     executor.runQueuedCommands().     verify(state, times(1)).discardState().     // Abort subsumed     Mockito.reset(state).     pending = createPendingCheckpoint(props, executor).     setTaskState(pending, state).     pending.abortSubsumed().     // execute asynchronous discard operation     executor.runQueuedCommands().     verify(state, times(1)).discardState(). }
true;public;0;60;/**  * Tests that the stats callbacks happen if the callback is registered.  */ ;/**  * Tests that the stats callbacks happen if the callback is registered.  */ @Test public void testPendingCheckpointStatsCallbacks() throws Exception {     {         // Complete successfully         PendingCheckpointStats callback = mock(PendingCheckpointStats.class).         PendingCheckpoint pending = createPendingCheckpoint(CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION)).         pending.setStatsCallback(callback).         pending.acknowledgeTask(ATTEMPT_ID, null, new CheckpointMetrics()).         verify(callback, times(1)).reportSubtaskStats(nullable(JobVertexID.class), any(SubtaskStateStats.class)).         pending.finalizeCheckpoint().         verify(callback, times(1)).reportCompletedCheckpoint(any(String.class)).     }     {         // Fail subsumed         PendingCheckpointStats callback = mock(PendingCheckpointStats.class).         PendingCheckpoint pending = createPendingCheckpoint(CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION)).         pending.setStatsCallback(callback).         pending.abortSubsumed().         verify(callback, times(1)).reportFailedCheckpoint(anyLong(), any(Exception.class)).     }     {         // Fail subsumed         PendingCheckpointStats callback = mock(PendingCheckpointStats.class).         PendingCheckpoint pending = createPendingCheckpoint(CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION)).         pending.setStatsCallback(callback).         pending.abortDeclined().         verify(callback, times(1)).reportFailedCheckpoint(anyLong(), any(Exception.class)).     }     {         // Fail subsumed         PendingCheckpointStats callback = mock(PendingCheckpointStats.class).         PendingCheckpoint pending = createPendingCheckpoint(CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION)).         pending.setStatsCallback(callback).         pending.abortError(new Exception("Expected test error")).         verify(callback, times(1)).reportFailedCheckpoint(anyLong(), any(Exception.class)).     }     {         // Fail subsumed         PendingCheckpointStats callback = mock(PendingCheckpointStats.class).         PendingCheckpoint pending = createPendingCheckpoint(CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION)).         pending.setStatsCallback(callback).         pending.abortExpired().         verify(callback, times(1)).reportFailedCheckpoint(anyLong(), any(Exception.class)).     } }
true;public;0;7;/**  * FLINK-5985.  *  * <p>Ensures that subtasks that acknowledge their state as 'null' are considered stateless. This means that they  * should not appear in the task states map of the checkpoint.  */ ;/**  * FLINK-5985.  *  * <p>Ensures that subtasks that acknowledge their state as 'null' are considered stateless. This means that they  * should not appear in the task states map of the checkpoint.  */ @Test public void testNullSubtaskStateLeadsToStatelessTask() throws Exception {     PendingCheckpoint pending = createPendingCheckpoint(CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION)).     pending.acknowledgeTask(ATTEMPT_ID, null, mock(CheckpointMetrics.class)).     Assert.assertTrue(pending.getOperatorStates().isEmpty()). }
true;public;0;7;/**  * FLINK-5985.  *  * <p>This tests checks the inverse of {@link #testNullSubtaskStateLeadsToStatelessTask()}. We want to test that  * for subtasks that acknowledge some state are given an entry in the task states of the checkpoint.  */ ;/**  * FLINK-5985.  *  * <p>This tests checks the inverse of {@link #testNullSubtaskStateLeadsToStatelessTask()}. We want to test that  * for subtasks that acknowledge some state are given an entry in the task states of the checkpoint.  */ @Test public void testNonNullSubtaskStateLeadsToStatefulTask() throws Exception {     PendingCheckpoint pending = createPendingCheckpoint(CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION)).     pending.acknowledgeTask(ATTEMPT_ID, mock(TaskStateSnapshot.class), mock(CheckpointMetrics.class)).     Assert.assertFalse(pending.getOperatorStates().isEmpty()). }
false;public;0;16;;@Test public void testSetCanceller() throws Exception {     final CheckpointProperties props = new CheckpointProperties(false, CheckpointType.CHECKPOINT, true, true, true, true, true).     PendingCheckpoint aborted = createPendingCheckpoint(props).     aborted.abortDeclined().     assertTrue(aborted.isDiscarded()).     assertFalse(aborted.setCancellerHandle(mock(ScheduledFuture.class))).     PendingCheckpoint pending = createPendingCheckpoint(props).     ScheduledFuture<?> canceller = mock(ScheduledFuture.class).     assertTrue(pending.setCancellerHandle(canceller)).     pending.abortDeclined().     verify(canceller).cancel(false). }
false;private;1;3;;// ------------------------------------------------------------------------ private PendingCheckpoint createPendingCheckpoint(CheckpointProperties props) throws IOException {     return createPendingCheckpoint(props, Executors.directExecutor()). }
false;private;2;20;;private PendingCheckpoint createPendingCheckpoint(CheckpointProperties props, Executor executor) throws IOException {     final Path checkpointDir = new Path(tmpFolder.newFolder().toURI()).     final FsCheckpointStorageLocation location = new FsCheckpointStorageLocation(LocalFileSystem.getSharedInstance(), checkpointDir, checkpointDir, checkpointDir, CheckpointStorageLocationReference.getDefault(), 1024).     final Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(ACK_TASKS).     return new PendingCheckpoint(new JobID(), 0, 1, ackTasks, props, location, executor). }
false;static;2;8;;@SuppressWarnings("unchecked") static void setTaskState(PendingCheckpoint pending, OperatorState state) throws NoSuchFieldException, IllegalAccessException {     Field field = PendingCheckpoint.class.getDeclaredField("operatorStates").     field.setAccessible(true).     Map<OperatorID, OperatorState> taskStates = (Map<OperatorID, OperatorState>) field.get(pending).     taskStates.put(new OperatorID(), state). }
false;public;1;4;;@Override public void execute(Runnable command) {     queue.add(command). }
false;public;0;5;;public void runQueuedCommands() {     for (Runnable runnable : queue) {         runnable.run().     } }
