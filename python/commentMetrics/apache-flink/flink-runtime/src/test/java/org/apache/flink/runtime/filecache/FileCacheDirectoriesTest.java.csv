commented;modifiers;parameterAmount;loc;comment;code
false;public;2;12;;@Override public File getFile(JobID jobId, PermanentBlobKey key) throws IOException {     if (key.equals(permanentBlobKey)) {         final java.nio.file.Path directory = temporaryFolder.newFolder("zipArchive").toPath().         final java.nio.file.Path containedFile = directory.resolve("cacheFile").         Files.copy(new ByteArrayInputStream(testFileContent.getBytes(StandardCharsets.UTF_8)), containedFile).         Path zipPath = FileUtils.compressDirectory(new Path(directory.toString()), new Path(directory + ".zip")).         return new File(zipPath.getPath()).     } else {         throw new IllegalArgumentException("This service contains only entry for " + permanentBlobKey).     } }
false;public;0;4;;@Override public void close() throws IOException { }
false;public;0;4;;@Before public void setup() throws Exception {     fileCache = new FileCache(new String[] { temporaryFolder.newFolder().getAbsolutePath() }, blobService, executorService, CLEANUP_INTERVAL). }
false;public;0;8;;@After public void shutdown() {     fileCache.shutdown().     if (executorService.lastDeleteProcess != null) {         executorService.lastDeleteProcess.run().     } }
false;public;0;24;;@Test public void testDirectoryDownloadedFromBlob() throws Exception {     JobID jobID = new JobID().     ExecutionAttemptID attemptID = new ExecutionAttemptID().     final String fileName = "test_file".     // copy / create the file     final DistributedCache.DistributedCacheEntry entry = new DistributedCache.DistributedCacheEntry(fileName, false, InstantiationUtil.serializeObject(permanentBlobKey), true).     Future<Path> copyResult = fileCache.createTmpFile(fileName, entry, jobID, attemptID).     final Path dstPath = copyResult.get().     final FileSystem fs = dstPath.getFileSystem().     final FileStatus fileStatus = fs.getFileStatus(dstPath).     assertTrue(fileStatus.isDir()).     final Path cacheFile = new Path(dstPath, "cacheFile").     assertTrue(fs.exists(cacheFile)).     final String actualContent = FileUtils.readFileUtf8(new File(cacheFile.getPath())).     assertEquals(testFileContent, actualContent). }
false;public;0;40;;@Test public void testDirectoryCleanUp() throws Exception {     JobID jobID = new JobID().     ExecutionAttemptID attemptID1 = new ExecutionAttemptID().     ExecutionAttemptID attemptID2 = new ExecutionAttemptID().     final String fileName = "test_file".     // copy / create the file     final DistributedCache.DistributedCacheEntry entry = new DistributedCache.DistributedCacheEntry(fileName, false, InstantiationUtil.serializeObject(permanentBlobKey), true).     Future<Path> copyResult = fileCache.createTmpFile(fileName, entry, jobID, attemptID1).     fileCache.createTmpFile(fileName, entry, jobID, attemptID2).     final Path dstPath = copyResult.get().     final FileSystem fs = dstPath.getFileSystem().     final FileStatus fileStatus = fs.getFileStatus(dstPath).     final Path cacheFile = new Path(dstPath, "cacheFile").     assertTrue(fileStatus.isDir()).     assertTrue(fs.exists(cacheFile)).     fileCache.releaseJob(jobID, attemptID1).     // still should be available     assertTrue(fileStatus.isDir()).     assertTrue(fs.exists(cacheFile)).     fileCache.releaseJob(jobID, attemptID2).     // still should be available, file will be deleted after cleanupInterval     assertTrue(fileStatus.isDir()).     assertTrue(fs.exists(cacheFile)).     // after a while, the file should disappear     assertEquals(CLEANUP_INTERVAL, executorService.lastDelayMillis).     executorService.lastDeleteProcess.run().     assertFalse(fs.exists(dstPath)).     assertFalse(fs.exists(cacheFile)). }
false;public;3;12;;@Override public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {     if (command instanceof FileCache.DeleteProcess) {         assertNull("Multiple delete process registered", lastDeleteProcess).         lastDeleteProcess = (FileCache.DeleteProcess) command.         lastDelayMillis = unit.toMillis(delay).         return super.schedule(() -> {         }, delay, unit).     } else {         return super.schedule(command, delay, unit).     } }
