commented;modifiers;parameterAmount;loc;comment;code
false;public;0;24;;@Override public Void call() throws Exception {     for (int i = 0. i < numberOfRuns. i++) {         LOG.debug("Starting run {}.", i + 1).         for (int j = 0. j < numberOfRequests. j++) {             ioChannel.addRequest(request).         }         LOG.debug("Added all ({}) requests of run {}.", numberOfRequests, i + 1).         int sleep = random.nextInt(10).         LOG.debug("Sleeping for {} ms before next run.", sleep).         Thread.sleep(sleep).     }     LOG.debug("Done. Closing channel.").     ioChannel.close().     sync.countDown().     return null. }
false;public;0;15;;@Override public Void call() throws Exception {     int total = numberOfRequests * numberOfRuns.     for (int i = 0. i < total. i++) {         requestQueue.take().         ioChannel.handleProcessedBuffer(buffer, null).     }     LOG.debug("Processed all ({}) requests.", numberOfRequests).     sync.countDown().     return null. }
false;public;0;19;;@Override public Void call() throws Exception {     while (true) {         int current = listener.getNumberOfNotifications().         if (ioChannel.registerAllRequestsProcessedListener(listener)) {             listener.waitForNotification(current).         } else if (ioChannel.isClosed()) {             break.         }     }     LOG.debug("Stopping listener. Channel closed.").     sync.countDown().     return null. }
false;public;0;130;;@Test public void testAllRequestsProcessedListenerNotification() throws Exception {     // -- Config ----------------------------------------------------------     final int numberOfRuns = 10.     final int numberOfRequests = 100.     // -- Setup -----------------------------------------------------------     final IOManagerAsync ioManager = new IOManagerAsync().     final ExecutorService executor = Executors.newFixedThreadPool(3).     final Random random = new Random().     final RequestQueue<WriteRequest> requestQueue = new RequestQueue<WriteRequest>().     final RequestDoneCallback<Buffer> ioChannelCallback = mock(RequestDoneCallback.class).     final TestNotificationListener listener = new TestNotificationListener().     // -- The Test --------------------------------------------------------     try {         for (int run = 0. run < numberOfRuns. run++) {             final TestAsyncFileIOChannel ioChannel = new TestAsyncFileIOChannel(ioManager.createChannel(), requestQueue, ioChannelCallback, true).             final CountDownLatch sync = new CountDownLatch(3).             // The mock requests             final Buffer buffer = mock(Buffer.class).             final WriteRequest request = mock(WriteRequest.class).             // Add requests task             Callable<Void> addRequestsTask = new Callable<Void>() {                  @Override                 public Void call() throws Exception {                     for (int i = 0. i < numberOfRuns. i++) {                         LOG.debug("Starting run {}.", i + 1).                         for (int j = 0. j < numberOfRequests. j++) {                             ioChannel.addRequest(request).                         }                         LOG.debug("Added all ({}) requests of run {}.", numberOfRequests, i + 1).                         int sleep = random.nextInt(10).                         LOG.debug("Sleeping for {} ms before next run.", sleep).                         Thread.sleep(sleep).                     }                     LOG.debug("Done. Closing channel.").                     ioChannel.close().                     sync.countDown().                     return null.                 }             }.             // Process requests task             Callable<Void> processRequestsTask = new Callable<Void>() {                  @Override                 public Void call() throws Exception {                     int total = numberOfRequests * numberOfRuns.                     for (int i = 0. i < total. i++) {                         requestQueue.take().                         ioChannel.handleProcessedBuffer(buffer, null).                     }                     LOG.debug("Processed all ({}) requests.", numberOfRequests).                     sync.countDown().                     return null.                 }             }.             // Listener             Callable<Void> registerListenerTask = new Callable<Void>() {                  @Override                 public Void call() throws Exception {                     while (true) {                         int current = listener.getNumberOfNotifications().                         if (ioChannel.registerAllRequestsProcessedListener(listener)) {                             listener.waitForNotification(current).                         } else if (ioChannel.isClosed()) {                             break.                         }                     }                     LOG.debug("Stopping listener. Channel closed.").                     sync.countDown().                     return null.                 }             }.             // Run tasks in random order             final List<Callable<?>> tasks = new LinkedList<Callable<?>>().             tasks.add(addRequestsTask).             tasks.add(processRequestsTask).             tasks.add(registerListenerTask).             Collections.shuffle(tasks).             for (Callable<?> task : tasks) {                 executor.submit(task).             }             if (!sync.await(2, TimeUnit.MINUTES)) {                 fail("Test failed due to a timeout. This indicates a deadlock due to the way" + "that listeners are registered/notified in the asynchronous file I/O" + "channel.").             }             listener.reset().         }     } finally {         ioManager.shutdown().         executor.shutdown().     } }
false;public;0;13;;@Override public Void call() throws Exception {     try {         ioChannel.addRequest(request).     } catch (Throwable expected) {     } finally {         sync.countDown().     }     return null. }
false;public;0;20;;@Override public Void call() throws Exception {     try {         while (true) {             int current = listener.getNumberOfNotifications().             if (ioChannel.registerAllRequestsProcessedListener(listener)) {                 listener.waitForNotification(current).             } else if (ioChannel.isClosed()) {                 break.             }         }     } finally {         sync.countDown().     }     return null. }
false;public;0;86;;@Test public void testClosedButAddRequestAndRegisterListenerRace() throws Exception {     // -- Config ----------------------------------------------------------     final int numberOfRuns = 1024.     // -- Setup -----------------------------------------------------------     final IOManagerAsync ioManager = new IOManagerAsync().     final ExecutorService executor = Executors.newFixedThreadPool(2).     final RequestQueue<WriteRequest> requestQueue = new RequestQueue<WriteRequest>().     @SuppressWarnings("unchecked")     final RequestDoneCallback<Buffer> ioChannelCallback = mock(RequestDoneCallback.class).     final TestNotificationListener listener = new TestNotificationListener().     // -- The Test --------------------------------------------------------     try {         // Repeatedly close the channel and add a request.         for (int i = 0. i < numberOfRuns. i++) {             final TestAsyncFileIOChannel ioChannel = new TestAsyncFileIOChannel(ioManager.createChannel(), requestQueue, ioChannelCallback, true).             final CountDownLatch sync = new CountDownLatch(2).             final WriteRequest request = mock(WriteRequest.class).             ioChannel.close().             // Add request task             Callable<Void> addRequestTask = new Callable<Void>() {                  @Override                 public Void call() throws Exception {                     try {                         ioChannel.addRequest(request).                     } catch (Throwable expected) {                     } finally {                         sync.countDown().                     }                     return null.                 }             }.             // Listener             Callable<Void> registerListenerTask = new Callable<Void>() {                  @Override                 public Void call() throws Exception {                     try {                         while (true) {                             int current = listener.getNumberOfNotifications().                             if (ioChannel.registerAllRequestsProcessedListener(listener)) {                                 listener.waitForNotification(current).                             } else if (ioChannel.isClosed()) {                                 break.                             }                         }                     } finally {                         sync.countDown().                     }                     return null.                 }             }.             executor.submit(addRequestTask).             executor.submit(registerListenerTask).             if (!sync.await(2, TimeUnit.MINUTES)) {                 fail("Test failed due to a timeout. This indicates a deadlock due to the way" + "that listeners are registered/notified in the asynchronous file I/O" + "channel.").             }         }     } finally {         ioManager.shutdown().         executor.shutdown().     } }
false;public;1;10;;@Override public void requestSuccessful(MemorySegment buffer) {     // we do the non safe variant. the callbacks should come in order from     // the same thread, so it should always work     callbackCounter.set(callbackCounter.get() + 1).     if (buffer != seg) {         exceptionOccurred.set(true).     } }
false;public;2;4;;@Override public void requestFailed(MemorySegment buffer, IOException e) {     exceptionOccurred.set(true). }
false;public;0;53;;@Test public void testClosingWaits() {     IOManagerAsync ioMan = new IOManagerAsync().     try {         final int NUM_BLOCKS = 100.         final MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(32 * 1024).         final AtomicInteger callbackCounter = new AtomicInteger().         final AtomicBoolean exceptionOccurred = new AtomicBoolean().         final RequestDoneCallback<MemorySegment> callback = new RequestDoneCallback<MemorySegment>() {              @Override             public void requestSuccessful(MemorySegment buffer) {                 // we do the non safe variant. the callbacks should come in order from                 // the same thread, so it should always work                 callbackCounter.set(callbackCounter.get() + 1).                 if (buffer != seg) {                     exceptionOccurred.set(true).                 }             }              @Override             public void requestFailed(MemorySegment buffer, IOException e) {                 exceptionOccurred.set(true).             }         }.         BlockChannelWriterWithCallback<MemorySegment> writer = ioMan.createBlockChannelWriter(ioMan.createChannel(), callback).         try {             for (int i = 0. i < NUM_BLOCKS. i++) {                 writer.writeBlock(seg).             }             writer.close().             assertEquals(NUM_BLOCKS, callbackCounter.get()).             assertFalse(exceptionOccurred.get()).         } finally {             writer.closeAndDelete().         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } finally {         ioMan.shutdown().     } }
false;public;0;11;;@Test public void testExceptionForwardsToClose() {     IOManagerAsync ioMan = new IOManagerAsync().     try {         testExceptionForwardsToClose(ioMan, 100, 1).         testExceptionForwardsToClose(ioMan, 100, 50).         testExceptionForwardsToClose(ioMan, 100, 100).     } finally {         ioMan.shutdown().     } }
false;public;1;11;;@Override public void writeBlock(MemorySegment segment) throws IOException {     numBlocks++.     if (numBlocks == failingBlock) {         this.requestsNotReturned.incrementAndGet().         this.requestQueue.add(new FailingWriteRequest(this, segment)).     } else {         super.writeBlock(segment).     } }
false;private;3;45;;private void testExceptionForwardsToClose(IOManagerAsync ioMan, final int numBlocks, final int failingBlock) {     try {         MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(32 * 1024).         FileIOChannel.ID channelId = ioMan.createChannel().         BlockChannelWriterWithCallback<MemorySegment> writer = new AsynchronousBlockWriterWithCallback(channelId, ioMan.getWriteRequestQueue(channelId), new NoOpCallback()) {              private int numBlocks.              @Override             public void writeBlock(MemorySegment segment) throws IOException {                 numBlocks++.                 if (numBlocks == failingBlock) {                     this.requestsNotReturned.incrementAndGet().                     this.requestQueue.add(new FailingWriteRequest(this, segment)).                 } else {                     super.writeBlock(segment).                 }             }         }.         try {             for (int i = 0. i < numBlocks. i++) {                 writer.writeBlock(seg).             }             writer.close().             fail("did not forward exception").         } catch (IOException e) {         // expected         } finally {             try {                 writer.closeAndDelete().             } catch (Throwable ignored) {             }         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;1;2;;@Override public void requestSuccessful(MemorySegment buffer) { }
false;public;2;2;;@Override public void requestFailed(MemorySegment buffer, IOException e) { }
false;public;0;4;;@Override public void write() throws IOException {     throw new IOException(). }
false;public;1;4;;@Override public void requestDone(IOException ioex) {     this.channel.handleProcessedBuffer(this.segment, ioex). }
false;;0;3;;int getNumberOfOutstandingRequests() {     return requestsNotReturned.get(). }
