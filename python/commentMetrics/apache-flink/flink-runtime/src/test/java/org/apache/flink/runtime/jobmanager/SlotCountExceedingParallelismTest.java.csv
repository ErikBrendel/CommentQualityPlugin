commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;6;;private static Configuration getFlinkConfiguration() {     final Configuration config = new Configuration().     config.setString(AkkaOptions.ASK_TIMEOUT, TestingUtils.DEFAULT_AKKA_ASK_TIMEOUT()).     return config. }
false;public;0;6;;@Test public void testNoSlotSharingAndBlockingResultSender() throws Exception {     // Sender with higher parallelism than available slots     JobGraph jobGraph = createTestJobGraph(JOB_NAME, PARALLELISM * 2, PARALLELISM).     submitJobGraphAndWait(jobGraph). }
false;public;0;6;;@Test public void testNoSlotSharingAndBlockingResultReceiver() throws Exception {     // Receiver with higher parallelism than available slots     JobGraph jobGraph = createTestJobGraph(JOB_NAME, PARALLELISM, PARALLELISM * 2).     submitJobGraphAndWait(jobGraph). }
false;public;0;6;;@Test public void testNoSlotSharingAndBlockingResultBoth() throws Exception {     // Both sender and receiver with higher parallelism than available slots     JobGraph jobGraph = createTestJobGraph(JOB_NAME, PARALLELISM * 2, PARALLELISM * 2).     submitJobGraphAndWait(jobGraph). }
false;private;1;3;;// --------------------------------------------------------------------------------------------- private void submitJobGraphAndWait(final JobGraph jobGraph) throws JobExecutionException, InterruptedException {     MINI_CLUSTER_RESOURCE.getMiniCluster().executeJobBlocking(jobGraph). }
false;private;3;30;;private JobGraph createTestJobGraph(String jobName, int senderParallelism, int receiverParallelism) {     // The sender and receiver invokable logic ensure that each subtask gets the expected data     final JobVertex sender = new JobVertex("Sender").     sender.setInvokableClass(RoundRobinSubtaskIndexSender.class).     sender.getConfiguration().setInteger(RoundRobinSubtaskIndexSender.CONFIG_KEY, receiverParallelism).     sender.setParallelism(senderParallelism).     final JobVertex receiver = new JobVertex("Receiver").     receiver.setInvokableClass(SubtaskIndexReceiver.class).     receiver.getConfiguration().setInteger(SubtaskIndexReceiver.CONFIG_KEY, senderParallelism).     receiver.setParallelism(receiverParallelism).     receiver.connectNewDataSetAsInput(sender, DistributionPattern.ALL_TO_ALL, ResultPartitionType.BLOCKING).     final JobGraph jobGraph = new JobGraph(jobName, sender, receiver).     // We need to allow queued scheduling, because there are not enough slots available     // to run all tasks at once. We queue tasks and then let them finish/consume the blocking     // result one after the other.     jobGraph.setAllowQueuedScheduling(true).     return jobGraph. }
false;public;0;18;;@Override public void invoke() throws Exception {     RecordWriter<IntValue> writer = new RecordWriter<>(getEnvironment().getWriter(0)).     final int numberOfTimesToSend = getTaskConfiguration().getInteger(CONFIG_KEY, 0).     final IntValue subtaskIndex = new IntValue(getEnvironment().getTaskInfo().getIndexOfThisSubtask()).     try {         for (int i = 0. i < numberOfTimesToSend. i++) {             writer.emit(subtaskIndex).         }         writer.flushAll().     } finally {         writer.clearBuffers().     } }
false;public;0;44;;@Override public void invoke() throws Exception {     RecordReader<IntValue> reader = new RecordReader<>(getEnvironment().getInputGate(0), IntValue.class, getEnvironment().getTaskManagerInfo().getTmpDirectories()).     try {         final int numberOfSubtaskIndexesToReceive = getTaskConfiguration().getInteger(CONFIG_KEY, 0).         final BitSet receivedSubtaskIndexes = new BitSet(numberOfSubtaskIndexesToReceive).         IntValue record.         int numberOfReceivedSubtaskIndexes = 0.         while ((record = reader.next()) != null) {             // Check that we don't receive more than expected             numberOfReceivedSubtaskIndexes++.             if (numberOfReceivedSubtaskIndexes > numberOfSubtaskIndexesToReceive) {                 throw new IllegalStateException("Received more records than expected.").             }             int subtaskIndex = record.getValue().             // Check that we only receive each subtask index once             if (receivedSubtaskIndexes.get(subtaskIndex)) {                 throw new IllegalStateException("Received expected subtask index twice.").             } else {                 receivedSubtaskIndexes.set(subtaskIndex, true).             }         }         // Check that we have received all expected subtask indexes         if (receivedSubtaskIndexes.cardinality() != numberOfSubtaskIndexesToReceive) {             throw new IllegalStateException("Finished receive, but did not receive " + "all expected subtask indexes.").         }     } finally {         reader.clearBuffers().     } }
