commented;modifiers;parameterAmount;loc;comment;code
false;public;1;24;;@Override public void write(int b) throws IOException {     if (position == blockAtPosition) {         unblockWaiter().         awaitUnblocker().     }     if (delegate != null) {         try {             delegate.write(b).         } catch (IOException ex) {             unblockWaiter().             throw ex.         }     }     // We also check for close here, in case the underlying stream does not do this     if (closed.get()) {         throw new IOException("Stream closed.").     }     ++position. }
true;public;3;6;// We override this to ensure that writes go through the blocking #write(int) method! ;// We override this to ensure that writes go through the blocking #write(int) method! @Override public void write(byte[] b, int off, int len) throws IOException {     for (int i = 0. i < len. i++) {         write(b[off + i]).     } }
false;public;0;4;;@Override public long getPos() throws IOException {     return position. }
false;public;0;6;;@Override public void flush() throws IOException {     if (delegate != null) {         delegate.flush().     } }
false;public;0;6;;@Override public void sync() throws IOException {     if (delegate != null) {         delegate.sync().     } }
false;public;0;10;;@Override public void close() {     if (closed.compareAndSet(false, true)) {         if (delegate != null) {             IOUtils.closeQuietly(delegate).         }         // trigger all the latches, essentially all blocking ops on the stream should resume after close.         unblockAll().     } }
false;private;0;5;;private void unblockWaiter() {     if (null != waitForBlocking) {         waitForBlocking.trigger().     } }
false;private;0;8;;private void awaitUnblocker() {     if (null != triggerUnblock) {         try {             triggerUnblock.await().         } catch (InterruptedException ignored) {         }     } }
false;private;0;8;;private void unblockAll() {     if (null != waitForBlocking) {         waitForBlocking.trigger().     }     if (null != triggerUnblock) {         triggerUnblock.trigger().     } }
false;public;0;18;;@Nullable @Override public StreamStateHandle closeAndGetHandle() throws IOException {     if (!closed.compareAndSet(false, true)) {         throw new IOException("Stream was already closed!").     }     if (delegate instanceof CheckpointStreamFactory.CheckpointStateOutputStream) {         StreamStateHandle streamStateHandle = ((CheckpointStreamFactory.CheckpointStateOutputStream) delegate).closeAndGetHandle().         unblockAll().         return streamStateHandle.     } else {         unblockAll().         throw new IOException("Delegate is not a CheckpointStateOutputStream!").     } }
false;public;0;3;;public boolean isClosed() {     return closed.get(). }
