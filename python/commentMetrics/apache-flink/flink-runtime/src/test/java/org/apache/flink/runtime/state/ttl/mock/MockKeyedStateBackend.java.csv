commented;modifiers;parameterAmount;loc;comment;code
false;;2;3;;<N, SV, S extends State, IS extends S> IS createInternalState(TypeSerializer<N> namespaceSerializer, StateDescriptor<S, SV> stateDesc) throws Exception.
false;public;3;21;;@Override @SuppressWarnings("unchecked") @Nonnull public <N, SV, SEV, S extends State, IS extends S> IS createInternalState(@Nonnull TypeSerializer<N> namespaceSerializer, @Nonnull StateDescriptor<S, SV> stateDesc, @Nonnull StateSnapshotTransformFactory<SEV> snapshotTransformFactory) throws Exception {     StateFactory stateFactory = STATE_FACTORIES.get(stateDesc.getClass()).     if (stateFactory == null) {         String message = String.format("State %s is not supported by %s", stateDesc.getClass(), TtlStateFactory.class).         throw new FlinkRuntimeException(message).     }     IS state = stateFactory.createInternalState(namespaceSerializer, stateDesc).     stateSnapshotFilters.put(stateDesc.getName(), (StateSnapshotTransformer<Object>) getStateSnapshotTransformer(stateDesc, snapshotTransformFactory)).     ((MockInternalKvState<K, N, SV>) state).values = () -> stateValues.computeIfAbsent(stateDesc.getName(), n -> new HashMap<>()).computeIfAbsent(getCurrentKey(), k -> new HashMap<>()).     return state. }
false;private;2;17;;@SuppressWarnings("unchecked") private <SV, SEV> StateSnapshotTransformer<SV> getStateSnapshotTransformer(StateDescriptor<?, SV> stateDesc, StateSnapshotTransformFactory<SEV> snapshotTransformFactory) {     Optional<StateSnapshotTransformer<SEV>> original = snapshotTransformFactory.createForDeserializedState().     if (original.isPresent()) {         if (stateDesc instanceof ListStateDescriptor) {             return (StateSnapshotTransformer<SV>) new StateSnapshotTransformers.ListStateSnapshotTransformer<>(original.get()).         } else if (stateDesc instanceof MapStateDescriptor) {             return (StateSnapshotTransformer<SV>) new StateSnapshotTransformers.MapStateSnapshotTransformer<>(original.get()).         } else {             return (StateSnapshotTransformer<SV>) original.get().         }     } else {         return null.     } }
false;public;0;10;;@Override public int numKeyValueStateEntries() {     int count = 0.     for (String state : stateValues.keySet()) {         for (K key : stateValues.get(state).keySet()) {             count += stateValues.get(state).get(key).size().         }     }     return count. }
false;public;0;4;;@Override public boolean requiresLegacySynchronousTimerSnapshots() {     return false. }
false;public;1;4;;@Override public void notifyCheckpointComplete(long checkpointId) { // noop }
false;public;2;6;;@Override public <N> Stream<K> getKeys(String state, N namespace) {     return stateValues.get(state).entrySet().stream().filter(e -> e.getValue().containsKey(namespace)).map(Map.Entry::getKey). }
false;public;4;10;;@Nonnull @Override public RunnableFuture<SnapshotResult<KeyedStateHandle>> snapshot(long checkpointId, long timestamp, @Nonnull CheckpointStreamFactory streamFactory, @Nonnull CheckpointOptions checkpointOptions) {     return new FutureTask<>(() -> SnapshotResult.of(new MockKeyedStateHandle<>(copy(stateValues, stateSnapshotFilters)))). }
false;public;1;7;;@SuppressWarnings("unchecked") @Override public void restore(Collection<KeyedStateHandle> state) {     stateValues.clear().     state = state == null ? Collections.emptyList() : state.     state.forEach(ksh -> stateValues.putAll(copy(((MockKeyedStateHandle<K>) ksh).snapshotStates))). }
false;private,static;1;4;;private static <K> Map<String, Map<K, Map<Object, Object>>> copy(Map<String, Map<K, Map<Object, Object>>> stateValues) {     return copy(stateValues, Collections.emptyMap()). }
false;private,static;2;15;;private static <K> Map<String, Map<K, Map<Object, Object>>> copy(Map<String, Map<K, Map<Object, Object>>> stateValues, Map<String, StateSnapshotTransformer<Object>> stateSnapshotFilters) {     Map<String, Map<K, Map<Object, Object>>> snapshotStates = new HashMap<>().     for (String stateName : stateValues.keySet()) {         StateSnapshotTransformer<Object> stateSnapshotTransformer = stateSnapshotFilters.getOrDefault(stateName, null).         Map<K, Map<Object, Object>> keyedValues = snapshotStates.computeIfAbsent(stateName, s -> new HashMap<>()).         for (K key : stateValues.get(stateName).keySet()) {             Map<Object, Object> snapshotedValues = keyedValues.computeIfAbsent(key, s -> new HashMap<>()).             for (Object namespace : stateValues.get(stateName).get(key).keySet()) {                 copyEntry(stateValues, snapshotedValues, stateName, key, namespace, stateSnapshotTransformer).             }         }     }     return snapshotStates. }
false;private,static;6;16;;@SuppressWarnings("unchecked") private static <K> void copyEntry(Map<String, Map<K, Map<Object, Object>>> stateValues, Map<Object, Object> snapshotedValues, String stateName, K key, Object namespace, StateSnapshotTransformer<Object> stateSnapshotTransformer) {     Object value = stateValues.get(stateName).get(key).get(namespace).     value = value instanceof List ? new ArrayList<>((List) value) : value.     value = value instanceof Map ? new HashMap<>((Map) value) : value.     Object filteredValue = stateSnapshotTransformer == null ? value : stateSnapshotTransformer.filterOrTransform(value).     if (filteredValue != null) {         snapshotedValues.put(namespace, filteredValue).     } }
false;public;2;13;;@Nonnull @Override public <T extends HeapPriorityQueueElement & PriorityComparable & Keyed> KeyGroupedInternalPriorityQueue<T> create(@Nonnull String stateName, @Nonnull TypeSerializer<T> byteOrderedElementSerializer) {     return new HeapPriorityQueueSet<>(PriorityComparator.forPriorityComparableObjects(), KeyExtractorFunction.forKeyedObjects(), 0, keyGroupRange, 0). }
false;public;0;4;;@Override public void discardState() {     snapshotStates.clear(). }
false;public;0;4;;@Override public long getStateSize() {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public void registerSharedStates(SharedStateRegistry stateRegistry) { }
false;public;0;4;;@Override public KeyGroupRange getKeyGroupRange() {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public KeyedStateHandle getIntersection(KeyGroupRange keyGroupRange) {     throw new UnsupportedOperationException(). }
