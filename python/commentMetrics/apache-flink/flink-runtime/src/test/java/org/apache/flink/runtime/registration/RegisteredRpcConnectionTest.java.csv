commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void setup() {     rpcService = new TestingRpcService(). }
false;public;0;6;;@After public void tearDown() throws ExecutionException, InterruptedException {     if (rpcService != null) {         rpcService.stopService().get().     } }
false;public;0;29;;@Test public void testSuccessfulRpcConnection() throws Exception {     final String testRpcConnectionEndpointAddress = "<TestRpcConnectionEndpointAddress>".     final UUID leaderId = UUID.randomUUID().     final String connectionID = "Test RPC Connection ID".     // an endpoint that immediately returns success     TestRegistrationGateway testGateway = new TestRegistrationGateway(new RetryingRegistrationTest.TestRegistrationSuccess(connectionID)).     try {         rpcService.registerGateway(testRpcConnectionEndpointAddress, testGateway).         TestRpcConnection connection = new TestRpcConnection(testRpcConnectionEndpointAddress, leaderId, rpcService.getExecutor(), rpcService).         connection.start().         // wait for connection established         final String actualConnectionId = connection.getConnectionFuture().get().         // validate correct invocation and result         assertTrue(connection.isConnected()).         assertEquals(testRpcConnectionEndpointAddress, connection.getTargetAddress()).         assertEquals(leaderId, connection.getTargetLeaderId()).         assertEquals(testGateway, connection.getTargetGateway()).         assertEquals(connectionID, actualConnectionId).     } finally {         testGateway.stop().     } }
false;public;0;31;;@Test public void testRpcConnectionFailures() throws Exception {     final String connectionFailureMessage = "Test RPC Connection failure".     final String testRpcConnectionEndpointAddress = "<TestRpcConnectionEndpointAddress>".     final UUID leaderId = UUID.randomUUID().     // gateway that upon calls Throw an exception     TestRegistrationGateway testGateway = mock(TestRegistrationGateway.class).     final RuntimeException registrationException = new RuntimeException(connectionFailureMessage).     when(testGateway.registrationCall(any(UUID.class), anyLong())).thenThrow(registrationException).     rpcService.registerGateway(testRpcConnectionEndpointAddress, testGateway).     TestRpcConnection connection = new TestRpcConnection(testRpcConnectionEndpointAddress, leaderId, rpcService.getExecutor(), rpcService).     connection.start().     // wait for connection failure     try {         connection.getConnectionFuture().get().         fail("expected failure.").     } catch (ExecutionException ee) {         assertEquals(registrationException, ee.getCause()).     }     // validate correct invocation and result     assertFalse(connection.isConnected()).     assertEquals(testRpcConnectionEndpointAddress, connection.getTargetAddress()).     assertEquals(leaderId, connection.getTargetLeaderId()).     assertNull(connection.getTargetGateway()). }
false;public;0;25;;@Test public void testRpcConnectionClose() throws Exception {     final String testRpcConnectionEndpointAddress = "<TestRpcConnectionEndpointAddress>".     final UUID leaderId = UUID.randomUUID().     final String connectionID = "Test RPC Connection ID".     TestRegistrationGateway testGateway = new TestRegistrationGateway(new RetryingRegistrationTest.TestRegistrationSuccess(connectionID)).     try {         rpcService.registerGateway(testRpcConnectionEndpointAddress, testGateway).         TestRpcConnection connection = new TestRpcConnection(testRpcConnectionEndpointAddress, leaderId, rpcService.getExecutor(), rpcService).         connection.start().         // close the connection         connection.close().         // validate connection is closed         assertEquals(testRpcConnectionEndpointAddress, connection.getTargetAddress()).         assertEquals(leaderId, connection.getTargetLeaderId()).         assertTrue(connection.isClosed()).     } finally {         testGateway.stop().     } }
false;public;0;25;;@Test public void testReconnect() throws Exception {     final String connectionId1 = "Test RPC Connection ID 1".     final String connectionId2 = "Test RPC Connection ID 2".     final String testRpcConnectionEndpointAddress = "<TestRpcConnectionEndpointAddress>".     final UUID leaderId = UUID.randomUUID().     final TestRegistrationGateway testGateway = new TestRegistrationGateway(new RetryingRegistrationTest.TestRegistrationSuccess(connectionId1), new RetryingRegistrationTest.TestRegistrationSuccess(connectionId2)).     rpcService.registerGateway(testRpcConnectionEndpointAddress, testGateway).     TestRpcConnection connection = new TestRpcConnection(testRpcConnectionEndpointAddress, leaderId, rpcService.getExecutor(), rpcService).     connection.start().     final String actualConnectionId1 = connection.getConnectionFuture().get().     assertEquals(actualConnectionId1, connectionId1).     assertTrue(connection.tryReconnect()).     final String actualConnectionId2 = connection.getConnectionFuture().get().     assertEquals(actualConnectionId2, connectionId2). }
false;protected;0;4;;@Override protected RetryingRegistration<UUID, TestRegistrationGateway, RetryingRegistrationTest.TestRegistrationSuccess> generateRegistration() {     return new RetryingRegistrationTest.TestRetryingRegistration(rpcService, getTargetAddress(), getTargetLeaderId()). }
false;protected;1;6;;@Override protected void onRegistrationSuccess(RetryingRegistrationTest.TestRegistrationSuccess success) {     synchronized (lock) {         connectionFuture.complete(success.getCorrelationId()).     } }
false;protected;1;6;;@Override protected void onRegistrationFailure(Throwable failure) {     synchronized (lock) {         connectionFuture.completeExceptionally(failure).     } }
false;public;0;8;;@Override public boolean tryReconnect() {     synchronized (lock) {         connectionFuture.cancel(false).         connectionFuture = new CompletableFuture<>().     }     return super.tryReconnect(). }
false;public;0;5;;public CompletableFuture<String> getConnectionFuture() {     synchronized (lock) {         return connectionFuture.     } }
