commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ChannelHandler[] getServerChannelHandlers() {     return new ChannelHandler[0]. }
false;public;3;11;;@Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {     if (writeNum >= 1) {         throw new RuntimeException("Expected test exception.").     }     writeNum++.     ctx.write(msg, promise). }
false;public;1;5;;@Override public Void answer(InvocationOnMock invocation) throws Throwable {     sync.countDown().     return null. }
true;public;0;78;/**  * Verifies that failed client requests via {@link PartitionRequestClient} are correctly  * attributed to the respective {@link RemoteInputChannel}.  */ ;/**  * Verifies that failed client requests via {@link PartitionRequestClient} are correctly  * attributed to the respective {@link RemoteInputChannel}.  */ @Test public void testExceptionOnWrite() throws Exception {     NettyProtocol protocol = new NettyProtocol(mock(ResultPartitionProvider.class), mock(TaskEventDispatcher.class), true) {          @Override         public ChannelHandler[] getServerChannelHandlers() {             return new ChannelHandler[0].         }     }.     // We need a real server and client in this test, because Netty's EmbeddedChannel is     // not failing the ChannelPromise of failed writes.     NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig()).     Channel ch = connect(serverAndClient).     NetworkClientHandler handler = getClientHandler(ch).     // Last outbound handler throws Exception after 1st write     ch.pipeline().addFirst(new ChannelOutboundHandlerAdapter() {          int writeNum = 0.          @Override         public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {             if (writeNum >= 1) {                 throw new RuntimeException("Expected test exception.").             }             writeNum++.             ctx.write(msg, promise).         }     }).     PartitionRequestClient requestClient = new PartitionRequestClient(ch, handler, mock(ConnectionID.class), mock(PartitionRequestClientFactory.class)).     // Create input channels     RemoteInputChannel[] rich = new RemoteInputChannel[] { createRemoteInputChannel(), createRemoteInputChannel() }.     final CountDownLatch sync = new CountDownLatch(1).     // Do this with explicit synchronization. Otherwise this is not robust against slow timings     // of the callback (e.g. we cannot just verify that it was called once, because there is     // a chance that we do this too early).     doAnswer(new Answer<Void>() {          @Override         public Void answer(InvocationOnMock invocation) throws Throwable {             sync.countDown().             return null.         }     }).when(rich[1]).onError(isA(LocalTransportException.class)).     // First request is successful     ChannelFuture f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[0], 0).     assertTrue(f.await().isSuccess()).     // Second request is *not* successful     f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[1], 0).     assertFalse(f.await().isSuccess()).     // Only the second channel should be notified about the error     verify(rich[0], times(0)).onError(any(LocalTransportException.class)).     // Wait for the notification     if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {         fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() + " ms to be notified about the channel error.").     }     shutdown(serverAndClient). }
true;public;0;48;/**  * Verifies that {@link NettyMessage.ErrorResponse} messages are correctly wrapped in  * {@link RemoteTransportException} instances.  */ ;/**  * Verifies that {@link NettyMessage.ErrorResponse} messages are correctly wrapped in  * {@link RemoteTransportException} instances.  */ @Test public void testWrappingOfRemoteErrorMessage() throws Exception {     EmbeddedChannel ch = createEmbeddedChannel().     NetworkClientHandler handler = getClientHandler(ch).     // Create input channels     RemoteInputChannel[] rich = new RemoteInputChannel[] { createRemoteInputChannel(), createRemoteInputChannel() }.     for (RemoteInputChannel r : rich) {         when(r.getInputChannelId()).thenReturn(new InputChannelID()).         handler.addInputChannel(r).     }     // Error msg for channel[0]     ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(new RuntimeException("Expected test exception"), rich[0].getInputChannelId())).     try {         // Exception should not reach end of pipeline...         ch.checkException().     } catch (Exception e) {         fail("The exception reached the end of the pipeline and " + "was not handled correctly by the last handler.").     }     verify(rich[0], times(1)).onError(isA(RemoteTransportException.class)).     verify(rich[1], never()).onError(any(Throwable.class)).     // Fatal error for all channels     ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(new RuntimeException("Expected test exception"))).     try {         // Exception should not reach end of pipeline...         ch.checkException().     } catch (Exception e) {         fail("The exception reached the end of the pipeline and " + "was not handled correctly by the last handler.").     }     verify(rich[0], times(2)).onError(isA(RemoteTransportException.class)).     verify(rich[1], times(1)).onError(isA(RemoteTransportException.class)). }
false;public;2;6;;@Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {     ctx.channel().close(). }
false;public;0;14;;@Override public ChannelHandler[] getServerChannelHandlers() {     return new ChannelHandler[] { // Close on read     new ChannelInboundHandlerAdapter() {          @Override         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {             ctx.channel().close().         }     } }. }
false;public;1;5;;@Override public Void answer(InvocationOnMock invocation) throws Throwable {     sync.countDown().     return null. }
true;public;0;65;/**  * Verifies that unexpected remote closes are reported as an instance of  * {@link RemoteTransportException}.  */ ;/**  * Verifies that unexpected remote closes are reported as an instance of  * {@link RemoteTransportException}.  */ @Test public void testExceptionOnRemoteClose() throws Exception {     NettyProtocol protocol = new NettyProtocol(mock(ResultPartitionProvider.class), mock(TaskEventDispatcher.class), true) {          @Override         public ChannelHandler[] getServerChannelHandlers() {             return new ChannelHandler[] { // Close on read             new ChannelInboundHandlerAdapter() {                  @Override                 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {                     ctx.channel().close().                 }             } }.         }     }.     NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig()).     Channel ch = connect(serverAndClient).     NetworkClientHandler handler = getClientHandler(ch).     // Create input channels     RemoteInputChannel[] rich = new RemoteInputChannel[] { createRemoteInputChannel(), createRemoteInputChannel() }.     final CountDownLatch sync = new CountDownLatch(rich.length).     Answer<Void> countDownLatch = new Answer<Void>() {          @Override         public Void answer(InvocationOnMock invocation) throws Throwable {             sync.countDown().             return null.         }     }.     for (RemoteInputChannel r : rich) {         doAnswer(countDownLatch).when(r).onError(any(Throwable.class)).         handler.addInputChannel(r).     }     // Write something to trigger close by server     ch.writeAndFlush(Unpooled.buffer().writerIndex(16)).     // Wait for the notification     if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {         fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() + " ms to be notified about remote connection close.").     }     // All the registered channels should be notified.     for (RemoteInputChannel r : rich) {         verify(r).onError(isA(RemoteTransportException.class)).     }     shutdown(serverAndClient). }
true;public;0;31;/**  * Verifies that fired Exceptions are handled correctly by the pipeline.  */ ;/**  * Verifies that fired Exceptions are handled correctly by the pipeline.  */ @Test public void testExceptionCaught() throws Exception {     EmbeddedChannel ch = createEmbeddedChannel().     NetworkClientHandler handler = getClientHandler(ch).     // Create input channels     RemoteInputChannel[] rich = new RemoteInputChannel[] { createRemoteInputChannel(), createRemoteInputChannel() }.     for (RemoteInputChannel r : rich) {         when(r.getInputChannelId()).thenReturn(new InputChannelID()).         handler.addInputChannel(r).     }     ch.pipeline().fireExceptionCaught(new Exception()).     try {         // Exception should not reach end of pipeline...         ch.checkException().     } catch (Exception e) {         fail("The exception reached the end of the pipeline and " + "was not handled correctly by the last handler.").     }     // ...but all the registered channels should be notified.     for (RemoteInputChannel r : rich) {         verify(r).onError(isA(LocalTransportException.class)).     } }
false;public;1;17;;@Override public Void answer(InvocationOnMock invocation) throws Throwable {     Throwable cause = (Throwable) invocation.getArguments()[0].     try {         assertEquals(RemoteTransportException.class, cause.getClass()).         assertNotEquals("Connection reset by peer", cause.getMessage()).         assertEquals(IOException.class, cause.getCause().getClass()).         assertEquals("Connection reset by peer", cause.getCause().getMessage()).     } catch (Throwable t) {         error[0] = t.     }     return null. }
true;public;0;35;/**  * Verifies that "Connection reset by peer" Exceptions are special-cased and are reported as  * an instance of {@link RemoteTransportException}.  */ ;/**  * Verifies that "Connection reset by peer" Exceptions are special-cased and are reported as  * an instance of {@link RemoteTransportException}.  */ @Test public void testConnectionResetByPeer() throws Throwable {     EmbeddedChannel ch = createEmbeddedChannel().     NetworkClientHandler handler = getClientHandler(ch).     RemoteInputChannel rich = addInputChannel(handler).     final Throwable[] error = new Throwable[1].     // Verify the Exception     doAnswer(new Answer<Void>() {          @Override         public Void answer(InvocationOnMock invocation) throws Throwable {             Throwable cause = (Throwable) invocation.getArguments()[0].             try {                 assertEquals(RemoteTransportException.class, cause.getClass()).                 assertNotEquals("Connection reset by peer", cause.getMessage()).                 assertEquals(IOException.class, cause.getCause().getClass()).                 assertEquals("Connection reset by peer", cause.getCause().getMessage()).             } catch (Throwable t) {                 error[0] = t.             }             return null.         }     }).when(rich).onError(any(Throwable.class)).     ch.pipeline().fireExceptionCaught(new IOException("Connection reset by peer")).     assertNull(error[0]). }
true;public;0;15;/**  * Verifies that the channel is closed if there is an error *during* error notification.  */ ;/**  * Verifies that the channel is closed if there is an error *during* error notification.  */ @Test public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception {     EmbeddedChannel ch = createEmbeddedChannel().     NetworkClientHandler handler = getClientHandler(ch).     RemoteInputChannel rich = addInputChannel(handler).     doThrow(new RuntimeException("Expected test exception")).when(rich).onError(any(Throwable.class)).     ch.pipeline().fireExceptionCaught(new Exception()).     assertFalse(ch.isActive()). }
false;private;0;8;;// --------------------------------------------------------------------------------------------- // Helpers // --------------------------------------------------------------------------------------------- private EmbeddedChannel createEmbeddedChannel() {     NettyProtocol protocol = new NettyProtocol(mock(ResultPartitionProvider.class), mock(TaskEventDispatcher.class), true).     return new EmbeddedChannel(protocol.getClientChannelHandlers()). }
false;private;1;7;;private RemoteInputChannel addInputChannel(NetworkClientHandler clientHandler) throws IOException {     RemoteInputChannel rich = createRemoteInputChannel().     clientHandler.addInputChannel(rich).     return rich. }
false;private;1;3;;private NetworkClientHandler getClientHandler(Channel ch) {     return ch.pipeline().get(NetworkClientHandler.class). }
false;private;0;5;;private RemoteInputChannel createRemoteInputChannel() {     return when(mock(RemoteInputChannel.class).getInputChannelId()).thenReturn(new InputChannelID()).getMock(). }
