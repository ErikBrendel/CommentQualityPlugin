# id;timestamp;commentText;codeText;commentWords;codeWords
TaskCancelAsyncProducerConsumerITCase -> private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace);1459798010;Returns whether the stack trace represents a Thread in a blocking buffer_request.__@param stackTrace Stack trace of the Thread to check__@return Flag indicating whether the Thread is in a blocking buffer_request or not;private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace) {_		return stackTrace.length >= 3 && stackTrace[0].getMethodName().equals("wait") &&_				stackTrace[1].getMethodName().equals("requestBuffer") &&_				stackTrace[2].getMethodName().equals("requestBufferBlocking")__	};returns,whether,the,stack,trace,represents,a,thread,in,a,blocking,buffer,request,param,stack,trace,stack,trace,of,the,thread,to,check,return,flag,indicating,whether,the,thread,is,in,a,blocking,buffer,request,or,not;private,boolean,is,in,blocking,buffer,request,stack,trace,element,stack,trace,return,stack,trace,length,3,stack,trace,0,get,method,name,equals,wait,stack,trace,1,get,method,name,equals,request,buffer,stack,trace,2,get,method,name,equals,request,buffer,blocking
TaskCancelAsyncProducerConsumerITCase -> private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace);1463155298;Returns whether the stack trace represents a Thread in a blocking buffer_request.__@param stackTrace Stack trace of the Thread to check__@return Flag indicating whether the Thread is in a blocking buffer_request or not;private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace) {_		return stackTrace.length >= 3 && stackTrace[0].getMethodName().equals("wait") &&_				stackTrace[1].getMethodName().equals("requestBuffer") &&_				stackTrace[2].getMethodName().equals("requestBufferBlocking")__	};returns,whether,the,stack,trace,represents,a,thread,in,a,blocking,buffer,request,param,stack,trace,stack,trace,of,the,thread,to,check,return,flag,indicating,whether,the,thread,is,in,a,blocking,buffer,request,or,not;private,boolean,is,in,blocking,buffer,request,stack,trace,element,stack,trace,return,stack,trace,length,3,stack,trace,0,get,method,name,equals,wait,stack,trace,1,get,method,name,equals,request,buffer,stack,trace,2,get,method,name,equals,request,buffer,blocking
TaskCancelAsyncProducerConsumerITCase -> private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace);1480624969;Returns whether the stack trace represents a Thread in a blocking buffer_request.__@param stackTrace Stack trace of the Thread to check__@return Flag indicating whether the Thread is in a blocking buffer_request or not;private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace) {_		return stackTrace.length >= 3 && stackTrace[0].getMethodName().equals("wait") &&_				stackTrace[1].getMethodName().equals("requestBuffer") &&_				stackTrace[2].getMethodName().equals("requestBufferBlocking")__	};returns,whether,the,stack,trace,represents,a,thread,in,a,blocking,buffer,request,param,stack,trace,stack,trace,of,the,thread,to,check,return,flag,indicating,whether,the,thread,is,in,a,blocking,buffer,request,or,not;private,boolean,is,in,blocking,buffer,request,stack,trace,element,stack,trace,return,stack,trace,length,3,stack,trace,0,get,method,name,equals,wait,stack,trace,1,get,method,name,equals,request,buffer,stack,trace,2,get,method,name,equals,request,buffer,blocking
TaskCancelAsyncProducerConsumerITCase -> private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace);1489060856;Returns whether the stack trace represents a Thread in a blocking buffer_request.__@param stackTrace Stack trace of the Thread to check__@return Flag indicating whether the Thread is in a blocking buffer_request or not;private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace) {_		return stackTrace.length >= 3 && stackTrace[0].getMethodName().equals("wait") &&_				stackTrace[1].getMethodName().equals("requestBuffer") &&_				stackTrace[2].getMethodName().equals("requestBufferBlocking")__	};returns,whether,the,stack,trace,represents,a,thread,in,a,blocking,buffer,request,param,stack,trace,stack,trace,of,the,thread,to,check,return,flag,indicating,whether,the,thread,is,in,a,blocking,buffer,request,or,not;private,boolean,is,in,blocking,buffer,request,stack,trace,element,stack,trace,return,stack,trace,length,3,stack,trace,0,get,method,name,equals,wait,stack,trace,1,get,method,name,equals,request,buffer,stack,trace,2,get,method,name,equals,request,buffer,blocking
TaskCancelAsyncProducerConsumerITCase -> private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace);1491500150;Returns whether the stack trace represents a Thread in a blocking buffer_request.__@param stackTrace Stack trace of the Thread to check__@return Flag indicating whether the Thread is in a blocking buffer_request or not;private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace) {_		return stackTrace.length >= 3 && stackTrace[0].getMethodName().equals("wait") &&_				stackTrace[1].getMethodName().equals("requestBuffer") &&_				stackTrace[2].getMethodName().equals("requestBufferBlocking")__	};returns,whether,the,stack,trace,represents,a,thread,in,a,blocking,buffer,request,param,stack,trace,stack,trace,of,the,thread,to,check,return,flag,indicating,whether,the,thread,is,in,a,blocking,buffer,request,or,not;private,boolean,is,in,blocking,buffer,request,stack,trace,element,stack,trace,return,stack,trace,length,3,stack,trace,0,get,method,name,equals,wait,stack,trace,1,get,method,name,equals,request,buffer,stack,trace,2,get,method,name,equals,request,buffer,blocking
TaskCancelAsyncProducerConsumerITCase -> private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace);1498015994;Returns whether the stack trace represents a Thread in a blocking buffer_request.__@param stackTrace Stack trace of the Thread to check__@return Flag indicating whether the Thread is in a blocking buffer_request or not;private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace) {_		return stackTrace.length >= 3 && stackTrace[0].getMethodName().equals("wait") &&_				stackTrace[1].getMethodName().equals("requestBuffer") &&_				stackTrace[2].getMethodName().equals("requestBufferBlocking")__	};returns,whether,the,stack,trace,represents,a,thread,in,a,blocking,buffer,request,param,stack,trace,stack,trace,of,the,thread,to,check,return,flag,indicating,whether,the,thread,is,in,a,blocking,buffer,request,or,not;private,boolean,is,in,blocking,buffer,request,stack,trace,element,stack,trace,return,stack,trace,length,3,stack,trace,0,get,method,name,equals,wait,stack,trace,1,get,method,name,equals,request,buffer,stack,trace,2,get,method,name,equals,request,buffer,blocking
TaskCancelAsyncProducerConsumerITCase -> private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace);1509404699;Returns whether the stack trace represents a Thread in a blocking buffer_request.__@param stackTrace Stack trace of the Thread to check__@return Flag indicating whether the Thread is in a blocking buffer_request or not;private boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace) {_		return stackTrace.length >= 3 && stackTrace[0].getMethodName().equals("wait") &&_				stackTrace[1].getMethodName().equals("requestBuffer") &&_				stackTrace[2].getMethodName().equals("requestBufferBlocking")__	};returns,whether,the,stack,trace,represents,a,thread,in,a,blocking,buffer,request,param,stack,trace,stack,trace,of,the,thread,to,check,return,flag,indicating,whether,the,thread,is,in,a,blocking,buffer,request,or,not;private,boolean,is,in,blocking,buffer,request,stack,trace,element,stack,trace,return,stack,trace,length,3,stack,trace,0,get,method,name,equals,wait,stack,trace,1,get,method,name,equals,request,buffer,stack,trace,2,get,method,name,equals,request,buffer,blocking
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1459798010;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_MEMORY_SEGMENT_SIZE_KEY, 4096)__			config.setInteger(ConfigConstants.TASK_MANAGER_NETWORK_NUM_BUFFERS_KEY, 8)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(new ExecutionConfig(), producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500)__				}_			}__			_			assertTrue("Producer thread is not blocked.", producerBlocked)___			boolean consumerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					consumerBlocked = isInBlockingQueuePoll(stackTrace)__				}__				if (consumerBlocked) {_					break__				} else {_					_					Thread.sleep(500)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerBlocked)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.shutdown()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,config,constants,4096,config,set,integer,config,constants,8,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,new,execution,config,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500,assert,true,producer,thread,is,not,blocked,producer,blocked,boolean,consumer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,consumer,blocked,is,in,blocking,queue,poll,stack,trace,if,consumer,blocked,break,else,thread,sleep,500,assert,true,consumer,thread,is,not,blocked,consumer,blocked,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,shutdown
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1463155298;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_MEMORY_SEGMENT_SIZE_KEY, 4096)__			config.setInteger(ConfigConstants.TASK_MANAGER_NETWORK_NUM_BUFFERS_KEY, 8)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500)__				}_			}__			_			assertTrue("Producer thread is not blocked.", producerBlocked)___			boolean consumerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					consumerBlocked = isInBlockingQueuePoll(stackTrace)__				}__				if (consumerBlocked) {_					break__				} else {_					_					Thread.sleep(500)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerBlocked)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.shutdown()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,config,constants,4096,config,set,integer,config,constants,8,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500,assert,true,producer,thread,is,not,blocked,producer,blocked,boolean,consumer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,consumer,blocked,is,in,blocking,queue,poll,stack,trace,if,consumer,blocked,break,else,thread,sleep,500,assert,true,consumer,thread,is,not,blocked,consumer,blocked,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,shutdown
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1480624969;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_MEMORY_SEGMENT_SIZE_KEY, 4096)__			config.setInteger(ConfigConstants.TASK_MANAGER_NETWORK_NUM_BUFFERS_KEY, 8)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_CONSUMER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.shutdown()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,config,constants,4096,config,set,integer,config,constants,8,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500,assert,true,consumer,thread,is,not,blocked,consumer,waiting,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,shutdown
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1489060856;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_MEMORY_SEGMENT_SIZE_KEY, 4096)__			config.setInteger(ConfigConstants.TASK_MANAGER_NETWORK_NUM_BUFFERS_KEY, 8)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_CONSUMER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.shutdown()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,config,constants,4096,config,set,integer,config,constants,8,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500,assert,true,consumer,thread,is,not,blocked,consumer,waiting,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,shutdown
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1491500150;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(TaskManagerOptions.MEMORY_SEGMENT_SIZE, 4096)__			config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 8)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_CONSUMER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.shutdown()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,task,manager,options,4096,config,set,integer,task,manager,options,8,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500,assert,true,consumer,thread,is,not,blocked,consumer,waiting,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,shutdown
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1498015994;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(TaskManagerOptions.MEMORY_SEGMENT_SIZE, 4096)__			config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 8)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.shutdown()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,task,manager,options,4096,config,set,integer,task,manager,options,8,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,shutdown
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1509404699;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(TaskManagerOptions.MEMORY_SEGMENT_SIZE, 4096)__			config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 8)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.stop()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,task,manager,options,4096,config,set,integer,task,manager,options,8,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,stop
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1515408360;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(TaskManagerOptions.MEMORY_SEGMENT_SIZE, 4096)__			config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 8)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.stop()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,task,manager,options,4096,config,set,integer,task,manager,options,8,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,stop
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1515519059;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(TaskManagerOptions.MEMORY_SEGMENT_SIZE, 4096)__			config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 8)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.stop()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,task,manager,options,4096,config,set,integer,task,manager,options,8,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,stop
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1518785736;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(TaskManagerOptions.MEMORY_SEGMENT_SIZE, 4096)__			config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 9)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.stop()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,task,manager,options,4096,config,set,integer,task,manager,options,9,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,stop
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1519308961;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = new FiniteDuration(2, TimeUnit.MINUTES).fromNow()__		TestingCluster flink = null___		try {_			_			Configuration config = new Configuration()__			config.setInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1)__			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, 1)__			config.setInteger(TaskManagerOptions.MEMORY_SEGMENT_SIZE, 4096)__			config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 9)___			flink = new TestingCluster(config, true)__			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			ActorGateway jobManager = flink.getLeaderGateway(deadline.timeLeft())__			flink.submitJobDetached(jobGraph)___			Object msg = new WaitForAllVerticesToBeRunning(jobGraph.getJobID())__			Future<?> runningFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(runningFuture, deadline.timeLeft())___			_			msg = new NotifyWhenJobStatus(jobGraph.getJobID(), JobStatus.CANCELED)__			Future<?> cancelledFuture = jobManager.ask(msg, deadline.timeLeft())___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			msg = new CancelJob(jobGraph.getJobID())__			Future<?> cancelFuture = jobManager.ask(msg, deadline.timeLeft())__			Await.ready(cancelFuture, deadline.timeLeft())___			Await.ready(cancelledFuture, deadline.timeLeft())___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		} finally {_			if (flink != null) {_				flink.stop()__			}_		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,new,finite,duration,2,time,unit,minutes,from,now,testing,cluster,flink,null,try,configuration,config,new,configuration,config,set,integer,config,constants,1,config,set,integer,config,constants,1,config,set,integer,task,manager,options,4096,config,set,integer,task,manager,options,9,flink,new,testing,cluster,config,true,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,actor,gateway,job,manager,flink,get,leader,gateway,deadline,time,left,flink,submit,job,detached,job,graph,object,msg,new,wait,for,all,vertices,to,be,running,job,graph,get,job,id,future,running,future,job,manager,ask,msg,deadline,time,left,await,ready,running,future,deadline,time,left,msg,new,notify,when,job,status,job,graph,get,job,id,job,status,canceled,future,cancelled,future,job,manager,ask,msg,deadline,time,left,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,msg,new,cancel,job,job,graph,get,job,id,future,cancel,future,job,manager,ask,msg,deadline,time,left,await,ready,cancel,future,deadline,time,left,await,ready,cancelled,future,deadline,time,left,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class,finally,if,flink,null,flink,stop
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1521828709;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = Deadline.now().plus(Duration.ofMinutes(2))___		_		Configuration config = new Configuration()__		config.setInteger(TaskManagerOptions.MEMORY_SEGMENT_SIZE, 4096)__		config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 9)___		MiniClusterConfiguration miniClusterConfiguration = new MiniClusterConfiguration.Builder()_			.setConfiguration(config)_			.setNumTaskManagers(1)_			.setNumSlotsPerTaskManager(1)_			.build()___		try (MiniCluster flink = new MiniCluster(miniClusterConfiguration)) {_			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			flink.runDetached(jobGraph)___			FutureUtils.retrySuccesfulWithDelay(_				() -> flink.getJobStatus(jobGraph.getJobID()),_				Time.milliseconds(10),_				deadline,_				status -> status == JobStatus.RUNNING,_				TestingUtils.defaultScheduledExecutor()_			).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			flink.cancelJob(jobGraph.getJobID())_				.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			_			FutureUtils.retrySuccesfulWithDelay(_				() -> flink.getJobStatus(jobGraph.getJobID()),_				Time.milliseconds(10),_				deadline,_				status -> status == JobStatus.CANCELED,_				TestingUtils.defaultScheduledExecutor()_			).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,deadline,now,plus,duration,of,minutes,2,configuration,config,new,configuration,config,set,integer,task,manager,options,4096,config,set,integer,task,manager,options,9,mini,cluster,configuration,mini,cluster,configuration,new,mini,cluster,configuration,builder,set,configuration,config,set,num,task,managers,1,set,num,slots,per,task,manager,1,build,try,mini,cluster,flink,new,mini,cluster,mini,cluster,configuration,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,flink,run,detached,job,graph,future,utils,retry,succesful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,running,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,flink,cancel,job,job,graph,get,job,id,get,deadline,time,left,to,millis,time,unit,milliseconds,future,utils,retry,succesful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,canceled,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1522681180;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = Deadline.now().plus(Duration.ofMinutes(2))___		_		Configuration config = new Configuration()__		config.setInteger(TaskManagerOptions.MEMORY_SEGMENT_SIZE, 4096)__		config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 9)___		MiniClusterConfiguration miniClusterConfiguration = new MiniClusterConfiguration.Builder()_			.setConfiguration(config)_			.setNumTaskManagers(1)_			.setNumSlotsPerTaskManager(1)_			.build()___		try (MiniCluster flink = new MiniCluster(miniClusterConfiguration)) {_			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			flink.runDetached(jobGraph)___			FutureUtils.retrySuccesfulWithDelay(_				() -> flink.getJobStatus(jobGraph.getJobID()),_				Time.milliseconds(10),_				deadline,_				status -> status == JobStatus.RUNNING,_				TestingUtils.defaultScheduledExecutor()_			).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			flink.cancelJob(jobGraph.getJobID())_				.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			_			FutureUtils.retrySuccesfulWithDelay(_				() -> flink.getJobStatus(jobGraph.getJobID()),_				Time.milliseconds(10),_				deadline,_				status -> status == JobStatus.CANCELED,_				TestingUtils.defaultScheduledExecutor()_			).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,deadline,now,plus,duration,of,minutes,2,configuration,config,new,configuration,config,set,integer,task,manager,options,4096,config,set,integer,task,manager,options,9,mini,cluster,configuration,mini,cluster,configuration,new,mini,cluster,configuration,builder,set,configuration,config,set,num,task,managers,1,set,num,slots,per,task,manager,1,build,try,mini,cluster,flink,new,mini,cluster,mini,cluster,configuration,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,flink,run,detached,job,graph,future,utils,retry,succesful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,running,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,flink,cancel,job,job,graph,get,job,id,get,deadline,time,left,to,millis,time,unit,milliseconds,future,utils,retry,succesful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,canceled,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1526494919;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = Deadline.now().plus(Duration.ofMinutes(2))___		_		Configuration config = new Configuration()__		config.setInteger(TaskManagerOptions.MEMORY_SEGMENT_SIZE, 4096)__		config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 9)___		MiniClusterConfiguration miniClusterConfiguration = new MiniClusterConfiguration.Builder()_			.setConfiguration(config)_			.setNumTaskManagers(1)_			.setNumSlotsPerTaskManager(1)_			.build()___		try (MiniCluster flink = new MiniCluster(miniClusterConfiguration)) {_			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			flink.runDetached(jobGraph)___			FutureUtils.retrySuccesfulWithDelay(_				() -> flink.getJobStatus(jobGraph.getJobID()),_				Time.milliseconds(10),_				deadline,_				status -> status == JobStatus.RUNNING,_				TestingUtils.defaultScheduledExecutor()_			).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			flink.cancelJob(jobGraph.getJobID())_				.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			_			FutureUtils.retrySuccesfulWithDelay(_				() -> flink.getJobStatus(jobGraph.getJobID()),_				Time.milliseconds(10),_				deadline,_				status -> status == JobStatus.CANCELED,_				TestingUtils.defaultScheduledExecutor()_			).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,deadline,now,plus,duration,of,minutes,2,configuration,config,new,configuration,config,set,integer,task,manager,options,4096,config,set,integer,task,manager,options,9,mini,cluster,configuration,mini,cluster,configuration,new,mini,cluster,configuration,builder,set,configuration,config,set,num,task,managers,1,set,num,slots,per,task,manager,1,build,try,mini,cluster,flink,new,mini,cluster,mini,cluster,configuration,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,flink,run,detached,job,graph,future,utils,retry,succesful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,running,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,flink,cancel,job,job,graph,get,job,id,get,deadline,time,left,to,millis,time,unit,milliseconds,future,utils,retry,succesful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,canceled,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1530798894;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = Deadline.now().plus(Duration.ofMinutes(2))___		_		Configuration config = new Configuration()__		config.setString(TaskManagerOptions.MEMORY_SEGMENT_SIZE, "4096")__		config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 9)___		MiniClusterConfiguration miniClusterConfiguration = new MiniClusterConfiguration.Builder()_			.setConfiguration(config)_			.setNumTaskManagers(1)_			.setNumSlotsPerTaskManager(1)_			.build()___		try (MiniCluster flink = new MiniCluster(miniClusterConfiguration)) {_			flink.start()___			_			JobVertex producer = new JobVertex("AsyncProducer")__			producer.setParallelism(1)__			producer.setInvokableClass(AsyncProducer.class)___			JobVertex consumer = new JobVertex("AsyncConsumer")__			consumer.setParallelism(1)__			consumer.setInvokableClass(AsyncConsumer.class)__			consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___			SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__			producer.setSlotSharingGroup(slot)__			consumer.setSlotSharingGroup(slot)___			JobGraph jobGraph = new JobGraph(producer, consumer)___			_			flink.runDetached(jobGraph)___			FutureUtils.retrySuccesfulWithDelay(_				() -> flink.getJobStatus(jobGraph.getJobID()),_				Time.milliseconds(10),_				deadline,_				status -> status == JobStatus.RUNNING,_				TestingUtils.defaultScheduledExecutor()_			).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			boolean producerBlocked = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_PRODUCER_THREAD___				if (thread != null && thread.isAlive()) {_					StackTraceElement[] stackTrace = thread.getStackTrace()__					producerBlocked = isInBlockingBufferRequest(stackTrace)__				}__				if (producerBlocked) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___			boolean consumerWaiting = false__			for (int i = 0_ i < 50_ i++) {_				Thread thread = ASYNC_CONSUMER_THREAD___				if (thread != null && thread.isAlive()) {_					consumerWaiting = thread.getState() == Thread.State.WAITING__				}__				if (consumerWaiting) {_					break__				} else {_					_					Thread.sleep(500L)__				}_			}__			_			assertTrue("Consumer thread is not blocked.", consumerWaiting)___			flink.cancelJob(jobGraph.getJobID())_				.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			_			FutureUtils.retrySuccesfulWithDelay(_				() -> flink.getJobStatus(jobGraph.getJobID()),_				Time.milliseconds(10),_				deadline,_				status -> status == JobStatus.CANCELED,_				TestingUtils.defaultScheduledExecutor()_			).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___			_			assertNotNull(ASYNC_PRODUCER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___			assertNotNull(ASYNC_CONSUMER_EXCEPTION)__			assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__		}_	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,deadline,now,plus,duration,of,minutes,2,configuration,config,new,configuration,config,set,string,task,manager,options,4096,config,set,integer,task,manager,options,9,mini,cluster,configuration,mini,cluster,configuration,new,mini,cluster,configuration,builder,set,configuration,config,set,num,task,managers,1,set,num,slots,per,task,manager,1,build,try,mini,cluster,flink,new,mini,cluster,mini,cluster,configuration,flink,start,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,flink,run,detached,job,graph,future,utils,retry,succesful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,running,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,flink,cancel,job,job,graph,get,job,id,get,deadline,time,left,to,millis,time,unit,milliseconds,future,utils,retry,succesful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,canceled,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1540389860;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = Deadline.now().plus(Duration.ofMinutes(2))___		_		JobVertex producer = new JobVertex("AsyncProducer")__		producer.setParallelism(1)__		producer.setInvokableClass(AsyncProducer.class)___		JobVertex consumer = new JobVertex("AsyncConsumer")__		consumer.setParallelism(1)__		consumer.setInvokableClass(AsyncConsumer.class)__		consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__		producer.setSlotSharingGroup(slot)__		consumer.setSlotSharingGroup(slot)___		JobGraph jobGraph = new JobGraph(producer, consumer)___		final MiniCluster flink = MINI_CLUSTER_RESOURCE.getMiniCluster()___		_		flink.runDetached(jobGraph)___		FutureUtils.retrySuccesfulWithDelay(_			() -> flink.getJobStatus(jobGraph.getJobID()),_			Time.milliseconds(10),_			deadline,_			status -> status == JobStatus.RUNNING,_			TestingUtils.defaultScheduledExecutor()_		).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		boolean producerBlocked = false__		for (int i = 0_ i < 50_ i++) {_			Thread thread = ASYNC_PRODUCER_THREAD___			if (thread != null && thread.isAlive()) {_				StackTraceElement[] stackTrace = thread.getStackTrace()__				producerBlocked = isInBlockingBufferRequest(stackTrace)__			}__			if (producerBlocked) {_				break__			} else {_				_				Thread.sleep(500L)__			}_		}__		_		assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___		boolean consumerWaiting = false__		for (int i = 0_ i < 50_ i++) {_			Thread thread = ASYNC_CONSUMER_THREAD___			if (thread != null && thread.isAlive()) {_				consumerWaiting = thread.getState() == Thread.State.WAITING__			}__			if (consumerWaiting) {_				break__			} else {_				_				Thread.sleep(500L)__			}_		}__		_		assertTrue("Consumer thread is not blocked.", consumerWaiting)___		flink.cancelJob(jobGraph.getJobID())_			.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		FutureUtils.retrySuccesfulWithDelay(_			() -> flink.getJobStatus(jobGraph.getJobID()),_			Time.milliseconds(10),_			deadline,_			status -> status == JobStatus.CANCELED,_			TestingUtils.defaultScheduledExecutor()_		).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		assertNotNull(ASYNC_PRODUCER_EXCEPTION)__		assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___		assertNotNull(ASYNC_CONSUMER_EXCEPTION)__		assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,deadline,now,plus,duration,of,minutes,2,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,final,mini,cluster,flink,get,mini,cluster,flink,run,detached,job,graph,future,utils,retry,succesful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,running,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,flink,cancel,job,job,graph,get,job,id,get,deadline,time,left,to,millis,time,unit,milliseconds,future,utils,retry,succesful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,canceled,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class
TaskCancelAsyncProducerConsumerITCase -> @Test 	public void testCancelAsyncProducerAndConsumer() throws Exception;1542282018;Tests that a task waiting on an async producer/consumer that is stuck_in a blocking buffer request can be properly cancelled.__<p>This is currently required for the Flink Kafka sources, which spawn_a separate Thread consuming from Kafka and producing the intermediate_streams in the spawned Thread instead of the main task Thread.;@Test_	public void testCancelAsyncProducerAndConsumer() throws Exception {_		Deadline deadline = Deadline.now().plus(Duration.ofMinutes(2))___		_		JobVertex producer = new JobVertex("AsyncProducer")__		producer.setParallelism(1)__		producer.setInvokableClass(AsyncProducer.class)___		JobVertex consumer = new JobVertex("AsyncConsumer")__		consumer.setParallelism(1)__		consumer.setInvokableClass(AsyncConsumer.class)__		consumer.connectNewDataSetAsInput(producer, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		SlotSharingGroup slot = new SlotSharingGroup(producer.getID(), consumer.getID())__		producer.setSlotSharingGroup(slot)__		consumer.setSlotSharingGroup(slot)___		JobGraph jobGraph = new JobGraph(producer, consumer)___		final MiniCluster flink = MINI_CLUSTER_RESOURCE.getMiniCluster()___		_		flink.runDetached(jobGraph)___		FutureUtils.retrySuccessfulWithDelay(_			() -> flink.getJobStatus(jobGraph.getJobID()),_			Time.milliseconds(10),_			deadline,_			status -> status == JobStatus.RUNNING,_			TestingUtils.defaultScheduledExecutor()_		).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		boolean producerBlocked = false__		for (int i = 0_ i < 50_ i++) {_			Thread thread = ASYNC_PRODUCER_THREAD___			if (thread != null && thread.isAlive()) {_				StackTraceElement[] stackTrace = thread.getStackTrace()__				producerBlocked = isInBlockingBufferRequest(stackTrace)__			}__			if (producerBlocked) {_				break__			} else {_				_				Thread.sleep(500L)__			}_		}__		_		assertTrue("Producer thread is not blocked: " + Arrays.toString(ASYNC_PRODUCER_THREAD.getStackTrace()), producerBlocked)___		boolean consumerWaiting = false__		for (int i = 0_ i < 50_ i++) {_			Thread thread = ASYNC_CONSUMER_THREAD___			if (thread != null && thread.isAlive()) {_				consumerWaiting = thread.getState() == Thread.State.WAITING__			}__			if (consumerWaiting) {_				break__			} else {_				_				Thread.sleep(500L)__			}_		}__		_		assertTrue("Consumer thread is not blocked.", consumerWaiting)___		flink.cancelJob(jobGraph.getJobID())_			.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		FutureUtils.retrySuccessfulWithDelay(_			() -> flink.getJobStatus(jobGraph.getJobID()),_			Time.milliseconds(10),_			deadline,_			status -> status == JobStatus.CANCELED,_			TestingUtils.defaultScheduledExecutor()_		).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS)___		_		assertNotNull(ASYNC_PRODUCER_EXCEPTION)__		assertEquals(IllegalStateException.class, ASYNC_PRODUCER_EXCEPTION.getClass())___		assertNotNull(ASYNC_CONSUMER_EXCEPTION)__		assertEquals(IllegalStateException.class, ASYNC_CONSUMER_EXCEPTION.getClass())__	};tests,that,a,task,waiting,on,an,async,producer,consumer,that,is,stuck,in,a,blocking,buffer,request,can,be,properly,cancelled,p,this,is,currently,required,for,the,flink,kafka,sources,which,spawn,a,separate,thread,consuming,from,kafka,and,producing,the,intermediate,streams,in,the,spawned,thread,instead,of,the,main,task,thread;test,public,void,test,cancel,async,producer,and,consumer,throws,exception,deadline,deadline,deadline,now,plus,duration,of,minutes,2,job,vertex,producer,new,job,vertex,async,producer,producer,set,parallelism,1,producer,set,invokable,class,async,producer,class,job,vertex,consumer,new,job,vertex,async,consumer,consumer,set,parallelism,1,consumer,set,invokable,class,async,consumer,class,consumer,connect,new,data,set,as,input,producer,distribution,pattern,pointwise,result,partition,type,pipelined,slot,sharing,group,slot,new,slot,sharing,group,producer,get,id,consumer,get,id,producer,set,slot,sharing,group,slot,consumer,set,slot,sharing,group,slot,job,graph,job,graph,new,job,graph,producer,consumer,final,mini,cluster,flink,get,mini,cluster,flink,run,detached,job,graph,future,utils,retry,successful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,running,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,boolean,producer,blocked,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,stack,trace,element,stack,trace,thread,get,stack,trace,producer,blocked,is,in,blocking,buffer,request,stack,trace,if,producer,blocked,break,else,thread,sleep,500l,assert,true,producer,thread,is,not,blocked,arrays,to,string,get,stack,trace,producer,blocked,boolean,consumer,waiting,false,for,int,i,0,i,50,i,thread,thread,if,thread,null,thread,is,alive,consumer,waiting,thread,get,state,thread,state,waiting,if,consumer,waiting,break,else,thread,sleep,500l,assert,true,consumer,thread,is,not,blocked,consumer,waiting,flink,cancel,job,job,graph,get,job,id,get,deadline,time,left,to,millis,time,unit,milliseconds,future,utils,retry,successful,with,delay,flink,get,job,status,job,graph,get,job,id,time,milliseconds,10,deadline,status,status,job,status,canceled,testing,utils,default,scheduled,executor,get,deadline,time,left,to,millis,time,unit,milliseconds,assert,not,null,assert,equals,illegal,state,exception,class,get,class,assert,not,null,assert,equals,illegal,state,exception,class,get,class
TaskCancelAsyncProducerConsumerITCase -> private boolean isInBlockingQueuePoll(StackTraceElement[] stackTrace);1459798010;Returns whether the stack trace represents a Thread in a blocking queue_poll call.__@param stackTrace Stack trace of the Thread to check__@return Flag indicating whether the Thread is in a blocking queue poll_call.;private boolean isInBlockingQueuePoll(StackTraceElement[] stackTrace) {_		for (StackTraceElement elem : stackTrace) {_			if (elem.getMethodName().equals("poll") &&_					elem.getClassName().equals("java.util.concurrent.LinkedBlockingQueue")) {__				return true__			}_		}__		return false__	};returns,whether,the,stack,trace,represents,a,thread,in,a,blocking,queue,poll,call,param,stack,trace,stack,trace,of,the,thread,to,check,return,flag,indicating,whether,the,thread,is,in,a,blocking,queue,poll,call;private,boolean,is,in,blocking,queue,poll,stack,trace,element,stack,trace,for,stack,trace,element,elem,stack,trace,if,elem,get,method,name,equals,poll,elem,get,class,name,equals,java,util,concurrent,linked,blocking,queue,return,true,return,false
TaskCancelAsyncProducerConsumerITCase -> private boolean isInBlockingQueuePoll(StackTraceElement[] stackTrace);1463155298;Returns whether the stack trace represents a Thread in a blocking queue_poll call.__@param stackTrace Stack trace of the Thread to check__@return Flag indicating whether the Thread is in a blocking queue poll_call.;private boolean isInBlockingQueuePoll(StackTraceElement[] stackTrace) {_		for (StackTraceElement elem : stackTrace) {_			if (elem.getMethodName().equals("poll") &&_					elem.getClassName().equals("java.util.concurrent.LinkedBlockingQueue")) {__				return true__			}_		}__		return false__	};returns,whether,the,stack,trace,represents,a,thread,in,a,blocking,queue,poll,call,param,stack,trace,stack,trace,of,the,thread,to,check,return,flag,indicating,whether,the,thread,is,in,a,blocking,queue,poll,call;private,boolean,is,in,blocking,queue,poll,stack,trace,element,stack,trace,for,stack,trace,element,elem,stack,trace,if,elem,get,method,name,equals,poll,elem,get,class,name,equals,java,util,concurrent,linked,blocking,queue,return,true,return,false
