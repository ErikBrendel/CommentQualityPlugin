commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test public void testGetTransientFailsDuringLookup1() throws IOException {     testGetFailsDuringLookup(null, new JobID(), TRANSIENT_BLOB). }
false;public;0;4;;@Test public void testGetTransientFailsDuringLookup2() throws IOException {     testGetFailsDuringLookup(new JobID(), new JobID(), TRANSIENT_BLOB). }
false;public;0;4;;@Test public void testGetTransientFailsDuringLookup3() throws IOException {     testGetFailsDuringLookup(new JobID(), null, TRANSIENT_BLOB). }
false;public;0;4;;@Test public void testGetPermanentFailsDuringLookup() throws IOException {     testGetFailsDuringLookup(new JobID(), new JobID(), PERMANENT_BLOB). }
true;private;3;40;/**  * Checks the correct result if a GET operation fails during the lookup of the file.  *  * @param jobId1 first job ID or <tt>null</tt> if job-unrelated  * @param jobId2 second job ID different to <tt>jobId1</tt>  * @param blobType  * 		whether the BLOB should become permanent or transient  */ ;/**  * Checks the correct result if a GET operation fails during the lookup of the file.  *  * @param jobId1 first job ID or <tt>null</tt> if job-unrelated  * @param jobId2 second job ID different to <tt>jobId1</tt>  * @param blobType  * 		whether the BLOB should become permanent or transient  */ private void testGetFailsDuringLookup(@Nullable final JobID jobId1, @Nullable final JobID jobId2, BlobKey.BlobType blobType) throws IOException {     final Configuration config = new Configuration().     config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath()).     try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {         server.start().         byte[] data = new byte[2000000].         rnd.nextBytes(data).         // put content addressable (like libraries)         BlobKey key = put(server, jobId1, data, blobType).         assertNotNull(key).         // delete file to make sure that GET requests fail         File blobFile = server.getStorageLocation(jobId1, key).         assertTrue(blobFile.delete()).         // issue a GET request that fails         verifyDeleted(server, jobId1, key).         // add the same data under a second jobId         BlobKey key2 = put(server, jobId2, data, blobType).         assertNotNull(key2).         verifyKeyDifferentHashEquals(key, key2).         // request for jobId2 should succeed         get(server, jobId2, key2).         // request for jobId1 should still fail         verifyDeleted(server, jobId1, key).         // same checks as for jobId1 but for jobId2 should also work:         blobFile = server.getStorageLocation(jobId2, key2).         assertTrue(blobFile.delete()).         verifyDeleted(server, jobId2, key2).     } }
true;public;0;66;/**  * Retrieves a BLOB from the HA store to a {@link BlobServer} which cannot create incoming  * files. File transfers should fail.  */ ;/**  * Retrieves a BLOB from the HA store to a {@link BlobServer} which cannot create incoming  * files. File transfers should fail.  */ @Test public void testGetFailsIncomingForJobHa() throws IOException {     // setWritable doesn't work on Windows.     assumeTrue(!OperatingSystem.isWindows()).     final JobID jobId = new JobID().     final Configuration config = new Configuration().     config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER").     config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath()).     config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.newFolder().getPath()).     BlobStoreService blobStore = null.     try {         blobStore = BlobUtils.createBlobStoreFromConfig(config).         File tempFileDir = null.         try (BlobServer server = new BlobServer(config, blobStore)) {             server.start().             // store the data on the server (and blobStore), remove from local store             byte[] data = new byte[2000000].             rnd.nextBytes(data).             BlobKey blobKey = put(server, jobId, data, PERMANENT_BLOB).             assertTrue(server.getStorageLocation(jobId, blobKey).delete()).             // make sure the blob server cannot create any files in its storage dir             tempFileDir = server.createTemporaryFilename().getParentFile().             assertTrue(tempFileDir.setExecutable(true, false)).             assertTrue(tempFileDir.setReadable(true, false)).             assertTrue(tempFileDir.setWritable(false, false)).             // request the file from the BlobStore             exception.expect(IOException.class).             exception.expectMessage("Permission denied").             try {                 get(server, jobId, blobKey).             } finally {                 HashSet<String> expectedDirs = new HashSet<>().                 expectedDirs.add("incoming").                 expectedDirs.add(JOB_DIR_PREFIX + jobId).                 // only the incoming and job directory should exist (no job directory!)                 File storageDir = tempFileDir.getParentFile().                 String[] actualDirs = storageDir.list().                 assertNotNull(actualDirs).                 assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs))).                 // job directory should be empty                 File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId).                 assertArrayEquals(new String[] {}, jobDir.list()).             }         } finally {             // set writable again to make sure we can remove the directory             if (tempFileDir != null) {                 // noinspection ResultOfMethodCallIgnored                 tempFileDir.setWritable(true, false).             }         }     } finally {         if (blobStore != null) {             blobStore.closeAndCleanupAllData().         }     } }
true;public;0;59;/**  * Retrieves a BLOB from the HA store to a {@link BlobServer} which cannot create the final  * storage file. File transfers should fail.  */ ;/**  * Retrieves a BLOB from the HA store to a {@link BlobServer} which cannot create the final  * storage file. File transfers should fail.  */ @Test public void testGetFailsStoreForJobHa() throws IOException {     // setWritable doesn't work on Windows.     assumeTrue(!OperatingSystem.isWindows()).     final JobID jobId = new JobID().     final Configuration config = new Configuration().     config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER").     config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath()).     config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.newFolder().getPath()).     BlobStoreService blobStore = null.     try {         blobStore = BlobUtils.createBlobStoreFromConfig(config).         File jobStoreDir = null.         try (BlobServer server = new BlobServer(config, blobStore)) {             server.start().             // store the data on the server (and blobStore), remove from local store             byte[] data = new byte[2000000].             rnd.nextBytes(data).             BlobKey blobKey = put(server, jobId, data, PERMANENT_BLOB).             assertTrue(server.getStorageLocation(jobId, blobKey).delete()).             // make sure the blob cache cannot create any files in its storage dir             jobStoreDir = server.getStorageLocation(jobId, blobKey).getParentFile().             assertTrue(jobStoreDir.setExecutable(true, false)).             assertTrue(jobStoreDir.setReadable(true, false)).             assertTrue(jobStoreDir.setWritable(false, false)).             // request the file from the BlobStore             exception.expect(AccessDeniedException.class).             try {                 get(server, jobId, blobKey).             } finally {                 // there should be no remaining incoming files                 File incomingFileDir = new File(jobStoreDir.getParent(), "incoming").                 assertArrayEquals(new String[] {}, incomingFileDir.list()).                 // there should be no files in the job directory                 assertArrayEquals(new String[] {}, jobStoreDir.list()).             }         } finally {             // set writable again to make sure we can remove the directory             if (jobStoreDir != null) {                 // noinspection ResultOfMethodCallIgnored                 jobStoreDir.setWritable(true, false).             }         }     } finally {         if (blobStore != null) {             blobStore.closeAndCleanupAllData().         }     } }
true;public;0;40;/**  * Retrieves a BLOB from the HA store to a {@link BlobServer} whose HA store does not contain  * the file. File transfers should fail.  */ ;/**  * Retrieves a BLOB from the HA store to a {@link BlobServer} whose HA store does not contain  * the file. File transfers should fail.  */ @Test public void testGetFailsHaStoreForJobHa() throws IOException {     final JobID jobId = new JobID().     final Configuration config = new Configuration().     config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath()).     try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {         server.start().         // store the data on the server (and blobStore), remove from local store         byte[] data = new byte[2000000].         rnd.nextBytes(data).         BlobKey blobKey = put(server, jobId, data, PERMANENT_BLOB).         assertTrue(server.getStorageLocation(jobId, blobKey).delete()).         File tempFileDir = server.createTemporaryFilename().getParentFile().         // request the file from the BlobStore         exception.expect(NoSuchFileException.class).         try {             get(server, jobId, blobKey).         } finally {             HashSet<String> expectedDirs = new HashSet<>().             expectedDirs.add("incoming").             expectedDirs.add(JOB_DIR_PREFIX + jobId).             // only the incoming and job directory should exist (no job directory!)             File storageDir = tempFileDir.getParentFile().             String[] actualDirs = storageDir.list().             assertNotNull(actualDirs).             assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs))).             // job directory should be empty             File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId).             assertArrayEquals(new String[] {}, jobDir.list()).         }     } }
false;public;0;4;;@Test public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException {     testConcurrentGetOperations(null, TRANSIENT_BLOB). }
false;public;0;4;;@Test public void testConcurrentGetOperationsForJob() throws IOException, ExecutionException, InterruptedException {     testConcurrentGetOperations(new JobID(), TRANSIENT_BLOB). }
false;public;0;4;;@Test public void testConcurrentGetOperationsForJobHa() throws IOException, ExecutionException, InterruptedException {     testConcurrentGetOperations(new JobID(), PERMANENT_BLOB). }
false;public;1;8;;@Override public Object answer(InvocationOnMock invocation) throws Throwable {     File targetFile = (File) invocation.getArguments()[2].     FileUtils.writeByteArrayToFile(targetFile, data).     return null. }
true;private;2;64;/**  * [FLINK-6020] Tests that concurrent get operations don't concurrently access the BlobStore to  * download a blob.  *  * @param jobId  * 		job ID to use (or <tt>null</tt> if job-unrelated)  * @param blobType  * 		whether the BLOB should become permanent or transient  */ ;/**  * [FLINK-6020] Tests that concurrent get operations don't concurrently access the BlobStore to  * download a blob.  *  * @param jobId  * 		job ID to use (or <tt>null</tt> if job-unrelated)  * @param blobType  * 		whether the BLOB should become permanent or transient  */ private void testConcurrentGetOperations(@Nullable final JobID jobId, final BlobKey.BlobType blobType) throws IOException, InterruptedException, ExecutionException {     final Configuration config = new Configuration().     config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath()).     final BlobStore blobStore = mock(BlobStore.class).     final int numberConcurrentGetOperations = 3.     final List<CompletableFuture<File>> getOperations = new ArrayList<>(numberConcurrentGetOperations).     final byte[] data = { 1, 2, 3, 4, 99, 42 }.     doAnswer(new Answer() {          @Override         public Object answer(InvocationOnMock invocation) throws Throwable {             File targetFile = (File) invocation.getArguments()[2].             FileUtils.writeByteArrayToFile(targetFile, data).             return null.         }     }).when(blobStore).get(any(JobID.class), any(BlobKey.class), any(File.class)).     final ExecutorService executor = Executors.newFixedThreadPool(numberConcurrentGetOperations).     try (final BlobServer server = new BlobServer(config, blobStore)) {         server.start().         // upload data first         final BlobKey blobKey = put(server, jobId, data, blobType).         // now try accessing it concurrently (only HA mode will be able to retrieve it from HA store!)         if (blobType == PERMANENT_BLOB) {             // remove local copy so that a transfer from HA store takes place             assertTrue(server.getStorageLocation(jobId, blobKey).delete()).         }         for (int i = 0. i < numberConcurrentGetOperations. i++) {             CompletableFuture<File> getOperation = CompletableFuture.supplyAsync(() -> {                 try {                     File file = get(server, jobId, blobKey).                     // check that we have read the right data                     validateGetAndClose(new FileInputStream(file), data).                     return file.                 } catch (IOException e) {                     throw new CompletionException(new FlinkException("Could not read blob for key " + blobKey + '.', e)).                 }             }, executor).             getOperations.add(getOperation).         }         CompletableFuture<Collection<File>> filesFuture = FutureUtils.combineAll(getOperations).         filesFuture.get().     } finally {         executor.shutdownNow().     } }
true;static;3;9;/**  * Retrieves the given blob.  *  * <p>Note that if a {@link BlobCacheService} is used, it may try to access the {@link  * BlobServer} to retrieve the blob.  *  * @param service  * 		BLOB client to use for connecting to the BLOB service  * @param jobId  * 		job ID or <tt>null</tt> if job-unrelated  * @param key  * 		key identifying the BLOB to request  */ ;/**  * Retrieves the given blob.  *  * <p>Note that if a {@link BlobCacheService} is used, it may try to access the {@link  * BlobServer} to retrieve the blob.  *  * @param service  * 		BLOB client to use for connecting to the BLOB service  * @param jobId  * 		job ID or <tt>null</tt> if job-unrelated  * @param key  * 		key identifying the BLOB to request  */ static File get(BlobService service, @Nullable JobID jobId, BlobKey key) throws IOException {     if (key instanceof PermanentBlobKey) {         return service.getPermanentBlobService().getFile(jobId, (PermanentBlobKey) key).     } else if (jobId == null) {         return service.getTransientBlobService().getFile((TransientBlobKey) key).     } else {         return service.getTransientBlobService().getFile(jobId, (TransientBlobKey) key).     } }
true;static;3;9;/**  * Checks that the given blob does not exist anymore by trying to access it.  *  * <p>Note that if a {@link BlobCacheService} is used, it may try to access the {@link  * BlobServer} to retrieve the blob.  *  * @param service  * 		BLOB client to use for connecting to the BLOB service  * @param jobId  * 		job ID or <tt>null</tt> if job-unrelated  * @param key  * 		key identifying the BLOB to request  */ ;/**  * Checks that the given blob does not exist anymore by trying to access it.  *  * <p>Note that if a {@link BlobCacheService} is used, it may try to access the {@link  * BlobServer} to retrieve the blob.  *  * @param service  * 		BLOB client to use for connecting to the BLOB service  * @param jobId  * 		job ID or <tt>null</tt> if job-unrelated  * @param key  * 		key identifying the BLOB to request  */ static void verifyDeleted(BlobService service, @Nullable JobID jobId, BlobKey key) throws IOException {     try {         get(service, jobId, key).         fail("File " + jobId + "/" + key + " should have been deleted.").     } catch (IOException e) {     // expected     } }
