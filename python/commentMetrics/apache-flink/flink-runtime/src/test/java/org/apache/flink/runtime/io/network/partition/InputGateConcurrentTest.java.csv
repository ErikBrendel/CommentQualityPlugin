commented;modifiers;parameterAmount;loc;comment;code
false;public;0;39;;@Test public void testConsumptionWithLocalChannels() throws Exception {     final int numberOfChannels = 11.     final int buffersPerChannel = 1000.     final ResultPartition resultPartition = mock(ResultPartition.class).     final PipelinedSubpartition[] partitions = new PipelinedSubpartition[numberOfChannels].     final Source[] sources = new Source[numberOfChannels].     final ResultPartitionManager resultPartitionManager = createResultPartitionManager(partitions).     final SingleInputGate gate = new SingleInputGate("Test Task Name", new JobID(), new IntermediateDataSetID(), ResultPartitionType.PIPELINED, 0, numberOfChannels, mock(TaskActions.class), UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup(), true).     for (int i = 0. i < numberOfChannels. i++) {         LocalInputChannel channel = new LocalInputChannel(gate, i, new ResultPartitionID(), resultPartitionManager, mock(TaskEventDispatcher.class), UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup()).         gate.setInputChannel(new IntermediateResultPartitionID(), channel).         partitions[i] = new PipelinedSubpartition(0, resultPartition).         sources[i] = new PipelinedSubpartitionSource(partitions[i]).     }     ProducerThread producer = new ProducerThread(sources, numberOfChannels * buffersPerChannel, 4, 10).     ConsumerThread consumer = new ConsumerThread(gate, numberOfChannels * buffersPerChannel).     producer.start().     consumer.start().     // the 'sync()' call checks for exceptions and failed assertions     producer.sync().     consumer.sync(). }
false;public;0;36;;@Test public void testConsumptionWithRemoteChannels() throws Exception {     final int numberOfChannels = 11.     final int buffersPerChannel = 1000.     final ConnectionManager connManager = createDummyConnectionManager().     final Source[] sources = new Source[numberOfChannels].     final SingleInputGate gate = new SingleInputGate("Test Task Name", new JobID(), new IntermediateDataSetID(), ResultPartitionType.PIPELINED, 0, numberOfChannels, mock(TaskActions.class), UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup(), true).     for (int i = 0. i < numberOfChannels. i++) {         RemoteInputChannel channel = new RemoteInputChannel(gate, i, new ResultPartitionID(), mock(ConnectionID.class), connManager, 0, 0, UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup()).         gate.setInputChannel(new IntermediateResultPartitionID(), channel).         sources[i] = new RemoteChannelSource(channel).     }     ProducerThread producer = new ProducerThread(sources, numberOfChannels * buffersPerChannel, 4, 10).     ConsumerThread consumer = new ConsumerThread(gate, numberOfChannels * buffersPerChannel).     producer.start().     consumer.start().     // the 'sync()' call checks for exceptions and failed assertions     producer.sync().     consumer.sync(). }
false;public;0;62;;@Test public void testConsumptionWithMixedChannels() throws Exception {     final int numberOfChannels = 61.     final int numLocalChannels = 20.     final int buffersPerChannel = 1000.     // fill the local/remote decision     List<Boolean> localOrRemote = new ArrayList<>(numberOfChannels).     for (int i = 0. i < numberOfChannels. i++) {         localOrRemote.add(i < numLocalChannels).     }     Collections.shuffle(localOrRemote).     final ConnectionManager connManager = createDummyConnectionManager().     final ResultPartition resultPartition = mock(ResultPartition.class).     final PipelinedSubpartition[] localPartitions = new PipelinedSubpartition[numLocalChannels].     final ResultPartitionManager resultPartitionManager = createResultPartitionManager(localPartitions).     final Source[] sources = new Source[numberOfChannels].     final SingleInputGate gate = new SingleInputGate("Test Task Name", new JobID(), new IntermediateDataSetID(), ResultPartitionType.PIPELINED, 0, numberOfChannels, mock(TaskActions.class), UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup(), true).     for (int i = 0, local = 0. i < numberOfChannels. i++) {         if (localOrRemote.get(i)) {             // local channel             PipelinedSubpartition psp = new PipelinedSubpartition(0, resultPartition).             localPartitions[local++] = psp.             sources[i] = new PipelinedSubpartitionSource(psp).             LocalInputChannel channel = new LocalInputChannel(gate, i, new ResultPartitionID(), resultPartitionManager, mock(TaskEventDispatcher.class), UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup()).             gate.setInputChannel(new IntermediateResultPartitionID(), channel).         } else {             // remote channel             RemoteInputChannel channel = new RemoteInputChannel(gate, i, new ResultPartitionID(), mock(ConnectionID.class), connManager, 0, 0, UnregisteredMetricGroups.createUnregisteredTaskMetricGroup().getIOMetricGroup()).             gate.setInputChannel(new IntermediateResultPartitionID(), channel).             sources[i] = new RemoteChannelSource(channel).         }     }     ProducerThread producer = new ProducerThread(sources, numberOfChannels * buffersPerChannel, 4, 10).     ConsumerThread consumer = new ConsumerThread(gate, numberOfChannels * buffersPerChannel).     producer.start().     consumer.start().     // the 'sync()' call checks for exceptions and failed assertions     producer.sync().     consumer.sync(). }
false;abstract;1;1;;abstract void addBufferConsumer(BufferConsumer bufferConsumer) throws Exception.
false;abstract;0;1;;abstract void flush().
false;;1;4;;@Override void addBufferConsumer(BufferConsumer bufferConsumer) throws Exception {     partition.add(bufferConsumer). }
false;;0;4;;@Override void flush() {     partition.flush(). }
false;;1;11;;@Override void addBufferConsumer(BufferConsumer bufferConsumer) throws Exception {     try {         Buffer buffer = bufferConsumer.build().         checkState(bufferConsumer.isFinished(), "Handling of non finished buffers is not yet implemented").         channel.onBuffer(buffer, seq++, -1).     } finally {         bufferConsumer.close().     } }
false;;0;3;;@Override void flush() { }
false;public;0;28;;@Override public void go() throws Exception {     final BufferConsumer bufferConsumer = BufferBuilderTestUtils.createFilledBufferConsumer(100).     int nextYield = numTotal - yieldAfter.     for (int i = numTotal. i > 0. ) {         final int nextChannel = rnd.nextInt(sources.length).         final int chunk = Math.min(i, rnd.nextInt(maxChunk) + 1).         final Source next = sources[nextChannel].         for (int k = chunk. k > 0. --k) {             next.addBufferConsumer(bufferConsumer.copy()).         }         i -= chunk.         if (i <= nextYield) {             nextYield -= yieldAfter.             // noinspection CallToThreadYield             Thread.yield().         }     }     for (Source source : sources) {         source.flush().     } }
false;public;0;6;;@Override public void go() throws Exception {     for (int i = numBuffers. i > 0. --i) {         assertNotNull(gate.getNextBufferOrEvent()).     } }
