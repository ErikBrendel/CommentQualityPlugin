commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;15;/**  * Sleeps for a given set of milliseconds, uninterruptibly. If interrupt is called,  * the sleep will continue nonetheless.  *  * @param msecs The number of milliseconds to sleep.  */ ;/**  * Sleeps for a given set of milliseconds, uninterruptibly. If interrupt is called,  * the sleep will continue nonetheless.  *  * @param msecs The number of milliseconds to sleep.  */ public static void sleepUninterruptibly(long msecs) {     long now = System.currentTimeMillis().     long sleepUntil = now + msecs.     long remaining.     while ((remaining = sleepUntil - now) > 0) {         try {             Thread.sleep(remaining).         } catch (InterruptedException ignored) {         }         now = System.currentTimeMillis().     } }
true;public,static;0;4;/**  * Gets the classpath with which the current JVM was started.  *  * @return The classpath with which the current JVM was started.  */ ;/**  * Gets the classpath with which the current JVM was started.  *  * @return The classpath with which the current JVM was started.  */ public static String getCurrentClasspath() {     RuntimeMXBean bean = ManagementFactory.getRuntimeMXBean().     return bean.getClassPath(). }
true;public,static;0;8;/**  * Create a temporary log4j configuration for the test.  */ ;/**  * Create a temporary log4j configuration for the test.  */ public static File createTemporaryLog4JProperties() throws IOException {     File log4jProps = File.createTempFile(FileUtils.getRandomFilename(""), "-log4j.properties").     log4jProps.deleteOnExit().     CommonTestUtils.printLog4jDebugConfig(log4jProps).     return log4jProps. }
true;public,static;0;29;/**  * Tries to get the java executable command with which the current JVM was started.  * Returns null, if the command could not be found.  *  * @return The java executable command.  */ ;/**  * Tries to get the java executable command with which the current JVM was started.  * Returns null, if the command could not be found.  *  * @return The java executable command.  */ public static String getJavaCommandPath() {     File javaHome = new File(System.getProperty("java.home")).     String path1 = new File(javaHome, "java").getAbsolutePath().     String path2 = new File(new File(javaHome, "bin"), "java").getAbsolutePath().     try {         ProcessBuilder bld = new ProcessBuilder(path1, "-version").         Process process = bld.start().         if (process.waitFor() == 0) {             return path1.         }     } catch (Throwable t) {     // ignore and try the second path     }     try {         ProcessBuilder bld = new ProcessBuilder(path2, "-version").         Process process = bld.start().         if (process.waitFor() == 0) {             return path2.         }     } catch (Throwable tt) {     // no luck     }     return null. }
true;public,static;1;13;/**  * Checks whether a process is still alive. Utility method for JVM versions before 1.8,  * where no direct method to check that is available.  *  * @param process The process to check.  * @return True, if the process is alive, false otherwise.  */ ;/**  * Checks whether a process is still alive. Utility method for JVM versions before 1.8,  * where no direct method to check that is available.  *  * @param process The process to check.  * @return True, if the process is alive, false otherwise.  */ public static boolean isProcessAlive(Process process) {     if (process == null) {         return false.     }     try {         process.exitValue().         return false.     } catch (IllegalThreadStateException e) {         return true.     } }
false;public,static;1;12;;public static void printLog4jDebugConfig(File file) throws IOException {     try (PrintWriter writer = new PrintWriter(new FileWriter(file))) {         writer.println("log4j.rootLogger=DEBUG, console").         writer.println("log4j.appender.console=org.apache.log4j.ConsoleAppender").         writer.println("log4j.appender.console.target = System.err").         writer.println("log4j.appender.console.layout=org.apache.log4j.PatternLayout").         writer.println("log4j.appender.console.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n").         writer.println("log4j.logger.org.eclipse.jetty.util.log=OFF").         writer.println("log4j.logger.org.apache.zookeeper=OFF").         writer.flush().     } }
false;public,static;2;3;;public static void waitUntilCondition(SupplierWithException<Boolean, Exception> condition, Deadline timeout) throws Exception {     waitUntilCondition(condition, timeout, RETRY_INTERVAL). }
false;public,static;3;9;;public static void waitUntilCondition(SupplierWithException<Boolean, Exception> condition, Deadline timeout, long retryIntervalMillis) throws Exception {     while (timeout.hasTimeLeft() && !condition.get()) {         Thread.sleep(Math.min(retryIntervalMillis, timeout.timeLeft().toMillis())).     }     if (!timeout.hasTimeLeft()) {         throw new TimeoutException("Condition was not met in given timeout.").     } }
false;public;0;12;;@Override public void run() {     try {         int next.         while ((next = source.read()) != -1) {             target.write(next).         }     } catch (IOException e) {     // terminate     } }
false;public,static;2;21;;public static boolean isSteamContentEqual(InputStream input1, InputStream input2) throws IOException {     if (!(input1 instanceof BufferedInputStream)) {         input1 = new BufferedInputStream(input1).     }     if (!(input2 instanceof BufferedInputStream)) {         input2 = new BufferedInputStream(input2).     }     int ch = input1.read().     while (-1 != ch) {         int ch2 = input2.read().         if (ch != ch2) {             return false.         }         ch = input1.read().     }     int ch2 = input2.read().     return (ch2 == -1). }
