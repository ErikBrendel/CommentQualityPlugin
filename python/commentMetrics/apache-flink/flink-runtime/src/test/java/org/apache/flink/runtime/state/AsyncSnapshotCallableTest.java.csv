commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Before public void setup() throws IOException {     ownerRegistry = new CloseableRegistry().     testProvidedResource = new TestBlockingCloseable().     testBlocker = new TestBlockingCloseable().     testAsyncSnapshotCallable = new TestAsyncSnapshotCallable(testProvidedResource, testBlocker).     task = testAsyncSnapshotCallable.toAsyncSnapshotFutureTask(ownerRegistry).     Assert.assertEquals(1, ownerRegistry.getNumberOfRegisteredCloseables()). }
false;public;0;5;;@After public void finalChecks() {     Assert.assertTrue(testProvidedResource.isClosed()).     Assert.assertEquals(0, ownerRegistry.getNumberOfRegisteredCloseables()). }
false;public;0;20;;@Test public void testNormalRun() throws Exception {     Thread runner = startTask(task).     while (testBlocker.getWaitersCount() < 1) {         Thread.sleep(1L).     }     testBlocker.unblockSuccessfully().     runner.join().     Assert.assertEquals(SUCCESS, task.get()).     Assert.assertEquals(Arrays.asList(METHOD_CALL, METHOD_LOG, METHOD_CLEANUP), testAsyncSnapshotCallable.getInvocationOrder()).     Assert.assertTrue(testBlocker.isClosed()). }
false;public;0;26;;@Test public void testExceptionRun() throws Exception {     testBlocker.introduceException().     Thread runner = startTask(task).     while (testBlocker.getWaitersCount() < 1) {         Thread.sleep(1L).     }     testBlocker.unblockSuccessfully().     try {         task.get().         Assert.fail().     } catch (ExecutionException ee) {         Assert.assertEquals(IOException.class, ee.getCause().getClass()).     }     runner.join().     Assert.assertEquals(Arrays.asList(METHOD_CALL, METHOD_CLEANUP), testAsyncSnapshotCallable.getInvocationOrder()).     Assert.assertTrue(testBlocker.isClosed()). }
false;public;0;26;;@Test public void testCancelRun() throws Exception {     Thread runner = startTask(task).     while (testBlocker.getWaitersCount() < 1) {         Thread.sleep(1L).     }     task.cancel(true).     testBlocker.unblockExceptionally().     try {         task.get().         Assert.fail().     } catch (CancellationException ignored) {     }     runner.join().     Assert.assertEquals(Arrays.asList(METHOD_CALL, METHOD_CANCEL, METHOD_CLEANUP), testAsyncSnapshotCallable.getInvocationOrder()).     Assert.assertTrue(testProvidedResource.isClosed()).     Assert.assertTrue(testBlocker.isClosed()). }
false;public;0;24;;@Test public void testCloseRun() throws Exception {     Thread runner = startTask(task).     while (testBlocker.getWaitersCount() < 1) {         Thread.sleep(1L).     }     ownerRegistry.close().     try {         task.get().         Assert.fail().     } catch (CancellationException ignored) {     }     runner.join().     Assert.assertEquals(Arrays.asList(METHOD_CALL, METHOD_CANCEL, METHOD_CLEANUP), testAsyncSnapshotCallable.getInvocationOrder()).     Assert.assertTrue(testBlocker.isClosed()). }
false;public;0;21;;@Test public void testCancelBeforeRun() throws Exception {     task.cancel(true).     Thread runner = startTask(task).     try {         task.get().         Assert.fail().     } catch (CancellationException ignored) {     }     runner.join().     Assert.assertEquals(Arrays.asList(METHOD_CANCEL, METHOD_CLEANUP), testAsyncSnapshotCallable.getInvocationOrder()).     Assert.assertTrue(testProvidedResource.isClosed()). }
false;private;1;5;;private Thread startTask(Runnable task) {     Thread runner = new Thread(task).     runner.start().     return runner. }
false;protected;0;15;;@Override protected String callInternal() throws Exception {     addInvocation(METHOD_CALL).     snapshotCloseableRegistry.registerCloseable(blockingResource).     try {         blockingResource.simulateBlockingOperation().     } finally {         if (snapshotCloseableRegistry.unregisterCloseable(blockingResource)) {             blockingResource.close().         }     }     return SUCCESS. }
false;protected;0;5;;@Override protected void cleanupProvidedResources() {     addInvocation(METHOD_CLEANUP).     providedResource.close(). }
false;protected;1;4;;@Override protected void logAsyncSnapshotComplete(long startTime) {     invocationOrder.add(METHOD_LOG). }
false;protected;0;5;;@Override protected void cancel() {     addInvocation(METHOD_CANCEL).     super.cancel(). }
false;public;0;6;;@Nonnull public List<String> getInvocationOrder() {     synchronized (invocationOrder) {         return new ArrayList<>(invocationOrder).     } }
false;private;1;5;;private void addInvocation(@Nonnull String invocation) {     synchronized (invocationOrder) {         invocationOrder.add(invocation).     } }
false;public;0;12;;public void simulateBlockingOperation() throws IOException {     while (!unblocked) {         try {             blockerLatch.await().         } catch (InterruptedException e) {             blockerLatch.reset().         }     }     if (exceptionally) {         throw new IOException("Closed in block").     } }
false;public;0;6;;@Override public void close() {     Preconditions.checkState(!closed).     this.closed = true.     unblockExceptionally(). }
false;public;0;3;;public boolean isClosed() {     return closed. }
false;public;0;4;;public void unblockExceptionally() {     introduceException().     unblock(). }
false;public;0;3;;public void unblockSuccessfully() {     unblock(). }
false;private;0;4;;private void unblock() {     this.unblocked = true.     blockerLatch.trigger(). }
false;public;0;3;;public void introduceException() {     this.exceptionally = true. }
false;public;0;3;;public int getWaitersCount() {     return blockerLatch.getWaitersCount(). }
