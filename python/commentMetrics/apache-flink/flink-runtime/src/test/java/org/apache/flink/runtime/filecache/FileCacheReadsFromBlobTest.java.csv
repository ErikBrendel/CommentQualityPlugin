commented;modifiers;parameterAmount;loc;comment;code
false;public;2;10;;@Override public File getFile(JobID jobId, PermanentBlobKey key) throws IOException {     if (key.equals(permanentBlobKey)) {         File f = temporaryFolder.newFile("cacheFile").         FileUtils.writeFileUtf8(f, testFileContent).         return f.     } else {         throw new IllegalArgumentException("This service contains only entry for " + permanentBlobKey).     } }
false;public;0;4;;@Override public void close() throws IOException { }
false;public;0;4;;@Before public void setup() throws Exception {     fileCache = new FileCache(new String[] { temporaryFolder.newFolder().getAbsolutePath() }, blobService). }
false;public;0;4;;@After public void shutdown() {     fileCache.shutdown(). }
false;public;0;18;;@Test public void testFileDownloadedFromBlob() throws Exception {     JobID jobID = new JobID().     ExecutionAttemptID attemptID = new ExecutionAttemptID().     final String fileName = "test_file".     // copy / create the file     final DistributedCache.DistributedCacheEntry entry = new DistributedCache.DistributedCacheEntry(fileName, false, InstantiationUtil.serializeObject(permanentBlobKey)).     Future<Path> copyResult = fileCache.createTmpFile(fileName, entry, jobID, attemptID).     final Path dstPath = copyResult.get().     final String actualContent = Files.toString(new File(dstPath.toUri()), StandardCharsets.UTF_8).     assertTrue(dstPath.getFileSystem().exists(dstPath)).     assertEquals(testFileContent, actualContent). }
