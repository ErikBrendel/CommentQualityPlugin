commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@SuppressWarnings("unchecked") @Before public void beforeTest() {     this.recordSerializer = TestData.getIntStringTupleSerializer().     this.record1Comparator = TestData.getIntStringTupleComparator().     this.record2Comparator = TestData.getIntStringTupleComparator().     this.recordPairComparator = new GenericPairComparator(record1Comparator, record2Comparator).     this.pairSerializer = new IntPairSerializer().     this.pairComparator = new TestData.IntPairComparator().     this.pairRecordPairComparator = new IntPairTuplePairComparator().     this.recordPairPairComparator = new TupleIntPairPairComparator().     this.memoryManager = new MemoryManager(MEMORY_SIZE, 1).     this.ioManager = new IOManagerAsync(). }
false;public;0;17;;@After public void afterTest() {     if (this.ioManager != null) {         this.ioManager.shutdown().         if (!this.ioManager.isProperlyShutDown()) {             Assert.fail("I/O manager failed to properly shut down.").         }         this.ioManager = null.     }     if (this.memoryManager != null) {         Assert.assertTrue("Memory Leak: Not all memory has been returned to the memory manager.", this.memoryManager.verifyEmpty()).         this.memoryManager.shutdown().         this.memoryManager = null.     } }
false;public;0;49;;@Test public void testBuildFirst() {     try {         TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(collectTupleData(input1), collectTupleData(input2)).         final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<Tuple2<Integer, String>>().         // reset the generators         generator1.reset().         generator2.reset().         input1.reset().         input2.reset().         // compare with iterator values         NonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildFirstHashJoinIterator<>(input1, input2, this.recordSerializer, this.record1Comparator, this.recordSerializer, this.record2Comparator, this.recordPairComparator, this.memoryManager, ioManager, this.parentTask, 1.0, false, false, true).         iterator.open().         // noinspection StatementWithEmptyBody         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;86;;@Test public void testBuildFirstWithHighNumberOfCommonKeys() {     // the size of the left and right inputs     final int INPUT_1_SIZE = 200.     final int INPUT_2_SIZE = 100.     final int INPUT_1_DUPLICATES = 10.     final int INPUT_2_DUPLICATES = 2000.     final int DUPLICATE_KEY = 13.     try {         TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator gen1Iter = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator gen2Iter = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         final TestData.TupleConstantValueIterator const1Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, "LEFT String for Duplicate Keys", INPUT_1_DUPLICATES).         final TestData.TupleConstantValueIterator const2Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, "RIGHT String for Duplicate Keys", INPUT_2_DUPLICATES).         final List<MutableObjectIterator<Tuple2<Integer, String>>> inList1 = new ArrayList<>().         inList1.add(gen1Iter).         inList1.add(const1Iter).         final List<MutableObjectIterator<Tuple2<Integer, String>>> inList2 = new ArrayList<>().         inList2.add(gen2Iter).         inList2.add(const2Iter).         MutableObjectIterator<Tuple2<Integer, String>> input1 = new UnionIterator<>(inList1).         MutableObjectIterator<Tuple2<Integer, String>> input2 = new UnionIterator<>(inList2).         // collect expected data         final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(collectTupleData(input1), collectTupleData(input2)).         // re-create the whole thing for actual processing         // reset the generators and iterators         generator1.reset().         generator2.reset().         const1Iter.reset().         const2Iter.reset().         gen1Iter.reset().         gen2Iter.reset().         inList1.clear().         inList1.add(gen1Iter).         inList1.add(const1Iter).         inList2.clear().         inList2.add(gen2Iter).         inList2.add(const2Iter).         input1 = new UnionIterator<>(inList1).         input2 = new UnionIterator<>(inList2).         final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         NonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildFirstHashJoinIterator<>(input1, input2, this.recordSerializer, this.record1Comparator, this.recordSerializer, this.record2Comparator, this.recordPairComparator, this.memoryManager, ioManager, this.parentTask, 1.0, false, false, true).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;48;;@Test public void testBuildSecond() {     try {         TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(collectTupleData(input1), collectTupleData(input2)).         final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         // reset the generators         generator1.reset().         generator2.reset().         input1.reset().         input2.reset().         // compare with iterator values         NonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildSecondHashJoinIterator<>(input1, input2, this.recordSerializer, this.record1Comparator, this.recordSerializer, this.record2Comparator, this.recordPairComparator, this.memoryManager, ioManager, this.parentTask, 1.0, false, false, true).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;86;;@Test public void testBuildSecondWithHighNumberOfCommonKeys() {     // the size of the left and right inputs     final int INPUT_1_SIZE = 200.     final int INPUT_2_SIZE = 100.     final int INPUT_1_DUPLICATES = 10.     final int INPUT_2_DUPLICATES = 2000.     final int DUPLICATE_KEY = 13.     try {         TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator gen1Iter = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator gen2Iter = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         final TestData.TupleConstantValueIterator const1Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, "LEFT String for Duplicate Keys", INPUT_1_DUPLICATES).         final TestData.TupleConstantValueIterator const2Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, "RIGHT String for Duplicate Keys", INPUT_2_DUPLICATES).         final List<MutableObjectIterator<Tuple2<Integer, String>>> inList1 = new ArrayList<>().         inList1.add(gen1Iter).         inList1.add(const1Iter).         final List<MutableObjectIterator<Tuple2<Integer, String>>> inList2 = new ArrayList<>().         inList2.add(gen2Iter).         inList2.add(const2Iter).         MutableObjectIterator<Tuple2<Integer, String>> input1 = new UnionIterator<>(inList1).         MutableObjectIterator<Tuple2<Integer, String>> input2 = new UnionIterator<>(inList2).         // collect expected data         final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(collectTupleData(input1), collectTupleData(input2)).         // re-create the whole thing for actual processing         // reset the generators and iterators         generator1.reset().         generator2.reset().         const1Iter.reset().         const2Iter.reset().         gen1Iter.reset().         gen2Iter.reset().         inList1.clear().         inList1.add(gen1Iter).         inList1.add(const1Iter).         inList2.clear().         inList2.add(gen2Iter).         inList2.add(const2Iter).         input1 = new UnionIterator<>(inList1).         input2 = new UnionIterator<>(inList2).         final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         NonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildSecondHashJoinIterator<>(input1, input2, this.recordSerializer, this.record1Comparator, this.recordSerializer, this.record2Comparator, this.recordPairComparator, this.memoryManager, ioManager, this.parentTask, 1.0, false, false, true).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;46;;@Test public void testBuildFirstWithMixedDataTypes() {     try {         MutableObjectIterator<IntPair> input1 = new UniformIntPairGenerator(500, 40, false).         final TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<TupleIntPairMatch>> expectedMatchesMap = joinIntPairs(collectIntPairData(input1), collectTupleData(input2)).         final FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> matcher = new TupleIntPairMatchRemovingMatcher(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         // reset the generators         input1 = new UniformIntPairGenerator(500, 40, false).         generator2.reset().         input2.reset().         // compare with iterator values         NonReusingBuildSecondHashJoinIterator<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildSecondHashJoinIterator<>(input1, input2, this.pairSerializer, this.pairComparator, this.recordSerializer, this.record2Comparator, this.pairRecordPairComparator, this.memoryManager, this.ioManager, this.parentTask, 1.0, false, false, true).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleIntPairMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;46;;@Test public void testBuildSecondWithMixedDataTypes() {     try {         MutableObjectIterator<IntPair> input1 = new UniformIntPairGenerator(500, 40, false).         final TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<TupleIntPairMatch>> expectedMatchesMap = joinIntPairs(collectIntPairData(input1), collectTupleData(input2)).         final FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> matcher = new TupleIntPairMatchRemovingMatcher(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         // reset the generators         input1 = new UniformIntPairGenerator(500, 40, false).         generator2.reset().         input2.reset().         // compare with iterator values         NonReusingBuildFirstHashJoinIterator<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildFirstHashJoinIterator<>(input1, input2, this.pairSerializer, this.pairComparator, this.recordSerializer, this.record2Comparator, this.recordPairPairComparator, this.memoryManager, this.ioManager, this.parentTask, 1.0, false, false, true).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleIntPairMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;48;;@Test public void testBuildFirstAndProbeSideOuterJoin() {     try {         TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         TupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = rightOuterJoinTuples(collectTupleData(input1), collectTupleData(input2)).         final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         // reset the generators         generator1.reset().         generator2.reset().         input1.reset().         input2.reset().         // compare with iterator values         NonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildFirstHashJoinIterator<>(input1, input2, this.recordSerializer, this.record1Comparator, this.recordSerializer, this.record2Comparator, this.recordPairComparator, this.memoryManager, ioManager, this.parentTask, 1.0, true, false, false).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;48;;@Test public void testBuildFirstAndBuildSideOuterJoin() {     try {         TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         TupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = leftOuterJoinTuples(collectTupleData(input1), collectTupleData(input2)).         final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         // reset the generators         generator1.reset().         generator2.reset().         input1.reset().         input2.reset().         // compare with iterator values         NonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildFirstHashJoinIterator<>(input1, input2, this.recordSerializer, this.record1Comparator, this.recordSerializer, this.record2Comparator, this.recordPairComparator, this.memoryManager, ioManager, this.parentTask, 1.0, false, true, false).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;48;;@Test public void testBuildFirstAndFullOuterJoin() {     try {         TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         TupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = fullOuterJoinTuples(collectTupleData(input1), collectTupleData(input2)).         final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         // reset the generators         generator1.reset().         generator2.reset().         input1.reset().         input2.reset().         // compare with iterator values         NonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildFirstHashJoinIterator<>(input1, input2, this.recordSerializer, this.record1Comparator, this.recordSerializer, this.record2Comparator, this.recordPairComparator, this.memoryManager, ioManager, this.parentTask, 1.0, true, true, false).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;48;;@Test public void testBuildSecondAndProbeSideOuterJoin() {     try {         TupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = leftOuterJoinTuples(collectTupleData(input1), collectTupleData(input2)).         final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         // reset the generators         generator1.reset().         generator2.reset().         input1.reset().         input2.reset().         // compare with iterator values         NonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildSecondHashJoinIterator<>(input1, input2, this.recordSerializer, this.record1Comparator, this.recordSerializer, this.record2Comparator, this.recordPairComparator, this.memoryManager, ioManager, this.parentTask, 1.0, true, false, false).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;48;;@Test public void testBuildSecondAndBuildSideOuterJoin() {     try {         TupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = rightOuterJoinTuples(collectTupleData(input1), collectTupleData(input2)).         final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         // reset the generators         generator1.reset().         generator2.reset().         input1.reset().         input2.reset().         // compare with iterator values         NonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildSecondHashJoinIterator<>(input1, input2, this.recordSerializer, this.record1Comparator, this.recordSerializer, this.record2Comparator, this.recordPairComparator, this.memoryManager, ioManager, this.parentTask, 1.0, false, true, false).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public;0;48;;@Test public void testBuildSecondAndFullOuterJoin() {     try {         TupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH).         final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE).         final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE).         // collect expected data         final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = fullOuterJoinTuples(collectTupleData(input1), collectTupleData(input2)).         final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap).         final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>().         // reset the generators         generator1.reset().         generator2.reset().         input1.reset().         input2.reset().         // compare with iterator values         NonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator = new NonReusingBuildSecondHashJoinIterator<>(input1, input2, this.recordSerializer, this.record1Comparator, this.recordSerializer, this.record2Comparator, this.recordPairComparator, this.memoryManager, ioManager, this.parentTask, 1.0, true, true, false).         iterator.open().         while (iterator.callWithNextKey(matcher, collector)) .         iterator.close().         // assert that each expected match was seen         for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {             if (!entry.getValue().isEmpty()) {                 Assert.fail("Collection for key " + entry.getKey() + " is not empty").             }         }     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;public,static;2;29;;// -------------------------------------------------------------------------------------------- // Utilities // -------------------------------------------------------------------------------------------- public static Map<Integer, Collection<TupleMatch>> joinTuples(Map<Integer, Collection<String>> leftMap, Map<Integer, Collection<String>> rightMap) {     Map<Integer, Collection<TupleMatch>> map = new HashMap<>().     for (Integer key : leftMap.keySet()) {         Collection<String> leftValues = leftMap.get(key).         Collection<String> rightValues = rightMap.get(key).         if (rightValues == null) {             continue.         }         if (!map.containsKey(key)) {             map.put(key, new ArrayList<TupleMatch>()).         }         Collection<TupleMatch> matchedValues = map.get(key).         for (String leftValue : leftValues) {             for (String rightValue : rightValues) {                 matchedValues.add(new TupleMatch(leftValue, rightValue)).             }         }     }     return map. }
false;public,static;2;30;;public static Map<Integer, Collection<TupleMatch>> leftOuterJoinTuples(Map<Integer, Collection<String>> leftMap, Map<Integer, Collection<String>> rightMap) {     Map<Integer, Collection<TupleMatch>> map = new HashMap<>().     for (Integer key : leftMap.keySet()) {         Collection<String> leftValues = leftMap.get(key).         Collection<String> rightValues = rightMap.get(key).         if (!map.containsKey(key)) {             map.put(key, new ArrayList<TupleMatch>()).         }         Collection<TupleMatch> matchedValues = map.get(key).         for (String leftValue : leftValues) {             if (rightValues != null) {                 for (String rightValue : rightValues) {                     matchedValues.add(new TupleMatch(leftValue, rightValue)).                 }             } else {                 matchedValues.add(new TupleMatch(leftValue, null)).             }         }     }     return map. }
false;public,static;2;30;;public static Map<Integer, Collection<TupleMatch>> rightOuterJoinTuples(Map<Integer, Collection<String>> leftMap, Map<Integer, Collection<String>> rightMap) {     Map<Integer, Collection<TupleMatch>> map = new HashMap<>().     for (Integer key : rightMap.keySet()) {         Collection<String> leftValues = leftMap.get(key).         Collection<String> rightValues = rightMap.get(key).         if (!map.containsKey(key)) {             map.put(key, new ArrayList<TupleMatch>()).         }         Collection<TupleMatch> matchedValues = map.get(key).         for (String rightValue : rightValues) {             if (leftValues != null) {                 for (String leftValue : leftValues) {                     matchedValues.add(new TupleMatch(leftValue, rightValue)).                 }             } else {                 matchedValues.add(new TupleMatch(null, rightValue)).             }         }     }     return map. }
false;public,static;2;46;;public static Map<Integer, Collection<TupleMatch>> fullOuterJoinTuples(Map<Integer, Collection<String>> leftMap, Map<Integer, Collection<String>> rightMap) {     Map<Integer, Collection<TupleMatch>> map = new HashMap<>().     for (Integer key : rightMap.keySet()) {         Collection<String> leftValues = leftMap.get(key).         Collection<String> rightValues = rightMap.get(key).         if (!map.containsKey(key)) {             map.put(key, new ArrayList<TupleMatch>()).         }         Collection<TupleMatch> matchedValues = map.get(key).         for (String rightValue : rightValues) {             if (leftValues != null) {                 for (String leftValue : leftValues) {                     matchedValues.add(new TupleMatch(leftValue, rightValue)).                 }             } else {                 matchedValues.add(new TupleMatch(null, rightValue)).             }         }     }     for (Integer key : leftMap.keySet()) {         Collection<String> leftValues = leftMap.get(key).         Collection<String> rightValues = rightMap.get(key).         if (rightValues == null) {             if (!map.containsKey(key)) {                 map.put(key, new ArrayList<TupleMatch>()).             }             Collection<TupleMatch> matchedValues = map.get(key).             for (String leftValue : leftValues) {                 matchedValues.add(new TupleMatch(leftValue, null)).             }         }     }     return map. }
false;public,static;2;30;;public static Map<Integer, Collection<TupleIntPairMatch>> joinIntPairs(Map<Integer, Collection<Integer>> leftMap, Map<Integer, Collection<String>> rightMap) {     final Map<Integer, Collection<TupleIntPairMatch>> map = new HashMap<>().     for (Integer i : leftMap.keySet()) {         final Collection<Integer> leftValues = leftMap.get(i).         final Collection<String> rightValues = rightMap.get(i).         if (rightValues == null) {             continue.         }         if (!map.containsKey(i)) {             map.put(i, new ArrayList<TupleIntPairMatch>()).         }         final Collection<TupleIntPairMatch> matchedValues = map.get(i).         for (Integer v : leftValues) {             for (String val : rightValues) {                 matchedValues.add(new TupleIntPairMatch(v, val)).             }         }     }     return map. }
false;public,static;1;19;;public static Map<Integer, Collection<String>> collectTupleData(MutableObjectIterator<Tuple2<Integer, String>> iter) throws Exception {     Map<Integer, Collection<String>> map = new HashMap<>().     Tuple2<Integer, String> pair = new Tuple2<>().     while ((pair = iter.next(pair)) != null) {         Integer key = pair.f0.         if (!map.containsKey(key)) {             map.put(key, new ArrayList<String>()).         }         Collection<String> values = map.get(key).         values.add(pair.f1).     }     return map. }
false;public,static;1;20;;public static Map<Integer, Collection<Integer>> collectIntPairData(MutableObjectIterator<IntPair> iter) throws Exception {     Map<Integer, Collection<Integer>> map = new HashMap<>().     IntPair pair = new IntPair().     while ((pair = iter.next(pair)) != null) {         final int key = pair.getKey().         final int value = pair.getValue().         if (!map.containsKey(key)) {             map.put(key, new ArrayList<Integer>()).         }         Collection<Integer> values = map.get(key).         values.add(value).     }     return map. }
false;public;1;9;;@Override public boolean equals(Object obj) {     TupleMatch that = (TupleMatch) obj.     return (this.right == null ? that.right == null : (that.right != null && this.right.equals(that.right))) && (this.left == null ? that.left == null : (that.left != null && this.left.equals(that.left))). }
false;public;0;6;;@Override public int hashCode() {     int hc = this.left != null ? this.left.hashCode() : 23.     hc = hc ^ (this.right != null ? this.right.hashCode() : 41).     return hc. }
false;public;0;6;;@Override public String toString() {     String s = left == null ? "<null>" : left.     s += ", " + (right == null ? "<null>" : right).     return s. }
false;public;1;5;;@Override public boolean equals(Object obj) {     TupleIntPairMatch o = (TupleIntPairMatch) obj.     return this.left == o.left && this.right.equals(o.right). }
false;public;0;4;;@Override public int hashCode() {     return this.left ^ this.right.hashCode(). }
false;public;0;4;;@Override public String toString() {     return left + ", " + right. }
false;public;3;21;;@Override public void join(Tuple2<Integer, String> rec1, Tuple2<Integer, String> rec2, Collector<Tuple2<Integer, String>> out) throws Exception {     int key = rec1 != null ? rec1.f0 : rec2.f0.     String value1 = rec1 != null ? rec1.f1 : null.     String value2 = rec2 != null ? rec2.f1 : null.     // System.err.println("rec1 key = "+key+"  rec2 key= "+rec2.f0).     Collection<TupleMatch> matches = this.toRemoveFrom.get(key).     if (matches == null) {         Assert.fail("Match " + key + " - " + value1 + ":" + value2 + " is unexpected.").     }     Assert.assertTrue("Produced match was not contained: " + key + " - " + value1 + ":" + value2, matches.remove(new TupleMatch(value1, value2))).     if (matches.isEmpty()) {         this.toRemoveFrom.remove(key).     } }
false;public;3;23;;@Override public void join(IntPair rec1, Tuple2<Integer, String> rec2, Collector<Tuple2<Integer, String>> out) throws Exception {     final int k = rec1.getKey().     final int v = rec1.getValue().     final Integer key = rec2.f0.     final String value = rec2.f1.     Assert.assertTrue("Key does not match for matching IntPair Tuple combination.", k == key).     Collection<TupleIntPairMatch> matches = this.toRemoveFrom.get(key).     if (matches == null) {         Assert.fail("Match " + key + " - " + v + ":" + value + " is unexpected.").     }     Assert.assertTrue("Produced match was not contained: " + key + " - " + v + ":" + value, matches.remove(new TupleIntPairMatch(v, value))).     if (matches.isEmpty()) {         this.toRemoveFrom.remove(key).     } }
false;public;1;4;;@Override public void setReference(IntPair reference) {     this.reference = reference.getKey(). }
false;public;1;8;;@Override public boolean equalToReference(Tuple2<Integer, String> candidate) {     try {         return candidate.f0 == this.reference.     } catch (NullPointerException npex) {         throw new NullKeyFieldException().     } }
false;public;1;8;;@Override public int compareToReference(Tuple2<Integer, String> candidate) {     try {         return candidate.f0 - this.reference.     } catch (NullPointerException npex) {         throw new NullKeyFieldException().     } }
false;public;1;4;;@Override public void setReference(Tuple2<Integer, String> reference) {     this.reference = reference.f0. }
false;public;1;4;;@Override public boolean equalToReference(IntPair candidate) {     return this.reference == candidate.getKey(). }
false;public;1;4;;@Override public int compareToReference(IntPair candidate) {     return candidate.getKey() - this.reference. }
