commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setup() {     ioManager = new IOManagerAsync(). }
false;public,static;0;5;;@AfterClass public static void shutdown() {     executorService.shutdownNow().     ioManager.shutdown(). }
false;;0;4;;@Override SpillableSubpartition createSubpartition() {     return createSubpartition(ioManager). }
false;private,static;1;7;;private static SpillableSubpartition createSubpartition(IOManager ioManager) {     ResultPartition parent = mock(ResultPartition.class).     BufferProvider bufferProvider = mock(BufferProvider.class).     when(parent.getBufferProvider()).thenReturn(bufferProvider).     when(bufferProvider.getMemorySegmentSize()).thenReturn(32 * 1024).     return new SpillableSubpartition(0, parent, ioManager). }
false;public;1;6;;@Override public Void answer(InvocationOnMock invocation) throws Throwable {     blockLatch.countDown().     doneLatch.await().     return null. }
false;public;0;5;;@Override public Void call() throws Exception {     partition.finish().     return null. }
true;public;0;53;/**  * Tests a fix for FLINK-2384.  *  * @see <a href="https://issues.apache.org/jira/browse/FLINK-2384">FLINK-2384</a>  */ ;/**  * Tests a fix for FLINK-2384.  *  * @see <a href="https://issues.apache.org/jira/browse/FLINK-2384">FLINK-2384</a>  */ @Test public void testConcurrentFinishAndReleaseMemory() throws Exception {     // Latches to blocking     final CountDownLatch doneLatch = new CountDownLatch(1).     final CountDownLatch blockLatch = new CountDownLatch(1).     // Blocking spill writer (blocks on the close call)     AsynchronousBufferFileWriter spillWriter = mock(AsynchronousBufferFileWriter.class).     doAnswer(new Answer<Void>() {          @Override         public Void answer(InvocationOnMock invocation) throws Throwable {             blockLatch.countDown().             doneLatch.await().             return null.         }     }).when(spillWriter).close().     // Mock I/O manager returning the blocking spill writer     IOManager ioManager = mock(IOManager.class).     when(ioManager.createBufferFileWriter(nullable(FileIOChannel.ID.class))).thenReturn(spillWriter).     // The partition     final SpillableSubpartition partition = new SpillableSubpartition(0, mock(ResultPartition.class), ioManager).     // Spill the partition initially (creates the spill writer)     assertEquals(0, partition.releaseMemory()).     ExecutorService executor = Executors.newSingleThreadExecutor().     // Finish the partition (this blocks because of the mock blocking writer)     Future<Void> blockingFinish = executor.submit(new Callable<Void>() {          @Override         public Void call() throws Exception {             partition.finish().             return null.         }     }).     // Ensure that the blocking call has been made     blockLatch.await().     // This call needs to go through. FLINK-2384 discovered a bug, in     // which the finish call was holding a lock, which was leading to a     // deadlock when another operation on the partition was happening.     partition.releaseMemory().     // Check that the finish call succeeded w/o problems as well to avoid     // false test successes.     doneLatch.countDown().     blockingFinish.get(). }
true;public;0;20;/**  * Tests a fix for FLINK-2412.  *  * @see <a href="https://issues.apache.org/jira/browse/FLINK-2412">FLINK-2412</a>  */ ;/**  * Tests a fix for FLINK-2412.  *  * @see <a href="https://issues.apache.org/jira/browse/FLINK-2412">FLINK-2412</a>  */ @Test public void testReleasePartitionAndGetNext() throws Exception {     // Create partition and add some buffers     SpillableSubpartition partition = createSubpartition().     partition.finish().     // Create the read view     ResultSubpartitionView readView = spy(partition.createReadView(new NoOpBufferAvailablityListener())).     // The released state check (of the parent) needs to be independent     // of the released state of the view.     doNothing().when(readView).releaseAllResources().     // Release the partition, but the view does not notice yet.     partition.release().     assertNull(readView.getNextBuffer()). }
true;public;0;61;/**  * Tests that a spilled partition is correctly read back in via a spilled  * read view.  */ ;/**  * Tests that a spilled partition is correctly read back in via a spilled  * read view.  */ @Test public void testConsumeSpilledPartition() throws Exception {     SpillableSubpartition partition = createSubpartition().     BufferConsumer bufferConsumer = createFilledBufferConsumer(BUFFER_DATA_SIZE, BUFFER_DATA_SIZE).     BufferConsumer eventBufferConsumer = EventSerializer.toBufferConsumer(new CancelCheckpointMarker(1)).     final int eventSize = eventBufferConsumer.getWrittenBytes().     partition.add(bufferConsumer.copy()).     partition.add(bufferConsumer.copy()).     partition.add(eventBufferConsumer).     partition.add(bufferConsumer).     assertEquals(4, partition.getTotalNumberOfBuffers()).     assertEquals(3, partition.getBuffersInBacklog()).     // only updated when getting/releasing the buffers     assertEquals(0, partition.getTotalNumberOfBytes()).     assertFalse(bufferConsumer.isRecycled()).     assertEquals(4, partition.releaseMemory()).     // now the bufferConsumer may be freed, depending on the timing of the write operation     // -> let's do this check at the end of the test (to save some time)     // still same statistics     assertEquals(4, partition.getTotalNumberOfBuffers()).     assertEquals(3, partition.getBuffersInBacklog()).     assertEquals(BUFFER_DATA_SIZE * 3 + eventSize, partition.getTotalNumberOfBytes()).     partition.finish().     // + one EndOfPartitionEvent     assertEquals(5, partition.getTotalNumberOfBuffers()).     assertEquals(3, partition.getBuffersInBacklog()).     assertEquals(BUFFER_DATA_SIZE * 3 + eventSize + 4, partition.getTotalNumberOfBytes()).     AwaitableBufferAvailablityListener listener = new AwaitableBufferAvailablityListener().     SpilledSubpartitionView reader = (SpilledSubpartitionView) partition.createReadView(listener).     assertEquals(1, listener.getNumNotifications()).     // buffer     assertFalse(reader.nextBufferIsEvent()).     assertNextBuffer(reader, BUFFER_DATA_SIZE, true, 2, false, true).     assertEquals(2, partition.getBuffersInBacklog()).     assertNextBuffer(reader, BUFFER_DATA_SIZE, true, 1, true, true).     assertEquals(1, partition.getBuffersInBacklog()).     assertNextEvent(reader, eventSize, CancelCheckpointMarker.class, true, 1, false, true).     assertEquals(1, partition.getBuffersInBacklog()).     assertNextBuffer(reader, BUFFER_DATA_SIZE, true, 0, true, true).     assertEquals(0, partition.getBuffersInBacklog()).     assertNextEvent(reader, 4, EndOfPartitionEvent.class, false, 0, false, true).     assertEquals(0, partition.getBuffersInBacklog()).     // finally check that the bufferConsumer has been freed after a successful (or failed) write     // 30 secs     final long deadline = System.currentTimeMillis() + 30_000L.     while (!bufferConsumer.isRecycled() && System.currentTimeMillis() < deadline) {         Thread.sleep(1).     }     assertTrue(bufferConsumer.isRecycled()). }
true;public;0;72;/**  * Tests that a spilled partition is correctly read back in via a spilled read view. The  * partition went into spilled state before adding buffers and the access pattern resembles  * the actual use of {@link org.apache.flink.runtime.io.network.api.writer.RecordWriter}.  */ ;/**  * Tests that a spilled partition is correctly read back in via a spilled read view. The  * partition went into spilled state before adding buffers and the access pattern resembles  * the actual use of {@link org.apache.flink.runtime.io.network.api.writer.RecordWriter}.  */ @Test public void testConsumeSpilledPartitionSpilledBeforeAdd() throws Exception {     SpillableSubpartition partition = createSubpartition().     // <---- SPILL to disk     assertEquals(0, partition.releaseMemory()).     BufferBuilder[] bufferBuilders = new BufferBuilder[] { createBufferBuilder(BUFFER_DATA_SIZE), createBufferBuilder(BUFFER_DATA_SIZE), createBufferBuilder(BUFFER_DATA_SIZE), createBufferBuilder(BUFFER_DATA_SIZE) }.     BufferConsumer[] bufferConsumers = Arrays.stream(bufferBuilders).map(BufferBuilder::createBufferConsumer).toArray(BufferConsumer[]::new).     BufferConsumer eventBufferConsumer = EventSerializer.toBufferConsumer(new CancelCheckpointMarker(1)).     final int eventSize = eventBufferConsumer.getWrittenBytes().     // note: only the newest buffer may be unfinished!     partition.add(bufferConsumers[0]).     fillBufferBuilder(bufferBuilders[0], BUFFER_DATA_SIZE).finish().     partition.add(bufferConsumers[1]).     fillBufferBuilder(bufferBuilders[1], BUFFER_DATA_SIZE).finish().     partition.add(eventBufferConsumer).     partition.add(bufferConsumers[2]).     // remains empty     bufferBuilders[2].finish().     partition.add(bufferConsumers[3]).     // last one: partially filled, unfinished     fillBufferBuilder(bufferBuilders[3], BUFFER_DATA_SIZE / 2).     // finished buffers only:     int expectedSize = BUFFER_DATA_SIZE * 2 + eventSize.     // now the bufferConsumer may be freed, depending on the timing of the write operation     // -> let's do this check at the end of the test (to save some time)     // still same statistics     assertEquals(5, partition.getTotalNumberOfBuffers()).     assertEquals(3, partition.getBuffersInBacklog()).     assertEquals(expectedSize, partition.getTotalNumberOfBytes()).     partition.finish().     // previously unfinished buffer     expectedSize += BUFFER_DATA_SIZE / 2.     // + one EndOfPartitionEvent     expectedSize += 4.     assertEquals(6, partition.getTotalNumberOfBuffers()).     assertEquals(3, partition.getBuffersInBacklog()).     assertEquals(expectedSize, partition.getTotalNumberOfBytes()).     Arrays.stream(bufferConsumers).forEach(bufferConsumer -> assertTrue(bufferConsumer.isRecycled())).     AwaitableBufferAvailablityListener listener = new AwaitableBufferAvailablityListener().     SpilledSubpartitionView reader = (SpilledSubpartitionView) partition.createReadView(listener).     assertEquals(1, listener.getNumNotifications()).     // full buffer     assertFalse(reader.nextBufferIsEvent()).     assertNextBuffer(reader, BUFFER_DATA_SIZE, true, 2, false, true).     assertEquals(2, partition.getBuffersInBacklog()).     assertNextBuffer(reader, BUFFER_DATA_SIZE, true, 1, true, true).     assertEquals(1, partition.getBuffersInBacklog()).     assertNextEvent(reader, eventSize, CancelCheckpointMarker.class, true, 1, false, true).     assertEquals(1, partition.getBuffersInBacklog()).     assertNextBuffer(reader, BUFFER_DATA_SIZE / 2, true, 0, true, true).     assertEquals(0, partition.getBuffersInBacklog()).     assertNextEvent(reader, 4, EndOfPartitionEvent.class, false, 0, false, true).     assertEquals(0, partition.getBuffersInBacklog()).     // close buffer consumers     Arrays.stream(bufferConsumers).forEach(bufferConsumer -> bufferConsumer.close()). }
true;public;0;87;/**  * Tests that a spilled partition is correctly read back in via a spilled  * read view.  */ ;/**  * Tests that a spilled partition is correctly read back in via a spilled  * read view.  */ @Test public void testConsumeSpillablePartitionSpilledDuringConsume() throws Exception {     SpillableSubpartition partition = createSubpartition().     BufferConsumer bufferConsumer = createFilledBufferConsumer(BUFFER_DATA_SIZE, BUFFER_DATA_SIZE).     BufferConsumer eventBufferConsumer = EventSerializer.toBufferConsumer(new CancelCheckpointMarker(1)).     final int eventSize = eventBufferConsumer.getWrittenBytes().     partition.add(bufferConsumer.copy()).     partition.add(bufferConsumer.copy()).     partition.add(eventBufferConsumer).     partition.add(bufferConsumer).     partition.finish().     assertEquals(5, partition.getTotalNumberOfBuffers()).     assertEquals(3, partition.getBuffersInBacklog()).     // only updated when getting/spilling the buffers     assertEquals(0, partition.getTotalNumberOfBytes()).     AwaitableBufferAvailablityListener listener = new AwaitableBufferAvailablityListener().     SpillableSubpartitionView reader = (SpillableSubpartitionView) partition.createReadView(listener).     // Initial notification     assertEquals(1, listener.getNumNotifications()).     assertFalse(bufferConsumer.isRecycled()).     assertFalse(reader.nextBufferIsEvent()).     // first buffer (non-spilled)     assertNextBuffer(reader, BUFFER_DATA_SIZE, true, 2, false, false).     // only updated when getting/spilling the buffers     assertEquals(BUFFER_DATA_SIZE, partition.getTotalNumberOfBytes()).     assertEquals(2, partition.getBuffersInBacklog()).     // since isMoreAvailable is set to true, no need for notification     assertEquals(1, listener.getNumNotifications()).     assertFalse(bufferConsumer.isRecycled()).     // Spill now     assertEquals(3, partition.releaseMemory()).     // still one in the reader!     assertFalse(bufferConsumer.isRecycled()).     // still same statistics:     assertEquals(5, partition.getTotalNumberOfBuffers()).     assertEquals(2, partition.getBuffersInBacklog()).     // only updated when getting/spilling the buffers but without the nextBuffer (kept in memory)     assertEquals(BUFFER_DATA_SIZE * 2 + eventSize + 4, partition.getTotalNumberOfBytes()).     // wait for successfully spilling all buffers (before that we may not access any spilled buffer and cannot rely on isMoreAvailable!)     listener.awaitNotifications(2, 30_000).     // Spiller finished     assertEquals(2, listener.getNumNotifications()).     // after consuming and releasing the next buffer, the bufferConsumer may be freed,     // depending on the timing of the last write operation     // -> retain once so that we can check below     Buffer buffer = bufferConsumer.build().     buffer.retainBuffer().     // second buffer (retained in SpillableSubpartition#nextBuffer)     assertNextBuffer(reader, BUFFER_DATA_SIZE, true, 1, true, false).     // finally integrates the nextBuffer statistics     assertEquals(BUFFER_DATA_SIZE * 3 + eventSize + 4, partition.getTotalNumberOfBytes()).     assertEquals(1, partition.getBuffersInBacklog()).     // recycle the retained buffer from above (should be the last reference!)     bufferConsumer.close().     // the event (spilled)     assertNextEvent(reader, eventSize, CancelCheckpointMarker.class, true, 1, false, true).     // already updated during spilling     assertEquals(BUFFER_DATA_SIZE * 3 + eventSize + 4, partition.getTotalNumberOfBytes()).     assertEquals(1, partition.getBuffersInBacklog()).     // last buffer (spilled)     assertNextBuffer(reader, BUFFER_DATA_SIZE, true, 0, true, true).     // already updated during spilling     assertEquals(BUFFER_DATA_SIZE * 3 + eventSize + 4, partition.getTotalNumberOfBytes()).     assertEquals(0, partition.getBuffersInBacklog()).     buffer.recycleBuffer().     assertTrue(buffer.isRecycled()).     // End of partition     assertNextEvent(reader, 4, EndOfPartitionEvent.class, false, 0, false, true).     // already updated during spilling     assertEquals(BUFFER_DATA_SIZE * 3 + eventSize + 4, partition.getTotalNumberOfBytes()).     assertEquals(0, partition.getBuffersInBacklog()).     // finally check that the bufferConsumer has been freed after a successful (or failed) write     // 30 secs     final long deadline = System.currentTimeMillis() + 30_000L.     while (!bufferConsumer.isRecycled() && System.currentTimeMillis() < deadline) {         Thread.sleep(1).     }     assertTrue(bufferConsumer.isRecycled()). }
true;public;0;4;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a spillable finished partition.  */ ;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a spillable finished partition.  */ @Test public void testAddOnFinishedSpillablePartition() throws Exception {     testAddOnFinishedPartition(false). }
true;public;0;4;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a spilled finished partition.  */ ;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a spilled finished partition.  */ @Test public void testAddOnFinishedSpilledPartition() throws Exception {     testAddOnFinishedPartition(true). }
true;private;1;25;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a finished partition.  *  * @param spilled  * 		whether the partition should be spilled to disk (<tt>true</tt>) or not (<tt>false</tt>,  * 		spillable).  */ ;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a finished partition.  *  * @param spilled  * 		whether the partition should be spilled to disk (<tt>true</tt>) or not (<tt>false</tt>,  * 		spillable).  */ private void testAddOnFinishedPartition(boolean spilled) throws Exception {     SpillableSubpartition partition = createSubpartition().     if (spilled) {         assertEquals(0, partition.releaseMemory()).     }     partition.finish().     // finish adds an EndOfPartitionEvent     assertEquals(1, partition.getTotalNumberOfBuffers()).     // if not spilled, statistics are only updated when consuming the buffers     assertEquals(spilled ? 4 : 0, partition.getTotalNumberOfBytes()).     BufferConsumer buffer = createFilledBufferConsumer(BUFFER_DATA_SIZE, BUFFER_DATA_SIZE).     try {         partition.add(buffer).     } finally {         if (!buffer.isRecycled()) {             buffer.close().             Assert.fail("buffer not recycled").         }     }     // still same statistics     assertEquals(1, partition.getTotalNumberOfBuffers()).     // if not spilled, statistics are only updated when consuming the buffers     assertEquals(spilled ? 4 : 0, partition.getTotalNumberOfBytes()). }
false;public;0;4;;@Test public void testAddOnReleasedSpillablePartition() throws Exception {     testAddOnReleasedPartition(false). }
false;public;0;4;;@Test public void testAddOnReleasedSpilledPartition() throws Exception {     testAddOnReleasedPartition(true). }
true;private;1;23;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a released partition.  *  * @param spilled  * 		whether the partition should be spilled to disk (<tt>true</tt>) or not (<tt>false</tt>,  * 		spillable).  */ ;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a released partition.  *  * @param spilled  * 		whether the partition should be spilled to disk (<tt>true</tt>) or not (<tt>false</tt>,  * 		spillable).  */ private void testAddOnReleasedPartition(boolean spilled) throws Exception {     SpillableSubpartition partition = createSubpartition().     partition.release().     if (spilled) {         assertEquals(0, partition.releaseMemory()).     }     BufferConsumer buffer = createFilledBufferConsumer(BUFFER_DATA_SIZE, BUFFER_DATA_SIZE).     boolean bufferRecycled.     try {         partition.add(buffer).     } finally {         bufferRecycled = buffer.isRecycled().         if (!bufferRecycled) {             buffer.close().         }     }     if (!bufferRecycled) {         Assert.fail("buffer not recycled").     }     assertEquals(0, partition.getTotalNumberOfBuffers()).     assertEquals(0, partition.getTotalNumberOfBytes()). }
true;public;0;24;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a spilled partition where adding the  * write request fails with an exception.  */ ;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a spilled partition where adding the  * write request fails with an exception.  */ @Test public void testAddOnSpilledPartitionWithSlowWriter() throws Exception {     // simulate slow writer by a no-op write operation     IOManager ioManager = new IOManagerAsyncWithNoOpBufferFileWriter().     SpillableSubpartition partition = createSubpartition(ioManager).     assertEquals(0, partition.releaseMemory()).     BufferConsumer buffer = createFilledBufferConsumer(BUFFER_DATA_SIZE, BUFFER_DATA_SIZE).     boolean bufferRecycled.     try {         partition.add(buffer).     } finally {         ioManager.shutdown().         bufferRecycled = buffer.isRecycled().         if (!bufferRecycled) {             buffer.close().         }     }     if (bufferRecycled) {         Assert.fail("buffer recycled before the write operation completed").     }     assertEquals(1, partition.getTotalNumberOfBuffers()).     assertEquals(BUFFER_DATA_SIZE, partition.getTotalNumberOfBytes()). }
true;public;0;4;/**  * Tests {@link SpillableSubpartition#releaseMemory()} with a spillable partition without a view  * but with a writer that does not do any write to check for correct buffer recycling.  */ ;/**  * Tests {@link SpillableSubpartition#releaseMemory()} with a spillable partition without a view  * but with a writer that does not do any write to check for correct buffer recycling.  */ @Test public void testReleaseOnSpillablePartitionWithoutViewWithSlowWriter() throws Exception {     testReleaseOnSpillablePartitionWithSlowWriter(false). }
true;public;0;4;/**  * Tests {@link SpillableSubpartition#releaseMemory()} with a spillable partition which has a  * view associated with it and a writer that does not do any write to check for correct buffer  * recycling.  */ ;/**  * Tests {@link SpillableSubpartition#releaseMemory()} with a spillable partition which has a  * view associated with it and a writer that does not do any write to check for correct buffer  * recycling.  */ @Test public void testReleaseOnSpillablePartitionWithViewWithSlowWriter() throws Exception {     testReleaseOnSpillablePartitionWithSlowWriter(true). }
true;private;1;42;/**  * Tests {@link SpillableSubpartition#releaseMemory()} with a spillable partition which has a a  * writer that does not do any write to check for correct buffer recycling.  */ ;/**  * Tests {@link SpillableSubpartition#releaseMemory()} with a spillable partition which has a a  * writer that does not do any write to check for correct buffer recycling.  */ private void testReleaseOnSpillablePartitionWithSlowWriter(boolean createView) throws Exception {     // simulate slow writer by a no-op write operation     IOManager ioManager = new IOManagerAsyncWithNoOpBufferFileWriter().     SpillableSubpartition partition = createSubpartition(ioManager).     BufferConsumer buffer1 = createFilledBufferConsumer(BUFFER_DATA_SIZE, BUFFER_DATA_SIZE).     BufferConsumer buffer2 = createFilledBufferConsumer(BUFFER_DATA_SIZE, BUFFER_DATA_SIZE).     try {         // we need two buffers because the view will use one of them and not release it         partition.add(buffer1).         partition.add(buffer2).         assertFalse("buffer1 should not be recycled (still in the queue)", buffer1.isRecycled()).         assertFalse("buffer2 should not be recycled (still in the queue)", buffer2.isRecycled()).         assertEquals(2, partition.getTotalNumberOfBuffers()).         // only updated when buffers are consumed or spilled         assertEquals(0, partition.getTotalNumberOfBytes()).         if (createView) {             // Create a read view             partition.finish().             partition.createReadView(new NoOpBufferAvailablityListener()).             // only updated when buffers are consumed or spilled             assertEquals(0, partition.getTotalNumberOfBytes()).         }         // one instance of the buffers is placed in the view's nextBuffer and not released         // (if there is no view, there will be no additional EndOfPartitionEvent)         assertEquals(2, partition.releaseMemory()).         assertFalse("buffer1 should not be recycled (advertised as nextBuffer)", buffer1.isRecycled()).         assertFalse("buffer2 should not be recycled (not written yet)", buffer2.isRecycled()).     } finally {         ioManager.shutdown().         if (!buffer1.isRecycled()) {             buffer1.close().         }         if (!buffer2.isRecycled()) {             buffer2.close().         }     }     // note: a view requires a finished partition which has an additional EndOfPartitionEvent     assertEquals(2 + (createView ? 1 : 0), partition.getTotalNumberOfBuffers()).     // with a view, one buffer remains in nextBuffer and is not counted yet     assertEquals(BUFFER_DATA_SIZE + (createView ? 4 : BUFFER_DATA_SIZE), partition.getTotalNumberOfBytes()). }
true;public;0;25;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a spilled partition where adding the  * write request fails with an exception.  */ ;/**  * Tests {@link SpillableSubpartition#add(BufferConsumer)} with a spilled partition where adding the  * write request fails with an exception.  */ @Test public void testAddOnSpilledPartitionWithFailingWriter() throws Exception {     IOManager ioManager = new IOManagerAsyncWithClosedBufferFileWriter().     SpillableSubpartition partition = createSubpartition(ioManager).     assertEquals(0, partition.releaseMemory()).     exception.expect(IOException.class).     BufferConsumer buffer = createFilledBufferConsumer(BUFFER_DATA_SIZE, BUFFER_DATA_SIZE).     boolean bufferRecycled.     try {         partition.add(buffer).     } finally {         ioManager.shutdown().         bufferRecycled = buffer.isRecycled().         if (!bufferRecycled) {             buffer.close().         }     }     if (!bufferRecycled) {         Assert.fail("buffer not recycled").     }     assertEquals(0, partition.getTotalNumberOfBuffers()).     assertEquals(0, partition.getTotalNumberOfBytes()). }
true;public;0;4;/**  * Tests cleanup of {@link SpillableSubpartition#release()} with a spillable partition and no  * read view attached.  */ ;/**  * Tests cleanup of {@link SpillableSubpartition#release()} with a spillable partition and no  * read view attached.  */ @Test public void testCleanupReleasedSpillablePartitionNoView() throws Exception {     testCleanupReleasedPartition(false, false). }
true;public;0;4;/**  * Tests cleanup of {@link SpillableSubpartition#release()} with a spillable partition and a  * read view attached - [FLINK-8371].  */ ;/**  * Tests cleanup of {@link SpillableSubpartition#release()} with a spillable partition and a  * read view attached - [FLINK-8371].  */ @Test public void testCleanupReleasedSpillablePartitionWithView() throws Exception {     testCleanupReleasedPartition(false, true). }
true;public;0;4;/**  * Tests cleanup of {@link SpillableSubpartition#release()} with a spilled partition and no  * read view attached.  */ ;/**  * Tests cleanup of {@link SpillableSubpartition#release()} with a spilled partition and no  * read view attached.  */ @Test public void testCleanupReleasedSpilledPartitionNoView() throws Exception {     testCleanupReleasedPartition(true, false). }
true;public;0;4;/**  * Tests cleanup of {@link SpillableSubpartition#release()} with a spilled partition and a  * read view attached.  */ ;/**  * Tests cleanup of {@link SpillableSubpartition#release()} with a spilled partition and a  * read view attached.  */ @Test public void testCleanupReleasedSpilledPartitionWithView() throws Exception {     testCleanupReleasedPartition(true, true). }
true;private;2;58;/**  * Tests cleanup of {@link SpillableSubpartition#release()}.  *  * @param spilled  * 		whether the partition should be spilled to disk (<tt>true</tt>) or not (<tt>false</tt>,  * 		spillable)  * @param createView  * 		whether the partition should have a view attached to it (<tt>true</tt>) or not (<tt>false</tt>)  */ ;/**  * Tests cleanup of {@link SpillableSubpartition#release()}.  *  * @param spilled  * 		whether the partition should be spilled to disk (<tt>true</tt>) or not (<tt>false</tt>,  * 		spillable)  * @param createView  * 		whether the partition should have a view attached to it (<tt>true</tt>) or not (<tt>false</tt>)  */ private void testCleanupReleasedPartition(boolean spilled, boolean createView) throws Exception {     SpillableSubpartition partition = createSubpartition().     BufferConsumer buffer1 = createFilledBufferConsumer(BUFFER_DATA_SIZE, BUFFER_DATA_SIZE).     BufferConsumer buffer2 = createFilledBufferConsumer(BUFFER_DATA_SIZE, BUFFER_DATA_SIZE).     boolean buffer1Recycled.     boolean buffer2Recycled.     try {         partition.add(buffer1).         partition.add(buffer2).         // create the read view before spilling         // (tests both code paths since this view may then contain the spilled view)         ResultSubpartitionView view = null.         if (createView) {             partition.finish().             view = partition.createReadView(new NoOpBufferAvailablityListener()).         }         if (spilled) {             // note: in case we create a view, one buffer will already reside in the view and             // one EndOfPartitionEvent will be added instead (so overall the number of             // buffers to spill is the same             assertEquals(2, partition.releaseMemory()).         }         partition.release().         assertTrue(partition.isReleased()).         if (createView) {             assertTrue(view.isReleased()).         }         assertTrue(buffer1.isRecycled()).     } finally {         buffer1Recycled = buffer1.isRecycled().         if (!buffer1Recycled) {             buffer1.close().         }         buffer2Recycled = buffer2.isRecycled().         if (!buffer2Recycled) {             buffer2.close().         }     }     if (!buffer1Recycled) {         Assert.fail("buffer 1 not recycled").     }     if (!buffer2Recycled) {         Assert.fail("buffer 2 not recycled").     }     // note: in case we create a view, there will be an additional EndOfPartitionEvent     assertEquals(createView ? 3 : 2, partition.getTotalNumberOfBuffers()).     if (spilled) {         // with a view, one buffer remains in nextBuffer and is not counted yet         assertEquals(BUFFER_DATA_SIZE + (createView ? 4 : BUFFER_DATA_SIZE), partition.getTotalNumberOfBytes()).     } else {         // non-spilled byte statistics are only updated when buffers are consumed         assertEquals(0, partition.getTotalNumberOfBytes()).     } }
true;public;0;13;/**  * Tests {@link SpillableSubpartition#spillFinishedBufferConsumers} spilled bytes and  * buffers counting.  */ ;/**  * Tests {@link SpillableSubpartition#spillFinishedBufferConsumers} spilled bytes and  * buffers counting.  */ @Test public void testSpillFinishedBufferConsumersFull() throws Exception {     SpillableSubpartition partition = createSubpartition().     BufferBuilder bufferBuilder = createBufferBuilder(BUFFER_DATA_SIZE).     partition.add(bufferBuilder.createBufferConsumer()).     assertEquals(0, partition.releaseMemory()).     assertEquals(1, partition.getBuffersInBacklog()).     // finally fill the buffer with some bytes     fillBufferBuilder(bufferBuilder, BUFFER_DATA_SIZE).finish().     assertEquals(BUFFER_DATA_SIZE, partition.spillFinishedBufferConsumers(false)).     assertEquals(1, partition.getBuffersInBacklog()). }
true;public;0;15;/**  * Tests {@link SpillableSubpartition#spillFinishedBufferConsumers} spilled bytes and  * buffers counting with partially filled buffers.  */ ;/**  * Tests {@link SpillableSubpartition#spillFinishedBufferConsumers} spilled bytes and  * buffers counting with partially filled buffers.  */ @Test public void testSpillFinishedBufferConsumersPartial() throws Exception {     SpillableSubpartition partition = createSubpartition().     BufferBuilder bufferBuilder = createBufferBuilder(BUFFER_DATA_SIZE * 2).     partition.add(bufferBuilder.createBufferConsumer()).     fillBufferBuilder(bufferBuilder, BUFFER_DATA_SIZE).     assertEquals(0, partition.releaseMemory()).     // partial one spilled, buffer consumer still enqueued     assertEquals(2, partition.getBuffersInBacklog()).     // finally fill the buffer with some bytes     fillBufferBuilder(bufferBuilder, BUFFER_DATA_SIZE).finish().     assertEquals(BUFFER_DATA_SIZE, partition.spillFinishedBufferConsumers(false)).     assertEquals(2, partition.getBuffersInBacklog()). }
false;public;1;7;;@Override public BufferFileWriter createBufferFileWriter(FileIOChannel.ID channelID) throws IOException {     BufferFileWriter bufferFileWriter = super.createBufferFileWriter(channelID).     bufferFileWriter.close().     return bufferFileWriter. }
