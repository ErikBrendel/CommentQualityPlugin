commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void setup() {     rpcService = new TestingRpcService(). }
false;public;0;6;;@After public void tearDown() throws ExecutionException, InterruptedException {     if (rpcService != null) {         rpcService.stopService().get().     } }
false;public;0;32;;@Test public void testSimpleSuccessfulRegistration() throws Exception {     final String testId = "laissez les bon temps roulez".     final String testEndpointAddress = "<test-address>".     final UUID leaderId = UUID.randomUUID().     // an endpoint that immediately returns success     TestRegistrationGateway testGateway = new TestRegistrationGateway(new TestRegistrationSuccess(testId)).     try {         rpcService.registerGateway(testEndpointAddress, testGateway).         TestRetryingRegistration registration = new TestRetryingRegistration(rpcService, testEndpointAddress, leaderId).         registration.startRegistration().         CompletableFuture<Tuple2<TestRegistrationGateway, TestRegistrationSuccess>> future = registration.getFuture().         assertNotNull(future).         // multiple accesses return the same future         assertEquals(future, registration.getFuture()).         Tuple2<TestRegistrationGateway, TestRegistrationSuccess> success = future.get(10L, TimeUnit.SECONDS).         // validate correct invocation and result         assertEquals(testId, success.f1.getCorrelationId()).         assertEquals(leaderId, testGateway.getInvocations().take().leaderId()).     } finally {         testGateway.stop().     } }
false;public;0;22;;@Test public void testPropagateFailures() throws Exception {     final String testExceptionMessage = "testExceptionMessage".     // RPC service that fails with exception upon the connection     RpcService rpc = mock(RpcService.class).     when(rpc.connect(anyString(), any(Class.class))).thenThrow(new RuntimeException(testExceptionMessage)).     TestRetryingRegistration registration = new TestRetryingRegistration(rpc, "testaddress", UUID.randomUUID()).     registration.startRegistration().     CompletableFuture<?> future = registration.getFuture().     assertTrue(future.isDone()).     try {         future.get().         fail("We expected an ExecutionException.").     } catch (ExecutionException e) {         assertEquals(testExceptionMessage, e.getCause().getMessage()).     } }
false;public;0;48;;@Test public void testRetryConnectOnFailure() throws Exception {     final String testId = "laissez les bon temps roulez".     final UUID leaderId = UUID.randomUUID().     ExecutorService executor = TestingUtils.defaultExecutor().     TestRegistrationGateway testGateway = new TestRegistrationGateway(new TestRegistrationSuccess(testId)).     try {         // RPC service that fails upon the first connection, but succeeds on the second         RpcService rpc = mock(RpcService.class).         when(rpc.connect(anyString(), any(Class.class))).thenReturn(// first connection attempt fails         FutureUtils.completedExceptionally(new Exception("test connect failure")), // second connection attempt succeeds         CompletableFuture.completedFuture(testGateway)).         when(rpc.getExecutor()).thenReturn(executor).         when(rpc.scheduleRunnable(any(Runnable.class), anyLong(), any(TimeUnit.class))).thenAnswer((InvocationOnMock invocation) -> {             final Runnable runnable = invocation.getArgument(0).             final long delay = invocation.getArgument(1).             final TimeUnit timeUnit = invocation.getArgument(2).             return TestingUtils.defaultScheduledExecutor().schedule(runnable, delay, timeUnit).         }).         TestRetryingRegistration registration = new TestRetryingRegistration(rpc, "foobar address", leaderId).         long start = System.currentTimeMillis().         registration.startRegistration().         Tuple2<TestRegistrationGateway, TestRegistrationSuccess> success = registration.getFuture().get(10L, TimeUnit.SECONDS).         // measure the duration of the registration --> should be longer than the error delay         long duration = System.currentTimeMillis() - start.         assertTrue("The registration should have failed the first time. Thus the duration should be longer than at least a single error delay.", duration > TestRetryingRegistration.DELAY_ON_ERROR).         // validate correct invocation and result         assertEquals(testId, success.f1.getCorrelationId()).         assertEquals(leaderId, testGateway.getInvocations().take().leaderId()).     } finally {         testGateway.stop().     } }
false;public;0;48;;@Test(timeout = 10000) public void testRetriesOnTimeouts() throws Exception {     final String testId = "rien ne va plus".     final String testEndpointAddress = "<test-address>".     final UUID leaderId = UUID.randomUUID().     // an endpoint that immediately returns futures with timeouts before returning a successful future     TestRegistrationGateway testGateway = new TestRegistrationGateway(// timeout     null, // timeout     null, // success     new TestRegistrationSuccess(testId)).     try {         rpcService.registerGateway(testEndpointAddress, testGateway).         final long initialTimeout = 20L.         TestRetryingRegistration registration = new TestRetryingRegistration(rpcService, testEndpointAddress, leaderId, new RetryingRegistrationConfiguration(initialTimeout, 1000L, // make sure that we timeout in case of an error         15000L, 15000L)).         long started = System.nanoTime().         registration.startRegistration().         CompletableFuture<Tuple2<TestRegistrationGateway, TestRegistrationSuccess>> future = registration.getFuture().         Tuple2<TestRegistrationGateway, TestRegistrationSuccess> success = future.get(10L, TimeUnit.SECONDS).         long finished = System.nanoTime().         long elapsedMillis = (finished - started) / 1000000.         // validate correct invocation and result         assertEquals(testId, success.f1.getCorrelationId()).         assertEquals(leaderId, testGateway.getInvocations().take().leaderId()).         // validate that some retry-delay / back-off behavior happened         assertTrue("retries did not properly back off", elapsedMillis >= 3 * initialTimeout).     } finally {         testGateway.stop().     } }
false;public;0;40;;@Test public void testDecline() throws Exception {     final String testId = "qui a coupe le fromage".     final String testEndpointAddress = "<test-address>".     final UUID leaderId = UUID.randomUUID().     TestRegistrationGateway testGateway = new TestRegistrationGateway(// timeout     null, new RegistrationResponse.Decline("no reason "), // timeout     null, // success     new TestRegistrationSuccess(testId)).     try {         rpcService.registerGateway(testEndpointAddress, testGateway).         TestRetryingRegistration registration = new TestRetryingRegistration(rpcService, testEndpointAddress, leaderId).         long started = System.nanoTime().         registration.startRegistration().         CompletableFuture<Tuple2<TestRegistrationGateway, TestRegistrationSuccess>> future = registration.getFuture().         Tuple2<TestRegistrationGateway, TestRegistrationSuccess> success = future.get(10L, TimeUnit.SECONDS).         long finished = System.nanoTime().         long elapsedMillis = (finished - started) / 1000000.         // validate correct invocation and result         assertEquals(testId, success.f1.getCorrelationId()).         assertEquals(leaderId, testGateway.getInvocations().take().leaderId()).         // validate that some retry-delay / back-off behavior happened         assertTrue("retries did not properly back off", elapsedMillis >= 2 * TestRetryingRegistration.INITIAL_TIMEOUT + TestRetryingRegistration.DELAY_ON_DECLINE).     } finally {         testGateway.stop().     } }
false;public;0;34;;@Test @SuppressWarnings("unchecked") public void testRetryOnError() throws Exception {     final String testId = "Petit a petit, l'oiseau fait son nid".     final String testEndpointAddress = "<test-address>".     final UUID leaderId = UUID.randomUUID().     // gateway that upon calls first responds with a failure, then with a success     TestRegistrationGateway testGateway = mock(TestRegistrationGateway.class).     when(testGateway.registrationCall(any(UUID.class), anyLong())).thenReturn(FutureUtils.completedExceptionally(new Exception("test exception")), CompletableFuture.completedFuture(new TestRegistrationSuccess(testId))).     rpcService.registerGateway(testEndpointAddress, testGateway).     TestRetryingRegistration registration = new TestRetryingRegistration(rpcService, testEndpointAddress, leaderId).     long started = System.nanoTime().     registration.startRegistration().     CompletableFuture<Tuple2<TestRegistrationGateway, TestRegistrationSuccess>> future = registration.getFuture().     Tuple2<TestRegistrationGateway, TestRegistrationSuccess> success = future.get(10, TimeUnit.SECONDS).     long finished = System.nanoTime().     long elapsedMillis = (finished - started) / 1000000.     assertEquals(testId, success.f1.getCorrelationId()).     // validate that some retry-delay / back-off behavior happened     assertTrue("retries did not properly back off", elapsedMillis >= TestRetryingRegistration.DELAY_ON_ERROR). }
false;public;0;22;;@Test public void testCancellation() throws Exception {     final String testEndpointAddress = "my-test-address".     final UUID leaderId = UUID.randomUUID().     CompletableFuture<RegistrationResponse> result = new CompletableFuture<>().     TestRegistrationGateway testGateway = mock(TestRegistrationGateway.class).     when(testGateway.registrationCall(any(UUID.class), anyLong())).thenReturn(result).     rpcService.registerGateway(testEndpointAddress, testGateway).     TestRetryingRegistration registration = new TestRetryingRegistration(rpcService, testEndpointAddress, leaderId).     registration.startRegistration().     // cancel and fail the current registration attempt     registration.cancel().     result.completeExceptionally(new TimeoutException()).     // there should not be a second registration attempt     verify(testGateway, atMost(1)).registrationCall(any(UUID.class), anyLong()). }
false;public;0;3;;public String getCorrelationId() {     return correlationId. }
false;protected;3;5;;@Override protected CompletableFuture<RegistrationResponse> invokeRegistration(TestRegistrationGateway gateway, UUID leaderId, long timeoutMillis) {     return gateway.registrationCall(leaderId, timeoutMillis). }
