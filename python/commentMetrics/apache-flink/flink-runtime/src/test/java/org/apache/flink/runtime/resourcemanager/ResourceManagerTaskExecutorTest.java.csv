commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setupClass() {     rpcService = new TestingRpcService(). }
false;public;0;16;;@Before public void setup() throws Exception {     rpcService = new TestingRpcService().     createAndRegisterTaskExecutorGateway().     taskExecutorResourceID = ResourceID.generate().     resourceManagerResourceID = ResourceID.generate().     testingFatalErrorHandler = new TestingFatalErrorHandler().     TestingLeaderElectionService rmLeaderElectionService = new TestingLeaderElectionService().     resourceManager = createAndStartResourceManager(rmLeaderElectionService, testingFatalErrorHandler).     rmGateway = resourceManager.getSelfGateway(ResourceManagerGateway.class).     wronglyFencedGateway = rpcService.connect(resourceManager.getAddress(), ResourceManagerId.generate(), ResourceManagerGateway.class).get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).     grantLeadership(rmLeaderElectionService).get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS). }
false;private;0;4;;private void createAndRegisterTaskExecutorGateway() {     taskExecutorGateway = new TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway().     rpcService.registerGateway(taskExecutorGateway.getAddress(), taskExecutorGateway). }
false;private;1;4;;private CompletableFuture<UUID> grantLeadership(TestingLeaderElectionService leaderElectionService) {     UUID leaderSessionId = UUID.randomUUID().     return leaderElectionService.isLeader(leaderSessionId). }
false;private;2;34;;private StandaloneResourceManager createAndStartResourceManager(LeaderElectionService rmLeaderElectionService, FatalErrorHandler fatalErrorHandler) throws Exception {     TestingHighAvailabilityServices highAvailabilityServices = new TestingHighAvailabilityServices().     HeartbeatServices heartbeatServices = new HeartbeatServices(1000L, 1000L).     highAvailabilityServices.setResourceManagerLeaderElectionService(rmLeaderElectionService).     SlotManager slotManager = new SlotManager(rpcService.getScheduledExecutor(), TestingUtils.infiniteTime(), TestingUtils.infiniteTime(), TestingUtils.infiniteTime()).     JobLeaderIdService jobLeaderIdService = new JobLeaderIdService(highAvailabilityServices, rpcService.getScheduledExecutor(), Time.minutes(5L)).     StandaloneResourceManager resourceManager = new StandaloneResourceManager(rpcService, ResourceManager.RESOURCE_MANAGER_NAME + UUID.randomUUID(), resourceManagerResourceID, highAvailabilityServices, heartbeatServices, slotManager, NoOpMetricRegistry.INSTANCE, jobLeaderIdService, new ClusterInformation("localhost", 1234), fatalErrorHandler, UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup()).     resourceManager.start().     return resourceManager. }
false;public;0;10;;@After public void teardown() throws Exception {     if (resourceManager != null) {         RpcUtils.terminateRpcEndpoint(resourceManager, TIMEOUT).     }     if (testingFatalErrorHandler != null && testingFatalErrorHandler.hasExceptionOccurred()) {         testingFatalErrorHandler.rethrowError().     } }
false;public,static;0;6;;@AfterClass public static void teardownClass() throws Exception {     if (rpcService != null) {         RpcUtils.terminateRpcService(rpcService, TIMEOUT).     } }
true;public;0;21;/**  * Test receive normal registration from task executor and receive duplicate registration  * from task executor.  */ ;/**  * Test receive normal registration from task executor and receive duplicate registration  * from task executor.  */ @Test public void testRegisterTaskExecutor() throws Exception {     // test response successful     CompletableFuture<RegistrationResponse> successfulFuture = registerTaskExecutor(rmGateway, taskExecutorGateway.getAddress()).     RegistrationResponse response = successfulFuture.get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).     assertTrue(response instanceof TaskExecutorRegistrationSuccess).     final TaskManagerInfo taskManagerInfo = rmGateway.requestTaskManagerInfo(taskExecutorResourceID, TIMEOUT).get().     assertThat(taskManagerInfo.getResourceId(), equalTo(taskExecutorResourceID)).     // test response successful with instanceID not equal to previous when receive duplicate registration from taskExecutor     CompletableFuture<RegistrationResponse> duplicateFuture = registerTaskExecutor(rmGateway, taskExecutorGateway.getAddress()).     RegistrationResponse duplicateResponse = duplicateFuture.get().     assertTrue(duplicateResponse instanceof TaskExecutorRegistrationSuccess).     assertNotEquals(((TaskExecutorRegistrationSuccess) response).getRegistrationId(), ((TaskExecutorRegistrationSuccess) duplicateResponse).getRegistrationId()).     assertThat(rmGateway.requestResourceOverview(TIMEOUT).get().getNumberTaskManagers(), is(1)). }
true;public;0;21;/**  * Tests that a TaskExecutor can disconnect from the {@link ResourceManager}.  */ ;/**  * Tests that a TaskExecutor can disconnect from the {@link ResourceManager}.  */ @Test public void testDisconnectTaskExecutor() throws Exception {     final RegistrationResponse registrationResponse = registerTaskExecutor(rmGateway, taskExecutorGateway.getAddress()).get().     assertThat(registrationResponse, instanceOf(TaskExecutorRegistrationSuccess.class)).     final InstanceID registrationId = ((TaskExecutorRegistrationSuccess) registrationResponse).getRegistrationId().     final int numberSlots = 10.     final Collection<SlotStatus> slots = createSlots(numberSlots).     final SlotReport slotReport = new SlotReport(slots).     rmGateway.sendSlotReport(taskExecutorResourceID, registrationId, slotReport, TIMEOUT).get().     final ResourceOverview resourceOverview = rmGateway.requestResourceOverview(TIMEOUT).get().     assertThat(resourceOverview.getNumberTaskManagers(), is(1)).     assertThat(resourceOverview.getNumberRegisteredSlots(), is(numberSlots)).     rmGateway.disconnectTaskManager(taskExecutorResourceID, new FlinkException("testDisconnectTaskExecutor")).     final ResourceOverview afterDisconnectResourceOverview = rmGateway.requestResourceOverview(TIMEOUT).get().     assertThat(afterDisconnectResourceOverview.getNumberTaskManagers(), is(0)).     assertThat(afterDisconnectResourceOverview.getNumberRegisteredSlots(), is(0)). }
false;private;1;6;;private Collection<SlotStatus> createSlots(int numberSlots) {     return IntStream.range(0, numberSlots).mapToObj(index -> new SlotStatus(new SlotID(taskExecutorResourceID, index), ResourceProfile.UNKNOWN)).collect(Collectors.toList()). }
true;public;0;12;/**  * Test receive registration with unmatched leadershipId from task executor.  */ ;/**  * Test receive registration with unmatched leadershipId from task executor.  */ @Test public void testRegisterTaskExecutorWithUnmatchedLeaderSessionId() throws Exception {     // test throw exception when receive a registration from taskExecutor which takes unmatched leaderSessionId     CompletableFuture<RegistrationResponse> unMatchedLeaderFuture = registerTaskExecutor(wronglyFencedGateway, taskExecutorGateway.getAddress()).     try {         unMatchedLeaderFuture.get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS).         fail("Should have failed because we are using a wrongly fenced ResourceManagerGateway.").     } catch (ExecutionException e) {         assertTrue(ExceptionUtils.stripExecutionException(e) instanceof FencingTokenException).     } }
true;public;0;8;/**  * Test receive registration with invalid address from task executor.  */ ;/**  * Test receive registration with invalid address from task executor.  */ @Test public void testRegisterTaskExecutorFromInvalidAddress() throws Exception {     // test throw exception when receive a registration from taskExecutor which takes invalid address     String invalidAddress = "/taskExecutor2".     CompletableFuture<RegistrationResponse> invalidAddressFuture = registerTaskExecutor(rmGateway, invalidAddress).     assertTrue(invalidAddressFuture.get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS) instanceof RegistrationResponse.Decline). }
false;private;2;8;;private CompletableFuture<RegistrationResponse> registerTaskExecutor(ResourceManagerGateway resourceManagerGateway, String taskExecutorAddress) {     return resourceManagerGateway.registerTaskExecutor(taskExecutorAddress, taskExecutorResourceID, dataPort, hardwareDescription, TIMEOUT). }
