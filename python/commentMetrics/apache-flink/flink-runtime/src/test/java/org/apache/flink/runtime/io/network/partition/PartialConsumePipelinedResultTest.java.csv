commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;7;;private static Configuration getFlinkConfiguration() {     final Configuration config = new Configuration().     config.setString(AkkaOptions.ASK_TIMEOUT, TestingUtils.DEFAULT_AKKA_ASK_TIMEOUT()).     config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, NUMBER_OF_NETWORK_BUFFERS).     return config. }
true;public;0;25;/**  * Tests a fix for FLINK-1930.  *  * <p>When consuming a pipelined result only partially, is is possible that local channels  * release the buffer pool, which is associated with the result partition, too early. If the  * producer is still producing data when this happens, it runs into an IllegalStateException,  * because of the destroyed buffer pool.  *  * @see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>  */ ;/**  * Tests a fix for FLINK-1930.  *  * <p>When consuming a pipelined result only partially, is is possible that local channels  * release the buffer pool, which is associated with the result partition, too early. If the  * producer is still producing data when this happens, it runs into an IllegalStateException,  * because of the destroyed buffer pool.  *  * @see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>  */ @Test public void testPartialConsumePipelinedResultReceiver() throws Exception {     final JobVertex sender = new JobVertex("Sender").     sender.setInvokableClass(SlowBufferSender.class).     sender.setParallelism(PARALLELISM).     final JobVertex receiver = new JobVertex("Receiver").     receiver.setInvokableClass(SingleBufferReceiver.class).     receiver.setParallelism(PARALLELISM).     // The partition needs to be pipelined, otherwise the original issue does not occur, because     // the sender and receiver are not online at the same time.     receiver.connectNewDataSetAsInput(sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).     final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver).     final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(sender.getID(), receiver.getID()).     sender.setSlotSharingGroup(slotSharingGroup).     receiver.setSlotSharingGroup(slotSharingGroup).     MINI_CLUSTER_RESOURCE.getMiniCluster().executeJobBlocking(jobGraph). }
false;public;0;11;;@Override public void invoke() throws Exception {     final ResultPartitionWriter writer = getEnvironment().getWriter(0).     for (int i = 0. i < 8. i++) {         final BufferBuilder bufferBuilder = writer.getBufferProvider().requestBufferBuilderBlocking().         writer.addBufferConsumer(bufferBuilder.createBufferConsumer(), 0).         Thread.sleep(50).         bufferBuilder.finish().     } }
false;public;0;8;;@Override public void invoke() throws Exception {     InputGate gate = getEnvironment().getInputGate(0).     Buffer buffer = gate.getNextBufferOrEvent().orElseThrow(IllegalStateException::new).getBuffer().     if (buffer != null) {         buffer.recycleBuffer().     } }
