commented;modifiers;parameterAmount;loc;comment;code
false;public;3;21;;public void addSlot(JobVertexID vertex, int subtaskIndex, CompletableFuture<LogicalSlot> future) {     checkNotNull(vertex).     checkNotNull(future).     checkArgument(subtaskIndex >= 0 && subtaskIndex < parallelism).     CompletableFuture<LogicalSlot>[] futures = slotFutures.get(vertex).     CompletableFuture<Boolean>[] requestedFutures = slotFutureRequested.get(vertex).     if (futures == null) {         @SuppressWarnings("unchecked")         CompletableFuture<LogicalSlot>[] newArray = (CompletableFuture<LogicalSlot>[]) new CompletableFuture<?>[parallelism].         futures = newArray.         slotFutures.put(vertex, futures).         requestedFutures = new CompletableFuture[parallelism].         slotFutureRequested.put(vertex, requestedFutures).     }     futures[subtaskIndex] = future.     requestedFutures[subtaskIndex] = new CompletableFuture<>(). }
false;public;2;15;;public void addSlots(JobVertexID vertex, CompletableFuture<LogicalSlot>[] futures) {     checkNotNull(vertex).     checkNotNull(futures).     checkArgument(futures.length == parallelism).     slotFutures.put(vertex, futures).     CompletableFuture<Boolean>[] requestedFutures = new CompletableFuture[futures.length].     for (int i = 0. i < futures.length. i++) {         requestedFutures[i] = new CompletableFuture<>().     }     slotFutureRequested.put(vertex, requestedFutures). }
false;public;2;3;;public CompletableFuture<Boolean> getSlotRequestedFuture(JobVertexID jobVertexId, int subtaskIndex) {     return slotFutureRequested.get(jobVertexId)[subtaskIndex]. }
false;public;0;3;;public Set<SlotRequestId> getSlotRequests() {     return Collections.unmodifiableSet(slotRequests). }
false;public;0;3;;public Set<SlotRequestId> getCanceledSlotRequests() {     return Collections.unmodifiableSet(canceledSlotRequests). }
false;public;5;23;;@Override public CompletableFuture<LogicalSlot> allocateSlot(SlotRequestId slotRequestId, ScheduledUnit task, SlotProfile slotProfile, boolean allowQueued, Time allocationTimeout) {     JobVertexID vertexId = task.getTaskToExecute().getVertex().getJobvertexId().     int subtask = task.getTaskToExecute().getParallelSubtaskIndex().     CompletableFuture<LogicalSlot>[] forTask = slotFutures.get(vertexId).     if (forTask != null) {         CompletableFuture<LogicalSlot> future = forTask[subtask].         if (future != null) {             slotFutureRequested.get(vertexId)[subtask].complete(true).             slotRequests.add(slotRequestId).             return future.         }     }     throw new IllegalArgumentException("No registered slot future for task " + vertexId + " (" + subtask + ')'). }
false;public;3;7;;@Override public void cancelSlotRequest(SlotRequestId slotRequestId, @Nullable SlotSharingGroupId slotSharingGroupId, Throwable cause) {     canceledSlotRequests.add(slotRequestId). }
false;public;1;4;;@Override public void start(@Nonnull ComponentMainThreadExecutor mainThreadExecutor) { }
false;public;0;4;;@Override public boolean requiresPreviousExecutionGraphAllocations() {     return false. }
false;public;1;4;;@Override public void returnLogicalSlot(LogicalSlot logicalSlot) {     throw new UnsupportedOperationException(). }
