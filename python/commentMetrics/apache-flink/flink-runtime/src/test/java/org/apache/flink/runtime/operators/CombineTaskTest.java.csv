commented;modifiers;parameterAmount;loc;comment;code
false;public;0;38;;@Test public void testCombineTask() {     try {         int keyCnt = 100.         int valCnt = 20.         setInput(new UniformIntTupleGenerator(keyCnt, valCnt, false), serializer).         addDriverComparator(this.comparator).         addDriverComparator(this.comparator).         setOutput(this.outList, serializer).         getTaskConfig().setDriverStrategy(DriverStrategy.SORTED_GROUP_COMBINE).         getTaskConfig().setRelativeMemoryDriver(combine_frac).         getTaskConfig().setFilehandlesDriver(2).         final GroupReduceCombineDriver<Tuple2<Integer, Integer>, Tuple2<Integer, Integer>> testTask = new GroupReduceCombineDriver<>().         testDriver(testTask, MockCombiningReduceStub.class).         int expSum = 0.         for (int i = 1. i < valCnt. i++) {             expSum += i.         }         assertTrue(this.outList.size() == keyCnt).         for (Tuple2<Integer, Integer> record : this.outList) {             assertTrue(record.f1 == expSum).         }         this.outList.clear().     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;31;;@Test public void testFailingCombineTask() {     try {         int keyCnt = 100.         int valCnt = 20.         setInput(new UniformIntTupleGenerator(keyCnt, valCnt, false), serializer).         addDriverComparator(this.comparator).         addDriverComparator(this.comparator).         setOutput(new DiscardingOutputCollector<Tuple2<Integer, Integer>>()).         getTaskConfig().setDriverStrategy(DriverStrategy.SORTED_GROUP_COMBINE).         getTaskConfig().setRelativeMemoryDriver(combine_frac).         getTaskConfig().setFilehandlesDriver(2).         final GroupReduceCombineDriver<Tuple2<Integer, Integer>, Tuple2<Integer, Integer>> testTask = new GroupReduceCombineDriver<>().         try {             testDriver(testTask, MockFailingCombiningReduceStub.class).             fail("Exception not forwarded.").         } catch (ExpectedTestException etex) {         // good!         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;9;;@Override public void run() {     try {         testDriver(testTask, MockFailingCombiningReduceStub.class).     } catch (Exception e) {     // exceptions may happen during canceling     } }
false;public;0;52;;@Test public void testCancelCombineTaskSorting() {     try {         MutableObjectIterator<Tuple2<Integer, Integer>> slowInfiniteInput = new DelayingIterator<>(new InfiniteIntTupleIterator(), 1).         setInput(slowInfiniteInput, serializer).         addDriverComparator(this.comparator).         addDriverComparator(this.comparator).         setOutput(new DiscardingOutputCollector<Tuple2<Integer, Integer>>()).         getTaskConfig().setDriverStrategy(DriverStrategy.SORTED_GROUP_COMBINE).         getTaskConfig().setRelativeMemoryDriver(combine_frac).         getTaskConfig().setFilehandlesDriver(2).         final GroupReduceCombineDriver<Tuple2<Integer, Integer>, Tuple2<Integer, Integer>> testTask = new GroupReduceCombineDriver<>().         Thread taskRunner = new Thread() {              @Override             public void run() {                 try {                     testDriver(testTask, MockFailingCombiningReduceStub.class).                 } catch (Exception e) {                 // exceptions may happen during canceling                 }             }         }.         taskRunner.start().         // give the task some time         Thread.sleep(500).         // cancel         testTask.cancel().         // make sure it reacts to the canceling in some time         long deadline = System.currentTimeMillis() + 10000.         do {             taskRunner.interrupt().             taskRunner.join(5000).         } while (taskRunner.isAlive() && System.currentTimeMillis() < deadline).         assertFalse("Task did not cancel properly within in 10 seconds.", taskRunner.isAlive()).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;12;;@Override public void reduce(Iterable<Tuple2<Integer, Integer>> records, Collector<Tuple2<Integer, Integer>> out) {     int key = 0.     int sum = 0.     for (Tuple2<Integer, Integer> next : records) {         key = next.f0.         sum += next.f1.     }     out.collect(new Tuple2<>(key, sum)). }
false;public;2;4;;@Override public void combine(Iterable<Tuple2<Integer, Integer>> records, Collector<Tuple2<Integer, Integer>> out) {     reduce(records, out). }
false;public;2;13;;@Override public void reduce(Iterable<Tuple2<Integer, Integer>> records, Collector<Tuple2<Integer, Integer>> out) {     int key = 0.     int sum = 0.     for (Tuple2<Integer, Integer> next : records) {         key = next.f0.         sum += next.f1.     }     int resultValue = sum - key.     out.collect(new Tuple2<>(key, resultValue)). }
false;public;2;17;;@Override public void combine(Iterable<Tuple2<Integer, Integer>> records, Collector<Tuple2<Integer, Integer>> out) {     int key = 0.     int sum = 0.     for (Tuple2<Integer, Integer> next : records) {         key = next.f0.         sum += next.f1.     }     if (++this.cnt >= 10) {         throw new ExpectedTestException().     }     int resultValue = sum - key.     out.collect(new Tuple2<>(key, resultValue)). }
