commented;modifiers;parameterAmount;loc;comment;code
false;public;0;31;;@Test public void testSingleLevelMergeReduceTask() {     final int keyCnt = 8192.     final int valCnt = 8.     setNumFileHandlesForSort(2).     addDriverComparator(this.comparator).     setOutput(this.outList).     getTaskConfig().setDriverStrategy(DriverStrategy.SORTED_GROUP_REDUCE).     try {         addInputSorted(new UniformRecordGenerator(keyCnt, valCnt, false), this.comparator.duplicate()).         GroupReduceDriver<Record, Record> testTask = new GroupReduceDriver<>().         testDriver(testTask, MockReduceStub.class).     } catch (Exception e) {         LOG.info("Exception while running the test task.", e).         Assert.fail("Exception in Test: " + e.getMessage()).     }     Assert.assertTrue("Resultset size was " + this.outList.size() + ". Expected was " + keyCnt, this.outList.size() == keyCnt).     for (Record record : this.outList) {         Assert.assertTrue("Incorrect result", record.getField(1, IntValue.class).getValue() == valCnt - record.getField(0, IntValue.class).getValue()).     }     this.outList.clear(). }
false;public;0;31;;@Test public void testMultiLevelMergeReduceTask() {     final int keyCnt = 32768.     final int valCnt = 8.     setNumFileHandlesForSort(2).     addDriverComparator(this.comparator).     setOutput(this.outList).     getTaskConfig().setDriverStrategy(DriverStrategy.SORTED_GROUP_REDUCE).     try {         addInputSorted(new UniformRecordGenerator(keyCnt, valCnt, false), this.comparator.duplicate()).         GroupReduceDriver<Record, Record> testTask = new GroupReduceDriver<>().         testDriver(testTask, MockReduceStub.class).     } catch (Exception e) {         LOG.info("Exception while running the test task.", e).         Assert.fail("Exception in Test: " + e.getMessage()).     }     Assert.assertTrue("Resultset size was " + this.outList.size() + ". Expected was " + keyCnt, this.outList.size() == keyCnt).     for (Record record : this.outList) {         Assert.assertTrue("Incorrect result", record.getField(1, IntValue.class).getValue() == valCnt - record.getField(0, IntValue.class).getValue()).     }     this.outList.clear(). }
false;public;0;44;;@Test public void testSingleLevelMergeCombiningReduceTask() {     final int keyCnt = 8192.     final int valCnt = 8.     addDriverComparator(this.comparator).     setOutput(this.outList).     getTaskConfig().setDriverStrategy(DriverStrategy.SORTED_GROUP_REDUCE).     CombiningUnilateralSortMerger<Record> sorter = null.     try {         sorter = new CombiningUnilateralSortMerger<>(new MockCombiningReduceStub(), getMemoryManager(), getIOManager(), new UniformRecordGenerator(keyCnt, valCnt, false), getContainingTask(), RecordSerializerFactory.get(), this.comparator.duplicate(), this.perSortFractionMem, 2, 0.8f, true, /* use large record handler */         true).         addInput(sorter.getIterator()).         GroupReduceDriver<Record, Record> testTask = new GroupReduceDriver<>().         testDriver(testTask, MockCombiningReduceStub.class).     } catch (Exception e) {         LOG.info("Exception while running the test task.", e).         Assert.fail("Invoke method caused exception: " + e.getMessage()).     } finally {         if (sorter != null) {             sorter.close().         }     }     int expSum = 0.     for (int i = 1. i < valCnt. i++) {         expSum += i.     }     Assert.assertTrue("Resultset size was " + this.outList.size() + ". Expected was " + keyCnt, this.outList.size() == keyCnt).     for (Record record : this.outList) {         Assert.assertTrue("Incorrect result", record.getField(1, IntValue.class).getValue() == expSum - record.getField(0, IntValue.class).getValue()).     }     this.outList.clear(). }
false;public;0;45;;@Test public void testMultiLevelMergeCombiningReduceTask() {     int keyCnt = 32768.     int valCnt = 8.     addDriverComparator(this.comparator).     setOutput(this.outList).     getTaskConfig().setDriverStrategy(DriverStrategy.SORTED_GROUP_REDUCE).     CombiningUnilateralSortMerger<Record> sorter = null.     try {         sorter = new CombiningUnilateralSortMerger<>(new MockCombiningReduceStub(), getMemoryManager(), getIOManager(), new UniformRecordGenerator(keyCnt, valCnt, false), getContainingTask(), RecordSerializerFactory.get(), this.comparator.duplicate(), this.perSortFractionMem, 2, 0.8f, true, /* use large record handler */         false).         addInput(sorter.getIterator()).         GroupReduceDriver<Record, Record> testTask = new GroupReduceDriver<>().         testDriver(testTask, MockCombiningReduceStub.class).     } catch (Exception e) {         LOG.info("Exception while running the test task.", e).         Assert.fail("Invoke method caused exception: " + e.getMessage()).     } finally {         if (sorter != null) {             sorter.close().         }     }     int expSum = 0.     for (int i = 1. i < valCnt. i++) {         expSum += i.     }     Assert.assertTrue("Resultset size was " + this.outList.size() + ". Expected was " + keyCnt, this.outList.size() == keyCnt).     for (Record record : this.outList) {         Assert.assertTrue("Incorrect result", record.getField(1, IntValue.class).getValue() == expSum - record.getField(0, IntValue.class).getValue()).     }     this.outList.clear(). }
false;public;2;14;;@Override public void reduce(Iterable<Record> records, Collector<Record> out) {     Record element = null.     int cnt = 0.     for (Record next : records) {         element = next.         cnt++.     }     element.getField(0, this.key).     this.value.setValue(cnt - this.key.getValue()).     element.setField(1, this.value).     out.collect(element). }
false;public;2;16;;@Override public void reduce(Iterable<Record> records, Collector<Record> out) {     Record element = null.     int sum = 0.     for (Record next : records) {         element = next.         element.getField(1, this.value).         sum += this.value.getValue().     }     element.getField(0, this.key).     this.value.setValue(sum - this.key.getValue()).     element.setField(1, this.value).     out.collect(element). }
false;public;2;16;;@Override public void combine(Iterable<Record> records, Collector<Record> out) {     Record element = null.     int sum = 0.     for (Record next : records) {         element = next.         element.getField(1, this.combineValue).         sum += this.combineValue.getValue().     }     this.combineValue.setValue(sum).     element.setField(1, this.combineValue).     out.collect(element). }
