commented;modifiers;parameterAmount;loc;comment;code
false;public;0;40;;@Override public void before() throws Exception {     temporaryFolder.create().     Configuration config = new Configuration().     config.setString(RestOptions.BIND_PORT, "0").     config.setString(RestOptions.ADDRESS, "localhost").     // set this to a lower value on purpose to test that files larger than the content limit are still accepted     config.setInteger(RestOptions.SERVER_MAX_CONTENT_LENGTH, 1024 * 1024).     configuredUploadDir = temporaryFolder.newFolder().toPath().     config.setString(WebOptions.UPLOAD_DIR, configuredUploadDir.toString()).     RestServerEndpointConfiguration serverConfig = RestServerEndpointConfiguration.fromConfiguration(config).     RestfulGateway mockRestfulGateway = mock(RestfulGateway.class).     final GatewayRetriever<RestfulGateway> mockGatewayRetriever = () -> CompletableFuture.completedFuture(mockRestfulGateway).     file1 = temporaryFolder.newFile().     try (RandomAccessFile rw = new RandomAccessFile(file1, "rw")) {         rw.setLength(1024 * 1024 * 64).     }     file2 = temporaryFolder.newFile().     Files.write(file2.toPath(), "world".getBytes(ConfigConstants.DEFAULT_CHARSET)).     mixedHandler = new MultipartMixedHandler(mockGatewayRetriever, Arrays.asList(file1.toPath(), file2.toPath())).     jsonHandler = new MultipartJsonHandler(mockGatewayRetriever).     fileHandler = new MultipartFileHandler(mockGatewayRetriever, Arrays.asList(file1.toPath(), file2.toPath())).     final List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> handlers = Arrays.asList(Tuple2.of(mixedHandler.getMessageHeaders(), mixedHandler), Tuple2.of(jsonHandler.getMessageHeaders(), jsonHandler), Tuple2.of(fileHandler.getMessageHeaders(), fileHandler)).     serverEndpoint = new TestRestServerEndpoint(serverConfig, handlers).     serverEndpoint.start().     serverAddress = serverEndpoint.getRestBaseUrl().     serverSocketAddress = serverEndpoint.getServerAddress(). }
false;public;0;3;;public Collection<File> getFilesToUpload() {     return Arrays.asList(file1, file2). }
false;public;0;3;;public String getServerAddress() {     return serverAddress. }
false;public;0;3;;public InetSocketAddress getServerSocketAddress() {     return serverSocketAddress. }
false;public;0;3;;public MultipartMixedHandler getMixedHandler() {     return mixedHandler. }
false;public;0;3;;public MultipartFileHandler getFileHandler() {     return fileHandler. }
false;public;0;3;;public MultipartJsonHandler getJsonHandler() {     return jsonHandler. }
false;public;0;3;;public Path getUploadDirectory() {     return configuredUploadDir. }
false;public;0;4;;public void resetState() {     mixedHandler.lastReceivedRequest = null.     jsonHandler.lastReceivedRequest = null. }
false;public;0;12;;@Override public void after() {     temporaryFolder.delete().     if (serverEndpoint != null) {         try {             serverEndpoint.close().         } catch (Exception e) {             LOG.warn("Could not properly shutdown RestServerEndpoint.", e).         }         serverEndpoint = null.     } }
false;public;0;13;;public void assertUploadDirectoryIsEmpty() throws IOException {     Path actualUploadDir.     try (Stream<Path> containedFiles = Files.list(configuredUploadDir)) {         List<Path> files = containedFiles.collect(Collectors.toList()).         Preconditions.checkArgument(1 == files.size(), "Directory structure in rest upload directory has changed. Test must be adjusted").         actualUploadDir = files.get(0).     }     try (Stream<Path> containedFiles = Files.list(actualUploadDir)) {         assertEquals("Not all files were cleaned up.", 0, containedFiles.count()).     } }
false;protected;2;6;;@Override protected CompletableFuture<EmptyResponseBody> handleRequest(@Nonnull HandlerRequest<TestRequestBody, EmptyMessageParameters> request, @Nonnull RestfulGateway gateway) throws RestHandlerException {     MultipartFileHandler.verifyFileUpload(expectedFiles, request.getUploadedFiles().stream().map(File::toPath).collect(Collectors.toList())).     this.lastReceivedRequest = request.getRequestBody().     return CompletableFuture.completedFuture(EmptyResponseBody.getInstance()). }
false;public;0;4;;@Override public Class<TestRequestBody> getRequestClass() {     return TestRequestBody.class. }
false;public;0;4;;@Override public Class<EmptyResponseBody> getResponseClass() {     return EmptyResponseBody.class. }
false;public;0;4;;@Override public HttpResponseStatus getResponseStatusCode() {     return HttpResponseStatus.OK. }
false;public;0;4;;@Override public String getDescription() {     return "". }
false;public;0;4;;@Override public EmptyMessageParameters getUnresolvedMessageParameters() {     return EmptyMessageParameters.getInstance(). }
false;public;0;4;;@Override public HttpMethodWrapper getHttpMethod() {     return HttpMethodWrapper.POST. }
false;public;0;4;;@Override public String getTargetRestEndpointURL() {     return "/test/upload/mixed". }
false;public;0;4;;@Override public boolean acceptsFileUploads() {     return true. }
false;protected;2;9;;@Override protected CompletableFuture<EmptyResponseBody> handleRequest(@Nonnull HandlerRequest<TestRequestBody, EmptyMessageParameters> request, @Nonnull RestfulGateway gateway) throws RestHandlerException {     Collection<Path> uploadedFiles = request.getUploadedFiles().stream().map(File::toPath).collect(Collectors.toList()).     if (!uploadedFiles.isEmpty()) {         throw new RestHandlerException("This handler should not have received file uploads.", HttpResponseStatus.INTERNAL_SERVER_ERROR).     }     this.lastReceivedRequest = request.getRequestBody().     return CompletableFuture.completedFuture(EmptyResponseBody.getInstance()). }
false;public;0;4;;@Override public Class<TestRequestBody> getRequestClass() {     return TestRequestBody.class. }
false;public;0;4;;@Override public String getTargetRestEndpointURL() {     return "/test/upload/json". }
false;public;0;4;;@Override public boolean acceptsFileUploads() {     return false. }
false;protected;2;5;;@Override protected CompletableFuture<EmptyResponseBody> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, EmptyMessageParameters> request, @Nonnull RestfulGateway gateway) throws RestHandlerException {     verifyFileUpload(expectedFiles, request.getUploadedFiles().stream().map(File::toPath).collect(Collectors.toList())).     return CompletableFuture.completedFuture(EmptyResponseBody.getInstance()). }
false;static;2;24;;static void verifyFileUpload(Collection<Path> expectedFiles, Collection<Path> uploadedFiles) throws RestHandlerException {     try {         assertEquals(expectedFiles.size(), uploadedFiles.size()).         List<Path> expectedList = new ArrayList<>(expectedFiles).         List<Path> actualList = new ArrayList<>(uploadedFiles).         expectedList.sort(Comparator.comparing(Path::toString)).         actualList.sort(Comparator.comparing(Path::toString)).         for (int x = 0. x < expectedList.size(). x++) {             Path expected = expectedList.get(x).             Path actual = actualList.get(x).             assertEquals(expected.getFileName().toString(), actual.getFileName().toString()).             byte[] originalContent = Files.readAllBytes(expected).             byte[] receivedContent = Files.readAllBytes(actual).             assertArrayEquals(originalContent, receivedContent).         }     } catch (Exception e) {         // return 505 to differentiate from common BAD_REQUEST responses in this test         throw new RestHandlerException("Test verification failed.", HttpResponseStatus.INTERNAL_SERVER_ERROR, e).     } }
false;public;0;4;;@Override public Class<EmptyRequestBody> getRequestClass() {     return EmptyRequestBody.class. }
false;public;0;4;;@Override public String getTargetRestEndpointURL() {     return "/test/upload/file". }
false;public;0;4;;@Override public boolean acceptsFileUploads() {     return true. }
false;public;0;4;;@Override public Class<EmptyResponseBody> getResponseClass() {     return EmptyResponseBody.class. }
false;public;0;4;;@Override public HttpResponseStatus getResponseStatusCode() {     return HttpResponseStatus.OK. }
false;public;0;4;;@Override public String getDescription() {     return "". }
false;public;0;4;;@Override public EmptyMessageParameters getUnresolvedMessageParameters() {     return EmptyMessageParameters.getInstance(). }
false;public;0;4;;@Override public HttpMethodWrapper getHttpMethod() {     return HttpMethodWrapper.POST. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     TestRequestBody that = (TestRequestBody) o.     return index == that.index. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(index). }
false;public;0;6;;@Override public String toString() {     return "TestRequestBody{" + "index=" + index + '}'. }
false;protected;1;4;;@Override protected List<Tuple2<RestHandlerSpecification, ChannelInboundHandler>> initializeHandlers(final CompletableFuture<String> localAddressFuture) {     return handlers. }
false;protected;0;3;;@Override protected void startInternal() { }
