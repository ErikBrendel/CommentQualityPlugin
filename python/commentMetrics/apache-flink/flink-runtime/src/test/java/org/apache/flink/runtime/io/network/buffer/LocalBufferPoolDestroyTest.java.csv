commented;modifiers;parameterAmount;loc;comment;code
true;public;0;57;/**  * Tests that a blocking request fails properly if the buffer pool is  * destroyed.  *  * <p>Starts a Thread, which triggers an unsatisfiable blocking buffer  * request. After making sure that the Thread is actually waiting in the  * blocking call, the buffer pool is destroyed and we check whether the  * request Thread threw the expected Exception.  */ ;/**  * Tests that a blocking request fails properly if the buffer pool is  * destroyed.  *  * <p>Starts a Thread, which triggers an unsatisfiable blocking buffer  * request. After making sure that the Thread is actually waiting in the  * blocking call, the buffer pool is destroyed and we check whether the  * request Thread threw the expected Exception.  */ @Test public void testDestroyWhileBlockingRequest() throws Exception {     AtomicReference<Exception> asyncException = new AtomicReference<>().     NetworkBufferPool networkBufferPool = null.     LocalBufferPool localBufferPool = null.     try {         networkBufferPool = new NetworkBufferPool(1, 4096).         localBufferPool = new LocalBufferPool(networkBufferPool, 1).         // Drain buffer pool         assertNotNull(localBufferPool.requestBuffer()).         assertNull(localBufferPool.requestBuffer()).         // Start request Thread         Thread thread = new Thread(new BufferRequestTask(localBufferPool, asyncException)).         thread.start().         // Wait for request         boolean success = false.         for (int i = 0. i < 50. i++) {             StackTraceElement[] stackTrace = thread.getStackTrace().             success = isInBlockingBufferRequest(stackTrace).             if (success) {                 break.             } else {                 // Retry                 Thread.sleep(500).             }         }         // Verify that Thread was in blocking request         assertTrue("Did not trigger blocking buffer request.", success).         // Destroy the buffer pool         localBufferPool.lazyDestroy().         // Wait for Thread to finish         thread.join().         // Verify expected Exception         assertNotNull("Did not throw expected Exception", asyncException.get()).         assertTrue(asyncException.get() instanceof IllegalStateException).     } finally {         if (localBufferPool != null) {             localBufferPool.lazyDestroy().         }         if (networkBufferPool != null) {             networkBufferPool.destroyAllBufferPools().             networkBufferPool.destroy().         }     } }
true;public,static;1;8;/**  * Returns whether the stack trace represents a Thread in a blocking buffer  * request.  *  * @param stackTrace Stack trace of the Thread to check  *  * @return Flag indicating whether the Thread is in a blocking buffer  * request or not  */ ;/**  * Returns whether the stack trace represents a Thread in a blocking buffer  * request.  *  * @param stackTrace Stack trace of the Thread to check  *  * @return Flag indicating whether the Thread is in a blocking buffer  * request or not  */ public static boolean isInBlockingBufferRequest(StackTraceElement[] stackTrace) {     if (stackTrace.length >= 3) {         return stackTrace[0].getMethodName().equals("wait") && stackTrace[1].getClassName().equals(LocalBufferPool.class.getName()).     } else {         return false.     } }
false;public;0;11;;@Override public void run() {     try {         String msg = "Test assumption violated: expected no available buffer".         assertNull(msg, bufferPool.requestBuffer()).         bufferPool.requestBufferBlocking().     } catch (Exception t) {         asyncException.set(t).     } }
