commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Test public void testConcurrentModificationOnce() {     try {         final int numSegments = 10000.         final int segmentSize = 4096.         MemoryManager memMan = new MemoryManager(numSegments * segmentSize, 1, segmentSize, MemoryType.HEAP, true).         ArrayList<MemorySegment> segs = new ListWithConcModExceptionOnFirstAccess<>().         memMan.allocatePages(this, segs, numSegments).         memMan.release(segs).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;33;;@Test public void testConcurrentModificationWhileReleasing() {     try {         final int numSegments = 10000.         final int segmentSize = 4096.         MemoryManager memMan = new MemoryManager(numSegments * segmentSize, 1, segmentSize, MemoryType.HEAP, true).         ArrayList<MemorySegment> segs = new ArrayList<>(numSegments).         memMan.allocatePages(this, segs, numSegments).         // start a thread that performs concurrent modifications         Modifier mod = new Modifier(segs).         Thread modRunner = new Thread(mod).         modRunner.start().         // give the thread some time to start working         Thread.sleep(500).         try {             memMan.release(segs).         } finally {             mod.cancel().         }         modRunner.join().     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;3;;public void cancel() {     running = false. }
false;public;0;12;;@Override public void run() {     while (running) {         try {             MemorySegment seg = toModify.remove(0).             toModify.add(seg).         } catch (IndexOutOfBoundsException e) {         // may happen, just retry         }     } }
false;public;0;10;;@Override public Iterator<E> iterator() {     if (returnedIterator) {         return super.iterator().     } else {         returnedIterator = true.         return new ConcFailingIterator<>().     } }
false;public;0;4;;@Override public boolean hasNext() {     return true. }
false;public;0;4;;@Override public E next() {     throw new ConcurrentModificationException(). }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
