commented;modifiers;parameterAmount;loc;comment;code
false;public;0;19;;@Test public void testConnectDirectly() {     JobVertex source = new JobVertex("source").     JobVertex target = new JobVertex("target").     target.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).     assertTrue(source.isInputVertex()).     assertFalse(source.isOutputVertex()).     assertFalse(target.isInputVertex()).     assertTrue(target.isOutputVertex()).     assertEquals(1, source.getNumberOfProducedIntermediateDataSets()).     assertEquals(1, target.getNumberOfInputs()).     assertEquals(target.getInputs().get(0).getSource(), source.getProducedDataSets().get(0)).     assertEquals(1, source.getProducedDataSets().get(0).getConsumers().size()).     assertEquals(target, source.getProducedDataSets().get(0).getConsumers().get(0).getTarget()). }
false;public;0;21;;@Test public void testConnectMultipleTargets() {     JobVertex source = new JobVertex("source").     JobVertex target1 = new JobVertex("target1").     JobVertex target2 = new JobVertex("target2").     target1.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).     target2.connectDataSetAsInput(source.getProducedDataSets().get(0), DistributionPattern.ALL_TO_ALL).     assertTrue(source.isInputVertex()).     assertFalse(source.isOutputVertex()).     assertFalse(target1.isInputVertex()).     assertTrue(target1.isOutputVertex()).     assertFalse(target2.isInputVertex()).     assertTrue(target2.isOutputVertex()).     assertEquals(1, source.getNumberOfProducedIntermediateDataSets()).     assertEquals(2, source.getProducedDataSets().get(0).getConsumers().size()).     assertEquals(target1.getInputs().get(0).getSource(), source.getProducedDataSets().get(0)).     assertEquals(target2.getInputs().get(0).getSource(), source.getProducedDataSets().get(0)). }
false;public;0;38;;@Test public void testOutputFormatVertex() {     try {         final OutputFormat outputFormat = new TestingOutputFormat().         final OutputFormatVertex of = new OutputFormatVertex("Name").         new TaskConfig(of.getConfiguration()).setStubWrapper(new UserCodeObjectWrapper<OutputFormat<?>>(outputFormat)).         final ClassLoader cl = new TestClassLoader().         try {             of.initializeOnMaster(cl).             fail("Did not throw expected exception.").         } catch (TestException e) {         // all good         }         OutputFormatVertex copy = InstantiationUtil.clone(of).         ClassLoader ctxCl = Thread.currentThread().getContextClassLoader().         try {             copy.initializeOnMaster(cl).             fail("Did not throw expected exception.").         } catch (TestException e) {         // all good         }         assertEquals("Previous classloader was not restored.", ctxCl, Thread.currentThread().getContextClassLoader()).         try {             copy.finalizeOnMaster(cl).             fail("Did not throw expected exception.").         } catch (TestException e) {         // all good         }         assertEquals("Previous classloader was not restored.", ctxCl, Thread.currentThread().getContextClassLoader()).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;21;;@Test public void testInputFormatVertex() {     try {         final TestInputFormat inputFormat = new TestInputFormat().         final InputFormatVertex vertex = new InputFormatVertex("Name").         new TaskConfig(vertex.getConfiguration()).setStubWrapper(new UserCodeObjectWrapper<InputFormat<?, ?>>(inputFormat)).         final ClassLoader cl = getClass().getClassLoader().         vertex.initializeOnMaster(cl).         InputSplit[] splits = vertex.getInputSplitSource().createInputSplits(77).         assertNotNull(splits).         assertEquals(1, splits.length).         assertEquals(TestSplit.class, splits[0].getClass()).     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;4;;@Override public boolean reachedEnd() {     return false. }
false;public;1;4;;@Override public Object nextRecord(Object reuse) {     return null. }
false;public;1;4;;@Override public GenericInputSplit[] createInputSplits(int numSplits) throws IOException {     return new GenericInputSplit[] { new TestSplit(0, 1) }. }
false;public;1;11;;@Override public void initializeGlobal(int parallelism) throws IOException {     if (!isConfigured) {         throw new IllegalStateException("OutputFormat was not configured before initializeGlobal was called.").     }     if (!(Thread.currentThread().getContextClassLoader() instanceof TestClassLoader)) {         throw new IllegalStateException("Context ClassLoader was not correctly switched.").     }     // notify we have been here.     throw new TestException(). }
false;public;1;11;;@Override public void finalizeGlobal(int parallelism) throws IOException {     if (!isConfigured) {         throw new IllegalStateException("OutputFormat was not configured before finalizeGlobal was called.").     }     if (!(Thread.currentThread().getContextClassLoader() instanceof TestClassLoader)) {         throw new IllegalStateException("Context ClassLoader was not correctly switched.").     }     // notify we have been here.     throw new TestException(). }
false;public;1;10;;@Override public void configure(Configuration parameters) {     if (isConfigured) {         throw new IllegalStateException("OutputFormat is already configured.").     }     if (!(Thread.currentThread().getContextClassLoader() instanceof TestClassLoader)) {         throw new IllegalStateException("Context ClassLoader was not correctly switched.").     }     isConfigured = true. }
