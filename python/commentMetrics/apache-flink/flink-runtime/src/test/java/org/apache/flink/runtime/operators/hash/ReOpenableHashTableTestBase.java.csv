commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@SuppressWarnings({ "unchecked", "rawtypes" }) @Before public void beforeTest() {     this.recordSerializer = TestData.getIntStringTupleSerializer().     this.record1Comparator = TestData.getIntStringTupleComparator().     this.record2Comparator = TestData.getIntStringTupleComparator().     this.recordPairComparator = new GenericPairComparator(this.record1Comparator, this.record2Comparator).     this.recordBuildSideAccesssor = TestData.getIntIntTupleSerializer().     this.recordProbeSideAccesssor = TestData.getIntIntTupleSerializer().     this.recordBuildSideComparator = TestData.getIntIntTupleComparator().     this.recordProbeSideComparator = TestData.getIntIntTupleComparator().     this.pactRecordComparator = new GenericPairComparator(this.recordBuildSideComparator, this.recordProbeSideComparator).     this.memoryManager = new MemoryManager(MEMORY_SIZE, 1, PAGE_SIZE, MemoryType.HEAP, true).     this.ioManager = new IOManagerAsync(). }
false;public;0;17;;@After public void afterTest() {     if (this.ioManager != null) {         this.ioManager.shutdown().         if (!this.ioManager.isProperlyShutDown()) {             Assert.fail("I/O manager failed to properly shut down.").         }         this.ioManager = null.     }     if (this.memoryManager != null) {         Assert.assertTrue("Memory Leak: Not all memory has been returned to the memory manager.", this.memoryManager.verifyEmpty()).         this.memoryManager.shutdown().         this.memoryManager = null.     } }
true;public;0;18;/**  * Test behavior with overflow buckets (Overflow buckets must be initialized correctly  * if the input is reopened again)  */ ;/**  * Test behavior with overflow buckets (Overflow buckets must be initialized correctly  * if the input is reopened again)  */ @Test public void testOverflow() {     int buildSize = 1000.     int probeSize = 1000.     try {         TupleGenerator bgen = new TupleGenerator(SEED1, 200, 1024, KeyMode.RANDOM, ValueMode.FIX_LENGTH).         TupleGenerator pgen = new TupleGenerator(SEED2, 0, 1024, KeyMode.SORTED, ValueMode.FIX_LENGTH).         final TupleGeneratorIterator buildInput = new TupleGeneratorIterator(bgen, buildSize).         final TupleGeneratorIterator probeInput = new TupleGeneratorIterator(pgen, probeSize).         doTest(buildInput, probeInput, bgen, pgen).     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
true;public;0;18;/**  * Verify proper operation if the build side is spilled to disk.  */ ;/**  * Verify proper operation if the build side is spilled to disk.  */ @Test public void testDoubleProbeSpilling() {     int buildSize = 1000.     int probeSize = 1000.     try {         TupleGenerator bgen = new TupleGenerator(SEED1, 0, 1024, KeyMode.SORTED, ValueMode.FIX_LENGTH).         TupleGenerator pgen = new TupleGenerator(SEED2, 0, 1024, KeyMode.SORTED, ValueMode.FIX_LENGTH).         final TupleGeneratorIterator buildInput = new TupleGeneratorIterator(bgen, buildSize).         final TupleGeneratorIterator probeInput = new TupleGeneratorIterator(pgen, probeSize).         doTest(buildInput, probeInput, bgen, pgen).     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
true;public;0;19;/**  * This test case verifies that hybrid hash join is able to handle multiple probe phases  * when the build side fits completely into memory.  */ ;/**  * This test case verifies that hybrid hash join is able to handle multiple probe phases  * when the build side fits completely into memory.  */ @Test public void testDoubleProbeInMemory() {     int buildSize = 1000.     int probeSize = 1000.     try {         TupleGenerator bgen = new TupleGenerator(SEED1, 0, 28, KeyMode.SORTED, ValueMode.FIX_LENGTH).         TupleGenerator pgen = new TupleGenerator(SEED2, 0, 28, KeyMode.SORTED, ValueMode.FIX_LENGTH).         final TupleGeneratorIterator buildInput = new TupleGeneratorIterator(bgen, buildSize).         final TupleGeneratorIterator probeInput = new TupleGeneratorIterator(pgen, probeSize).         doTest(buildInput, probeInput, bgen, pgen).     } catch (Exception e) {         e.printStackTrace().         Assert.fail("An exception occurred during the test: " + e.getMessage()).     } }
false;abstract,protected;4;1;;abstract protected void doTest(TupleGeneratorIterator buildInput, TupleGeneratorIterator probeInput, TestData.TupleGenerator bgen, TestData.TupleGenerator pgen) throws Exception.
false;static;1;11;;static Map<Integer, Collection<TupleMatch>> deepCopy(Map<Integer, Collection<TupleMatch>> expectedSecondMatchesMap) {     Map<Integer, Collection<TupleMatch>> copy = new HashMap<>(expectedSecondMatchesMap.size()).     for (Map.Entry<Integer, Collection<TupleMatch>> entry : expectedSecondMatchesMap.entrySet()) {         List<TupleMatch> matches = new ArrayList<TupleMatch>(entry.getValue().size()).         for (TupleMatch m : entry.getValue()) {             matches.add(m).         }         copy.put(entry.getKey(), matches).     }     return copy. }
