commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setup() {     akkaRpcService = new TestingRpcService(). }
false;public,static;0;4;;@AfterClass public static void shutdown() throws InterruptedException, ExecutionException, TimeoutException {     RpcUtils.terminateRpcService(akkaRpcService, timeout). }
true;public;0;10;/**  * Tests that the rpc endpoint and the associated rpc gateway have the same addresses.  * @throws Exception  */ ;/**  * Tests that the rpc endpoint and the associated rpc gateway have the same addresses.  * @throws Exception  */ @Test public void testAddressResolution() throws Exception {     DummyRpcEndpoint rpcEndpoint = new DummyRpcEndpoint(akkaRpcService).     CompletableFuture<DummyRpcGateway> futureRpcGateway = akkaRpcService.connect(rpcEndpoint.getAddress(), DummyRpcGateway.class).     DummyRpcGateway rpcGateway = futureRpcGateway.get(timeout.getSize(), timeout.getUnit()).     assertEquals(rpcEndpoint.getAddress(), rpcGateway.getAddress()). }
true;public;0;13;/**  * Tests that a {@link RpcConnectionException} is thrown if the rpc endpoint cannot be connected to.  */ ;/**  * Tests that a {@link RpcConnectionException} is thrown if the rpc endpoint cannot be connected to.  */ @Test public void testFailingAddressResolution() throws Exception {     CompletableFuture<DummyRpcGateway> futureRpcGateway = akkaRpcService.connect("foobar", DummyRpcGateway.class).     try {         futureRpcGateway.get(timeout.getSize(), timeout.getUnit()).         fail("The rpc connection resolution should have failed.").     } catch (ExecutionException exception) {         // we're expecting a RpcConnectionException         assertTrue(exception.getCause() instanceof RpcConnectionException).     } }
true;public;0;37;/**  * Tests that the {@link AkkaRpcActor} discards messages until the corresponding  * {@link RpcEndpoint} has been started.  */ ;/**  * Tests that the {@link AkkaRpcActor} discards messages until the corresponding  * {@link RpcEndpoint} has been started.  */ @Test public void testMessageDiscarding() throws Exception {     int expectedValue = 1337.     DummyRpcEndpoint rpcEndpoint = new DummyRpcEndpoint(akkaRpcService).     DummyRpcGateway rpcGateway = rpcEndpoint.getSelfGateway(DummyRpcGateway.class).     // this message should be discarded and completed with an AkkaRpcException     CompletableFuture<Integer> result = rpcGateway.foobar().     try {         result.get(timeout.getSize(), timeout.getUnit()).         fail("Expected an AkkaRpcException.").     } catch (ExecutionException ee) {         // expected this exception, because the endpoint has not been started         assertTrue(ee.getCause() instanceof AkkaRpcException).     }     // set a new value which we expect to be returned     rpcEndpoint.setFoobar(expectedValue).     // start the endpoint so that it can process messages     rpcEndpoint.start().     try {         // send the rpc again         result = rpcGateway.foobar().         // now we should receive a result :-)         Integer actualValue = result.get(timeout.getSize(), timeout.getUnit()).         assertThat("The new foobar value should have been returned.", actualValue, Is.is(expectedValue)).     } finally {         RpcUtils.terminateRpcEndpoint(rpcEndpoint, timeout).     } }
true;public;0;16;/**  * Tests that we can wait for a RpcEndpoint to terminate.  *  * @throws ExecutionException  * @throws InterruptedException  */ ;/**  * Tests that we can wait for a RpcEndpoint to terminate.  *  * @throws ExecutionException  * @throws InterruptedException  */ @Test(timeout = 5000) public void testRpcEndpointTerminationFuture() throws Exception {     final DummyRpcEndpoint rpcEndpoint = new DummyRpcEndpoint(akkaRpcService).     rpcEndpoint.start().     CompletableFuture<Void> terminationFuture = rpcEndpoint.getTerminationFuture().     assertFalse(terminationFuture.isDone()).     CompletableFuture.runAsync(rpcEndpoint::closeAsync, akkaRpcService.getExecutor()).     // wait until the rpc endpoint has terminated     terminationFuture.get(). }
false;public;0;18;;@Test public void testExceptionPropagation() throws Exception {     ExceptionalEndpoint rpcEndpoint = new ExceptionalEndpoint(akkaRpcService).     rpcEndpoint.start().     ExceptionalGateway rpcGateway = rpcEndpoint.getSelfGateway(ExceptionalGateway.class).     CompletableFuture<Integer> result = rpcGateway.doStuff().     try {         result.get(timeout.getSize(), timeout.getUnit()).         fail("this should fail with an exception").     } catch (ExecutionException e) {         Throwable cause = e.getCause().         assertEquals(RuntimeException.class, cause.getClass()).         assertEquals("my super specific test exception", cause.getMessage()).     } }
false;public;0;18;;@Test public void testExceptionPropagationFuturePiping() throws Exception {     ExceptionalFutureEndpoint rpcEndpoint = new ExceptionalFutureEndpoint(akkaRpcService).     rpcEndpoint.start().     ExceptionalGateway rpcGateway = rpcEndpoint.getSelfGateway(ExceptionalGateway.class).     CompletableFuture<Integer> result = rpcGateway.doStuff().     try {         result.get(timeout.getSize(), timeout.getUnit()).         fail("this should fail with an exception").     } catch (ExecutionException e) {         Throwable cause = e.getCause().         assertEquals(Exception.class, cause.getClass()).         assertEquals("some test", cause.getMessage()).     } }
true;public;0;13;/**  * Tests that exception thrown in the onStop method are returned by the termination  * future.  */ ;/**  * Tests that exception thrown in the onStop method are returned by the termination  * future.  */ @Test public void testOnStopExceptionPropagation() throws Exception {     FailingOnStopEndpoint rpcEndpoint = new FailingOnStopEndpoint(akkaRpcService, "FailingOnStopEndpoint").     rpcEndpoint.start().     CompletableFuture<Void> terminationFuture = rpcEndpoint.closeAsync().     try {         terminationFuture.get().     } catch (ExecutionException e) {         assertTrue(e.getCause() instanceof FailingOnStopEndpoint.OnStopException).     } }
true;public;0;11;/**  * Checks that the onStop callback is executed within the main thread.  */ ;/**  * Checks that the onStop callback is executed within the main thread.  */ @Test public void testOnStopExecutedByMainThread() throws Exception {     SimpleRpcEndpoint simpleRpcEndpoint = new SimpleRpcEndpoint(akkaRpcService, "SimpleRpcEndpoint").     simpleRpcEndpoint.start().     CompletableFuture<Void> terminationFuture = simpleRpcEndpoint.closeAsync().     // check that we executed the onStop method in the main thread, otherwise an exception     // would be thrown here.     terminationFuture.get(). }
true;public;0;21;/**  * Tests that actors are properly terminated when the AkkaRpcService is shut down.  */ ;/**  * Tests that actors are properly terminated when the AkkaRpcService is shut down.  */ @Test public void testActorTerminationWhenServiceShutdown() throws Exception {     final ActorSystem rpcActorSystem = AkkaUtils.createDefaultActorSystem().     final RpcService rpcService = new AkkaRpcService(rpcActorSystem, AkkaRpcServiceConfiguration.defaultConfiguration()).     try {         SimpleRpcEndpoint rpcEndpoint = new SimpleRpcEndpoint(rpcService, SimpleRpcEndpoint.class.getSimpleName()).         rpcEndpoint.start().         CompletableFuture<Void> terminationFuture = rpcEndpoint.getTerminationFuture().         rpcService.stopService().         terminationFuture.get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS).     } finally {         rpcActorSystem.terminate().         Await.ready(rpcActorSystem.whenTerminated(), FutureUtils.toFiniteDuration(timeout)).     } }
true;public;0;20;/**  * Tests that the {@link AkkaRpcActor} only completes after the asynchronous  * post stop action has completed.  */ ;/**  * Tests that the {@link AkkaRpcActor} only completes after the asynchronous  * post stop action has completed.  */ @Test public void testActorTerminationWithAsynchronousOnStopAction() throws Exception {     final CompletableFuture<Void> onStopFuture = new CompletableFuture<>().     final AsynchronousOnStopEndpoint endpoint = new AsynchronousOnStopEndpoint(akkaRpcService, onStopFuture).     try {         endpoint.start().         final CompletableFuture<Void> terminationFuture = endpoint.closeAsync().         assertFalse(terminationFuture.isDone()).         onStopFuture.complete(null).         // the onStopFuture completion should allow the endpoint to terminate         terminationFuture.get().     } finally {         RpcUtils.terminateRpcEndpoint(endpoint, timeout).     } }
true;public;0;14;/**  * Tests that we can still run commands via the main thread executor when the onStop method  * is called.  */ ;/**  * Tests that we can still run commands via the main thread executor when the onStop method  * is called.  */ @Test public void testMainThreadExecutionOnStop() throws Exception {     final MainThreadExecutorOnStopEndpoint endpoint = new MainThreadExecutorOnStopEndpoint(akkaRpcService).     try {         endpoint.start().         CompletableFuture<Void> terminationFuture = endpoint.closeAsync().         terminationFuture.get().     } finally {         RpcUtils.terminateRpcEndpoint(endpoint, timeout).     } }
true;public;0;37;/**  * Tests that when the onStop future completes that no other messages will be  * processed.  */ ;/**  * Tests that when the onStop future completes that no other messages will be  * processed.  */ @Test public void testOnStopFutureCompletionDirectlyTerminatesAkkaRpcActor() throws Exception {     final CompletableFuture<Void> onStopFuture = new CompletableFuture<>().     final TerminatingAfterOnStopFutureCompletionEndpoint endpoint = new TerminatingAfterOnStopFutureCompletionEndpoint(akkaRpcService, onStopFuture).     try {         endpoint.start().         final AsyncOperationGateway asyncOperationGateway = endpoint.getSelfGateway(AsyncOperationGateway.class).         final CompletableFuture<Void> terminationFuture = endpoint.closeAsync().         assertThat(terminationFuture.isDone(), is(false)).         final CompletableFuture<Integer> firstAsyncOperationFuture = asyncOperationGateway.asyncOperation(timeout).         final CompletableFuture<Integer> secondAsyncOperationFuture = asyncOperationGateway.asyncOperation(timeout).         endpoint.awaitEnterAsyncOperation().         // complete stop operation which should prevent the second async operation from being executed         onStopFuture.complete(null).         // we can only complete the termination after the first async operation has been completed         assertThat(terminationFuture.isDone(), is(false)).         endpoint.triggerUnblockAsyncOperation().         assertThat(firstAsyncOperationFuture.get(), is(42)).         terminationFuture.get().         assertThat(endpoint.getNumberAsyncOperationCalls(), is(1)).         assertThat(secondAsyncOperationFuture.isDone(), is(false)).     } finally {         RpcUtils.terminateRpcEndpoint(endpoint, timeout).     } }
true;public;0;11;/**  * Tests that the {@link RpcEndpoint#onStart()} method is called when the {@link RpcEndpoint}  * is started.  */ ;/**  * Tests that the {@link RpcEndpoint#onStart()} method is called when the {@link RpcEndpoint}  * is started.  */ @Test public void testOnStartIsCalledWhenRpcEndpointStarts() throws Exception {     final OnStartEndpoint onStartEndpoint = new OnStartEndpoint(akkaRpcService, null).     try {         onStartEndpoint.start().         onStartEndpoint.awaitUntilOnStartCalled().     } finally {         RpcUtils.terminateRpcEndpoint(onStartEndpoint, timeout).     } }
true;public;0;15;/**  * Tests that if onStart fails, then the endpoint terminates.  */ ;/**  * Tests that if onStart fails, then the endpoint terminates.  */ @Test public void testOnStartFails() throws Exception {     final FlinkException testException = new FlinkException("Test exception").     final OnStartEndpoint onStartEndpoint = new OnStartEndpoint(akkaRpcService, testException).     onStartEndpoint.start().     onStartEndpoint.awaitUntilOnStartCalled().     try {         onStartEndpoint.getTerminationFuture().get().         fail("Expected that the rpc endpoint failed onStart and thus has terminated.").     } catch (ExecutionException ee) {         assertThat(ExceptionUtils.findThrowable(ee, exception -> exception.equals(testException)).isPresent(), is(true)).     } }
false;;0;1;;CompletableFuture<Integer> foobar().
false;public;0;4;;@Override public CompletableFuture<Integer> foobar() {     return CompletableFuture.completedFuture(foobar). }
false;public;1;3;;public void setFoobar(int value) {     foobar = value. }
false;;0;1;;CompletableFuture<Integer> doStuff().
false;public;0;4;;@Override public CompletableFuture<Integer> doStuff() {     throw new RuntimeException("my super specific test exception"). }
false;public;0;7;;@Override public void run() {     try {         Thread.sleep(10).     } catch (InterruptedException ignored) {     }     future.completeExceptionally(new Exception("some test")). }
false;public;0;17;;@Override public CompletableFuture<Integer> doStuff() {     final CompletableFuture<Integer> future = new CompletableFuture<>().     // complete the future slightly in the, well, future...     new Thread() {          @Override         public void run() {             try {                 Thread.sleep(10).             } catch (InterruptedException ignored) {             }             future.completeExceptionally(new Exception("some test")).         }     }.start().     return future. }
false;public;0;4;;@Override public CompletableFuture<Void> onStop() {     return FutureUtils.completedExceptionally(new OnStopException("Test exception.")). }
false;public;0;4;;@Override public CompletableFuture<Void> onStop() {     return onStopFuture. }
false;public;0;4;;@Override public CompletableFuture<Void> onStop() {     return CompletableFuture.runAsync(() -> {     }, getMainThreadExecutor()). }
false;;1;1;;CompletableFuture<Integer> asyncOperation(@RpcTimeout Time timeout).
false;public;1;13;;@Override public CompletableFuture<Integer> asyncOperation(Time timeout) {     asyncOperationCounter.incrementAndGet().     enterAsyncOperation.trigger().     try {         blockAsyncOperation.await().     } catch (InterruptedException e) {         throw new FlinkRuntimeException(e).     }     return CompletableFuture.completedFuture(42). }
false;public;0;4;;@Override public CompletableFuture<Void> onStop() {     return onStopFuture. }
false;;0;3;;void awaitEnterAsyncOperation() throws InterruptedException {     enterAsyncOperation.await(). }
false;;0;3;;void triggerUnblockAsyncOperation() {     blockAsyncOperation.trigger(). }
false;;0;3;;int getNumberAsyncOperationCalls() {     return asyncOperationCounter.get(). }
false;public;0;6;;@Override public void onStart() throws Exception {     countDownLatch.countDown().     ExceptionUtils.tryRethrowException(exception). }
false;public;0;3;;public void awaitUntilOnStartCalled() throws InterruptedException {     countDownLatch.await(). }
