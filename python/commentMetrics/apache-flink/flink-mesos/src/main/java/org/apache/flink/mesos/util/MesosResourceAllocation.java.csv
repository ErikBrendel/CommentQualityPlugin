commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the remaining resources.  */ ;/**  * Gets the remaining resources.  */ public List<Protos.Resource> getRemaining() {     return Collections.unmodifiableList(resources). }
true;public;3;43;/**  * Takes some amount of scalar resources (e.g. cpus, mem).  *  * @param amount the (approximate) amount to take from the available quantity.  * @param roles the roles to accept  */ ;/**  * Takes some amount of scalar resources (e.g. cpus, mem).  *  * @param amount the (approximate) amount to take from the available quantity.  * @param roles the roles to accept  */ public List<Protos.Resource> takeScalar(String resourceName, double amount, Set<String> roles) {     if (LOG.isDebugEnabled()) {         LOG.debug("Allocating {} {}", amount, resourceName).     }     List<Protos.Resource> result = new ArrayList<>(1).     for (ListIterator<Protos.Resource> i = resources.listIterator(). i.hasNext(). ) {         if (amount <= EPSILON) {             break.         }         // take from next available scalar resource that is unreserved or reserved for an applicable role         Protos.Resource available = i.next().         if (!resourceName.equals(available.getName()) || !available.hasScalar()) {             continue.         }         if (!UNRESERVED_ROLE.equals(available.getRole()) && !roles.contains(available.getRole())) {             continue.         }         double amountToTake = Math.min(available.getScalar().getValue(), amount).         Protos.Resource taken = available.toBuilder().setScalar(Protos.Value.Scalar.newBuilder().setValue(amountToTake)).build().         amount -= amountToTake.         result.add(taken).         if (LOG.isDebugEnabled()) {             LOG.debug("Taking {} from {}", amountToTake, Utils.toString(available)).         }         // keep remaining amount (if any)         double remaining = available.getScalar().getValue() - taken.getScalar().getValue().         if (remaining > EPSILON) {             i.set(available.toBuilder().setScalar(Protos.Value.Scalar.newBuilder().setValue(remaining)).build()).         } else {             i.remove().         }     }     if (LOG.isDebugEnabled()) {         LOG.debug("Allocated: {}, unsatisfied: {}", Utils.toString(result), amount).     }     return result. }
true;public;3;63;/**  * Takes some amount of range resources (e.g. ports).  *  * @param amount the number of values to take from the available range(s).  * @param roles the roles to accept  */ ;/**  * Takes some amount of range resources (e.g. ports).  *  * @param amount the number of values to take from the available range(s).  * @param roles the roles to accept  */ public List<Protos.Resource> takeRanges(String resourceName, int amount, Set<String> roles) {     if (LOG.isDebugEnabled()) {         LOG.debug("Allocating {} {}", amount, resourceName).     }     List<Protos.Resource> result = new ArrayList<>(1).     for (ListIterator<Protos.Resource> i = resources.listIterator(). i.hasNext(). ) {         if (amount <= 0) {             break.         }         // take from next available range resource that is unreserved or reserved for an applicable role         Protos.Resource available = i.next().         if (!resourceName.equals(available.getName()) || !available.hasRanges()) {             continue.         }         if (!UNRESERVED_ROLE.equals(available.getRole()) && !roles.contains(available.getRole())) {             continue.         }         List<Protos.Value.Range> takenRanges = new ArrayList<>().         List<Protos.Value.Range> remainingRanges = new ArrayList<>(available.getRanges().getRangeList()).         for (ListIterator<Protos.Value.Range> j = remainingRanges.listIterator(). j.hasNext(). ) {             if (amount <= 0) {                 break.             }             // take from next available range (note: ranges are inclusive)             Protos.Value.Range availableRange = j.next().             long amountToTake = Math.min(availableRange.getEnd() - availableRange.getBegin() + 1, amount).             Protos.Value.Range takenRange = availableRange.toBuilder().setEnd(availableRange.getBegin() + amountToTake - 1).build().             amount -= amountToTake.             takenRanges.add(takenRange).             // keep remaining range (if any)             long remaining = availableRange.getEnd() - takenRange.getEnd().             if (remaining > 0) {                 j.set(availableRange.toBuilder().setBegin(takenRange.getEnd() + 1).build()).             } else {                 j.remove().             }         }         Protos.Resource taken = available.toBuilder().setRanges(Protos.Value.Ranges.newBuilder().addAllRange(takenRanges)).build().         if (LOG.isDebugEnabled()) {             LOG.debug("Taking {} from {}", Utils.toString(taken.getRanges()), Utils.toString(available)).         }         result.add(taken).         // keep remaining ranges (if any)         if (remainingRanges.size() > 0) {             i.set(available.toBuilder().setRanges(Protos.Value.Ranges.newBuilder().addAllRange(remainingRanges)).build()).         } else {             i.remove().         }     }     if (LOG.isDebugEnabled()) {         LOG.debug("Allocated: {}, unsatisfied: {}", Utils.toString(result), amount).     }     return result. }
false;public;0;6;;@Override public String toString() {     return "MesosResourceAllocation{" + "resources=" + Utils.toString(resources) + '}'. }
