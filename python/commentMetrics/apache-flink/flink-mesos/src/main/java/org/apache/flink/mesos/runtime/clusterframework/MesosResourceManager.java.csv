commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;protected ActorRef createSelfActor() {     return actorSystem.actorOf(Props.create(AkkaAdapter.class, this), "ResourceManager"). }
false;protected;0;5;;protected ActorRef createConnectionMonitor() {     return actorSystem.actorOf(ConnectionMonitor.createActorProps(ConnectionMonitor.class, flinkConfig), "connectionMonitor"). }
false;protected;1;5;;protected ActorRef createTaskMonitor(SchedulerDriver schedulerDriver) {     return actorSystem.actorOf(Tasks.createActorProps(Tasks.class, selfActor, flinkConfig, schedulerDriver, TaskMonitor.class), "tasks"). }
false;protected;2;7;;protected ActorRef createLaunchCoordinator(SchedulerDriver schedulerDriver, ActorRef selfActor) {     return actorSystem.actorOf(LaunchCoordinator.createActorProps(LaunchCoordinator.class, selfActor, flinkConfig, schedulerDriver, createOptimizer()), "launchCoordinator"). }
false;protected;1;5;;protected ActorRef createReconciliationCoordinator(SchedulerDriver schedulerDriver) {     return actorSystem.actorOf(ReconciliationCoordinator.createActorProps(ReconciliationCoordinator.class, flinkConfig, schedulerDriver), "reconciliationCoordinator"). }
false;protected;0;43;;// ------------------------------------------------------------------------ // Resource Manager overrides // ------------------------------------------------------------------------ @Override protected void initialize() throws ResourceManagerException {     // create and start the worker store     try {         this.workerStore = mesosServices.createMesosWorkerStore(flinkConfig, getRpcService().getExecutor()).         workerStore.start().     } catch (Exception e) {         throw new ResourceManagerException("Unable to initialize the worker store.", e).     }     // Prepare to register with Mesos     Protos.FrameworkInfo.Builder frameworkInfo = mesosConfig.frameworkInfo().clone().setCheckpoint(true).     if (webUiUrl != null) {         frameworkInfo.setWebuiUrl(webUiUrl).     }     try {         Option<Protos.FrameworkID> frameworkID = workerStore.getFrameworkID().         if (frameworkID.isEmpty()) {             LOG.info("Registering as new framework.").         } else {             LOG.info("Recovery scenario: re-registering using framework ID {}.", frameworkID.get().getValue()).             frameworkInfo.setId(frameworkID.get()).         }     } catch (Exception e) {         throw new ResourceManagerException("Unable to recover the framework ID.", e).     }     initializedMesosConfig = mesosConfig.withFrameworkInfo(frameworkInfo).     MesosConfiguration.logMesosConfig(LOG, initializedMesosConfig).     this.selfActor = createSelfActor().     // configure the artifact server to serve the TM container artifacts     try {         LaunchableMesosWorker.configureArtifactServer(artifactServer, taskManagerContainerSpec).     } catch (IOException e) {         throw new ResourceManagerException("Unable to configure the artifact server with TaskManager artifacts.", e).     } }
false;protected;0;26;;@Override protected CompletableFuture<Void> prepareLeadershipAsync() {     Preconditions.checkState(initializedMesosConfig != null).     schedulerDriver = initializedMesosConfig.createDriver(new MesosResourceManagerSchedulerCallback(), false).     // create supporting actors     connectionMonitor = createConnectionMonitor().     launchCoordinator = createLaunchCoordinator(schedulerDriver, selfActor).     reconciliationCoordinator = createReconciliationCoordinator(schedulerDriver).     taskMonitor = createTaskMonitor(schedulerDriver).     return getWorkersAsync().thenApplyAsync((tasksFromPreviousAttempts) -> {         // recover state         recoverWorkers(tasksFromPreviousAttempts).         // begin scheduling         connectionMonitor.tell(new ConnectionMonitor.Start(), selfActor).         schedulerDriver.start().         LOG.info("Mesos resource manager started.").         return null.     }, getMainThreadExecutor()). }
false;protected;0;10;;@Override protected CompletableFuture<Void> clearStateAsync() {     schedulerDriver.stop(true).     workersInNew.clear().     workersInLaunch.clear().     workersBeingReturned.clear().     return stopSupportingActorsAsync(). }
true;private;0;18;/**  * Fetches framework/worker information persisted by a prior incarnation of the RM.  */ ;/**  * Fetches framework/worker information persisted by a prior incarnation of the RM.  */ private CompletableFuture<List<MesosWorkerStore.Worker>> getWorkersAsync() {     // then some worker tasks are most likely still alive and we can re-obtain them     return CompletableFuture.supplyAsync(() -> {         try {             final List<MesosWorkerStore.Worker> tasksFromPreviousAttempts = workerStore.recoverWorkers().             for (final MesosWorkerStore.Worker worker : tasksFromPreviousAttempts) {                 if (worker.state() == MesosWorkerStore.WorkerState.New) {                     // remove new workers because allocation requests are transient                     workerStore.removeWorker(worker.taskID()).                 }             }             return tasksFromPreviousAttempts.         } catch (final Exception e) {             throw new CompletionException(new ResourceManagerException(e)).         }     }, getRpcService().getExecutor()). }
true;private;1;30;/**  * Recovers given framework/worker information.  *  * @see #getWorkersAsync()  */ ;/**  * Recovers given framework/worker information.  *  * @see #getWorkersAsync()  */ private void recoverWorkers(final List<MesosWorkerStore.Worker> tasksFromPreviousAttempts) {     assert (workersInNew.isEmpty()).     assert (workersInLaunch.isEmpty()).     assert (workersBeingReturned.isEmpty()).     if (!tasksFromPreviousAttempts.isEmpty()) {         LOG.info("Retrieved {} TaskManagers from previous attempt", tasksFromPreviousAttempts.size()).         List<Tuple2<TaskRequest, String>> toAssign = new ArrayList<>(tasksFromPreviousAttempts.size()).         for (final MesosWorkerStore.Worker worker : tasksFromPreviousAttempts) {             switch(worker.state()) {                 case Launched:                     workersInLaunch.put(extractResourceID(worker.taskID()), worker).                     final LaunchableMesosWorker launchable = createLaunchableMesosWorker(worker.taskID()).                     toAssign.add(new Tuple2<>(launchable.taskRequest(), worker.hostname().get())).                     break.                 case Released:                     workersBeingReturned.put(extractResourceID(worker.taskID()), worker).                     break.             }             taskMonitor.tell(new TaskMonitor.TaskGoalStateUpdated(extractGoalState(worker)), selfActor).         }         // tell the launch coordinator about prior assignments         if (toAssign.size() >= 1) {             launchCoordinator.tell(new LaunchCoordinator.Assign(toAssign), selfActor).         }     } }
false;private;0;21;;private CompletableFuture<Void> stopSupportingActorsAsync() {     FiniteDuration stopTimeout = new FiniteDuration(5L, TimeUnit.SECONDS).     CompletableFuture<Boolean> stopTaskMonitorFuture = stopActor(taskMonitor, stopTimeout).     taskMonitor = null.     CompletableFuture<Boolean> stopConnectionMonitorFuture = stopActor(connectionMonitor, stopTimeout).     connectionMonitor = null.     CompletableFuture<Boolean> stopLaunchCoordinatorFuture = stopActor(launchCoordinator, stopTimeout).     launchCoordinator = null.     CompletableFuture<Boolean> stopReconciliationCoordinatorFuture = stopActor(reconciliationCoordinator, stopTimeout).     reconciliationCoordinator = null.     return CompletableFuture.allOf(stopTaskMonitorFuture, stopConnectionMonitorFuture, stopLaunchCoordinatorFuture, stopReconciliationCoordinatorFuture). }
false;public;0;4;;@Override public CompletableFuture<Void> onStop() {     return stopSupportingActorsAsync().thenCompose((ignored) -> super.onStop()). }
false;protected;2;28;;@Override protected void internalDeregisterApplication(ApplicationStatus finalStatus, @Nullable String diagnostics) throws ResourceManagerException {     LOG.info("Shutting down and unregistering as a Mesos framework.").     Exception exception = null.     try {         // unregister the framework, which implicitly removes all tasks.         schedulerDriver.stop(false).     } catch (Exception ex) {         exception = new Exception("Could not unregister the Mesos framework.", ex).     }     try {         workerStore.stop(true).     } catch (Exception ex) {         exception = ExceptionUtils.firstOrSuppressed(new Exception("Could not stop the Mesos worker store.", ex), exception).     }     if (exception != null) {         throw new ResourceManagerException("Could not properly shut down the Mesos application.", exception).     } }
false;public;1;26;;@Override public Collection<ResourceProfile> startNewWorker(ResourceProfile resourceProfile) {     LOG.info("Starting a new worker.").     try {         // generate new workers into persistent state and launch associated actors         MesosWorkerStore.Worker worker = MesosWorkerStore.Worker.newWorker(workerStore.newTaskID(), resourceProfile).         workerStore.putWorker(worker).         workersInNew.put(extractResourceID(worker.taskID()), worker).         LaunchableMesosWorker launchable = createLaunchableMesosWorker(worker.taskID()).         LOG.info("Scheduling Mesos task {} with ({} MB, {} cpus).", launchable.taskID().getValue(), launchable.taskRequest().getMemory(), launchable.taskRequest().getCPUs()).         // tell the task monitor about the new plans         taskMonitor.tell(new TaskMonitor.TaskGoalStateUpdated(extractGoalState(worker)), selfActor).         // tell the launch coordinator to launch the new tasks         launchCoordinator.tell(new LaunchCoordinator.Launch(Collections.singletonList(launchable)), selfActor).         return slotsPerWorker.     } catch (Exception ex) {         onFatalError(new ResourceManagerException("Unable to request new workers.", ex)).         return Collections.emptyList().     } }
false;public;1;32;;@Override public boolean stopWorker(RegisteredMesosWorkerNode workerNode) {     LOG.info("Stopping worker {}.", workerNode.getResourceID()).     try {         if (workersInLaunch.containsKey(workerNode.getResourceID())) {             // update persistent state of worker to Released             MesosWorkerStore.Worker worker = workersInLaunch.remove(workerNode.getResourceID()).             worker = worker.releaseWorker().             workerStore.putWorker(worker).             workersBeingReturned.put(extractResourceID(worker.taskID()), worker).             taskMonitor.tell(new TaskMonitor.TaskGoalStateUpdated(extractGoalState(worker)), selfActor).             if (worker.hostname().isDefined()) {                 // tell the launch coordinator that the task is being unassigned from the host, for planning purposes                 launchCoordinator.tell(new LaunchCoordinator.Unassign(worker.taskID(), worker.hostname().get()), selfActor).             }         } else if (workersBeingReturned.containsKey(workerNode.getResourceID())) {             LOG.info("Ignoring request to stop worker {} because it is already being stopped.", workerNode.getResourceID()).         } else {             LOG.warn("Unrecognized worker {}.", workerNode.getResourceID()).         }     } catch (Exception e) {         onFatalError(new ResourceManagerException("Unable to release a worker.", e)).     }     return true. }
true;protected;1;13;/**  * Callback when a worker was started.  *  * @param resourceID The worker resource id (as provided by the TaskExecutor)  */ ;/**  * Callback when a worker was started.  *  * @param resourceID The worker resource id (as provided by the TaskExecutor)  */ @Override protected RegisteredMesosWorkerNode workerStarted(ResourceID resourceID) {     // note: this may occur more than once for a given worker.     MesosWorkerStore.Worker inLaunch = workersInLaunch.get(resourceID).     if (inLaunch != null) {         return new RegisteredMesosWorkerNode(inLaunch).     } else {         // return null to indicate that TaskExecutor registration should be declined         return null.     } }
false;protected;1;13;;// ------------------------------------------------------------------------ // Mesos specific methods // ------------------------------------------------------------------------ protected void registered(Registered message) {     connectionMonitor.tell(message, selfActor).     try {         workerStore.setFrameworkID(Option.apply(message.frameworkId())).     } catch (Exception ex) {         onFatalError(new ResourceManagerException("Unable to store the assigned framework ID.", ex)).         return.     }     launchCoordinator.tell(message, selfActor).     reconciliationCoordinator.tell(message, selfActor).     taskMonitor.tell(message, selfActor). }
true;protected;1;6;/**  * Called when reconnected to Mesos following a failover event.  */ ;/**  * Called when reconnected to Mesos following a failover event.  */ protected void reregistered(ReRegistered message) {     connectionMonitor.tell(message, selfActor).     launchCoordinator.tell(message, selfActor).     reconciliationCoordinator.tell(message, selfActor).     taskMonitor.tell(message, selfActor). }
true;protected;1;6;/**  * Called when disconnected from Mesos.  */ ;/**  * Called when disconnected from Mesos.  */ protected void disconnected(Disconnected message) {     connectionMonitor.tell(message, selfActor).     launchCoordinator.tell(message, selfActor).     reconciliationCoordinator.tell(message, selfActor).     taskMonitor.tell(message, selfActor). }
true;protected;1;3;/**  * Called when resource offers are made to the framework.  */ ;/**  * Called when resource offers are made to the framework.  */ protected void resourceOffers(ResourceOffers message) {     launchCoordinator.tell(message, selfActor). }
true;protected;1;3;/**  * Called when resource offers are rescinded.  */ ;/**  * Called when resource offers are rescinded.  */ protected void offerRescinded(OfferRescinded message) {     launchCoordinator.tell(message, selfActor). }
true;protected;1;5;/**  * Handles a task status update from Mesos.  */ ;/**  * Handles a task status update from Mesos.  */ protected void statusUpdate(StatusUpdate message) {     taskMonitor.tell(message, selfActor).     reconciliationCoordinator.tell(message, selfActor).     schedulerDriver.acknowledgeStatusUpdate(message.status()). }
false;protected;1;1;;protected void frameworkMessage(FrameworkMessage message) { }
false;protected;1;1;;protected void slaveLost(SlaveLost message) { }
false;protected;1;1;;protected void executorLost(ExecutorLost message) { }
true;public;1;34;/**  * Accept offers as advised by the launch coordinator.  *  * <p>Acceptance is routed through the RM to update the persistent state before  * forwarding the message to Mesos.  */ ;/**  * Accept offers as advised by the launch coordinator.  *  * <p>Acceptance is routed through the RM to update the persistent state before  * forwarding the message to Mesos.  */ public void acceptOffers(AcceptOffers msg) {     try {         List<TaskMonitor.TaskGoalStateUpdated> toMonitor = new ArrayList<>(msg.operations().size()).         // transition the persistent state of some tasks to Launched         for (Protos.Offer.Operation op : msg.operations()) {             if (op.getType() == Protos.Offer.Operation.Type.LAUNCH) {                 for (Protos.TaskInfo info : op.getLaunch().getTaskInfosList()) {                     MesosWorkerStore.Worker worker = workersInNew.remove(extractResourceID(info.getTaskId())).                     assert (worker != null).                     worker = worker.launchWorker(info.getSlaveId(), msg.hostname()).                     workerStore.putWorker(worker).                     workersInLaunch.put(extractResourceID(worker.taskID()), worker).                     LOG.info("Launching Mesos task {} on host {}.", worker.taskID().getValue(), worker.hostname().get()).                     toMonitor.add(new TaskMonitor.TaskGoalStateUpdated(extractGoalState(worker))).                 }             }         }         // tell the task monitor about the new plans         for (TaskMonitor.TaskGoalStateUpdated update : toMonitor) {             taskMonitor.tell(update, selfActor).         }         // send the acceptance message to Mesos         schedulerDriver.acceptOffers(msg.offerIds(), msg.operations(), msg.filters()).     } catch (Exception ex) {         onFatalError(new ResourceManagerException("unable to accept offers", ex)).     } }
true;public;1;4;/**  * Handles a reconciliation request from a task monitor.  */ ;/**  * Handles a reconciliation request from a task monitor.  */ public void reconcile(ReconciliationCoordinator.Reconcile message) {     // forward to the reconciliation coordinator     reconciliationCoordinator.tell(message, selfActor). }
true;public;1;37;/**  * Handles a termination notification from a task monitor.  */ ;/**  * Handles a termination notification from a task monitor.  */ public void taskTerminated(TaskMonitor.TaskTerminated message) {     Protos.TaskID taskID = message.taskID().     Protos.TaskStatus status = message.status().     // note: this callback occurs for failed containers and for released containers alike     final ResourceID id = extractResourceID(taskID).     boolean existed.     try {         existed = workerStore.removeWorker(taskID).     } catch (Exception ex) {         onFatalError(new ResourceManagerException("unable to remove worker", ex)).         return.     }     if (!existed) {         LOG.info("Received a termination notice for an unrecognized worker: {}", id).         return.     }     // check if this is a failed task or a released task     assert (!workersInNew.containsKey(id)).     if (workersBeingReturned.remove(id) != null) {         // regular finished worker that we released         LOG.info("Worker {} finished successfully with message: {}", id, status.getMessage()).     } else {         // failed worker, either at startup, or running         final MesosWorkerStore.Worker launched = workersInLaunch.remove(id).         assert (launched != null).         LOG.info("Worker {} failed with status: {}, reason: {}, message: {}.", id, status.getState(), status.getReason(), status.getMessage()).         startNewWorker(launched.profile()).     }     closeTaskManagerConnection(id, new Exception(status.getMessage())). }
true;private;2;17;/**  * Tries to shut down the given actor gracefully.  *  * @param actorRef specifying the actor to shut down  * @param timeout  for the graceful shut down  * @return A future that finishes with {@code true} iff. the actor could be stopped gracefully  * or {@code actorRef} was {@code null}.  */ ;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ /**  * Tries to shut down the given actor gracefully.  *  * @param actorRef specifying the actor to shut down  * @param timeout  for the graceful shut down  * @return A future that finishes with {@code true} iff. the actor could be stopped gracefully  * or {@code actorRef} was {@code null}.  */ private CompletableFuture<Boolean> stopActor(@Nullable final ActorRef actorRef, FiniteDuration timeout) {     if (actorRef == null) {         return CompletableFuture.completedFuture(true).     }     return FutureUtils.toJava(Patterns.gracefulStop(actorRef, timeout)).exceptionally((Throwable throwable) -> {         // The actor did not stop gracefully in time, try to directly stop it         actorSystem.stop(actorRef).         log.warn("Could not stop actor {} gracefully.", actorRef.path(), throwable).         return false.     }). }
true;private;1;13;/**  * Creates a launchable task for Fenzo to process.  */ ;/**  * Creates a launchable task for Fenzo to process.  */ private LaunchableMesosWorker createLaunchableMesosWorker(Protos.TaskID taskID) {     LOG.debug("LaunchableMesosWorker parameters: {}", taskManagerParameters).     LaunchableMesosWorker launchable = new LaunchableMesosWorker(artifactServer, taskManagerParameters, taskManagerContainerSpec, taskID, mesosConfig).     return launchable. }
true;static;1;3;/**  * Extracts a unique ResourceID from the Mesos task.  *  * @param taskId the Mesos TaskID  * @return The ResourceID for the container  */ ;/**  * Extracts a unique ResourceID from the Mesos task.  *  * @param taskId the Mesos TaskID  * @return The ResourceID for the container  */ static ResourceID extractResourceID(Protos.TaskID taskId) {     return new ResourceID(taskId.getValue()). }
true;static;1;8;/**  * Extracts the Mesos task goal state from the worker information.  *  * @param worker the persistent worker information.  * @return goal state information for the {@Link TaskMonitor}.  */ ;/**  * Extracts the Mesos task goal state from the worker information.  *  * @param worker the persistent worker information.  * @return goal state information for the {@Link TaskMonitor}.  */ static TaskMonitor.TaskGoalState extractGoalState(MesosWorkerStore.Worker worker) {     switch(worker.state()) {         case New:             return new TaskMonitor.New(worker.taskID()).         case Launched:             return new TaskMonitor.Launched(worker.taskID(), worker.slaveID().get()).         case Released:             return new TaskMonitor.Released(worker.taskID(), worker.slaveID().get()).         default:             throw new IllegalArgumentException("unsupported worker state").     } }
false;public;1;5;;@Override public TaskSchedulerBuilder withLeaseRejectAction(Action1<VirtualMachineLease> action) {     builder.withLeaseRejectAction(action).     return this. }
false;public;0;4;;@Override public TaskScheduler build() {     return builder.build(). }
true;private,static;0;16;/**  * Creates the Fenzo optimizer (builder).  * The builder is an indirection to facilitate unit testing of the Launch Coordinator.  */ ;/**  * Creates the Fenzo optimizer (builder).  * The builder is an indirection to facilitate unit testing of the Launch Coordinator.  */ private static TaskSchedulerBuilder createOptimizer() {     return new TaskSchedulerBuilder() {          TaskScheduler.Builder builder = new TaskScheduler.Builder().          @Override         public TaskSchedulerBuilder withLeaseRejectAction(Action1<VirtualMachineLease> action) {             builder.withLeaseRejectAction(action).             return this.         }          @Override         public TaskScheduler build() {             return builder.build().         }     }. }
false;public;0;4;;@Override public void run() {     MesosResourceManager.this.registered(new Registered(frameworkId, masterInfo)). }
false;public;3;9;;@Override public void registered(SchedulerDriver driver, final Protos.FrameworkID frameworkId, final Protos.MasterInfo masterInfo) {     runAsync(new Runnable() {          @Override         public void run() {             MesosResourceManager.this.registered(new Registered(frameworkId, masterInfo)).         }     }). }
false;public;0;4;;@Override public void run() {     MesosResourceManager.this.reregistered(new ReRegistered(masterInfo)). }
false;public;2;9;;@Override public void reregistered(SchedulerDriver driver, final Protos.MasterInfo masterInfo) {     runAsync(new Runnable() {          @Override         public void run() {             MesosResourceManager.this.reregistered(new ReRegistered(masterInfo)).         }     }). }
false;public;0;4;;@Override public void run() {     MesosResourceManager.this.resourceOffers(new ResourceOffers(offers)). }
false;public;2;9;;@Override public void resourceOffers(SchedulerDriver driver, final List<Protos.Offer> offers) {     runAsync(new Runnable() {          @Override         public void run() {             MesosResourceManager.this.resourceOffers(new ResourceOffers(offers)).         }     }). }
false;public;0;4;;@Override public void run() {     MesosResourceManager.this.offerRescinded(new OfferRescinded(offerId)). }
false;public;2;9;;@Override public void offerRescinded(SchedulerDriver driver, final Protos.OfferID offerId) {     runAsync(new Runnable() {          @Override         public void run() {             MesosResourceManager.this.offerRescinded(new OfferRescinded(offerId)).         }     }). }
false;public;0;4;;@Override public void run() {     MesosResourceManager.this.statusUpdate(new StatusUpdate(status)). }
false;public;2;9;;@Override public void statusUpdate(SchedulerDriver driver, final Protos.TaskStatus status) {     runAsync(new Runnable() {          @Override         public void run() {             MesosResourceManager.this.statusUpdate(new StatusUpdate(status)).         }     }). }
false;public;0;4;;@Override public void run() {     MesosResourceManager.this.frameworkMessage(new FrameworkMessage(executorId, slaveId, data)). }
false;public;4;9;;@Override public void frameworkMessage(SchedulerDriver driver, final Protos.ExecutorID executorId, final Protos.SlaveID slaveId, final byte[] data) {     runAsync(new Runnable() {          @Override         public void run() {             MesosResourceManager.this.frameworkMessage(new FrameworkMessage(executorId, slaveId, data)).         }     }). }
false;public;0;4;;@Override public void run() {     MesosResourceManager.this.disconnected(new Disconnected()). }
false;public;1;9;;@Override public void disconnected(SchedulerDriver driver) {     runAsyncWithoutFencing(new Runnable() {          @Override         public void run() {             MesosResourceManager.this.disconnected(new Disconnected()).         }     }). }
false;public;0;4;;@Override public void run() {     MesosResourceManager.this.slaveLost(new SlaveLost(slaveId)). }
false;public;2;9;;@Override public void slaveLost(SchedulerDriver driver, final Protos.SlaveID slaveId) {     runAsync(new Runnable() {          @Override         public void run() {             MesosResourceManager.this.slaveLost(new SlaveLost(slaveId)).         }     }). }
false;public;0;4;;@Override public void run() {     MesosResourceManager.this.executorLost(new ExecutorLost(executorId, slaveId, status)). }
false;public;4;9;;@Override public void executorLost(SchedulerDriver driver, final Protos.ExecutorID executorId, final Protos.SlaveID slaveId, final int status) {     runAsync(new Runnable() {          @Override         public void run() {             MesosResourceManager.this.executorLost(new ExecutorLost(executorId, slaveId, status)).         }     }). }
false;public;0;4;;@Override public void run() {     onFatalError(new ResourceManagerException(message)). }
false;public;2;9;;@Override public void error(SchedulerDriver driver, final String message) {     runAsync(new Runnable() {          @Override         public void run() {             onFatalError(new ResourceManagerException(message)).         }     }). }
false;public;0;4;;@Override public void run() {     acceptOffers((AcceptOffers) message). }
false;public;0;4;;@Override public void run() {     taskTerminated((TaskMonitor.TaskTerminated) message). }
false;public;0;4;;@Override public void run() {     reconcile((ReconciliationCoordinator.Reconcile) message). }
false;public;1;27;;@Override public void onReceive(final Object message) throws Exception {     if (message instanceof ReconciliationCoordinator.Reconcile) {         runAsync(new Runnable() {              @Override             public void run() {                 reconcile((ReconciliationCoordinator.Reconcile) message).             }         }).     } else if (message instanceof TaskMonitor.TaskTerminated) {         runAsync(new Runnable() {              @Override             public void run() {                 taskTerminated((TaskMonitor.TaskTerminated) message).             }         }).     } else if (message instanceof AcceptOffers) {         runAsync(new Runnable() {              @Override             public void run() {                 acceptOffers((AcceptOffers) message).             }         }).     } else {         MesosResourceManager.LOG.error("unrecognized message: " + message).     } }
