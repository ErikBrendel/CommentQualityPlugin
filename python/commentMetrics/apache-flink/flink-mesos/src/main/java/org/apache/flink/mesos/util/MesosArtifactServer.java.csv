commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;15;;@Override protected void initChannel(SocketChannel ch) {     RouterHandler handler = new RouterHandler(router, new HashMap<>()).     // SSL should be the first handler in the pipeline     if (sslFactory != null) {         ch.pipeline().addLast("ssl", sslFactory.createNettySSLHandler()).     }     ch.pipeline().addLast(new HttpServerCodec()).addLast(new ChunkedWriteHandler()).addLast(handler.getName(), handler).addLast(new UnknownFileHandler()). }
false;public;0;3;;public URL baseURL() {     return baseURL. }
true;public,synchronized;0;11;/**  * Get the server port on which the artifact server is listening.  */ ;/**  * Get the server port on which the artifact server is listening.  */ public synchronized int getServerPort() {     Channel server = this.serverChannel.     if (server != null) {         try {             return ((InetSocketAddress) server.localAddress()).getPort().         } catch (Exception e) {             LOG.error("Cannot access local server port", e).         }     }     return -1. }
true;public,synchronized;2;3;/**  * Adds a file to the artifact server.  * @param localFile the local file to serve.  * @param remoteFile the remote path with which to locate the file.  * @return the fully-qualified remote path to the file.  * @throws MalformedURLException if the remote path is invalid.  */ ;/**  * Adds a file to the artifact server.  * @param localFile the local file to serve.  * @param remoteFile the remote path with which to locate the file.  * @return the fully-qualified remote path to the file.  * @throws MalformedURLException if the remote path is invalid.  */ public synchronized URL addFile(File localFile, String remoteFile) throws IOException, MalformedURLException {     return addPath(new Path(localFile.toURI()), new Path(remoteFile)). }
true;public,synchronized;2;14;/**  * Adds a path to the artifact server.  * @param path the qualified FS path to serve (local, hdfs, etc).  * @param remoteFile the remote path with which to locate the file.  * @return the fully-qualified remote path to the file.  * @throws MalformedURLException if the remote path is invalid.  */ ;/**  * Adds a path to the artifact server.  * @param path the qualified FS path to serve (local, hdfs, etc).  * @param remoteFile the remote path with which to locate the file.  * @return the fully-qualified remote path to the file.  * @throws MalformedURLException if the remote path is invalid.  */ public synchronized URL addPath(Path path, Path remoteFile) throws IOException, MalformedURLException {     if (paths.containsKey(remoteFile)) {         throw new IllegalArgumentException("duplicate path registered").     }     if (remoteFile.isAbsolute()) {         throw new IllegalArgumentException("not expecting an absolute path").     }     URL fileURL = new URL(baseURL, remoteFile.toString()).     router.addAny(fileURL.getPath(), new VirtualFileServerHandler(path)).     paths.put(remoteFile, fileURL).     return fileURL. }
false;public,synchronized;1;11;;public synchronized void removePath(Path remoteFile) {     if (paths.containsKey(remoteFile)) {         URL fileURL = null.         try {             fileURL = new URL(baseURL, remoteFile.toString()).         } catch (MalformedURLException e) {             throw new RuntimeException(e).         }         router.removePathPattern(fileURL.getPath()).     } }
false;public,synchronized;1;5;;@Override public synchronized Option<URL> resolve(Path remoteFile) {     Option<URL> resolved = Option.apply(paths.get(remoteFile)).     return resolved. }
true;public,synchronized;0;12;/**  * Stops the artifact server.  * @throws Exception  */ ;/**  * Stops the artifact server.  * @throws Exception  */ public synchronized void stop() throws Exception {     if (this.serverChannel != null) {         this.serverChannel.close().awaitUninterruptibly().         this.serverChannel = null.     }     if (bootstrap != null) {         if (bootstrap.group() != null) {             bootstrap.group().shutdownGracefully().         }         bootstrap = null.     } }
false;protected;2;47;;@Override protected void channelRead0(ChannelHandlerContext ctx, RoutedRequest routedRequest) throws Exception {     HttpRequest request = routedRequest.getRequest().     if (LOG.isDebugEnabled()) {         LOG.debug("{} request for file '{}'", request.getMethod(), path).     }     if (!(request.getMethod() == GET || request.getMethod() == HEAD)) {         sendMethodNotAllowed(ctx).         return.     }     final FileStatus status.     try {         status = fs.getFileStatus(path).     } catch (IOException e) {         LOG.error("unable to stat file", e).         sendError(ctx, GONE).         return.     }     // compose the response     HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK).     HttpHeaders.setHeader(response, CONNECTION, HttpHeaders.Values.CLOSE).     HttpHeaders.setHeader(response, CACHE_CONTROL, "private").     HttpHeaders.setHeader(response, CONTENT_TYPE, "application/octet-stream").     HttpHeaders.setContentLength(response, status.getLen()).     ctx.write(response).     if (request.getMethod() == GET) {         // write the content.  Netty will close the stream.         final FSDataInputStream stream = fs.open(path).         try {             ctx.write(new ChunkedStream(stream)).         } catch (Exception e) {             stream.close().             throw e.         }     }     ChannelFuture lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).     lastContentFuture.addListener(ChannelFutureListener.CLOSE). }
false;public;2;7;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {     if (ctx.channel().isActive()) {         LOG.error("Caught exception", cause).         sendError(ctx, INTERNAL_SERVER_ERROR).     } }
true;private,static;1;6;/**  * Send the "405 Method Not Allowed" response.  *  * @param ctx The channel context to write the response to.  */ ;/**  * Send the "405 Method Not Allowed" response.  *  * @param ctx The channel context to write the response to.  */ private static void sendMethodNotAllowed(ChannelHandlerContext ctx) {     FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, METHOD_NOT_ALLOWED).     // close the connection as soon as the error message is sent.     ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE). }
true;private,static;2;8;/**  * Writes a simple  error response message.  *  * @param ctx    The channel context to write the response to.  * @param status The response status.  */ ;/**  * Writes a simple  error response message.  *  * @param ctx    The channel context to write the response to.  * @param status The response status.  */ private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {     FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, status, Unpooled.copiedBuffer("Failure: " + status + "\r\n", CharsetUtil.UTF_8)).     HttpHeaders.setHeader(response, CONTENT_TYPE, "text/plain. charset=UTF-8").     // close the connection as soon as the error message is sent.     ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE). }
false;protected;2;4;;@Override protected void channelRead0(ChannelHandlerContext ctx, Object message) {     sendNotFound(ctx). }
false;private,static;1;6;;private static void sendNotFound(ChannelHandlerContext ctx) {     FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, NOT_FOUND).     // close the connection as soon as the error message is sent.     ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE). }
