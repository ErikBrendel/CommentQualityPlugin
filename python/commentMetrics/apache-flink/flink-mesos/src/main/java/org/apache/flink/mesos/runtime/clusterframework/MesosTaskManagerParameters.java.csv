commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Get the CPU units to use for the TaskManager process.  */ ;/**  * Get the CPU units to use for the TaskManager process.  */ public double cpus() {     return cpus. }
true;public;0;3;/**  * Get the GPU units to use for the TaskManager Process.  */ ;/**  * Get the GPU units to use for the TaskManager Process.  */ public int gpus() {     return gpus. }
true;public;0;3;/**  * Get the container type (Mesos or Docker).  The default is Mesos.  *  * <p>Mesos provides a facility for a framework to specify which containerizer to use.  */ ;/**  * Get the container type (Mesos or Docker).  The default is Mesos.  *  * <p>Mesos provides a facility for a framework to specify which containerizer to use.  */ public ContainerType containerType() {     return containerType. }
true;public;0;3;/**  * Get the container image name.  */ ;/**  * Get the container image name.  */ public Option<String> containerImageName() {     return containerImageName. }
true;public;0;3;/**  * Get the common containered parameters.  */ ;/**  * Get the common containered parameters.  */ public ContaineredTaskManagerParameters containeredParameters() {     return containeredParameters. }
true;public;0;3;/**  * Get the container volumes string.  */ ;/**  * Get the container volumes string.  */ public List<Protos.Volume> containerVolumes() {     return containerVolumes. }
true;public;0;3;/**  * Get Docker runtime parameters.  */ ;/**  * Get Docker runtime parameters.  */ public List<Protos.Parameter> dockerParameters() {     return dockerParameters. }
true;public;0;3;/**  * Get Docker option to force pull image.  */ ;/**  * Get Docker option to force pull image.  */ public boolean dockerForcePullImage() {     return dockerForcePullImage. }
true;public;0;3;/**  * Get the placement constraints.  */ ;/**  * Get the placement constraints.  */ public List<ConstraintEvaluator> constraints() {     return constraints. }
true;public;0;3;/**  * Get the taskManager hostname.  */ ;/**  * Get the taskManager hostname.  */ public Option<String> getTaskManagerHostname() {     return taskManagerHostname. }
true;public;0;3;/**  * Get the command.  */ ;/**  * Get the command.  */ public String command() {     return command. }
true;public;0;3;/**  * Get the bootstrap command.  */ ;/**  * Get the bootstrap command.  */ public Option<String> bootstrapCommand() {     return bootstrapCommand. }
true;public;0;3;/**  * Get custom artifact URIs.  */ ;/**  * Get custom artifact URIs.  */ public List<String> uris() {     return uris. }
false;public;0;18;;@Override public String toString() {     return "MesosTaskManagerParameters{" + "cpus=" + cpus + ", gpus=" + gpus + ", containerType=" + containerType + ", containerImageName=" + containerImageName + ", containeredParameters=" + containeredParameters + ", containerVolumes=" + containerVolumes + ", dockerParameters=" + dockerParameters + ", dockerForcePullImage=" + dockerForcePullImage + ", constraints=" + constraints + ", taskManagerHostName=" + taskManagerHostname + ", command=" + command + ", bootstrapCommand=" + bootstrapCommand + ", uris=" + uris + '}'. }
true;public,static;1;77;/**  * Create the Mesos TaskManager parameters.  *  * @param flinkConfig the TM configuration.  */ ;/**  * Create the Mesos TaskManager parameters.  *  * @param flinkConfig the TM configuration.  */ public static MesosTaskManagerParameters create(Configuration flinkConfig) {     List<ConstraintEvaluator> constraints = parseConstraints(flinkConfig.getString(MESOS_CONSTRAINTS_HARD_HOSTATTR)).     // parse the common parameters     ContaineredTaskManagerParameters containeredParameters = ContaineredTaskManagerParameters.create(flinkConfig, flinkConfig.getInteger(MESOS_RM_TASKS_MEMORY_MB), flinkConfig.getInteger(MESOS_RM_TASKS_SLOTS)).     double cpus = flinkConfig.getDouble(MESOS_RM_TASKS_CPUS).     if (cpus <= 0.0) {         cpus = Math.max(containeredParameters.numSlots(), 1.0).     }     int gpus = flinkConfig.getInteger(MESOS_RM_TASKS_GPUS).     if (gpus < 0) {         throw new IllegalConfigurationException(MESOS_RM_TASKS_GPUS.key() + " cannot be negative").     }     // parse the containerization parameters     String imageName = flinkConfig.getString(MESOS_RM_CONTAINER_IMAGE_NAME).     ContainerType containerType.     String containerTypeString = flinkConfig.getString(MESOS_RM_CONTAINER_TYPE).     switch(containerTypeString) {         case MESOS_RESOURCEMANAGER_TASKS_CONTAINER_TYPE_MESOS:             containerType = ContainerType.MESOS.             break.         case MESOS_RESOURCEMANAGER_TASKS_CONTAINER_TYPE_DOCKER:             containerType = ContainerType.DOCKER.             if (imageName == null || imageName.length() == 0) {                 throw new IllegalConfigurationException(MESOS_RM_CONTAINER_IMAGE_NAME.key() + " must be specified for docker container type").             }             break.         default:             throw new IllegalConfigurationException("invalid container type: " + containerTypeString).     }     Option<String> containerVolOpt = Option.<String>apply(flinkConfig.getString(MESOS_RM_CONTAINER_VOLUMES)).     Option<String> dockerParamsOpt = Option.<String>apply(flinkConfig.getString(MESOS_RM_CONTAINER_DOCKER_PARAMETERS)).     Option<String> uriParamsOpt = Option.<String>apply(flinkConfig.getString(MESOS_TM_URIS)).     boolean dockerForcePullImage = flinkConfig.getBoolean(MESOS_RM_CONTAINER_DOCKER_FORCE_PULL_IMAGE).     List<Protos.Volume> containerVolumes = buildVolumes(containerVolOpt).     List<Protos.Parameter> dockerParameters = buildDockerParameters(dockerParamsOpt).     List<String> uris = buildUris(uriParamsOpt).     // obtain Task Manager Host Name from the configuration     Option<String> taskManagerHostname = Option.apply(flinkConfig.getString(MESOS_TM_HOSTNAME)).     // obtain command-line from the configuration     String tmCommand = flinkConfig.getString(MESOS_TM_CMD).     Option<String> tmBootstrapCommand = Option.apply(flinkConfig.getString(MESOS_TM_BOOTSTRAP_CMD)).     return new MesosTaskManagerParameters(cpus, gpus, containerType, Option.apply(imageName), containeredParameters, containerVolumes, dockerParameters, dockerForcePullImage, constraints, tmCommand, tmBootstrapCommand, taskManagerHostname, uris). }
false;private,static;1;21;;private static List<ConstraintEvaluator> parseConstraints(String mesosConstraints) {     if (mesosConstraints == null || mesosConstraints.isEmpty()) {         return Collections.emptyList().     } else {         List<ConstraintEvaluator> constraints = new ArrayList<>().         for (String constraint : mesosConstraints.split(",")) {             if (constraint.isEmpty()) {                 continue.             }             final String[] constraintList = constraint.split(":").             if (constraintList.length != 2) {                 continue.             }             addHostAttrValueConstraint(constraints, constraintList[0], constraintList[1]).         }         return constraints.     } }
false;public;1;4;;@Override public String call(String s) {     return constraintValue. }
false;private,static;3;8;;private static void addHostAttrValueConstraint(List<ConstraintEvaluator> constraints, String constraintKey, final String constraintValue) {     constraints.add(new HostAttrValueConstraint(constraintKey, new Func1<String, String>() {          @Override         public String call(String s) {             return constraintValue.         }     })). }
true;public,static;1;45;/**  * Used to build volume specs for mesos. This allows for mounting additional volumes into a container  *  * @param containerVolumes a comma delimited optional string of [host_path:]container_path[:RO|RW] that  *                         defines mount points for a container volume. If None or empty string, returns  *                         an empty iterator  */ ;/**  * Used to build volume specs for mesos. This allows for mounting additional volumes into a container  *  * @param containerVolumes a comma delimited optional string of [host_path:]container_path[:RO|RW] that  *                         defines mount points for a container volume. If None or empty string, returns  *                         an empty iterator  */ public static List<Protos.Volume> buildVolumes(Option<String> containerVolumes) {     if (containerVolumes.isEmpty()) {         return Collections.emptyList().     } else {         String[] volumeSpecifications = containerVolumes.get().split(",").         List<Protos.Volume> volumes = new ArrayList<>(volumeSpecifications.length).         for (String volumeSpecification : volumeSpecifications) {             if (!volumeSpecification.trim().isEmpty()) {                 Protos.Volume.Builder volume = Protos.Volume.newBuilder().                 volume.setMode(Protos.Volume.Mode.RW).                 String[] parts = volumeSpecification.split(":").                 switch(parts.length) {                     case 1:                         volume.setContainerPath(parts[0]).                         break.                     case 2:                         try {                             Protos.Volume.Mode mode = Protos.Volume.Mode.valueOf(parts[1].trim().toUpperCase()).                             volume.setMode(mode).setContainerPath(parts[0]).                         } catch (IllegalArgumentException e) {                             volume.setHostPath(parts[0]).setContainerPath(parts[1]).                         }                         break.                     case 3:                         Protos.Volume.Mode mode = Protos.Volume.Mode.valueOf(parts[2].trim().toUpperCase()).                         volume.setMode(mode).setHostPath(parts[0]).setContainerPath(parts[1]).                         break.                     default:                         throw new IllegalArgumentException("volume specification is invalid, given: " + volumeSpecification).                 }                 volumes.add(volume.build()).             }         }         return volumes.     } }
false;public,static;1;25;;public static List<Protos.Parameter> buildDockerParameters(Option<String> dockerParameters) {     if (dockerParameters.isEmpty()) {         return Collections.emptyList().     } else {         String[] dockerParameterSpecifications = dockerParameters.get().split(",").         List<Protos.Parameter> parameters = new ArrayList<>(dockerParameterSpecifications.length).         for (String dockerParameterSpecification : dockerParameterSpecifications) {             if (!dockerParameterSpecification.trim().isEmpty()) {                 // split with the limit of 2 in case the value includes '='                 String[] match = dockerParameterSpecification.split("=", 2).                 if (match.length != 2) {                     throw new IllegalArgumentException("Docker parameter specification is invalid, given: " + dockerParameterSpecification).                 }                 Protos.Parameter.Builder parameter = Protos.Parameter.newBuilder().                 parameter.setKey(match[0]).                 parameter.setValue(match[1]).                 parameters.add(parameter.build()).             }         }         return parameters.     } }
true;public,static;1;11;/**  * Build a list of URIs for providing custom artifacts to Mesos tasks.  * @param uris a comma delimited optional string listing artifact URIs  */ ;/**  * Build a list of URIs for providing custom artifacts to Mesos tasks.  * @param uris a comma delimited optional string listing artifact URIs  */ public static List<String> buildUris(Option<String> uris) {     if (uris.isEmpty()) {         return Collections.emptyList().     } else {         List<String> urisList = new ArrayList<>().         for (String uri : uris.get().split(",")) {             urisList.add(uri.trim()).         }         return urisList.     } }
