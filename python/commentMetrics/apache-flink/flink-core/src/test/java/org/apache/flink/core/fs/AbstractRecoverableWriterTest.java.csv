commented;modifiers;parameterAmount;loc;comment;code
false;public,abstract;0;1;;public abstract Path getBasePath() throws Exception.
false;public,abstract;0;1;;public abstract FileSystem initializeFileSystem() throws Exception.
false;public;0;3;;public Path getBasePathForTest() {     return basePathForTest. }
false;private;0;6;;private FileSystem getFileSystem() throws Exception {     if (fileSystem == null) {         fileSystem = initializeFileSystem().     }     return fileSystem. }
false;private;0;3;;private RecoverableWriter getNewFileSystemWriter() throws Exception {     return getFileSystem().createRecoverableWriter(). }
false;public;0;5;;@Before public void prepare() throws Exception {     basePathForTest = new Path(getBasePath(), randomName()).     getFileSystem().mkdirs(basePathForTest). }
false;public;0;4;;@After public void cleanup() throws Exception {     getFileSystem().delete(basePathForTest, true). }
false;public;0;21;;@Test public void testCloseWithNoData() throws Exception {     final RecoverableWriter writer = getNewFileSystemWriter().     final Path testDir = getBasePathForTest().     final Path path = new Path(testDir, "part-0").     final RecoverableFsDataOutputStream stream = writer.open(path).     for (Map.Entry<Path, String> fileContents : getFileContentByPath(testDir).entrySet()) {         Assert.assertTrue(fileContents.getKey().getName().startsWith(".part-0.inprogress.")).         Assert.assertTrue(fileContents.getValue().isEmpty()).     }     stream.closeForCommit().commit().     for (Map.Entry<Path, String> fileContents : getFileContentByPath(testDir).entrySet()) {         Assert.assertEquals("part-0", fileContents.getKey().getName()).         Assert.assertTrue(fileContents.getValue().isEmpty()).     } }
false;public;0;18;;@Test public void testCommitAfterNormalClose() throws Exception {     final RecoverableWriter writer = getNewFileSystemWriter().     final Path testDir = getBasePathForTest().     final Path path = new Path(testDir, "part-0").     try (final RecoverableFsDataOutputStream stream = writer.open(path)) {         stream.write(testData1.getBytes(StandardCharsets.UTF_8)).         stream.closeForCommit().commit().         for (Map.Entry<Path, String> fileContents : getFileContentByPath(testDir).entrySet()) {             Assert.assertEquals("part-0", fileContents.getKey().getName()).             Assert.assertEquals(testData1, fileContents.getValue()).         }     } }
false;public;0;21;;@Test public void testCommitAfterPersist() throws Exception {     final RecoverableWriter writer = getNewFileSystemWriter().     final Path testDir = getBasePathForTest().     final Path path = new Path(testDir, "part-0").     try (final RecoverableFsDataOutputStream stream = writer.open(path)) {         stream.write(testData1.getBytes(StandardCharsets.UTF_8)).         stream.persist().         stream.write(testData2.getBytes(StandardCharsets.UTF_8)).         stream.closeForCommit().commit().         for (Map.Entry<Path, String> fileContents : getFileContentByPath(testDir).entrySet()) {             Assert.assertEquals("part-0", fileContents.getKey().getName()).             Assert.assertEquals(testData1 + testData2, fileContents.getValue()).         }     } }
false;public;0;7;;@Test public void testRecoverWithEmptyState() throws Exception {     testResumeAfterMultiplePersist(INIT_EMPTY_PERSIST, "", testData3). }
false;public;0;7;;@Test public void testRecoverWithState() throws Exception {     testResumeAfterMultiplePersist(INTERM_WITH_STATE_PERSIST, testData1, testData1 + testData3). }
false;public;0;7;;@Test public void testRecoverFromIntermWithoutAdditionalState() throws Exception {     testResumeAfterMultiplePersist(INTERM_WITH_NO_ADDITIONAL_STATE_PERSIST, testData1, testData1 + testData3). }
false;public;0;7;;@Test public void testRecoverAfterMultiplePersistsState() throws Exception {     testResumeAfterMultiplePersist(FINAL_WITH_EXTRA_STATE, testData1 + testData2, testData1 + testData2 + testData3). }
false;private;3;57;;private void testResumeAfterMultiplePersist(final String persistName, final String expectedPostRecoveryContents, final String expectedFinalContents) throws Exception {     final Path testDir = getBasePathForTest().     final Path path = new Path(testDir, "part-0").     final RecoverableWriter initWriter = getNewFileSystemWriter().     final Map<String, RecoverableWriter.ResumeRecoverable> recoverables = new HashMap<>(4).     try (final RecoverableFsDataOutputStream stream = initWriter.open(path)) {         recoverables.put(INIT_EMPTY_PERSIST, stream.persist()).         stream.write(testData1.getBytes(StandardCharsets.UTF_8)).         recoverables.put(INTERM_WITH_STATE_PERSIST, stream.persist()).         recoverables.put(INTERM_WITH_NO_ADDITIONAL_STATE_PERSIST, stream.persist()).         // and write some more data         stream.write(testData2.getBytes(StandardCharsets.UTF_8)).         recoverables.put(FINAL_WITH_EXTRA_STATE, stream.persist()).     }     final SimpleVersionedSerializer<RecoverableWriter.ResumeRecoverable> serializer = initWriter.getResumeRecoverableSerializer().     final byte[] serializedRecoverable = serializer.serialize(recoverables.get(persistName)).     // get a new serializer from a new writer to make sure that no pre-initialized state leaks in.     final RecoverableWriter newWriter = getNewFileSystemWriter().     final SimpleVersionedSerializer<RecoverableWriter.ResumeRecoverable> deserializer = newWriter.getResumeRecoverableSerializer().     final RecoverableWriter.ResumeRecoverable recoveredRecoverable = deserializer.deserialize(serializer.getVersion(), serializedRecoverable).     try (final RecoverableFsDataOutputStream recoveredStream = newWriter.recover(recoveredRecoverable)) {         // we expect the data to be truncated         Map<Path, String> files = getFileContentByPath(testDir).         Assert.assertEquals(1L, files.size()).         for (Map.Entry<Path, String> fileContents : files.entrySet()) {             Assert.assertTrue(fileContents.getKey().getName().startsWith(".part-0.inprogress.")).             Assert.assertEquals(expectedPostRecoveryContents, fileContents.getValue()).         }         recoveredStream.write(testData3.getBytes(StandardCharsets.UTF_8)).         recoveredStream.closeForCommit().commit().         files = getFileContentByPath(testDir).         Assert.assertEquals(1L, files.size()).         for (Map.Entry<Path, String> fileContents : files.entrySet()) {             Assert.assertEquals("part-0", fileContents.getKey().getName()).             Assert.assertEquals(expectedFinalContents, fileContents.getValue()).         }     } }
false;public;0;38;;@Test public void testCommitAfterRecovery() throws Exception {     final Path testDir = getBasePathForTest().     final Path path = new Path(testDir, "part-0").     final RecoverableWriter initWriter = getNewFileSystemWriter().     final RecoverableWriter.CommitRecoverable recoverable.     try (final RecoverableFsDataOutputStream stream = initWriter.open(path)) {         stream.write(testData1.getBytes(StandardCharsets.UTF_8)).         stream.persist().         stream.persist().         // and write some more data         stream.write(testData2.getBytes(StandardCharsets.UTF_8)).         recoverable = stream.closeForCommit().getRecoverable().     }     final byte[] serializedRecoverable = initWriter.getCommitRecoverableSerializer().serialize(recoverable).     // get a new serializer from a new writer to make sure that no pre-initialized state leaks in.     final RecoverableWriter newWriter = getNewFileSystemWriter().     final SimpleVersionedSerializer<RecoverableWriter.CommitRecoverable> deserializer = newWriter.getCommitRecoverableSerializer().     final RecoverableWriter.CommitRecoverable recoveredRecoverable = deserializer.deserialize(deserializer.getVersion(), serializedRecoverable).     final RecoverableFsDataOutputStream.Committer committer = newWriter.recoverForCommit(recoveredRecoverable).     committer.commitAfterRecovery().     Map<Path, String> files = getFileContentByPath(testDir).     Assert.assertEquals(1L, files.size()).     for (Map.Entry<Path, String> fileContents : files.entrySet()) {         Assert.assertEquals("part-0", fileContents.getKey().getName()).         Assert.assertEquals(testData1 + testData2, fileContents.getValue()).     } }
false;public;0;15;;// TESTS FOR EXCEPTIONS @Test(expected = IOException.class) public void testExceptionWritingAfterCloseForCommit() throws Exception {     final Path testDir = getBasePathForTest().     final RecoverableWriter writer = getNewFileSystemWriter().     final Path path = new Path(testDir, "part-0").     try (final RecoverableFsDataOutputStream stream = writer.open(path)) {         stream.write(testData1.getBytes(StandardCharsets.UTF_8)).         stream.closeForCommit().getRecoverable().         stream.write(testData2.getBytes(StandardCharsets.UTF_8)).         fail().     } }
false;public;0;21;;@Test(expected = IOException.class) public void testResumeAfterCommit() throws Exception {     final Path testDir = getBasePathForTest().     final RecoverableWriter writer = getNewFileSystemWriter().     final Path path = new Path(testDir, "part-0").     RecoverableWriter.ResumeRecoverable recoverable.     try (final RecoverableFsDataOutputStream stream = writer.open(path)) {         stream.write(testData1.getBytes(StandardCharsets.UTF_8)).         recoverable = stream.persist().         stream.write(testData2.getBytes(StandardCharsets.UTF_8)).         stream.closeForCommit().commit().     }     // this should throw an exception as the file is already committed     writer.recover(recoverable).     fail(). }
false;public;0;37;;@Test public void testResumeWithWrongOffset() throws Exception {     // this is a rather unrealistic scenario, but it is to trigger     // truncation of the file and try to resume with missing data.     final Path testDir = getBasePathForTest().     final RecoverableWriter writer = getNewFileSystemWriter().     final Path path = new Path(testDir, "part-0").     final RecoverableWriter.ResumeRecoverable recoverable1.     final RecoverableWriter.ResumeRecoverable recoverable2.     try (final RecoverableFsDataOutputStream stream = writer.open(path)) {         stream.write(testData1.getBytes(StandardCharsets.UTF_8)).         recoverable1 = stream.persist().         stream.write(testData2.getBytes(StandardCharsets.UTF_8)).         recoverable2 = stream.persist().         stream.write(testData3.getBytes(StandardCharsets.UTF_8)).     }     try (RecoverableFsDataOutputStream ignored = writer.recover(recoverable1)) {     // this should work fine     } catch (Exception e) {         fail().     }     // this should throw an exception     try (RecoverableFsDataOutputStream ignored = writer.recover(recoverable2)) {         fail().     } catch (IOException e) {         // we expect this         return.     }     fail(). }
false;private;1;15;;private Map<Path, String> getFileContentByPath(Path directory) throws Exception {     Map<Path, String> contents = new HashMap<>().     final FileStatus[] filesInBucket = getFileSystem().listStatus(directory).     for (FileStatus file : filesInBucket) {         final long fileLength = file.getLen().         byte[] serContents = new byte[(int) fileLength].         FSDataInputStream stream = getFileSystem().open(file.getPath()).         stream.read(serContents).         contents.put(file.getPath(), new String(serContents, StandardCharsets.UTF_8)).     }     return contents. }
false;private,static;0;3;;private static String randomName() {     return StringUtils.getRandomString(RND, 16, 16, 'a', 'z'). }
