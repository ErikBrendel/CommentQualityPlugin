commented;modifiers;parameterAmount;loc;comment;code
false;public;1;2;;@Override public void write(DataOutputView out) throws IOException { }
false;public;1;2;;@Override public void read(DataInputView in) throws IOException { }
false;public;0;5;;@Test public void testDuplicateFieldException() {     TypeInformation<?> ti = TypeExtractor.createTypeInfo(HasDuplicateField.class).     Assert.assertTrue(ti instanceof GenericTypeInfo<?>). }
false;public;0;3;;public int getCount() {     return count. }
false;public;1;3;;public void setCount(int c) {     this.count = c. }
false;public;0;3;;public int getIsPrivate() {     return isPrivate. }
false;public;0;3;;public int getField() {     return this.field. }
false;public;1;3;;public void setField(int f) {     this.field = f. }
false;public;0;3;;public boolean isFavorited() {     return favorited. }
false;public;1;3;;public void setFavorited(boolean favorited) {     this.favorited = favorited. }
false;public;0;3;;public Collection<String> getUsers() {     return users. }
false;public;1;3;;public void setUsers(Collection<String> users) {     this.users = users. }
false;public;0;6;;@Test public void testPojoWithGenericFields() {     TypeInformation<?> typeForClass = TypeExtractor.createTypeInfo(PojoWithGenericFields.class).     Assert.assertTrue(typeForClass instanceof PojoTypeInfo<?>). }
false;public;1;3;;public void setPackageProtected(String in) {     this.packageProtected = in. }
false;public;0;3;;public T getPackageProtected() {     return packageProtected. }
false;public;0;8;;@Test public void testIncorrectPojos() {     TypeInformation<?> typeForClass = TypeExtractor.createTypeInfo(IncorrectPojo.class).     Assert.assertTrue(typeForClass instanceof GenericTypeInfo<?>).     typeForClass = TypeExtractor.createTypeInfo(WrongCtorPojo.class).     Assert.assertTrue(typeForClass instanceof GenericTypeInfo<?>). }
false;public;0;8;;@Test public void testCorrectPojos() {     TypeInformation<?> typeForClass = TypeExtractor.createTypeInfo(BeanStylePojo.class).     Assert.assertTrue(typeForClass instanceof PojoTypeInfo<?>).     typeForClass = TypeExtractor.createTypeInfo(TypedPojoGetterSetterCheck.class).     Assert.assertTrue(typeForClass instanceof PojoTypeInfo<?>). }
false;public;0;10;;@Test public void testPojoWC() {     TypeInformation<?> typeForClass = TypeExtractor.createTypeInfo(WC.class).     checkWCPojoAsserts(typeForClass).     WC t = new WC().     t.complex = new ComplexNestedClass().     TypeInformation<?> typeForObject = TypeExtractor.getForObject(t).     checkWCPojoAsserts(typeForObject). }
false;private;1;198;;@SuppressWarnings({ "unchecked", "rawtypes" }) private void checkWCPojoAsserts(TypeInformation<?> typeInfo) {     Assert.assertFalse(typeInfo.isBasicType()).     Assert.assertFalse(typeInfo.isTupleType()).     Assert.assertEquals(10, typeInfo.getTotalFields()).     Assert.assertTrue(typeInfo instanceof PojoTypeInfo).     PojoTypeInfo<?> pojoType = (PojoTypeInfo<?>) typeInfo.     List<FlatFieldDescriptor> ffd = new ArrayList<FlatFieldDescriptor>().     String[] fields = { "count", "complex.date", "complex.collection", "complex.nothing", "complex.someFloat", "complex.someNumberWithÜnicödeNäme", "complex.valueType", "complex.word.f0", "complex.word.f1", "complex.word.f2" }.     int[] positions = { 9, 1, 0, 2, 3, 4, 5, 6, 7, 8 }.     Assert.assertEquals(fields.length, positions.length).     for (int i = 0. i < fields.length. i++) {         pojoType.getFlatFields(fields[i], 0, ffd).         Assert.assertEquals("Too many keys returned", 1, ffd.size()).         Assert.assertEquals("position of field " + fields[i] + " wrong", positions[i], ffd.get(0).getPosition()).         ffd.clear().     }     pojoType.getFlatFields("complex.word.*", 0, ffd).     Assert.assertEquals(3, ffd.size()).     // check if it returns 5,6,7     for (FlatFieldDescriptor ffdE : ffd) {         final int pos = ffdE.getPosition().         Assert.assertTrue(pos <= 8).         Assert.assertTrue(6 <= pos).         if (pos == 6) {             Assert.assertEquals(Long.class, ffdE.getType().getTypeClass()).         }         if (pos == 7) {             Assert.assertEquals(Long.class, ffdE.getType().getTypeClass()).         }         if (pos == 8) {             Assert.assertEquals(String.class, ffdE.getType().getTypeClass()).         }     }     ffd.clear().     // scala style full tuple selection for pojos     pojoType.getFlatFields("complex.word._", 0, ffd).     Assert.assertEquals(3, ffd.size()).     ffd.clear().     pojoType.getFlatFields("complex.*", 0, ffd).     Assert.assertEquals(9, ffd.size()).     // check if it returns 0-7     for (FlatFieldDescriptor ffdE : ffd) {         final int pos = ffdE.getPosition().         Assert.assertTrue(ffdE.getPosition() <= 8).         Assert.assertTrue(0 <= ffdE.getPosition()).         if (pos == 0) {             Assert.assertEquals(List.class, ffdE.getType().getTypeClass()).         }         if (pos == 1) {             Assert.assertEquals(Date.class, ffdE.getType().getTypeClass()).         }         if (pos == 2) {             Assert.assertEquals(Object.class, ffdE.getType().getTypeClass()).         }         if (pos == 3) {             Assert.assertEquals(Float.class, ffdE.getType().getTypeClass()).         }         if (pos == 4) {             Assert.assertEquals(Integer.class, ffdE.getType().getTypeClass()).         }         if (pos == 5) {             Assert.assertEquals(MyValue.class, ffdE.getType().getTypeClass()).         }         if (pos == 6) {             Assert.assertEquals(Long.class, ffdE.getType().getTypeClass()).         }         if (pos == 7) {             Assert.assertEquals(Long.class, ffdE.getType().getTypeClass()).         }         if (pos == 8) {             Assert.assertEquals(String.class, ffdE.getType().getTypeClass()).         }         if (pos == 9) {             Assert.assertEquals(Integer.class, ffdE.getType().getTypeClass()).         }     }     ffd.clear().     pojoType.getFlatFields("*", 0, ffd).     Assert.assertEquals(10, ffd.size()).     // check if it returns 0-8     for (FlatFieldDescriptor ffdE : ffd) {         Assert.assertTrue(ffdE.getPosition() <= 9).         Assert.assertTrue(0 <= ffdE.getPosition()).         if (ffdE.getPosition() == 9) {             Assert.assertEquals(Integer.class, ffdE.getType().getTypeClass()).         }     }     ffd.clear().     // ComplexNestedClass complex     TypeInformation<?> typeComplexNested = pojoType.getTypeAt(0).     Assert.assertTrue(typeComplexNested instanceof PojoTypeInfo).     Assert.assertEquals(7, typeComplexNested.getArity()).     Assert.assertEquals(9, typeComplexNested.getTotalFields()).     PojoTypeInfo<?> pojoTypeComplexNested = (PojoTypeInfo<?>) typeComplexNested.     boolean dateSeen = false, intSeen = false, floatSeen = false, tupleSeen = false, objectSeen = false, writableSeen = false, collectionSeen = false.     for (int i = 0. i < pojoTypeComplexNested.getArity(). i++) {         PojoField field = pojoTypeComplexNested.getPojoFieldAt(i).         String name = field.getField().getName().         if (name.equals("date")) {             if (dateSeen) {                 Assert.fail("already seen").             }             dateSeen = true.             Assert.assertEquals(BasicTypeInfo.DATE_TYPE_INFO, field.getTypeInformation()).             Assert.assertEquals(Date.class, field.getTypeInformation().getTypeClass()).         } else if (name.equals("someNumberWithÜnicödeNäme")) {             if (intSeen) {                 Assert.fail("already seen").             }             intSeen = true.             Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, field.getTypeInformation()).             Assert.assertEquals(Integer.class, field.getTypeInformation().getTypeClass()).         } else if (name.equals("someFloat")) {             if (floatSeen) {                 Assert.fail("already seen").             }             floatSeen = true.             Assert.assertEquals(BasicTypeInfo.FLOAT_TYPE_INFO, field.getTypeInformation()).             Assert.assertEquals(Float.class, field.getTypeInformation().getTypeClass()).         } else if (name.equals("word")) {             if (tupleSeen) {                 Assert.fail("already seen").             }             tupleSeen = true.             Assert.assertTrue(field.getTypeInformation() instanceof TupleTypeInfo<?>).             Assert.assertEquals(Tuple3.class, field.getTypeInformation().getTypeClass()).             // do some more advanced checks on the tuple             TupleTypeInfo<?> tupleTypeFromComplexNested = (TupleTypeInfo<?>) field.getTypeInformation().             Assert.assertEquals(BasicTypeInfo.LONG_TYPE_INFO, tupleTypeFromComplexNested.getTypeAt(0)).             Assert.assertEquals(BasicTypeInfo.LONG_TYPE_INFO, tupleTypeFromComplexNested.getTypeAt(1)).             Assert.assertEquals(BasicTypeInfo.STRING_TYPE_INFO, tupleTypeFromComplexNested.getTypeAt(2)).         } else if (name.equals("nothing")) {             if (objectSeen) {                 Assert.fail("already seen").             }             objectSeen = true.             Assert.assertEquals(new GenericTypeInfo<Object>(Object.class), field.getTypeInformation()).             Assert.assertEquals(Object.class, field.getTypeInformation().getTypeClass()).         } else if (name.equals("valueType")) {             if (writableSeen) {                 Assert.fail("already seen").             }             writableSeen = true.             Assert.assertEquals(new ValueTypeInfo<>(MyValue.class), field.getTypeInformation()).             Assert.assertEquals(MyValue.class, field.getTypeInformation().getTypeClass()).         } else if (name.equals("collection")) {             if (collectionSeen) {                 Assert.fail("already seen").             }             collectionSeen = true.             Assert.assertEquals(new GenericTypeInfo(List.class), field.getTypeInformation()).         } else {             Assert.fail("field " + field + " is not expected").         }     }     Assert.assertTrue("Field was not present", dateSeen).     Assert.assertTrue("Field was not present", intSeen).     Assert.assertTrue("Field was not present", floatSeen).     Assert.assertTrue("Field was not present", tupleSeen).     Assert.assertTrue("Field was not present", objectSeen).     Assert.assertTrue("Field was not present", writableSeen).     Assert.assertTrue("Field was not present", collectionSeen).     // int count     TypeInformation<?> typeAtOne = pojoType.getTypeAt(1).     Assert.assertTrue(typeAtOne instanceof BasicTypeInfo).     Assert.assertEquals(typeInfo.getTypeClass(), WC.class).     Assert.assertEquals(typeInfo.getArity(), 2). }
false;public;0;8;;@Test public void testPojoAllPublic() {     TypeInformation<?> typeForClass = TypeExtractor.createTypeInfo(AllPublic.class).     checkAllPublicAsserts(typeForClass).     TypeInformation<?> typeForObject = TypeExtractor.getForObject(new AllPublic()).     checkAllPublicAsserts(typeForObject). }
false;private;1;42;;private void checkAllPublicAsserts(TypeInformation<?> typeInformation) {     Assert.assertTrue(typeInformation instanceof PojoTypeInfo).     Assert.assertEquals(10, typeInformation.getArity()).     Assert.assertEquals(12, typeInformation.getTotalFields()).     // check if the three additional fields are identified correctly     boolean arrayListSeen = false, multisetSeen = false, strArraySeen = false.     PojoTypeInfo<?> pojoTypeForClass = (PojoTypeInfo<?>) typeInformation.     for (int i = 0. i < pojoTypeForClass.getArity(). i++) {         PojoField field = pojoTypeForClass.getPojoFieldAt(i).         String name = field.getField().getName().         if (name.equals("somethingFancy")) {             if (arrayListSeen) {                 Assert.fail("already seen").             }             arrayListSeen = true.             Assert.assertTrue(field.getTypeInformation() instanceof GenericTypeInfo).             Assert.assertEquals(ArrayList.class, field.getTypeInformation().getTypeClass()).         } else if (name.equals("fancyIds")) {             if (multisetSeen) {                 Assert.fail("already seen").             }             multisetSeen = true.             Assert.assertTrue(field.getTypeInformation() instanceof GenericTypeInfo).             Assert.assertEquals(FancyCollectionSubtype.class, field.getTypeInformation().getTypeClass()).         } else if (name.equals("fancyArray")) {             if (strArraySeen) {                 Assert.fail("already seen").             }             strArraySeen = true.             Assert.assertEquals(BasicArrayTypeInfo.STRING_ARRAY_TYPE_INFO, field.getTypeInformation()).             Assert.assertEquals(String[].class, field.getTypeInformation().getTypeClass()).         } else if (Arrays.asList("date", "someNumberWithÜnicödeNäme", "someFloat", "word", "nothing", "valueType", "collection").contains(name)) {         // ignore these, they are inherited from the ComplexNestedClass         } else {             Assert.fail("field " + field + " is not expected").         }     }     Assert.assertTrue("Field was not present", arrayListSeen).     Assert.assertTrue("Field was not present", multisetSeen).     Assert.assertTrue("Field was not present", strArraySeen). }
false;public;0;10;;@Test public void testPojoExtendingTuple() {     TypeInformation<?> typeForClass = TypeExtractor.createTypeInfo(FromTuple.class).     checkFromTuplePojo(typeForClass).     FromTuple ft = new FromTuple().     ft.f0 = "".     ft.f1 = "".     ft.f2 = 0L.     TypeInformation<?> typeForObject = TypeExtractor.getForObject(ft).     checkFromTuplePojo(typeForObject). }
false;private;1;18;;private void checkFromTuplePojo(TypeInformation<?> typeInformation) {     Assert.assertTrue(typeInformation instanceof PojoTypeInfo<?>).     Assert.assertEquals(4, typeInformation.getTotalFields()).     PojoTypeInfo<?> pojoTypeForClass = (PojoTypeInfo<?>) typeInformation.     for (int i = 0. i < pojoTypeForClass.getArity(). i++) {         PojoField field = pojoTypeForClass.getPojoFieldAt(i).         String name = field.getField().getName().         if (name.equals("special")) {             Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, field.getTypeInformation()).         } else if (name.equals("f0") || name.equals("f1")) {             Assert.assertEquals(BasicTypeInfo.STRING_TYPE_INFO, field.getTypeInformation()).         } else if (name.equals("f2")) {             Assert.assertEquals(BasicTypeInfo.LONG_TYPE_INFO, field.getTypeInformation()).         } else {             Assert.fail("unexpected field").         }     } }
false;public;0;21;;@Test public void testPojoWithGenerics() {     TypeInformation<?> typeForClass = TypeExtractor.createTypeInfo(ParentSettingGenerics.class).     Assert.assertTrue(typeForClass instanceof PojoTypeInfo<?>).     PojoTypeInfo<?> pojoTypeForClass = (PojoTypeInfo<?>) typeForClass.     for (int i = 0. i < pojoTypeForClass.getArity(). i++) {         PojoField field = pojoTypeForClass.getPojoFieldAt(i).         String name = field.getField().getName().         if (name.equals("field1")) {             Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, field.getTypeInformation()).         } else if (name.equals("field2")) {             Assert.assertEquals(BasicTypeInfo.LONG_TYPE_INFO, field.getTypeInformation()).         } else if (name.equals("field3")) {             Assert.assertEquals(BasicTypeInfo.STRING_TYPE_INFO, field.getTypeInformation()).         } else if (name.equals("key")) {             Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, field.getTypeInformation()).         } else {             Assert.fail("Unexpected field " + field).         }     } }
true;public;0;19;/**  * Test if the TypeExtractor is accepting untyped generics,  * making them GenericTypes  */ ;/**  * Test if the TypeExtractor is accepting untyped generics,  * making them GenericTypes  */ @Test public void testPojoWithGenericsSomeFieldsGeneric() {     TypeInformation<?> typeForClass = TypeExtractor.createTypeInfo(PojoWithGenerics.class).     Assert.assertTrue(typeForClass instanceof PojoTypeInfo<?>).     PojoTypeInfo<?> pojoTypeForClass = (PojoTypeInfo<?>) typeForClass.     for (int i = 0. i < pojoTypeForClass.getArity(). i++) {         PojoField field = pojoTypeForClass.getPojoFieldAt(i).         String name = field.getField().getName().         if (name.equals("field1")) {             Assert.assertEquals(new GenericTypeInfo<Object>(Object.class), field.getTypeInformation()).         } else if (name.equals("field2")) {             Assert.assertEquals(new GenericTypeInfo<Object>(Object.class), field.getTypeInformation()).         } else if (name.equals("key")) {             Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, field.getTypeInformation()).         } else {             Assert.fail("Unexpected field " + field).         }     } }
false;public;0;20;;@Test public void testPojoWithComplexHierarchy() {     TypeInformation<?> typeForClass = TypeExtractor.createTypeInfo(ComplexHierarchyTop.class).     Assert.assertTrue(typeForClass instanceof PojoTypeInfo<?>).     PojoTypeInfo<?> pojoTypeForClass = (PojoTypeInfo<?>) typeForClass.     for (int i = 0. i < pojoTypeForClass.getArity(). i++) {         PojoField field = pojoTypeForClass.getPojoFieldAt(i).         String name = field.getField().getName().         if (name.equals("field1")) {             // From tuple is pojo (not tuple type!)             Assert.assertTrue(field.getTypeInformation() instanceof PojoTypeInfo<?>).         } else if (name.equals("field2")) {             Assert.assertTrue(field.getTypeInformation() instanceof TupleTypeInfo<?>).             Assert.assertTrue(((TupleTypeInfo<?>) field.getTypeInformation()).getTypeAt(0).equals(BasicTypeInfo.STRING_TYPE_INFO)).         } else if (name.equals("key")) {             Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, field.getTypeInformation()).         } else {             Assert.fail("Unexpected field " + field).         }     } }
false;public;1;5;;@Override public PojoWithGenerics<T, T> map(PojoWithGenerics<Long, T> value) throws Exception {     return null. }
false;public;0;24;;@Test public void testGenericPojoTypeInference1() {     MyMapper<String> function = new MyMapper<>().     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(function, TypeInformation.of(new TypeHint<PojoWithGenerics<Long, String>>() {     })).     Assert.assertTrue(ti instanceof PojoTypeInfo<?>).     PojoTypeInfo<?> pti = (PojoTypeInfo<?>) ti.     for (int i = 0. i < pti.getArity(). i++) {         PojoField field = pti.getPojoFieldAt(i).         String name = field.getField().getName().         if (name.equals("field1")) {             Assert.assertEquals(BasicTypeInfo.STRING_TYPE_INFO, field.getTypeInformation()).         } else if (name.equals("field2")) {             Assert.assertEquals(BasicTypeInfo.STRING_TYPE_INFO, field.getTypeInformation()).         } else if (name.equals("key")) {             Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, field.getTypeInformation()).         } else {             Assert.fail("Unexpected field " + field).         }     } }
false;public;1;4;;@Override public PojoTuple<E, D, D> map(Tuple2<E, D> value) throws Exception {     return null. }
false;public;0;27;;@SuppressWarnings({ "unchecked", "rawtypes" }) @Test public void testGenericPojoTypeInference2() {     MyMapper2<Boolean, Character> function = new MyMapper2<>().     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(function, TypeInformation.of(new TypeHint<Tuple2<Character, Boolean>>() {     })).     Assert.assertTrue(ti instanceof PojoTypeInfo<?>).     PojoTypeInfo<?> pti = (PojoTypeInfo<?>) ti.     for (int i = 0. i < pti.getArity(). i++) {         PojoField field = pti.getPojoFieldAt(i).         String name = field.getField().getName().         if (name.equals("extraField")) {             Assert.assertEquals(BasicTypeInfo.CHAR_TYPE_INFO, field.getTypeInformation()).         } else if (name.equals("f0")) {             Assert.assertEquals(BasicTypeInfo.BOOLEAN_TYPE_INFO, field.getTypeInformation()).         } else if (name.equals("f1")) {             Assert.assertEquals(BasicTypeInfo.BOOLEAN_TYPE_INFO, field.getTypeInformation()).         } else if (name.equals("f2")) {             Assert.assertEquals(BasicTypeInfo.LONG_TYPE_INFO, field.getTypeInformation()).         } else {             Assert.fail("Unexpected field " + field).         }     } }
false;public;1;4;;@Override public Tuple2<E, D> map(PojoTuple<E, D, D> value) throws Exception {     return null. }
false;public;0;14;;@SuppressWarnings({ "unchecked", "rawtypes" }) @Test public void testGenericPojoTypeInference3() {     MyMapper3<Boolean, Character> function = new MyMapper3<>().     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(function, TypeInformation.of(new TypeHint<PojoTuple<Character, Boolean, Boolean>>() {     })).     Assert.assertTrue(ti instanceof TupleTypeInfo<?>).     TupleTypeInfo<?> tti = (TupleTypeInfo<?>) ti.     Assert.assertEquals(BasicTypeInfo.CHAR_TYPE_INFO, tti.getTypeAt(0)).     Assert.assertEquals(BasicTypeInfo.BOOLEAN_TYPE_INFO, tti.getTypeAt(1)). }
false;public;1;4;;@Override public A map(PojoWithParameterizedFields1<A> value) throws Exception {     return null. }
false;public;0;10;;@SuppressWarnings({ "unchecked", "rawtypes" }) @Test public void testGenericPojoTypeInference4() {     MyMapper4<Byte> function = new MyMapper4<>().     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(function, TypeInformation.of(new TypeHint<PojoWithParameterizedFields1<Byte>>() {     })).     Assert.assertEquals(BasicTypeInfo.BYTE_TYPE_INFO, ti). }
false;public;1;4;;@Override public A map(PojoWithParameterizedFields2<A> value) throws Exception {     return null. }
false;public;0;10;;@SuppressWarnings({ "unchecked", "rawtypes" }) @Test public void testGenericPojoTypeInference5() {     MyMapper5<Byte> function = new MyMapper5<>().     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(function, TypeInformation.of(new TypeHint<PojoWithParameterizedFields2<Byte>>() {     })).     Assert.assertEquals(BasicTypeInfo.BYTE_TYPE_INFO, ti). }
false;public;1;4;;@Override public A map(PojoWithParameterizedFields3<A> value) throws Exception {     return null. }
false;public;0;10;;@SuppressWarnings({ "unchecked", "rawtypes" }) @Test public void testGenericPojoTypeInference6() {     MyMapper6<Integer> function = new MyMapper6<>().     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(function, TypeInformation.of(new TypeHint<PojoWithParameterizedFields3<Integer>>() {     })).     Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, ti). }
false;public;1;4;;@Override public A map(PojoWithParameterizedFields4<A> value) throws Exception {     return null. }
false;public;0;11;;@SuppressWarnings({ "unchecked", "rawtypes" }) @Test public void testGenericPojoTypeInference7() {     MyMapper7<Integer> function = new MyMapper7<>().     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(function, TypeInformation.of(new TypeHint<PojoWithParameterizedFields4<Integer>>() {     })).     Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, ti). }
false;public;0;6;;@Test public void testRecursivePojo1() {     TypeInformation<?> ti = TypeExtractor.createTypeInfo(RecursivePojo1.class).     Assert.assertTrue(ti instanceof PojoTypeInfo).     Assert.assertEquals(GenericTypeInfo.class, ((PojoTypeInfo) ti).getPojoFieldAt(0).getTypeInformation().getClass()). }
false;public;0;8;;@Test public void testRecursivePojo2() {     TypeInformation<?> ti = TypeExtractor.createTypeInfo(RecursivePojo2.class).     Assert.assertTrue(ti instanceof PojoTypeInfo).     PojoField pf = ((PojoTypeInfo) ti).getPojoFieldAt(0).     Assert.assertTrue(pf.getTypeInformation() instanceof TupleTypeInfo).     Assert.assertEquals(GenericTypeInfo.class, ((TupleTypeInfo) pf.getTypeInformation()).getTypeAt(0).getClass()). }
false;public;0;8;;@Test public void testRecursivePojo3() {     TypeInformation<?> ti = TypeExtractor.createTypeInfo(RecursivePojo3.class).     Assert.assertTrue(ti instanceof PojoTypeInfo).     PojoField pf = ((PojoTypeInfo) ti).getPojoFieldAt(0).     Assert.assertTrue(pf.getTypeInformation() instanceof PojoTypeInfo).     Assert.assertEquals(GenericTypeInfo.class, ((PojoTypeInfo) pf.getTypeInformation()).getPojoFieldAt(0).getTypeInformation().getClass()). }
false;public;1;4;;@Override public Tuple2<FooBarPojo, FooBarPojo> map(FooBarPojo value) throws Exception {     return null. }
false;public;0;9;;@Test public void testDualUseOfPojo() {     MapFunction<?, ?> function = new DuplicateMapper().     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(function, (TypeInformation) TypeExtractor.createTypeInfo(FooBarPojo.class)).     Assert.assertTrue(ti instanceof TupleTypeInfo).     TupleTypeInfo<?> tti = ((TupleTypeInfo) ti).     Assert.assertTrue(tti.getTypeAt(0) instanceof PojoTypeInfo).     Assert.assertTrue(tti.getTypeAt(1) instanceof PojoTypeInfo). }
false;public;0;6;;@Test public void testPojoWithRecursiveGenericField() {     TypeInformation<?> ti = TypeExtractor.createTypeInfo(PojoWithRecursiveGenericField.class).     Assert.assertTrue(ti instanceof PojoTypeInfo).     Assert.assertEquals(GenericTypeInfo.class, ((PojoTypeInfo) ti).getPojoFieldAt(0).getTypeInformation().getClass()). }
false;public;0;8;;@Test public void testPojosWithMutualRecursion() {     TypeInformation<?> ti = TypeExtractor.createTypeInfo(MutualPojoB.class).     Assert.assertTrue(ti instanceof PojoTypeInfo).     TypeInformation<?> pti = ((PojoTypeInfo) ti).getPojoFieldAt(0).getTypeInformation().     Assert.assertTrue(pti instanceof PojoTypeInfo).     Assert.assertEquals(GenericTypeInfo.class, ((PojoTypeInfo) pti).getPojoFieldAt(0).getTypeInformation().getClass()). }
false;public;0;8;;@Test public void testRecursivePojoWithTypeVariable() {     TypeInformation<?> ti = TypeExtractor.createTypeInfo(MyType.class).     Assert.assertTrue(ti instanceof PojoTypeInfo).     TypeInformation<?> pti = ((PojoTypeInfo) ti).getPojoFieldAt(0).getTypeInformation().     Assert.assertTrue(pti instanceof PojoTypeInfo).     Assert.assertEquals(GenericTypeInfo.class, ((PojoTypeInfo) pti).getPojoFieldAt(0).getTypeInformation().getClass()). }
false;public;0;9;;@Test public void testLombokPojo() {     TypeInformation<TestLombok> ti = TypeExtractor.getForClass(TestLombok.class).     Assert.assertTrue(ti instanceof PojoTypeInfo).     PojoTypeInfo<TestLombok> pti = (PojoTypeInfo<TestLombok>) ti.     Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, pti.getTypeAt(0)).     Assert.assertEquals(BasicTypeInfo.STRING_TYPE_INFO, pti.getTypeAt(1)). }
