commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public void close() throws IOException {     closeable.close(). }
false;public;0;4;;@Override public Closeable getWrappedDelegate() {     return closeable. }
false;protected;1;16;;@Override protected void registerCloseable(final Closeable closeable) throws IOException {     final WrappingProxyCloseable<Closeable> wrappingProxyCloseable = new WrappingProxyCloseable<Closeable>() {          @Override         public void close() throws IOException {             closeable.close().         }          @Override         public Closeable getWrappedDelegate() {             return closeable.         }     }.     closeableRegistry.registerCloseable(wrappingProxyCloseable). }
false;protected;0;7;;@Override protected AbstractCloseableRegistry<WrappingProxyCloseable<? extends Closeable>, SafetyNetCloseableRegistry.PhantomDelegatingCloseableRef> createRegistry() {     return new SafetyNetCloseableRegistry(). }
false;protected;0;12;;@Override protected void createAndRegisterStream() throws IOException {     String debug = Thread.currentThread().getName() + " " + count.     TestStream testStream = new TestStream(refCount).     // this method automatically registers the stream with the given registry.     @SuppressWarnings("unused")     ClosingFSDataInputStream pis = ClosingFSDataInputStream.wrapSafe(testStream, (SafetyNetCloseableRegistry) registry, // reference dies here     debug).     ++count. }
false;protected;3;30;;@Override protected AbstractCloseableRegistryTest.ProducerThread<WrappingProxyCloseable<? extends Closeable>, SafetyNetCloseableRegistry.PhantomDelegatingCloseableRef> createProducerThread(AbstractCloseableRegistry<WrappingProxyCloseable<? extends Closeable>, SafetyNetCloseableRegistry.PhantomDelegatingCloseableRef> registry, AtomicInteger unclosedCounter, int maxStreams) {     return new AbstractCloseableRegistryTest.ProducerThread<WrappingProxyCloseable<? extends Closeable>, SafetyNetCloseableRegistry.PhantomDelegatingCloseableRef>(registry, unclosedCounter, maxStreams) {          int count = 0.          @Override         protected void createAndRegisterStream() throws IOException {             String debug = Thread.currentThread().getName() + " " + count.             TestStream testStream = new TestStream(refCount).             // this method automatically registers the stream with the given registry.             @SuppressWarnings("unused")             ClosingFSDataInputStream pis = ClosingFSDataInputStream.wrapSafe(testStream, (SafetyNetCloseableRegistry) registry, // reference dies here             debug).             ++count.         }     }. }
false;public;0;4;;@After public void tearDown() {     Assert.assertFalse(SafetyNetCloseableRegistry.isReaperThreadRunning()). }
false;public;0;14;;@Override public void go() {     FileSystem fs2 = FileSystem.getLocalFileSystem().     // ensure the safety net does not leak here     Assert.assertFalse(fs2 instanceof SafetyNetWrapperFileSystem).     FileSystemSafetyNet.initializeSafetyNetForThread().     fs2 = FileSystem.getLocalFileSystem().     // ensure we can bring another safety net in place     Assert.assertTrue(fs2 instanceof SafetyNetWrapperFileSystem).     FileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread().     fs2 = FileSystem.getLocalFileSystem().     // and that we can remove it again     Assert.assertFalse(fs2 instanceof SafetyNetWrapperFileSystem). }
false;public;0;55;;@Override public void go() throws Exception {     try {         FileSystem fs1 = FileSystem.getLocalFileSystem().         // ensure no safety net in place         Assert.assertFalse(fs1 instanceof SafetyNetWrapperFileSystem).         FileSystemSafetyNet.initializeSafetyNetForThread().         fs1 = FileSystem.getLocalFileSystem().         // ensure safety net is in place now         Assert.assertTrue(fs1 instanceof SafetyNetWrapperFileSystem).         Path tmp = new Path(tmpFolder.newFolder().toURI().toString(), "test_file").         try (FSDataOutputStream stream = fs1.create(tmp, FileSystem.WriteMode.NO_OVERWRITE)) {             CheckedThread t2 = new CheckedThread() {                  @Override                 public void go() {                     FileSystem fs2 = FileSystem.getLocalFileSystem().                     // ensure the safety net does not leak here                     Assert.assertFalse(fs2 instanceof SafetyNetWrapperFileSystem).                     FileSystemSafetyNet.initializeSafetyNetForThread().                     fs2 = FileSystem.getLocalFileSystem().                     // ensure we can bring another safety net in place                     Assert.assertTrue(fs2 instanceof SafetyNetWrapperFileSystem).                     FileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread().                     fs2 = FileSystem.getLocalFileSystem().                     // and that we can remove it again                     Assert.assertFalse(fs2 instanceof SafetyNetWrapperFileSystem).                 }             }.             t2.start().             t2.sync().             // ensure stream is still open and was never closed by any interferences             stream.write(42).             FileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread().             // ensure leaking stream was closed             try {                 stream.write(43).                 Assert.fail().             } catch (IOException ignore) {             }             fs1 = FileSystem.getLocalFileSystem().             // ensure safety net was removed             Assert.assertFalse(fs1 instanceof SafetyNetWrapperFileSystem).         } finally {             fs1.delete(tmp, false).         }     } catch (Exception e) {         Assert.fail(ExceptionUtils.stringifyException(e)).     } }
false;public;0;64;;@Test public void testCorrectScopesForSafetyNet() throws Exception {     CheckedThread t1 = new CheckedThread() {          @Override         public void go() throws Exception {             try {                 FileSystem fs1 = FileSystem.getLocalFileSystem().                 // ensure no safety net in place                 Assert.assertFalse(fs1 instanceof SafetyNetWrapperFileSystem).                 FileSystemSafetyNet.initializeSafetyNetForThread().                 fs1 = FileSystem.getLocalFileSystem().                 // ensure safety net is in place now                 Assert.assertTrue(fs1 instanceof SafetyNetWrapperFileSystem).                 Path tmp = new Path(tmpFolder.newFolder().toURI().toString(), "test_file").                 try (FSDataOutputStream stream = fs1.create(tmp, FileSystem.WriteMode.NO_OVERWRITE)) {                     CheckedThread t2 = new CheckedThread() {                          @Override                         public void go() {                             FileSystem fs2 = FileSystem.getLocalFileSystem().                             // ensure the safety net does not leak here                             Assert.assertFalse(fs2 instanceof SafetyNetWrapperFileSystem).                             FileSystemSafetyNet.initializeSafetyNetForThread().                             fs2 = FileSystem.getLocalFileSystem().                             // ensure we can bring another safety net in place                             Assert.assertTrue(fs2 instanceof SafetyNetWrapperFileSystem).                             FileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread().                             fs2 = FileSystem.getLocalFileSystem().                             // and that we can remove it again                             Assert.assertFalse(fs2 instanceof SafetyNetWrapperFileSystem).                         }                     }.                     t2.start().                     t2.sync().                     // ensure stream is still open and was never closed by any interferences                     stream.write(42).                     FileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread().                     // ensure leaking stream was closed                     try {                         stream.write(43).                         Assert.fail().                     } catch (IOException ignore) {                     }                     fs1 = FileSystem.getLocalFileSystem().                     // ensure safety net was removed                     Assert.assertFalse(fs1 instanceof SafetyNetWrapperFileSystem).                 } finally {                     fs1.delete(tmp, false).                 }             } catch (Exception e) {                 Assert.fail(ExceptionUtils.stringifyException(e)).             }         }     }.     t1.start().     t1.sync(). }
false;public;0;15;;@Test public void testSafetyNetClose() throws Exception {     setup(20).     startThreads().     joinThreads().     for (int i = 0. i < 5 && unclosedCounter.get() > 0. ++i) {         System.gc().         Thread.sleep(50).     }     Assert.assertEquals(0, unclosedCounter.get()).     closeableRegistry.close(). }
false;public;0;14;;@Test public void testReaperThreadSpawnAndStop() throws Exception {     Assert.assertFalse(SafetyNetCloseableRegistry.isReaperThreadRunning()).     try (SafetyNetCloseableRegistry ignored = new SafetyNetCloseableRegistry()) {         Assert.assertTrue(SafetyNetCloseableRegistry.isReaperThreadRunning()).         try (SafetyNetCloseableRegistry ignored2 = new SafetyNetCloseableRegistry()) {             Assert.assertTrue(SafetyNetCloseableRegistry.isReaperThreadRunning()).         }         Assert.assertTrue(SafetyNetCloseableRegistry.isReaperThreadRunning()).     }     Assert.assertFalse(SafetyNetCloseableRegistry.isReaperThreadRunning()). }
