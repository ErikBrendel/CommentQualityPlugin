commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Test public void testSimplePojoTypeExtraction() {     TypeInformation<SimplePojo> type = TypeExtractor.getForClass(SimplePojo.class).     assertTrue("Extracted type is not a composite/pojo type but should be.", type instanceof CompositeType). }
false;public;0;5;;@Test public void testNestedPojoTypeExtraction() {     TypeInformation<NestedPojoOuter> type = TypeExtractor.getForClass(NestedPojoOuter.class).     assertTrue("Extracted type is not a Pojo type but should be.", type instanceof CompositeType). }
false;public;0;7;;@Test public void testRecursivePojoTypeExtraction() {     // This one tests whether a recursive pojo is detected using the set of visited     // types in the type extractor. The recursive field will be handled using the generic serializer.     TypeInformation<Recursive1Pojo> type = TypeExtractor.getForClass(Recursive1Pojo.class).     assertTrue("Extracted type is not a Pojo type but should be.", type instanceof CompositeType). }
false;public;0;5;;@Test public void testRecursivePojoObjectTypeExtraction() {     TypeInformation<Recursive1Pojo> type = TypeExtractor.getForObject(new Recursive1Pojo()).     assertTrue("Extracted type is not a Pojo type but should be.", type instanceof CompositeType). }
