commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Test public void serializerSnapshotIsSuccessfullyRead() {     TypeSerializerSnapshot<ElementT> snapshot = snapshotUnderTest().     assertThat(snapshot, allOf(notNullValue(), instanceOf(TypeSerializerSnapshot.class))). }
false;public;0;8;;@Test public void specifiedNewSerializerHasExpectedCompatibilityResultsWithSnapshot() {     TypeSerializerSnapshot<ElementT> snapshot = snapshotUnderTest().     TypeSerializerSchemaCompatibility<ElementT> result = snapshot.resolveSchemaCompatibility(testSpecification.createSerializer()).     assertThat(result, testSpecification.schemaCompatibilityMatcher). }
false;public;0;7;;@Test public void restoredSerializerIsAbleToDeserializePreviousData() throws IOException {     TypeSerializerSnapshot<ElementT> snapshot = snapshotUnderTest().     TypeSerializer<ElementT> serializer = snapshot.restoreSerializer().     assertSerializerIsAbleToReadOldData(serializer). }
false;public;0;13;;@Test public void reconfiguredSerializerIsAbleToDeserializePreviousData() throws IOException {     TypeSerializerSnapshot<ElementT> snapshot = snapshotUnderTest().     TypeSerializerSchemaCompatibility<ElementT> compatibility = snapshot.resolveSchemaCompatibility(testSpecification.createSerializer()).     if (!compatibility.isCompatibleWithReconfiguredSerializer()) {         // this test only applies for reconfigured serializers.         return.     }     TypeSerializer<ElementT> serializer = compatibility.getReconfiguredSerializer().     assertSerializerIsAbleToReadOldData(serializer). }
false;public;0;16;;@SuppressWarnings("deprecation") @Test public void movingForward() throws IOException {     TypeSerializerSnapshot<ElementT> previousSnapshot = snapshotUnderTest().     TypeSerializer<ElementT> restoredSerializer = previousSnapshot.restoreSerializer().     TypeSerializerSnapshot<ElementT> nextSnapshot = restoredSerializer.snapshotConfiguration().     assertThat(nextSnapshot, instanceOf(testSpecification.snapshotClass)).     TypeSerializerSnapshot<ElementT> nextSnapshotDeserialized = writeAndThenReadTheSnapshot(restoredSerializer, nextSnapshot).     assertThat(nextSnapshotDeserialized, allOf(notNullValue(), not(instanceOf(TypeSerializerConfigSnapshot.class)))). }
false;public;0;21;;@Test public void restoreSerializerFromNewSerializerSnapshotIsAbleToDeserializePreviousData() throws IOException {     TypeSerializer<ElementT> newSerializer = testSpecification.createSerializer().     TypeSerializerSchemaCompatibility<ElementT> compatibility = snapshotUnderTest().resolveSchemaCompatibility(newSerializer).     final TypeSerializer<ElementT> nextSerializer.     if (compatibility.isCompatibleWithReconfiguredSerializer()) {         nextSerializer = compatibility.getReconfiguredSerializer().     } else if (compatibility.isCompatibleAsIs()) {         nextSerializer = newSerializer.     } else {         // this test does not apply.         return.     }     TypeSerializerSnapshot<ElementT> nextSnapshot = nextSerializer.snapshotConfiguration().     assertSerializerIsAbleToReadOldData(nextSnapshot.restoreSerializer()). }
false;private;2;10;;// -------------------------------------------------------------------------------------------------------------- // Test Helpers // -------------------------------------------------------------------------------------------------------------- private TypeSerializerSnapshot<ElementT> writeAndThenReadTheSnapshot(TypeSerializer<ElementT> serializer, TypeSerializerSnapshot<ElementT> newSnapshot) throws IOException {     DataOutputSerializer out = new DataOutputSerializer(128).     TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(out, newSnapshot, serializer).     DataInputView in = new DataInputDeserializer(out.wrapAsByteBuffer()).     return readSnapshot(in). }
false;private;0;13;;private TypeSerializerSnapshot<ElementT> snapshotUnderTest() {     DataInputView input = contentsOf(testSpecification.getSnapshotDataLocation()).     try {         if (!testSpecification.getTestMigrationVersion().isNewerVersionThan(MigrationVersion.v1_6)) {             return readPre17SnapshotFormat(input).         } else {             return readSnapshot(input).         }     } catch (IOException e) {         throw new RuntimeException("Unable to read " + testSpecification.getSnapshotDataLocation(), e).     } }
false;private;1;9;;@SuppressWarnings({ "unchecked", "deprecation" }) private TypeSerializerSnapshot<ElementT> readPre17SnapshotFormat(DataInputView input) throws IOException {     final ClassLoader cl = Thread.currentThread().getContextClassLoader().     List<Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> serializers = TypeSerializerSerializationUtil.readSerializersAndConfigsWithResilience(input, cl).     return (TypeSerializerSnapshot<ElementT>) serializers.get(0).f1. }
false;private;1;4;;private TypeSerializerSnapshot<ElementT> readSnapshot(DataInputView in) throws IOException {     return TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(in, Thread.currentThread().getContextClassLoader(), null). }
false;private;0;3;;private DataInputView dataUnderTest() {     return contentsOf(testSpecification.getTestDataLocation()). }
false;private;1;9;;private void assertSerializerIsAbleToReadOldData(TypeSerializer<ElementT> serializer) throws IOException {     DataInputView input = dataUnderTest().     final Matcher<ElementT> matcher = testSpecification.testDataElementMatcher.     for (int i = 0. i < testSpecification.testDataCount. i++) {         final ElementT result = serializer.deserialize(input).         assertThat(result, matcher).     } }
false;private,static;1;9;;// -------------------------------------------------------------------------------------------------------------- // Static Helpers // -------------------------------------------------------------------------------------------------------------- private static DataInputView contentsOf(Path path) {     try {         byte[] bytes = Files.readAllBytes(path).         return new DataInputDeserializer(bytes).     } catch (IOException e) {         throw new RuntimeException("Failed to read " + path, e).     } }
false;private,static;1;14;;private static Path resourcePath(String resourceName) {     checkNotNull(resourceName, "resource name can not be NULL").     try {         ClassLoader cl = Thread.currentThread().getContextClassLoader().         URL resource = cl.getResource(resourceName).         if (resource == null) {             throw new IllegalArgumentException("unable locate test data " + resourceName).         }         return Paths.get(resource.toURI()).     } catch (URISyntaxException e) {         throw new RuntimeException("unable", e).     } }
false;public,static;4;13;;@SuppressWarnings("unchecked") public static <T> TestSpecification<T> builder(String name, Class<? extends TypeSerializer> serializerClass, Class<? extends TypeSerializerSnapshot> snapshotClass, MigrationVersion testMigrationVersion) {     return new TestSpecification<>(name, (Class<? extends TypeSerializer<T>>) serializerClass, (Class<? extends TypeSerializerSnapshot<T>>) snapshotClass, testMigrationVersion). }
false;public;1;3;;public TestSpecification<T> withNewSerializerProvider(Supplier<? extends TypeSerializer<T>> serializerProvider) {     return withNewSerializerProvider(serializerProvider, TypeSerializerSchemaCompatibility.compatibleAsIs()). }
false;public;2;7;;public TestSpecification<T> withNewSerializerProvider(Supplier<? extends TypeSerializer<T>> serializerProvider, TypeSerializerSchemaCompatibility<T> expectedCompatibilityResult) {     this.serializerProvider = serializerProvider.     this.schemaCompatibilityMatcher = hasSameCompatibilityAs(expectedCompatibilityResult).     return this. }
false;public;1;5;;public TestSpecification<T> withSchemaCompatibilityMatcher(Matcher<TypeSerializerSchemaCompatibility<T>> schemaCompatibilityMatcher) {     this.schemaCompatibilityMatcher = schemaCompatibilityMatcher.     return this. }
false;public;1;4;;public TestSpecification<T> withSnapshotDataLocation(String snapshotDataLocation) {     this.snapshotDataLocation = snapshotDataLocation.     return this. }
false;public;2;5;;public TestSpecification<T> withTestData(String testDataLocation, int testDataCount) {     this.testDataLocation = testDataLocation.     this.testDataCount = testDataCount.     return this. }
false;public;1;4;;public TestSpecification<T> withTestDataMatcher(Matcher<T> matcher) {     testDataElementMatcher = matcher.     return this. }
false;public;1;4;;public TestSpecification<T> withTestDataCount(int expectedDataItmes) {     this.testDataCount = expectedDataItmes.     return this. }
false;private;0;8;;private TypeSerializer<T> createSerializer() {     try {         return (serializerProvider == null) ? serializerType.newInstance() : serializerProvider.get().     } catch (InstantiationException | IllegalAccessException e) {         throw new RuntimeException("serializer provider was not set, and creating the serializer reflectively failed.", e).     } }
false;private;0;3;;private Path getTestDataLocation() {     return resourcePath(this.testDataLocation). }
false;private;0;3;;private Path getSnapshotDataLocation() {     return resourcePath(this.snapshotDataLocation). }
false;private;0;3;;private MigrationVersion getTestMigrationVersion() {     return testMigrationVersion. }
false;public;0;4;;@Override public String toString() {     return String.format("%s , %s, %s", name, serializerType.getSimpleName(), snapshotClass.getSimpleName()). }
true;public;4;21;/**  * Adds a test specification to be tested for all specified test versions.  *  * <p>This method adds the specification with pre-defined snapshot and data filenames,  * with the format "flink-&lt.testVersion&gt.-&lt.specName&gt.-&lt.data/snapshot&gt.",  * and each specification's test data count is assumed to always be 10.  *  * @param name test specification name.  * @param serializerClass class of the current serializer.  * @param snapshotClass class of the current serializer snapshot class.  * @param serializerProvider provider for an instance of the current serializer.  *  * @param <T> type of the test data.  */ ;/**  * Adds a test specification to be tested for all specified test versions.  *  * <p>This method adds the specification with pre-defined snapshot and data filenames,  * with the format "flink-&lt.testVersion&gt.-&lt.specName&gt.-&lt.data/snapshot&gt.",  * and each specification's test data count is assumed to always be 10.  *  * @param name test specification name.  * @param serializerClass class of the current serializer.  * @param snapshotClass class of the current serializer snapshot class.  * @param serializerProvider provider for an instance of the current serializer.  *  * @param <T> type of the test data.  */ public <T> void add(String name, Class<? extends TypeSerializer> serializerClass, Class<? extends TypeSerializerSnapshot> snapshotClass, Supplier<? extends TypeSerializer<T>> serializerProvider) {     for (MigrationVersion testVersion : testVersions) {         testSpecifications.add(TestSpecification.<T>builder(getSpecNameForVersion(name, testVersion), serializerClass, snapshotClass, testVersion).withNewSerializerProvider(serializerProvider).withSnapshotDataLocation(String.format(DEFAULT_SNAPSHOT_FILENAME_FORMAT, testVersion, name)).withTestData(String.format(DEFAULT_TEST_DATA_FILENAME_FORMAT, testVersion, name), DEFAULT_TEST_DATA_COUNT)).     } }
true;public;5;23;/**  * Adds a test specification to be tested for all specified test versions.  *  * <p>This method adds the specification with pre-defined snapshot and data filenames,  * with the format "flink-&lt.testVersion&gt.-&lt.specName&gt.-&lt.data/snapshot&gt.",  * and each specification's test data count is assumed to always be 10.  *  * @param <T> type of the test data.  */ ;/**  * Adds a test specification to be tested for all specified test versions.  *  * <p>This method adds the specification with pre-defined snapshot and data filenames,  * with the format "flink-&lt.testVersion&gt.-&lt.specName&gt.-&lt.data/snapshot&gt.",  * and each specification's test data count is assumed to always be 10.  *  * @param <T> type of the test data.  */ public <T> void addWithCompatibilityMatcher(String name, Class<? extends TypeSerializer> serializerClass, Class<? extends TypeSerializerSnapshot> snapshotClass, Supplier<? extends TypeSerializer<T>> serializerProvider, Matcher<TypeSerializerSchemaCompatibility<T>> schemaCompatibilityMatcher) {     for (MigrationVersion testVersion : testVersions) {         testSpecifications.add(TestSpecification.<T>builder(getSpecNameForVersion(name, testVersion), serializerClass, snapshotClass, testVersion).withNewSerializerProvider(serializerProvider).withSchemaCompatibilityMatcher(schemaCompatibilityMatcher).withSnapshotDataLocation(String.format(DEFAULT_SNAPSHOT_FILENAME_FORMAT, testVersion, name)).withTestData(String.format(DEFAULT_TEST_DATA_FILENAME_FORMAT, testVersion, name), DEFAULT_TEST_DATA_COUNT)).     } }
true;public;5;23;/**  * Adds a test specification to be tested for all specified test versions.  *  * <p>This method adds the specification with pre-defined snapshot and data filenames,  * with the format "flink-&lt.testVersion&gt.-&lt.specName&gt.-&lt.data/snapshot&gt.",  * and each specification's test data count is assumed to always be 10.  *  * @param name test specification name.  * @param serializerClass class of the current serializer.  * @param snapshotClass class of the current serializer snapshot class.  * @param serializerProvider provider for an instance of the current serializer.  * @param elementMatcher an {@code hamcrest} matcher to match test data.  *  * @param <T> type of the test data.  */ ;/**  * Adds a test specification to be tested for all specified test versions.  *  * <p>This method adds the specification with pre-defined snapshot and data filenames,  * with the format "flink-&lt.testVersion&gt.-&lt.specName&gt.-&lt.data/snapshot&gt.",  * and each specification's test data count is assumed to always be 10.  *  * @param name test specification name.  * @param serializerClass class of the current serializer.  * @param snapshotClass class of the current serializer snapshot class.  * @param serializerProvider provider for an instance of the current serializer.  * @param elementMatcher an {@code hamcrest} matcher to match test data.  *  * @param <T> type of the test data.  */ public <T> void add(String name, Class<? extends TypeSerializer> serializerClass, Class<? extends TypeSerializerSnapshot> snapshotClass, Supplier<? extends TypeSerializer<T>> serializerProvider, Matcher<T> elementMatcher) {     for (MigrationVersion testVersion : testVersions) {         testSpecifications.add(TestSpecification.<T>builder(getSpecNameForVersion(name, testVersion), serializerClass, snapshotClass, testVersion).withNewSerializerProvider(serializerProvider).withSnapshotDataLocation(String.format(DEFAULT_SNAPSHOT_FILENAME_FORMAT, testVersion, name)).withTestData(String.format(DEFAULT_TEST_DATA_FILENAME_FORMAT, testVersion, name), DEFAULT_TEST_DATA_COUNT).withTestDataMatcher(elementMatcher)).     } }
true;public;7;21;/**  * Adds a test specification to be tested for all specified test versions.  *  * @param name test specification name.  * @param serializerClass class of the current serializer.  * @param snapshotClass class of the current serializer snapshot class.  * @param serializerProvider provider for an instance of the current serializer.  * @param testSnapshotFilenameProvider provider for the filename of the test snapshot.  * @param testDataFilenameProvider provider for the filename of the test data.  * @param testDataCount expected number of records to be read in the test data files.  *  * @param <T> type of the test data.  */ ;/**  * Adds a test specification to be tested for all specified test versions.  *  * @param name test specification name.  * @param serializerClass class of the current serializer.  * @param snapshotClass class of the current serializer snapshot class.  * @param serializerProvider provider for an instance of the current serializer.  * @param testSnapshotFilenameProvider provider for the filename of the test snapshot.  * @param testDataFilenameProvider provider for the filename of the test data.  * @param testDataCount expected number of records to be read in the test data files.  *  * @param <T> type of the test data.  */ public <T> void add(String name, Class<? extends TypeSerializer> serializerClass, Class<? extends TypeSerializerSnapshot> snapshotClass, Supplier<? extends TypeSerializer<T>> serializerProvider, TestResourceFilenameSupplier testSnapshotFilenameProvider, TestResourceFilenameSupplier testDataFilenameProvider, int testDataCount) {     for (MigrationVersion testVersion : testVersions) {         testSpecifications.add(TestSpecification.<T>builder(getSpecNameForVersion(name, testVersion), serializerClass, snapshotClass, testVersion).withNewSerializerProvider(serializerProvider).withSnapshotDataLocation(testSnapshotFilenameProvider.get(testVersion)).withTestData(testDataFilenameProvider.get(testVersion), testDataCount)).     } }
false;public;0;3;;public Collection<TestSpecification<?>> get() {     return Collections.unmodifiableCollection(testSpecifications). }
false;private,static;2;3;;private static String getSpecNameForVersion(String baseName, MigrationVersion testVersion) {     return testVersion + "-" + baseName. }
false;;1;1;;String get(MigrationVersion testVersion).
