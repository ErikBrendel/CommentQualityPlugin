commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;0;1;;protected abstract T[] getTestData().
false;public;0;34;;@Test public void testHashcodeAndEquals() throws Exception {     final T[] testData = getTestData().     final TypeInformation<?> unrelatedTypeInfo = new UnrelatedTypeInfo().     for (T typeInfo : testData) {         // check for implemented hashCode and equals         if (typeInfo.getClass().getMethod("hashCode").getDeclaringClass() == Object.class) {             throw new AssertionError("Type information does not implement own hashCode method: " + typeInfo.getClass().getCanonicalName()).         }         if (typeInfo.getClass().getMethod("equals", Object.class).getDeclaringClass() == Object.class) {             throw new AssertionError("Type information does not implement own equals method: " + typeInfo.getClass().getCanonicalName()).         }         // compare among test data         for (T otherTypeInfo : testData) {             // test equality             if (typeInfo == otherTypeInfo) {                 assertTrue("hashCode() returns inconsistent results.", typeInfo.hashCode() == otherTypeInfo.hashCode()).                 assertEquals("equals() is false for same object.", typeInfo, otherTypeInfo).             } else // test inequality             {                 assertNotEquals("equals() returned true for different objects.", typeInfo, otherTypeInfo).             }         }         // compare with unrelated type         assertFalse("Type information allows to compare with unrelated type.", typeInfo.canEqual(unrelatedTypeInfo)).         assertNotEquals(typeInfo, unrelatedTypeInfo).     } }
false;public;0;22;;@Test public void testSerialization() {     final T[] testData = getTestData().     for (T typeInfo : testData) {         final byte[] serialized.         try {             serialized = InstantiationUtil.serializeObject(typeInfo).         } catch (IOException e) {             throw new AssertionError("Could not serialize type information: " + typeInfo, e).         }         final T deserialized.         try {             deserialized = InstantiationUtil.deserializeObject(serialized, getClass().getClassLoader()).         } catch (IOException | ClassNotFoundException e) {             throw new AssertionError("Could not deserialize type information: " + typeInfo, e).         }         if (typeInfo.hashCode() != deserialized.hashCode() || !typeInfo.equals(deserialized)) {             throw new AssertionError("Deserialized type information differs from original one.").         }     } }
false;public;0;9;;@Test public void testGetTotalFields() {     final T[] testData = getTestData().     for (T typeInfo : testData) {         assertTrue("Number of total fields must be at least 1", typeInfo.getTotalFields() > 0).     } }
false;public;0;4;;@Override public boolean isBasicType() {     return false. }
false;public;0;4;;@Override public boolean isTupleType() {     return false. }
false;public;0;4;;@Override public int getArity() {     return 0. }
false;public;0;4;;@Override public int getTotalFields() {     return 0. }
false;public;0;4;;@Override public Class<Object> getTypeClass() {     return null. }
false;public;0;4;;@Override public boolean isKeyType() {     return false. }
false;public;1;4;;@Override public TypeSerializer<Object> createSerializer(ExecutionConfig config) {     return null. }
false;public;0;4;;@Override public String toString() {     return null. }
false;public;1;4;;@Override public boolean equals(Object obj) {     return false. }
false;public;0;4;;@Override public int hashCode() {     return 0. }
false;public;1;4;;@Override public boolean canEqual(Object obj) {     return false. }
