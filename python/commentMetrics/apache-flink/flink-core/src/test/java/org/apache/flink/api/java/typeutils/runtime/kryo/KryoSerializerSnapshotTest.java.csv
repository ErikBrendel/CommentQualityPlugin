commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void setup() {     oldConfig = new ExecutionConfig().     newConfig = new ExecutionConfig(). }
false;public;0;4;;@Test public void sanityTest() {     assertThat(resolveKryoCompatibility(oldConfig, newConfig), isCompatibleAsIs()). }
false;public;0;10;;@Test public void addingTypesIsCompatibleAfterReconfiguration() {     oldConfig.registerKryoType(Animal.class).     newConfig.registerKryoType(Animal.class).     newConfig.registerTypeWithKryoSerializer(Dog.class, DogKryoSerializer.class).     assertThat(resolveKryoCompatibility(oldConfig, newConfig), isCompatibleWithReconfiguredSerializer()). }
false;public;0;13;;@Test public void replacingKryoSerializersIsCompatibleAsIs() {     oldConfig.registerKryoType(Animal.class).     oldConfig.registerTypeWithKryoSerializer(Dog.class, DogKryoSerializer.class).     newConfig.registerKryoType(Animal.class).     newConfig.registerTypeWithKryoSerializer(Dog.class, DogV2KryoSerializer.class).     // it is compatible as is, since Kryo does not expose compatibility API with KryoSerializers     // so we can not know if DogKryoSerializer is compatible with DogV2KryoSerializer     assertThat(resolveKryoCompatibility(oldConfig, newConfig), isCompatibleAsIs()). }
false;public;0;11;;@Test public void reorderingIsCompatibleAfterReconfiguration() {     oldConfig.registerKryoType(Parrot.class).     oldConfig.registerKryoType(Dog.class).     newConfig.registerKryoType(Dog.class).     newConfig.registerKryoType(Parrot.class).     assertThat(resolveKryoCompatibility(oldConfig, newConfig), isCompatibleWithReconfiguredSerializer()). }
false;public;0;9;;@Test public void tryingToRestoreWithNonExistingClassShouldBeIncompatible() throws IOException {     TypeSerializerSnapshot<Animal> restoredSnapshot = kryoSnapshotWithMissingClass().     TypeSerializer<Animal> currentSerializer = new KryoSerializer<>(Animal.class, new ExecutionConfig()).     assertThat(restoredSnapshot.resolveSchemaCompatibility(currentSerializer), isIncompatible()). }
false;private,static;0;7;;// ------------------------------------------------------------------------------------------------------- // Helpers // ------------------------------------------------------------------------------------------------------- private static TypeSerializerSnapshot<Animal> kryoSnapshotWithMissingClass() throws IOException {     DataInputView in = new DataInputDeserializer(unLoadableSnapshotBytes()).     return TypeSerializerSnapshot.readVersionedSnapshot(in, KryoSerializerSnapshotTest.class.getClassLoader()). }
true;private,static;0;21;/**  * This method returns the bytes of a serialized {@link KryoSerializerSnapshot}, that contains a Kryo registration  * of a class that does not exists in the current classpath.  */ ;/**  * This method returns the bytes of a serialized {@link KryoSerializerSnapshot}, that contains a Kryo registration  * of a class that does not exists in the current classpath.  */ private static byte[] unLoadableSnapshotBytes() throws IOException {     final ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader().     ClassLoader tempClassLoader = new URLClassLoader(new URL[0], KryoSerializerSnapshotTest.class.getClassLoader()).     try {         Thread.currentThread().setContextClassLoader(tempClassLoader).         ExecutionConfig conf = registerClassThatIsNotInClassPath(tempClassLoader).         KryoSerializer<Animal> previousSerializer = new KryoSerializer<>(Animal.class, conf).         TypeSerializerSnapshot<Animal> previousSnapshot = previousSerializer.snapshotConfiguration().         DataOutputSerializer out = new DataOutputSerializer(4096).         TypeSerializerSnapshot.writeVersionedSnapshot(out, previousSnapshot).         return out.getCopyOfBuffer().     } finally {         Thread.currentThread().setContextClassLoader(originalClassLoader).     } }
false;private,static;1;8;;private static ExecutionConfig registerClassThatIsNotInClassPath(ClassLoader tempClassLoader) {     Object objectForClassNotInClassPath = CommonTestUtils.createObjectForClassNotInClassPath(tempClassLoader).     ExecutionConfig conf = new ExecutionConfig().     conf.registerKryoType(objectForClassNotInClassPath.getClass()).     return conf. }
false;private,static;2;7;;private static TypeSerializerSchemaCompatibility<Animal> resolveKryoCompatibility(ExecutionConfig previous, ExecutionConfig current) {     KryoSerializer<Animal> previousSerializer = new KryoSerializer<>(Animal.class, previous).     TypeSerializerSnapshot<Animal> previousSnapshot = previousSerializer.snapshotConfiguration().     TypeSerializer<Animal> currentSerializer = new KryoSerializer<>(Animal.class, current).     return previousSnapshot.resolveSchemaCompatibility(currentSerializer). }
