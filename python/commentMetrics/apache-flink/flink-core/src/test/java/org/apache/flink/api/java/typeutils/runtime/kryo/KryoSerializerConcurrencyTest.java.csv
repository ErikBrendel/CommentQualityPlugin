commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Test public void testDuplicateSerializerWithDefaultSerializerClass() {     ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.addDefaultKryoSerializer(WrappedString.class, TestSerializer.class).     runDuplicateSerializerTest(executionConfig). }
false;public;0;6;;@Test public void testDuplicateSerializerWithDefaultSerializerInstance() {     ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.addDefaultKryoSerializer(WrappedString.class, new TestSerializer()).     runDuplicateSerializerTest(executionConfig). }
false;public;0;6;;@Test public void testDuplicateSerializerWithRegisteredSerializerClass() {     ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.registerTypeWithKryoSerializer(WrappedString.class, TestSerializer.class).     runDuplicateSerializerTest(executionConfig). }
false;public;0;6;;@Test public void testDuplicateSerializerWithRegisteredSerializerInstance() {     ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.registerTypeWithKryoSerializer(WrappedString.class, new TestSerializer()).     runDuplicateSerializerTest(executionConfig). }
false;private;1;15;;private void runDuplicateSerializerTest(ExecutionConfig executionConfig) {     final KryoSerializer<WrappedString> original = new KryoSerializer<>(WrappedString.class, executionConfig).     final KryoSerializer<WrappedString> duplicate = original.duplicate().     WrappedString testString = new WrappedString("test").     String copyWithOriginal = original.copy(testString).content.     String copyWithDuplicate = duplicate.copy(testString).content.     Assert.assertTrue(copyWithOriginal.startsWith(testString.content)).     Assert.assertTrue(copyWithDuplicate.startsWith(testString.content)).     // check that both serializer instances have appended a different identity hash     Assert.assertNotEquals(copyWithOriginal, copyWithDuplicate). }
false;public;0;4;;@Override public void go() throws Exception {     serializer.serialize("a value", lockingOut). }
false;public;0;36;;@Test public void testConcurrentUseOfSerializer() throws Exception {     final KryoSerializer<String> serializer = new KryoSerializer<>(String.class, new ExecutionConfig()).     final BlockerSync sync = new BlockerSync().     final DataOutputView regularOut = new DataOutputSerializer(32).     final DataOutputView lockingOut = new LockingView(sync).     // this thread serializes and gets stuck there     final CheckedThread thread = new CheckedThread("serializer") {          @Override         public void go() throws Exception {             serializer.serialize("a value", lockingOut).         }     }.     thread.start().     sync.awaitBlocker().     // this should fail with an exception     try {         serializer.serialize("value", regularOut).         fail("should have failed with an exception").     } catch (IllegalStateException e) {     // expected     } finally {         // release the thread that serializes         sync.releaseBlocker().     }     // this propagates exceptions from the spawned thread     thread.sync(). }
false;public;3;4;;@Override public void write(byte[] b, int off, int len) throws IOException {     blocker.blockNonInterruptible(). }
false;public;0;6;;@Override public String toString() {     return "WrappedString{" + "content='" + content + '\'' + '}'. }
false;public;3;4;;@Override public void write(Kryo kryo, Output output, WrappedString object) {     output.writeString(object.content). }
false;public;3;4;;@Override public WrappedString read(Kryo kryo, Input input, Class<WrappedString> type) {     return new WrappedString(input.readString() + " " + System.identityHashCode(this)). }
