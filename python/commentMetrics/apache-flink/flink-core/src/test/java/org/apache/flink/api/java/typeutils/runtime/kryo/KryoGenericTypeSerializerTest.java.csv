commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Test public void testJavaList() {     Collection<Integer> a = new ArrayList<>().     fillCollection(a).     runTests(a). }
false;public;0;8;;@Test public void testJavaSet() {     Collection<Integer> b = new HashSet<>().     fillCollection(b).     runTests(b). }
false;public;0;6;;@Test public void testJavaDequeue() {     Collection<Integer> c = new LinkedList<>().     fillCollection(c).     runTests(c). }
false;private;1;6;;private void fillCollection(Collection<Integer> coll) {     coll.add(42).     coll.add(1337).     coll.add(49).     coll.add(1). }
false;protected;1;4;;@Override protected <T> TypeSerializer<T> createSerializer(Class<T> type) {     return new KryoSerializer<T>(type, ec). }
true;public;0;36;/**  * Make sure that the kryo serializer forwards EOF exceptions properly when serializing  */ ;/**  * Make sure that the kryo serializer forwards EOF exceptions properly when serializing  */ @Test public void testForwardEOFExceptionWhileSerializing() {     try {         // construct a long string         String str.         {             char[] charData = new char[40000].             Random rnd = new Random().             for (int i = 0. i < charData.length. i++) {                 charData[i] = (char) rnd.nextInt(10000).             }             str = new String(charData).         }         // construct a memory target that is too small for the string         TestDataOutputSerializer target = new TestDataOutputSerializer(10000, 30000).         KryoSerializer<String> serializer = new KryoSerializer<String>(String.class, new ExecutionConfig()).         try {             serializer.serialize(str, target).             fail("should throw a java.io.EOFException").         } catch (java.io.EOFException e) {         // that is how we like it         } catch (Exception e) {             fail("throws wrong exception: should throw a java.io.EOFException, has thrown a " + e.getClass().getName()).         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
true;public;0;35;/**  * Make sure that the kryo serializer forwards EOF exceptions properly when serializing  */ ;/**  * Make sure that the kryo serializer forwards EOF exceptions properly when serializing  */ @Test public void testForwardEOFExceptionWhileDeserializing() {     try {         int numElements = 100.         // construct a memory target that is too small for the string         TestDataOutputSerializer target = new TestDataOutputSerializer(5 * numElements, 5 * numElements).         KryoSerializer<Integer> serializer = new KryoSerializer<>(Integer.class, new ExecutionConfig()).         for (int i = 0. i < numElements. i++) {             serializer.serialize(i, target).         }         ComparatorTestBase.TestInputView source = new ComparatorTestBase.TestInputView(target.copyByteBuffer()).         for (int i = 0. i < numElements. i++) {             int value = serializer.deserialize(source).             assertEquals(i, value).         }         try {             serializer.deserialize(source).             fail("should throw a java.io.EOFException").         } catch (java.io.EOFException e) {         // that is how we like it :-)         } catch (Exception e) {             fail("throws wrong exception: should throw a java.io.EOFException, has thrown a " + e.getClass().getName()).         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;6;;@Test public void validateReferenceMappingEnabled() {     KryoSerializer<String> serializer = new KryoSerializer<>(String.class, new ExecutionConfig()).     Kryo kryo = serializer.getKryo().     assertTrue(kryo.getReferences()). }
