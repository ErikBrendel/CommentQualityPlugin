commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public Integer map(String value) {     return Integer.parseInt(value). }
false;public;1;4;;@Override public Integer map(String value) {     return Integer.parseInt(value). }
false;public;1;4;;@Override public Tuple2<Integer, Long> map(Integer value) {     return new Tuple2<>(value, 1L). }
false;public;0;39;;@Test @SuppressWarnings({ "Convert2Lambda", "Anonymous2MethodRef" }) public void testIdentifyLambdas() throws TypeExtractionException {     MapFunction<?, ?> anonymousFromInterface = new MapFunction<String, Integer>() {          @Override         public Integer map(String value) {             return Integer.parseInt(value).         }     }.     MapFunction<?, ?> anonymousFromClass = new RichMapFunction<String, Integer>() {          @Override         public Integer map(String value) {             return Integer.parseInt(value).         }     }.     MapFunction<?, ?> fromProperClass = new StaticMapper().     MapFunction<?, ?> fromDerived = new ToTuple<Integer>() {          @Override         public Tuple2<Integer, Long> map(Integer value) {             return new Tuple2<>(value, 1L).         }     }.     MapFunction<String, Integer> staticLambda = Integer::parseInt.     MapFunction<Integer, String> instanceLambda = Object::toString.     MapFunction<String, Integer> constructorLambda = Integer::new.     assertNull(checkAndExtractLambda(anonymousFromInterface)).     assertNull(checkAndExtractLambda(anonymousFromClass)).     assertNull(checkAndExtractLambda(fromProperClass)).     assertNull(checkAndExtractLambda(fromDerived)).     assertNotNull(checkAndExtractLambda(staticLambda)).     assertNotNull(checkAndExtractLambda(instanceLambda)).     assertNotNull(checkAndExtractLambda(constructorLambda)).     assertNotNull(checkAndExtractLambda(STATIC_LAMBDA)). }
false;public;1;4;;@Override public Integer map(String value) {     return Integer.parseInt(value). }
false;;1;2;;@Override Tuple2<T, Long> map(T value) throws Exception.
false;public;0;3;;public MapFunction<Integer, String> getMapFunction() {     return (i) -> s. }
false;public;0;5;;@Test public void testLambdaWithMemberVariable() {     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(new MyClass().getMapFunction(), Types.INT).     assertEquals(ti, BasicTypeInfo.STRING_TYPE_INFO). }
false;public;0;11;;@Test public void testLambdaWithLocalVariable() {     String s = "mystring".     final int k = 24.     int j = 26.     MapFunction<Integer, String> f = (i) -> s + k + j.     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(f, Types.INT).     assertEquals(ti, BasicTypeInfo.STRING_TYPE_INFO). }
false;public;0;8;;@Test public void testLambdaWithNonGenericResultType() {     MapFunction<Tuple2<Tuple1<Integer>, Boolean>, Boolean> f = (i) -> null.     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(f, NESTED_TUPLE_BOOLEAN_TYPE, null, true).     assertTrue(ti instanceof BasicTypeInfo).     assertEquals(BasicTypeInfo.BOOLEAN_TYPE_INFO, ti). }
false;public;0;12;;@Test public void testMapLambda() {     MapFunction<Tuple2<Tuple1<Integer>, Boolean>, Tuple2<Tuple1<Integer>, String>> f = (i) -> null.     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(f, NESTED_TUPLE_BOOLEAN_TYPE, null, true).     if (!(ti instanceof MissingTypeInfo)) {         assertTrue(ti.isTupleType()).         assertEquals(2, ti.getArity()).         assertTrue(((TupleTypeInfo<?>) ti).getTypeAt(0).isTupleType()).         assertEquals(((TupleTypeInfo<?>) ti).getTypeAt(1), BasicTypeInfo.STRING_TYPE_INFO).     } }
false;public;0;12;;@Test public void testFlatMapLambda() {     FlatMapFunction<Tuple2<Tuple1<Integer>, Boolean>, Tuple2<Tuple1<Integer>, String>> f = (i, out) -> out.collect(null).     TypeInformation<?> ti = TypeExtractor.getFlatMapReturnTypes(f, NESTED_TUPLE_BOOLEAN_TYPE, null, true).     if (!(ti instanceof MissingTypeInfo)) {         assertTrue(ti.isTupleType()).         assertEquals(2, ti.getArity()).         assertTrue(((TupleTypeInfo<?>) ti).getTypeAt(0).isTupleType()).         assertEquals(((TupleTypeInfo<?>) ti).getTypeAt(1), BasicTypeInfo.STRING_TYPE_INFO).     } }
false;public;0;12;;@Test public void testMapPartitionLambda() {     MapPartitionFunction<Tuple2<Tuple1<Integer>, Boolean>, Tuple2<Tuple1<Integer>, String>> f = (i, o) -> {     }.     TypeInformation<?> ti = TypeExtractor.getMapPartitionReturnTypes(f, NESTED_TUPLE_BOOLEAN_TYPE, null, true).     if (!(ti instanceof MissingTypeInfo)) {         assertTrue(ti.isTupleType()).         assertEquals(2, ti.getArity()).         assertTrue(((TupleTypeInfo<?>) ti).getTypeAt(0).isTupleType()).         assertEquals(((TupleTypeInfo<?>) ti).getTypeAt(1), BasicTypeInfo.STRING_TYPE_INFO).     } }
false;public;0;12;;@Test public void testJoinLambda() {     JoinFunction<Tuple2<Tuple1<Integer>, Boolean>, Tuple2<Tuple1<Integer>, Double>, Tuple2<Tuple1<Integer>, String>> f = (i1, i2) -> null.     TypeInformation<?> ti = TypeExtractor.getJoinReturnTypes(f, NESTED_TUPLE_BOOLEAN_TYPE, NESTED_TUPLE_DOUBLE_TYPE, null, true).     if (!(ti instanceof MissingTypeInfo)) {         assertTrue(ti.isTupleType()).         assertEquals(2, ti.getArity()).         assertTrue(((TupleTypeInfo<?>) ti).getTypeAt(0).isTupleType()).         assertEquals(((TupleTypeInfo<?>) ti).getTypeAt(1), BasicTypeInfo.STRING_TYPE_INFO).     } }
false;public;0;12;;@Test public void testCoGroupLambda() {     CoGroupFunction<Tuple2<Tuple1<Integer>, Boolean>, Tuple2<Tuple1<Integer>, Double>, Tuple2<Tuple1<Integer>, String>> f = (i1, i2, o) -> {     }.     TypeInformation<?> ti = TypeExtractor.getCoGroupReturnTypes(f, NESTED_TUPLE_BOOLEAN_TYPE, NESTED_TUPLE_DOUBLE_TYPE, null, true).     if (!(ti instanceof MissingTypeInfo)) {         assertTrue(ti.isTupleType()).         assertEquals(2, ti.getArity()).         assertTrue(((TupleTypeInfo<?>) ti).getTypeAt(0).isTupleType()).         assertEquals(((TupleTypeInfo<?>) ti).getTypeAt(1), BasicTypeInfo.STRING_TYPE_INFO).     } }
false;public;0;12;;@Test public void testKeySelectorLambda() {     KeySelector<Tuple2<Tuple1<Integer>, Boolean>, Tuple2<Tuple1<Integer>, String>> f = (i) -> null.     TypeInformation<?> ti = TypeExtractor.getKeySelectorTypes(f, NESTED_TUPLE_BOOLEAN_TYPE, null, true).     if (!(ti instanceof MissingTypeInfo)) {         assertTrue(ti.isTupleType()).         assertEquals(2, ti.getArity()).         assertTrue(((TupleTypeInfo<?>) ti).getTypeAt(0).isTupleType()).         assertEquals(((TupleTypeInfo<?>) ti).getTypeAt(1), BasicTypeInfo.STRING_TYPE_INFO).     } }
false;public;0;7;;@SuppressWarnings("rawtypes") @Test public void testLambdaTypeErasure() {     MapFunction<Tuple1<Integer>, Tuple1> f = (i) -> null.     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(f, new TypeHint<Tuple1<Integer>>() {     }.getTypeInfo(), null, true).     assertTrue(ti instanceof MissingTypeInfo). }
false;public;0;12;;@Test public void testPartitionerLambda() {     Partitioner<Tuple2<Integer, String>> partitioner = (key, numPartitions) -> key.f1.length() % numPartitions.     final TypeInformation<?> ti = TypeExtractor.getPartitionerTypes(partitioner, null, true).     if (!(ti instanceof MissingTypeInfo)) {         assertTrue(ti.isTupleType()).         assertEquals(2, ti.getArity()).         assertEquals(((TupleTypeInfo<?>) ti).getTypeAt(0), BasicTypeInfo.INT_TYPE_INFO).         assertEquals(((TupleTypeInfo<?>) ti).getTypeAt(1), BasicTypeInfo.STRING_TYPE_INFO).     } }
false;public;0;3;;public int getKey() {     return key. }
false;public;1;3;;public void setKey(int key) {     this.key = key. }
false;protected;0;3;;protected int getKey2() {     return 0. }
false;public;0;6;;@Test public void testInstanceMethodRefSameType() {     MapFunction<MyType, Integer> f = MyType::getKey.     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(f, TypeExtractor.createTypeInfo(MyType.class)).     assertEquals(BasicTypeInfo.INT_TYPE_INFO, ti). }
false;public;0;6;;@Test public void testInstanceMethodRefSuperType() {     MapFunction<Integer, String> f = Object::toString.     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(f, BasicTypeInfo.INT_TYPE_INFO).     assertEquals(BasicTypeInfo.STRING_TYPE_INFO, ti). }
false;public;0;6;;@Test public void testInstanceMethodRefSuperTypeProtected() {     MapFunction<MySubtype, Integer> f = MyType::getKey2.     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(f, TypeExtractor.createTypeInfo(MySubtype.class)).     assertEquals(BasicTypeInfo.INT_TYPE_INFO, ti). }
false;public;0;6;;@Test public void testConstructorMethodRef() {     MapFunction<String, Integer> f = Integer::new.     TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(f, BasicTypeInfo.STRING_TYPE_INFO).     assertEquals(BasicTypeInfo.INT_TYPE_INFO, ti). }
false;;0;1;;void samMethod().
false;default;0;3;;default void defaultMethod() { }
false;public;0;6;;@Test public void testSamMethodExtractionInterfaceWithDefaultMethod() {     final Method sam = TypeExtractionUtils.getSingleAbstractMethod(InterfaceWithDefaultMethod.class).     assertNotNull(sam).     assertEquals("samMethod", sam.getName()). }
false;;0;1;;void firstMethod().
false;;0;1;;void secondMethod().
false;public;0;4;;@Test(expected = InvalidTypesException.class) public void getSingleAbstractMethodMultipleMethods() {     TypeExtractionUtils.getSingleAbstractMethod(InterfaceWithMultipleMethods.class). }
false;default;0;3;;default void defaultMethod() { }
false;public;0;4;;@Test(expected = InvalidTypesException.class) public void testSingleAbstractMethodNoAbstractMethods() {     TypeExtractionUtils.getSingleAbstractMethod(InterfaceWithoutAbstractMethod.class). }
false;public,abstract;0;1;;public abstract void defaultMethod().
false;public;0;4;;@Test(expected = InvalidTypesException.class) public void testSingleAbstractMethodNotAnInterface() {     TypeExtractionUtils.getSingleAbstractMethod(AbstractClassWithSingleAbstractMethod.class). }
