commented;modifiers;parameterAmount;loc;comment;code
true;public;0;19;/**  * Verifies that reading and writing serializers work correctly.  */ ;/**  * Verifies that reading and writing serializers work correctly.  */ @Test public void testSerializerSerialization() throws Exception {     TypeSerializer<?> serializer = IntSerializer.INSTANCE.     byte[] serialized.     try (ByteArrayOutputStreamWithPos out = new ByteArrayOutputStreamWithPos()) {         TypeSerializerSerializationUtil.writeSerializer(new DataOutputViewStreamWrapper(out), serializer).         serialized = out.toByteArray().     }     TypeSerializer<?> deserializedSerializer.     try (ByteArrayInputStreamWithPos in = new ByteArrayInputStreamWithPos(serialized)) {         deserializedSerializer = TypeSerializerSerializationUtil.tryReadSerializer(new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader()).     }     Assert.assertEquals(serializer, deserializedSerializer). }
true;public;0;27;/**  * Verifies deserialization failure cases when reading a serializer from bytes, in the  * case of a {@link ClassNotFoundException}.  */ ;/**  * Verifies deserialization failure cases when reading a serializer from bytes, in the  * case of a {@link ClassNotFoundException}.  */ @Test public void testSerializerSerializationWithClassNotFound() throws Exception {     TypeSerializer<?> serializer = IntSerializer.INSTANCE.     byte[] serialized.     try (ByteArrayOutputStreamWithPos out = new ByteArrayOutputStreamWithPos()) {         TypeSerializerSerializationUtil.writeSerializer(new DataOutputViewStreamWrapper(out), serializer).         serialized = out.toByteArray().     }     TypeSerializer<?> deserializedSerializer.     try (ByteArrayInputStreamWithPos in = new ByteArrayInputStreamWithPos(serialized)) {         deserializedSerializer = TypeSerializerSerializationUtil.tryReadSerializer(new DataInputViewStreamWrapper(in), new ArtificialCNFExceptionThrowingClassLoader(Thread.currentThread().getContextClassLoader(), Collections.singleton(IntSerializer.class.getName())), true).     }     Assert.assertTrue(deserializedSerializer instanceof UnloadableDummyTypeSerializer).     Assert.assertArrayEquals(InstantiationUtil.serializeObject(serializer), ((UnloadableDummyTypeSerializer<?>) deserializedSerializer).getActualBytes()). }
true;public;0;23;/**  * Verifies deserialization failure cases when reading a serializer from bytes, in the  * case of a {@link InvalidClassException}.  */ ;/**  * Verifies deserialization failure cases when reading a serializer from bytes, in the  * case of a {@link InvalidClassException}.  */ @Test public void testSerializerSerializationWithInvalidClass() throws Exception {     TypeSerializer<?> serializer = IntSerializer.INSTANCE.     byte[] serialized.     try (ByteArrayOutputStreamWithPos out = new ByteArrayOutputStreamWithPos()) {         TypeSerializerSerializationUtil.writeSerializer(new DataOutputViewStreamWrapper(out), serializer).         serialized = out.toByteArray().     }     TypeSerializer<?> deserializedSerializer.     try (ByteArrayInputStreamWithPos in = new ByteArrayInputStreamWithPos(serialized)) {         deserializedSerializer = TypeSerializerSerializationUtil.tryReadSerializer(new DataInputViewStreamWrapper(in), new ArtificialCNFExceptionThrowingClassLoader(Thread.currentThread().getContextClassLoader(), Collections.singleton(IntSerializer.class.getName())), true).     }     Assert.assertTrue(deserializedSerializer instanceof UnloadableDummyTypeSerializer). }
true;public;0;23;/**  * Verifies that reading and writing configuration snapshots work correctly.  */ ;/**  * Verifies that reading and writing configuration snapshots work correctly.  */ @Test public void testSerializeConfigurationSnapshots() throws Exception {     TypeSerializerSerializationUtilTest.TestConfigSnapshot<String> configSnapshot1 = new TypeSerializerSerializationUtilTest.TestConfigSnapshot<>(1, "foo").     byte[] serializedConfig.     try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {         TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(new DataOutputViewStreamWrapper(out), configSnapshot1, StringSerializer.INSTANCE).         serializedConfig = out.toByteArray().     }     TypeSerializerSnapshot<?> restoredConfigs.     try (ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {         restoredConfigs = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), null).     }     assertEquals(configSnapshot1, restoredConfigs). }
true;public;0;19;/**  * Verifies that deserializing config snapshots fail if the config class could not be found.  */ ;/**  * Verifies that deserializing config snapshots fail if the config class could not be found.  */ @Test(expected = IOException.class) public void testFailsWhenConfigurationSnapshotClassNotFound() throws Exception {     byte[] serializedConfig.     try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {         TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(new DataOutputViewStreamWrapper(out), new TypeSerializerSerializationUtilTest.TestConfigSnapshot<>(123, "foobar"), StringSerializer.INSTANCE).         serializedConfig = out.toByteArray().     }     try (ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {         // read using a dummy classloader         TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(new DataInputViewStreamWrapper(in), new URLClassLoader(new URL[0], null), null).     }     fail("Expected a ClassNotFoundException wrapped in IOException"). }
true;public;0;31;/**  * Verifies resilience to serializer deserialization failures when writing and reading  * serializer and config snapshot pairs.  */ ;/**  * Verifies resilience to serializer deserialization failures when writing and reading  * serializer and config snapshot pairs.  */ @Test public void testSerializerAndConfigPairsSerializationWithSerializerDeserializationFailures() throws Exception {     TestIntSerializer serializer = new TestIntSerializer().     List<Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> serializersAndConfigs = Arrays.asList(new Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>(serializer, serializer.snapshotConfiguration())).     byte[] serializedSerializersAndConfigs.     try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {         TypeSerializerSerializationUtil.writeSerializersAndConfigsWithResilience(new DataOutputViewStreamWrapper(out), serializersAndConfigs).         serializedSerializersAndConfigs = out.toByteArray().     }     Set<String> cnfThrowingClassnames = new HashSet<>().     cnfThrowingClassnames.add(TestIntSerializer.class.getName()).     List<Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> restored.     try (ByteArrayInputStream in = new ByteArrayInputStream(serializedSerializersAndConfigs)) {         restored = TypeSerializerSerializationUtil.readSerializersAndConfigsWithResilience(new DataInputViewStreamWrapper(in), new ArtificialCNFExceptionThrowingClassLoader(Thread.currentThread().getContextClassLoader(), cnfThrowingClassnames)).     }     Assert.assertEquals(1, restored.size()).     Assert.assertTrue(restored.get(0).f0 instanceof UnloadableDummyTypeSerializer).     Assert.assertThat(restored.get(0).f1, Matchers.instanceOf(SimpleTypeSerializerSnapshot.class)). }
false;public;0;4;;@Override public TypeSerializerSnapshot<Integer> snapshotConfiguration() {     return null. }
true;public;0;31;/**  * Verifies that serializers of anonymous classes can be deserialized, even if serialVersionUID changes.  */ ;/**  * Verifies that serializers of anonymous classes can be deserialized, even if serialVersionUID changes.  */ @Test public void testAnonymousSerializerClassWithChangedSerialVersionUID() throws Exception {     TypeSerializer anonymousClassSerializer = new AbstractIntSerializer() {          @Override         public TypeSerializerSnapshot<Integer> snapshotConfiguration() {             return null.         }     }.     // assert that our assumption holds     Assert.assertTrue(anonymousClassSerializer.getClass().isAnonymousClass()).     byte[] anonymousSerializerBytes.     try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {         TypeSerializerSerializationUtil.writeSerializer(new DataOutputViewStreamWrapper(out), anonymousClassSerializer).         anonymousSerializerBytes = out.toByteArray().     }     long newSerialVersionUID = 1234567L.     // assert that we're actually modifying to a different serialVersionUID     Assert.assertNotEquals(ObjectStreamClass.lookup(anonymousClassSerializer.getClass()).getSerialVersionUID(), newSerialVersionUID).     modifySerialVersionUID(anonymousSerializerBytes, anonymousClassSerializer.getClass().getName(), newSerialVersionUID).     try (ByteArrayInputStream in = new ByteArrayInputStream(anonymousSerializerBytes)) {         anonymousClassSerializer = TypeSerializerSerializationUtil.tryReadSerializer(new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader()).     }     // serializer should have been deserialized despite serialVersionUID mismatch     Assert.assertNotNull(anonymousClassSerializer).     Assert.assertTrue(anonymousClassSerializer.getClass().isAnonymousClass()). }
false;public;1;6;;@Override public void write(DataOutputView out) throws IOException {     super.write(out).     out.writeInt(val).     out.writeUTF(msg). }
false;public;1;6;;@Override public void read(DataInputView in) throws IOException {     super.read(in).     val = in.readInt().     msg = in.readUTF(). }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;1;17;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     }     if (obj == null) {         return false.     }     if (obj instanceof TypeSerializerSerializationUtilTest.TestConfigSnapshot) {         return val == ((TypeSerializerSerializationUtilTest.TestConfigSnapshot) obj).val && msg.equals(((TypeSerializerSerializationUtilTest.TestConfigSnapshot) obj).msg).     } else {         return false.     } }
false;public;0;4;;@Override public int hashCode() {     return 31 * val + msg.hashCode(). }
false;private,static;3;37;;private static void modifySerialVersionUID(byte[] objectBytes, String classname, long newSerialVersionUID) throws Exception {     byte[] classnameBytes = classname.getBytes().     // serialVersionUID follows directly after classname in the object byte stream.     // advance serialVersionUIDPosition until end of classname in stream     int serialVersionUIDOffset.     boolean foundClass = false.     int numMatchedBytes = 0.     for (serialVersionUIDOffset = 0. serialVersionUIDOffset < objectBytes.length. serialVersionUIDOffset++) {         if (objectBytes[serialVersionUIDOffset] == classnameBytes[numMatchedBytes]) {             numMatchedBytes++.             foundClass = true.         } else {             if (objectBytes[serialVersionUIDOffset] == classnameBytes[0]) {                 numMatchedBytes = 1.             } else {                 numMatchedBytes = 0.                 foundClass = false.             }         }         if (numMatchedBytes == classnameBytes.length) {             break.         }     }     if (!foundClass) {         throw new RuntimeException("Could not find class " + classname + " in object byte stream.").     }     byte[] newUIDBytes = ByteBuffer.allocate(Long.SIZE / Byte.SIZE).putLong(newSerialVersionUID).array().     // replace original serialVersionUID bytes with new serialVersionUID bytes     for (int uidIndex = 0. uidIndex < newUIDBytes.length. uidIndex++) {         objectBytes[serialVersionUIDOffset + 1 + uidIndex] = newUIDBytes[uidIndex].     } }
false;public;0;4;;@Override public Integer createInstance() {     return IntSerializer.INSTANCE.createInstance(). }
false;public;0;4;;@Override public boolean isImmutableType() {     return IntSerializer.INSTANCE.isImmutableType(). }
false;public;1;4;;@Override public Integer copy(Integer from) {     return IntSerializer.INSTANCE.copy(from). }
false;public;2;4;;@Override public Integer copy(Integer from, Integer reuse) {     return IntSerializer.INSTANCE.copy(from, reuse). }
false;public;2;4;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     IntSerializer.INSTANCE.copy(source, target). }
false;public;1;4;;@Override public Integer deserialize(DataInputView source) throws IOException {     return IntSerializer.INSTANCE.deserialize(source). }
false;public;2;4;;@Override public Integer deserialize(Integer reuse, DataInputView source) throws IOException {     return IntSerializer.INSTANCE.deserialize(reuse, source). }
false;public;2;4;;@Override public void serialize(Integer record, DataOutputView target) throws IOException {     IntSerializer.INSTANCE.serialize(record, target). }
false;public;0;4;;@Override public TypeSerializer<Integer> duplicate() {     return IntSerializer.INSTANCE.duplicate(). }
false;public;0;4;;@Override public int getLength() {     return IntSerializer.INSTANCE.getLength(). }
false;public;1;4;;@Override public boolean equals(Object obj) {     return IntSerializer.INSTANCE.equals(obj). }
false;public;0;4;;@Override public int hashCode() {     return IntSerializer.INSTANCE.hashCode(). }
false;public;0;4;;@Override public TypeSerializerSnapshot<Integer> snapshotConfiguration() {     return new TestIntSerializerSnapshot(). }
