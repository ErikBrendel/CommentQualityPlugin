commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;@Test public void testMigrationStrategyForRemovedAvroDependency() throws Exception {     KryoSerializer<TestClass> kryoSerializerForA = new KryoSerializer<>(TestClass.class, new ExecutionConfig()).     // read configuration again from bytes     TypeSerializerSnapshot kryoSerializerConfigSnapshot.     try (InputStream in = getClass().getResourceAsStream("/kryo-serializer-flink1.3-snapshot")) {         kryoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), kryoSerializerForA).     }     @SuppressWarnings("unchecked")     TypeSerializerSchemaCompatibility<TestClass> compatResult = kryoSerializerConfigSnapshot.resolveSchemaCompatibility(kryoSerializerForA).     assertTrue(compatResult.isCompatibleAsIs()). }
false;public;0;15;;@Test public void testDeserializingKryoSerializerWithoutAvro() throws Exception {     final String resource = "serialized-kryo-serializer-1.3".     TypeSerializer<?> serializer.     try (InputStream in = getClass().getClassLoader().getResourceAsStream(resource)) {         DataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(in).         serializer = TypeSerializerSerializationUtil.tryReadSerializer(inView, getClass().getClassLoader()).     }     assertNotNull(serializer).     assertTrue(serializer instanceof KryoSerializer). }
true;public;0;26;/**  * Verifies that reconfiguration result is INCOMPATIBLE if data type has changed.  */ ;/**  * Verifies that reconfiguration result is INCOMPATIBLE if data type has changed.  */ @Test public void testMigrationStrategyWithDifferentKryoType() throws Exception {     KryoSerializer<TestClassA> kryoSerializerForA = new KryoSerializer<>(TestClassA.class, new ExecutionConfig()).     // snapshot configuration and serialize to bytes     TypeSerializerSnapshot kryoSerializerConfigSnapshot = kryoSerializerForA.snapshotConfiguration().     byte[] serializedConfig.     try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {         TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(new DataOutputViewStreamWrapper(out), kryoSerializerConfigSnapshot, kryoSerializerForA).         serializedConfig = out.toByteArray().     }     KryoSerializer<TestClassB> kryoSerializerForB = new KryoSerializer<>(TestClassB.class, new ExecutionConfig()).     // read configuration again from bytes     try (ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {         kryoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), kryoSerializerForB).     }     @SuppressWarnings("unchecked")     TypeSerializerSchemaCompatibility<TestClassB> compatResult = kryoSerializerConfigSnapshot.resolveSchemaCompatibility(kryoSerializerForB).     assertTrue(compatResult.isIncompatible()). }
false;public;0;60;;@Test public void testMigrationOfTypeWithAvroType() throws Exception {     /* 		 When Avro sees the schema "{"type" : "array", "items" : "boolean"}" it will create a field 		 of type List<Integer> but the actual type will be GenericData.Array<Integer>. The 		 KryoSerializer registers a special Serializer for this type that simply deserializes 		 as ArrayList because Kryo cannot handle GenericData.Array well. Before Flink 1.4 Avro 		 was always in the classpath but after 1.4 it's only present if the flink-avro jar is 		 included. This test verifies that we can still deserialize data written pre-1.4. 		 */     class FakeAvroClass {          public List<Integer> array.          FakeAvroClass(List<Integer> array) {             this.array = array.         }     }     /* 		// This has to be executed on a pre-1.4 branch to generate the binary blob 		{ 			ExecutionConfig executionConfig = new ExecutionConfig(). 			KryoSerializer<FakeAvroClass> kryoSerializer = 				new KryoSerializer<>(FakeAvroClass.class, executionConfig).  			try ( 				FileOutputStream f = new FileOutputStream( 					"src/test/resources/type-with-avro-serialized-using-kryo"). 				DataOutputViewStreamWrapper outputView = new DataOutputViewStreamWrapper(f)) {   				GenericData.Array<Integer> array = 					new GenericData.Array<>(10, Schema.createArray(Schema.create(Schema.Type.INT))).  				array.add(10). 				array.add(20). 				array.add(30).  				FakeAvroClass myTestClass = new FakeAvroClass(array).  				kryoSerializer.serialize(myTestClass, outputView). 			} 		} 		*/     {         ExecutionConfig executionConfig = new ExecutionConfig().         KryoSerializer<FakeAvroClass> kryoSerializer = new KryoSerializer<>(FakeAvroClass.class, executionConfig).         try (FileInputStream f = new FileInputStream("src/test/resources/type-with-avro-serialized-using-kryo").             DataInputViewStreamWrapper inputView = new DataInputViewStreamWrapper(f)) {             thrown.expectMessage("Could not find required Avro dependency").             kryoSerializer.deserialize(inputView).         }     } }
false;public;0;54;;@Test public void testMigrationWithTypeDevoidOfAvroTypes() throws Exception {     class FakeClass {          public List<Integer> array.          FakeClass(List<Integer> array) {             this.array = array.         }     }     /* 		// This has to be executed on a pre-1.4 branch to generate the binary blob 		{ 			ExecutionConfig executionConfig = new ExecutionConfig(). 			KryoSerializer<FakeClass> kryoSerializer = 				new KryoSerializer<>(FakeClass.class, executionConfig).  			try ( 				FileOutputStream f = new FileOutputStream( 					"src/test/resources/type-without-avro-serialized-using-kryo"). 				DataOutputViewStreamWrapper outputView = new DataOutputViewStreamWrapper(f)) {   				List<Integer> array = new ArrayList<>(10).  				array.add(10). 				array.add(20). 				array.add(30).  				FakeClass myTestClass = new FakeClass(array).  				kryoSerializer.serialize(myTestClass, outputView). 			} 		} 		*/     {         ExecutionConfig executionConfig = new ExecutionConfig().         KryoSerializer<FakeClass> kryoSerializer = new KryoSerializer<>(FakeClass.class, executionConfig).         try (FileInputStream f = new FileInputStream("src/test/resources/type-without-avro-serialized-using-kryo").             DataInputViewStreamWrapper inputView = new DataInputViewStreamWrapper(f)) {             FakeClass myTestClass = kryoSerializer.deserialize(inputView).             assertThat(myTestClass.array.get(0), is(10)).             assertThat(myTestClass.array.get(1), is(20)).             assertThat(myTestClass.array.get(2), is(30)).         }     } }
true;public;0;47;/**  * Tests that after reconfiguration, registration ids are reconfigured to  * remain the same as the preceding KryoSerializer.  */ ;/**  * Tests that after reconfiguration, registration ids are reconfigured to  * remain the same as the preceding KryoSerializer.  */ @Test public void testMigrationStrategyForDifferentRegistrationOrder() throws Exception {     ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.registerKryoType(TestClassA.class).     executionConfig.registerKryoType(TestClassB.class).     KryoSerializer<TestClass> kryoSerializer = new KryoSerializer<>(TestClass.class, executionConfig).     // get original registration ids     int testClassId = kryoSerializer.getKryo().getRegistration(TestClass.class).getId().     int testClassAId = kryoSerializer.getKryo().getRegistration(TestClassA.class).getId().     int testClassBId = kryoSerializer.getKryo().getRegistration(TestClassB.class).getId().     // snapshot configuration and serialize to bytes     TypeSerializerSnapshot kryoSerializerConfigSnapshot = kryoSerializer.snapshotConfiguration().     byte[] serializedConfig.     try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {         TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(new DataOutputViewStreamWrapper(out), kryoSerializerConfigSnapshot, kryoSerializer).         serializedConfig = out.toByteArray().     }     // use new config and instantiate new KryoSerializer     executionConfig = new ExecutionConfig().     // test with B registered before A     executionConfig.registerKryoType(TestClassB.class).     executionConfig.registerKryoType(TestClassA.class).     kryoSerializer = new KryoSerializer<>(TestClass.class, executionConfig).     // read configuration from bytes     try (ByteArrayInputStream in = new ByteArrayInputStream(serializedConfig)) {         kryoSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(new DataInputViewStreamWrapper(in), Thread.currentThread().getContextClassLoader(), kryoSerializer).     }     // reconfigure - check reconfiguration result and that registration id remains the same     @SuppressWarnings("unchecked")     TypeSerializerSchemaCompatibility<TestClass> compatResult = kryoSerializerConfigSnapshot.resolveSchemaCompatibility(kryoSerializer).     assertTrue(compatResult.isCompatibleWithReconfiguredSerializer()).     kryoSerializer = (KryoSerializer<TestClass>) compatResult.getReconfiguredSerializer().     assertEquals(testClassId, kryoSerializer.getKryo().getRegistration(TestClass.class).getId()).     assertEquals(testClassAId, kryoSerializer.getKryo().getRegistration(TestClassA.class).getId()).     assertEquals(testClassBId, kryoSerializer.getKryo().getRegistration(TestClassB.class).getId()). }
false;public;3;4;;@Override public void write(Kryo kryo, Output output, Object o) {     throw new UnsupportedOperationException(). }
false;public;3;4;;@Override public Object read(Kryo kryo, Input input, Class aClass) {     throw new UnsupportedOperationException(). }
