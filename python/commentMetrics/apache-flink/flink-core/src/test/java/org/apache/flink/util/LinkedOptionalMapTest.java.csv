commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Test public void usageExample() {     LinkedOptionalMap<Class<?>, String> map = new LinkedOptionalMap<>().     map.put("java.lang.String", String.class, "a string class").     map.put("scala.Option", null, "a scala Option").     map.put("java.lang.Boolean", Boolean.class, null).     assertThat(map.keyNames(), hasItems("java.lang.String", "scala.Option")).     assertThat(map.absentKeysOrValues(), hasItems("scala.Option", "java.lang.Boolean")). }
false;public;0;9;;@Test public void overridingKeyWithTheSameKeyName() {     LinkedOptionalMap<Class<?>, String> map = new LinkedOptionalMap<>().     map.put("java.lang.String", null, "a string class").     map.put("java.lang.String", String.class, "a string class").     assertThat(map.absentKeysOrValues(), is(empty())). }
false;public;0;9;;@Test public void overridingKeysAndValuesWithTheSameKeyName() {     LinkedOptionalMap<Class<?>, String> map = new LinkedOptionalMap<>().     map.put("java.lang.String", null, null).     map.put("java.lang.String", String.class, "a string class").     assertThat(map.absentKeysOrValues(), is(empty())). }
false;public;0;9;;@Test public void overridingAValueWithMissingKeyShouldBeConsideredAsAbsent() {     LinkedOptionalMap<Class<?>, String> map = new LinkedOptionalMap<>().     map.put("java.lang.String", null, null).     map.put("java.lang.String", null, "a string class").     assertThat(map.absentKeysOrValues(), hasItem("java.lang.String")). }
false;public;0;16;;@Test public void mergingMapsWithPresentEntriesLeavesNoAbsentKeyNames() {     LinkedOptionalMap<Class<?>, String> first = new LinkedOptionalMap<>().     first.put("b", null, null).     first.put("c", String.class, null).     LinkedOptionalMap<Class<?>, String> second = new LinkedOptionalMap<>().     second.put("a", String.class, "aaa").     second.put("b", String.class, "bbb").     second.put("c", Void.class, "ccc").     second.put("d", String.class, "ddd").     first.putAll(second).     assertThat(first.absentKeysOrValues(), is(empty())). }
false;public;0;16;;@Test public void mergingMapsPreserversTheOrderOfTheOriginalMap() {     LinkedOptionalMap<Class<?>, String> first = new LinkedOptionalMap<>().     first.put("b", null, null).     first.put("c", String.class, null).     LinkedOptionalMap<Class<?>, String> second = new LinkedOptionalMap<>().     second.put("a", String.class, "aaa").     second.put("b", String.class, "bbb").     second.put("c", Void.class, "ccc").     second.put("d", String.class, "ddd").     first.putAll(second).     assertThat(first.keyNames(), contains("b", "c", "a", "d")). }
false;public;0;14;;@Test public void mergingToEmpty() {     LinkedOptionalMap<Class<?>, String> first = new LinkedOptionalMap<>().     LinkedOptionalMap<Class<?>, String> second = new LinkedOptionalMap<>().     second.put("a", String.class, "aaa").     second.put("b", String.class, "bbb").     second.put("c", Void.class, "ccc").     second.put("d", String.class, "ddd").     first.putAll(second).     assertThat(first.keyNames(), contains("a", "b", "c", "d")). }
false;public;0;8;;@Test(expected = IllegalStateException.class) public void unwrapOptionalsWithMissingValueThrows() {     LinkedOptionalMap<Class<?>, String> map = new LinkedOptionalMap<>().     map.put("a", String.class, null).     map.unwrapOptionals(). }
false;public;0;8;;@Test(expected = IllegalStateException.class) public void unwrapOptionalsWithMissingKeyThrows() {     LinkedOptionalMap<Class<?>, String> map = new LinkedOptionalMap<>().     map.put("a", null, "blabla").     map.unwrapOptionals(). }
false;public;0;12;;@Test public void unwrapOptionalsPreservesOrder() {     LinkedOptionalMap<Class<?>, String> map = new LinkedOptionalMap<>().     map.put("a", String.class, "aaa").     map.put("b", Boolean.class, "bbb").     LinkedHashMap<Class<?>, String> m = map.unwrapOptionals().     assertThat(m.keySet(), contains(String.class, Boolean.class)).     assertThat(m.values(), contains("aaa", "bbb")). }
false;public;0;13;;@Test public void testPrefix() {     LinkedOptionalMap<Class<?>, String> left = new LinkedOptionalMap<>().     left.put("a", String.class, "aaa").     left.put("b", String.class, "aaa").     LinkedOptionalMap<Class<?>, String> right = new LinkedOptionalMap<>(left).     right.put("c", Boolean.class, "bbb").     assertTrue(LinkedOptionalMap.isLeftPrefixOfRight(left, right)). }
false;public;0;14;;@Test public void testNonPrefix() {     LinkedOptionalMap<Class<?>, String> left = new LinkedOptionalMap<>().     left.put("a", String.class, "aaa").     left.put("c", String.class, "aaa").     LinkedOptionalMap<Class<?>, String> right = new LinkedOptionalMap<>().     right.put("b", Boolean.class, "bbb").     right.put("c", Boolean.class, "bbb").     assertFalse(LinkedOptionalMap.isLeftPrefixOfRight(left, right)). }
false;public;0;22;;@Test @SuppressWarnings("unchecked") public void demoMergeResult() {     LinkedOptionalMap<Class<?>, String> left = new LinkedOptionalMap<>().     left.put("b", null, null).     left.put("c", String.class, null).     LinkedOptionalMap<Class<?>, String> right = new LinkedOptionalMap<>().     right.put("b", String.class, "bbb").     right.put("c", Void.class, "ccc").     right.put("a", Boolean.class, "aaa").     right.put("d", Long.class, "ddd").     MergeResult<Class<?>, String> result = LinkedOptionalMap.mergeRightIntoLeft(left, right).     assertThat(result.hasMissingKeys(), is(false)).     assertThat(result.isOrderedSubset(), is(true)).     assertThat(result.missingKeys(), is(empty())).     LinkedHashMap<Class<?>, String> merged = result.getMerged().     assertThat(merged.keySet(), contains(String.class, Void.class, Boolean.class, Long.class)). }
