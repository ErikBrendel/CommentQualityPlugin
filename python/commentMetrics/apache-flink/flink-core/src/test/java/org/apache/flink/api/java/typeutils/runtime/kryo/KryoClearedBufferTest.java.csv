commented;modifiers;parameterAmount;loc;comment;code
true;public;0;49;/**  * Tests that the kryo output buffer is cleared in case of an exception. Flink uses the  * EOFException to signal that a buffer is full. In such a case, the record which was tried  * to be written will be rewritten. Therefore, eventually buffered data of this record has  * to be cleared.  */ ;/**  * Tests that the kryo output buffer is cleared in case of an exception. Flink uses the  * EOFException to signal that a buffer is full. In such a case, the record which was tried  * to be written will be rewritten. Therefore, eventually buffered data of this record has  * to be cleared.  */ @Test public void testOutputBufferedBeingClearedInCaseOfException() throws Exception {     ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.registerTypeWithKryoSerializer(TestRecord.class, new TestRecordSerializer()).     executionConfig.registerKryoType(TestRecord.class).     KryoSerializer<TestRecord> kryoSerializer = new KryoSerializer<TestRecord>(TestRecord.class, executionConfig).     int size = 94.     int bufferSize = 150.     TestRecord testRecord = new TestRecord(size).     TestDataOutputView target = new TestDataOutputView(bufferSize).     kryoSerializer.serialize(testRecord, target).     try {         kryoSerializer.serialize(testRecord, target).         Assert.fail("Expected an EOFException.").     } catch (EOFException eofException) {     // expected exception     // now the Kryo Output should have been cleared     }     TestRecord actualRecord = kryoSerializer.deserialize(new DataInputViewStreamWrapper(new ByteArrayInputStream(target.getBuffer()))).     Assert.assertEquals(testRecord, actualRecord).     target.clear().     // if the kryo output has been cleared then we can serialize our test record into the target     // because the target buffer 150 bytes can host one TestRecord (total serialization size 100)     kryoSerializer.serialize(testRecord, target).     byte[] buffer = target.getBuffer().     int counter = 0.     for (int i = 0. i < buffer.length. i++) {         if (buffer[i] == 42) {             counter++.         }     }     Assert.assertEquals(size, counter). }
false;public;1;10;;@Override public boolean equals(Object obj) {     if (obj instanceof TestRecord) {         TestRecord record = (TestRecord) obj.         return Arrays.equals(buffer, record.buffer).     } else {         return false.     } }
false;public;3;5;;@Override public void write(Kryo kryo, Output output, TestRecord object) {     output.writeInt(object.buffer.length).     output.write(object.buffer). }
false;public;3;7;;@Override public TestRecord read(Kryo kryo, Input input, Class<TestRecord> type) {     int length = input.readInt().     byte[] buffer = input.readBytes(length).     return new TestRecord(buffer). }
false;public;0;3;;public void clear() {     position = 0. }
false;public;0;3;;public byte[] getBuffer() {     return buffer. }
false;public;1;5;;public void checkSize(int numBytes) throws EOFException {     if (position + numBytes > buffer.length) {         throw new EOFException().     } }
false;public;1;6;;@Override public void skipBytesToWrite(int numBytes) throws IOException {     checkSize(numBytes).     position += numBytes. }
false;public;2;12;;@Override public void write(DataInputView source, int numBytes) throws IOException {     checkSize(numBytes).     byte[] tempBuffer = new byte[numBytes].     source.readFully(tempBuffer).     System.arraycopy(tempBuffer, 0, buffer, position, numBytes).     position += numBytes. }
false;public;1;6;;@Override public void write(int b) throws IOException {     checkSize(4).     position += 4. }
false;public;1;7;;@Override public void write(byte[] b) throws IOException {     checkSize(b.length).     System.arraycopy(b, 0, buffer, position, b.length).     position += b.length. }
false;public;3;8;;@Override public void write(byte[] b, int off, int len) throws IOException {     checkSize(len).     System.arraycopy(b, off, buffer, position, len).     position += len. }
false;public;1;5;;@Override public void writeBoolean(boolean v) throws IOException {     checkSize(1).     position += 1. }
false;public;1;8;;@Override public void writeByte(int v) throws IOException {     checkSize(1).     buffer[position] = (byte) v.     position++. }
false;public;1;6;;@Override public void writeShort(int v) throws IOException {     checkSize(2).     position += 2. }
false;public;1;5;;@Override public void writeChar(int v) throws IOException {     checkSize(1).     position++. }
false;public;1;6;;@Override public void writeInt(int v) throws IOException {     checkSize(4).     position += 4. }
false;public;1;5;;@Override public void writeLong(long v) throws IOException {     checkSize(8).     position += 8. }
false;public;1;5;;@Override public void writeFloat(float v) throws IOException {     checkSize(4).     position += 4. }
false;public;1;5;;@Override public void writeDouble(double v) throws IOException {     checkSize(8).     position += 8. }
false;public;1;7;;@Override public void writeBytes(String s) throws IOException {     byte[] sBuffer = s.getBytes(ConfigConstants.DEFAULT_CHARSET).     checkSize(sBuffer.length).     System.arraycopy(sBuffer, 0, buffer, position, sBuffer.length).     position += sBuffer.length. }
false;public;1;7;;@Override public void writeChars(String s) throws IOException {     byte[] sBuffer = s.getBytes(ConfigConstants.DEFAULT_CHARSET).     checkSize(sBuffer.length).     System.arraycopy(sBuffer, 0, buffer, position, sBuffer.length).     position += sBuffer.length. }
false;public;1;7;;@Override public void writeUTF(String s) throws IOException {     byte[] sBuffer = s.getBytes(ConfigConstants.DEFAULT_CHARSET).     checkSize(sBuffer.length).     System.arraycopy(sBuffer, 0, buffer, position, sBuffer.length).     position += sBuffer.length. }
