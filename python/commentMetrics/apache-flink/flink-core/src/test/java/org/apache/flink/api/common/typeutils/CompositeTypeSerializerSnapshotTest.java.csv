commented;modifiers;parameterAmount;loc;comment;code
false;public;0;19;;// ------------------------------------------------------------------------------------------------ // Scope: tests CompositeTypeSerializerSnapshot#resolveSchemaCompatibility // ------------------------------------------------------------------------------------------------ @Test public void testIncompatiblePrecedence() throws IOException {     final String OUTER_CONFIG = "outer-config".     final TypeSerializer<?>[] testNestedSerializers = { new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS), new NestedSerializer(TargetCompatibility.COMPATIBLE_AFTER_MIGRATION), new NestedSerializer(TargetCompatibility.INCOMPATIBLE), new NestedSerializer(TargetCompatibility.COMPATIBLE_WITH_RECONFIGURED_SERIALIZER) }.     TypeSerializerSchemaCompatibility<String> compatibility = snapshotCompositeSerializerAndGetSchemaCompatibilityAfterRestore(testNestedSerializers, testNestedSerializers, OUTER_CONFIG, OUTER_CONFIG).     Assert.assertTrue(compatibility.isIncompatible()). }
false;public;0;19;;@Test public void testCompatibleAfterMigrationPrecedence() throws IOException {     final String OUTER_CONFIG = "outer-config".     TypeSerializer<?>[] testNestedSerializers = { new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS), new NestedSerializer(TargetCompatibility.COMPATIBLE_AFTER_MIGRATION), new NestedSerializer(TargetCompatibility.COMPATIBLE_WITH_RECONFIGURED_SERIALIZER), new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS) }.     TypeSerializerSchemaCompatibility<String> compatibility = snapshotCompositeSerializerAndGetSchemaCompatibilityAfterRestore(testNestedSerializers, testNestedSerializers, OUTER_CONFIG, OUTER_CONFIG).     Assert.assertTrue(compatibility.isCompatibleAfterMigration()). }
false;public;0;26;;@Test public void testCompatibleWithReconfiguredSerializerPrecedence() throws IOException {     final String OUTER_CONFIG = "outer-config".     TypeSerializer<?>[] testNestedSerializers = { new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS), new NestedSerializer(TargetCompatibility.COMPATIBLE_WITH_RECONFIGURED_SERIALIZER), new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS) }.     TypeSerializerSchemaCompatibility<String> compatibility = snapshotCompositeSerializerAndGetSchemaCompatibilityAfterRestore(testNestedSerializers, testNestedSerializers, OUTER_CONFIG, OUTER_CONFIG).     Assert.assertTrue(compatibility.isCompatibleWithReconfiguredSerializer()).     TestCompositeTypeSerializer reconfiguredSerializer = (TestCompositeTypeSerializer) compatibility.getReconfiguredSerializer().     TypeSerializer<?>[] reconfiguredNestedSerializers = reconfiguredSerializer.getNestedSerializers().     // nested serializer at index 1 should strictly be a ReconfiguredNestedSerializer     Assert.assertTrue(reconfiguredNestedSerializers[0].getClass() == NestedSerializer.class).     Assert.assertTrue(reconfiguredNestedSerializers[1].getClass() == ReconfiguredNestedSerializer.class).     Assert.assertTrue(reconfiguredNestedSerializers[2].getClass() == NestedSerializer.class). }
false;public;0;17;;@Test public void testCompatibleAsIsPrecedence() throws IOException {     final String OUTER_CONFIG = "outer-config".     TypeSerializer<?>[] testNestedSerializers = { new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS), new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS) }.     TypeSerializerSchemaCompatibility<String> compatibility = snapshotCompositeSerializerAndGetSchemaCompatibilityAfterRestore(testNestedSerializers, testNestedSerializers, OUTER_CONFIG, OUTER_CONFIG).     Assert.assertTrue(compatibility.isCompatibleAsIs()). }
false;public;0;19;;@Test public void testOuterSnapshotCompatibilityPrecedence() throws IOException {     final String INIT_OUTER_CONFIG = "outer-config".     final String INCOMPAT_OUTER_CONFIG = "incompat-outer-config".     TypeSerializer<?>[] testNestedSerializers = { new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS) }.     TypeSerializerSchemaCompatibility<String> compatibility = snapshotCompositeSerializerAndGetSchemaCompatibilityAfterRestore(testNestedSerializers, testNestedSerializers, INIT_OUTER_CONFIG, INCOMPAT_OUTER_CONFIG).     // even though nested serializers are compatible, incompatibility of the outer     // snapshot should have higher precedence in the final result     Assert.assertTrue(compatibility.isIncompatible()). }
false;public;0;24;;@Test public void testNestedFieldSerializerArityMismatchPrecedence() throws IOException {     final String OUTER_CONFIG = "outer-config".     final TypeSerializer<?>[] initialNestedSerializers = { new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS) }.     final TypeSerializer<?>[] newNestedSerializers = { new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS), new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS), new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS) }.     TypeSerializerSchemaCompatibility<String> compatibility = snapshotCompositeSerializerAndGetSchemaCompatibilityAfterRestore(initialNestedSerializers, newNestedSerializers, OUTER_CONFIG, OUTER_CONFIG).     // arity mismatch in the nested serializers should return incompatible as the result     Assert.assertTrue(compatibility.isIncompatible()). }
false;private;4;21;;private TypeSerializerSchemaCompatibility<String> snapshotCompositeSerializerAndGetSchemaCompatibilityAfterRestore(TypeSerializer<?>[] initialNestedSerializers, TypeSerializer<?>[] newNestedSerializer, String initialOuterConfiguration, String newOuterConfiguration) throws IOException {     TestCompositeTypeSerializer testSerializer = new TestCompositeTypeSerializer(initialOuterConfiguration, initialNestedSerializers).     TypeSerializerSnapshot<String> testSerializerSnapshot = testSerializer.snapshotConfiguration().     DataOutputSerializer out = new DataOutputSerializer(128).     TypeSerializerSnapshot.writeVersionedSnapshot(out, testSerializerSnapshot).     DataInputDeserializer in = new DataInputDeserializer(out.getCopyOfBuffer()).     testSerializerSnapshot = TypeSerializerSnapshot.readVersionedSnapshot(in, Thread.currentThread().getContextClassLoader()).     TestCompositeTypeSerializer newTestSerializer = new TestCompositeTypeSerializer(newOuterConfiguration, newNestedSerializer).     return testSerializerSnapshot.resolveSchemaCompatibility(newTestSerializer). }
false;public;0;28;;// ------------------------------------------------------------------------------------------------ // Scope: tests CompositeTypeSerializerSnapshot#restoreSerializer // ------------------------------------------------------------------------------------------------ @Test public void testRestoreCompositeTypeSerializer() throws IOException {     // the target compatibilities of the nested serializers doesn't matter,     // because we're only testing the restore serializer     TypeSerializer<?>[] testNestedSerializers = { new NestedSerializer(TargetCompatibility.COMPATIBLE_AS_IS), new NestedSerializer(TargetCompatibility.INCOMPATIBLE), new NestedSerializer(TargetCompatibility.COMPATIBLE_AFTER_MIGRATION) }.     TestCompositeTypeSerializer testSerializer = new TestCompositeTypeSerializer("outer-config", testNestedSerializers).     TypeSerializerSnapshot<String> testSerializerSnapshot = testSerializer.snapshotConfiguration().     DataOutputSerializer out = new DataOutputSerializer(128).     TypeSerializerSnapshot.writeVersionedSnapshot(out, testSerializerSnapshot).     DataInputDeserializer in = new DataInputDeserializer(out.getCopyOfBuffer()).     testSerializerSnapshot = TypeSerializerSnapshot.readVersionedSnapshot(in, Thread.currentThread().getContextClassLoader()).     // now, restore the composite type serializer.     // the restored nested serializer should be a RestoredNestedSerializer     testSerializer = (TestCompositeTypeSerializer) testSerializerSnapshot.restoreSerializer().     Assert.assertTrue(testSerializer.getNestedSerializers()[0].getClass() == RestoredNestedSerializer.class).     Assert.assertTrue(testSerializer.getNestedSerializers()[1].getClass() == RestoredNestedSerializer.class).     Assert.assertTrue(testSerializer.getNestedSerializers()[2].getClass() == RestoredNestedSerializer.class). }
false;public;0;3;;public String getOuterConfiguration() {     return outerConfiguration. }
false;;0;3;;TypeSerializer<?>[] getNestedSerializers() {     return nestedSerializers. }
false;public;0;4;;@Override public TypeSerializerSnapshot<String> snapshotConfiguration() {     return new TestCompositeTypeSerializerSnapshot(this). }
false;public;2;4;;// -------------------------------------------------------------------------------- // Serialization delegation // -------------------------------------------------------------------------------- @Override public String deserialize(String reuse, DataInputView source) throws IOException {     return delegateSerializer.deserialize(reuse, source). }
false;public;1;4;;@Override public String deserialize(DataInputView source) throws IOException {     return delegateSerializer.deserialize(source). }
false;public;2;4;;@Override public void serialize(String record, DataOutputView target) throws IOException {     delegateSerializer.serialize(record, target). }
false;public;2;4;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     delegateSerializer.copy(source, target). }
false;public;1;4;;@Override public String copy(String from) {     return delegateSerializer.copy(from). }
false;public;2;4;;@Override public String copy(String from, String reuse) {     return delegateSerializer.copy(from, reuse). }
false;public;0;4;;@Override public String createInstance() {     return delegateSerializer.createInstance(). }
false;public;0;4;;@Override public TypeSerializer<String> duplicate() {     return this. }
false;public;0;4;;@Override public boolean isImmutableType() {     return false. }
false;public;0;4;;@Override public int getLength() {     return 0. }
false;public;1;7;;@Override public boolean equals(Object obj) {     if (obj instanceof TestCompositeTypeSerializer) {         return Arrays.equals(nestedSerializers, ((TestCompositeTypeSerializer) obj).getNestedSerializers()).     }     return false. }
false;public;0;4;;@Override public int hashCode() {     return Arrays.hashCode(nestedSerializers). }
false;protected;1;4;;@Override protected TestCompositeTypeSerializer createOuterSerializerWithNestedSerializers(TypeSerializer<?>[] nestedSerializers) {     return new TestCompositeTypeSerializer(outerConfiguration, nestedSerializers). }
false;protected;1;4;;@Override protected TypeSerializer<?>[] getNestedSerializers(TestCompositeTypeSerializer outerSerializer) {     return outerSerializer.getNestedSerializers(). }
false;protected;1;4;;@Override protected void writeOuterSnapshot(DataOutputView out) throws IOException {     out.writeUTF(outerConfiguration). }
false;public;3;5;;@Override public void readOuterSnapshot(int readOuterSnapshotVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     Assert.assertEquals(getCurrentOuterSnapshotVersion(), readOuterSnapshotVersion).     this.outerConfiguration = in.readUTF(). }
false;protected;1;4;;@Override protected boolean isOuterSnapshotCompatible(TestCompositeTypeSerializer newSerializer) {     return outerConfiguration.equals(newSerializer.getOuterConfiguration()). }
false;public;0;4;;@Override public int getCurrentOuterSnapshotVersion() {     return 1. }
false;public;0;4;;@Override public TypeSerializerSnapshot<String> snapshotConfiguration() {     return new NestedSerializerSnapshot(targetCompatibility). }
false;public;2;4;;// -------------------------------------------------------------------------------- // Serialization delegation // -------------------------------------------------------------------------------- @Override public String deserialize(String reuse, DataInputView source) throws IOException {     return delegateSerializer.deserialize(reuse, source). }
false;public;1;4;;@Override public String deserialize(DataInputView source) throws IOException {     return delegateSerializer.deserialize(source). }
false;public;2;4;;@Override public void serialize(String record, DataOutputView target) throws IOException {     delegateSerializer.serialize(record, target). }
false;public;2;4;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     delegateSerializer.copy(source, target). }
false;public;1;4;;@Override public String copy(String from) {     return delegateSerializer.copy(from). }
false;public;2;4;;@Override public String copy(String from, String reuse) {     return delegateSerializer.copy(from, reuse). }
false;public;0;4;;@Override public String createInstance() {     return delegateSerializer.createInstance(). }
false;public;0;4;;@Override public TypeSerializer<String> duplicate() {     return this. }
false;public;0;4;;@Override public boolean isImmutableType() {     return false. }
false;public;0;4;;@Override public int getLength() {     return 0. }
false;public;1;4;;@Override public boolean equals(Object obj) {     return targetCompatibility == ((NestedSerializer) obj).targetCompatibility. }
false;public;0;4;;@Override public int hashCode() {     return targetCompatibility.hashCode(). }
false;public;1;4;;@Override public void writeSnapshot(DataOutputView out) throws IOException {     out.writeInt(targetCompatibility.ordinal()). }
false;public;3;4;;@Override public void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     this.targetCompatibility = TargetCompatibility.values()[in.readInt()]. }
false;public;1;22;;@Override public TypeSerializerSchemaCompatibility<String> resolveSchemaCompatibility(TypeSerializer<String> newSerializer) {     // this ensures that we get a new serializer, and not a ReconfiguredNestedSerializer or RestoredNestedSerializer     if (newSerializer.getClass() == NestedSerializer.class) {         switch(targetCompatibility) {             case COMPATIBLE_AS_IS:                 return TypeSerializerSchemaCompatibility.compatibleAsIs().             case COMPATIBLE_AFTER_MIGRATION:                 return TypeSerializerSchemaCompatibility.compatibleAfterMigration().             case COMPATIBLE_WITH_RECONFIGURED_SERIALIZER:                 return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(new ReconfiguredNestedSerializer(targetCompatibility)).             case INCOMPATIBLE:                 return TypeSerializerSchemaCompatibility.incompatible().             default:                 throw new IllegalStateException("Unexpected target compatibility.").         }     }     throw new IllegalArgumentException("Expected the new serializer to be of class " + NestedSerializer.class). }
false;public;0;4;;@Override public TypeSerializer<String> restoreSerializer() {     return new RestoredNestedSerializer(targetCompatibility). }
false;public;0;4;;@Override public int getCurrentVersion() {     return 1. }
