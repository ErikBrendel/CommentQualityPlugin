commented;modifiers;parameterAmount;loc;comment;code
false;public;0;17;;@Test public void testResolveProxyClass() throws Exception {     final String interfaceName = "UserDefinedInterface".     final String proxyName = "UserProxy".     try (URLClassLoader userClassLoader = createClassLoader(interfaceName, proxyName)) {         Class<?> userInterface = Class.forName(interfaceName, false, userClassLoader).         InvocationHandler userProxy = (InvocationHandler) Class.forName(proxyName, false, userClassLoader).newInstance().         Object proxy = Proxy.newProxyInstance(userClassLoader, new Class[] { userInterface }, userProxy).         byte[] serializeObject = InstantiationUtil.serializeObject(proxy).         Object deserializedProxy = InstantiationUtil.deserializeObject(serializeObject, userClassLoader).         assertNotNull(deserializedProxy).     } }
false;private;2;6;;private URLClassLoader createClassLoader(String interfaceName, String proxyName) throws IOException {     return ClassLoaderUtils.withRoot(temporaryFolder.newFolder()).addClass(interfaceName, String.format("interface %s { void test().}", interfaceName)).addClass(proxyName, createProxyDefinition(proxyName)).build(). }
false;private;1;3;;private String createProxyDefinition(String proxyName) {     return String.format(PROXY_DEFINITION_FORMAT, proxyName). }
false;public;0;6;;@Test public void testInstantiationOfStringValue() {     StringValue stringValue = InstantiationUtil.instantiate(StringValue.class, null).     assertNotNull(stringValue). }
false;public;0;6;;@Test public void testInstantiationOfStringValueAndCastToValue() {     StringValue stringValue = InstantiationUtil.instantiate(StringValue.class, Value.class).     assertNotNull(stringValue). }
false;public;0;5;;@Test public void testHasNullaryConstructor() {     assertTrue(InstantiationUtil.hasPublicNullaryConstructor(StringValue.class)). }
false;public;0;4;;@Test public void testClassIsProper() {     assertTrue(InstantiationUtil.isProperClass(StringValue.class)). }
false;public;0;4;;@Test public void testClassIsNotProper() {     assertFalse(InstantiationUtil.isProperClass(Value.class)). }
false;public;0;4;;@Test(expected = RuntimeException.class) public void testCheckForInstantiationOfPrivateClass() {     InstantiationUtil.checkForInstantiation(TestClass.class). }
false;public;0;11;;@Test public void testSerializationToByteArray() throws IOException {     final DoubleValue toSerialize = new DoubleValue(Math.random()).     final DoubleValueSerializer serializer = new DoubleValueSerializer().     byte[] serialized = InstantiationUtil.serializeToByteArray(serializer, toSerialize).     DoubleValue deserialized = InstantiationUtil.deserializeFromByteArray(serializer, serialized).     assertEquals("Serialized record is not equal after serialization.", toSerialize, deserialized). }
false;public;0;48;;@Test public void testWriteToConfigFailingSerialization() {     try {         final String key1 = "testkey1".         final String key2 = "testkey2".         final Configuration config = new Configuration().         try {             InstantiationUtil.writeObjectToConfig(new TestClassWriteFails(), config, "irgnored").             fail("should throw an exception").         } catch (TestException e) {         // expected         } catch (Exception e) {             fail("Wrong exception type - exception not properly forwarded").         }         InstantiationUtil.writeObjectToConfig(new TestClassReadFails(), config, key1).         InstantiationUtil.writeObjectToConfig(new TestClassReadFailsCNF(), config, key2).         try {             InstantiationUtil.readObjectFromConfig(config, key1, getClass().getClassLoader()).             fail("should throw an exception").         } catch (TestException e) {         // expected         } catch (Exception e) {             fail("Wrong exception type - exception not properly forwarded").         }         try {             InstantiationUtil.readObjectFromConfig(config, key2, getClass().getClassLoader()).             fail("should throw an exception").         } catch (ClassNotFoundException e) {         // expected         } catch (Exception e) {             fail("Wrong exception type - exception not properly forwarded").         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;8;;@Test public void testCopyWritable() throws Exception {     WritableType original = new WritableType().     WritableType copy = InstantiationUtil.createCopyWritable(original).     assertTrue(original != copy).     assertTrue(original.equals(copy)). }
false;private;1;3;;private void writeObject(ObjectOutputStream out) throws IOException {     throw new TestException(). }
false;private;1;3;;private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {     throw new TestException(). }
false;private;1;3;;private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {     throw new ClassNotFoundException("test exception"). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(aInt, aLong). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     } else if (obj != null && obj.getClass() == WritableType.class) {         WritableType that = (WritableType) obj.         return this.aLong == that.aLong && this.aInt == that.aInt.     } else {         return false.     } }
false;public;1;5;;@Override public void write(DataOutputView out) throws IOException {     out.writeInt(aInt).     out.writeLong(aLong). }
false;public;1;5;;@Override public void read(DataInputView in) throws IOException {     this.aInt = in.readInt().     this.aLong = in.readLong(). }
