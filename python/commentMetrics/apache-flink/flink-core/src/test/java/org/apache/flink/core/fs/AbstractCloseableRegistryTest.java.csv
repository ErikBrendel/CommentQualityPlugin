commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;1;1;;protected abstract void registerCloseable(Closeable closeable) throws IOException.
false;protected,abstract;0;1;;protected abstract AbstractCloseableRegistry<C, T> createRegistry().
false;protected,abstract;3;4;;protected abstract ProducerThread<C, T> createProducerThread(AbstractCloseableRegistry<C, T> registry, AtomicInteger unclosedCounter, int maxStreams).
false;public;1;9;;public void setup(int maxStreams) {     Assert.assertFalse(SafetyNetCloseableRegistry.isReaperThreadRunning()).     this.closeableRegistry = createRegistry().     this.unclosedCounter = new AtomicInteger(0).     this.streamOpenThreads = new ProducerThread[10].     for (int i = 0. i < streamOpenThreads.length. ++i) {         streamOpenThreads[i] = createProducerThread(closeableRegistry, unclosedCounter, maxStreams).     } }
false;protected;0;5;;protected void startThreads() {     for (ProducerThread t : streamOpenThreads) {         t.start().     } }
false;protected;0;5;;protected void joinThreads() throws InterruptedException {     for (Thread t : streamOpenThreads) {         t.join().     } }
false;public;0;28;;@Test public void testClose() throws Exception {     setup(Integer.MAX_VALUE).     startThreads().     for (int i = 0. i < 5. ++i) {         System.gc().         Thread.sleep(40).     }     closeableRegistry.close().     joinThreads().     assertEquals(0, unclosedCounter.get()).     assertEquals(0, closeableRegistry.getNumberOfRegisteredCloseables()).     final TestCloseable testCloseable = new TestCloseable().     try {         registerCloseable(testCloseable).         fail("Closed registry should not accept closeables!").     } catch (IOException expected) {     }     assertTrue(testCloseable.isClosed()).     assertEquals(0, unclosedCounter.get()).     assertEquals(0, closeableRegistry.getNumberOfRegisteredCloseables()). }
false;public;0;31;;@Test public void testNonBlockingClose() throws Exception {     setup(Integer.MAX_VALUE).     final BlockingTestCloseable blockingCloseable = new BlockingTestCloseable().     registerCloseable(blockingCloseable).     assertEquals(1, closeableRegistry.getNumberOfRegisteredCloseables()).     Thread closer = new Thread(() -> {         try {             closeableRegistry.close().         } catch (IOException ignore) {         }     }).     closer.start().     blockingCloseable.awaitClose(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS).     final TestCloseable testCloseable = new TestCloseable().     try {         registerCloseable(testCloseable).         fail("Closed registry should not accept closeables!").     } catch (IOException ignored) {     }     blockingCloseable.unblockClose().     closer.join().     assertTrue(testCloseable.isClosed()).     assertEquals(0, closeableRegistry.getNumberOfRegisteredCloseables()). }
false;protected,abstract;0;1;;protected abstract void createAndRegisterStream() throws IOException.
false;public;0;19;;@Override public void run() {     try {         while (numStreams < maxStreams) {             createAndRegisterStream().             try {                 Thread.sleep(2).             } catch (InterruptedException ignored) {             }             if (maxStreams != Integer.MAX_VALUE) {                 ++numStreams.             }         }     } catch (Exception ex) {     // ignored     } }
false;public;1;4;;@Override public void seek(long desired) throws IOException { }
false;public;0;4;;@Override public long getPos() throws IOException {     return 0. }
false;public;0;4;;@Override public int read() throws IOException {     return 0. }
false;public,synchronized;0;4;;@Override public synchronized void close() throws IOException {     refCount.decrementAndGet(). }
false;public;0;9;;@Override public void close() throws IOException {     closeCalledLatch.countDown().     try {         blockCloseLatch.await().     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } }
true;public;0;3;/**  * Unblocks {@link #close()}.  */ ;/**  * Unblocks {@link #close()}.  */ public void unblockClose() {     blockCloseLatch.countDown(). }
true;public;2;3;/**  * Causes the current thread to wait until {@link #close()} is called.  */ ;/**  * Causes the current thread to wait until {@link #close()} is called.  */ public void awaitClose(final long timeout, final TimeUnit timeUnit) throws InterruptedException {     closeCalledLatch.await(timeout, timeUnit). }
false;public;0;4;;@Override public void close() throws IOException {     assertTrue("TestCloseable was already closed", closed.compareAndSet(false, true)). }
false;public;0;3;;public boolean isClosed() {     return closed.get(). }
