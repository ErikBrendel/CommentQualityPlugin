commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;public ByteBuffer wrapAsByteBuffer() {     this.wrapper.position(0).     this.wrapper.limit(this.position).     return this.wrapper. }
false;public;0;6;;public byte[] copyByteBuffer() {     byte[] target = new byte[position].     System.arraycopy(buffer, 0, target, 0, position).     return target. }
false;public;0;3;;public void clear() {     this.position = 0. }
false;public;0;3;;public int length() {     return this.position. }
false;public;0;4;;@Override public String toString() {     return String.format("[pos=%d cap=%d]", this.position, this.buffer.length). }
false;public;1;7;;// ---------------------------------------------------------------------------------------- // Data Output // ---------------------------------------------------------------------------------------- @Override public void write(int b) throws IOException {     if (this.position >= this.buffer.length) {         resize(1).     }     this.buffer[this.position++] = (byte) (b & 0xff). }
false;public;1;4;;@Override public void write(byte[] b) throws IOException {     write(b, 0, b.length). }
false;public;3;11;;@Override public void write(byte[] b, int off, int len) throws IOException {     if (len < 0 || off > b.length - len) {         throw new ArrayIndexOutOfBoundsException().     }     if (this.position > this.buffer.length - len) {         resize(len).     }     System.arraycopy(b, off, this.buffer, this.position, len).     this.position += len. }
false;public;1;4;;@Override public void writeBoolean(boolean v) throws IOException {     write(v ? 1 : 0). }
false;public;1;4;;@Override public void writeByte(int v) throws IOException {     write(v). }
false;public;1;12;;@Override public void writeBytes(String s) throws IOException {     final int sLen = s.length().     if (this.position >= this.buffer.length - sLen) {         resize(sLen).     }     for (int i = 0. i < sLen. i++) {         writeByte(s.charAt(i)).     }     this.position += sLen. }
false;public;1;8;;@Override public void writeChar(int v) throws IOException {     if (this.position >= this.buffer.length - 1) {         resize(2).     }     this.buffer[this.position++] = (byte) (v >> 8).     this.buffer[this.position++] = (byte) v. }
false;public;1;10;;@Override public void writeChars(String s) throws IOException {     final int sLen = s.length().     if (this.position >= this.buffer.length - 2 * sLen) {         resize(2 * sLen).     }     for (int i = 0. i < sLen. i++) {         writeChar(s.charAt(i)).     } }
false;public;1;4;;@Override public void writeDouble(double v) throws IOException {     writeLong(Double.doubleToLongBits(v)). }
false;public;1;4;;@Override public void writeFloat(float v) throws IOException {     writeInt(Float.floatToIntBits(v)). }
false;public;1;12;;@SuppressWarnings("restriction") @Override public void writeInt(int v) throws IOException {     if (this.position >= this.buffer.length - 3) {         resize(4).     }     if (LITTLE_ENDIAN) {         v = Integer.reverseBytes(v).     }     UNSAFE.putInt(this.buffer, BASE_OFFSET + this.position, v).     this.position += 4. }
false;public;1;12;;@SuppressWarnings("restriction") @Override public void writeLong(long v) throws IOException {     if (this.position >= this.buffer.length - 7) {         resize(8).     }     if (LITTLE_ENDIAN) {         v = Long.reverseBytes(v).     }     UNSAFE.putLong(this.buffer, BASE_OFFSET + this.position, v).     this.position += 8. }
false;public;1;8;;@Override public void writeShort(int v) throws IOException {     if (this.position >= this.buffer.length - 1) {         resize(2).     }     this.buffer[this.position++] = (byte) ((v >>> 8) & 0xff).     this.buffer[this.position++] = (byte) ((v >>> 0) & 0xff). }
false;public;1;57;;@Override public void writeUTF(String str) throws IOException {     int strlen = str.length().     int utflen = 0.     int c.     /* use charAt instead of copying String to char array */     for (int i = 0. i < strlen. i++) {         c = str.charAt(i).         if ((c >= 0x0001) && (c <= 0x007F)) {             utflen++.         } else if (c > 0x07FF) {             utflen += 3.         } else {             utflen += 2.         }     }     if (utflen > 65535) {         throw new UTFDataFormatException("Encoded string is too long: " + utflen).     } else if (this.position > this.buffer.length - utflen - 2) {         resize(utflen + 2).     }     byte[] bytearr = this.buffer.     int count = this.position.     bytearr[count++] = (byte) ((utflen >>> 8) & 0xFF).     bytearr[count++] = (byte) ((utflen >>> 0) & 0xFF).     int i = 0.     for (i = 0. i < strlen. i++) {         c = str.charAt(i).         if (!((c >= 0x0001) && (c <= 0x007F))) {             break.         }         bytearr[count++] = (byte) c.     }     for (. i < strlen. i++) {         c = str.charAt(i).         if ((c >= 0x0001) && (c <= 0x007F)) {             bytearr[count++] = (byte) c.         } else if (c > 0x07FF) {             bytearr[count++] = (byte) (0xE0 | ((c >> 12) & 0x0F)).             bytearr[count++] = (byte) (0x80 | ((c >> 6) & 0x3F)).             bytearr[count++] = (byte) (0x80 | ((c >> 0) & 0x3F)).         } else {             bytearr[count++] = (byte) (0xC0 | ((c >> 6) & 0x1F)).             bytearr[count++] = (byte) (0x80 | ((c >> 0) & 0x3F)).         }     }     this.position = count. }
false;private;1;22;;private void resize(int minCapacityAdd) throws IOException {     try {         int newLen = Math.max(this.buffer.length * 2, this.buffer.length + minCapacityAdd).         if (newLen > maxSize) {             if (this.buffer.length + minCapacityAdd > maxSize) {                 throw new EOFException("Exceeded maximum capacity").             }             newLen = maxSize.         }         final byte[] nb = new byte[newLen].         System.arraycopy(this.buffer, 0, nb, 0, this.position).         this.buffer = nb.         this.wrapper = ByteBuffer.wrap(this.buffer).     } catch (NegativeArraySizeException nasex) {         throw new IOException("Serialization failed because the record length would exceed 2GB (max addressable array size in Java).").     } }
false;public;1;8;;@Override public void skipBytesToWrite(int numBytes) throws IOException {     if (buffer.length - this.position < numBytes) {         throw new EOFException("Could not skip " + numBytes + " bytes.").     }     this.position += numBytes. }
false;public;2;9;;@Override public void write(DataInputView source, int numBytes) throws IOException {     if (buffer.length - this.position < numBytes) {         throw new EOFException("Could not write " + numBytes + " bytes. Buffer overflow.").     }     source.readFully(this.buffer, this.position, numBytes).     this.position += numBytes. }
