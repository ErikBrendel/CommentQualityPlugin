commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;@Override public int compareSerialized(DataInputView firstSource, DataInputView secondSource) throws IOException {     BigDecimal bd1 = BigDecSerializer.readBigDecimal(firstSource).     BigDecimal bd2 = BigDecSerializer.readBigDecimal(secondSource).     // null is not supported     int comp = bd1.compareTo(bd2).     return ascendingComparison ? comp : -comp. }
false;public;0;4;;@Override public boolean supportsNormalizedKey() {     return true. }
false;public;0;4;;@Override public boolean supportsSerializationWithKeyNormalization() {     return false. }
false;public;0;4;;@Override public int getNormalizeKeyLen() {     return 5. }
false;public;1;4;;@Override public boolean isNormalizedKeyPrefixOnly(int keyBytes) {     return true. }
true;public;4;37;/**  * Adds a normalized key containing a normalized order of magnitude of the given record.  * 2 bits determine the sign (negative, zero, positive), 33 bits determine the magnitude.  * This method adds at most 5 bytes that contain information.  */ ;/**  * Adds a normalized key containing a normalized order of magnitude of the given record.  * 2 bits determine the sign (negative, zero, positive), 33 bits determine the magnitude.  * This method adds at most 5 bytes that contain information.  */ @Override public void putNormalizedKey(BigDecimal record, MemorySegment target, int offset, int len) {     final long signum = record.signum().     // order of magnitude     // smallest:     // scale = Integer.MAX, precision = 1 => SMALLEST_MAGNITUDE     // largest:     // scale = Integer.MIN, precision = Integer.MAX => LARGEST_MAGNITUDE     final long mag = ((long) record.scale()) - ((long) record.precision()) + 1.     // normalize value range: from 0 to (SMALLEST_MAGNITUDE + -1*LARGEST_MAGNITUDE)     final long normMag = -1L * LARGEST_MAGNITUDE + mag.     // normalize value range dependent on sign:     // 0 to (SMALLEST_MAGNITUDE + -1*LARGEST_MAGNITUDE)     // OR (SMALLEST_MAGNITUDE + -1*LARGEST_MAGNITUDE) to 0     // --> uses at most 33 bit (5 least-significant bytes)     long signNormMag = signum < 0 ? normMag : (SMALLEST_MAGNITUDE + -1L * LARGEST_MAGNITUDE - normMag).     // set 34th bit to flag zero     if (signum == 0) {         signNormMag = 0L.         signNormMag |= (1L << 34).     } else // set 35th bit to flag positive sign     if (signum > 0) {         signNormMag |= (1L << 35).     }     // add 5 least-significant bytes that contain value to target     for (int i = 0. i < 5 && len > 0. i++, len--) {         final byte b = (byte) (signNormMag >>> (8 * (4 - i))).         target.put(offset++, b).     } }
false;public;0;4;;@Override public BigDecComparator duplicate() {     return new BigDecComparator(ascendingComparison). }
