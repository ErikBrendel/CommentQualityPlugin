commented;modifiers;parameterAmount;loc;comment;code
true;public;1;9;/**  * Returns whether this type should be automatically casted to  * the target type in an arithmetic operation.  */ ;// -------------------------------------------------------------------------------------------- /**  * Returns whether this type should be automatically casted to  * the target type in an arithmetic operation.  */ @PublicEvolving public boolean shouldAutocastTo(BasicTypeInfo<?> to) {     for (Class<?> possibleTo : possibleCastTargetTypes) {         if (possibleTo.equals(to.getTypeClass())) {             return true.         }     }     return false. }
false;public;0;5;;@Override @PublicEvolving public boolean isBasicType() {     return true. }
false;public;0;5;;@Override @PublicEvolving public boolean isTupleType() {     return false. }
false;public;0;5;;@Override @PublicEvolving public int getArity() {     return 1. }
false;public;0;5;;@Override @PublicEvolving public int getTotalFields() {     return 1. }
false;public;0;5;;@Override @PublicEvolving public Class<T> getTypeClass() {     return this.clazz. }
false;public;0;5;;@Override @PublicEvolving public boolean isKeyType() {     return true. }
false;public;1;5;;@Override @PublicEvolving public TypeSerializer<T> createSerializer(ExecutionConfig executionConfig) {     return this.serializer. }
false;public;2;9;;@Override @PublicEvolving public TypeComparator<T> createComparator(boolean sortOrderAscending, ExecutionConfig executionConfig) {     if (comparatorClass != null) {         return instantiateComparator(comparatorClass, sortOrderAscending).     } else {         throw new InvalidTypesException("The type " + clazz.getSimpleName() + " cannot be used as a key.").     } }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public int hashCode() {     return (31 * Objects.hash(clazz, serializer, comparatorClass)) + Arrays.hashCode(possibleCastTargetTypes). }
false;public;1;4;;@Override public boolean canEqual(Object obj) {     return obj instanceof BasicTypeInfo. }
false;public;1;14;;@Override public boolean equals(Object obj) {     if (obj instanceof BasicTypeInfo) {         @SuppressWarnings("unchecked")         BasicTypeInfo<T> other = (BasicTypeInfo<T>) obj.         return other.canEqual(this) && this.clazz == other.clazz && serializer.equals(other.serializer) && this.comparatorClass == other.comparatorClass.     } else {         return false.     } }
false;public;0;4;;@Override public String toString() {     return clazz.getSimpleName(). }
false;public,static;1;10;;// -------------------------------------------------------------------------------------------- @PublicEvolving public static <X> BasicTypeInfo<X> getInfoFor(Class<X> type) {     if (type == null) {         throw new NullPointerException().     }     @SuppressWarnings("unchecked")     BasicTypeInfo<X> info = (BasicTypeInfo<X>) TYPES.get(type).     return info. }
false;private,static;2;9;;private static <X> TypeComparator<X> instantiateComparator(Class<? extends TypeComparator<X>> comparatorClass, boolean ascendingOrder) {     try {         Constructor<? extends TypeComparator<X>> constructor = comparatorClass.getConstructor(boolean.class).         return constructor.newInstance(ascendingOrder).     } catch (Exception e) {         throw new RuntimeException("Could not initialize basic comparator " + comparatorClass.getName(), e).     } }
