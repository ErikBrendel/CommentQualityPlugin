commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;@Override public int compareSerialized(DataInputView firstSource, DataInputView secondSource) throws IOException {     String s1 = StringValue.readString(firstSource).     String s2 = StringValue.readString(secondSource).     int comp = s1.compareTo(s2).     return ascendingComparison ? comp : -comp. }
false;public;0;4;;@Override public boolean supportsNormalizedKey() {     return true. }
false;public;0;4;;@Override public boolean supportsSerializationWithKeyNormalization() {     return false. }
false;public;0;4;;@Override public int getNormalizeKeyLen() {     return Integer.MAX_VALUE. }
false;public;1;4;;@Override public boolean isNormalizedKeyPrefixOnly(int keyBytes) {     return true. }
false;public;4;31;;@Override public void putNormalizedKey(String record, MemorySegment target, int offset, int len) {     final int limit = offset + len.     final int end = record.length().     int pos = 0.     while (pos < end && offset < limit) {         char c = record.charAt(pos++).         if (c < HIGH_BIT) {             target.put(offset++, (byte) c).         } else if (c < HIGH_BIT2) {             target.put(offset++, (byte) ((c >>> 7) | HIGH_BIT)).             if (offset < limit) {                 target.put(offset++, (byte) c).             }         } else {             target.put(offset++, (byte) ((c >>> 10) | HIGH_BIT2_MASK)).             if (offset < limit) {                 target.put(offset++, (byte) (c >>> 2)).             }             if (offset < limit) {                 target.put(offset++, (byte) c).             }         }     }     while (offset < limit) {         target.put(offset++, (byte) 0).     } }
false;public;0;4;;@Override public StringComparator duplicate() {     return new StringComparator(ascendingComparison). }
