commented;modifiers;parameterAmount;loc;comment;code
true;public;2;11;/**  * Sets the order of the elements within a group for the given input.  *  * @param inputNum The number of the input (here either <i>0</i> or <i>1</i>).  * @param order    The order for the elements in a group.  */ ;// -------------------------------------------------------------------------------------------- /**  * Sets the order of the elements within a group for the given input.  *  * @param inputNum The number of the input (here either <i>0</i> or <i>1</i>).  * @param order    The order for the elements in a group.  */ public void setGroupOrder(int inputNum, Ordering order) {     if (inputNum == 0) {         this.groupOrder1 = order.     } else if (inputNum == 1) {         this.groupOrder2 = order.     } else {         throw new IndexOutOfBoundsException().     } }
true;public;1;3;/**  * Sets the order of the elements within a group for the first input.  *  * @param order The order for the elements in a group.  */ ;/**  * Sets the order of the elements within a group for the first input.  *  * @param order The order for the elements in a group.  */ public void setGroupOrderForInputOne(Ordering order) {     setGroupOrder(0, order). }
true;public;1;3;/**  * Sets the order of the elements within a group for the second input.  *  * @param order The order for the elements in a group.  */ ;/**  * Sets the order of the elements within a group for the second input.  *  * @param order The order for the elements in a group.  */ public void setGroupOrderForInputTwo(Ordering order) {     setGroupOrder(1, order). }
true;public;1;11;/**  * Gets the value order for an input, i.e. the order of elements within a group.  * If no such order has been set, this method returns null.  *  * @param inputNum The number of the input (here either <i>0</i> or <i>1</i>).  * @return The group order.  */ ;/**  * Gets the value order for an input, i.e. the order of elements within a group.  * If no such order has been set, this method returns null.  *  * @param inputNum The number of the input (here either <i>0</i> or <i>1</i>).  * @return The group order.  */ public Ordering getGroupOrder(int inputNum) {     if (inputNum == 0) {         return this.groupOrder1.     } else if (inputNum == 1) {         return this.groupOrder2.     } else {         throw new IndexOutOfBoundsException().     } }
true;public;0;3;/**  * Gets the order of elements within a group for the first input.  * If no such order has been set, this method returns null.  *  * @return The group order for the first input.  */ ;/**  * Gets the order of elements within a group for the first input.  * If no such order has been set, this method returns null.  *  * @return The group order for the first input.  */ public Ordering getGroupOrderForInputOne() {     return getGroupOrder(0). }
true;public;0;3;/**  * Gets the order of elements within a group for the second input.  * If no such order has been set, this method returns null.  *  * @return The group order for the second input.  */ ;/**  * Gets the order of elements within a group for the second input.  * If no such order has been set, this method returns null.  *  * @return The group order for the second input.  */ public Ordering getGroupOrderForInputTwo() {     return getGroupOrder(1). }
false;public;0;3;;// -------------------------------------------------------------------------------------------- public boolean isCombinableFirst() {     return this.combinableFirst. }
false;public;1;3;;public void setCombinableFirst(boolean combinableFirst) {     this.combinableFirst = combinableFirst. }
false;public;0;3;;public boolean isCombinableSecond() {     return this.combinableSecond. }
false;public;1;3;;public void setCombinableSecond(boolean combinableSecond) {     this.combinableSecond = combinableSecond. }
false;public;1;3;;public void setCustomPartitioner(Partitioner<?> customPartitioner) {     this.customPartitioner = customPartitioner. }
false;public;0;3;;public Partitioner<?> getCustomPartitioner() {     return customPartitioner. }
false;protected;4;87;;// ------------------------------------------------------------------------ @Override protected List<OUT> executeOnCollections(List<IN1> input1, List<IN2> input2, RuntimeContext ctx, ExecutionConfig executionConfig) throws Exception {     // --------------------------------------------------------------------     // Setup     // --------------------------------------------------------------------     TypeInformation<IN1> inputType1 = getOperatorInfo().getFirstInputType().     TypeInformation<IN2> inputType2 = getOperatorInfo().getSecondInputType().     // for the grouping / merging comparator     int[] inputKeys1 = getKeyColumns(0).     int[] inputKeys2 = getKeyColumns(1).     boolean[] inputDirections1 = new boolean[inputKeys1.length].     boolean[] inputDirections2 = new boolean[inputKeys2.length].     Arrays.fill(inputDirections1, true).     Arrays.fill(inputDirections2, true).     final TypeSerializer<IN1> inputSerializer1 = inputType1.createSerializer(executionConfig).     final TypeSerializer<IN2> inputSerializer2 = inputType2.createSerializer(executionConfig).     final TypeComparator<IN1> inputComparator1 = getTypeComparator(executionConfig, inputType1, inputKeys1, inputDirections1).     final TypeComparator<IN2> inputComparator2 = getTypeComparator(executionConfig, inputType2, inputKeys2, inputDirections2).     final TypeComparator<IN1> inputSortComparator1.     final TypeComparator<IN2> inputSortComparator2.     if (groupOrder1 == null || groupOrder1.getNumberOfFields() == 0) {         // no group sorting         inputSortComparator1 = inputComparator1.     } else {         // group sorting         int[] groupSortKeys = groupOrder1.getFieldPositions().         int[] allSortKeys = new int[inputKeys1.length + groupOrder1.getNumberOfFields()].         System.arraycopy(inputKeys1, 0, allSortKeys, 0, inputKeys1.length).         System.arraycopy(groupSortKeys, 0, allSortKeys, inputKeys1.length, groupSortKeys.length).         boolean[] groupSortDirections = groupOrder1.getFieldSortDirections().         boolean[] allSortDirections = new boolean[inputKeys1.length + groupSortKeys.length].         Arrays.fill(allSortDirections, 0, inputKeys1.length, true).         System.arraycopy(groupSortDirections, 0, allSortDirections, inputKeys1.length, groupSortDirections.length).         inputSortComparator1 = getTypeComparator(executionConfig, inputType1, allSortKeys, allSortDirections).     }     if (groupOrder2 == null || groupOrder2.getNumberOfFields() == 0) {         // no group sorting         inputSortComparator2 = inputComparator2.     } else {         // group sorting         int[] groupSortKeys = groupOrder2.getFieldPositions().         int[] allSortKeys = new int[inputKeys2.length + groupOrder2.getNumberOfFields()].         System.arraycopy(inputKeys2, 0, allSortKeys, 0, inputKeys2.length).         System.arraycopy(groupSortKeys, 0, allSortKeys, inputKeys2.length, groupSortKeys.length).         boolean[] groupSortDirections = groupOrder2.getFieldSortDirections().         boolean[] allSortDirections = new boolean[inputKeys2.length + groupSortKeys.length].         Arrays.fill(allSortDirections, 0, inputKeys2.length, true).         System.arraycopy(groupSortDirections, 0, allSortDirections, inputKeys2.length, groupSortDirections.length).         inputSortComparator2 = getTypeComparator(executionConfig, inputType2, allSortKeys, allSortDirections).     }     CoGroupSortListIterator<IN1, IN2> coGroupIterator = new CoGroupSortListIterator<IN1, IN2>(input1, inputSortComparator1, inputComparator1, inputSerializer1, input2, inputSortComparator2, inputComparator2, inputSerializer2).     // --------------------------------------------------------------------     // Run UDF     // --------------------------------------------------------------------     CoGroupFunction<IN1, IN2, OUT> function = userFunction.getUserCodeObject().     FunctionUtils.setFunctionRuntimeContext(function, ctx).     FunctionUtils.openFunction(function, parameters).     List<OUT> result = new ArrayList<OUT>().     Collector<OUT> resultCollector = new CopyingListCollector<OUT>(result, getOperatorInfo().getOutputType().createSerializer(executionConfig)).     while (coGroupIterator.next()) {         function.coGroup(coGroupIterator.getValues1(), coGroupIterator.getValues2(), resultCollector).     }     FunctionUtils.closeFunction(function).     return result. }
false;private;4;10;;@SuppressWarnings("unchecked") private <T> TypeComparator<T> getTypeComparator(ExecutionConfig executionConfig, TypeInformation<T> inputType, int[] inputKeys, boolean[] inputSortDirections) {     if (inputType instanceof CompositeType) {         return ((CompositeType<T>) inputType).createComparator(inputKeys, inputSortDirections, 0, executionConfig).     } else if (inputType instanceof AtomicType) {         return ((AtomicType<T>) inputType).createComparator(inputSortDirections[0], executionConfig).     }     throw new InvalidProgramException("Input type of coGroup must be one of composite types or atomic types."). }
false;public;2;4;;@Override public int compare(IN1 o1, IN1 o2) {     return inputSortComparator1.compare(o1, o2). }
false;public;2;4;;@Override public int compare(IN2 o1, IN2 o2) {     return inputSortComparator2.compare(o1, o2). }
false;private;0;71;;private boolean next() throws IOException {     boolean firstEmpty = true.     boolean secondEmpty = true.     if (this.matchStatus != MatchStatus.FIRST_EMPTY) {         if (this.matchStatus == MatchStatus.FIRST_REMAINED) {             // comparator is still set correctly             firstEmpty = false.         } else {             if (this.iterator1.nextKey()) {                 this.pairComparator.setReference(iterator1.getValues().getCurrent()).                 firstEmpty = false.             }         }     }     if (this.matchStatus != MatchStatus.SECOND_EMPTY) {         if (this.matchStatus == MatchStatus.SECOND_REMAINED) {             secondEmpty = false.         } else {             if (iterator2.nextKey()) {                 secondEmpty = false.             }         }     }     if (firstEmpty && secondEmpty) {         // both inputs are empty         return false.     } else if (firstEmpty && !secondEmpty) {         // input1 is empty, input2 not         this.firstReturn = Collections.emptySet().         this.secondReturn = this.iterator2.getValues().         this.matchStatus = MatchStatus.FIRST_EMPTY.         return true.     } else if (!firstEmpty && secondEmpty) {         // input1 is not empty, input 2 is empty         this.firstReturn = this.iterator1.getValues().         this.secondReturn = Collections.emptySet().         this.matchStatus = MatchStatus.SECOND_EMPTY.         return true.     } else {         // both inputs are not empty         final int comp = this.pairComparator.compareToReference(iterator2.getValues().getCurrent()).         if (0 == comp) {             // keys match             this.firstReturn = this.iterator1.getValues().             this.secondReturn = this.iterator2.getValues().             this.matchStatus = MatchStatus.NONE_REMAINED.         } else if (0 < comp) {             // key1 goes first             this.firstReturn = this.iterator1.getValues().             this.secondReturn = Collections.emptySet().             this.matchStatus = MatchStatus.SECOND_REMAINED.         } else {             // key 2 goes first             this.firstReturn = Collections.emptySet().             this.secondReturn = this.iterator2.getValues().             this.matchStatus = MatchStatus.FIRST_REMAINED.         }         return true.     } }
false;private;0;3;;private Iterable<IN1> getValues1() {     return firstReturn. }
false;private;0;3;;private Iterable<IN2> getValues2() {     return secondReturn. }
