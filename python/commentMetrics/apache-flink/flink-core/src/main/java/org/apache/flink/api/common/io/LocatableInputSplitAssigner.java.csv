commented;modifiers;parameterAmount;loc;comment;code
false;public;2;129;;// -------------------------------------------------------------------------------------------- @Override public LocatableInputSplit getNextInputSplit(String host, int taskId) {     // for a null host, we return a remote split     if (host == null) {         synchronized (this.remoteSplitChooser) {             synchronized (this.unassigned) {                 LocatableInputSplitWithCount split = this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned).                 if (split != null) {                     // got a split to assign. Double check that it hasn't been assigned before.                     if (this.unassigned.remove(split)) {                         if (LOG.isInfoEnabled()) {                             LOG.info("Assigning split to null host (random assignment).").                         }                         remoteAssignments++.                         return split.getSplit().                     } else {                         throw new IllegalStateException("Chosen InputSplit has already been assigned. This should not happen!").                     }                 } else {                     // all splits consumed                     if (LOG.isDebugEnabled()) {                         LOG.debug("No more unassigned input splits remaining.").                     }                     return null.                 }             }         }     }     host = host.toLowerCase(Locale.US).     // for any non-null host, we take the list of non-null splits     LocatableInputSplitChooser localSplits = this.localPerHost.get(host).     // if we have no list for this host yet, create one     if (localSplits == null) {         localSplits = new LocatableInputSplitChooser().         // lock the list, to be sure that others have to wait for that host's local list         synchronized (localSplits) {             LocatableInputSplitChooser prior = this.localPerHost.putIfAbsent(host, localSplits).             // simply work with that other list             if (prior == null) {                 // we are the first, we populate                 // first, copy the remaining splits to release the lock on the set early                 // because that is shared among threads                 LocatableInputSplitWithCount[] remaining.                 synchronized (this.unassigned) {                     remaining = this.unassigned.toArray(new LocatableInputSplitWithCount[this.unassigned.size()]).                 }                 for (LocatableInputSplitWithCount isw : remaining) {                     if (isLocal(host, isw.getSplit().getHostnames())) {                         // Split is local on host.                         // Increment local count                         isw.incrementLocalCount().                         // and add to local split list                         localSplits.addInputSplit(isw).                     }                 }             } else {                 // someone else was faster                 localSplits = prior.             }         }     }     // NOTE: we need to obtain the locks in this order, strictly!!!     synchronized (localSplits) {         synchronized (this.unassigned) {             LocatableInputSplitWithCount split = localSplits.getNextUnassignedMinLocalCountSplit(this.unassigned).             if (split != null) {                 // found a valid split. Double check that it hasn't been assigned before.                 if (this.unassigned.remove(split)) {                     if (LOG.isInfoEnabled()) {                         LOG.info("Assigning local split to host " + host).                     }                     localAssignments++.                     return split.getSplit().                 } else {                     throw new IllegalStateException("Chosen InputSplit has already been assigned. This should not happen!").                 }             }         }     }     // we did not find a local split, return a remote split     synchronized (this.remoteSplitChooser) {         synchronized (this.unassigned) {             LocatableInputSplitWithCount split = this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned).             if (split != null) {                 // found a valid split. Double check that it hasn't been assigned yet.                 if (this.unassigned.remove(split)) {                     if (LOG.isInfoEnabled()) {                         LOG.info("Assigning remote split to host " + host).                     }                     remoteAssignments++.                     return split.getSplit().                 } else {                     throw new IllegalStateException("Chosen InputSplit has already been assigned. This should not happen!").                 }             } else {                 // all splits consumed                 if (LOG.isDebugEnabled()) {                     LOG.debug("No more input splits remaining.").                 }                 return null.             }         }     } }
false;private,static,final;2;12;;private static final boolean isLocal(String flinkHost, String[] hosts) {     if (flinkHost == null || hosts == null) {         return false.     }     for (String h : hosts) {         if (h != null && NetUtils.getHostnameFromFQDN(h.toLowerCase()).equals(flinkHost)) {             return true.         }     }     return false. }
false;public;0;3;;public int getNumberOfLocalAssignments() {     return localAssignments. }
false;public;0;3;;public int getNumberOfRemoteAssignments() {     return remoteAssignments. }
false;public;0;3;;public void incrementLocalCount() {     this.localCount++. }
false;public;0;3;;public int getLocalCount() {     return this.localCount. }
false;public;0;3;;public LocatableInputSplit getSplit() {     return this.split. }
true;public;1;25;/**  * Adds a single input split  *  * @param split The input split to add  */ ;/**  * Adds a single input split  *  * @param split The input split to add  */ public void addInputSplit(LocatableInputSplitWithCount split) {     int localCount = split.getLocalCount().     if (minLocalCount == -1) {         // first split to add         this.minLocalCount = localCount.         this.elementCycleCount = 1.         this.splits.offerFirst(split).     } else if (localCount < minLocalCount) {         // split with new min local count         this.nextMinLocalCount = this.minLocalCount.         this.minLocalCount = localCount.         // all other splits have more local host than this one         this.elementCycleCount = 1.         splits.offerFirst(split).     } else if (localCount == minLocalCount) {         this.elementCycleCount++.         this.splits.offerFirst(split).     } else {         if (localCount < nextMinLocalCount) {             nextMinLocalCount = localCount.         }         splits.offerLast(split).     } }
true;public;1;42;/**  * Retrieves a LocatableInputSplit with minimum local count.  * InputSplits which have already been assigned (i.e., which are not contained in the provided set) are filtered out.  * The returned input split is NOT removed from the provided set.  *  * @param unassignedSplits Set of unassigned input splits.  * @return An input split with minimum local count or null if all splits have been assigned.  */ ;/**  * Retrieves a LocatableInputSplit with minimum local count.  * InputSplits which have already been assigned (i.e., which are not contained in the provided set) are filtered out.  * The returned input split is NOT removed from the provided set.  *  * @param unassignedSplits Set of unassigned input splits.  * @return An input split with minimum local count or null if all splits have been assigned.  */ public LocatableInputSplitWithCount getNextUnassignedMinLocalCountSplit(Set<LocatableInputSplitWithCount> unassignedSplits) {     if (splits.size() == 0) {         return null.     }     do {         elementCycleCount--.         // take first split of the list         LocatableInputSplitWithCount split = splits.pollFirst().         if (unassignedSplits.contains(split)) {             int localCount = split.getLocalCount().             // still unassigned, check local count             if (localCount > minLocalCount) {                 // re-insert at end of the list and continue to look for split with smaller local count                 splits.offerLast(split).                 // check and update second smallest local count                 if (nextMinLocalCount == -1 || split.getLocalCount() < nextMinLocalCount) {                     nextMinLocalCount = split.getLocalCount().                 }                 split = null.             }         } else {             // split was already assigned             split = null.         }         if (elementCycleCount == 0) {             // one full cycle, but no split with min local count found             // update minLocalCnt and element cycle count for next pass over the splits             minLocalCount = nextMinLocalCount.             nextMinLocalCount = -1.             elementCycleCount = splits.size().         }         if (split != null) {             // found a split to assign             return split.         }     } while (elementCycleCount > 0).     // no split left     return null. }
