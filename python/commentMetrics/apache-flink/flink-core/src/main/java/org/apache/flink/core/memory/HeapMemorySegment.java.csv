commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;// ------------------------------------------------------------------------- // MemorySegment operations // ------------------------------------------------------------------------- @Override public void free() {     super.free().     this.memory = null. }
false;public;2;9;;@Override public ByteBuffer wrap(int offset, int length) {     try {         return ByteBuffer.wrap(this.memory, offset, length).     } catch (NullPointerException e) {         throw new IllegalStateException("segment has been freed").     } }
true;public;0;3;/**  * Gets the byte array that backs this memory segment.  *  * @return The byte array that backs this memory segment, or null, if the segment has been freed.  */ ;/**  * Gets the byte array that backs this memory segment.  *  * @return The byte array that backs this memory segment, or null, if the segment has been freed.  */ public byte[] getArray() {     return this.heapMemory. }
false;public,final;1;4;;// ------------------------------------------------------------------------ // Random Access get() and put() methods // ------------------------------------------------------------------------ @Override public final byte get(int index) {     return this.memory[index]. }
false;public,final;2;4;;@Override public final void put(int index, byte b) {     this.memory[index] = b. }
false;public,final;2;4;;@Override public final void get(int index, byte[] dst) {     get(index, dst, 0, dst.length). }
false;public,final;2;4;;@Override public final void put(int index, byte[] src) {     put(index, src, 0, src.length). }
false;public,final;4;5;;@Override public final void get(int index, byte[] dst, int offset, int length) {     // system arraycopy does the boundary checks anyways, no need to check extra     System.arraycopy(this.memory, index, dst, offset, length). }
false;public,final;4;5;;@Override public final void put(int index, byte[] src, int offset, int length) {     // system arraycopy does the boundary checks anyways, no need to check extra     System.arraycopy(src, offset, this.memory, index, length). }
false;public,final;1;4;;@Override public final boolean getBoolean(int index) {     return this.memory[index] != 0. }
false;public,final;2;4;;@Override public final void putBoolean(int index, boolean value) {     this.memory[index] = (byte) (value ? 1 : 0). }
false;public,final;3;4;;// ------------------------------------------------------------------------- // Bulk Read and Write Methods // ------------------------------------------------------------------------- @Override public final void get(DataOutput out, int offset, int length) throws IOException {     out.write(this.memory, offset, length). }
false;public,final;3;4;;@Override public final void put(DataInput in, int offset, int length) throws IOException {     in.readFully(this.memory, offset, length). }
false;public,final;3;5;;@Override public final void get(int offset, ByteBuffer target, int numBytes) {     // ByteBuffer performs the boundary checks     target.put(this.memory, offset, numBytes). }
false;public,final;3;5;;@Override public final void put(int offset, ByteBuffer source, int numBytes) {     // ByteBuffer performs the boundary checks     source.get(this.memory, offset, numBytes). }
true;public;1;3;/**  * Creates a new memory segment that targets the given heap memory region.  *  * @param memory The heap memory region.  * @return A new memory segment that targets the given heap memory region.  */ ;/**  * Creates a new memory segment that targets the given heap memory region.  *  * @param memory The heap memory region.  * @return A new memory segment that targets the given heap memory region.  */ public HeapMemorySegment wrap(byte[] memory) {     return new HeapMemorySegment(memory). }
true;public;2;3;/**  * Allocates some unpooled memory and creates a new memory segment that represents  * that memory.  *  * @param size The size of the memory segment to allocate.  * @param owner The owner to associate with the memory segment.  * @return A new memory segment, backed by unpooled heap memory.  */ ;/**  * Allocates some unpooled memory and creates a new memory segment that represents  * that memory.  *  * @param size The size of the memory segment to allocate.  * @param owner The owner to associate with the memory segment.  * @return A new memory segment, backed by unpooled heap memory.  */ public HeapMemorySegment allocateUnpooledSegment(int size, Object owner) {     return new HeapMemorySegment(new byte[size], owner). }
true;public;2;3;/**  * Creates a memory segment that wraps the given byte array.  *  * <p>This method is intended to be used for components which pool memory and create  * memory segments around long-lived memory regions.  *  * @param memory The heap memory to be represented by the memory segment.  * @param owner The owner to associate with the memory segment.  * @return A new memory segment representing the given heap memory.  */ ;/**  * Creates a memory segment that wraps the given byte array.  *  * <p>This method is intended to be used for components which pool memory and create  * memory segments around long-lived memory regions.  *  * @param memory The heap memory to be represented by the memory segment.  * @param owner The owner to associate with the memory segment.  * @return A new memory segment representing the given heap memory.  */ public HeapMemorySegment wrapPooledHeapMemory(byte[] memory, Object owner) {     return new HeapMemorySegment(memory, owner). }
