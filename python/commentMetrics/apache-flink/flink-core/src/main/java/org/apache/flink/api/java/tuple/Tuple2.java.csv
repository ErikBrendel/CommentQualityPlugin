commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int getArity() {     return 2. }
false;public;1;9;;@Override @SuppressWarnings("unchecked") public <T> T getField(int pos) {     switch(pos) {         case 0:             return (T) this.f0.         case 1:             return (T) this.f1.         default:             throw new IndexOutOfBoundsException(String.valueOf(pos)).     } }
false;public;2;13;;@Override @SuppressWarnings("unchecked") public <T> void setField(T value, int pos) {     switch(pos) {         case 0:             this.f0 = (T0) value.             break.         case 1:             this.f1 = (T1) value.             break.         default:             throw new IndexOutOfBoundsException(String.valueOf(pos)).     } }
true;public;2;4;/**  * Sets new values to all fields of the tuple.  *  * @param value0 The value for field 0  * @param value1 The value for field 1  */ ;/**  * Sets new values to all fields of the tuple.  *  * @param value0 The value for field 0  * @param value1 The value for field 1  */ public void setFields(T0 value0, T1 value1) {     this.f0 = value0.     this.f1 = value1. }
true;public;0;3;/**  * Returns a shallow copy of the tuple with swapped values.  *  * @return shallow copy of the tuple with swapped values  */ ;/**  * Returns a shallow copy of the tuple with swapped values.  *  * @return shallow copy of the tuple with swapped values  */ public Tuple2<T1, T0> swap() {     return new Tuple2<T1, T0>(f1, f0). }
true;public;0;6;/**  * Creates a string representation of the tuple in the form  * (f0, f1),  * where the individual fields are the value returned by calling {@link Object#toString} on that field.  * @return The string representation of the tuple.  */ ;// ------------------------------------------------------------------------------------------------- // standard utilities // ------------------------------------------------------------------------------------------------- /**  * Creates a string representation of the tuple in the form  * (f0, f1),  * where the individual fields are the value returned by calling {@link Object#toString} on that field.  * @return The string representation of the tuple.  */ @Override public String toString() {     return "(" + StringUtils.arrayAwareToString(this.f0) + "," + StringUtils.arrayAwareToString(this.f1) + ")". }
true;public;1;18;/**  * Deep equality for tuples by calling equals() on the tuple members.  * @param o the object checked for equality  * @return true if this is equal to o.  */ ;/**  * Deep equality for tuples by calling equals() on the tuple members.  * @param o the object checked for equality  * @return true if this is equal to o.  */ @Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (!(o instanceof Tuple2)) {         return false.     }     @SuppressWarnings("rawtypes")     Tuple2 tuple = (Tuple2) o.     if (f0 != null ? !f0.equals(tuple.f0) : tuple.f0 != null) {         return false.     }     if (f1 != null ? !f1.equals(tuple.f1) : tuple.f1 != null) {         return false.     }     return true. }
false;public;0;6;;@Override public int hashCode() {     int result = f0 != null ? f0.hashCode() : 0.     result = 31 * result + (f1 != null ? f1.hashCode() : 0).     return result. }
true;public;0;6;/**  * Shallow tuple copy.  * @return A new Tuple with the same fields as this.  */ ;/**  * Shallow tuple copy.  * @return A new Tuple with the same fields as this.  */ @Override @SuppressWarnings("unchecked") public Tuple2<T0, T1> copy() {     return new Tuple2<>(this.f0, this.f1). }
true;public,static;2;4;/**  * Creates a new tuple and assigns the given values to the tuple's fields.  * This is more convenient than using the constructor, because the compiler can  * infer the generic type arguments implicitly. For example:  * {@code Tuple3.of(n, x, s)}  * instead of  * {@code new Tuple3<Integer, Double, String>(n, x, s)}  */ ;/**  * Creates a new tuple and assigns the given values to the tuple's fields.  * This is more convenient than using the constructor, because the compiler can  * infer the generic type arguments implicitly. For example:  * {@code Tuple3.of(n, x, s)}  * instead of  * {@code new Tuple3<Integer, Double, String>(n, x, s)}  */ public static <T0, T1> Tuple2<T0, T1> of(T0 value0, T1 value1) {     return new Tuple2<>(value0, value1). }
