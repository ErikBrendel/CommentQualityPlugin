commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the maximum number of concurrently open output streams.  */ ;// ------------------------------------------------------------------------ /**  * Gets the maximum number of concurrently open output streams.  */ public int getMaxNumOpenOutputStreams() {     return maxNumOpenOutputStreams. }
true;public;0;3;/**  * Gets the maximum number of concurrently open input streams.  */ ;/**  * Gets the maximum number of concurrently open input streams.  */ public int getMaxNumOpenInputStreams() {     return maxNumOpenInputStreams. }
true;public;0;3;/**  * Gets the maximum number of concurrently open streams (input + output).  */ ;/**  * Gets the maximum number of concurrently open streams (input + output).  */ public int getMaxNumOpenStreamsTotal() {     return maxNumOpenStreamsTotal. }
true;public;0;3;/**  * Gets the number of milliseconds that a opening a stream may wait for availability in the  * connection pool.  */ ;/**  * Gets the number of milliseconds that a opening a stream may wait for availability in the  * connection pool.  */ public long getStreamOpenTimeout() {     return streamOpenTimeoutNanos / 1_000_000. }
true;public;0;3;/**  * Gets the milliseconds that a stream may spend not writing any bytes before it is closed as inactive.  */ ;/**  * Gets the milliseconds that a stream may spend not writing any bytes before it is closed as inactive.  */ public long getStreamInactivityTimeout() {     return streamInactivityTimeoutNanos / 1_000_000. }
true;public;0;8;/**  * Gets the total number of open streams (input plus output).  */ ;/**  * Gets the total number of open streams (input plus output).  */ public int getTotalNumberOfOpenStreams() {     lock.lock().     try {         return numReservedOutputStreams + numReservedInputStreams.     } finally {         lock.unlock().     } }
true;public;0;9;/**  * Gets the number of currently open output streams.  */ ;/**  * Gets the number of currently open output streams.  */ public int getNumberOfOpenOutputStreams() {     lock.lock().     try {         return numReservedOutputStreams.     } finally {         lock.unlock().     } }
true;public;0;3;/**  * Gets the number of currently open input streams.  */ ;/**  * Gets the number of currently open input streams.  */ public int getNumberOfOpenInputStreams() {     return numReservedInputStreams. }
false;public;2;4;;// ------------------------------------------------------------------------ // input & output stream opening methods // ------------------------------------------------------------------------ @Override public FSDataOutputStream create(Path f, WriteMode overwriteMode) throws IOException {     return createOutputStream(() -> originalFs.create(f, overwriteMode)). }
false;public;5;12;;@Override @Deprecated @SuppressWarnings("deprecation") public FSDataOutputStream create(Path f, boolean overwrite, int bufferSize, short replication, long blockSize) throws IOException {     return createOutputStream(() -> originalFs.create(f, overwrite, bufferSize, replication, blockSize)). }
false;public;2;4;;@Override public FSDataInputStream open(Path f, int bufferSize) throws IOException {     return createInputStream(() -> originalFs.open(f, bufferSize)). }
false;public;1;4;;@Override public FSDataInputStream open(Path f) throws IOException {     return createInputStream(() -> originalFs.open(f)). }
false;private;1;8;;private FSDataOutputStream createOutputStream(final SupplierWithException<FSDataOutputStream, IOException> streamOpener) throws IOException {     final SupplierWithException<OutStream, IOException> wrappedStreamOpener = () -> new OutStream(streamOpener.get(), this).     return createStream(wrappedStreamOpener, openOutputStreams, true). }
false;private;1;8;;private FSDataInputStream createInputStream(final SupplierWithException<FSDataInputStream, IOException> streamOpener) throws IOException {     final SupplierWithException<InStream, IOException> wrappedStreamOpener = () -> new InStream(streamOpener.get(), this).     return createStream(wrappedStreamOpener, openInputStreams, false). }
false;public;0;4;;// ------------------------------------------------------------------------ // other delegating file system methods // ------------------------------------------------------------------------ @Override public FileSystemKind getKind() {     return originalFs.getKind(). }
false;public;0;4;;@Override public boolean isDistributedFS() {     return originalFs.isDistributedFS(). }
false;public;0;4;;@Override public Path getWorkingDirectory() {     return originalFs.getWorkingDirectory(). }
false;public;0;4;;@Override public Path getHomeDirectory() {     return originalFs.getHomeDirectory(). }
false;public;0;4;;@Override public URI getUri() {     return originalFs.getUri(). }
false;public;1;4;;@Override public FileStatus getFileStatus(Path f) throws IOException {     return originalFs.getFileStatus(f). }
false;public;3;4;;@Override public BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException {     return originalFs.getFileBlockLocations(file, start, len). }
false;public;1;4;;@Override public FileStatus[] listStatus(Path f) throws IOException {     return originalFs.listStatus(f). }
false;public;2;4;;@Override public boolean delete(Path f, boolean recursive) throws IOException {     return originalFs.delete(f, recursive). }
false;public;1;4;;@Override public boolean mkdirs(Path f) throws IOException {     return originalFs.mkdirs(f). }
false;public;2;4;;@Override public boolean rename(Path src, Path dst) throws IOException {     return originalFs.rename(src, dst). }
false;public;1;4;;@Override public boolean exists(Path f) throws IOException {     return originalFs.exists(f). }
false;public;0;6;;@Override @Deprecated @SuppressWarnings("deprecation") public long getDefaultBlockSize() {     return originalFs.getDefaultBlockSize(). }
false;private;3;74;;// ------------------------------------------------------------------------ private <T extends StreamWithTimeout> T createStream(final SupplierWithException<T, IOException> streamOpener, final HashSet<T> openStreams, final boolean output) throws IOException {     final int outputLimit = output && maxNumOpenOutputStreams > 0 ? maxNumOpenOutputStreams : Integer.MAX_VALUE.     final int inputLimit = !output && maxNumOpenInputStreams > 0 ? maxNumOpenInputStreams : Integer.MAX_VALUE.     final int totalLimit = maxNumOpenStreamsTotal > 0 ? maxNumOpenStreamsTotal : Integer.MAX_VALUE.     final int outputCredit = output ? 1 : 0.     final int inputCredit = output ? 0 : 1.     // a supposedly fast operation (like 'getPos()' on a stream) actually takes long.     try {         lock.lockInterruptibly().         try {             // some integrity checks             assert openOutputStreams.size() <= numReservedOutputStreams.             assert openInputStreams.size() <= numReservedInputStreams.             // wait until there are few enough streams so we can open another             waitForAvailability(totalLimit, outputLimit, inputLimit).             // We do not open the stream here in the locked scope because opening a stream             // could take a while. Holding the lock during that operation would block all concurrent             // attempts to try and open a stream, effectively serializing all calls to open the streams.             numReservedOutputStreams += outputCredit.             numReservedInputStreams += inputCredit.         } finally {             lock.unlock().         }     } catch (InterruptedException e) {         // restore interruption flag         Thread.currentThread().interrupt().         throw new IOException("interrupted before opening stream").     }     // open the stream outside the lock.     boolean success = false.     try {         final T out = streamOpener.get().         // add the stream to the set, need to re-acquire the lock         lock.lock().         try {             openStreams.add(out).         } finally {             lock.unlock().         }         // good, can now return cleanly         success = true.         return out.     } finally {         if (!success) {             // remove the reserved credit             // we must open this non-interruptibly, because this must succeed!             lock.lock().             try {                 numReservedOutputStreams -= outputCredit.                 numReservedInputStreams -= inputCredit.                 available.signalAll().             } finally {                 lock.unlock().             }         }     } }
false;private;3;58;;@GuardedBy("lock") private void waitForAvailability(int totalLimit, int outputLimit, int inputLimit) throws InterruptedException, IOException {     checkState(lock.isHeldByCurrentThread()).     // compute the deadline of this operations     final long deadline.     if (streamOpenTimeoutNanos == 0) {         deadline = Long.MAX_VALUE.     } else {         long deadlineNanos = System.nanoTime() + streamOpenTimeoutNanos.         // check for overflow         deadline = deadlineNanos > 0 ? deadlineNanos : Long.MAX_VALUE.     }     // wait for available connections     long timeLeft.     if (streamInactivityTimeoutNanos == 0) {         // simple case: just wait         while ((timeLeft = (deadline - System.nanoTime())) > 0 && !hasAvailability(totalLimit, outputLimit, inputLimit)) {             available.await(timeLeft, TimeUnit.NANOSECONDS).         }     } else {         // complex case: chase down inactive streams         final long checkIntervalNanos = (streamInactivityTimeoutNanos >>> 1) + 1.         long now.         while (// while still within timeout         (timeLeft = (deadline - (now = System.nanoTime()))) > 0 && !hasAvailability(totalLimit, outputLimit, inputLimit)) {             // check all streams whether there in one that has been inactive for too long             if (!(closeInactiveStream(openOutputStreams, now) || closeInactiveStream(openInputStreams, now))) {                 // only wait if we did not manage to close any stream.                 // otherwise eagerly check again if we have availability now (we should have!)                 long timeToWait = Math.min(checkIntervalNanos, timeLeft).                 available.await(timeToWait, TimeUnit.NANOSECONDS).             }         }     }     // to re-acquire the lock     if (timeLeft <= 0 && !hasAvailability(totalLimit, outputLimit, inputLimit)) {         throw new IOException(String.format("Timeout while waiting for an available stream/connection. " + "limits: total=%d, input=%d, output=%d . Open: input=%d, output=%d . timeout: %d ms", maxNumOpenStreamsTotal, maxNumOpenInputStreams, maxNumOpenOutputStreams, numReservedInputStreams, numReservedOutputStreams, getStreamOpenTimeout())).     } }
false;private;3;6;;@GuardedBy("lock") private boolean hasAvailability(int totalLimit, int outputLimit, int inputLimit) {     return numReservedOutputStreams < outputLimit && numReservedInputStreams < inputLimit && numReservedOutputStreams + numReservedInputStreams < totalLimit. }
false;private;2;28;;@GuardedBy("lock") private boolean closeInactiveStream(HashSet<? extends StreamWithTimeout> streams, long nowNanos) {     for (StreamWithTimeout stream : streams) {         try {             final StreamProgressTracker tracker = stream.getProgressTracker().             // do not classify it as inactive. We also skip the check if another check happened too recently.             if (stream.isClosed() || nowNanos < tracker.getLastCheckTimestampNanos() + streamInactivityTimeoutNanos) {                 // interval since last check not yet over                 return false.             } else if (!tracker.checkNewBytesAndMark(nowNanos)) {                 stream.closeDueToTimeout().                 return true.             }         } catch (StreamTimeoutException ignored) {         // may happen due to races         } catch (IOException e) {             // only log on debug level here, to avoid log spamming             LOG.debug("Could not check for stream progress to determine inactivity", e).         }     }     return false. }
true;;1;13;/**  * Atomically removes the given output stream from the set of currently open output streams,  * and signals that new stream can now be opened.  */ ;// ------------------------------------------------------------------------ /**  * Atomically removes the given output stream from the set of currently open output streams,  * and signals that new stream can now be opened.  */ void unregisterOutputStream(OutStream stream) {     lock.lock().     try {         // only decrement if we actually remove the stream         if (openOutputStreams.remove(stream)) {             numReservedOutputStreams--.             available.signalAll().         }     } finally {         lock.unlock().     } }
true;;1;13;/**  * Atomically removes the given input stream from the set of currently open input streams,  * and signals that new stream can now be opened.  */ ;/**  * Atomically removes the given input stream from the set of currently open input streams,  * and signals that new stream can now be opened.  */ void unregisterInputStream(InStream stream) {     lock.lock().     try {         // only decrement if we actually remove the stream         if (openInputStreams.remove(stream)) {             numReservedInputStreams--.             available.signalAll().         }     } finally {         lock.unlock().     } }
true;;0;1;/**  * Gets the progress tracker for this stream.  */ ;/**  * Gets the progress tracker for this stream.  */ StreamProgressTracker getProgressTracker().
true;;0;1;/**  * Gets the current position in the stream, as in number of bytes read or written.  */ ;/**  * Gets the current position in the stream, as in number of bytes read or written.  */ long getPos() throws IOException.
true;;0;1;/**  * Closes the stream asynchronously with a special exception that indicates closing due  * to lack of progress.  */ ;/**  * Closes the stream asynchronously with a special exception that indicates closing due  * to lack of progress.  */ void closeDueToTimeout() throws IOException.
true;;0;1;/**  * Checks whether the stream was closed already.  */ ;/**  * Checks whether the stream was closed already.  */ boolean isClosed().
true;public;0;3;/**  * Gets the timestamp when the last inactivity evaluation was made.  */ ;/**  * Gets the timestamp when the last inactivity evaluation was made.  */ public long getLastCheckTimestampNanos() {     return lastCheckTimestampNanos. }
true;public;1;13;/**  * Checks whether there were new bytes since the last time this method was invoked.  * This also sets the given timestamp, to be read via {@link #getLastCheckTimestampNanos()}.  *  * @return True, if there were new bytes, false if not.  */ ;/**  * Checks whether there were new bytes since the last time this method was invoked.  * This also sets the given timestamp, to be read via {@link #getLastCheckTimestampNanos()}.  *  * @return True, if there were new bytes, false if not.  */ public boolean checkNewBytesAndMark(long timestamp) throws IOException {     // remember the time when checked     lastCheckTimestampNanos = timestamp.     final long bytesNow = stream.getPos().     if (bytesNow > lastCheckBytes) {         lastCheckBytes = bytesNow.         return true.     } else {         return false.     } }
false;public;1;9;;// --- FSDataOutputStream API implementation @Override public void write(int b) throws IOException {     try {         originalStream.write(b).     } catch (IOException e) {         handleIOException(e).     } }
false;public;3;9;;@Override public void write(byte[] b, int off, int len) throws IOException {     try {         originalStream.write(b, off, len).     } catch (IOException e) {         handleIOException(e).     } }
false;public;0;10;;@Override public long getPos() throws IOException {     try {         return originalStream.getPos().     } catch (IOException e) {         handleIOException(e).         // silence the compiler         return -1.     } }
false;public;0;9;;@Override public void flush() throws IOException {     try {         originalStream.flush().     } catch (IOException e) {         handleIOException(e).     } }
false;public;0;9;;@Override public void sync() throws IOException {     try {         originalStream.sync().     } catch (IOException e) {         handleIOException(e).     } }
false;public;0;14;;@Override public void close() throws IOException {     if (closed.compareAndSet(false, true)) {         try {             originalStream.close().         } catch (IOException e) {             handleIOException(e).         } finally {             fs.unregisterOutputStream(this).         }     } }
false;public;0;5;;@Override public void closeDueToTimeout() throws IOException {     this.timeoutException = new StreamTimeoutException().     close(). }
false;public;0;4;;@Override public boolean isClosed() {     return closed.get(). }
false;public;0;4;;@Override public StreamProgressTracker getProgressTracker() {     return progressTracker. }
false;private;1;11;;private void handleIOException(IOException exception) throws IOException {     if (timeoutException == null) {         throw exception.     } else {         // throw a new exception to capture this call's stack trace         // the new exception is forwarded as a suppressed exception         StreamTimeoutException te = new StreamTimeoutException(timeoutException).         te.addSuppressed(exception).         throw te.     } }
false;public;0;10;;// --- FSDataOutputStream API implementation @Override public int read() throws IOException {     try {         return originalStream.read().     } catch (IOException e) {         handleIOException(e).         // silence the compiler         return 0.     } }
false;public;1;10;;@Override public int read(byte[] b) throws IOException {     try {         return originalStream.read(b).     } catch (IOException e) {         handleIOException(e).         // silence the compiler         return 0.     } }
false;public;3;10;;@Override public int read(byte[] b, int off, int len) throws IOException {     try {         return originalStream.read(b, off, len).     } catch (IOException e) {         handleIOException(e).         // silence the compiler         return 0.     } }
false;public;1;10;;@Override public long skip(long n) throws IOException {     try {         return originalStream.skip(n).     } catch (IOException e) {         handleIOException(e).         // silence the compiler         return 0L.     } }
false;public;0;10;;@Override public int available() throws IOException {     try {         return originalStream.available().     } catch (IOException e) {         handleIOException(e).         // silence the compiler         return 0.     } }
false;public;1;4;;@Override public void mark(int readlimit) {     originalStream.mark(readlimit). }
false;public;0;9;;@Override public void reset() throws IOException {     try {         originalStream.reset().     } catch (IOException e) {         handleIOException(e).     } }
false;public;0;4;;@Override public boolean markSupported() {     return originalStream.markSupported(). }
false;public;1;9;;@Override public void seek(long desired) throws IOException {     try {         originalStream.seek(desired).     } catch (IOException e) {         handleIOException(e).     } }
false;public;0;10;;@Override public long getPos() throws IOException {     try {         return originalStream.getPos().     } catch (IOException e) {         handleIOException(e).         // silence the compiler         return 0.     } }
false;public;0;14;;@Override public void close() throws IOException {     if (closed.compareAndSet(false, true)) {         try {             originalStream.close().         } catch (IOException e) {             handleIOException(e).         } finally {             fs.unregisterInputStream(this).         }     } }
false;public;0;5;;@Override public void closeDueToTimeout() throws IOException {     this.timeoutException = new StreamTimeoutException().     close(). }
false;public;0;4;;@Override public boolean isClosed() {     return closed.get(). }
false;public;0;4;;@Override public StreamProgressTracker getProgressTracker() {     return progressTracker. }
false;private;1;11;;private void handleIOException(IOException exception) throws IOException {     if (timeoutException == null) {         throw exception.     } else {         // throw a new exception to capture this call's stack trace         // the new exception is forwarded as a suppressed exception         StreamTimeoutException te = new StreamTimeoutException(timeoutException).         te.addSuppressed(exception).         throw te.     } }
true;public,static;2;42;/**  * Parses and returns the settings for connection limiting, for the file system with  * the given file system scheme.  *  * @param config The configuration to check.  * @param fsScheme The file system scheme.  *  * @return The parsed configuration, or null, if no connection limiting is configured.  */ ;// -------------------------------------------------------------------- /**  * Parses and returns the settings for connection limiting, for the file system with  * the given file system scheme.  *  * @param config The configuration to check.  * @param fsScheme The file system scheme.  *  * @return The parsed configuration, or null, if no connection limiting is configured.  */ @Nullable public static ConnectionLimitingSettings fromConfig(Configuration config, String fsScheme) {     checkNotNull(fsScheme, "fsScheme").     checkNotNull(config, "config").     final ConfigOption<Integer> totalLimitOption = CoreOptions.fileSystemConnectionLimit(fsScheme).     final ConfigOption<Integer> limitInOption = CoreOptions.fileSystemConnectionLimitIn(fsScheme).     final ConfigOption<Integer> limitOutOption = CoreOptions.fileSystemConnectionLimitOut(fsScheme).     final int totalLimit = config.getInteger(totalLimitOption).     final int limitIn = config.getInteger(limitInOption).     final int limitOut = config.getInteger(limitOutOption).     checkLimit(totalLimit, totalLimitOption).     checkLimit(limitIn, limitInOption).     checkLimit(limitOut, limitOutOption).     // create the settings only, if at least one limit is configured     if (totalLimit <= 0 && limitIn <= 0 && limitOut <= 0) {         // no limit configured         return null.     } else {         final ConfigOption<Long> openTimeoutOption = CoreOptions.fileSystemConnectionLimitTimeout(fsScheme).         final ConfigOption<Long> inactivityTimeoutOption = CoreOptions.fileSystemConnectionLimitStreamInactivityTimeout(fsScheme).         final long openTimeout = config.getLong(openTimeoutOption).         final long inactivityTimeout = config.getLong(inactivityTimeoutOption).         checkTimeout(openTimeout, openTimeoutOption).         checkTimeout(inactivityTimeout, inactivityTimeoutOption).         return new ConnectionLimitingSettings(totalLimit == -1 ? 0 : totalLimit, limitIn == -1 ? 0 : limitIn, limitOut == -1 ? 0 : limitOut, openTimeout, inactivityTimeout).     } }
false;private,static;2;5;;private static void checkLimit(int value, ConfigOption<Integer> option) {     if (value < -1) {         throw new IllegalConfigurationException("Invalid value for '" + option.key() + "': " + value).     } }
false;private,static;2;5;;private static void checkTimeout(long timeout, ConfigOption<Long> option) {     if (timeout < 0) {         throw new IllegalConfigurationException("Invalid value for '" + option.key() + "': " + timeout).     } }
