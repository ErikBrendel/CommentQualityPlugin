commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int getCurrentVersion() {     return VERSION. }
false;public;1;4;;@Override public void writeSnapshot(DataOutputView out) throws IOException {     snapshotData.writeSnapshotData(out). }
false;public;3;5;;@Override public void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     checkArgument(readVersion == 2, "unrecognized read version %d", readVersion).     snapshotData = PojoSerializerSnapshotData.createFrom(in, userCodeClassLoader). }
false;public;0;30;;@Override @SuppressWarnings("unchecked") public TypeSerializer<T> restoreSerializer() {     final int numFields = snapshotData.getFieldSerializerSnapshots().size().     final ArrayList<Field> restoredFields = new ArrayList<>(numFields).     final ArrayList<TypeSerializer<?>> restoredFieldSerializers = new ArrayList<>(numFields).     snapshotData.getFieldSerializerSnapshots().forEach((fieldName, field, fieldSerializerSnapshot) -> {         restoredFields.add(field).         checkState(fieldSerializerSnapshot != null, "field serializer snapshots should be present.").         restoredFieldSerializers.add(fieldSerializerSnapshot.restoreSerializer()).     }).     final LinkedHashMap<Class<?>, TypeSerializer<?>> registeredSubclassSerializers = restoreSerializers(snapshotData.getRegisteredSubclassSerializerSnapshots().unwrapOptionals()).     final Tuple2<LinkedHashMap<Class<?>, Integer>, TypeSerializer<Object>[]> decomposedSubclassSerializerRegistry = decomposeSubclassSerializerRegistry(registeredSubclassSerializers).     final LinkedHashMap<Class<?>, TypeSerializer<?>> nonRegisteredSubclassSerializers = restoreSerializers(snapshotData.getNonRegisteredSubclassSerializerSnapshots().unwrapOptionals()).     return new PojoSerializer<>(snapshotData.getPojoClass(), restoredFields.toArray(new Field[numFields]), restoredFieldSerializers.toArray(new TypeSerializer[numFields]), decomposedSubclassSerializerRegistry.f0, decomposedSubclassSerializerRegistry.f1, nonRegisteredSubclassSerializers, new ExecutionConfig()). }
false;public;1;66;;@Override public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializer<T> newSerializer) {     if (newSerializer.getClass() != PojoSerializer.class) {         return TypeSerializerSchemaCompatibility.incompatible().     }     final PojoSerializer<T> newPojoSerializer = (PojoSerializer<T>) newSerializer.     final Class<T> previousPojoClass = snapshotData.getPojoClass().     final LinkedOptionalMap<Field, TypeSerializerSnapshot<?>> fieldSerializerSnapshots = snapshotData.getFieldSerializerSnapshots().     final LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>> registeredSubclassSerializerSnapshots = snapshotData.getRegisteredSubclassSerializerSnapshots().     final LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>> nonRegisteredSubclassSerializerSnapshots = snapshotData.getNonRegisteredSubclassSerializerSnapshots().     if (previousPojoClass != newPojoSerializer.getPojoClass()) {         return TypeSerializerSchemaCompatibility.incompatible().     }     if (registeredSubclassSerializerSnapshots.hasAbsentKeysOrValues()) {         return TypeSerializerSchemaCompatibility.incompatible().     }     if (nonRegisteredSubclassSerializerSnapshots.hasAbsentKeysOrValues()) {         return TypeSerializerSchemaCompatibility.incompatible().     }     final IntermediateCompatibilityResult<T> preExistingFieldSerializersCompatibility = getCompatibilityOfPreExistingFields(newPojoSerializer, fieldSerializerSnapshots).     if (preExistingFieldSerializersCompatibility.isIncompatible()) {         return TypeSerializerSchemaCompatibility.incompatible().     }     final IntermediateCompatibilityResult<T> preExistingRegistrationsCompatibility = getCompatibilityOfPreExistingRegisteredSubclasses(newPojoSerializer, registeredSubclassSerializerSnapshots).     if (preExistingRegistrationsCompatibility.isIncompatible()) {         return TypeSerializerSchemaCompatibility.incompatible().     }     if (newPojoSerializerIsCompatibleAfterMigration(newPojoSerializer, preExistingFieldSerializersCompatibility, preExistingRegistrationsCompatibility, fieldSerializerSnapshots)) {         return TypeSerializerSchemaCompatibility.compatibleAfterMigration().     }     if (newPojoSerializerIsCompatibleWithReconfiguredSerializer(newPojoSerializer, preExistingFieldSerializersCompatibility, preExistingRegistrationsCompatibility, registeredSubclassSerializerSnapshots, nonRegisteredSubclassSerializerSnapshots)) {         return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(constructReconfiguredPojoSerializer(newPojoSerializer, preExistingFieldSerializersCompatibility, registeredSubclassSerializerSnapshots, preExistingRegistrationsCompatibility, nonRegisteredSubclassSerializerSnapshots)).     }     return TypeSerializerSchemaCompatibility.compatibleAsIs(). }
true;private,static;1;5;/**  * Transforms a {@link LinkedHashMap} with {@link TypeSerializerSnapshot}s as  * the value to {@link TypeSerializer} as the value by restoring the snapshot.  */ ;// --------------------------------------------------------------------------------------------- // Utility methods // --------------------------------------------------------------------------------------------- /**  * Transforms a {@link LinkedHashMap} with {@link TypeSerializerSnapshot}s as  * the value to {@link TypeSerializer} as the value by restoring the snapshot.  */ private static <K> LinkedHashMap<K, TypeSerializer<?>> restoreSerializers(LinkedHashMap<K, TypeSerializerSnapshot<?>> snapshotsMap) {     final LinkedHashMap<K, TypeSerializer<?>> restoredSerializersMap = new LinkedHashMap<>(snapshotsMap.size()).     snapshotsMap.forEach((key, snapshot) -> restoredSerializersMap.put(key, snapshot.restoreSerializer())).     return restoredSerializersMap. }
true;private,static;1;15;/**  * Transforms the subclass serializer registry structure, {@code LinkedHashMap<Class<?>, TypeSerializer<?>>}  * to 2 separate structures: a map containing with registered classes as key and their corresponding ids (order  * in the original map) as value, as well as a separate array of the corresponding subclass serializers.  */ ;/**  * Transforms the subclass serializer registry structure, {@code LinkedHashMap<Class<?>, TypeSerializer<?>>}  * to 2 separate structures: a map containing with registered classes as key and their corresponding ids (order  * in the original map) as value, as well as a separate array of the corresponding subclass serializers.  */ @SuppressWarnings("unchecked") private static Tuple2<LinkedHashMap<Class<?>, Integer>, TypeSerializer<Object>[]> decomposeSubclassSerializerRegistry(LinkedHashMap<Class<?>, TypeSerializer<?>> subclassSerializerRegistry) {     final LinkedHashMap<Class<?>, Integer> subclassIds = new LinkedHashMap<>(subclassSerializerRegistry.size()).     final TypeSerializer[] subclassSerializers = new TypeSerializer[subclassSerializerRegistry.size()].     subclassSerializerRegistry.forEach((registeredSubclassClass, serializer) -> {         int id = subclassIds.size().         subclassIds.put(registeredSubclassClass, id).         subclassSerializers[id] = serializer.     }).     return Tuple2.of(subclassIds, subclassSerializers). }
true;private,static;2;27;/**  * Finds which Pojo fields exists both in the new {@link PojoSerializer} as well as in the previous one  * (represented by this snapshot), and returns an {@link IntermediateCompatibilityResult}  * of the serializers of those preexisting fields.  */ ;/**  * Finds which Pojo fields exists both in the new {@link PojoSerializer} as well as in the previous one  * (represented by this snapshot), and returns an {@link IntermediateCompatibilityResult}  * of the serializers of those preexisting fields.  */ private static <T> IntermediateCompatibilityResult<T> getCompatibilityOfPreExistingFields(PojoSerializer<T> newPojoSerializer, LinkedOptionalMap<Field, TypeSerializerSnapshot<?>> fieldSerializerSnapshots) {     // the present entries dictates the preexisting fields, because removed fields would be     // represented as absent keys in the optional map.     final Set<LinkedOptionalMap.KeyValue<Field, TypeSerializerSnapshot<?>>> presentFieldSnapshots = fieldSerializerSnapshots.getPresentEntries().     final ArrayList<TypeSerializerSnapshot<?>> associatedFieldSerializerSnapshots = new ArrayList<>(presentFieldSnapshots.size()).     final ArrayList<TypeSerializer<?>> associatedNewFieldSerializers = new ArrayList<>(presentFieldSnapshots.size()).     final Map<Field, TypeSerializer<?>> newFieldSerializersIndex = buildNewFieldSerializersIndex(newPojoSerializer).     for (LinkedOptionalMap.KeyValue<Field, TypeSerializerSnapshot<?>> presentFieldEntry : presentFieldSnapshots) {         TypeSerializer<?> associatedNewFieldSerializer = newFieldSerializersIndex.get(presentFieldEntry.getKey()).         checkState(associatedNewFieldSerializer != null, "a present field should have its associated new field serializer available.").         associatedFieldSerializerSnapshots.add(presentFieldEntry.getValue()).         associatedNewFieldSerializers.add(associatedNewFieldSerializer).     }     return CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(associatedNewFieldSerializers.toArray(new TypeSerializer<?>[associatedNewFieldSerializers.size()]), associatedFieldSerializerSnapshots.toArray(new TypeSerializerSnapshot<?>[associatedFieldSerializerSnapshots.size()])). }
true;private,static;1;14;/**  * Builds an index of fields to their corresponding serializers for the  * new {@link PojoSerializer} for faster field serializer lookups.  */ ;/**  * Builds an index of fields to their corresponding serializers for the  * new {@link PojoSerializer} for faster field serializer lookups.  */ private static <T> Map<Field, TypeSerializer<?>> buildNewFieldSerializersIndex(PojoSerializer<T> newPojoSerializer) {     final Field[] newFields = newPojoSerializer.getFields().     final TypeSerializer<?>[] newFieldSerializers = newPojoSerializer.getFieldSerializers().     checkState(newFields.length == newFieldSerializers.length).     int numFields = newFields.length.     final Map<Field, TypeSerializer<?>> index = new HashMap<>(numFields).     for (int i = 0. i < numFields. i++) {         index.put(newFields[i], newFieldSerializers[i]).     }     return index. }
true;private,static;2;23;/**  * Finds which registered subclasses exists both in the new {@link PojoSerializer} as well as in the previous one  * (represented by this snapshot), and returns an {@link IntermediateCompatibilityResult}  * of the serializers of this preexisting registered subclasses.  */ ;/**  * Finds which registered subclasses exists both in the new {@link PojoSerializer} as well as in the previous one  * (represented by this snapshot), and returns an {@link IntermediateCompatibilityResult}  * of the serializers of this preexisting registered subclasses.  */ private static <T> IntermediateCompatibilityResult<T> getCompatibilityOfPreExistingRegisteredSubclasses(PojoSerializer<T> newPojoSerializer, LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>> registeredSubclassSerializerSnapshots) {     final LinkedHashMap<Class<?>, TypeSerializerSnapshot<?>> unwrappedSerializerSnapshots = registeredSubclassSerializerSnapshots.unwrapOptionals().     final ArrayList<TypeSerializerSnapshot<?>> associatedSubclassSerializerSnapshots = new ArrayList<>().     final ArrayList<TypeSerializer<?>> associatedNewSubclassSerializers = new ArrayList<>().     final LinkedHashMap<Class<?>, TypeSerializer<?>> newSubclassSerializerRegistry = newPojoSerializer.getBundledSubclassSerializerRegistry().     for (Map.Entry<Class<?>, TypeSerializerSnapshot<?>> entry : unwrappedSerializerSnapshots.entrySet()) {         TypeSerializer<?> newRegisteredSerializer = newSubclassSerializerRegistry.get(entry.getKey()).         if (newRegisteredSerializer != null) {             associatedSubclassSerializerSnapshots.add(entry.getValue()).             associatedNewSubclassSerializers.add(newRegisteredSerializer).         }     }     return CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(associatedNewSubclassSerializers.toArray(new TypeSerializer<?>[associatedNewSubclassSerializers.size()]), associatedSubclassSerializerSnapshots.toArray(new TypeSerializerSnapshot<?>[associatedSubclassSerializerSnapshots.size()])). }
true;private,static;4;9;/**  * Checks if the new {@link PojoSerializer} is compatible after migration.  */ ;/**  * Checks if the new {@link PojoSerializer} is compatible after migration.  */ private static <T> boolean newPojoSerializerIsCompatibleAfterMigration(PojoSerializer<T> newPojoSerializer, IntermediateCompatibilityResult<T> fieldSerializerCompatibility, IntermediateCompatibilityResult<T> preExistingRegistrationsCompatibility, LinkedOptionalMap<Field, TypeSerializerSnapshot<?>> fieldSerializerSnapshots) {     return newPojoHasNewOrRemovedFields(fieldSerializerSnapshots, newPojoSerializer) || fieldSerializerCompatibility.isCompatibleAfterMigration() || preExistingRegistrationsCompatibility.isCompatibleAfterMigration(). }
true;private,static;5;11;/**  * Checks if the new {@link PojoSerializer} is compatible with a reconfigured instance.  */ ;/**  * Checks if the new {@link PojoSerializer} is compatible with a reconfigured instance.  */ private static <T> boolean newPojoSerializerIsCompatibleWithReconfiguredSerializer(PojoSerializer<T> newPojoSerializer, IntermediateCompatibilityResult<T> fieldSerializerCompatibility, IntermediateCompatibilityResult<T> preExistingRegistrationsCompatibility, LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>> registeredSubclassSerializerSnapshots, LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>> nonRegisteredSubclassSerializerSnapshots) {     return newPojoHasDifferentSubclassRegistrationOrder(registeredSubclassSerializerSnapshots, newPojoSerializer) || previousSerializerHasNonRegisteredSubclasses(nonRegisteredSubclassSerializerSnapshots) || fieldSerializerCompatibility.isCompatibleWithReconfiguredSerializer() || preExistingRegistrationsCompatibility.isCompatibleWithReconfiguredSerializer(). }
true;private,static;2;10;/**  * Checks whether the new {@link PojoSerializer} has new or removed fields compared to the previous one.  */ ;/**  * Checks whether the new {@link PojoSerializer} has new or removed fields compared to the previous one.  */ private static boolean newPojoHasNewOrRemovedFields(LinkedOptionalMap<Field, TypeSerializerSnapshot<?>> fieldSerializerSnapshots, PojoSerializer<?> newPojoSerializer) {     int numRemovedFields = fieldSerializerSnapshots.absentKeysOrValues().size().     int numPreexistingFields = fieldSerializerSnapshots.size() - numRemovedFields.     boolean hasRemovedFields = numRemovedFields > 0.     boolean hasNewFields = newPojoSerializer.getFields().length - numPreexistingFields > 0.     return hasRemovedFields || hasNewFields. }
true;private,static;2;7;/**  * Checks whether the new {@link PojoSerializer} has a different subclass registration order  * compared to the previous one.  */ ;/**  * Checks whether the new {@link PojoSerializer} has a different subclass registration order  * compared to the previous one.  */ private static boolean newPojoHasDifferentSubclassRegistrationOrder(LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>> registeredSubclassSerializerSnapshots, PojoSerializer<?> newPojoSerializer) {     Set<Class<?>> previousRegistrationOrder = registeredSubclassSerializerSnapshots.unwrapOptionals().keySet().     Set<Class<?>> newRegistrationOrder = newPojoSerializer.getRegisteredClasses().keySet().     return !isPreviousRegistrationPrefixOfNewRegistration(previousRegistrationOrder, newRegistrationOrder). }
false;private,static;2;16;;private static boolean isPreviousRegistrationPrefixOfNewRegistration(Set<Class<?>> previousRegistrationOrder, Set<Class<?>> newRegistrationOrder) {     Iterator<Class<?>> newRegistrationItr = newRegistrationOrder.iterator().     for (Class<?> previousRegisteredClass : previousRegistrationOrder) {         if (!newRegistrationItr.hasNext()) {             return false.         }         Class<?> newRegisteredClass = newRegistrationItr.next().         if (!previousRegisteredClass.equals(newRegisteredClass)) {             return false.         }     }     return true. }
true;private,static;1;4;/**  * Checks whether the previous serializer, represented by this snapshot, has  * non-registered subclasses.  */ ;/**  * Checks whether the previous serializer, represented by this snapshot, has  * non-registered subclasses.  */ private static boolean previousSerializerHasNonRegisteredSubclasses(LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>> nonRegisteredSubclassSerializerSnapshots) {     return nonRegisteredSubclassSerializerSnapshots.size() > 0. }
true;private,static;5;24;/**  * Creates a reconfigured version of the {@link PojoSerializer}.  *  * @param originalNewPojoSerializer the original new {@link PojoSerializer} to create a reconfigured version of.  * @param fieldSerializerCompatibility compatibility of preexisting fields' serializers.  * @param registeredSerializerSnapshots snapshot of previous registered subclasses' serializers.  * @param preExistingRegistrationsCompatibility compatibility of preexisting subclasses' serializers.  * @param nonRegisteredSubclassSerializerSnapshots snapshot of previous non-registered subclasses' serializers.  *  * @return a reconfigured version of the original new {@link PojoSerializer}.  */ ;/**  * Creates a reconfigured version of the {@link PojoSerializer}.  *  * @param originalNewPojoSerializer the original new {@link PojoSerializer} to create a reconfigured version of.  * @param fieldSerializerCompatibility compatibility of preexisting fields' serializers.  * @param registeredSerializerSnapshots snapshot of previous registered subclasses' serializers.  * @param preExistingRegistrationsCompatibility compatibility of preexisting subclasses' serializers.  * @param nonRegisteredSubclassSerializerSnapshots snapshot of previous non-registered subclasses' serializers.  *  * @return a reconfigured version of the original new {@link PojoSerializer}.  */ private static <T> PojoSerializer<T> constructReconfiguredPojoSerializer(PojoSerializer<T> originalNewPojoSerializer, IntermediateCompatibilityResult<T> fieldSerializerCompatibility, LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>> registeredSerializerSnapshots, IntermediateCompatibilityResult<T> preExistingRegistrationsCompatibility, LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>> nonRegisteredSubclassSerializerSnapshots) {     @SuppressWarnings("unchecked")     final TypeSerializer<Object>[] reconfiguredFieldSerializers = constructReconfiguredFieldSerializers(fieldSerializerCompatibility).     Tuple2<LinkedHashMap<Class<?>, Integer>, TypeSerializer<Object>[]> reconfiguredSubclassRegistry = constructReconfiguredSubclassRegistry(originalNewPojoSerializer.getBundledSubclassSerializerRegistry(), registeredSerializerSnapshots, preExistingRegistrationsCompatibility).     return new PojoSerializer<>(originalNewPojoSerializer.getPojoClass(), originalNewPojoSerializer.getFields(), reconfiguredFieldSerializers, reconfiguredSubclassRegistry.f0, reconfiguredSubclassRegistry.f1, restoreSerializers(nonRegisteredSubclassSerializerSnapshots.unwrapOptionals()), originalNewPojoSerializer.getExecutionConfig()). }
false;private,static;1;5;;private static TypeSerializer[] constructReconfiguredFieldSerializers(IntermediateCompatibilityResult<?> fieldSerializerCompatibility) {     checkArgument(!fieldSerializerCompatibility.isIncompatible() && !fieldSerializerCompatibility.isCompatibleAfterMigration()).     return fieldSerializerCompatibility.getNestedSerializers(). }
false;private,static;3;24;;private static Tuple2<LinkedHashMap<Class<?>, Integer>, TypeSerializer<Object>[]> constructReconfiguredSubclassRegistry(LinkedHashMap<Class<?>, TypeSerializer<?>> newSubclassRegistrations, LinkedOptionalMap<Class<?>, TypeSerializerSnapshot<?>> registeredSerializerSnapshots, IntermediateCompatibilityResult<?> preExistingRegistrationsCompatibility) {     checkArgument(!preExistingRegistrationsCompatibility.isIncompatible() && !preExistingRegistrationsCompatibility.isCompatibleAfterMigration()).     LinkedHashMap<Class<?>, TypeSerializer<?>> reconfiguredSubclassSerializerRegistry = restoreSerializers(registeredSerializerSnapshots.unwrapOptionals()).     Iterator<TypeSerializer<?>> serializersForPreexistingRegistrations = Arrays.asList(preExistingRegistrationsCompatibility.getNestedSerializers()).iterator().     for (Map.Entry<Class<?>, TypeSerializer<?>> registration : newSubclassRegistrations.entrySet()) {         // new registrations should simply be appended to the subclass serializer registry with their new serializers.         // preexisting registrations should use the compatibility-checked serializer         TypeSerializer<?> newRegistration = (reconfiguredSubclassSerializerRegistry.containsKey(registration.getKey())) ? serializersForPreexistingRegistrations.next() : registration.getValue().         reconfiguredSubclassSerializerRegistry.put(registration.getKey(), newRegistration).     }     return decomposeSubclassSerializerRegistry(reconfiguredSubclassSerializerRegistry). }
