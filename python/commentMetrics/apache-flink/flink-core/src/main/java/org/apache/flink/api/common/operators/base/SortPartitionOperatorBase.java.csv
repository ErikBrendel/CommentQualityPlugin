commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Ordering getPartitionOrdering() {     return partitionOrdering. }
false;public;0;4;;@Override public SingleInputSemanticProperties getSemanticProperties() {     return new SingleInputSemanticProperties.AllFieldsForwardedProperties(). }
false;public;2;4;;@Override public int compare(IN o1, IN o2) {     return sortComparator.compare(o1, o2). }
false;protected;3;26;;// -------------------------------------------------------------------------------------------- @Override protected List<IN> executeOnCollections(List<IN> inputData, RuntimeContext runtimeContext, ExecutionConfig executionConfig) {     TypeInformation<IN> inputType = getInput().getOperatorInfo().getOutputType().     int[] sortColumns = this.partitionOrdering.getFieldPositions().     boolean[] sortOrderings = this.partitionOrdering.getFieldSortDirections().     final TypeComparator<IN> sortComparator.     if (inputType instanceof CompositeType) {         sortComparator = ((CompositeType<IN>) inputType).createComparator(sortColumns, sortOrderings, 0, executionConfig).     } else if (inputType instanceof AtomicType) {         sortComparator = ((AtomicType) inputType).createComparator(sortOrderings[0], executionConfig).     } else {         throw new UnsupportedOperationException("Partition sorting does not support type " + inputType + " yet.").     }     Collections.sort(inputData, new Comparator<IN>() {          @Override         public int compare(IN o1, IN o2) {             return sortComparator.compare(o1, o2).         }     }).     return inputData. }
