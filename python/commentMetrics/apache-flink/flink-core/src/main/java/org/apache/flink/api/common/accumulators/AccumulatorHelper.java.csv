commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;25;/**  * Merge two collections of accumulators. The second will be merged into the  * first.  *  * @param target  *            The collection of accumulators that will be updated  * @param toMerge  *            The collection of accumulators that will be merged into the  *            other  */ ;/**  * Merge two collections of accumulators. The second will be merged into the  * first.  *  * @param target  *            The collection of accumulators that will be updated  * @param toMerge  *            The collection of accumulators that will be merged into the  *            other  */ public static void mergeInto(Map<String, OptionalFailure<Accumulator<?, ?>>> target, Map<String, Accumulator<?, ?>> toMerge) {     for (Map.Entry<String, Accumulator<?, ?>> otherEntry : toMerge.entrySet()) {         OptionalFailure<Accumulator<?, ?>> ownAccumulator = target.get(otherEntry.getKey()).         if (ownAccumulator == null) {             // Create initial counter (copy!)             target.put(otherEntry.getKey(), wrapUnchecked(otherEntry.getKey(), () -> otherEntry.getValue().clone())).         } else if (ownAccumulator.isFailure()) {             continue.         } else {             Accumulator<?, ?> accumulator = ownAccumulator.getUnchecked().             // Both should have the same type             compareAccumulatorTypes(otherEntry.getKey(), accumulator.getClass(), otherEntry.getValue().getClass()).             // Merge target counter with other counter             target.put(otherEntry.getKey(), wrapUnchecked(otherEntry.getKey(), () -> mergeSingle(accumulator, otherEntry.getValue().clone()))).         }     } }
true;private,static;2;12;/**  * Workaround method for type safety.  */ ;/**  * Workaround method for type safety.  */ private static <V, R extends Serializable> Accumulator<V, R> mergeSingle(Accumulator<?, ?> target, Accumulator<?, ?> toMerge) {     @SuppressWarnings("unchecked")     Accumulator<V, R> typedTarget = (Accumulator<V, R>) target.     @SuppressWarnings("unchecked")     Accumulator<V, R> typedToMerge = (Accumulator<V, R>) toMerge.     typedTarget.merge(typedToMerge).     return typedTarget. }
true;public,static;3;22;/**  * Compare both classes and throw {@link UnsupportedOperationException} if  * they differ.  */ ;/**  * Compare both classes and throw {@link UnsupportedOperationException} if  * they differ.  */ @SuppressWarnings("rawtypes") public static void compareAccumulatorTypes(Object name, Class<? extends Accumulator> first, Class<? extends Accumulator> second) throws UnsupportedOperationException {     if (first == null || second == null) {         throw new NullPointerException().     }     if (first != second) {         if (!first.getName().equals(second.getName())) {             throw new UnsupportedOperationException("The accumulator object '" + name + "' was created with two different types: " + first.getName() + " and " + second.getName()).         } else {             // damn, name is the same, but different classloaders             throw new UnsupportedOperationException("The accumulator object '" + name + "' was created with two different classes: " + first + " and " + second + " Both have the same type (" + first.getName() + ") but different classloaders: " + first.getClassLoader() + " and " + second.getClassLoader()).         }     } }
true;public,static;1;7;/**  * Transform the Map with accumulators into a Map containing only the  * results.  */ ;/**  * Transform the Map with accumulators into a Map containing only the  * results.  */ public static Map<String, OptionalFailure<Object>> toResultMap(Map<String, Accumulator<?, ?>> accumulators) {     Map<String, OptionalFailure<Object>> resultMap = new HashMap<>().     for (Map.Entry<String, Accumulator<?, ?>> entry : accumulators.entrySet()) {         resultMap.put(entry.getKey(), wrapUnchecked(entry.getKey(), () -> entry.getValue().getLocalValue())).     }     return resultMap. }
false;private,static;2;10;;private static <R> OptionalFailure<R> wrapUnchecked(String name, Supplier<R> supplier) {     return OptionalFailure.createFrom(() -> {         try {             return supplier.get().         } catch (RuntimeException ex) {             LOG.error("Unexpected error while handling accumulator [" + name + "]", ex).             throw new FlinkException(ex).         }     }). }
false;public,static;1;18;;public static String getResultsFormatted(Map<String, Object> map) {     StringBuilder builder = new StringBuilder().     for (Map.Entry<String, Object> entry : map.entrySet()) {         builder.append("- ").append(entry.getKey()).append(" (").append(entry.getValue().getClass().getName()).append(")").         if (entry.getValue() instanceof Collection) {             builder.append(" [").append(((Collection) entry.getValue()).size()).append(" elements]").         } else {             builder.append(": ").append(entry.getValue().toString()).         }         builder.append(System.lineSeparator()).     }     return builder.toString(). }
false;public,static;1;9;;public static Map<String, Accumulator<?, ?>> copy(Map<String, Accumulator<?, ?>> accumulators) {     Map<String, Accumulator<?, ?>> result = new HashMap<String, Accumulator<?, ?>>().     for (Map.Entry<String, Accumulator<?, ?>> entry : accumulators.entrySet()) {         result.put(entry.getKey(), entry.getValue().clone()).     }     return result. }
true;public,static;2;22;/**  * Takes the serialized accumulator results and tries to deserialize them using the provided  * class loader.  * @param serializedAccumulators The serialized accumulator results.  * @param loader The class loader to use.  * @return The deserialized accumulator results.  * @throws IOException  * @throws ClassNotFoundException  */ ;/**  * Takes the serialized accumulator results and tries to deserialize them using the provided  * class loader.  * @param serializedAccumulators The serialized accumulator results.  * @param loader The class loader to use.  * @return The deserialized accumulator results.  * @throws IOException  * @throws ClassNotFoundException  */ public static Map<String, OptionalFailure<Object>> deserializeAccumulators(Map<String, SerializedValue<OptionalFailure<Object>>> serializedAccumulators, ClassLoader loader) throws IOException, ClassNotFoundException {     if (serializedAccumulators == null || serializedAccumulators.isEmpty()) {         return Collections.emptyMap().     }     Map<String, OptionalFailure<Object>> accumulators = new HashMap<>(serializedAccumulators.size()).     for (Map.Entry<String, SerializedValue<OptionalFailure<Object>>> entry : serializedAccumulators.entrySet()) {         OptionalFailure<Object> value = null.         if (entry.getValue() != null) {             value = entry.getValue().deserializeValue(loader).         }         accumulators.put(entry.getKey(), value).     }     return accumulators. }
