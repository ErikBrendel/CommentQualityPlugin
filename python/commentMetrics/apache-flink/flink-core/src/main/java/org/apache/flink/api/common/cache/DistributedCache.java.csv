commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Override public String toString() {     return "DistributedCacheEntry{" + "filePath='" + filePath + '\'' + ", isExecutable=" + isExecutable + ", isZipped=" + isZipped + ", blobKey=" + Arrays.toString(blobKey) + '}'. }
false;public;1;24;;// ------------------------------------------------------------------------ public File getFile(String name) {     if (name == null) {         throw new NullPointerException("name must not be null").     }     Future<Path> future = cacheCopyTasks.get(name).     if (future == null) {         throw new IllegalArgumentException("File with name '" + name + "' is not available." + " Did you forget to register the file?").     }     try {         final Path path = future.get().         URI tmp = path.makeQualified(path.getFileSystem()).toUri().         return new File(tmp).     } catch (ExecutionException e) {         throw new RuntimeException("An error occurred while copying the file.", e.getCause()).     } catch (Exception e) {         throw new RuntimeException("Error while getting the file registered under '" + name + "' from the distributed cache", e).     } }
false;public,static;3;11;;// ------------------------------------------------------------------------ // Utilities to read/write cache files from/to the configuration // ------------------------------------------------------------------------ public static void writeFileInfoToConfig(String name, DistributedCacheEntry e, Configuration conf) {     int num = conf.getInteger(CACHE_FILE_NUM, 0) + 1.     conf.setInteger(CACHE_FILE_NUM, num).     conf.setString(CACHE_FILE_NAME + num, name).     conf.setString(CACHE_FILE_PATH + num, e.filePath).     conf.setBoolean(CACHE_FILE_EXE + num, e.isExecutable || new File(e.filePath).canExecute()).     conf.setBoolean(CACHE_FILE_DIR + num, e.isZipped || new File(e.filePath).isDirectory()).     if (e.blobKey != null) {         conf.setBytes(CACHE_FILE_BLOB_KEY + num, e.blobKey).     } }
false;public,static;1;18;;public static Set<Entry<String, DistributedCacheEntry>> readFileInfoFromConfig(Configuration conf) {     int num = conf.getInteger(CACHE_FILE_NUM, 0).     if (num == 0) {         return Collections.emptySet().     }     Map<String, DistributedCacheEntry> cacheFiles = new HashMap<String, DistributedCacheEntry>().     for (int i = 1. i <= num. i++) {         String name = conf.getString(CACHE_FILE_NAME + i, null).         String filePath = conf.getString(CACHE_FILE_PATH + i, null).         boolean isExecutable = conf.getBoolean(CACHE_FILE_EXE + i, false).         boolean isDirectory = conf.getBoolean(CACHE_FILE_DIR + i, false).         byte[] blobKey = conf.getBytes(CACHE_FILE_BLOB_KEY + i, null).         cacheFiles.put(name, new DistributedCacheEntry(filePath, isExecutable, blobKey, isDirectory)).     }     return cacheFiles.entrySet(). }
