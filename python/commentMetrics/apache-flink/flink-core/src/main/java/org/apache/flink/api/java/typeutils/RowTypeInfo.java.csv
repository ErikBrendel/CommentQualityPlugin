commented;modifiers;parameterAmount;loc;comment;code
false;public;3;63;;@Override public void getFlatFields(String fieldExpression, int offset, List<FlatFieldDescriptor> result) {     Matcher matcher = PATTERN_NESTED_FIELDS_WILDCARD.matcher(fieldExpression).     if (!matcher.matches()) {         throw new InvalidFieldReferenceException("Invalid tuple field reference \"" + fieldExpression + "\".").     }     String field = matcher.group(0).     if ((field.equals(ExpressionKeys.SELECT_ALL_CHAR)) || (field.equals(ExpressionKeys.SELECT_ALL_CHAR_SCALA))) {         // handle select all         int keyPosition = 0.         for (TypeInformation<?> fType : types) {             if (fType instanceof CompositeType) {                 CompositeType<?> cType = (CompositeType<?>) fType.                 cType.getFlatFields(ExpressionKeys.SELECT_ALL_CHAR, offset + keyPosition, result).                 keyPosition += cType.getTotalFields() - 1.             } else {                 result.add(new FlatFieldDescriptor(offset + keyPosition, fType)).             }             keyPosition++.         }     } else {         field = matcher.group(1).         Matcher intFieldMatcher = PATTERN_INT_FIELD.matcher(field).         int fieldIndex.         if (intFieldMatcher.matches()) {             // field expression is an integer             fieldIndex = Integer.valueOf(field).         } else {             fieldIndex = this.getFieldIndex(field).         }         // fetch the field type will throw exception if the index is illegal         TypeInformation<?> fieldType = this.getTypeAt(fieldIndex).         // compute the offset,         for (int i = 0. i < fieldIndex. i++) {             offset += this.getTypeAt(i).getTotalFields().         }         String tail = matcher.group(3).         if (tail == null) {             // expression hasn't nested field             if (fieldType instanceof CompositeType) {                 ((CompositeType) fieldType).getFlatFields("*", offset, result).             } else {                 result.add(new FlatFieldDescriptor(offset, fieldType)).             }         } else {             // expression has nested field             if (fieldType instanceof CompositeType) {                 ((CompositeType) fieldType).getFlatFields(tail, offset, result).             } else {                 throw new InvalidFieldReferenceException("Nested field expression \"" + tail + "\" not possible on atomic type " + fieldType + ".").             }         }     } }
false;public;1;38;;@Override public <X> TypeInformation<X> getTypeAt(String fieldExpression) {     Matcher matcher = PATTERN_NESTED_FIELDS.matcher(fieldExpression).     if (!matcher.matches()) {         if (fieldExpression.equals(ExpressionKeys.SELECT_ALL_CHAR) || fieldExpression.equals(ExpressionKeys.SELECT_ALL_CHAR_SCALA)) {             throw new InvalidFieldReferenceException("Wildcard expressions are not allowed here.").         } else {             throw new InvalidFieldReferenceException("Invalid format of Row field expression \"" + fieldExpression + "\".").         }     }     String field = matcher.group(1).     Matcher intFieldMatcher = PATTERN_INT_FIELD.matcher(field).     int fieldIndex.     if (intFieldMatcher.matches()) {         // field expression is an integer         fieldIndex = Integer.valueOf(field).     } else {         fieldIndex = this.getFieldIndex(field).     }     // fetch the field type will throw exception if the index is illegal     TypeInformation<X> fieldType = this.getTypeAt(fieldIndex).     String tail = matcher.group(3).     if (tail == null) {         // found the type         return fieldType.     } else {         if (fieldType instanceof CompositeType) {             return ((CompositeType<?>) fieldType).getTypeAt(tail).         } else {             throw new InvalidFieldReferenceException("Nested field expression \"" + tail + "\" not possible on atomic type " + fieldType + ".").         }     } }
false;public;4;16;;@Override public TypeComparator<Row> createComparator(int[] logicalKeyFields, boolean[] orders, int logicalFieldOffset, ExecutionConfig config) {     comparatorOrders = orders.     TypeComparator<Row> comparator = super.createComparator(logicalKeyFields, orders, logicalFieldOffset, config).     comparatorOrders = null.     return comparator. }
false;protected;0;7;;@Override protected TypeComparatorBuilder<Row> createTypeComparatorBuilder() {     if (comparatorOrders == null) {         throw new IllegalStateException("Cannot create comparator builder without orders.").     }     return new RowTypeComparatorBuilder(comparatorOrders). }
false;public;0;4;;@Override public String[] getFieldNames() {     return fieldNames. }
false;public;1;9;;@Override public int getFieldIndex(String fieldName) {     for (int i = 0. i < fieldNames.length. i++) {         if (fieldNames[i].equals(fieldName)) {             return i.         }     }     return -1. }
false;public;1;9;;@Override public TypeSerializer<Row> createSerializer(ExecutionConfig config) {     int len = getArity().     TypeSerializer<?>[] fieldSerializers = new TypeSerializer[len].     for (int i = 0. i < len. i++) {         fieldSerializers[i] = types[i].createSerializer(config).     }     return new RowSerializer(fieldSerializers). }
false;public;1;4;;@Override public boolean canEqual(Object obj) {     return obj instanceof RowTypeInfo. }
false;public;0;4;;@Override public int hashCode() {     return 31 * super.hashCode(). }
true;public;1;9;/**  * The equals method does only check for field types. Field names do not matter during  * runtime so we can consider rows with the same field types as equal.  * Use {@link RowTypeInfo#schemaEquals(Object)} for checking schema-equivalence.  */ ;/**  * The equals method does only check for field types. Field names do not matter during  * runtime so we can consider rows with the same field types as equal.  * Use {@link RowTypeInfo#schemaEquals(Object)} for checking schema-equivalence.  */ @Override public boolean equals(Object obj) {     if (obj instanceof RowTypeInfo) {         final RowTypeInfo other = (RowTypeInfo) obj.         return other.canEqual(this) && super.equals(other).     } else {         return false.     } }
false;public;0;14;;@Override public String toString() {     StringBuilder bld = new StringBuilder("Row").     if (types.length > 0) {         bld.append('(').append(fieldNames[0]).append(": ").append(types[0]).         for (int i = 1. i < types.length. i++) {             bld.append(", ").append(fieldNames[i]).append(": ").append(types[i]).         }         bld.append(')').     }     return bld.toString(). }
true;public;0;3;/**  * Returns the field types of the row. The order matches the order of the field names.  */ ;/**  * Returns the field types of the row. The order matches the order of the field names.  */ public TypeInformation<?>[] getFieldTypes() {     return types. }
true;public;1;3;/**  * Tests whether an other object describes the same, schema-equivalent row information.  */ ;/**  * Tests whether an other object describes the same, schema-equivalent row information.  */ public boolean schemaEquals(Object obj) {     return equals(obj) && Arrays.equals(fieldNames, ((RowTypeInfo) obj).fieldNames). }
false;private;1;9;;private boolean hasDuplicateFieldNames(String[] fieldNames) {     HashSet<String> names = new HashSet<>().     for (String field : fieldNames) {         if (!names.add(field)) {             return true.         }     }     return false. }
false;public;1;5;;@Override public void initializeTypeComparatorBuilder(int size) {     fieldComparators.ensureCapacity(size).     logicalKeyFields.ensureCapacity(size). }
false;public;2;5;;@Override public void addComparatorField(int fieldId, TypeComparator<?> comparator) {     fieldComparators.add(comparator).     logicalKeyFields.add(fieldId). }
false;public;1;48;;@Override public TypeComparator<Row> createTypeComparator(ExecutionConfig config) {     checkState(fieldComparators.size() > 0, "No field comparators were defined for the TupleTypeComparatorBuilder.").     checkState(logicalKeyFields.size() > 0, "No key fields were defined for the TupleTypeComparatorBuilder.").     checkState(fieldComparators.size() == logicalKeyFields.size(), "The number of field comparators and key fields is not equal.").     final int maxKey = Collections.max(logicalKeyFields).     checkState(maxKey >= 0, "The maximum key field must be greater or equal than 0.").     TypeSerializer<?>[] fieldSerializers = new TypeSerializer<?>[maxKey + 1].     for (int i = 0. i <= maxKey. i++) {         fieldSerializers[i] = types[i].createSerializer(config).     }     int[] keyPositions = new int[logicalKeyFields.size()].     for (int i = 0. i < keyPositions.length. i++) {         keyPositions[i] = logicalKeyFields.get(i).     }     TypeComparator[] comparators = new TypeComparator[fieldComparators.size()].     for (int i = 0. i < fieldComparators.size(). i++) {         comparators[i] = fieldComparators.get(i).     }     // noinspection unchecked     return new RowComparator(getArity(), keyPositions, comparators, (TypeSerializer<Object>[]) fieldSerializers, comparatorOrders). }
true;public,static;2;9;/**  * Creates a {@link RowTypeInfo} with projected fields.  *  * @param rowType The original RowTypeInfo whose fields are projected  * @param fieldMapping The field mapping of the projection  * @return A RowTypeInfo with projected fields.  */ ;/**  * Creates a {@link RowTypeInfo} with projected fields.  *  * @param rowType The original RowTypeInfo whose fields are projected  * @param fieldMapping The field mapping of the projection  * @return A RowTypeInfo with projected fields.  */ public static RowTypeInfo projectFields(RowTypeInfo rowType, int[] fieldMapping) {     TypeInformation[] fieldTypes = new TypeInformation[fieldMapping.length].     String[] fieldNames = new String[fieldMapping.length].     for (int i = 0. i < fieldMapping.length. i++) {         fieldTypes[i] = rowType.getTypeAt(fieldMapping[i]).         fieldNames[i] = rowType.getFieldNames()[fieldMapping[i]].     }     return new RowTypeInfo(fieldTypes, fieldNames). }
