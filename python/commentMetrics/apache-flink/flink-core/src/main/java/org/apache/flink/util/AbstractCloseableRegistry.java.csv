commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;16;/**  * Registers a {@link Closeable} with the registry. In case the registry is already closed, this method throws an  * {@link IllegalStateException} and closes the passed {@link Closeable}.  *  * @param closeable Closeable tor register  * @throws IOException exception when the registry was closed before  */ ;/**  * Registers a {@link Closeable} with the registry. In case the registry is already closed, this method throws an  * {@link IllegalStateException} and closes the passed {@link Closeable}.  *  * @param closeable Closeable tor register  * @throws IOException exception when the registry was closed before  */ public final void registerCloseable(C closeable) throws IOException {     if (null == closeable) {         return.     }     synchronized (getSynchronizationLock()) {         if (!closed) {             doRegister(closeable, closeableToRef).             return.         }     }     IOUtils.closeQuietly(closeable).     throw new IOException("Cannot register Closeable, registry is already closed. Closing argument."). }
true;public,final;1;10;/**  * Removes a {@link Closeable} from the registry.  *  * @param closeable instance to remove from the registry.  * @return true if the closeable was previously registered and became unregistered through this call.  */ ;/**  * Removes a {@link Closeable} from the registry.  *  * @param closeable instance to remove from the registry.  * @return true if the closeable was previously registered and became unregistered through this call.  */ public final boolean unregisterCloseable(C closeable) {     if (null == closeable) {         return false.     }     synchronized (getSynchronizationLock()) {         return doUnRegister(closeable, closeableToRef).     } }
false;public;0;19;;@Override public void close() throws IOException {     Collection<Closeable> toCloseCopy.     synchronized (getSynchronizationLock()) {         if (closed) {             return.         }         closed = true.         toCloseCopy = new ArrayList<>(closeableToRef.keySet()).         closeableToRef.clear().     }     IOUtils.closeAllQuietly(toCloseCopy). }
false;public;0;5;;public boolean isClosed() {     synchronized (getSynchronizationLock()) {         return closed.     } }
true;protected,abstract;2;1;/**  * Does the actual registration of the closeable with the registry map. This should not do any long running or  * potentially blocking operations as is is executed under the registry's lock.  */ ;/**  * Does the actual registration of the closeable with the registry map. This should not do any long running or  * potentially blocking operations as is is executed under the registry's lock.  */ protected abstract void doRegister(@Nonnull C closeable, @Nonnull Map<Closeable, T> closeableMap).
true;protected,abstract;2;1;/**  * Does the actual un-registration of the closeable from the registry map. This should not do any long running or  * potentially blocking operations as is is executed under the registry's lock.  */ ;/**  * Does the actual un-registration of the closeable from the registry map. This should not do any long running or  * potentially blocking operations as is is executed under the registry's lock.  */ protected abstract boolean doUnRegister(@Nonnull C closeable, @Nonnull Map<Closeable, T> closeableMap).
true;protected,final;0;3;/**  * Returns the lock on which manipulations to members closeableToRef and closeable must be synchronized.  */ ;/**  * Returns the lock on which manipulations to members closeableToRef and closeable must be synchronized.  */ protected final Object getSynchronizationLock() {     return lock. }
true;protected,final;2;5;/**  * Adds a mapping to the registry map, respecting locking.  */ ;/**  * Adds a mapping to the registry map, respecting locking.  */ protected final void addCloseableInternal(Closeable closeable, T metaData) {     synchronized (getSynchronizationLock()) {         closeableToRef.put(closeable, metaData).     } }
true;protected,final;1;5;/**  * Removes a mapping from the registry map, respecting locking.  */ ;/**  * Removes a mapping from the registry map, respecting locking.  */ protected final void removeCloseableInternal(Closeable closeable) {     synchronized (getSynchronizationLock()) {         closeableToRef.remove(closeable).     } }
false;public,final;0;6;;@VisibleForTesting public final int getNumberOfRegisteredCloseables() {     synchronized (getSynchronizationLock()) {         return closeableToRef.size().     } }
false;public,final;1;6;;@VisibleForTesting public final boolean isCloseableRegistered(Closeable c) {     synchronized (getSynchronizationLock()) {         return closeableToRef.containsKey(c).     } }
