commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns this operator's input operator.  *  * @return This operator's input.  */ ;// -------------------------------------------------------------------------------------------- /**  * Returns this operator's input operator.  *  * @return This operator's input.  */ public Operator<IN> getInput() {     return this.input. }
true;public;1;3;/**  * Sets the given operator as the input to this operator.  *  * @param input The operator to use as the input.  */ ;/**  * Sets the given operator as the input to this operator.  *  * @param input The operator to use as the input.  */ public void setInput(Operator<IN> input) {     this.input = checkNotNull(input, "The input may not be null."). }
true;public;1;5;/**  * Sets the input to the union of the given operators.  *  * @param inputs The operator(s) that form the input.  * @deprecated This method will be removed in future versions. Use the {@link org.apache.flink.api.common.operators.Union} operator instead.  */ ;/**  * Sets the input to the union of the given operators.  *  * @param inputs The operator(s) that form the input.  * @deprecated This method will be removed in future versions. Use the {@link org.apache.flink.api.common.operators.Union} operator instead.  */ @Deprecated public void setInputs(Operator<IN>... inputs) {     checkNotNull(inputs, "The inputs may not be null.").     this.input = Operator.createUnionCascade(inputs). }
true;public;1;5;/**  * Sets the input to the union of the given operators.  *  * @param inputs The operator(s) that form the input.  * @deprecated This method will be removed in future versions. Use the {@link org.apache.flink.api.common.operators.Union} operator instead.  */ ;/**  * Sets the input to the union of the given operators.  *  * @param inputs The operator(s) that form the input.  * @deprecated This method will be removed in future versions. Use the {@link org.apache.flink.api.common.operators.Union} operator instead.  */ @Deprecated public void setInputs(List<Operator<IN>> inputs) {     checkNotNull(inputs, "The inputs may not be null.").     this.input = Operator.createUnionCascade(inputs). }
true;public;1;5;/**  * Adds to the input the union of the given operators.  *  * @param inputs The operator(s) to be unioned with the input.  * @deprecated This method will be removed in future versions. Use the {@link org.apache.flink.api.common.operators.Union} operator instead.  */ ;/**  * Adds to the input the union of the given operators.  *  * @param inputs The operator(s) to be unioned with the input.  * @deprecated This method will be removed in future versions. Use the {@link org.apache.flink.api.common.operators.Union} operator instead.  */ @Deprecated public void addInput(Operator<IN>... inputs) {     checkNotNull(inputs, "The input may not be null.").     this.input = Operator.createUnionCascade(this.input, inputs). }
true;public;1;6;/**  * Adds to the input the union of the given operators.  *  * @param inputs The operator(s) to be unioned with the input.  * @deprecated This method will be removed in future versions. Use the {@link org.apache.flink.api.common.operators.Union} operator instead.  */ ;/**  * Adds to the input the union of the given operators.  *  * @param inputs The operator(s) to be unioned with the input.  * @deprecated This method will be removed in future versions. Use the {@link org.apache.flink.api.common.operators.Union} operator instead.  */ @SuppressWarnings("unchecked") @Deprecated public void addInputs(List<? extends Operator<IN>> inputs) {     checkNotNull(inputs, "The inputs may not be null.").     this.input = createUnionCascade(this.input, (Operator<IN>[]) inputs.toArray(new Operator[inputs.size()])). }
true;public;0;3;/**  * Gets the order, in which the data sink writes its data locally. Local order means that  * with in each fragment of the file inside the distributed file system, the data is ordered,  * but not across file fragments.  *  * @return NONE, if the sink writes data in any order, or ASCENDING (resp. DESCENDING),  *         if the sink writes it data with a local ascending (resp. descending) order.  */ ;// -------------------------------------------------------------------------------------------- /**  * Gets the order, in which the data sink writes its data locally. Local order means that  * with in each fragment of the file inside the distributed file system, the data is ordered,  * but not across file fragments.  *  * @return NONE, if the sink writes data in any order, or ASCENDING (resp. DESCENDING),  *         if the sink writes it data with a local ascending (resp. descending) order.  */ public Ordering getLocalOrder() {     return this.localOrdering. }
true;public;1;3;/**  * Sets the order in which the sink must write its data within each fragment in the distributed  * file system. For any value other then <tt>NONE</tt>, this will cause the system to perform a  * local sort, or try to reuse an order from a previous operation.  *  * @param localOrder The local order to write the data in.  */ ;/**  * Sets the order in which the sink must write its data within each fragment in the distributed  * file system. For any value other then <tt>NONE</tt>, this will cause the system to perform a  * local sort, or try to reuse an order from a previous operation.  *  * @param localOrder The local order to write the data in.  */ public void setLocalOrder(Ordering localOrder) {     this.localOrdering = localOrder. }
true;public;0;3;/**  * Gets the class describing this sinks output format.  *  * @return The output format class.  */ ;// -------------------------------------------------------------------------------------------- /**  * Gets the class describing this sinks output format.  *  * @return The output format class.  */ public UserCodeWrapper<? extends OutputFormat<IN>> getFormatWrapper() {     return this.formatWrapper. }
true;public;0;4;/**  * Gets the class describing the output format.  * <p>  * This method is basically identical to {@link #getFormatWrapper()}.  *  * @return The class describing the output format.  *  * @see org.apache.flink.api.common.operators.Operator#getUserCodeWrapper()  */ ;/**  * Gets the class describing the output format.  * <p>  * This method is basically identical to {@link #getFormatWrapper()}.  *  * @return The class describing the output format.  *  * @see org.apache.flink.api.common.operators.Operator#getUserCodeWrapper()  */ @Override public UserCodeWrapper<? extends OutputFormat<IN>> getUserCodeWrapper() {     return this.formatWrapper. }
true;public;1;8;/**  * Accepts the visitor and applies it this instance. This method applies the visitor in a depth-first traversal.  * The visitors pre-visit method is called and, if returning  * <tt>true</tt>, the visitor is recursively applied on the single input. After the recursion returned,  * the post-visit method is called.  *  * @param visitor The visitor.  *  * @see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor)  */ ;// -------------------------------------------------------------------------------------------- /**  * Accepts the visitor and applies it this instance. This method applies the visitor in a depth-first traversal.  * The visitors pre-visit method is called and, if returning  * <tt>true</tt>, the visitor is recursively applied on the single input. After the recursion returned,  * the post-visit method is called.  *  * @param visitor The visitor.  *  * @see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor)  */ @Override public void accept(Visitor<Operator<?>> visitor) {     boolean descend = visitor.preVisit(this).     if (descend) {         this.input.accept(visitor).         visitor.postVisit(this).     } }
false;public;2;4;;@Override public int compare(IN o1, IN o2) {     return sortComparator.compare(o1, o2). }
false;protected;3;45;;// -------------------------------------------------------------------------------------------- @SuppressWarnings("unchecked") protected void executeOnCollections(List<IN> inputData, RuntimeContext ctx, ExecutionConfig executionConfig) throws Exception {     OutputFormat<IN> format = this.formatWrapper.getUserCodeObject().     TypeInformation<IN> inputType = getInput().getOperatorInfo().getOutputType().     if (this.localOrdering != null) {         int[] sortColumns = this.localOrdering.getFieldPositions().         boolean[] sortOrderings = this.localOrdering.getFieldSortDirections().         final TypeComparator<IN> sortComparator.         if (inputType instanceof CompositeType) {             sortComparator = ((CompositeType<IN>) inputType).createComparator(sortColumns, sortOrderings, 0, executionConfig).         } else if (inputType instanceof AtomicType) {             sortComparator = ((AtomicType<IN>) inputType).createComparator(sortOrderings[0], executionConfig).         } else {             throw new UnsupportedOperationException("Local output sorting does not support type " + inputType + " yet.").         }         Collections.sort(inputData, new Comparator<IN>() {              @Override             public int compare(IN o1, IN o2) {                 return sortComparator.compare(o1, o2).             }         }).     }     if (format instanceof InitializeOnMaster) {         ((InitializeOnMaster) format).initializeGlobal(1).     }     format.configure(this.parameters).     if (format instanceof RichOutputFormat) {         ((RichOutputFormat<?>) format).setRuntimeContext(ctx).     }     format.open(0, 1).     for (IN element : inputData) {         format.writeRecord(element).     }     format.close().     if (format instanceof FinalizeOnMaster) {         ((FinalizeOnMaster) format).finalizeGlobal(1).     } }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public String toString() {     return this.name. }
