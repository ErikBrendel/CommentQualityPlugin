commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public void enableQuotedStringParsing(byte quoteCharacter) {     this.quotedStringParsing = true.     this.quoteCharacter = quoteCharacter. }
false;public;5;65;;@Override public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, StringValue reusable) {     if (startPos == limit) {         setErrorState(ParseErrorState.EMPTY_COLUMN).         reusable.setValueAscii(bytes, startPos, 0).         return limit.     }     this.result = reusable.     int i = startPos.     final int delimLimit = limit - delimiter.length + 1.     if (quotedStringParsing && bytes[i] == quoteCharacter) {         // quoted string parsing enabled and first character is a quote         i++.         // search for ending quote character, continue when it is escaped         while (i < limit && (bytes[i] != quoteCharacter || bytes[i - 1] == BACKSLASH)) {             i++.         }         if (i == limit) {             setErrorState(ParseErrorState.UNTERMINATED_QUOTED_STRING).             return -1.         } else {             i++.             // check for proper termination             if (i == limit) {                 // either by end of line                 reusable.setValueAscii(bytes, startPos + 1, i - startPos - 2).                 return limit.             } else if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {                 // or following field delimiter                 reusable.setValueAscii(bytes, startPos + 1, i - startPos - 2).                 return i + delimiter.length.             } else {                 // no proper termination                 setErrorState(ParseErrorState.UNQUOTED_CHARS_AFTER_QUOTED_STRING).                 return -1.             }         }     } else {         // look for delimiter         while (i < delimLimit && !delimiterNext(bytes, i, delimiter)) {             i++.         }         if (i >= delimLimit) {             reusable.setValueAscii(bytes, startPos, limit - startPos).             return limit.         } else {             // delimiter found.             if (i == startPos) {                 // mark empty column                 setErrorState(ParseErrorState.EMPTY_COLUMN).             }             reusable.setValueAscii(bytes, startPos, i - startPos).             return i + delimiter.length.         }     } }
false;public;0;4;;@Override public StringValue createValue() {     return new StringValue(). }
false;public;0;4;;@Override public StringValue getLastResult() {     return this.result. }
