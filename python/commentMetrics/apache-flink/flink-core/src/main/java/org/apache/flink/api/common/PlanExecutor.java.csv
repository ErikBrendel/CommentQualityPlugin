commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Sets whether the executor should print progress results to "standard out" ({@link System#out}).  * All progress messages are logged using the configured logging framework independent of the value  * set here.  *  * @param printStatus True, to print progress updates to standard out, false to not do that.  */ ;/**  * Sets whether the executor should print progress results to "standard out" ({@link System#out}).  * All progress messages are logged using the configured logging framework independent of the value  * set here.  *  * @param printStatus True, to print progress updates to standard out, false to not do that.  */ public void setPrintStatusDuringExecution(boolean printStatus) {     this.printUpdatesToSysout = printStatus. }
true;public;0;3;/**  * Gets whether the executor prints progress results to "standard out" ({@link System#out}).  *  * @return True, if the executor prints progress messages to standard out, false if not.  */ ;/**  * Gets whether the executor prints progress results to "standard out" ({@link System#out}).  *  * @return True, if the executor prints progress messages to standard out, false if not.  */ public boolean isPrintingStatusDuringExecution() {     return this.printUpdatesToSysout. }
true;public,abstract;0;1;/**  * Starts the program executor. After the executor has been started, it will keep  * running until {@link #stop()} is called.  *  * @throws Exception Thrown, if the executor startup failed.  */ ;// ------------------------------------------------------------------------ // Startup & Shutdown // ------------------------------------------------------------------------ /**  * Starts the program executor. After the executor has been started, it will keep  * running until {@link #stop()} is called.  *  * @throws Exception Thrown, if the executor startup failed.  */ public abstract void start() throws Exception.
true;public,abstract;0;1;/**  * Shuts down the plan executor and releases all local resources.  *  * <p>This method also ends all sessions created by this executor. Remote job executions  * may complete, but the session is not kept alive after that.</p>  *  * @throws Exception Thrown, if the proper shutdown failed.  */ ;/**  * Shuts down the plan executor and releases all local resources.  *  * <p>This method also ends all sessions created by this executor. Remote job executions  * may complete, but the session is not kept alive after that.</p>  *  * @throws Exception Thrown, if the proper shutdown failed.  */ public abstract void stop() throws Exception.
true;public,abstract;0;1;/**  * Checks if this executor is currently running.  *  * @return True is the executor is running, false otherwise.  */ ;/**  * Checks if this executor is currently running.  *  * @return True is the executor is running, false otherwise.  */ public abstract boolean isRunning().
true;public,abstract;1;1;/**  * Execute the given program.  *  * <p>If the executor has not been started before, then this method will start the  * executor and stop it after the execution has completed. This implies that one needs  * to explicitly start the executor for all programs where multiple dataflow parts  * depend on each other. Otherwise, the previous parts will no longer  * be available, because the executor immediately shut down after the execution.</p>  *  * @param plan The plan of the program to execute.  * @return The execution result, containing for example the net runtime of the program, and the accumulators.  *  * @throws Exception Thrown, if job submission caused an exception.  */ ;// ------------------------------------------------------------------------ // Program Execution // ------------------------------------------------------------------------ /**  * Execute the given program.  *  * <p>If the executor has not been started before, then this method will start the  * executor and stop it after the execution has completed. This implies that one needs  * to explicitly start the executor for all programs where multiple dataflow parts  * depend on each other. Otherwise, the previous parts will no longer  * be available, because the executor immediately shut down after the execution.</p>  *  * @param plan The plan of the program to execute.  * @return The execution result, containing for example the net runtime of the program, and the accumulators.  *  * @throws Exception Thrown, if job submission caused an exception.  */ public abstract JobExecutionResult executePlan(Plan plan) throws Exception.
true;public,abstract;1;1;/**  * Gets the programs execution plan in a JSON format.  *  * @param plan The program to get the execution plan for.  * @return The execution plan, as a JSON string.  *  * @throws Exception Thrown, if the executor could not connect to the compiler.  */ ;/**  * Gets the programs execution plan in a JSON format.  *  * @param plan The program to get the execution plan for.  * @return The execution plan, as a JSON string.  *  * @throws Exception Thrown, if the executor could not connect to the compiler.  */ public abstract String getOptimizerPlanAsJSON(Plan plan) throws Exception.
true;public,abstract;1;1;/**  * Ends the job session, identified by the given JobID. Jobs can be kept around as sessions,  * if a session timeout is specified. Keeping Jobs as sessions allows users to incrementally  * add new operations to their dataflow, that refer to previous intermediate results of the  * dataflow.  *  * @param jobID The JobID identifying the job session.  * @throws Exception Thrown, if the message to finish the session cannot be delivered.  */ ;/**  * Ends the job session, identified by the given JobID. Jobs can be kept around as sessions,  * if a session timeout is specified. Keeping Jobs as sessions allows users to incrementally  * add new operations to their dataflow, that refer to previous intermediate results of the  * dataflow.  *  * @param jobID The JobID identifying the job session.  * @throws Exception Thrown, if the message to finish the session cannot be delivered.  */ public abstract void endSession(JobID jobID) throws Exception.
true;public,static;1;11;/**  * Creates an executor that runs the plan locally in a multi-threaded environment.  *  * @return A local executor.  */ ;// ------------------------------------------------------------------------ // Executor Factories // ------------------------------------------------------------------------ /**  * Creates an executor that runs the plan locally in a multi-threaded environment.  *  * @return A local executor.  */ public static PlanExecutor createLocalExecutor(Configuration configuration) {     Class<? extends PlanExecutor> leClass = loadExecutorClass(LOCAL_EXECUTOR_CLASS).     try {         return leClass.getConstructor(Configuration.class).newInstance(configuration).     } catch (Throwable t) {         throw new RuntimeException("An error occurred while loading the local executor (" + LOCAL_EXECUTOR_CLASS + ").", t).     } }
true;public,static;5;29;/**  * Creates an executor that runs the plan on a remote environment. The remote executor is typically used  * to send the program to a cluster for execution.  *  * @param hostname The address of the JobManager to send the program to.  * @param port The port of the JobManager to send the program to.  * @param clientConfiguration The configuration for the client (Akka, default.parallelism).  * @param jarFiles A list of jar files that contain the user-defined function (UDF) classes and all classes used  *                 from within the UDFs.  * @param globalClasspaths A list of URLs that are added to the classpath of each user code classloader of the  *                 program. Paths must specify a protocol (e.g. file://) and be accessible on all nodes.  * @return A remote executor.  */ ;/**  * Creates an executor that runs the plan on a remote environment. The remote executor is typically used  * to send the program to a cluster for execution.  *  * @param hostname The address of the JobManager to send the program to.  * @param port The port of the JobManager to send the program to.  * @param clientConfiguration The configuration for the client (Akka, default.parallelism).  * @param jarFiles A list of jar files that contain the user-defined function (UDF) classes and all classes used  *                 from within the UDFs.  * @param globalClasspaths A list of URLs that are added to the classpath of each user code classloader of the  *                 program. Paths must specify a protocol (e.g. file://) and be accessible on all nodes.  * @return A remote executor.  */ public static PlanExecutor createRemoteExecutor(String hostname, int port, Configuration clientConfiguration, List<URL> jarFiles, List<URL> globalClasspaths) {     if (hostname == null) {         throw new IllegalArgumentException("The hostname must not be null.").     }     if (port <= 0 || port > 0xffff) {         throw new IllegalArgumentException("The port value is out of range.").     }     Class<? extends PlanExecutor> reClass = loadExecutorClass(REMOTE_EXECUTOR_CLASS).     List<URL> files = (jarFiles == null) ? Collections.<URL>emptyList() : jarFiles.     List<URL> paths = (globalClasspaths == null) ? Collections.<URL>emptyList() : globalClasspaths.     try {         PlanExecutor executor = (clientConfiguration == null) ? reClass.getConstructor(String.class, int.class, List.class).newInstance(hostname, port, files) : reClass.getConstructor(String.class, int.class, Configuration.class, List.class, List.class).newInstance(hostname, port, clientConfiguration, files, paths).         return executor.     } catch (Throwable t) {         throw new RuntimeException("An error occurred while loading the remote executor (" + REMOTE_EXECUTOR_CLASS + ").", t).     } }
false;private,static;1;13;;private static Class<? extends PlanExecutor> loadExecutorClass(String className) {     try {         Class<?> leClass = Class.forName(className).         return leClass.asSubclass(PlanExecutor.class).     } catch (ClassNotFoundException cnfe) {         throw new RuntimeException("Could not load the executor class (" + className + "). Do you have the 'flink-clients' project in your dependencies?").     } catch (Throwable t) {         throw new RuntimeException("An error occurred while loading the executor (" + className + ").", t).     } }
