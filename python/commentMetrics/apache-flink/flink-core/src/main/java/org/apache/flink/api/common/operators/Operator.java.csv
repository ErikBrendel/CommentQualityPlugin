commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the information about the operators input/output types.  */ ;/**  * Gets the information about the operators input/output types.  */ public OperatorInformation<OUT> getOperatorInfo() {     return operatorInfo. }
true;public;0;3;/**  * Gets the name of the contract instance. The name is only used to describe the contract instance  * in logging output and graphical representations.  *  * @return The contract instance's name.  */ ;/**  * Gets the name of the contract instance. The name is only used to describe the contract instance  * in logging output and graphical representations.  *  * @return The contract instance's name.  */ public String getName() {     return this.name. }
true;public;1;3;/**  * Sets the name of the contract instance. The name is only used to describe the contract instance  * in logging output and graphical representations.  *  * @param name The operator's name.  */ ;/**  * Sets the name of the contract instance. The name is only used to describe the contract instance  * in logging output and graphical representations.  *  * @param name The operator's name.  */ public void setName(String name) {     this.name = name. }
true;public;0;3;/**  * Gets the compiler hints for this contract instance. In the compiler hints, different fields may  * be set (for example the selectivity) that will be evaluated by the pact compiler when generating  * plan alternatives.  *  * @return The compiler hints object.  */ ;/**  * Gets the compiler hints for this contract instance. In the compiler hints, different fields may  * be set (for example the selectivity) that will be evaluated by the pact compiler when generating  * plan alternatives.  *  * @return The compiler hints object.  */ public CompilerHints getCompilerHints() {     return this.compilerHints. }
true;public;0;3;/**  * Gets the stub parameters of this contract. The stub parameters are a map that maps string keys to  * string or integer values. The map is accessible by the user code at runtime. Parameters that the  * user code needs to access at runtime to configure its behavior are typically stored in that configuration  * object.  *  * @return The configuration containing the stub parameters.  */ ;/**  * Gets the stub parameters of this contract. The stub parameters are a map that maps string keys to  * string or integer values. The map is accessible by the user code at runtime. Parameters that the  * user code needs to access at runtime to configure its behavior are typically stored in that configuration  * object.  *  * @return The configuration containing the stub parameters.  */ public Configuration getParameters() {     return this.parameters. }
true;public;2;3;/**  * Sets a stub parameters in the configuration of this contract. The stub parameters are accessible by the user  * code at runtime. Parameters that the user code needs to access at runtime to configure its behavior are  * typically stored as stub parameters.  *  * @see #getParameters()  *  * @param key  *        The parameter key.  * @param value  *        The parameter value.  */ ;/**  * Sets a stub parameters in the configuration of this contract. The stub parameters are accessible by the user  * code at runtime. Parameters that the user code needs to access at runtime to configure its behavior are  * typically stored as stub parameters.  *  * @see #getParameters()  *  * @param key  *        The parameter key.  * @param value  *        The parameter value.  */ public void setParameter(String key, String value) {     this.parameters.setString(key, value). }
true;public;2;3;/**  * Sets a stub parameters in the configuration of this contract. The stub parameters are accessible by the user  * code at runtime. Parameters that the user code needs to access at runtime to configure its behavior are  * typically stored as stub parameters.  *  * @see #getParameters()  *  * @param key  *        The parameter key.  * @param value  *        The parameter value.  */ ;/**  * Sets a stub parameters in the configuration of this contract. The stub parameters are accessible by the user  * code at runtime. Parameters that the user code needs to access at runtime to configure its behavior are  * typically stored as stub parameters.  *  * @see #getParameters()  *  * @param key  *        The parameter key.  * @param value  *        The parameter value.  */ public void setParameter(String key, int value) {     this.parameters.setInteger(key, value). }
true;public;2;3;/**  * Sets a stub parameters in the configuration of this contract. The stub parameters are accessible by the user  * code at runtime. Parameters that the user code needs to access at runtime to configure its behavior are  * typically stored as stub parameters.  *  * @see #getParameters()  * @param key  *        The parameter key.  * @param value  *        The parameter value.  */ ;/**  * Sets a stub parameters in the configuration of this contract. The stub parameters are accessible by the user  * code at runtime. Parameters that the user code needs to access at runtime to configure its behavior are  * typically stored as stub parameters.  *  * @see #getParameters()  * @param key  *        The parameter key.  * @param value  *        The parameter value.  */ public void setParameter(String key, boolean value) {     this.parameters.setBoolean(key, value). }
true;public;0;3;/**  * Gets the parallelism for this contract instance. The parallelism denotes how many  * parallel instances of the user function will be spawned during the execution. If this  * value is {@link ExecutionConfig#PARALLELISM_DEFAULT}, then the system will decide the  * number of parallel instances by itself.  *  * @return The parallelism.  */ ;/**  * Gets the parallelism for this contract instance. The parallelism denotes how many  * parallel instances of the user function will be spawned during the execution. If this  * value is {@link ExecutionConfig#PARALLELISM_DEFAULT}, then the system will decide the  * number of parallel instances by itself.  *  * @return The parallelism.  */ public int getParallelism() {     return this.parallelism. }
true;public;1;3;/**  * Sets the parallelism for this contract instance. The parallelism denotes  * how many parallel instances of the user function will be spawned during the execution.  *  * @param parallelism The number of parallel instances to spawn. Set this value to  *        {@link ExecutionConfig#PARALLELISM_DEFAULT} to let the system decide on its own.  */ ;/**  * Sets the parallelism for this contract instance. The parallelism denotes  * how many parallel instances of the user function will be spawned during the execution.  *  * @param parallelism The number of parallel instances to spawn. Set this value to  *        {@link ExecutionConfig#PARALLELISM_DEFAULT} to let the system decide on its own.  */ public void setParallelism(int parallelism) {     this.parallelism = parallelism. }
true;public;0;4;/**  * Gets the minimum resources for this operator. The minimum resources denotes how many  * resources will be needed at least minimum for the operator or user function during the execution.  *  * @return The minimum resources of this operator.  */ ;/**  * Gets the minimum resources for this operator. The minimum resources denotes how many  * resources will be needed at least minimum for the operator or user function during the execution.  *  * @return The minimum resources of this operator.  */ @PublicEvolving public ResourceSpec getMinResources() {     return this.minResources. }
true;public;0;4;/**  * Gets the preferred resources for this contract instance. The preferred resources denote how many  * resources will be needed in the maximum for the user function during the execution.  *  * @return The preferred resource of this operator.  */ ;/**  * Gets the preferred resources for this contract instance. The preferred resources denote how many  * resources will be needed in the maximum for the user function during the execution.  *  * @return The preferred resource of this operator.  */ @PublicEvolving public ResourceSpec getPreferredResources() {     return this.preferredResources. }
true;public;2;5;/**  * Sets the minimum and preferred resources for this contract instance. The resource denotes  * how many memories and cpu cores of the user function will be consumed during the execution.  *  * @param minResources The minimum resource of this operator.  * @param preferredResources The preferred resource of this operator.  */ ;/**  * Sets the minimum and preferred resources for this contract instance. The resource denotes  * how many memories and cpu cores of the user function will be consumed during the execution.  *  * @param minResources The minimum resource of this operator.  * @param preferredResources The preferred resource of this operator.  */ @PublicEvolving public void setResources(ResourceSpec minResources, ResourceSpec preferredResources) {     this.minResources = minResources.     this.preferredResources = preferredResources. }
true;public;0;3;/**  * Gets the user code wrapper. In the case of a pact, that object will be the stub with the user function,  * in the case of an input or output format, it will be the format object.  *  * @return The class with the user code.  */ ;/**  * Gets the user code wrapper. In the case of a pact, that object will be the stub with the user function,  * in the case of an input or output format, it will be the format object.  *  * @return The class with the user code.  */ public UserCodeWrapper<?> getUserCodeWrapper() {     return null. }
true;public,static;1;4;/**  * Takes a list of operators and creates a cascade of unions of this inputs, if needed.  * If not needed (there was only one operator in the list), then that operator is returned.  *  * @param operators The operators.  * @return The single operator or a cascade of unions of the operators.  */ ;// -------------------------------------------------------------------------------------------- /**  * Takes a list of operators and creates a cascade of unions of this inputs, if needed.  * If not needed (there was only one operator in the list), then that operator is returned.  *  * @param operators The operators.  * @return The single operator or a cascade of unions of the operators.  */ @SuppressWarnings("unchecked") public static <T> Operator<T> createUnionCascade(List<? extends Operator<T>> operators) {     return createUnionCascade((Operator<T>[]) operators.toArray(new Operator[operators.size()])). }
true;public,static;1;3;/**  * Takes a list of operators and creates a cascade of unions of this inputs, if needed.  * If not needed (there was only one operator in the list), then that operator is returned.  *  * @param operators The operators.  * @return The single operator or a cascade of unions of the operators.  */ ;/**  * Takes a list of operators and creates a cascade of unions of this inputs, if needed.  * If not needed (there was only one operator in the list), then that operator is returned.  *  * @param operators The operators.  * @return The single operator or a cascade of unions of the operators.  */ public static <T> Operator<T> createUnionCascade(Operator<T>... operators) {     return createUnionCascade(null, operators). }
true;public,static;2;47;/**  * Takes a single Operator and a list of operators and creates a cascade of unions of this inputs, if needed.  * If not needed there was only one operator as input, then this operator is returned.  *  * @param input1 The first input operator.  * @param input2 The other input operators.  *  * @return The single operator or a cascade of unions of the operators.  */ ;/**  * Takes a single Operator and a list of operators and creates a cascade of unions of this inputs, if needed.  * If not needed there was only one operator as input, then this operator is returned.  *  * @param input1 The first input operator.  * @param input2 The other input operators.  *  * @return The single operator or a cascade of unions of the operators.  */ public static <T> Operator<T> createUnionCascade(Operator<T> input1, Operator<T>... input2) {     // return cases where we don't need a union     if (input2 == null || input2.length == 0) {         return input1.     } else if (input2.length == 1 && input1 == null) {         return input2[0].     }     TypeInformation<T> type = null.     if (input1 != null) {         type = input1.getOperatorInfo().getOutputType().     } else if (input2.length > 0 && input2[0] != null) {         type = input2[0].getOperatorInfo().getOutputType().     } else {         throw new IllegalArgumentException("Could not determine type information from inputs.").     }     // Otherwise construct union cascade     Union<T> lastUnion = new Union<T>(new BinaryOperatorInformation<T, T, T>(type, type, type), "<unknown>").     int i.     if (input2[0] == null) {         throw new IllegalArgumentException("The input may not contain null elements.").     }     lastUnion.setFirstInput(input2[0]).     if (input1 != null) {         lastUnion.setSecondInput(input1).         i = 1.     } else {         if (input2[1] == null) {             throw new IllegalArgumentException("The input may not contain null elements.").         }         lastUnion.setSecondInput(input2[1]).         i = 2.     }     for (. i < input2.length. i++) {         Union<T> tmpUnion = new Union<T>(new BinaryOperatorInformation<T, T, T>(type, type, type), "<unknown>").         tmpUnion.setSecondInput(lastUnion).         if (input2[i] == null) {             throw new IllegalArgumentException("The input may not contain null elements.").         }         tmpUnion.setFirstInput(input2[i]).         lastUnion = tmpUnion.     }     return lastUnion. }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public String toString() {     return getClass().getSimpleName() + " - " + getName(). }
