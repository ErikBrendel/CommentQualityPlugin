commented;modifiers;parameterAmount;loc;comment;code
true;public;1;7;/**  * Adds a data sink to the set of sinks in this program.  *  * @param sink The data sink to add.  */ ;// ------------------------------------------------------------------------ /**  * Adds a data sink to the set of sinks in this program.  *  * @param sink The data sink to add.  */ public void addDataSink(GenericDataSinkBase<?> sink) {     checkNotNull(sink, "The data sink must not be null.").     if (!this.sinks.contains(sink)) {         this.sinks.add(sink).     } }
true;public;0;3;/**  * Gets all the data sinks of this job.  *  * @return All sinks of the program.  */ ;/**  * Gets all the data sinks of this job.  *  * @return All sinks of the program.  */ public Collection<? extends GenericDataSinkBase<?>> getDataSinks() {     return this.sinks. }
true;public;0;3;/**  * Gets the name of this job.  *  * @return The name of the job.  */ ;/**  * Gets the name of this job.  *  * @return The name of the job.  */ public String getJobName() {     return this.jobName. }
true;public;1;4;/**  * Sets the jobName for this Plan.  *  * @param jobName The jobName to set.  */ ;/**  * Sets the jobName for this Plan.  *  * @param jobName The jobName to set.  */ public void setJobName(String jobName) {     checkNotNull(jobName, "The job name must not be null.").     this.jobName = jobName. }
true;public;0;3;/**  * Gets the ID of the job that the dataflow plan belongs to.  * If this ID is not set, then the dataflow represents its own  * independent job.  *  * @return The ID of the job that the dataflow plan belongs to.  */ ;/**  * Gets the ID of the job that the dataflow plan belongs to.  * If this ID is not set, then the dataflow represents its own  * independent job.  *  * @return The ID of the job that the dataflow plan belongs to.  */ public JobID getJobId() {     return jobId. }
true;public;1;3;/**  * Sets the ID of the job that the dataflow plan belongs to.  * If this ID is set to {@code null}, then the dataflow represents its own  * independent job.  *  * @param jobId The ID of the job that the dataflow plan belongs to.  */ ;/**  * Sets the ID of the job that the dataflow plan belongs to.  * If this ID is set to {@code null}, then the dataflow represents its own  * independent job.  *  * @param jobId The ID of the job that the dataflow plan belongs to.  */ public void setJobId(JobID jobId) {     this.jobId = jobId. }
false;public;1;3;;public void setSessionTimeout(long sessionTimeout) {     this.sessionTimeout = sessionTimeout. }
false;public;0;3;;public long getSessionTimeout() {     return sessionTimeout. }
true;public;0;3;/**  * Gets the default parallelism for this job. That degree is always used when an operator  * is not explicitly given a parallelism.  *  * @return The default parallelism for the plan.  */ ;/**  * Gets the default parallelism for this job. That degree is always used when an operator  * is not explicitly given a parallelism.  *  * @return The default parallelism for the plan.  */ public int getDefaultParallelism() {     return this.defaultParallelism. }
true;public;1;6;/**  * Sets the default parallelism for this plan. That degree is always used when an operator  * is not explicitly given a parallelism.  *  * @param defaultParallelism The default parallelism for the plan.  */ ;/**  * Sets the default parallelism for this plan. That degree is always used when an operator  * is not explicitly given a parallelism.  *  * @param defaultParallelism The default parallelism for the plan.  */ public void setDefaultParallelism(int defaultParallelism) {     checkArgument(defaultParallelism >= 1 || defaultParallelism == ExecutionConfig.PARALLELISM_DEFAULT, "The default parallelism must be positive, or ExecutionConfig.PARALLELISM_DEFAULT if the system should use the globally configured default.").     this.defaultParallelism = defaultParallelism. }
true;public;0;3;/**  * Gets the optimizer post-pass class for this job. The post-pass typically creates utility classes  * for data types and is specific to a particular data model (record, tuple, Scala, ...)  *  * @return The name of the class implementing the optimizer post-pass.  */ ;/**  * Gets the optimizer post-pass class for this job. The post-pass typically creates utility classes  * for data types and is specific to a particular data model (record, tuple, Scala, ...)  *  * @return The name of the class implementing the optimizer post-pass.  */ public String getPostPassClassName() {     return "org.apache.flink.optimizer.postpass.JavaApiPostPass". }
true;public;0;6;/**  * Gets the execution config object.  *  * @return The execution config object.  */ ;/**  * Gets the execution config object.  *  * @return The execution config object.  */ public ExecutionConfig getExecutionConfig() {     if (executionConfig == null) {         throw new RuntimeException("Execution config has not been set properly for this plan").     }     return executionConfig. }
true;public;1;3;/**  * Sets the runtime config object defining execution parameters.  *  * @param executionConfig The execution config to use.  */ ;/**  * Sets the runtime config object defining execution parameters.  *  * @param executionConfig The execution config to use.  */ public void setExecutionConfig(ExecutionConfig executionConfig) {     this.executionConfig = executionConfig. }
true;public;1;6;/**  * Traverses the job depth first from all data sinks on towards the sources.  *  * @see Visitable#accept(Visitor)  */ ;// ------------------------------------------------------------------------ /**  * Traverses the job depth first from all data sinks on towards the sources.  *  * @see Visitable#accept(Visitor)  */ @Override public void accept(Visitor<Operator<?>> visitor) {     for (GenericDataSinkBase<?> sink : this.sinks) {         sink.accept(visitor).     } }
true;public;2;7;/**  *  register cache files in program level  * @param entry contains all relevant information  * @param name user defined name of that file  * @throws java.io.IOException  */ ;/**  *  register cache files in program level  * @param entry contains all relevant information  * @param name user defined name of that file  * @throws java.io.IOException  */ public void registerCachedFile(String name, DistributedCacheEntry entry) throws IOException {     if (!this.cacheFile.containsKey(name)) {         this.cacheFile.put(name, entry).     } else {         throw new IOException("cache file " + name + "already exists!").     } }
true;public;0;3;/**  * return the registered caches files  * @return Set of (name, filePath) pairs  */ ;/**  * return the registered caches files  * @return Set of (name, filePath) pairs  */ public Set<Entry<String, DistributedCacheEntry>> getCachedFiles() {     return this.cacheFile.entrySet(). }
false;public;0;5;;public int getMaximumParallelism() {     MaxDopVisitor visitor = new MaxDopVisitor().     accept(visitor).     return Math.max(visitor.maxDop, this.defaultParallelism). }
false;public;1;8;;@Override public boolean preVisit(Operator<?> visitable) {     if (!visitedOperators.add(visitable)) {         return false.     }     this.maxDop = Math.max(this.maxDop, visitable.getParallelism()).     return true. }
false;public;1;2;;@Override public void postVisit(Operator<?> visitable) { }
