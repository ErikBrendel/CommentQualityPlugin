commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public int compare(PojoField o1, PojoField o2) {     return o1.getField().getName().compareTo(o2.getField().getName()). }
false;public;0;5;;@Override @PublicEvolving public boolean isBasicType() {     return false. }
false;public;0;5;;@Override @PublicEvolving public boolean isTupleType() {     return false. }
false;public;0;5;;@Override @PublicEvolving public int getArity() {     return fields.length. }
false;public;0;5;;@Override @PublicEvolving public int getTotalFields() {     return totalFields. }
false;public;0;8;;@Override @PublicEvolving public boolean isSortKeyType() {     // gives only some undefined order.     return false. }
false;public;3;75;;@Override @PublicEvolving public void getFlatFields(String fieldExpression, int offset, List<FlatFieldDescriptor> result) {     Matcher matcher = PATTERN_NESTED_FIELDS_WILDCARD.matcher(fieldExpression).     if (!matcher.matches()) {         throw new InvalidFieldReferenceException("Invalid POJO field reference \"" + fieldExpression + "\".").     }     String field = matcher.group(0).     if (field.equals(ExpressionKeys.SELECT_ALL_CHAR) || field.equals(ExpressionKeys.SELECT_ALL_CHAR_SCALA)) {         // handle select all         int keyPosition = 0.         for (PojoField pField : fields) {             if (pField.getTypeInformation() instanceof CompositeType) {                 CompositeType<?> cType = (CompositeType<?>) pField.getTypeInformation().                 cType.getFlatFields(String.valueOf(ExpressionKeys.SELECT_ALL_CHAR), offset + keyPosition, result).                 keyPosition += cType.getTotalFields() - 1.             } else {                 result.add(new NamedFlatFieldDescriptor(pField.getField().getName(), offset + keyPosition, pField.getTypeInformation())).             }             keyPosition++.         }         return.     } else {         field = matcher.group(1).     }     // get field     int fieldPos = -1.     TypeInformation<?> fieldType = null.     for (int i = 0. i < fields.length. i++) {         if (fields[i].getField().getName().equals(field)) {             fieldPos = i.             fieldType = fields[i].getTypeInformation().             break.         }     }     if (fieldPos == -1) {         throw new InvalidFieldReferenceException("Unable to find field \"" + field + "\" in type " + this + ".").     }     String tail = matcher.group(3).     if (tail == null) {         if (fieldType instanceof CompositeType) {             // forward offset             for (int i = 0. i < fieldPos. i++) {                 offset += this.getTypeAt(i).getTotalFields().             }             // add all fields of composite type             ((CompositeType<?>) fieldType).getFlatFields("*", offset, result).         } else {             // we found the field to add             // compute flat field position by adding skipped fields             int flatFieldPos = offset.             for (int i = 0. i < fieldPos. i++) {                 flatFieldPos += this.getTypeAt(i).getTotalFields().             }             result.add(new FlatFieldDescriptor(flatFieldPos, fieldType)).         }     } else {         if (fieldType instanceof CompositeType<?>) {             // forward offset             for (int i = 0. i < fieldPos. i++) {                 offset += this.getTypeAt(i).getTotalFields().             }             ((CompositeType<?>) fieldType).getFlatFields(tail, offset, result).         } else {             throw new InvalidFieldReferenceException("Nested field expression \"" + tail + "\" not possible on atomic type " + fieldType + ".").         }     } }
false;public;1;41;;@SuppressWarnings("unchecked") @Override @PublicEvolving public <X> TypeInformation<X> getTypeAt(String fieldExpression) {     Matcher matcher = PATTERN_NESTED_FIELDS.matcher(fieldExpression).     if (!matcher.matches()) {         if (fieldExpression.startsWith(ExpressionKeys.SELECT_ALL_CHAR) || fieldExpression.startsWith(ExpressionKeys.SELECT_ALL_CHAR_SCALA)) {             throw new InvalidFieldReferenceException("Wildcard expressions are not allowed here.").         } else {             throw new InvalidFieldReferenceException("Invalid format of POJO field expression \"" + fieldExpression + "\".").         }     }     String field = matcher.group(1).     // get field     int fieldPos = -1.     TypeInformation<?> fieldType = null.     for (int i = 0. i < fields.length. i++) {         if (fields[i].getField().getName().equals(field)) {             fieldPos = i.             fieldType = fields[i].getTypeInformation().             break.         }     }     if (fieldPos == -1) {         throw new InvalidFieldReferenceException("Unable to find field \"" + field + "\" in type " + this + ".").     }     String tail = matcher.group(3).     if (tail == null) {         // we found the type         return (TypeInformation<X>) fieldType.     } else {         if (fieldType instanceof CompositeType<?>) {             return ((CompositeType<?>) fieldType).getTypeAt(tail).         } else {             throw new InvalidFieldReferenceException("Nested field expression \"" + tail + "\" not possible on atomic type " + fieldType + ".").         }     } }
false;public;1;10;;@Override @PublicEvolving public <X> TypeInformation<X> getTypeAt(int pos) {     if (pos < 0 || pos >= this.fields.length) {         throw new IndexOutOfBoundsException().     }     @SuppressWarnings("unchecked")     TypeInformation<X> typed = (TypeInformation<X>) fields[pos].getTypeInformation().     return typed. }
false;protected;0;5;;@Override @PublicEvolving protected TypeComparatorBuilder<T> createTypeComparatorBuilder() {     return new PojoTypeComparatorBuilder(). }
false;public;1;7;;@PublicEvolving public PojoField getPojoFieldAt(int pos) {     if (pos < 0 || pos >= this.fields.length) {         throw new IndexOutOfBoundsException().     }     return this.fields[pos]. }
false;public;0;8;;@PublicEvolving public String[] getFieldNames() {     String[] result = new String[fields.length].     for (int i = 0. i < fields.length. i++) {         result[i] = fields[i].getField().getName().     }     return result. }
false;public;1;10;;@Override @PublicEvolving public int getFieldIndex(String fieldName) {     for (int i = 0. i < fields.length. i++) {         if (fields[i].getField().getName().equals(fieldName)) {             return i.         }     }     return -1. }
false;public;1;14;;@Override @PublicEvolving @SuppressWarnings("unchecked") public TypeSerializer<T> createSerializer(ExecutionConfig config) {     if (config.isForceKryoEnabled()) {         return new KryoSerializer<>(getTypeClass(), config).     }     if (config.isForceAvroEnabled()) {         return AvroUtils.getAvroUtils().createAvroSerializer(getTypeClass()).     }     return createPojoSerializer(config). }
false;public;1;11;;public PojoSerializer<T> createPojoSerializer(ExecutionConfig config) {     TypeSerializer<?>[] fieldSerializers = new TypeSerializer<?>[fields.length].     Field[] reflectiveFields = new Field[fields.length].     for (int i = 0. i < fields.length. i++) {         fieldSerializers[i] = fields[i].getTypeInformation().createSerializer(config).         reflectiveFields[i] = fields[i].getField().     }     return new PojoSerializer<T>(getTypeClass(), fieldSerializers, reflectiveFields, config). }
false;public;1;14;;@Override public boolean equals(Object obj) {     if (obj instanceof PojoTypeInfo) {         @SuppressWarnings("unchecked")         PojoTypeInfo<T> pojoTypeInfo = (PojoTypeInfo<T>) obj.         return pojoTypeInfo.canEqual(this) && super.equals(pojoTypeInfo) && Arrays.equals(fields, pojoTypeInfo.fields) && totalFields == pojoTypeInfo.totalFields.     } else {         return false.     } }
false;public;0;4;;@Override public int hashCode() {     return 31 * (31 * Arrays.hashCode(fields) + totalFields) + super.hashCode(). }
false;public;1;4;;@Override public boolean canEqual(Object obj) {     return obj instanceof PojoTypeInfo. }
false;public;0;10;;@Override public String toString() {     List<String> fieldStrings = new ArrayList<String>().     for (PojoField field : fields) {         fieldStrings.add(field.getField().getName() + ": " + field.getTypeInformation().toString()).     }     return "PojoType<" + getTypeClass().getName() + ", fields = [" + StringUtils.join(fieldStrings, ", ") + "]" + ">". }
false;public;1;5;;@Override public void initializeTypeComparatorBuilder(int size) {     fieldComparators.ensureCapacity(size).     keyFields.ensureCapacity(size). }
false;public;2;5;;@Override public void addComparatorField(int fieldId, TypeComparator<?> comparator) {     fieldComparators.add(comparator).     keyFields.add(fields[fieldId].getField()). }
false;public;1;20;;@Override public TypeComparator<T> createTypeComparator(ExecutionConfig config) {     checkState(keyFields.size() > 0, "No keys were defined for the PojoTypeComparatorBuilder.").     checkState(fieldComparators.size() > 0, "No type comparators were defined for the PojoTypeComparatorBuilder.").     checkState(keyFields.size() == fieldComparators.size(), "Number of key fields and field comparators is not equal.").     return new PojoComparator<T>(keyFields.toArray(new Field[keyFields.size()]), fieldComparators.toArray(new TypeComparator[fieldComparators.size()]), createSerializer(config), getTypeClass()). }
false;public;0;3;;public String getFieldName() {     return fieldName. }
false;public;0;4;;@Override public String toString() {     return "NamedFlatFieldDescriptor [name=" + fieldName + " position=" + getPosition() + " typeInfo=" + getType() + "]". }
