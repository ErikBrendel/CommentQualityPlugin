commented;modifiers;parameterAmount;loc;comment;code
false;public;2;13;;@Override public int compareSerialized(DataInputView firstSource, DataInputView secondSource) throws IOException {     // compare Date part     final int comp = DateComparator.compareSerializedDate(firstSource, secondSource, ascendingComparison).     // compare nanos     if (comp == 0) {         final int i1 = firstSource.readInt().         final int i2 = secondSource.readInt().         final int comp2 = (i1 < i2 ? -1 : (i1 == i2 ? 0 : 1)).         return ascendingComparison ? comp2 : -comp2.     }     return comp. }
false;public;0;4;;@Override public boolean supportsNormalizedKey() {     return true. }
false;public;0;4;;@Override public int getNormalizeKeyLen() {     return 12. }
false;public;1;4;;@Override public boolean isNormalizedKeyPrefixOnly(int keyBytes) {     return keyBytes < 12. }
false;public;4;25;;@Override public void putNormalizedKey(java.util.Date record, MemorySegment target, int offset, int numBytes) {     // put Date key     DateComparator.putNormalizedKeyDate(record, target, offset, numBytes > 8 ? 8 : numBytes).     numBytes -= 8.     offset += 8.     if (numBytes <= 0) {     // nothing to do     } else // put nanos     if (numBytes < 4) {         final int nanos = ((Timestamp) record).getNanos().         for (int i = 0. numBytes > 0. numBytes--, i++) {             target.put(offset + i, (byte) (nanos >>> ((3 - i) << 3))).         }     } else // put nanos with padding     {         final int nanos = ((Timestamp) record).getNanos().         target.putIntBigEndian(offset, nanos).         for (int i = 4. i < numBytes. i++) {             target.put(offset + i, (byte) 0).         }     } }
false;public;0;4;;@Override public SqlTimestampComparator duplicate() {     return new SqlTimestampComparator(ascendingComparison). }
