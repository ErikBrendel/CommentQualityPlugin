commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public int hash(T record) {     if (record != null) {         return wrappedComparator.hash(record).     } else {         return 0.     } }
false;public;1;9;;@Override public void setReference(T toCompare) {     if (toCompare == null) {         nullReference = true.     } else {         nullReference = false.         wrappedComparator.setReference(toCompare).     } }
false;public;1;15;;@Override public boolean equalToReference(T candidate) {     // both values are null     if (candidate == null && nullReference) {         return true.     } else // one value is null     if (candidate == null || nullReference) {         return false.     } else // no null value     {         return wrappedComparator.equalToReference(candidate).     } }
false;public;1;23;;@Override public int compareToReference(TypeComparator<T> referencedComparator) {     NullAwareComparator otherComparator = (NullAwareComparator) referencedComparator.     boolean otherNullReference = otherComparator.nullReference.     // both values are null -> equality     if (nullReference && otherNullReference) {         return 0.     } else // but order is considered     if (nullReference) {         return order ? 1 : -1.     } else // but order is considered     if (otherNullReference) {         return order ? -1 : 1.     } else // no null values     {         return wrappedComparator.compareToReference(otherComparator.wrappedComparator).     } }
false;public;2;21;;@Override public int compare(T first, T second) {     // both values are null -> equality     if (first == null && second == null) {         return 0.     } else // but order is considered     if (first == null) {         return order ? -1 : 1.     } else // but order is considered     if (second == null) {         return order ? 1 : -1.     } else // no null values     {         return wrappedComparator.compare(first, second).     } }
false;public;2;8;;@Override public int compareSerialized(DataInputView firstSource, DataInputView secondSource) throws IOException {     throw new UnsupportedOperationException("Comparator does not support null-aware serialized comparision."). }
false;public;0;4;;@Override public boolean supportsNormalizedKey() {     return wrappedComparator.supportsNormalizedKey(). }
false;public;0;4;;@Override public boolean supportsSerializationWithKeyNormalization() {     return false. }
false;public;0;10;;@Override public int getNormalizeKeyLen() {     int len = wrappedComparator.getNormalizeKeyLen().     if (len == Integer.MAX_VALUE) {         return Integer.MAX_VALUE.     } else {         // add one for a null byte         return len + 1.     } }
false;public;1;4;;@Override public boolean isNormalizedKeyPrefixOnly(int keyBytes) {     return wrappedComparator.isNormalizedKeyPrefixOnly(keyBytes - 1). }
false;public;4;19;;@Override public void putNormalizedKey(T record, MemorySegment target, int offset, int numBytes) {     if (numBytes > 0) {         // write a null byte with padding         if (record == null) {             target.putBoolean(offset, false).             // write padding             for (int j = 0. j < numBytes - 1. j++) {                 target.put(offset + 1 + j, (byte) 0).             }         } else // write a non-null byte with key         {             target.putBoolean(offset, true).             // write key             wrappedComparator.putNormalizedKey(record, target, offset + 1, numBytes - 1).         }     } }
false;public;2;5;;@Override public void writeWithKeyNormalization(T record, DataOutputView target) throws IOException {     throw new UnsupportedOperationException("Record serialization with leading normalized keys not supported."). }
false;public;2;5;;@Override public T readWithKeyDenormalization(T reuse, DataInputView source) throws IOException {     throw new UnsupportedOperationException("Record deserialization with leading normalized keys not supported."). }
false;public;0;4;;@Override public boolean invertNormalizedKey() {     return wrappedComparator.invertNormalizedKey(). }
false;public;0;4;;@Override public TypeComparator<T> duplicate() {     return new NullAwareComparator<T>(wrappedComparator.duplicate(), order). }
false;public;3;11;;@Override public int extractKeys(Object record, Object[] target, int index) {     if (record == null) {         for (int i = 0. i < flatFields. i++) {             target[index + i] = null.         }         return flatFields.     } else {         return wrappedComparator.extractKeys(record, target, index).     } }
false;public;0;16;;@Override public TypeComparator[] getFlatComparators() {     // determine the flat comparators and wrap them again in null-aware comparators     List<TypeComparator<?>> flatComparators = new ArrayList<>().     if (wrappedComparator instanceof CompositeTypeComparator) {         ((CompositeTypeComparator) wrappedComparator).getFlatComparator(flatComparators).     } else {         flatComparators.add(wrappedComparator).     }     TypeComparator<?>[] result = new TypeComparator[flatComparators.size()].     for (int i = 0. i < result.length. i++) {         result[i] = new NullAwareComparator<>(flatComparators.get(i), order).     }     return result. }
