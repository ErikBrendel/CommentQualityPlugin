commented;modifiers;parameterAmount;loc;comment;code
false;public;2;8;;@Override public FieldSet getForwardingTargetFields(int input, int sourceField) {     if (input != 0) {         throw new IndexOutOfBoundsException().     }     return this.fieldMapping.containsKey(sourceField) ? this.fieldMapping.get(sourceField) : FieldSet.EMPTY_SET. }
false;public;2;13;;@Override public int getForwardingSourceField(int input, int targetField) {     if (input != 0) {         throw new IndexOutOfBoundsException().     }     for (Map.Entry<Integer, FieldSet> e : fieldMapping.entrySet()) {         if (e.getValue().contains(targetField)) {             return e.getKey().         }     }     return -1. }
false;public;1;8;;@Override public FieldSet getReadFields(int input) {     if (input != 0) {         throw new IndexOutOfBoundsException().     }     return this.readFields. }
true;public;2;12;/**  * Adds, to the existing information, a field that is forwarded directly  * from the source record(s) to the destination record(s).  *  * @param sourceField the position in the source record(s)  * @param targetField the position in the destination record(s)  */ ;/**  * Adds, to the existing information, a field that is forwarded directly  * from the source record(s) to the destination record(s).  *  * @param sourceField the position in the source record(s)  * @param targetField the position in the destination record(s)  */ public void addForwardedField(int sourceField, int targetField) {     if (isTargetFieldPresent(targetField)) {         throw new InvalidSemanticAnnotationException("Target field " + targetField + " was added twice.").     }     FieldSet targetFields = fieldMapping.get(sourceField).     if (targetFields != null) {         fieldMapping.put(sourceField, targetFields.addField(targetField)).     } else {         fieldMapping.put(sourceField, new FieldSet(targetField)).     } }
false;private;1;8;;private boolean isTargetFieldPresent(int targetField) {     for (FieldSet targetFields : fieldMapping.values()) {         if (targetFields.contains(targetField)) {             return true.         }     }     return false. }
true;public;1;7;/**  * Adds, to the existing information, field(s) that are read in  * the source record(s).  *  * @param readFields the position(s) in the source record(s)  */ ;/**  * Adds, to the existing information, field(s) that are read in  * the source record(s).  *  * @param readFields the position(s) in the source record(s)  */ public void addReadFields(FieldSet readFields) {     if (this.readFields == null) {         this.readFields = readFields.     } else {         this.readFields = this.readFields.addFields(readFields).     } }
false;public;0;4;;@Override public String toString() {     return "SISP(" + this.fieldMapping + ")". }
false;public;2;7;;@Override public FieldSet getForwardingTargetFields(int input, int sourceField) {     if (input != 0) {         throw new IndexOutOfBoundsException().     }     return new FieldSet(sourceField). }
false;public;2;7;;@Override public int getForwardingSourceField(int input, int targetField) {     if (input != 0) {         throw new IndexOutOfBoundsException().     }     return targetField. }
false;public;2;4;;@Override public void addForwardedField(int sourceField, int targetField) {     throw new UnsupportedOperationException("Cannot modify forwarded fields"). }
