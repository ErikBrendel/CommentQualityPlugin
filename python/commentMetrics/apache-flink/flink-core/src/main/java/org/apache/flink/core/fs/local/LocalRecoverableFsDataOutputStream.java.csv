commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void write(int b) throws IOException {     fos.write(b). }
false;public;3;4;;@Override public void write(byte[] b, int off, int len) throws IOException {     fos.write(b, off, len). }
false;public;0;4;;@Override public void flush() throws IOException {     fos.flush(). }
false;public;0;4;;@Override public void sync() throws IOException {     fileChannel.force(true). }
false;public;0;4;;@Override public long getPos() throws IOException {     return fileChannel.position(). }
false;public;0;9;;@Override public ResumeRecoverable persist() throws IOException {     // we call both flush and sync in order to ensure persistence on mounted     // file systems, like NFS, EBS, EFS, ...     flush().     sync().     return new LocalRecoverable(targetFile, tempFile, getPos()). }
false;public;0;6;;@Override public Committer closeForCommit() throws IOException {     final long pos = getPos().     close().     return new LocalCommitter(new LocalRecoverable(targetFile, tempFile, pos)). }
false;public;0;4;;@Override public void close() throws IOException {     fos.close(). }
false;public;0;26;;@Override public void commit() throws IOException {     final File src = recoverable.tempFile().     final File dest = recoverable.targetFile().     // sanity check     if (src.length() != recoverable.offset()) {         // this is not the "clean" case         throw new IOException("Cannot clean commit: File has trailing junk data.").     }     // in order to improve error messages     try {         Files.move(src.toPath(), dest.toPath(), StandardCopyOption.ATOMIC_MOVE).     } catch (UnsupportedOperationException | AtomicMoveNotSupportedException e) {         if (!src.renameTo(dest)) {             throw new IOException("Committing file failed, could not rename " + src + " -> " + dest).         }     } catch (FileAlreadyExistsException e) {         throw new IOException("Committing file failed. Target file already exists: " + dest).     } }
false;public;0;31;;@Override public void commitAfterRecovery() throws IOException {     final File src = recoverable.tempFile().     final File dest = recoverable.targetFile().     final long expectedLength = recoverable.offset().     if (src.exists()) {         if (src.length() > expectedLength) {             // truncate the trailing junk away             try (FileOutputStream fos = new FileOutputStream(src, true)) {                 fos.getChannel().truncate(expectedLength).             }         } else if (src.length() < expectedLength) {             throw new IOException("Missing data in tmp file: " + src).         }         // source still exists, so no renaming happened yet. do it!         Files.move(src.toPath(), dest.toPath(), StandardCopyOption.ATOMIC_MOVE).     } else if (!dest.exists()) {     // neither exists - that can be a sign of     // - (1) a serious problem (file system loss of data)     // - (2) a recovery of a savepoint that is some time old and the users     // removed the files in the meantime.     // TODO how to handle this?     // We probably need an option for users whether this should log,     // or result in an exception or unrecoverable exception     } }
false;public;0;4;;@Override public CommitRecoverable getRecoverable() {     return recoverable. }
