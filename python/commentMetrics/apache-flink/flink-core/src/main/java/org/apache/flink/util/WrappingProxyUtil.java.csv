commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;16;/**  * Expects a proxy, and returns the unproxied delegate.  *  * @param wrappingProxy The initial proxy.  * @param <T> The type of the delegate. Note that all proxies in the chain must be assignable to T.  * @return The unproxied delegate.  */ ;/**  * Expects a proxy, and returns the unproxied delegate.  *  * @param wrappingProxy The initial proxy.  * @param <T> The type of the delegate. Note that all proxies in the chain must be assignable to T.  * @return The unproxied delegate.  */ @SuppressWarnings("unchecked") public static <T> T stripProxy(@Nullable final WrappingProxy<T> wrappingProxy) {     if (wrappingProxy == null) {         return null.     }     T delegate = wrappingProxy.getWrappedDelegate().     int numProxiesStripped = 0.     while (delegate instanceof WrappingProxy) {         throwIfSafetyNetExceeded(++numProxiesStripped).         delegate = ((WrappingProxy<T>) delegate).getWrappedDelegate().     }     return delegate. }
false;private,static;1;6;;private static void throwIfSafetyNetExceeded(final int numProxiesStripped) {     if (numProxiesStripped >= SAFETY_NET_MAX_ITERATIONS) {         throw new IllegalArgumentException(format("Already stripped %d proxies. " + "Are there loops in the object graph?", SAFETY_NET_MAX_ITERATIONS)).     } }
