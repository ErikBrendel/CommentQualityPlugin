commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;4;/**  * Set the originating serializer of this configuration snapshot.  */ ;/**  * Set the originating serializer of this configuration snapshot.  */ @Internal public final void setPriorSerializer(TypeSerializer<T> serializer) {     this.serializer = Preconditions.checkNotNull(serializer). }
true;public,final;1;4;/**  * Set the user code class loader.  * Only relevant if this configuration instance was deserialized from binary form.  *  * <p>This method is not part of the public user-facing API, and cannot be overriden.  *  * @param userCodeClassLoader user code class loader.  */ ;/**  * Set the user code class loader.  * Only relevant if this configuration instance was deserialized from binary form.  *  * <p>This method is not part of the public user-facing API, and cannot be overriden.  *  * @param userCodeClassLoader user code class loader.  */ @Internal public final void setUserCodeClassLoader(ClassLoader userCodeClassLoader) {     this.userCodeClassLoader = Preconditions.checkNotNull(userCodeClassLoader). }
true;public,final;0;4;/**  * Returns the user code class loader.  * Only relevant if this configuration instance was deserialized from binary form.  *  * @return the user code class loader  */ ;/**  * Returns the user code class loader.  * Only relevant if this configuration instance was deserialized from binary form.  *  * @return the user code class loader  */ @Internal public final ClassLoader getUserCodeClassLoader() {     return userCodeClassLoader. }
false;public,final;0;4;;// ---------------------------------------------------------------------------- // Implementation of the TypeSerializerSnapshot interface // ---------------------------------------------------------------------------- @Override public final int getCurrentVersion() {     return ADAPTER_VERSION. }
false;public,final;1;12;;@Override public final void writeSnapshot(DataOutputView out) throws IOException {     checkState(serializer != null, "the prior serializer has not been set on this").     // write the snapshot for a non-updated serializer.     // this mimics the previous behavior where the TypeSerializer was     // Java-serialized, for backwards compatibility     TypeSerializerSerializationUtil.writeSerializer(out, serializer).     // now delegate to the snapshots own writing code     write(out). }
false;public,final;3;12;;@Override public final void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     if (readVersion != ADAPTER_VERSION) {         throw new IOException("Wrong/unexpected version for the TypeSerializerConfigSnapshot: " + readVersion).     }     serializer = TypeSerializerSerializationUtil.tryReadSerializer(in, userCodeClassLoader, true).     // now delegate to the snapshots own reading code     setUserCodeClassLoader(userCodeClassLoader).     read(in). }
true;public,final;0;19;/**  * Creates a serializer using this configuration, that is capable of reading data  * written by the serializer described by this configuration.  *  * @return the restored serializer.  */ ;/**  * Creates a serializer using this configuration, that is capable of reading data  * written by the serializer described by this configuration.  *  * @return the restored serializer.  */ @Override public final TypeSerializer<T> restoreSerializer() {     if (serializer == null) {         throw new IllegalStateException("Trying to restore the prior serializer via TypeSerializerConfigSnapshot, " + "but the prior serializer has not been set.").     } else if (serializer instanceof UnloadableDummyTypeSerializer) {         Throwable originalError = ((UnloadableDummyTypeSerializer<?>) serializer).getOriginalError().         throw new IllegalStateException("Could not Java-deserialize TypeSerializer while restoring checkpoint metadata for serializer " + "snapshot '" + getClass().getName() + "'. " + "Please update to the TypeSerializerSnapshot interface that removes Java Serialization to avoid " + "this problem in the future.", originalError).     } else {         return this.serializer.     } }
false;public;1;27;;@Override public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializer<T> newSerializer) {     if (newSerializer instanceof TypeSerializerConfigSnapshot.SelfResolvingTypeSerializer<?>) {         @SuppressWarnings("unchecked")         SelfResolvingTypeSerializer<T> selfResolvingTypeSerializer = (SelfResolvingTypeSerializer<T>) newSerializer.         return selfResolvingTypeSerializer.resolveSchemaCompatibilityViaRedirectingToNewSnapshotClass(this).     }     // to assist with the redirection     throw new UnsupportedOperationException("Serializer snapshot " + getClass().getName() + " is still implementing the deprecated TypeSerializerConfigSnapshot class.\n" + "Please update it to implement the TypeSerializerSnapshot interface, to enable state evolution as well as being future-proof.\n\n" + "- If possible, you should try to perform the update in-place, i.e. use the same snapshot class under the same name, but change it to implement TypeSerializerSnapshot instead.\n\n" + "- Otherwise, if the above isn't possible (perhaps because the new snapshot is intended to have completely\n" + "  different written contents or intended to have a different class name),\n" + "  retain the old serializer snapshot class (extending TypeSerializerConfigSnapshot) under the same name\n" + "  and give the updated serializer snapshot class (the one extending TypeSerializerSnapshot) a new name.\n" + "  Afterwards, override the TypeSerializerConfigSnapshot#resolveSchemaCompatibility(TypeSerializer)\n" + "  method on the old snapshot to perform the compatibility check based on configuration written by" + "  the old serializer snapshot class."). }
true;;1;2;/**  * Resolve Schema Compatibility.  *  * <p>Given an instance of a {@code TypeSerializerConfigSnapshot} this method should redirect the compatibility  * check to the new {@code TypeSerializerSnapshot} class along with the relevant information as present in the  * given {@code deprecatedConfigSnapshot}.  *  * @param deprecatedConfigSnapshot the not yet migrated config snapshot class.  * @return the compatibility result of the {@code deprecatedConfigSnapshot} with {@code this} serializer.  */ ;/**  * Resolve Schema Compatibility.  *  * <p>Given an instance of a {@code TypeSerializerConfigSnapshot} this method should redirect the compatibility  * check to the new {@code TypeSerializerSnapshot} class along with the relevant information as present in the  * given {@code deprecatedConfigSnapshot}.  *  * @param deprecatedConfigSnapshot the not yet migrated config snapshot class.  * @return the compatibility result of the {@code deprecatedConfigSnapshot} with {@code this} serializer.  */ TypeSerializerSchemaCompatibility<E> resolveSchemaCompatibilityViaRedirectingToNewSnapshotClass(TypeSerializerConfigSnapshot<E> deprecatedConfigSnapshot).
