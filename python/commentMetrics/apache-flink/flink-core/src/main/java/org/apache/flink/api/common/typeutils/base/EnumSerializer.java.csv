commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isImmutableType() {     return true. }
false;public;0;4;;@Override public EnumSerializer<T> duplicate() {     return this. }
false;public;0;5;;@Override public T createInstance() {     checkState(values != null).     return values[0]. }
false;public;1;4;;@Override public T copy(T from) {     return from. }
false;public;2;4;;@Override public T copy(T from, T reuse) {     return from. }
false;public;0;4;;@Override public int getLength() {     return 4. }
false;public;2;5;;@Override public void serialize(T record, DataOutputView target) throws IOException {     // use our own maintained ordinals instead of the actual enum ordinal     target.writeInt(valueToOrdinal.get(record)). }
false;public;1;4;;@Override public T deserialize(DataInputView source) throws IOException {     return values[source.readInt()]. }
false;public;2;4;;@Override public T deserialize(T reuse, DataInputView source) throws IOException {     return values[source.readInt()]. }
false;public;2;4;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     target.write(source, 4). }
false;public;1;11;;@Override public boolean equals(Object obj) {     if (obj instanceof EnumSerializer) {         EnumSerializer<?> other = (EnumSerializer<?>) obj.         return other.enumClass == this.enumClass && Arrays.equals(values, other.values).     } else {         return false.     } }
false;public;0;4;;@Override public int hashCode() {     return enumClass.hashCode(). }
false;private;1;14;;// -------------------------------------------------------------------------------------------- private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {     in.defaultReadObject().     // may be null if this serializer was deserialized from an older version     if (this.values == null) {         this.values = enumClass.getEnumConstants().         this.valueToOrdinal = new EnumMap<>(this.enumClass).         int i = 0.         for (T value : values) {             this.valueToOrdinal.put(value, i++).         }     } }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // Serializer configuration snapshotting & compatibility // -------------------------------------------------------------------------------------------- @Override public EnumSerializerSnapshot<T> snapshotConfiguration() {     return new EnumSerializerSnapshot<>(enumClass, values). }
false;public;0;4;;@Override public int getCurrentVersion() {     return CURRENT_VERSION. }
false;public;1;9;;@Override public void writeSnapshot(DataOutputView out) throws IOException {     checkState(enumClass != null, "Enum class can not be null.").     out.writeUTF(enumClass.getName()).     out.writeInt(previousEnums.length).     for (T enumConstant : previousEnums) {         out.writeUTF(enumConstant.name()).     } }
false;public;3;21;;@Override public void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     enumClass = InstantiationUtil.resolveClassByName(in, userCodeClassLoader).     int numEnumConstants = in.readInt().     @SuppressWarnings("unchecked")     T[] previousEnums = (T[]) Array.newInstance(enumClass, numEnumConstants).     for (int i = 0. i < numEnumConstants. i++) {         String enumName = in.readUTF().         try {             previousEnums[i] = Enum.valueOf(enumClass, enumName).         } catch (IllegalArgumentException e) {             throw new IllegalStateException("Could not create a restore serializer for enum " + enumClass + ". Probably because an enum value was removed.").         }     }     this.previousEnums = previousEnums. }
false;public;0;6;;@Override public TypeSerializer<T> restoreSerializer() {     checkState(enumClass != null, "Enum class can not be null.").     return new EnumSerializer<>(enumClass, previousEnums). }
false;public;1;30;;@Override public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializer<T> newSerializer) {     if (!(newSerializer instanceof EnumSerializer)) {         return TypeSerializerSchemaCompatibility.incompatible().     }     EnumSerializer<T> newEnumSerializer = (EnumSerializer<T>) newSerializer.     if (!enumClass.equals(newEnumSerializer.enumClass)) {         return TypeSerializerSchemaCompatibility.incompatible().     }     T[] currentEnums = enumClass.getEnumConstants().     if (Arrays.equals(previousEnums, currentEnums)) {         return TypeSerializerSchemaCompatibility.compatibleAsIs().     }     Set<T> reconfiguredEnumSet = new LinkedHashSet<>(Arrays.asList(previousEnums)).     reconfiguredEnumSet.addAll(Arrays.asList(currentEnums)).     @SuppressWarnings("unchecked")     T[] reconfiguredEnums = reconfiguredEnumSet.toArray((T[]) Array.newInstance(enumClass, reconfiguredEnumSet.size())).     EnumSerializer<T> reconfiguredSerializer = new EnumSerializer<>(enumClass, reconfiguredEnums).     return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(reconfiguredSerializer). }
false;public;1;9;;@Override public void write(DataOutputView out) throws IOException {     super.write(out).     out.writeInt(enumConstants.size()).     for (String enumConstant : enumConstants) {         out.writeUTF(enumConstant).     } }
false;public;1;27;;@Override public void read(DataInputView in) throws IOException {     super.read(in).     if (getReadVersion() == 1) {         try (final DataInputViewStream inViewWrapper = new DataInputViewStream(in)) {             try {                 T[] legacyEnumConstants = InstantiationUtil.deserializeObject(inViewWrapper, getUserCodeClassLoader()).                 this.enumConstants = buildEnumConstantsList(legacyEnumConstants).             } catch (ClassNotFoundException e) {                 throw new IOException("The requested enum class cannot be found in classpath.", e).             } catch (IllegalArgumentException e) {                 throw new IOException("A previously existing enum constant of " + getTypeClass().getName() + " no longer exists.", e).             }         }     } else if (getReadVersion() == VERSION) {         int numEnumConstants = in.readInt().         this.enumConstants = new ArrayList<>(numEnumConstants).         for (int i = 0. i < numEnumConstants. i++) {             enumConstants.add(in.readUTF()).         }     } else {         throw new IOException("Cannot deserialize EnumSerializerConfigSnapshot with version " + getReadVersion()).     } }
false;public;1;20;;@Override public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializer<T> newSerializer) {     Class<T> enumClass = getTypeClass().     @SuppressWarnings("unchecked")     T[] previousEnums = (T[]) Array.newInstance(enumClass, enumConstants.size()).     for (int i = 0. i < enumConstants.size(). i++) {         String enumName = enumConstants.get(i).         try {             previousEnums[i] = Enum.valueOf(enumClass, enumName).         } catch (IllegalArgumentException e) {             throw new RuntimeException("Could not create a restore serializer for enum " + enumClass + ". Probably because an enum value was removed.").         }     }     return new EnumSerializerSnapshot<>(enumClass, previousEnums).resolveSchemaCompatibility(newSerializer). }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;0;4;;@Override public int[] getCompatibleVersions() {     return new int[] { VERSION, 1 }. }
false;;0;3;;List<String> getEnumConstants() {     return enumConstants. }
false;public;1;4;;@Override public boolean equals(Object obj) {     return super.equals(obj) && enumConstants.equals(((EnumSerializerConfigSnapshot) obj).getEnumConstants()). }
false;public;0;4;;@Override public int hashCode() {     return super.hashCode() * 31 + enumConstants.hashCode(). }
false;private,static;1;9;;private static <T extends Enum<T>> List<String> buildEnumConstantsList(T[] enumConstantsArr) {     List<String> res = new ArrayList<>(enumConstantsArr.length).     for (T enumConstant : enumConstantsArr) {         res.add(enumConstant.name()).     }     return res. }
false;;0;4;;// -------------------------------------------------------------------------------------------- // Test utilities // -------------------------------------------------------------------------------------------- @VisibleForTesting T[] getValues() {     return values. }
false;;0;4;;@VisibleForTesting Map<T, Integer> getValueToOrdinal() {     return valueToOrdinal. }
false;public;0;7;;@Override public String toString() {     return "EnumSerializer{" + "enumClass=" + enumClass + ", values=" + Arrays.toString(values) + '}'. }
