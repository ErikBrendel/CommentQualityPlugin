commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Class<T> getTupleClass() {     return this.tupleClass. }
false;public;0;4;;@Override public boolean isImmutableType() {     return false. }
false;public;0;16;;@Override public int getLength() {     if (length == -2) {         int sum = 0.         for (TypeSerializer<Object> serializer : fieldSerializers) {             if (serializer.getLength() > 0) {                 sum += serializer.getLength().             } else {                 length = -1.                 return length.             }         }         length = sum.     }     return length. }
false;public;0;3;;public int getArity() {     return arity. }
true;public,abstract;1;1;// of immutable Tuples (i.e. Scala Tuples) ;// We use this in the Aggregate and Distinct Operators to create instances // of immutable Tuples (i.e. Scala Tuples) public abstract T createInstance(Object[] fields).
false;public,abstract;2;1;;public abstract T createOrReuseInstance(Object[] fields, T reuse).
false;public;2;6;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     for (int i = 0. i < arity. i++) {         fieldSerializers[i].copy(source, target).     } }
false;public;0;4;;@Override public int hashCode() {     return 31 * Arrays.hashCode(fieldSerializers) + Objects.hash(tupleClass, arity). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (obj instanceof TupleSerializerBase) {         TupleSerializerBase<?> other = (TupleSerializerBase<?>) obj.         return tupleClass == other.tupleClass && Arrays.equals(fieldSerializers, other.fieldSerializers) && arity == other.arity.     } else {         return false.     } }
false;public;0;4;;@VisibleForTesting public TypeSerializer<Object>[] getFieldSerializers() {     return fieldSerializers. }
