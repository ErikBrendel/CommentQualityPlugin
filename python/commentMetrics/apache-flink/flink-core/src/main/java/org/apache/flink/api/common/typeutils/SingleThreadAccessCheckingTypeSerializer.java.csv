commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override public boolean isImmutableType() {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return originalSerializer.isImmutableType().     } }
false;public;0;6;;@Override public TypeSerializer<T> duplicate() {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return new SingleThreadAccessCheckingTypeSerializer<>(originalSerializer.duplicate()).     } }
false;public;0;6;;@Override public T createInstance() {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return originalSerializer.createInstance().     } }
false;public;1;6;;@Override public T copy(T from) {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return originalSerializer.copy(from).     } }
false;public;2;6;;@Override public T copy(T from, T reuse) {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return originalSerializer.copy(from, reuse).     } }
false;public;0;6;;@Override public int getLength() {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return originalSerializer.getLength().     } }
false;public;2;6;;@Override public void serialize(T record, DataOutputView target) throws IOException {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         originalSerializer.serialize(record, target).     } }
false;public;1;6;;@Override public T deserialize(DataInputView source) throws IOException {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return originalSerializer.deserialize(source).     } }
false;public;2;6;;@Override public T deserialize(T reuse, DataInputView source) throws IOException {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return originalSerializer.deserialize(reuse, source).     } }
false;public;2;6;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         originalSerializer.copy(source, target).     } }
false;public;1;8;;@Override public boolean equals(Object obj) {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return obj == this || (obj != null && obj.getClass() == getClass() && originalSerializer.equals(obj)).     } }
false;public;0;6;;@Override public int hashCode() {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return originalSerializer.hashCode().     } }
false;public;0;6;;@Override public TypeSerializerSnapshot<T> snapshotConfiguration() {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         return new SingleThreadAccessCheckingTypeSerializerSnapshot<>(this).     } }
false;protected;0;4;;@Override protected int getCurrentOuterSnapshotVersion() {     return 1. }
false;protected;1;4;;@Override protected TypeSerializer<?>[] getNestedSerializers(SingleThreadAccessCheckingTypeSerializer<T> outerSerializer) {     return new TypeSerializer[] { outerSerializer.originalSerializer }. }
false;protected;1;7;;@SuppressWarnings("unchecked") @Override protected SingleThreadAccessCheckingTypeSerializer<T> createOuterSerializerWithNestedSerializers(TypeSerializer<?>[] nestedSerializers) {     return new SingleThreadAccessCheckingTypeSerializer<>((TypeSerializer<T>) nestedSerializers[0]). }
false;private;1;5;;private void writeObject(ObjectOutputStream outputStream) throws IOException {     try (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {         outputStream.defaultWriteObject().     } }
false;;0;5;;SingleThreadAccessCheck startSingleThreadAccessCheck() {     assert (currentThreadRef.compareAndSet(null, Thread.currentThread())) : "The checker has concurrent access from " + currentThreadRef.get().     return new SingleThreadAccessCheck(currentThreadRef). }
false;private;1;4;;private void readObject(ObjectInputStream inputStream) throws ClassNotFoundException, IOException {     inputStream.defaultReadObject().     currentThreadRef = new AtomicReference<>(). }
false;public;0;5;;@Override public void close() {     assert (currentThreadRef.compareAndSet(Thread.currentThread(), null)) : "The checker has concurrent access from " + currentThreadRef.get(). }
