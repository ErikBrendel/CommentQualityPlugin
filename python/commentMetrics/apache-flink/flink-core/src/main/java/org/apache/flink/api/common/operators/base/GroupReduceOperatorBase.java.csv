commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Sets the order of the elements within a reduce group.  *  * @param order The order for the elements in a reduce group.  */ ;// -------------------------------------------------------------------------------------------- /**  * Sets the order of the elements within a reduce group.  *  * @param order The order for the elements in a reduce group.  */ public void setGroupOrder(Ordering order) {     this.groupOrder = order. }
true;public;0;3;/**  * Gets the order of elements within a reduce group. If no such order has been  * set, this method returns null.  *  * @return The secondary order.  */ ;/**  * Gets the order of elements within a reduce group. If no such order has been  * set, this method returns null.  *  * @return The secondary order.  */ public Ordering getGroupOrder() {     return this.groupOrder. }
true;public;1;9;/**  * Marks the group reduce operation as combinable. Combinable operations may pre-reduce the  * data before the actual group reduce operations. Combinable user-defined functions  * must implement the interface {@link GroupCombineFunction}.  *  * @param combinable Flag to mark the group reduce operation as combinable.  */ ;/**  * Marks the group reduce operation as combinable. Combinable operations may pre-reduce the  * data before the actual group reduce operations. Combinable user-defined functions  * must implement the interface {@link GroupCombineFunction}.  *  * @param combinable Flag to mark the group reduce operation as combinable.  */ public void setCombinable(boolean combinable) {     // sanity check     if (combinable && !GroupCombineFunction.class.isAssignableFrom(this.userFunction.getUserCodeClass())) {         throw new IllegalArgumentException("Cannot set a UDF as combinable if it does not implement the interface " + GroupCombineFunction.class.getName()).     } else {         this.combinable = combinable.     } }
true;public;0;3;/**  * Checks whether the operation is combinable.  *  * @return True, if the UDF is combinable, false if not.  *  * @see #setCombinable(boolean)  */ ;/**  * Checks whether the operation is combinable.  *  * @return True, if the UDF is combinable, false if not.  *  * @see #setCombinable(boolean)  */ public boolean isCombinable() {     return this.combinable. }
false;public;1;12;;public void setCustomPartitioner(Partitioner<?> customPartitioner) {     if (customPartitioner != null) {         int[] keys = getKeyColumns(0).         if (keys == null || keys.length == 0) {             throw new IllegalArgumentException("Cannot use custom partitioner for a non-grouped GroupReduce (AllGroupReduce)").         }         if (keys.length > 1) {             throw new IllegalArgumentException("Cannot use the key partitioner for composite keys (more than one key field)").         }     }     this.customPartitioner = customPartitioner. }
false;public;0;3;;public Partitioner<?> getCustomPartitioner() {     return customPartitioner. }
false;private;4;9;;private TypeComparator<IN> getTypeComparator(TypeInformation<IN> typeInfo, int[] sortColumns, boolean[] sortOrderings, ExecutionConfig executionConfig) {     if (typeInfo instanceof CompositeType) {         return ((CompositeType<IN>) typeInfo).createComparator(sortColumns, sortOrderings, 0, executionConfig).     } else if (typeInfo instanceof AtomicType) {         return ((AtomicType<IN>) typeInfo).createComparator(sortOrderings[0], executionConfig).     }     throw new InvalidProgramException("Input type of GroupReduce must be one of composite types or atomic types."). }
false;public;2;4;;@Override public int compare(IN o1, IN o2) {     return sortComparator.compare(o1, o2). }
false;protected;3;62;;// -------------------------------------------------------------------------------------------- @Override protected List<OUT> executeOnCollections(List<IN> inputData, RuntimeContext ctx, ExecutionConfig executionConfig) throws Exception {     GroupReduceFunction<IN, OUT> function = this.userFunction.getUserCodeObject().     UnaryOperatorInformation<IN, OUT> operatorInfo = getOperatorInfo().     TypeInformation<IN> inputType = operatorInfo.getInputType().     int[] keyColumns = getKeyColumns(0).     int[] sortColumns = keyColumns.     boolean[] sortOrderings = new boolean[sortColumns.length].     if (groupOrder != null) {         sortColumns = ArrayUtils.addAll(sortColumns, groupOrder.getFieldPositions()).         sortOrderings = ArrayUtils.addAll(sortOrderings, groupOrder.getFieldSortDirections()).     }     if (sortColumns.length == 0) {         // => all reduce. No comparator         checkArgument(sortOrderings.length == 0).     } else {         final TypeComparator<IN> sortComparator = getTypeComparator(inputType, sortColumns, sortOrderings, executionConfig).         Collections.sort(inputData, new Comparator<IN>() {              @Override             public int compare(IN o1, IN o2) {                 return sortComparator.compare(o1, o2).             }         }).     }     FunctionUtils.setFunctionRuntimeContext(function, ctx).     FunctionUtils.openFunction(function, this.parameters).     ArrayList<OUT> result = new ArrayList<OUT>().     if (inputData.size() > 0) {         final TypeSerializer<IN> inputSerializer = inputType.createSerializer(executionConfig).         if (keyColumns.length == 0) {             TypeSerializer<OUT> outSerializer = getOperatorInfo().getOutputType().createSerializer(executionConfig).             List<IN> inputDataCopy = new ArrayList<IN>(inputData.size()).             for (IN in : inputData) {                 inputDataCopy.add(inputSerializer.copy(in)).             }             CopyingListCollector<OUT> collector = new CopyingListCollector<OUT>(result, outSerializer).             function.reduce(inputDataCopy, collector).         } else {             boolean[] keyOrderings = new boolean[keyColumns.length].             final TypeComparator<IN> comparator = getTypeComparator(inputType, keyColumns, keyOrderings, executionConfig).             ListKeyGroupedIterator<IN> keyedIterator = new ListKeyGroupedIterator<IN>(inputData, inputSerializer, comparator).             TypeSerializer<OUT> outSerializer = getOperatorInfo().getOutputType().createSerializer(executionConfig).             CopyingListCollector<OUT> collector = new CopyingListCollector<OUT>(result, outSerializer).             while (keyedIterator.nextKey()) {                 function.reduce(keyedIterator.getValues(), collector).             }         }     }     FunctionUtils.closeFunction(function).     return result. }
