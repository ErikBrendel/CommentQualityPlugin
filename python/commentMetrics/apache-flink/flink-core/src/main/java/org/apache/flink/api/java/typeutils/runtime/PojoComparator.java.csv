commented;modifiers;parameterAmount;loc;comment;code
false;private;1;8;;private void writeObject(ObjectOutputStream out) throws IOException, ClassNotFoundException {     out.defaultWriteObject().     out.writeInt(keyFields.length).     for (Field field : keyFields) {         FieldSerializer.serializeField(field, out).     } }
false;private;1;9;;private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {     in.defaultReadObject().     int numKeyFields = in.readInt().     keyFields = new Field[numKeyFields].     for (int i = 0. i < numKeyFields. i++) {         keyFields[i] = FieldSerializer.deserializeField(in).     } }
false;public;0;3;;public Field[] getKeyFields() {     return this.keyFields. }
false;public;1;11;;@SuppressWarnings({ "rawtypes", "unchecked" }) @Override public void getFlatComparator(List<TypeComparator> flatComparators) {     for (int i = 0. i < comparators.length. i++) {         if (comparators[i] instanceof CompositeTypeComparator) {             ((CompositeTypeComparator) comparators[i]).getFlatComparator(flatComparators).         } else {             flatComparators.add(comparators[i]).         }     } }
true;public,final;2;11;/**  * This method is handling the IllegalAccess exceptions of Field.get()  */ ;/**  * This method is handling the IllegalAccess exceptions of Field.get()  */ public final Object accessField(Field field, Object object) {     try {         object = field.get(object).     } catch (NullPointerException npex) {         throw new NullKeyFieldException("Unable to access field " + field + " on object " + object).     } catch (IllegalAccessException iaex) {         throw new RuntimeException("This should not happen since we call setAccesssible(true) in PojoTypeInfo." + " fields: " + field + " obj: " + object).     }     return object. }
false;public;1;16;;@Override public int hash(T value) {     int i = 0.     int code = 0.     for (. i < this.keyFields.length. i++) {         code *= TupleComparatorBase.HASH_SALT[i & 0x1F].         try {             code += this.comparators[i].hash(accessField(keyFields[i], value)).         } catch (NullPointerException npe) {             throw new RuntimeException("A NullPointerException occured while accessing a key field in a POJO. " + "Most likely, the value grouped/joined on is null. Field name: " + keyFields[i].getName(), npe).         }     }     return code. }
false;public;1;7;;@Override public void setReference(T toCompare) {     int i = 0.     for (. i < this.keyFields.length. i++) {         this.comparators[i].setReference(accessField(keyFields[i], toCompare)).     } }
false;public;1;10;;@Override public boolean equalToReference(T candidate) {     int i = 0.     for (. i < this.keyFields.length. i++) {         if (!this.comparators[i].equalToReference(accessField(keyFields[i], candidate))) {             return false.         }     }     return true. }
false;public;1;18;;@Override public int compareToReference(TypeComparator<T> referencedComparator) {     PojoComparator<T> other = (PojoComparator<T>) referencedComparator.     int i = 0.     try {         for (. i < this.keyFields.length. i++) {             int cmp = this.comparators[i].compareToReference(other.comparators[i]).             if (cmp != 0) {                 return cmp.             }         }         return 0.     } catch (NullPointerException npex) {         throw new NullKeyFieldException(this.keyFields[i].toString()).     } }
false;public;2;12;;@Override public int compare(T first, T second) {     int i = 0.     for (. i < keyFields.length. i++) {         int cmp = comparators[i].compare(accessField(keyFields[i], first), accessField(keyFields[i], second)).         if (cmp != 0) {             return cmp.         }     }     return 0. }
false;public;2;10;;@Override public int compareSerialized(DataInputView firstSource, DataInputView secondSource) throws IOException {     T first = this.serializer.createInstance().     T second = this.serializer.createInstance().     first = this.serializer.deserialize(first, firstSource).     second = this.serializer.deserialize(second, secondSource).     return this.compare(first, second). }
false;public;0;4;;@Override public boolean supportsNormalizedKey() {     return this.numLeadingNormalizableKeys > 0. }
false;public;0;4;;@Override public int getNormalizeKeyLen() {     return this.normalizableKeyPrefixLen. }
false;public;1;6;;@Override public boolean isNormalizedKeyPrefixOnly(int keyBytes) {     return this.numLeadingNormalizableKeys < this.keyFields.length || this.normalizableKeyPrefixLen == Integer.MAX_VALUE || this.normalizableKeyPrefixLen > keyBytes. }
false;public;4;12;;@Override public void putNormalizedKey(T value, MemorySegment target, int offset, int numBytes) {     int i = 0.     for (. i < this.numLeadingNormalizableKeys && numBytes > 0. i++) {         int len = this.normalizedKeyLengths[i].         len = numBytes >= len ? len : numBytes.         this.comparators[i].putNormalizedKey(accessField(keyFields[i], value), target, offset, len).         numBytes -= len.         offset += len.     } }
false;public;0;4;;@Override public boolean invertNormalizedKey() {     return this.invertNormKey. }
false;public;0;4;;@Override public boolean supportsSerializationWithKeyNormalization() {     return false. }
false;public;2;4;;@Override public void writeWithKeyNormalization(T record, DataOutputView target) throws IOException {     throw new UnsupportedOperationException(). }
false;public;2;4;;@Override public T readWithKeyDenormalization(T reuse, DataInputView source) throws IOException {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public PojoComparator<T> duplicate() {     return new PojoComparator<T>(this). }
false;public;3;8;;@Override public int extractKeys(Object record, Object[] target, int index) {     int localIndex = index.     for (int i = 0. i < comparators.length. i++) {         localIndex += comparators[i].extractKeys(accessField(keyFields[i], record), target, localIndex).     }     return localIndex - index. }
