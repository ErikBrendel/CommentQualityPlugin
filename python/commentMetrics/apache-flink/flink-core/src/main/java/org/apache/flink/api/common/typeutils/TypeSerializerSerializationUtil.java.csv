commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Writes a {@link TypeSerializer} to the provided data output view.  *  * <p>It is written with a format that can be later read again using  * {@link #tryReadSerializer(DataInputView, ClassLoader, boolean)}.  *  * @param out the data output view.  * @param serializer the serializer to write.  *  * @param <T> Data type of the serializer.  *  * @throws IOException  */ ;/**  * Writes a {@link TypeSerializer} to the provided data output view.  *  * <p>It is written with a format that can be later read again using  * {@link #tryReadSerializer(DataInputView, ClassLoader, boolean)}.  *  * @param out the data output view.  * @param serializer the serializer to write.  *  * @param <T> Data type of the serializer.  *  * @throws IOException  */ public static <T> void writeSerializer(DataOutputView out, TypeSerializer<T> serializer) throws IOException {     new TypeSerializerSerializationUtil.TypeSerializerSerializationProxy<>(serializer).write(out). }
true;public,static;2;3;/**  * Reads from a data input view a {@link TypeSerializer} that was previously  * written using {@link #writeSerializer(DataOutputView, TypeSerializer)}.  *  * <p>If deserialization fails for any reason (corrupted serializer bytes, serializer class  * no longer in classpath, serializer class no longer valid, etc.), an {@link IOException} is thrown.  *  * @param in the data input view.  * @param userCodeClassLoader the user code class loader to use.  *  * @param <T> Data type of the serializer.  *  * @return the deserialized serializer.  */ ;/**  * Reads from a data input view a {@link TypeSerializer} that was previously  * written using {@link #writeSerializer(DataOutputView, TypeSerializer)}.  *  * <p>If deserialization fails for any reason (corrupted serializer bytes, serializer class  * no longer in classpath, serializer class no longer valid, etc.), an {@link IOException} is thrown.  *  * @param in the data input view.  * @param userCodeClassLoader the user code class loader to use.  *  * @param <T> Data type of the serializer.  *  * @return the deserialized serializer.  */ public static <T> TypeSerializer<T> tryReadSerializer(DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     return tryReadSerializer(in, userCodeClassLoader, false). }
true;public,static;3;20;/**  * Reads from a data input view a {@link TypeSerializer} that was previously  * written using {@link #writeSerializer(DataOutputView, TypeSerializer)}.  *  * <p>If deserialization fails due to any exception, users can opt to use a dummy  * {@link UnloadableDummyTypeSerializer} to hold the serializer bytes, otherwise an {@link IOException} is thrown.  *  * @param in the data input view.  * @param userCodeClassLoader the user code class loader to use.  * @param useDummyPlaceholder whether or not to use a dummy {@link UnloadableDummyTypeSerializer} to hold the  *                            serializer bytes in the case of a {@link ClassNotFoundException} or  *                            {@link InvalidClassException}.  *  * @param <T> Data type of the serializer.  *  * @return the deserialized serializer.  */ ;/**  * Reads from a data input view a {@link TypeSerializer} that was previously  * written using {@link #writeSerializer(DataOutputView, TypeSerializer)}.  *  * <p>If deserialization fails due to any exception, users can opt to use a dummy  * {@link UnloadableDummyTypeSerializer} to hold the serializer bytes, otherwise an {@link IOException} is thrown.  *  * @param in the data input view.  * @param userCodeClassLoader the user code class loader to use.  * @param useDummyPlaceholder whether or not to use a dummy {@link UnloadableDummyTypeSerializer} to hold the  *                            serializer bytes in the case of a {@link ClassNotFoundException} or  *                            {@link InvalidClassException}.  *  * @param <T> Data type of the serializer.  *  * @return the deserialized serializer.  */ public static <T> TypeSerializer<T> tryReadSerializer(DataInputView in, ClassLoader userCodeClassLoader, boolean useDummyPlaceholder) throws IOException {     final TypeSerializerSerializationUtil.TypeSerializerSerializationProxy<T> proxy = new TypeSerializerSerializationUtil.TypeSerializerSerializationProxy<>(userCodeClassLoader).     try {         proxy.read(in).         return proxy.getTypeSerializer().     } catch (UnloadableTypeSerializerException e) {         if (useDummyPlaceholder) {             LOG.warn("Could not read a requested serializer. Replaced with a UnloadableDummyTypeSerializer.", e.getCause()).             return new UnloadableDummyTypeSerializer<>(e.getSerializerBytes(), e.getCause()).         } else {             throw e.         }     } }
true;public,static;2;22;/**  * Write a list of serializers and their corresponding config snapshots to the provided  * data output view. This method writes in a fault tolerant way, so that when read again  * using {@link #readSerializersAndConfigsWithResilience(DataInputView, ClassLoader)}, if  * deserialization of the serializer fails, its configuration snapshot will remain intact.  *  * <p>Specifically, all written serializers and their config snapshots are indexed by their  * offset positions within the serialized bytes. The serialization format is as follows:  * <ul>  *     <li>1. number of serializer and configuration snapshot pairs.</li>  *     <li>2. offsets of each serializer and configuration snapshot, in order.</li>  *     <li>3. total number of bytes for the serialized serializers and the config snapshots.</li>  *     <li>4. serialized serializers and the config snapshots.</li>  * </ul>  *  * @param out the data output view.  * @param serializersAndConfigs serializer and configuration snapshot pairs  *  * @throws IOException  */ ;/**  * Write a list of serializers and their corresponding config snapshots to the provided  * data output view. This method writes in a fault tolerant way, so that when read again  * using {@link #readSerializersAndConfigsWithResilience(DataInputView, ClassLoader)}, if  * deserialization of the serializer fails, its configuration snapshot will remain intact.  *  * <p>Specifically, all written serializers and their config snapshots are indexed by their  * offset positions within the serialized bytes. The serialization format is as follows:  * <ul>  *     <li>1. number of serializer and configuration snapshot pairs.</li>  *     <li>2. offsets of each serializer and configuration snapshot, in order.</li>  *     <li>3. total number of bytes for the serialized serializers and the config snapshots.</li>  *     <li>4. serialized serializers and the config snapshots.</li>  * </ul>  *  * @param out the data output view.  * @param serializersAndConfigs serializer and configuration snapshot pairs  *  * @throws IOException  */ public static void writeSerializersAndConfigsWithResilience(DataOutputView out, List<Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> serializersAndConfigs) throws IOException {     try (ByteArrayOutputStreamWithPos bufferWithPos = new ByteArrayOutputStreamWithPos().         DataOutputViewStreamWrapper bufferWrapper = new DataOutputViewStreamWrapper(bufferWithPos)) {         out.writeInt(serializersAndConfigs.size()).         for (Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>> serAndConfSnapshot : serializersAndConfigs) {             out.writeInt(bufferWithPos.getPosition()).             writeSerializer(bufferWrapper, serAndConfSnapshot.f0).             out.writeInt(bufferWithPos.getPosition()).             TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(bufferWrapper, (TypeSerializerSnapshot) serAndConfSnapshot.f1, serAndConfSnapshot.f0).         }         out.writeInt(bufferWithPos.getPosition()).         out.write(bufferWithPos.getBuf(), 0, bufferWithPos.getPosition()).     } }
true;public,static;2;46;/**  * Reads from a data input view a list of serializers and their corresponding config snapshots  * written using {@link #writeSerializersAndConfigsWithResilience(DataOutputView, List)}.  *  * <p>If deserialization for serializers fails due to any exception, users can opt to use a dummy  * {@link UnloadableDummyTypeSerializer} to hold the serializer bytes  *  * @param in the data input view.  * @param userCodeClassLoader the user code class loader to use.  *  * @return the deserialized serializer and config snapshot pairs.  *  * @throws IOException  */ ;/**  * Reads from a data input view a list of serializers and their corresponding config snapshots  * written using {@link #writeSerializersAndConfigsWithResilience(DataOutputView, List)}.  *  * <p>If deserialization for serializers fails due to any exception, users can opt to use a dummy  * {@link UnloadableDummyTypeSerializer} to hold the serializer bytes  *  * @param in the data input view.  * @param userCodeClassLoader the user code class loader to use.  *  * @return the deserialized serializer and config snapshot pairs.  *  * @throws IOException  */ public static List<Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> readSerializersAndConfigsWithResilience(DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     int numSerializersAndConfigSnapshots = in.readInt().     int[] offsets = new int[numSerializersAndConfigSnapshots * 2].     for (int i = 0. i < numSerializersAndConfigSnapshots. i++) {         offsets[i * 2] = in.readInt().         offsets[i * 2 + 1] = in.readInt().     }     int totalBytes = in.readInt().     byte[] buffer = new byte[totalBytes].     in.readFully(buffer).     List<Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> serializersAndConfigSnapshots = new ArrayList<>(numSerializersAndConfigSnapshots).     TypeSerializer<?> serializer.     TypeSerializerSnapshot<?> configSnapshot.     try (ByteArrayInputStreamWithPos bufferWithPos = new ByteArrayInputStreamWithPos(buffer).         DataInputViewStreamWrapper bufferWrapper = new DataInputViewStreamWrapper(bufferWithPos)) {         for (int i = 0. i < numSerializersAndConfigSnapshots. i++) {             bufferWithPos.setPosition(offsets[i * 2]).             serializer = tryReadSerializer(bufferWrapper, userCodeClassLoader, true).             bufferWithPos.setPosition(offsets[i * 2 + 1]).             configSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(bufferWrapper, userCodeClassLoader, serializer).             if (serializer instanceof LegacySerializerSnapshotTransformer) {                 configSnapshot = transformLegacySnapshot(serializer, configSnapshot).             }             serializersAndConfigSnapshots.add(new Tuple2<>(serializer, configSnapshot)).         }     }     return serializersAndConfigSnapshots. }
false;private,static;2;7;;@SuppressWarnings("unchecked") private static <T, U> TypeSerializerSnapshot<T> transformLegacySnapshot(TypeSerializer<T> serializer, TypeSerializerSnapshot<U> configSnapshot) {     LegacySerializerSnapshotTransformer<T> transformation = (LegacySerializerSnapshotTransformer<T>) serializer.     return transformation.transformLegacySerializerSnapshot(configSnapshot). }
false;public;0;3;;public TypeSerializer<T> getTypeSerializer() {     return typeSerializer. }
false;public;1;20;;@Override public void write(DataOutputView out) throws IOException {     super.write(out).     if (typeSerializer instanceof UnloadableDummyTypeSerializer) {         UnloadableDummyTypeSerializer<T> dummyTypeSerializer = (UnloadableDummyTypeSerializer<T>) this.typeSerializer.         byte[] serializerBytes = dummyTypeSerializer.getActualBytes().         out.write(serializerBytes.length).         out.write(serializerBytes).     } else {         // write in a way that allows the stream to recover from exceptions         try (ByteArrayOutputStreamWithPos streamWithPos = new ByteArrayOutputStreamWithPos()) {             InstantiationUtil.serializeObject(streamWithPos, typeSerializer).             out.writeInt(streamWithPos.getPosition()).             out.write(streamWithPos.getBuf(), 0, streamWithPos.getPosition()).         }     } }
false;public;1;23;;@SuppressWarnings("unchecked") @Override public void read(DataInputView in) throws IOException {     super.read(in).     // read in a way that allows the stream to recover from exceptions     int serializerBytes = in.readInt().     byte[] buffer = new byte[serializerBytes].     in.readFully(buffer).     ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader().     try (InstantiationUtil.FailureTolerantObjectInputStream ois = new InstantiationUtil.FailureTolerantObjectInputStream(new ByteArrayInputStream(buffer), userClassLoader)) {         Thread.currentThread().setContextClassLoader(userClassLoader).         typeSerializer = (TypeSerializer<T>) ois.readObject().     } catch (Exception e) {         throw new UnloadableTypeSerializerException(e, buffer).     } finally {         Thread.currentThread().setContextClassLoader(previousClassLoader).     } }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;0;3;;public byte[] getSerializerBytes() {     return serializerBytes. }
