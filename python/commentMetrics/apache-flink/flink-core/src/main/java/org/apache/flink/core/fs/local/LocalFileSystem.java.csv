commented;modifiers;parameterAmount;loc;comment;code
false;public;3;6;;// ------------------------------------------------------------------------ @Override public BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len) throws IOException {     return new BlockLocation[] { new LocalBlockLocation(hostName, file.getLen()) }. }
false;public;1;11;;@Override public FileStatus getFileStatus(Path f) throws IOException {     final File path = pathToFile(f).     if (path.exists()) {         return new LocalFileStatus(path, this).     } else {         throw new FileNotFoundException("File " + f + " does not exist or the user running " + "Flink ('" + System.getProperty("user.name") + "') has insufficient permissions to access it.").     } }
false;public;0;4;;@Override public URI getUri() {     return LOCAL_URI. }
false;public;0;4;;@Override public Path getWorkingDirectory() {     return new Path(workingDir). }
false;public;0;4;;@Override public Path getHomeDirectory() {     return new Path(homeDir). }
false;public;2;4;;@Override public FSDataInputStream open(final Path f, final int bufferSize) throws IOException {     return open(f). }
false;public;1;5;;@Override public FSDataInputStream open(final Path f) throws IOException {     final File file = pathToFile(f).     return new LocalDataInputStream(file). }
false;public;0;4;;@Override public LocalRecoverableWriter createRecoverableWriter() throws IOException {     return new LocalRecoverableWriter(this). }
false;public;1;5;;@Override public boolean exists(Path f) throws IOException {     final File path = pathToFile(f).     return path.exists(). }
false;public;1;24;;@Override public FileStatus[] listStatus(final Path f) throws IOException {     final File localf = pathToFile(f).     FileStatus[] results.     if (!localf.exists()) {         return null.     }     if (localf.isFile()) {         return new FileStatus[] { new LocalFileStatus(localf, this) }.     }     final String[] names = localf.list().     if (names == null) {         return null.     }     results = new FileStatus[names.length].     for (int i = 0. i < names.length. i++) {         results[i] = getFileStatus(new Path(f, names[i])).     }     return results. }
false;public;2;17;;@Override public boolean delete(final Path f, final boolean recursive) throws IOException {     final File file = pathToFile(f).     if (file.isFile()) {         return file.delete().     } else if ((!recursive) && file.isDirectory()) {         File[] containedFiles = file.listFiles().         if (containedFiles == null) {             throw new IOException("Directory " + file.toString() + " does not exist or an I/O error occurred").         } else if (containedFiles.length != 0) {             throw new IOException("Directory " + file.toString() + " is not empty").         }     }     return delete(file). }
true;private;1;19;/**  * Deletes the given file or directory.  *  * @param f  *        the file to be deleted  * @return <code>true</code> if all files were deleted successfully, <code>false</code> otherwise  * @throws IOException  *         thrown if an error occurred while deleting the files/directories  */ ;/**  * Deletes the given file or directory.  *  * @param f  *        the file to be deleted  * @return <code>true</code> if all files were deleted successfully, <code>false</code> otherwise  * @throws IOException  *         thrown if an error occurred while deleting the files/directories  */ private boolean delete(final File f) throws IOException {     if (f.isDirectory()) {         final File[] files = f.listFiles().         if (files != null) {             for (File file : files) {                 final boolean del = delete(file).                 if (!del) {                     return false.                 }             }         }     } else {         return f.delete().     }     // Now directory is empty     return f.delete(). }
true;public;1;5;/**  * Recursively creates the directory specified by the provided path.  *  * @return <code>true</code>if the directories either already existed or have been created successfully,  *         <code>false</code> otherwise  * @throws IOException  *         thrown if an error occurred while creating the directory/directories  */ ;/**  * Recursively creates the directory specified by the provided path.  *  * @return <code>true</code>if the directories either already existed or have been created successfully,  *         <code>false</code> otherwise  * @throws IOException  *         thrown if an error occurred while creating the directory/directories  */ @Override public boolean mkdirs(final Path f) throws IOException {     checkNotNull(f, "path is null").     return mkdirsInternal(pathToFile(f)). }
false;private;1;16;;private boolean mkdirsInternal(File file) throws IOException {     if (file.isDirectory()) {         return true.     } else if (file.exists() && !file.isDirectory()) {         // exists and is not a directory -> is a regular file         throw new FileAlreadyExistsException(file.getAbsolutePath()).     } else {         File parent = file.getParentFile().         return (parent == null || mkdirsInternal(parent)) && (file.mkdir() || file.isDirectory()).     } }
false;public;2;16;;@Override public FSDataOutputStream create(final Path filePath, final WriteMode overwrite) throws IOException {     checkNotNull(filePath, "filePath").     if (exists(filePath) && overwrite == WriteMode.NO_OVERWRITE) {         throw new FileAlreadyExistsException("File already exists: " + filePath).     }     final Path parent = filePath.getParent().     if (parent != null && !mkdirs(parent)) {         throw new IOException("Mkdirs failed to create " + parent).     }     final File file = pathToFile(filePath).     return new LocalDataOutputStream(file). }
false;public;2;20;;@Override public boolean rename(final Path src, final Path dst) throws IOException {     final File srcFile = pathToFile(src).     final File dstFile = pathToFile(dst).     final File dstParent = dstFile.getParentFile().     // Files.move fails if the destination directory doesn't exist     // noinspection ResultOfMethodCallIgnored -- we don't care if the directory existed or was created     dstParent.mkdirs().     try {         Files.move(srcFile.toPath(), dstFile.toPath(), StandardCopyOption.REPLACE_EXISTING).         return true.     } catch (NoSuchFileException | AccessDeniedException | DirectoryNotEmptyException | SecurityException ex) {         // catch the errors that are regular "move failed" exceptions and return false         return false.     } }
false;public;0;4;;@Override public boolean isDistributedFS() {     return false. }
false;public;0;4;;@Override public FileSystemKind getKind() {     return FileSystemKind.FILE_SYSTEM. }
true;public;1;6;/**  * Converts the given Path to a File for this file system.  *  * <p>If the path is not absolute, it is interpreted relative to this FileSystem's working directory.  */ ;// ------------------------------------------------------------------------ /**  * Converts the given Path to a File for this file system.  *  * <p>If the path is not absolute, it is interpreted relative to this FileSystem's working directory.  */ public File pathToFile(Path path) {     if (!path.isAbsolute()) {         path = new Path(getWorkingDirectory(), path).     }     return new File(path.toUri().getPath()). }
true;public,static;0;3;/**  * Gets the URI that represents the local file system.  * That URI is {@code "file:/"} on Windows platforms and {@code "file:///"} on other  * UNIX family platforms.  *  * @return The URI that represents the local file system.  */ ;// ------------------------------------------------------------------------ /**  * Gets the URI that represents the local file system.  * That URI is {@code "file:/"} on Windows platforms and {@code "file:///"} on other  * UNIX family platforms.  *  * @return The URI that represents the local file system.  */ public static URI getLocalFsURI() {     return LOCAL_URI. }
true;public,static;0;3;/**  * Gets the shared instance of this file system.  *  * @return The shared instance of this file system.  */ ;/**  * Gets the shared instance of this file system.  *  * @return The shared instance of this file system.  */ public static LocalFileSystem getSharedInstance() {     return INSTANCE. }
