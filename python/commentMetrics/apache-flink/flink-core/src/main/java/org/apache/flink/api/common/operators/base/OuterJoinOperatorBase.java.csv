commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setOuterJoinType(OuterJoinType outerJoinType) {     this.outerJoinType = outerJoinType. }
false;public;0;3;;public OuterJoinType getOuterJoinType() {     return outerJoinType. }
false;protected;4;37;;@Override protected List<OUT> executeOnCollections(List<IN1> leftInput, List<IN2> rightInput, RuntimeContext runtimeContext, ExecutionConfig executionConfig) throws Exception {     TypeInformation<IN1> leftInformation = getOperatorInfo().getFirstInputType().     TypeInformation<IN2> rightInformation = getOperatorInfo().getSecondInputType().     TypeInformation<OUT> outInformation = getOperatorInfo().getOutputType().     TypeComparator<IN1> leftComparator = buildComparatorFor(0, executionConfig, leftInformation).     TypeComparator<IN2> rightComparator = buildComparatorFor(1, executionConfig, rightInformation).     TypeSerializer<IN1> leftSerializer = leftInformation.createSerializer(executionConfig).     TypeSerializer<IN2> rightSerializer = rightInformation.createSerializer(executionConfig).     OuterJoinListIterator<IN1, IN2> outerJoinIterator = new OuterJoinListIterator<>(leftInput, leftSerializer, leftComparator, rightInput, rightSerializer, rightComparator, outerJoinType).     // --------------------------------------------------------------------     // Run UDF     // --------------------------------------------------------------------     FlatJoinFunction<IN1, IN2, OUT> function = userFunction.getUserCodeObject().     FunctionUtils.setFunctionRuntimeContext(function, runtimeContext).     FunctionUtils.openFunction(function, this.parameters).     List<OUT> result = new ArrayList<>().     Collector<OUT> collector = new CopyingListCollector<>(result, outInformation.createSerializer(executionConfig)).     while (outerJoinIterator.next()) {         IN1 left = outerJoinIterator.getLeft().         IN2 right = outerJoinIterator.getRight().         function.join(left == null ? null : leftSerializer.copy(left), right == null ? null : rightSerializer.copy(right), collector).     }     FunctionUtils.closeFunction(function).     return result. }
false;private;3;17;;@SuppressWarnings("unchecked") private <T> TypeComparator<T> buildComparatorFor(int input, ExecutionConfig executionConfig, TypeInformation<T> typeInformation) {     TypeComparator<T> comparator.     if (typeInformation instanceof AtomicType) {         comparator = ((AtomicType<T>) typeInformation).createComparator(true, executionConfig).     } else if (typeInformation instanceof CompositeType) {         int[] keyPositions = getKeyColumns(input).         boolean[] orders = new boolean[keyPositions.length].         Arrays.fill(orders, true).         comparator = ((CompositeType<T>) typeInformation).createComparator(keyPositions, orders, 0, executionConfig).     } else {         throw new RuntimeException("Type information for input of type " + typeInformation.getClass().getCanonicalName() + " is not supported. Could not generate a comparator.").     }     return comparator. }
false;public;2;4;;@Override public int compare(IN1 o1, IN1 o2) {     return leftComparator.compare(o1, o2). }
false;public;2;4;;@Override public int compare(IN2 o1, IN2 o2) {     return rightComparator.compare(o1, o2). }
false;private;0;29;;@SuppressWarnings("unchecked") private boolean next() throws IOException {     boolean hasMoreElements.     if ((currLeftIterator == null || !currLeftIterator.hasNext()) && (currRightIterator == null || !currRightIterator.hasNext())) {         hasMoreElements = nextGroups(outerJoinType).         if (hasMoreElements) {             if (outerJoinType != OuterJoinType.LEFT) {                 currLeftIterator = new ListIteratorWrapper(currLeftSubset.iterator()).             }             leftReturn = (IN1) currLeftIterator.next().             if (outerJoinType != OuterJoinType.RIGHT) {                 currRightIterator = new ListIteratorWrapper(currRightSubset.iterator()).             }             rightReturn = (IN2) currRightIterator.next().             return true.         } else {             // no more elements             return false.         }     } else if (currLeftIterator.hasNext() && !currRightIterator.hasNext()) {         leftReturn = (IN1) currLeftIterator.next().         currRightIterator.reset().         rightReturn = (IN2) currRightIterator.next().         return true.     } else {         rightReturn = (IN2) currRightIterator.next().         return true.     } }
false;private;1;27;;private boolean nextGroups(OuterJoinType outerJoinType) throws IOException {     if (outerJoinType == OuterJoinType.FULL) {         return nextGroups().     } else if (outerJoinType == OuterJoinType.LEFT) {         boolean leftContainsElements = false.         while (!leftContainsElements && nextGroups()) {             currLeftIterator = new ListIteratorWrapper(currLeftSubset.iterator()).             if (currLeftIterator.next() != null) {                 leftContainsElements = true.             }             currLeftIterator.reset().         }         return leftContainsElements.     } else if (outerJoinType == OuterJoinType.RIGHT) {         boolean rightContainsElements = false.         while (!rightContainsElements && nextGroups()) {             currRightIterator = new ListIteratorWrapper(currRightSubset.iterator()).             if (currRightIterator.next() != null) {                 rightContainsElements = true.             }             currRightIterator.reset().         }         return rightContainsElements.     } else {         throw new IllegalArgumentException("Outer join of type '" + outerJoinType + "' not supported.").     } }
false;private;0;64;;private boolean nextGroups() throws IOException {     boolean firstEmpty = true.     boolean secondEmpty = true.     if (this.matchStatus != MatchStatus.FIRST_EMPTY) {         if (this.matchStatus == MatchStatus.FIRST_REMAINED) {             // comparator is still set correctly             firstEmpty = false.         } else {             if (this.leftGroupedIterator.nextKey()) {                 this.pairComparator.setReference(leftGroupedIterator.getValues().getCurrent()).                 firstEmpty = false.             }         }     }     if (this.matchStatus != MatchStatus.SECOND_EMPTY) {         if (this.matchStatus == MatchStatus.SECOND_REMAINED) {             secondEmpty = false.         } else {             if (rightGroupedIterator.nextKey()) {                 secondEmpty = false.             }         }     }     if (firstEmpty && secondEmpty) {         // both inputs are empty         return false.     } else if (firstEmpty && !secondEmpty) {         // input1 is empty, input2 not         this.currLeftSubset = Collections.singleton(null).         this.currRightSubset = this.rightGroupedIterator.getValues().         this.matchStatus = MatchStatus.FIRST_EMPTY.         return true.     } else if (!firstEmpty && secondEmpty) {         // input1 is not empty, input 2 is empty         this.currLeftSubset = this.leftGroupedIterator.getValues().         this.currRightSubset = Collections.singleton(null).         this.matchStatus = MatchStatus.SECOND_EMPTY.         return true.     } else {         // both inputs are not empty         final int comp = this.pairComparator.compareToReference(rightGroupedIterator.getValues().getCurrent()).         if (0 == comp) {             // keys match             this.currLeftSubset = this.leftGroupedIterator.getValues().             this.currRightSubset = this.rightGroupedIterator.getValues().             this.matchStatus = MatchStatus.NONE_REMAINED.         } else if (0 < comp) {             // key1 goes first             this.currLeftSubset = this.leftGroupedIterator.getValues().             this.currRightSubset = Collections.singleton(null).             this.matchStatus = MatchStatus.SECOND_REMAINED.         } else {             // key 2 goes first             this.currLeftSubset = Collections.singleton(null).             this.currRightSubset = this.rightGroupedIterator.getValues().             this.matchStatus = MatchStatus.FIRST_REMAINED.         }         return true.     } }
false;private;0;3;;private IN1 getLeft() {     return leftReturn. }
false;private;0;3;;private IN2 getRight() {     return rightReturn. }
