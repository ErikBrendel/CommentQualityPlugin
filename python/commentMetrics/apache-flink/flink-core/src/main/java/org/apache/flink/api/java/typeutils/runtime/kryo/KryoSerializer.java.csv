commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;Class<T> getType() {     return type. }
false;;0;3;;LinkedHashMap<Class<?>, SerializableSerializer<?>> getDefaultKryoSerializers() {     return defaultSerializers. }
false;;0;3;;LinkedHashMap<Class<?>, Class<? extends Serializer<?>>> getDefaultKryoSerializerClasses() {     return defaultSerializerClasses. }
false;;0;3;;LinkedHashMap<String, KryoRegistration> getKryoRegistrations() {     return kryoRegistrations. }
false;public;0;4;;// ------------------------------------------------------------------------ @Override public boolean isImmutableType() {     return false. }
false;public;0;4;;@Override public KryoSerializer<T> duplicate() {     return new KryoSerializer<>(this). }
false;public;0;13;;@Override public T createInstance() {     if (Modifier.isAbstract(type.getModifiers()) || Modifier.isInterface(type.getModifiers())) {         return null.     } else {         checkKryoInitialized().         try {             return kryo.newInstance(type).         } catch (Throwable e) {             return null.         }     } }
false;public;1;37;;@SuppressWarnings("unchecked") @Override public T copy(T from) {     if (from == null) {         return null.     }     if (CONCURRENT_ACCESS_CHECK) {         enterExclusiveThread().     }     try {         checkKryoInitialized().         try {             return kryo.copy(from).         } catch (KryoException ke) {             // kryo was unable to copy it, so we do it through serialization:             ByteArrayOutputStream baout = new ByteArrayOutputStream().             Output output = new Output(baout).             kryo.writeObject(output, from).             output.close().             ByteArrayInputStream bain = new ByteArrayInputStream(baout.toByteArray()).             Input input = new Input(bain).             return (T) kryo.readObject(input, from.getClass()).         }     } finally {         if (CONCURRENT_ACCESS_CHECK) {             exitExclusiveThread().         }     } }
false;public;2;4;;@Override public T copy(T from, T reuse) {     return copy(from). }
false;public;0;4;;@Override public int getLength() {     return -1. }
false;public;2;46;;@Override public void serialize(T record, DataOutputView target) throws IOException {     if (CONCURRENT_ACCESS_CHECK) {         enterExclusiveThread().     }     try {         checkKryoInitialized().         if (target != previousOut) {             DataOutputViewStream outputStream = new DataOutputViewStream(target).             output = new Output(outputStream).             previousOut = target.         }         // otherwise data might be written multiple times in case of a previous EOFException         if (output.position() != 0) {             throw new IllegalStateException("The Kryo Output still contains data from a previous " + "serialize call. It has to be flushed or cleared at the end of the serialize call.").         }         try {             kryo.writeClassAndObject(output, record).             output.flush().         } catch (KryoException ke) {             // make sure that the Kryo output buffer is cleared in case that we can recover from             // the exception (e.g. EOFException which denotes buffer full)             output.clear().             Throwable cause = ke.getCause().             if (cause instanceof EOFException) {                 throw (EOFException) cause.             } else {                 throw ke.             }         }     } finally {         if (CONCURRENT_ACCESS_CHECK) {             exitExclusiveThread().         }     } }
false;public;1;34;;@SuppressWarnings("unchecked") @Override public T deserialize(DataInputView source) throws IOException {     if (CONCURRENT_ACCESS_CHECK) {         enterExclusiveThread().     }     try {         checkKryoInitialized().         if (source != previousIn) {             DataInputViewStream inputStream = new DataInputViewStream(source).             input = new NoFetchingInput(inputStream).             previousIn = source.         }         try {             return (T) kryo.readClassAndObject(input).         } catch (KryoException ke) {             Throwable cause = ke.getCause().             if (cause instanceof EOFException) {                 throw (EOFException) cause.             } else {                 throw ke.             }         }     } finally {         if (CONCURRENT_ACCESS_CHECK) {             exitExclusiveThread().         }     } }
false;public;2;4;;@Override public T deserialize(T reuse, DataInputView source) throws IOException {     return deserialize(source). }
false;public;2;21;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     if (CONCURRENT_ACCESS_CHECK) {         enterExclusiveThread().     }     try {         checkKryoInitialized().         if (this.copyInstance == null) {             this.copyInstance = createInstance().         }         T tmp = deserialize(copyInstance, source).         serialize(tmp, target).     } finally {         if (CONCURRENT_ACCESS_CHECK) {             exitExclusiveThread().         }     } }
false;public;0;9;;// -------------------------------------------------------------------------------------------- @Override public int hashCode() {     int result = type.hashCode().     result = 31 * result + (kryoRegistrations.hashCode()).     result = 31 * result + (defaultSerializers.hashCode()).     result = 31 * result + (defaultSerializerClasses.hashCode()).     return result. }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (obj instanceof KryoSerializer) {         KryoSerializer<?> other = (KryoSerializer<?>) obj.         return type == other.type && Objects.equals(kryoRegistrations, other.kryoRegistrations) && Objects.equals(defaultSerializerClasses, other.defaultSerializerClasses) && Objects.equals(defaultSerializers, other.defaultSerializers).     } else {         return false.     } }
true;private;0;27;/**  * Returns the Chill Kryo Serializer which is implicitly added to the classpath via flink-runtime.  * Falls back to the default Kryo serializer if it can't be found.  * @return The Kryo serializer instance.  */ ;// -------------------------------------------------------------------------------------------- /**  * Returns the Chill Kryo Serializer which is implicitly added to the classpath via flink-runtime.  * Falls back to the default Kryo serializer if it can't be found.  * @return The Kryo serializer instance.  */ private Kryo getKryoInstance() {     try {         // check if ScalaKryoInstantiator is in class path (coming from Twitter's Chill library).         // This will be true if Flink's Scala API is used.         Class<?> chillInstantiatorClazz = Class.forName("org.apache.flink.runtime.types.FlinkScalaKryoInstantiator").         Object chillInstantiator = chillInstantiatorClazz.newInstance().         // obtain a Kryo instance through Twitter Chill         Method m = chillInstantiatorClazz.getMethod("newKryo").         return (Kryo) m.invoke(chillInstantiator).     } catch (ClassNotFoundException | InstantiationException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {         LOG.warn("Falling back to default Kryo serializer because Chill serializer couldn't be found.", e).         Kryo.DefaultInstantiatorStrategy initStrategy = new Kryo.DefaultInstantiatorStrategy().         initStrategy.setFallbackInstantiatorStrategy(new StdInstantiatorStrategy()).         Kryo kryo = new Kryo().         kryo.setInstantiatorStrategy(initStrategy).         return kryo.     } }
false;private;0;28;;private void checkKryoInitialized() {     if (this.kryo == null) {         this.kryo = getKryoInstance().         // Enable reference tracking.         kryo.setReferences(true).         // Throwable and all subclasses should be serialized via java serialization         // Note: the registered JavaSerializer is Flink's own implementation, and not Kryo's.         // This is due to a know issue with Kryo's JavaSerializer. See FLINK-6025 for details.         kryo.addDefaultSerializer(Throwable.class, new JavaSerializer()).         // are registered with a default serializer         for (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {             kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer()).         }         for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {             kryo.addDefaultSerializer(entry.getKey(), entry.getValue()).         }         KryoUtils.applyRegistrations(this.kryo, kryoRegistrations.values()).         kryo.setRegistrationRequired(false).         kryo.setClassLoader(Thread.currentThread().getContextClassLoader()).     } }
false;public;0;8;;// -------------------------------------------------------------------------------------------- // Serializer configuration snapshotting & compatibility // -------------------------------------------------------------------------------------------- @Override public TypeSerializerSnapshot<T> snapshotConfiguration() {     return new KryoSerializerSnapshot<>(type, defaultSerializers, defaultSerializerClasses, kryoRegistrations). }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;1;12;;@Override public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializer<T> newSerializer) {     KryoSerializer<T> javaSerializedKryoSerializer = (KryoSerializer<T>) super.restoreSerializer().     KryoSerializerSnapshot<T> snapshot = new KryoSerializerSnapshot<>(javaSerializedKryoSerializer.getType(), javaSerializedKryoSerializer.getDefaultKryoSerializers(), javaSerializedKryoSerializer.getDefaultKryoSerializerClasses(), javaSerializedKryoSerializer.getKryoRegistrations()).     return snapshot.resolveSchemaCompatibility(newSerializer). }
true;private,static;4;39;/**  * Utility method that takes lists of registered types and their serializers, and resolve  * them into a single list such that the result will resemble the final registration  * result in Kryo.  */ ;// -------------------------------------------------------------------------------------------- // Utilities // -------------------------------------------------------------------------------------------- /**  * Utility method that takes lists of registered types and their serializers, and resolve  * them into a single list such that the result will resemble the final registration  * result in Kryo.  */ private static LinkedHashMap<String, KryoRegistration> buildKryoRegistrations(Class<?> serializedType, LinkedHashSet<Class<?>> registeredTypes, LinkedHashMap<Class<?>, Class<? extends Serializer<?>>> registeredTypesWithSerializerClasses, LinkedHashMap<Class<?>, ExecutionConfig.SerializableSerializer<?>> registeredTypesWithSerializers) {     final LinkedHashMap<String, KryoRegistration> kryoRegistrations = new LinkedHashMap<>().     kryoRegistrations.put(serializedType.getName(), new KryoRegistration(serializedType)).     for (Class<?> registeredType : checkNotNull(registeredTypes)) {         kryoRegistrations.put(registeredType.getName(), new KryoRegistration(registeredType)).     }     for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> registeredTypeWithSerializerClassEntry : checkNotNull(registeredTypesWithSerializerClasses).entrySet()) {         kryoRegistrations.put(registeredTypeWithSerializerClassEntry.getKey().getName(), new KryoRegistration(registeredTypeWithSerializerClassEntry.getKey(), registeredTypeWithSerializerClassEntry.getValue())).     }     for (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> registeredTypeWithSerializerEntry : checkNotNull(registeredTypesWithSerializers).entrySet()) {         kryoRegistrations.put(registeredTypeWithSerializerEntry.getKey().getName(), new KryoRegistration(registeredTypeWithSerializerEntry.getKey(), registeredTypeWithSerializerEntry.getValue())).     }     // add Avro support if flink-avro is available. a dummy otherwise     AvroUtils.getAvroUtils().addAvroGenericDataArrayRegistration(kryoRegistrations).     return kryoRegistrations. }
false;static;0;9;;static void configureKryoLogging() {     // a logging for each object, which is infeasible in Flink.     if (LOG.isTraceEnabled()) {         com.esotericsoftware.minlog.Log.setLogger(new MinlogForwarder(LOG)).         com.esotericsoftware.minlog.Log.TRACE().     } }
false;private;1;12;;// -------------------------------------------------------------------------------------------- private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {     in.defaultReadObject().     // kryoRegistrations may be null if this Kryo serializer is deserialized from an old version     if (kryoRegistrations == null) {         this.kryoRegistrations = buildKryoRegistrations(type, registeredTypes, registeredTypesWithSerializerClasses, registeredTypesWithSerializers).     } }
false;private;1;10;;private ExecutionConfig.SerializableSerializer<? extends Serializer<?>> deepCopySerializer(ExecutionConfig.SerializableSerializer<? extends Serializer<?>> original) {     try {         return InstantiationUtil.clone(original, Thread.currentThread().getContextClassLoader()).     } catch (IOException | ClassNotFoundException ex) {         throw new CloneFailedException("Could not clone serializer instance of class " + original.getClass(), ex).     } }
false;private;0;16;;// -------------------------------------------------------------------------------------------- // For testing // -------------------------------------------------------------------------------------------- private void enterExclusiveThread() {     // we use simple get, check, set here, rather than CAS     // we don't need lock-style correctness, this is only a sanity-check and we thus     // favor speed at the cost of some false negatives in this check     Thread previous = currentThread.     Thread thisThread = Thread.currentThread().     if (previous == null) {         currentThread = thisThread.     } else if (previous != thisThread) {         throw new IllegalStateException("Concurrent access to KryoSerializer. Thread 1: " + thisThread.getName() + " , Thread 2: " + previous.getName()).     } }
false;private;0;3;;private void exitExclusiveThread() {     currentThread = null. }
false;public;0;5;;@VisibleForTesting public Kryo getKryo() {     checkKryoInitialized().     return this.kryo. }
