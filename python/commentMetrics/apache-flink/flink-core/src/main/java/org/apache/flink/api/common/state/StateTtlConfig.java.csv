commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Nonnull public UpdateType getUpdateType() {     return updateType. }
false;public;0;4;;@Nonnull public StateVisibility getStateVisibility() {     return stateVisibility. }
false;public;0;4;;@Nonnull public Time getTtl() {     return ttl. }
false;public;0;4;;@Nonnull public TimeCharacteristic getTimeCharacteristic() {     return timeCharacteristic. }
false;public;0;3;;public boolean isEnabled() {     return updateType != UpdateType.Disabled. }
false;public;0;4;;@Nonnull public CleanupStrategies getCleanupStrategies() {     return cleanupStrategies. }
false;public;0;9;;@Override public String toString() {     return "StateTtlConfig{" + "updateType=" + updateType + ", stateVisibility=" + stateVisibility + ", timeCharacteristic=" + timeCharacteristic + ", ttl=" + ttl + '}'. }
false;public,static;1;4;;@Nonnull public static Builder newBuilder(@Nonnull Time ttl) {     return new Builder(ttl). }
true;public;1;5;/**  * Sets the ttl update type.  *  * @param updateType The ttl update type configures when to update last access timestamp which prolongs state TTL.  */ ;/**  * Sets the ttl update type.  *  * @param updateType The ttl update type configures when to update last access timestamp which prolongs state TTL.  */ @Nonnull public Builder setUpdateType(UpdateType updateType) {     this.updateType = updateType.     return this. }
false;public;0;4;;@Nonnull public Builder updateTtlOnCreateAndWrite() {     return setUpdateType(UpdateType.OnCreateAndWrite). }
false;public;0;4;;@Nonnull public Builder updateTtlOnReadAndWrite() {     return setUpdateType(UpdateType.OnReadAndWrite). }
true;public;1;5;/**  * Sets the state visibility.  *  * @param stateVisibility The state visibility configures whether expired user value can be returned or not.  */ ;/**  * Sets the state visibility.  *  * @param stateVisibility The state visibility configures whether expired user value can be returned or not.  */ @Nonnull public Builder setStateVisibility(@Nonnull StateVisibility stateVisibility) {     this.stateVisibility = stateVisibility.     return this. }
false;public;0;4;;@Nonnull public Builder returnExpiredIfNotCleanedUp() {     return setStateVisibility(StateVisibility.ReturnExpiredIfNotCleanedUp). }
false;public;0;4;;@Nonnull public Builder neverReturnExpired() {     return setStateVisibility(StateVisibility.NeverReturnExpired). }
true;public;1;5;/**  * Sets the time characteristic.  *  * @param timeCharacteristic The time characteristic configures time scale to use for ttl.  */ ;/**  * Sets the time characteristic.  *  * @param timeCharacteristic The time characteristic configures time scale to use for ttl.  */ @Nonnull public Builder setTimeCharacteristic(@Nonnull TimeCharacteristic timeCharacteristic) {     this.timeCharacteristic = timeCharacteristic.     return this. }
false;public;0;4;;@Nonnull public Builder useProcessingTime() {     return setTimeCharacteristic(TimeCharacteristic.ProcessingTime). }
true;public;0;5;/**  * Cleanup expired state in full snapshot on checkpoint.  */ ;/**  * Cleanup expired state in full snapshot on checkpoint.  */ @Nonnull public Builder cleanupFullSnapshot() {     cleanupStrategies.activate(CleanupStrategies.Strategies.FULL_STATE_SCAN_SNAPSHOT).     return this. }
true;public;2;9;/**  * Cleanup expired state incrementally cleanup local state.  *  * <p>Upon every state access this cleanup strategy checks a bunch of state keys for expiration  * and cleans up expired ones. It keeps a lazy iterator through all keys with relaxed consistency  * if backend supports it. This way all keys should be regularly checked and cleaned eventually over time  * if any state is constantly being accessed.  *  * <p>Additionally to the incremental cleanup upon state access, it can also run per every record.  * Caution: if there are a lot of registered states using this option,  * they all will be iterated for every record to check if there is something to cleanup.  *  * <p>Note: if no access happens to this state or no records are processed  * in case of {@code runCleanupForEveryRecord}, expired state will persist.  *  * <p>Note: Time spent for the incremental cleanup increases record processing latency.  *  * <p>Note: At the moment incremental cleanup is implemented only for Heap state backend.  * Setting it for RocksDB will have no effect.  *  * <p>Note: If heap state backend is used with synchronous snapshotting, the global iterator keeps a copy of all keys  * while iterating because of its specific implementation which does not support concurrent modifications.  * Enabling of this feature will increase memory consumption then. Asynchronous snapshotting does not have this problem.  *  * @param cleanupSize max number of keys pulled from queue for clean up upon state touch for any key  * @param runCleanupForEveryRecord run incremental cleanup per each processed record  */ ;/**  * Cleanup expired state incrementally cleanup local state.  *  * <p>Upon every state access this cleanup strategy checks a bunch of state keys for expiration  * and cleans up expired ones. It keeps a lazy iterator through all keys with relaxed consistency  * if backend supports it. This way all keys should be regularly checked and cleaned eventually over time  * if any state is constantly being accessed.  *  * <p>Additionally to the incremental cleanup upon state access, it can also run per every record.  * Caution: if there are a lot of registered states using this option,  * they all will be iterated for every record to check if there is something to cleanup.  *  * <p>Note: if no access happens to this state or no records are processed  * in case of {@code runCleanupForEveryRecord}, expired state will persist.  *  * <p>Note: Time spent for the incremental cleanup increases record processing latency.  *  * <p>Note: At the moment incremental cleanup is implemented only for Heap state backend.  * Setting it for RocksDB will have no effect.  *  * <p>Note: If heap state backend is used with synchronous snapshotting, the global iterator keeps a copy of all keys  * while iterating because of its specific implementation which does not support concurrent modifications.  * Enabling of this feature will increase memory consumption then. Asynchronous snapshotting does not have this problem.  *  * @param cleanupSize max number of keys pulled from queue for clean up upon state touch for any key  * @param runCleanupForEveryRecord run incremental cleanup per each processed record  */ @Nonnull public Builder cleanupIncrementally(@Nonnegative int cleanupSize, boolean runCleanupForEveryRecord) {     cleanupStrategies.activate(CleanupStrategies.Strategies.INCREMENTAL_CLEANUP, new IncrementalCleanupStrategy(cleanupSize, runCleanupForEveryRecord)).     return this. }
true;public;0;4;/**  * Cleanup expired state while Rocksdb compaction is running.  *  * <p>RocksDB runs periodic compaction of state updates and merges them to free storage.  * During this process, the TTL filter checks timestamp of state entries and drops expired ones.  * The feature has to be activated in RocksDb backend firstly  * using the following Flink configuration option:  * state.backend.rocksdb.ttl.compaction.filter.enabled.  *  * <p>Due to specifics of RocksDB compaction filter,  * cleanup is not properly guaranteed if put and merge operations are used at the same time:  * https://github.com/facebook/rocksdb/blob/master/include/rocksdb/compaction_filter.h#L69  * It means that the TTL filter should be tested for List state taking into account this caveat.  */ ;/**  * Cleanup expired state while Rocksdb compaction is running.  *  * <p>RocksDB runs periodic compaction of state updates and merges them to free storage.  * During this process, the TTL filter checks timestamp of state entries and drops expired ones.  * The feature has to be activated in RocksDb backend firstly  * using the following Flink configuration option:  * state.backend.rocksdb.ttl.compaction.filter.enabled.  *  * <p>Due to specifics of RocksDB compaction filter,  * cleanup is not properly guaranteed if put and merge operations are used at the same time:  * https://github.com/facebook/rocksdb/blob/master/include/rocksdb/compaction_filter.h#L69  * It means that the TTL filter should be tested for List state taking into account this caveat.  */ @Nonnull public Builder cleanupInRocksdbCompactFilter() {     return cleanupInRocksdbCompactFilter(1000L). }
true;public;1;6;/**  * Cleanup expired state while Rocksdb compaction is running.  *  * <p>RocksDB compaction filter will query current timestamp,  * used to check expiration, from Flink every time after processing {@code queryTimeAfterNumEntries} number of state entries.  * Updating the timestamp more often can improve cleanup speed  * but it decreases compaction performance because it uses JNI call from native code.  *  * @param queryTimeAfterNumEntries number of state entries to process by compaction filter before updating current timestamp  */ ;/**  * Cleanup expired state while Rocksdb compaction is running.  *  * <p>RocksDB compaction filter will query current timestamp,  * used to check expiration, from Flink every time after processing {@code queryTimeAfterNumEntries} number of state entries.  * Updating the timestamp more often can improve cleanup speed  * but it decreases compaction performance because it uses JNI call from native code.  *  * @param queryTimeAfterNumEntries number of state entries to process by compaction filter before updating current timestamp  */ @Nonnull public Builder cleanupInRocksdbCompactFilter(long queryTimeAfterNumEntries) {     cleanupStrategies.activate(CleanupStrategies.Strategies.ROCKSDB_COMPACTION_FILTER, new RocksdbCompactFilterCleanupStrategy(queryTimeAfterNumEntries)).     return this. }
true;public;1;5;/**  * Sets the ttl time.  * @param ttl The ttl time.  */ ;/**  * Sets the ttl time.  * @param ttl The ttl time.  */ @Nonnull public Builder setTtl(@Nonnull Time ttl) {     this.ttl = ttl.     return this. }
false;public;0;9;;@Nonnull public StateTtlConfig build() {     return new StateTtlConfig(updateType, stateVisibility, timeCharacteristic, ttl, cleanupStrategies). }
false;public;1;3;;public void activate(Strategies strategy) {     activate(strategy, EMPTY_STRATEGY). }
false;public;2;3;;public void activate(Strategies strategy, CleanupStrategy config) {     strategies.put(strategy, config). }
false;public;0;3;;public boolean inFullSnapshot() {     return strategies.containsKey(Strategies.FULL_STATE_SCAN_SNAPSHOT). }
false;public;0;4;;@Nullable public IncrementalCleanupStrategy getIncrementalCleanupStrategy() {     return (IncrementalCleanupStrategy) strategies.get(Strategies.INCREMENTAL_CLEANUP). }
false;public;0;3;;public boolean inRocksdbCompactFilter() {     return strategies.containsKey(Strategies.ROCKSDB_COMPACTION_FILTER). }
false;public;0;4;;@Nullable public RocksdbCompactFilterCleanupStrategy getRocksdbCompactFilterCleanupStrategy() {     return (RocksdbCompactFilterCleanupStrategy) strategies.get(Strategies.ROCKSDB_COMPACTION_FILTER). }
false;public;0;3;;public int getCleanupSize() {     return cleanupSize. }
false;public;0;3;;public boolean runCleanupForEveryRecord() {     return runCleanupForEveryRecord. }
false;public;0;3;;public long getQueryTimeAfterNumEntries() {     return queryTimeAfterNumEntries. }
