commented;modifiers;parameterAmount;loc;comment;code
false;public;2;12;;@Override public FieldSet getForwardingTargetFields(int input, int sourceField) {     if (input != 0 && input != 1) {         throw new IndexOutOfBoundsException().     } else if (input == 0) {         return fieldMapping1.containsKey(sourceField) ? fieldMapping1.get(sourceField) : FieldSet.EMPTY_SET.     } else {         return fieldMapping2.containsKey(sourceField) ? fieldMapping2.get(sourceField) : FieldSet.EMPTY_SET.     } }
false;public;2;19;;@Override public int getForwardingSourceField(int input, int targetField) {     Map<Integer, FieldSet> fieldMapping.     if (input != 0 && input != 1) {         throw new IndexOutOfBoundsException().     } else if (input == 0) {         fieldMapping = fieldMapping1.     } else {         fieldMapping = fieldMapping2.     }     for (Map.Entry<Integer, FieldSet> e : fieldMapping.entrySet()) {         if (e.getValue().contains(targetField)) {             return e.getKey().         }     }     return -1. }
false;public;1;12;;@Override public FieldSet getReadFields(int input) {     if (input != 0 && input != 1) {         throw new IndexOutOfBoundsException().     }     if (input == 0) {         return readFields1.     } else {         return readFields2.     } }
true;public;3;23;/**  * Adds, to the existing information, a field that is forwarded directly  * from the source record(s) in the first input to the destination  * record(s).  *  * @param input the input of the source field  * @param sourceField the position in the source record  * @param targetField the position in the destination record  */ ;/**  * Adds, to the existing information, a field that is forwarded directly  * from the source record(s) in the first input to the destination  * record(s).  *  * @param input the input of the source field  * @param sourceField the position in the source record  * @param targetField the position in the destination record  */ public void addForwardedField(int input, int sourceField, int targetField) {     Map<Integer, FieldSet> fieldMapping.     if (input != 0 && input != 1) {         throw new IndexOutOfBoundsException().     } else if (input == 0) {         fieldMapping = this.fieldMapping1.     } else {         fieldMapping = this.fieldMapping2.     }     if (isTargetFieldPresent(targetField, fieldMapping)) {         throw new InvalidSemanticAnnotationException("Target field " + targetField + " was added twice to input " + input).     }     FieldSet targetFields = fieldMapping.get(sourceField).     if (targetFields != null) {         fieldMapping.put(sourceField, targetFields.addField(targetField)).     } else {         fieldMapping.put(sourceField, new FieldSet(targetField)).     } }
false;private;2;9;;private boolean isTargetFieldPresent(int targetField, Map<Integer, FieldSet> fieldMapping) {     for (FieldSet targetFields : fieldMapping.values()) {         if (targetFields.contains(targetField)) {             return true.         }     }     return false. }
true;public;2;10;/**  * Adds, to the existing information, field(s) that are read in  * the source record(s) from the first input.  *  * @param input the input of the read fields  * @param readFields the position(s) in the source record(s)  */ ;/**  * Adds, to the existing information, field(s) that are read in  * the source record(s) from the first input.  *  * @param input the input of the read fields  * @param readFields the position(s) in the source record(s)  */ public void addReadFields(int input, FieldSet readFields) {     if (input != 0 && input != 1) {         throw new IndexOutOfBoundsException().     } else if (input == 0) {         this.readFields1 = (this.readFields1 == null) ? readFields.clone() : this.readFields1.addFields(readFields).     } else {         this.readFields2 = (this.readFields2 == null) ? readFields.clone() : this.readFields2.addFields(readFields).     } }
false;public;0;4;;@Override public String toString() {     return "DISP(" + this.fieldMapping1 + ". " + this.fieldMapping2 + ")". }
