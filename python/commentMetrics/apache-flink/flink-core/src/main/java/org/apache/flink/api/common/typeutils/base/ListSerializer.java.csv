commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the serializer for the elements of the list.  * @return The serializer for the elements of the list  */ ;// ------------------------------------------------------------------------ // ListSerializer specific properties // ------------------------------------------------------------------------ /**  * Gets the serializer for the elements of the list.  * @return The serializer for the elements of the list  */ public TypeSerializer<T> getElementSerializer() {     return elementSerializer. }
false;public;0;4;;// ------------------------------------------------------------------------ // Type Serializer implementation // ------------------------------------------------------------------------ @Override public boolean isImmutableType() {     return false. }
false;public;0;5;;@Override public TypeSerializer<List<T>> duplicate() {     TypeSerializer<T> duplicateElement = elementSerializer.duplicate().     return duplicateElement == elementSerializer ? this : new ListSerializer<>(duplicateElement). }
false;public;0;4;;@Override public List<T> createInstance() {     return new ArrayList<>(0). }
false;public;1;12;;@Override public List<T> copy(List<T> from) {     List<T> newList = new ArrayList<>(from.size()).     // The Iterator should be stack allocated on new JVMs (due to escape analysis)     for (T element : from) {         newList.add(elementSerializer.copy(element)).     }     return newList. }
false;public;2;4;;@Override public List<T> copy(List<T> from, List<T> reuse) {     return copy(from). }
false;public;0;4;;@Override public int getLength() {     // var length     return -1. }
false;public;2;12;;@Override public void serialize(List<T> list, DataOutputView target) throws IOException {     final int size = list.size().     target.writeInt(size).     // The Iterator should be stack allocated on new JVMs (due to escape analysis)     for (T element : list) {         elementSerializer.serialize(element, target).     } }
false;public;1;10;;@Override public List<T> deserialize(DataInputView source) throws IOException {     final int size = source.readInt().     // create new list with (size + 1) capacity to prevent expensive growth when a single element is added     final List<T> list = new ArrayList<>(size + 1).     for (int i = 0. i < size. i++) {         list.add(elementSerializer.deserialize(source)).     }     return list. }
false;public;2;4;;@Override public List<T> deserialize(List<T> reuse, DataInputView source) throws IOException {     return deserialize(source). }
false;public;2;9;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     // copy number of elements     final int num = source.readInt().     target.writeInt(num).     for (int i = 0. i < num. i++) {         elementSerializer.copy(source, target).     } }
false;public;1;6;;// -------------------------------------------------------------------- @Override public boolean equals(Object obj) {     return obj == this || (obj != null && obj.getClass() == getClass() && elementSerializer.equals(((ListSerializer<?>) obj).elementSerializer)). }
false;public;0;4;;@Override public int hashCode() {     return elementSerializer.hashCode(). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // Serializer configuration snapshot & compatibility // -------------------------------------------------------------------------------------------- @Override public TypeSerializerSnapshot<List<T>> snapshotConfiguration() {     return new ListSerializerSnapshot<>(this). }
