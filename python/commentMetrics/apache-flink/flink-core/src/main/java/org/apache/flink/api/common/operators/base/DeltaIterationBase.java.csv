commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// -------------------------------------------------------------------------------------------- public int[] getSolutionSetKeyFields() {     return this.solutionSetKeyFields. }
false;public;1;3;;public void setMaximumNumberOfIterations(int maxIterations) {     this.maxNumberOfIterations = maxIterations. }
false;public;0;3;;public int getMaximumNumberOfIterations() {     return this.maxNumberOfIterations. }
false;public;0;4;;@Override public AggregatorRegistry getAggregators() {     return this.aggregators. }
true;public;0;3;/**  * Gets the contract that represents the solution set for the step function.  *  * @return The solution set for the step function.  */ ;// -------------------------------------------------------------------------------------------- // Getting / Setting of the step function input place-holders // -------------------------------------------------------------------------------------------- /**  * Gets the contract that represents the solution set for the step function.  *  * @return The solution set for the step function.  */ public Operator<ST> getSolutionSet() {     return this.solutionSetPlaceholder. }
true;public;0;3;/**  * Gets the contract that represents the workset for the step function.  *  * @return The workset for the step function.  */ ;/**  * Gets the contract that represents the workset for the step function.  *  * @return The workset for the step function.  */ public Operator<WT> getWorkset() {     return this.worksetPlaceholder. }
true;public;1;3;/**  * Sets the contract of the step function that represents the next workset. This contract is considered  * one of the two sinks of the step function (the other one being the solution set delta).  *  * @param result The contract representing the next workset.  */ ;/**  * Sets the contract of the step function that represents the next workset. This contract is considered  * one of the two sinks of the step function (the other one being the solution set delta).  *  * @param result The contract representing the next workset.  */ public void setNextWorkset(Operator<WT> result) {     this.nextWorkset = result. }
true;public;0;3;/**  * Gets the contract that has been set as the next workset.  *  * @return The contract that has been set as the next workset.  */ ;/**  * Gets the contract that has been set as the next workset.  *  * @return The contract that has been set as the next workset.  */ public Operator<WT> getNextWorkset() {     return this.nextWorkset. }
true;public;1;3;/**  * Sets the contract of the step function that represents the solution set delta. This contract is considered  * one of the two sinks of the step function (the other one being the next workset).  *  * @param delta The contract representing the solution set delta.  */ ;/**  * Sets the contract of the step function that represents the solution set delta. This contract is considered  * one of the two sinks of the step function (the other one being the next workset).  *  * @param delta The contract representing the solution set delta.  */ public void setSolutionSetDelta(Operator<ST> delta) {     this.solutionSetDelta = delta. }
true;public;0;3;/**  * Gets the contract that has been set as the solution set delta.  *  * @return The contract that has been set as the solution set delta.  */ ;/**  * Gets the contract that has been set as the solution set delta.  *  * @return The contract that has been set as the solution set delta.  */ public Operator<ST> getSolutionSetDelta() {     return this.solutionSetDelta. }
true;public;0;3;/**  * Returns the initial solution set input, or null, if none is set.  *  * @return The iteration's initial solution set input.  */ ;// -------------------------------------------------------------------------------------------- // Getting / Setting the Inputs // -------------------------------------------------------------------------------------------- /**  * Returns the initial solution set input, or null, if none is set.  *  * @return The iteration's initial solution set input.  */ public Operator<ST> getInitialSolutionSet() {     return getFirstInput(). }
true;public;0;3;/**  * Returns the initial workset input, or null, if none is set.  *  * @return The iteration's workset input.  */ ;/**  * Returns the initial workset input, or null, if none is set.  *  * @return The iteration's workset input.  */ public Operator<WT> getInitialWorkset() {     return getSecondInput(). }
true;public;1;3;/**  * Sets the given input as the initial solution set.  *  * @param input The contract to set the initial solution set.  */ ;/**  * Sets the given input as the initial solution set.  *  * @param input The contract to set the initial solution set.  */ public void setInitialSolutionSet(Operator<ST> input) {     setFirstInput(input). }
true;public;1;3;/**  * Sets the given input as the initial workset.  *  * @param input The contract to set as the initial workset.  */ ;/**  * Sets the given input as the initial workset.  *  * @param input The contract to set as the initial workset.  */ public void setInitialWorkset(Operator<WT> input) {     setSecondInput(input). }
true;public;0;3;/**  * DeltaIteration meta operator cannot have broadcast inputs.  *  * @return An empty map.  */ ;/**  * DeltaIteration meta operator cannot have broadcast inputs.  *  * @return An empty map.  */ public Map<String, Operator<?>> getBroadcastInputs() {     return Collections.emptyMap(). }
true;public;2;3;/**  * The DeltaIteration meta operator cannot have broadcast inputs.  * This method always throws an exception.  *  * @param name Ignored.  * @param root Ignored.  */ ;/**  * The DeltaIteration meta operator cannot have broadcast inputs.  * This method always throws an exception.  *  * @param name Ignored.  * @param root Ignored.  */ public void setBroadcastVariable(String name, Operator<?> root) {     throw new UnsupportedOperationException("The DeltaIteration meta operator cannot have broadcast inputs."). }
true;public;1;3;/**  * The DeltaIteration meta operator cannot have broadcast inputs.  * This method always throws an exception.  *  * @param inputs Ignored  */ ;/**  * The DeltaIteration meta operator cannot have broadcast inputs.  * This method always throws an exception.  *  * @param inputs Ignored  */ public <X> void setBroadcastVariables(Map<String, Operator<X>> inputs) {     throw new UnsupportedOperationException("The DeltaIteration meta operator cannot have broadcast inputs."). }
true;public;1;3;/**  * Sets whether to keep the solution set in managed memory (safe against heap exhaustion) or unmanaged memory  * (objects on heap).  *  * @param solutionSetUnManaged True to keep the solution set in unmanaged memory, false to keep it in managed memory.  *  * @see #isSolutionSetUnManaged()  */ ;/**  * Sets whether to keep the solution set in managed memory (safe against heap exhaustion) or unmanaged memory  * (objects on heap).  *  * @param solutionSetUnManaged True to keep the solution set in unmanaged memory, false to keep it in managed memory.  *  * @see #isSolutionSetUnManaged()  */ public void setSolutionSetUnManaged(boolean solutionSetUnManaged) {     this.solutionSetUnManaged = solutionSetUnManaged. }
true;public;0;3;/**  * gets whether the solution set is in managed or unmanaged memory.  *  * @return True, if the solution set is in unmanaged memory (object heap), false if in managed memory.  *  * @see #setSolutionSetUnManaged(boolean)  */ ;/**  * gets whether the solution set is in managed or unmanaged memory.  *  * @return True, if the solution set is in unmanaged memory (object heap), false if in managed memory.  *  * @see #setSolutionSetUnManaged(boolean)  */ public boolean isSolutionSetUnManaged() {     return solutionSetUnManaged. }
false;public;0;3;;public DeltaIterationBase<?, WT> getContainingWorksetIteration() {     return this.containingIteration. }
false;public;1;5;;@Override public void accept(Visitor<Operator<?>> visitor) {     visitor.preVisit(this).     visitor.postVisit(this). }
false;public;0;4;;@Override public UserCodeWrapper<?> getUserCodeWrapper() {     return null. }
false;public;0;3;;public DeltaIterationBase<ST, ?> getContainingWorksetIteration() {     return this.containingIteration. }
false;public;1;5;;@Override public void accept(Visitor<Operator<?>> visitor) {     visitor.preVisit(this).     visitor.postVisit(this). }
false;public;0;4;;@Override public UserCodeWrapper<?> getUserCodeWrapper() {     return null. }
false;protected;4;4;;@Override protected List<ST> executeOnCollections(List<ST> inputData1, List<WT> inputData2, RuntimeContext runtimeContext, ExecutionConfig executionConfig) {     throw new UnsupportedOperationException(). }
