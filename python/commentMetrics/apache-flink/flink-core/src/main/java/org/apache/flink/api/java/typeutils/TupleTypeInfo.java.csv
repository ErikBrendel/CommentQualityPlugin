commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override @PublicEvolving public String[] getFieldNames() {     return fieldNames. }
false;public;1;10;;@Override @PublicEvolving public int getFieldIndex(String fieldName) {     for (int i = 0. i < fieldNames.length. i++) {         if (fieldNames[i].equals(fieldName)) {             return i.         }     }     return -1. }
false;public;1;17;;@SuppressWarnings("unchecked") @Override @PublicEvolving public TupleSerializer<T> createSerializer(ExecutionConfig executionConfig) {     if (getTypeClass() == Tuple0.class) {         return (TupleSerializer<T>) Tuple0Serializer.INSTANCE.     }     TypeSerializer<?>[] fieldSerializers = new TypeSerializer<?>[getArity()].     for (int i = 0. i < types.length. i++) {         fieldSerializers[i] = types[i].createSerializer(executionConfig).     }     Class<T> tupleClass = getTypeClass().     return new TupleSerializer<T>(tupleClass, fieldSerializers). }
false;protected;0;4;;@Override protected TypeComparatorBuilder<T> createTypeComparatorBuilder() {     return new TupleTypeComparatorBuilder(). }
false;public;1;5;;@Override public void initializeTypeComparatorBuilder(int size) {     fieldComparators.ensureCapacity(size).     logicalKeyFields.ensureCapacity(size). }
false;public;2;5;;@Override public void addComparatorField(int fieldId, TypeComparator<?> comparator) {     fieldComparators.add(comparator).     logicalKeyFields.add(fieldId). }
false;public;1;36;;@Override public TypeComparator<T> createTypeComparator(ExecutionConfig config) {     checkState(fieldComparators.size() > 0, "No field comparators were defined for the TupleTypeComparatorBuilder.").     checkState(logicalKeyFields.size() > 0, "No key fields were defined for the TupleTypeComparatorBuilder.").     checkState(fieldComparators.size() == logicalKeyFields.size(), "The number of field comparators and key fields is not equal.").     final int maxKey = Collections.max(logicalKeyFields).     checkState(maxKey >= 0, "The maximum key field must be greater or equal than 0.").     TypeSerializer<?>[] fieldSerializers = new TypeSerializer<?>[maxKey + 1].     for (int i = 0. i <= maxKey. i++) {         fieldSerializers[i] = types[i].createSerializer(config).     }     return new TupleComparator<T>(listToPrimitives(logicalKeyFields), fieldComparators.toArray(new TypeComparator[fieldComparators.size()]), fieldSerializers). }
false;public;0;8;;@Override public Map<String, TypeInformation<?>> getGenericParameters() {     Map<String, TypeInformation<?>> m = new HashMap<>(types.length).     for (int i = 0. i < types.length. i++) {         m.put("T" + i, types[i]).     }     return m. }
false;public;1;12;;// -------------------------------------------------------------------------------------------- @Override public boolean equals(Object obj) {     if (obj instanceof TupleTypeInfo) {         @SuppressWarnings("unchecked")         TupleTypeInfo<T> other = (TupleTypeInfo<T>) obj.         return other.canEqual(this) && super.equals(other) && Arrays.equals(fieldNames, other.fieldNames).     } else {         return false.     } }
false;public;1;4;;@Override public boolean canEqual(Object obj) {     return obj instanceof TupleTypeInfo. }
false;public;0;4;;@Override public int hashCode() {     return 31 * super.hashCode() + Arrays.hashCode(fieldNames). }
false;public;0;4;;@Override public String toString() {     return "Java " + super.toString(). }
false;public,static;1;24;;// -------------------------------------------------------------------------------------------- @PublicEvolving public static <X extends Tuple> TupleTypeInfo<X> getBasicTupleTypeInfo(Class<?>... basicTypes) {     if (basicTypes == null || basicTypes.length == 0) {         throw new IllegalArgumentException().     }     TypeInformation<?>[] infos = new TypeInformation<?>[basicTypes.length].     for (int i = 0. i < infos.length. i++) {         Class<?> type = basicTypes[i].         if (type == null) {             throw new IllegalArgumentException("Type at position " + i + " is null.").         }         TypeInformation<?> info = BasicTypeInfo.getInfoFor(type).         if (info == null) {             throw new IllegalArgumentException("Type at position " + i + " is not a basic type.").         }         infos[i] = info.     }     @SuppressWarnings("unchecked")     TupleTypeInfo<X> tupleInfo = (TupleTypeInfo<X>) new TupleTypeInfo<Tuple>(infos).     return tupleInfo. }
false;public,static;1;31;;@SuppressWarnings("unchecked") @PublicEvolving public static <X extends Tuple> TupleTypeInfo<X> getBasicAndBasicValueTupleTypeInfo(Class<?>... basicTypes) {     if (basicTypes == null || basicTypes.length == 0) {         throw new IllegalArgumentException().     }     TypeInformation<?>[] infos = new TypeInformation<?>[basicTypes.length].     for (int i = 0. i < infos.length. i++) {         Class<?> type = basicTypes[i].         if (type == null) {             throw new IllegalArgumentException("Type at position " + i + " is null.").         }         TypeInformation<?> info = BasicTypeInfo.getInfoFor(type).         if (info == null) {             try {                 info = ValueTypeInfo.getValueTypeInfo((Class<Value>) type).                 if (!((ValueTypeInfo<?>) info).isBasicValueType()) {                     throw new IllegalArgumentException("Type at position " + i + " is not a basic or value type.").                 }             } catch (ClassCastException | InvalidTypesException e) {                 throw new IllegalArgumentException("Type at position " + i + " is not a basic or value type.", e).             }         }         infos[i] = info.     }     return (TupleTypeInfo<X>) new TupleTypeInfo<>(infos). }
false;private,static;1;7;;private static int[] listToPrimitives(ArrayList<Integer> ints) {     int[] result = new int[ints.size()].     for (int i = 0. i < result.length. i++) {         result[i] = ints.get(i).     }     return result. }
