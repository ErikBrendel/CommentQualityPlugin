commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;@Override public void close() throws IOException {     try {         DataOutputViewStreamWrapper o = this.outView.         if (o != null) {             o.close().         }     } finally {         super.close().     } }
false;protected;1;1;;protected void complementBlockInfo(BlockInfo blockInfo) { }
false;public;1;13;;@Override public void configure(Configuration parameters) {     super.configure(parameters).     // read own parameters     this.blockSize = parameters.getLong(BLOCK_SIZE_PARAMETER_KEY, NATIVE_BLOCK_SIZE).     if (this.blockSize < 1 && this.blockSize != NATIVE_BLOCK_SIZE) {         throw new IllegalArgumentException("The block size parameter must be set and larger than 0.").     }     if (this.blockSize > Integer.MAX_VALUE) {         throw new UnsupportedOperationException("Currently only block size up to Integer.MAX_VALUE are supported").     } }
false;protected;0;3;;protected BlockInfo createBlockInfo() {     return new BlockInfo(). }
false;public;2;10;;@Override public void open(int taskNumber, int numTasks) throws IOException {     super.open(taskNumber, numTasks).     final long blockSize = this.blockSize == NATIVE_BLOCK_SIZE ? this.outputFilePath.getFileSystem().getDefaultBlockSize() : this.blockSize.     this.blockBasedOutput = new BlockBasedOutput(this.stream, (int) blockSize).     this.outView = new DataOutputViewStreamWrapper(this.blockBasedOutput). }
false;protected,abstract;2;1;;protected abstract void serialize(T record, DataOutputView dataOutput) throws IOException.
false;public;1;5;;@Override public void writeRecord(T record) throws IOException {     this.blockBasedOutput.startRecord().     this.serialize(record, outView). }
false;public;0;8;;@Override public void close() throws IOException {     if (this.blockPos > 0) {         this.writeInfo().     }     super.flush().     super.close(). }
false;public;0;7;;public void startRecord() {     if (this.firstRecordStartPos == NO_RECORD) {         this.firstRecordStartPos = this.blockPos.     }     this.blockCount++.     this.totalCount++. }
false;public;1;4;;@Override public void write(byte[] b) throws IOException {     this.write(b, 0, b.length). }
false;public;3;15;;@Override public void write(byte[] b, int off, int len) throws IOException {     for (int remainingLength = len, offset = off. remainingLength > 0. ) {         int blockLen = Math.min(remainingLength, this.maxPayloadSize - this.blockPos).         this.out.write(b, offset, blockLen).         this.blockPos += blockLen.         if (this.blockPos >= this.maxPayloadSize) {             this.writeInfo().         }         remainingLength -= blockLen.         offset += blockLen.     } }
false;public;1;7;;@Override public void write(int b) throws IOException {     super.write(b).     if (++this.blockPos >= this.maxPayloadSize) {         this.writeInfo().     } }
false;private;0;10;;private void writeInfo() throws IOException {     this.blockInfo.setRecordCount(this.blockCount).     this.blockInfo.setAccumulatedRecordCount(this.totalCount).     this.blockInfo.setFirstRecordStart(this.firstRecordStartPos == NO_RECORD ? 0 : this.firstRecordStartPos).     BinaryOutputFormat.this.complementBlockInfo(this.blockInfo).     this.blockInfo.write(this.headerStream).     this.blockPos = 0.     this.blockCount = 0.     this.firstRecordStartPos = NO_RECORD. }
