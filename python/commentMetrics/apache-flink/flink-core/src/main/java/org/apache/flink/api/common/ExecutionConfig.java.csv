commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Enables the ClosureCleaner. This analyzes user code functions and sets fields to null  * that are not used. This will in most cases make closures or anonymous inner classes  * serializable that where not serializable due to some Scala or Java implementation artifact.  * User code must be serializable because it needs to be sent to worker nodes.  */ ;// -------------------------------------------------------------------------------------------- /**  * Enables the ClosureCleaner. This analyzes user code functions and sets fields to null  * that are not used. This will in most cases make closures or anonymous inner classes  * serializable that where not serializable due to some Scala or Java implementation artifact.  * User code must be serializable because it needs to be sent to worker nodes.  */ public ExecutionConfig enableClosureCleaner() {     useClosureCleaner = true.     return this. }
true;public;0;4;/**  * Disables the ClosureCleaner.  *  * @see #enableClosureCleaner()  */ ;/**  * Disables the ClosureCleaner.  *  * @see #enableClosureCleaner()  */ public ExecutionConfig disableClosureCleaner() {     useClosureCleaner = false.     return this. }
true;public;0;3;/**  * Returns whether the ClosureCleaner is enabled.  *  * @see #enableClosureCleaner()  */ ;/**  * Returns whether the ClosureCleaner is enabled.  *  * @see #enableClosureCleaner()  */ public boolean isClosureCleanerEnabled() {     return useClosureCleaner. }
true;public;1;5;/**  * Sets the interval of the automatic watermark emission. Watermarks are used throughout  * the streaming system to keep track of the progress of time. They are used, for example,  * for time based windowing.  *  * @param interval The interval between watermarks in milliseconds.  */ ;/**  * Sets the interval of the automatic watermark emission. Watermarks are used throughout  * the streaming system to keep track of the progress of time. They are used, for example,  * for time based windowing.  *  * @param interval The interval between watermarks in milliseconds.  */ @PublicEvolving public ExecutionConfig setAutoWatermarkInterval(long interval) {     this.autoWatermarkInterval = interval.     return this. }
true;public;0;4;/**  * Returns the interval of the automatic watermark emission.  *  * @see #setAutoWatermarkInterval(long)  */ ;/**  * Returns the interval of the automatic watermark emission.  *  * @see #setAutoWatermarkInterval(long)  */ @PublicEvolving public long getAutoWatermarkInterval() {     return this.autoWatermarkInterval. }
true;public;1;6;/**  * Interval for sending latency tracking marks from the sources to the sinks.  * Flink will send latency tracking marks from the sources at the specified interval.  *  * Setting a tracking interval <= 0 disables the latency tracking.  *  * @param interval Interval in milliseconds.  */ ;/**  * Interval for sending latency tracking marks from the sources to the sinks.  * Flink will send latency tracking marks from the sources at the specified interval.  *  * Setting a tracking interval <= 0 disables the latency tracking.  *  * @param interval Interval in milliseconds.  */ @PublicEvolving public ExecutionConfig setLatencyTrackingInterval(long interval) {     this.latencyTrackingInterval = interval.     this.isLatencyTrackingConfigured = true.     return this. }
true;public;0;4;/**  * Returns the latency tracking interval.  * @return The latency tracking interval in milliseconds  */ ;/**  * Returns the latency tracking interval.  * @return The latency tracking interval in milliseconds  */ @PublicEvolving public long getLatencyTrackingInterval() {     return latencyTrackingInterval. }
true;public;0;5;/**  * @deprecated will be removed in a future version  */ ;/**  * @deprecated will be removed in a future version  */ @PublicEvolving @Deprecated public boolean isLatencyTrackingEnabled() {     return isLatencyTrackingConfigured && latencyTrackingInterval > 0. }
false;public;0;4;;@Internal public boolean isLatencyTrackingConfigured() {     return isLatencyTrackingConfigured. }
true;public;0;3;/**  * Gets the parallelism with which operation are executed by default. Operations can  * individually override this value to use a specific parallelism.  *  * Other operations may need to run with a different parallelism - for example calling  * a reduce operation over the entire data set will involve an operation that runs  * with a parallelism of one (the final reduce to the single result value).  *  * @return The parallelism used by operations, unless they override that value. This method  *         returns {@link #PARALLELISM_DEFAULT} if the environment's default parallelism  *         should be used.  */ ;/**  * Gets the parallelism with which operation are executed by default. Operations can  * individually override this value to use a specific parallelism.  *  * Other operations may need to run with a different parallelism - for example calling  * a reduce operation over the entire data set will involve an operation that runs  * with a parallelism of one (the final reduce to the single result value).  *  * @return The parallelism used by operations, unless they override that value. This method  *         returns {@link #PARALLELISM_DEFAULT} if the environment's default parallelism  *         should be used.  */ public int getParallelism() {     return parallelism. }
true;public;1;10;/**  * Sets the parallelism for operations executed through this environment.  * Setting a parallelism of x here will cause all operators (such as join, map, reduce) to run with  * x parallel instances.  * <p>  * This method overrides the default parallelism for this environment.  * The local execution environment uses by default a value equal to the number of hardware  * contexts (CPU cores / threads). When executing the program via the command line client  * from a JAR file, the default parallelism is the one configured for that setup.  *  * @param parallelism The parallelism to use  */ ;/**  * Sets the parallelism for operations executed through this environment.  * Setting a parallelism of x here will cause all operators (such as join, map, reduce) to run with  * x parallel instances.  * <p>  * This method overrides the default parallelism for this environment.  * The local execution environment uses by default a value equal to the number of hardware  * contexts (CPU cores / threads). When executing the program via the command line client  * from a JAR file, the default parallelism is the one configured for that setup.  *  * @param parallelism The parallelism to use  */ public ExecutionConfig setParallelism(int parallelism) {     if (parallelism != PARALLELISM_UNKNOWN) {         if (parallelism < 1 && parallelism != PARALLELISM_DEFAULT) {             throw new IllegalArgumentException("Parallelism must be at least one, or ExecutionConfig.PARALLELISM_DEFAULT (use system default).").         }         this.parallelism = parallelism.     }     return this. }
true;public;0;4;/**  * Gets the maximum degree of parallelism defined for the program.  *  * The maximum degree of parallelism specifies the upper limit for dynamic scaling. It also  * defines the number of key groups used for partitioned state.  *  * @return Maximum degree of parallelism  */ ;/**  * Gets the maximum degree of parallelism defined for the program.  *  * The maximum degree of parallelism specifies the upper limit for dynamic scaling. It also  * defines the number of key groups used for partitioned state.  *  * @return Maximum degree of parallelism  */ @PublicEvolving public int getMaxParallelism() {     return maxParallelism. }
true;public;1;5;/**  * Sets the maximum degree of parallelism defined for the program.  *  * The maximum degree of parallelism specifies the upper limit for dynamic scaling. It also  * defines the number of key groups used for partitioned state.  *  * @param maxParallelism Maximum degree of parallelism to be used for the program.  */ ;/**  * Sets the maximum degree of parallelism defined for the program.  *  * The maximum degree of parallelism specifies the upper limit for dynamic scaling. It also  * defines the number of key groups used for partitioned state.  *  * @param maxParallelism Maximum degree of parallelism to be used for the program.  */ @PublicEvolving public void setMaxParallelism(int maxParallelism) {     checkArgument(maxParallelism > 0, "The maximum parallelism must be greater than 0.").     this.maxParallelism = maxParallelism. }
true;public;0;3;/**  * Gets the interval (in milliseconds) between consecutive attempts to cancel a running task.  */ ;/**  * Gets the interval (in milliseconds) between consecutive attempts to cancel a running task.  */ public long getTaskCancellationInterval() {     return this.taskCancellationIntervalMillis. }
true;public;1;4;/**  * Sets the configuration parameter specifying the interval (in milliseconds)  * between consecutive attempts to cancel a running task.  * @param interval the interval (in milliseconds).  */ ;/**  * Sets the configuration parameter specifying the interval (in milliseconds)  * between consecutive attempts to cancel a running task.  * @param interval the interval (in milliseconds).  */ public ExecutionConfig setTaskCancellationInterval(long interval) {     this.taskCancellationIntervalMillis = interval.     return this. }
true;public;0;4;/**  * Returns the timeout (in milliseconds) after which an ongoing task  * cancellation leads to a fatal TaskManager error.  *  * <p>The value <code>0</code> means that the timeout is disabled. In  * this case a stuck cancellation will not lead to a fatal error.  */ ;/**  * Returns the timeout (in milliseconds) after which an ongoing task  * cancellation leads to a fatal TaskManager error.  *  * <p>The value <code>0</code> means that the timeout is disabled. In  * this case a stuck cancellation will not lead to a fatal error.  */ @PublicEvolving public long getTaskCancellationTimeout() {     return this.taskCancellationTimeoutMillis. }
true;public;1;6;/**  * Sets the timeout (in milliseconds) after which an ongoing task cancellation  * is considered failed, leading to a fatal TaskManager error.  *  * <p>The cluster default is configured via {@link TaskManagerOptions#TASK_CANCELLATION_TIMEOUT}.  *  * <p>The value <code>0</code> disables the timeout. In this case a stuck  * cancellation will not lead to a fatal error.  *  * @param timeout The task cancellation timeout (in milliseconds).  */ ;/**  * Sets the timeout (in milliseconds) after which an ongoing task cancellation  * is considered failed, leading to a fatal TaskManager error.  *  * <p>The cluster default is configured via {@link TaskManagerOptions#TASK_CANCELLATION_TIMEOUT}.  *  * <p>The value <code>0</code> disables the timeout. In this case a stuck  * cancellation will not lead to a fatal error.  *  * @param timeout The task cancellation timeout (in milliseconds).  */ @PublicEvolving public ExecutionConfig setTaskCancellationTimeout(long timeout) {     checkArgument(timeout >= 0, "Timeout needs to be >= 0.").     this.taskCancellationTimeoutMillis = timeout.     return this. }
true;public;1;4;/**  * Sets the restart strategy to be used for recovery.  *  * <pre>{@code  * ExecutionConfig config = env.getConfig().  *  * config.setRestartStrategy(RestartStrategies.fixedDelayRestart(  * 	10,  // number of retries  * 	1000 // delay between retries)).  * }</pre>  *  * @param restartStrategyConfiguration Configuration defining the restart strategy to use  */ ;/**  * Sets the restart strategy to be used for recovery.  *  * <pre>{@code  * ExecutionConfig config = env.getConfig().  *  * config.setRestartStrategy(RestartStrategies.fixedDelayRestart(  * 	10,  // number of retries  * 	1000 // delay between retries)).  * }</pre>  *  * @param restartStrategyConfiguration Configuration defining the restart strategy to use  */ @PublicEvolving public void setRestartStrategy(RestartStrategies.RestartStrategyConfiguration restartStrategyConfiguration) {     this.restartStrategyConfiguration = Preconditions.checkNotNull(restartStrategyConfiguration). }
true;public;0;16;/**  * Returns the restart strategy which has been set for the current job.  *  * @return The specified restart configuration  */ ;/**  * Returns the restart strategy which has been set for the current job.  *  * @return The specified restart configuration  */ @PublicEvolving @SuppressWarnings("deprecation") public RestartStrategies.RestartStrategyConfiguration getRestartStrategy() {     if (restartStrategyConfiguration instanceof RestartStrategies.FallbackRestartStrategyConfiguration) {         // support the old API calls by creating a restart strategy from them         if (getNumberOfExecutionRetries() > 0 && getExecutionRetryDelay() >= 0) {             return RestartStrategies.fixedDelayRestart(getNumberOfExecutionRetries(), getExecutionRetryDelay()).         } else if (getNumberOfExecutionRetries() == 0) {             return RestartStrategies.noRestart().         } else {             return restartStrategyConfiguration.         }     } else {         return restartStrategyConfiguration.     } }
true;public;0;4;/**  * Gets the number of times the system will try to re-execute failed tasks. A value  * of {@code -1} indicates that the system default value (as defined in the configuration)  * should be used.  *  * @return The number of times the system will try to re-execute failed tasks.  *  * @deprecated Should no longer be used because it is subsumed by RestartStrategyConfiguration  */ ;/**  * Gets the number of times the system will try to re-execute failed tasks. A value  * of {@code -1} indicates that the system default value (as defined in the configuration)  * should be used.  *  * @return The number of times the system will try to re-execute failed tasks.  *  * @deprecated Should no longer be used because it is subsumed by RestartStrategyConfiguration  */ @Deprecated public int getNumberOfExecutionRetries() {     return numberOfExecutionRetries. }
true;public;0;4;/**  * Returns the delay between execution retries.  *  * @return The delay between successive execution retries in milliseconds.  *  * @deprecated Should no longer be used because it is subsumed by RestartStrategyConfiguration  */ ;/**  * Returns the delay between execution retries.  *  * @return The delay between successive execution retries in milliseconds.  *  * @deprecated Should no longer be used because it is subsumed by RestartStrategyConfiguration  */ @Deprecated public long getExecutionRetryDelay() {     return executionRetryDelay. }
true;public;1;9;/**  * Sets the number of times that failed tasks are re-executed. A value of zero  * effectively disables fault tolerance. A value of {@code -1} indicates that the system  * default value (as defined in the configuration) should be used.  *  * @param numberOfExecutionRetries The number of times the system will try to re-execute failed tasks.  *  * @return The current execution configuration  *  * @deprecated This method will be replaced by {@link #setRestartStrategy}. The  * {@link RestartStrategies.FixedDelayRestartStrategyConfiguration} contains the number of  * execution retries.  */ ;/**  * Sets the number of times that failed tasks are re-executed. A value of zero  * effectively disables fault tolerance. A value of {@code -1} indicates that the system  * default value (as defined in the configuration) should be used.  *  * @param numberOfExecutionRetries The number of times the system will try to re-execute failed tasks.  *  * @return The current execution configuration  *  * @deprecated This method will be replaced by {@link #setRestartStrategy}. The  * {@link RestartStrategies.FixedDelayRestartStrategyConfiguration} contains the number of  * execution retries.  */ @Deprecated public ExecutionConfig setNumberOfExecutionRetries(int numberOfExecutionRetries) {     if (numberOfExecutionRetries < -1) {         throw new IllegalArgumentException("The number of execution retries must be non-negative, or -1 (use system default)").     }     this.numberOfExecutionRetries = numberOfExecutionRetries.     return this. }
true;public;1;9;/**  * Sets the delay between executions.  *  * @param executionRetryDelay The number of milliseconds the system will wait to retry.  *  * @return The current execution configuration  *  * @deprecated This method will be replaced by {@link #setRestartStrategy}. The  * {@link RestartStrategies.FixedDelayRestartStrategyConfiguration} contains the delay between  * successive execution attempts.  */ ;/**  * Sets the delay between executions.  *  * @param executionRetryDelay The number of milliseconds the system will wait to retry.  *  * @return The current execution configuration  *  * @deprecated This method will be replaced by {@link #setRestartStrategy}. The  * {@link RestartStrategies.FixedDelayRestartStrategyConfiguration} contains the delay between  * successive execution attempts.  */ @Deprecated public ExecutionConfig setExecutionRetryDelay(long executionRetryDelay) {     if (executionRetryDelay < 0) {         throw new IllegalArgumentException("The delay between retries must be non-negative.").     }     this.executionRetryDelay = executionRetryDelay.     return this. }
true;public;1;3;/**  * Sets the execution mode to execute the program. The execution mode defines whether  * data exchanges are performed in a batch or on a pipelined manner.  *  * The default execution mode is {@link ExecutionMode#PIPELINED}.  *  * @param executionMode The execution mode to use.  */ ;/**  * Sets the execution mode to execute the program. The execution mode defines whether  * data exchanges are performed in a batch or on a pipelined manner.  *  * The default execution mode is {@link ExecutionMode#PIPELINED}.  *  * @param executionMode The execution mode to use.  */ public void setExecutionMode(ExecutionMode executionMode) {     this.executionMode = executionMode. }
true;public;0;3;/**  * Gets the execution mode used to execute the program. The execution mode defines whether  * data exchanges are performed in a batch or on a pipelined manner.  *  * The default execution mode is {@link ExecutionMode#PIPELINED}.  *  * @return The execution mode for the program.  */ ;/**  * Gets the execution mode used to execute the program. The execution mode defines whether  * data exchanges are performed in a batch or on a pipelined manner.  *  * The default execution mode is {@link ExecutionMode#PIPELINED}.  *  * @return The execution mode for the program.  */ public ExecutionMode getExecutionMode() {     return executionMode. }
true;public;1;4;/**  * Sets the default input dependency constraint for vertex scheduling. It indicates when a task  * should be scheduled considering its inputs status.  *  * <p>The default constraint is {@link InputDependencyConstraint#ANY}.  *  * @param inputDependencyConstraint The input dependency constraint.  */ ;/**  * Sets the default input dependency constraint for vertex scheduling. It indicates when a task  * should be scheduled considering its inputs status.  *  * <p>The default constraint is {@link InputDependencyConstraint#ANY}.  *  * @param inputDependencyConstraint The input dependency constraint.  */ @PublicEvolving public void setDefaultInputDependencyConstraint(InputDependencyConstraint inputDependencyConstraint) {     this.defaultInputDependencyConstraint = inputDependencyConstraint. }
true;public;0;4;/**  * Gets the default input dependency constraint for vertex scheduling. It indicates when a task  * should be scheduled considering its inputs status.  *  * <p>The default constraint is {@link InputDependencyConstraint#ANY}.  *  * @return The input dependency constraint of this job.  */ ;/**  * Gets the default input dependency constraint for vertex scheduling. It indicates when a task  * should be scheduled considering its inputs status.  *  * <p>The default constraint is {@link InputDependencyConstraint#ANY}.  *  * @return The input dependency constraint of this job.  */ @PublicEvolving public InputDependencyConstraint getDefaultInputDependencyConstraint() {     return defaultInputDependencyConstraint. }
true;public;0;3;/**  * Force TypeExtractor to use Kryo serializer for POJOS even though we could analyze as POJO.  * In some cases this might be preferable. For example, when using interfaces  * with subclasses that cannot be analyzed as POJO.  */ ;/**  * Force TypeExtractor to use Kryo serializer for POJOS even though we could analyze as POJO.  * In some cases this might be preferable. For example, when using interfaces  * with subclasses that cannot be analyzed as POJO.  */ public void enableForceKryo() {     forceKryo = true. }
true;public;0;3;/**  * Disable use of Kryo serializer for all POJOs.  */ ;/**  * Disable use of Kryo serializer for all POJOs.  */ public void disableForceKryo() {     forceKryo = false. }
false;public;0;3;;public boolean isForceKryoEnabled() {     return forceKryo. }
true;public;0;3;/**  * Enables the use generic types which are serialized via Kryo.  *  * <p>Generic types are enabled by default.  *  * @see #disableGenericTypes()  */ ;/**  * Enables the use generic types which are serialized via Kryo.  *  * <p>Generic types are enabled by default.  *  * @see #disableGenericTypes()  */ public void enableGenericTypes() {     disableGenericTypes = false. }
true;public;0;3;/**  * Disables the use of generic types (types that would be serialized via Kryo). If this option  * is used, Flink will throw an {@code UnsupportedOperationException} whenever it encounters  * a data type that would go through Kryo for serialization.  *  * <p>Disabling generic types can be helpful to eagerly find and eliminate the use of types  * that would go through Kryo serialization during runtime. Rather than checking types  * individually, using this option will throw exceptions eagerly in the places where generic  * types are used.  *  * <p><b>Important:</b> We recommend to use this option only during development and pre-production  * phases, not during actual production use. The application program and/or the input data may be  * such that new, previously unseen, types occur at some point. In that case, setting this option  * would cause the program to fail.  *  * @see #enableGenericTypes()  */ ;/**  * Disables the use of generic types (types that would be serialized via Kryo). If this option  * is used, Flink will throw an {@code UnsupportedOperationException} whenever it encounters  * a data type that would go through Kryo for serialization.  *  * <p>Disabling generic types can be helpful to eagerly find and eliminate the use of types  * that would go through Kryo serialization during runtime. Rather than checking types  * individually, using this option will throw exceptions eagerly in the places where generic  * types are used.  *  * <p><b>Important:</b> We recommend to use this option only during development and pre-production  * phases, not during actual production use. The application program and/or the input data may be  * such that new, previously unseen, types occur at some point. In that case, setting this option  * would cause the program to fail.  *  * @see #enableGenericTypes()  */ public void disableGenericTypes() {     disableGenericTypes = true. }
true;public;0;3;/**  * Checks whether generic types are supported. Generic types are types that go through Kryo during  * serialization.  *  * <p>Generic types are enabled by default.  *  * @see #enableGenericTypes()  * @see #disableGenericTypes()  */ ;/**  * Checks whether generic types are supported. Generic types are types that go through Kryo during  * serialization.  *  * <p>Generic types are enabled by default.  *  * @see #enableGenericTypes()  * @see #disableGenericTypes()  */ public boolean hasGenericTypesDisabled() {     return disableGenericTypes. }
true;public;0;3;/**  * Forces Flink to use the Apache Avro serializer for POJOs.  *  * <b>Important:</b> Make sure to include the <i>flink-avro</i> module.  */ ;/**  * Forces Flink to use the Apache Avro serializer for POJOs.  *  * <b>Important:</b> Make sure to include the <i>flink-avro</i> module.  */ public void enableForceAvro() {     forceAvro = true. }
true;public;0;3;/**  * Disables the Apache Avro serializer as the forced serializer for POJOs.  */ ;/**  * Disables the Apache Avro serializer as the forced serializer for POJOs.  */ public void disableForceAvro() {     forceAvro = false. }
true;public;0;3;/**  * Returns whether the Apache Avro is the default serializer for POJOs.  */ ;/**  * Returns whether the Apache Avro is the default serializer for POJOs.  */ public boolean isForceAvroEnabled() {     return forceAvro. }
true;public;0;4;/**  * Enables reusing objects that Flink internally uses for deserialization and passing  * data to user-code functions. Keep in mind that this can lead to bugs when the  * user-code function of an operation is not aware of this behaviour.  */ ;/**  * Enables reusing objects that Flink internally uses for deserialization and passing  * data to user-code functions. Keep in mind that this can lead to bugs when the  * user-code function of an operation is not aware of this behaviour.  */ public ExecutionConfig enableObjectReuse() {     objectReuse = true.     return this. }
true;public;0;4;/**  * Disables reusing objects that Flink internally uses for deserialization and passing  * data to user-code functions. @see #enableObjectReuse()  */ ;/**  * Disables reusing objects that Flink internally uses for deserialization and passing  * data to user-code functions. @see #enableObjectReuse()  */ public ExecutionConfig disableObjectReuse() {     objectReuse = false.     return this. }
true;public;0;3;/**  * Returns whether object reuse has been enabled or disabled. @see #enableObjectReuse()  */ ;/**  * Returns whether object reuse has been enabled or disabled. @see #enableObjectReuse()  */ public boolean isObjectReuseEnabled() {     return objectReuse. }
true;public;1;4;/**  * Sets the {@link CodeAnalysisMode} of the program. Specifies to which extent user-defined  * functions are analyzed in order to give the Flink optimizer an insight of UDF internals  * and inform the user about common implementation mistakes. The static code analyzer pre-interprets  * user-defined functions in order to get implementation insights for program improvements  * that can be printed to the log, automatically applied, or disabled.  *  * @param codeAnalysisMode see {@link CodeAnalysisMode}  */ ;/**  * Sets the {@link CodeAnalysisMode} of the program. Specifies to which extent user-defined  * functions are analyzed in order to give the Flink optimizer an insight of UDF internals  * and inform the user about common implementation mistakes. The static code analyzer pre-interprets  * user-defined functions in order to get implementation insights for program improvements  * that can be printed to the log, automatically applied, or disabled.  *  * @param codeAnalysisMode see {@link CodeAnalysisMode}  */ @PublicEvolving public void setCodeAnalysisMode(CodeAnalysisMode codeAnalysisMode) {     this.codeAnalysisMode = codeAnalysisMode. }
true;public;0;4;/**  * Returns the {@link CodeAnalysisMode} of the program.  */ ;/**  * Returns the {@link CodeAnalysisMode} of the program.  */ @PublicEvolving public CodeAnalysisMode getCodeAnalysisMode() {     return codeAnalysisMode. }
true;public;0;4;/**  * Enables the printing of progress update messages to {@code System.out}  *  * @return The ExecutionConfig object, to allow for function chaining.  */ ;/**  * Enables the printing of progress update messages to {@code System.out}  *  * @return The ExecutionConfig object, to allow for function chaining.  */ public ExecutionConfig enableSysoutLogging() {     this.printProgressDuringExecution = true.     return this. }
true;public;0;4;/**  * Disables the printing of progress update messages to {@code System.out}  *  * @return The ExecutionConfig object, to allow for function chaining.  */ ;/**  * Disables the printing of progress update messages to {@code System.out}  *  * @return The ExecutionConfig object, to allow for function chaining.  */ public ExecutionConfig disableSysoutLogging() {     this.printProgressDuringExecution = false.     return this. }
true;public;0;3;/**  * Gets whether progress update messages should be printed to {@code System.out}  *  * @return True, if progress update messages should be printed, false otherwise.  */ ;/**  * Gets whether progress update messages should be printed to {@code System.out}  *  * @return True, if progress update messages should be printed, false otherwise.  */ public boolean isSysoutLoggingEnabled() {     return this.printProgressDuringExecution. }
false;public;0;3;;public GlobalJobParameters getGlobalJobParameters() {     return globalJobParameters. }
true;public;1;3;/**  * Register a custom, serializable user configuration object.  * @param globalJobParameters Custom user configuration object  */ ;/**  * Register a custom, serializable user configuration object.  * @param globalJobParameters Custom user configuration object  */ public void setGlobalJobParameters(GlobalJobParameters globalJobParameters) {     this.globalJobParameters = globalJobParameters. }
true;public;2;7;/**  * Adds a new Kryo default serializer to the Runtime.  *  * Note that the serializer instance must be serializable (as defined by java.io.Serializable),  * because it may be distributed to the worker nodes by java serialization.  *  * @param type The class of the types serialized with the given serializer.  * @param serializer The serializer to use.  */ ;// -------------------------------------------------------------------------------------------- // Registry for types and serializers // -------------------------------------------------------------------------------------------- /**  * Adds a new Kryo default serializer to the Runtime.  *  * Note that the serializer instance must be serializable (as defined by java.io.Serializable),  * because it may be distributed to the worker nodes by java serialization.  *  * @param type The class of the types serialized with the given serializer.  * @param serializer The serializer to use.  */ public <T extends Serializer<?> & Serializable> void addDefaultKryoSerializer(Class<?> type, T serializer) {     if (type == null || serializer == null) {         throw new NullPointerException("Cannot register null class or serializer.").     }     defaultKryoSerializers.put(type, new SerializableSerializer<>(serializer)). }
true;public;2;6;/**  * Adds a new Kryo default serializer to the Runtime.  *  * @param type The class of the types serialized with the given serializer.  * @param serializerClass The class of the serializer to use.  */ ;/**  * Adds a new Kryo default serializer to the Runtime.  *  * @param type The class of the types serialized with the given serializer.  * @param serializerClass The class of the serializer to use.  */ public void addDefaultKryoSerializer(Class<?> type, Class<? extends Serializer<?>> serializerClass) {     if (type == null || serializerClass == null) {         throw new NullPointerException("Cannot register null class or serializer.").     }     defaultKryoSerializerClasses.put(type, serializerClass). }
true;public;2;7;/**  * Registers the given type with a Kryo Serializer.  *  * Note that the serializer instance must be serializable (as defined by java.io.Serializable),  * because it may be distributed to the worker nodes by java serialization.  *  * @param type The class of the types serialized with the given serializer.  * @param serializer The serializer to use.  */ ;/**  * Registers the given type with a Kryo Serializer.  *  * Note that the serializer instance must be serializable (as defined by java.io.Serializable),  * because it may be distributed to the worker nodes by java serialization.  *  * @param type The class of the types serialized with the given serializer.  * @param serializer The serializer to use.  */ public <T extends Serializer<?> & Serializable> void registerTypeWithKryoSerializer(Class<?> type, T serializer) {     if (type == null || serializer == null) {         throw new NullPointerException("Cannot register null class or serializer.").     }     registeredTypesWithKryoSerializers.put(type, new SerializableSerializer<>(serializer)). }
true;public;2;10;/**  * Registers the given Serializer via its class as a serializer for the given type at the KryoSerializer  *  * @param type The class of the types serialized with the given serializer.  * @param serializerClass The class of the serializer to use.  */ ;/**  * Registers the given Serializer via its class as a serializer for the given type at the KryoSerializer  *  * @param type The class of the types serialized with the given serializer.  * @param serializerClass The class of the serializer to use.  */ @SuppressWarnings("rawtypes") public void registerTypeWithKryoSerializer(Class<?> type, Class<? extends Serializer> serializerClass) {     if (type == null || serializerClass == null) {         throw new NullPointerException("Cannot register null class or serializer.").     }     @SuppressWarnings("unchecked")     Class<? extends Serializer<?>> castedSerializerClass = (Class<? extends Serializer<?>>) serializerClass.     registeredTypesWithKryoSerializerClasses.put(type, castedSerializerClass). }
true;public;1;8;/**  * Registers the given type with the serialization stack. If the type is eventually  * serialized as a POJO, then the type is registered with the POJO serializer. If the  * type ends up being serialized with Kryo, then it will be registered at Kryo to make  * sure that only tags are written.  *  * @param type The class of the type to register.  */ ;/**  * Registers the given type with the serialization stack. If the type is eventually  * serialized as a POJO, then the type is registered with the POJO serializer. If the  * type ends up being serialized with Kryo, then it will be registered at Kryo to make  * sure that only tags are written.  *  * @param type The class of the type to register.  */ public void registerPojoType(Class<?> type) {     if (type == null) {         throw new NullPointerException("Cannot register null type class.").     }     if (!registeredPojoTypes.contains(type)) {         registeredPojoTypes.add(type).     } }
true;public;1;6;/**  * Registers the given type with the serialization stack. If the type is eventually  * serialized as a POJO, then the type is registered with the POJO serializer. If the  * type ends up being serialized with Kryo, then it will be registered at Kryo to make  * sure that only tags are written.  *  * @param type The class of the type to register.  */ ;/**  * Registers the given type with the serialization stack. If the type is eventually  * serialized as a POJO, then the type is registered with the POJO serializer. If the  * type ends up being serialized with Kryo, then it will be registered at Kryo to make  * sure that only tags are written.  *  * @param type The class of the type to register.  */ public void registerKryoType(Class<?> type) {     if (type == null) {         throw new NullPointerException("Cannot register null type class.").     }     registeredKryoTypes.add(type). }
true;public;0;3;/**  * Returns the registered types with Kryo Serializers.  */ ;/**  * Returns the registered types with Kryo Serializers.  */ public LinkedHashMap<Class<?>, SerializableSerializer<?>> getRegisteredTypesWithKryoSerializers() {     return registeredTypesWithKryoSerializers. }
true;public;0;3;/**  * Returns the registered types with their Kryo Serializer classes.  */ ;/**  * Returns the registered types with their Kryo Serializer classes.  */ public LinkedHashMap<Class<?>, Class<? extends Serializer<?>>> getRegisteredTypesWithKryoSerializerClasses() {     return registeredTypesWithKryoSerializerClasses. }
true;public;0;3;/**  * Returns the registered default Kryo Serializers.  */ ;/**  * Returns the registered default Kryo Serializers.  */ public LinkedHashMap<Class<?>, SerializableSerializer<?>> getDefaultKryoSerializers() {     return defaultKryoSerializers. }
true;public;0;3;/**  * Returns the registered default Kryo Serializer classes.  */ ;/**  * Returns the registered default Kryo Serializer classes.  */ public LinkedHashMap<Class<?>, Class<? extends Serializer<?>>> getDefaultKryoSerializerClasses() {     return defaultKryoSerializerClasses. }
true;public;0;16;/**  * Returns the registered Kryo types.  */ ;/**  * Returns the registered Kryo types.  */ public LinkedHashSet<Class<?>> getRegisteredKryoTypes() {     if (isForceKryoEnabled()) {         // if we force kryo, we must also return all the types that         // were previously only registered as POJO         LinkedHashSet<Class<?>> result = new LinkedHashSet<>().         result.addAll(registeredKryoTypes).         for (Class<?> t : registeredPojoTypes) {             if (!result.contains(t)) {                 result.add(t).             }         }         return result.     } else {         return registeredKryoTypes.     } }
true;public;0;3;/**  * Returns the registered POJO types.  */ ;/**  * Returns the registered POJO types.  */ public LinkedHashSet<Class<?>> getRegisteredPojoTypes() {     return registeredPojoTypes. }
false;public;0;3;;public boolean isAutoTypeRegistrationDisabled() {     return !autoTypeRegistrationEnabled. }
true;public;0;3;/**  * Control whether Flink is automatically registering all types in the user programs with  * Kryo.  */ ;/**  * Control whether Flink is automatically registering all types in the user programs with  * Kryo.  */ public void disableAutoTypeRegistration() {     this.autoTypeRegistrationEnabled = false. }
false;public;0;3;;public boolean isUseSnapshotCompression() {     return useSnapshotCompression. }
false;public;1;3;;public void setUseSnapshotCompression(boolean useSnapshotCompression) {     this.useSnapshotCompression = useSnapshotCompression. }
true;public;0;4;/**  * This method is visible because of the way the configuration is currently forwarded from the checkpoint config to  * the task. This should not be called by the user, please use CheckpointConfig.isFailTaskOnCheckpointError()  * instead.  */ ;/**  * This method is visible because of the way the configuration is currently forwarded from the checkpoint config to  * the task. This should not be called by the user, please use CheckpointConfig.isFailTaskOnCheckpointError()  * instead.  */ @Internal public boolean isFailTaskOnCheckpointError() {     return failTaskOnCheckpointError. }
true;public;1;4;/**  * This method is visible because of the way the configuration is currently forwarded from the checkpoint config to  * the task. This should not be called by the user, please use CheckpointConfig.setFailOnCheckpointingErrors(...)  * instead.  */ ;/**  * This method is visible because of the way the configuration is currently forwarded from the checkpoint config to  * the task. This should not be called by the user, please use CheckpointConfig.setFailOnCheckpointingErrors(...)  * instead.  */ @Internal public void setFailTaskOnCheckpointError(boolean failTaskOnCheckpointError) {     this.failTaskOnCheckpointError = failTaskOnCheckpointError. }
false;public;1;32;;@Override public boolean equals(Object obj) {     if (obj instanceof ExecutionConfig) {         ExecutionConfig other = (ExecutionConfig) obj.         return other.canEqual(this) && Objects.equals(executionMode, other.executionMode) && useClosureCleaner == other.useClosureCleaner && parallelism == other.parallelism && ((restartStrategyConfiguration == null && other.restartStrategyConfiguration == null) || (null != restartStrategyConfiguration && restartStrategyConfiguration.equals(other.restartStrategyConfiguration))) && forceKryo == other.forceKryo && disableGenericTypes == other.disableGenericTypes && objectReuse == other.objectReuse && autoTypeRegistrationEnabled == other.autoTypeRegistrationEnabled && forceAvro == other.forceAvro && Objects.equals(codeAnalysisMode, other.codeAnalysisMode) && printProgressDuringExecution == other.printProgressDuringExecution && Objects.equals(globalJobParameters, other.globalJobParameters) && autoWatermarkInterval == other.autoWatermarkInterval && registeredTypesWithKryoSerializerClasses.equals(other.registeredTypesWithKryoSerializerClasses) && defaultKryoSerializerClasses.equals(other.defaultKryoSerializerClasses) && registeredKryoTypes.equals(other.registeredKryoTypes) && registeredPojoTypes.equals(other.registeredPojoTypes) && taskCancellationIntervalMillis == other.taskCancellationIntervalMillis && useSnapshotCompression == other.useSnapshotCompression && defaultInputDependencyConstraint == other.defaultInputDependencyConstraint.     } else {         return false.     } }
false;public;0;24;;@Override public int hashCode() {     return Objects.hash(executionMode, useClosureCleaner, parallelism, restartStrategyConfiguration, forceKryo, disableGenericTypes, objectReuse, autoTypeRegistrationEnabled, forceAvro, codeAnalysisMode, printProgressDuringExecution, globalJobParameters, autoWatermarkInterval, registeredTypesWithKryoSerializerClasses, defaultKryoSerializerClasses, registeredKryoTypes, registeredPojoTypes, taskCancellationIntervalMillis, useSnapshotCompression, defaultInputDependencyConstraint). }
false;public;1;3;;public boolean canEqual(Object obj) {     return obj instanceof ExecutionConfig. }
false;public;0;5;;@Override @Internal public ArchivedExecutionConfig archive() {     return new ArchivedExecutionConfig(this). }
false;public;0;3;;public T getSerializer() {     return serializer. }
true;public;0;3;/**  * Convert UserConfig into a {@code Map<String, String>} representation.  * This can be used by the runtime, for example for presenting the user config in the web frontend.  *  * @return Key/Value representation of the UserConfig  */ ;/**  * Convert UserConfig into a {@code Map<String, String>} representation.  * This can be used by the runtime, for example for presenting the user config in the web frontend.  *  * @return Key/Value representation of the UserConfig  */ public Map<String, String> toMap() {     return Collections.emptyMap(). }
