commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;4;;@Override public final int getCurrentVersion() {     return VERSION. }
false;public,final;1;5;;@Override public final void writeSnapshot(DataOutputView out) throws IOException {     internalWriteOuterSnapshot(out).     nestedSerializersSnapshotDelegate.writeNestedSerializerSnapshots(out). }
false;public,final;3;9;;@Override public final void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     if (readVersion > HIGHEST_LEGACY_READ_VERSION) {         internalReadOuterSnapshot(in, userCodeClassLoader).     } else {         legacyInternalReadOuterSnapshot(readVersion, in, userCodeClassLoader).     }     this.nestedSerializersSnapshotDelegate = NestedSerializersSnapshotDelegate.readNestedSerializerSnapshots(in, userCodeClassLoader). }
false;public,final;1;4;;@Override public final TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializer<T> newSerializer) {     return internalResolveSchemaCompatibility(newSerializer, nestedSerializersSnapshotDelegate.getNestedSerializerSnapshots()). }
false;;2;23;;@Internal TypeSerializerSchemaCompatibility<T> internalResolveSchemaCompatibility(TypeSerializer<T> newSerializer, TypeSerializerSnapshot<?>[] snapshots) {     if (newSerializer.getClass() != correspondingSerializerClass) {         return TypeSerializerSchemaCompatibility.incompatible().     }     S castedNewSerializer = correspondingSerializerClass.cast(newSerializer).     // check that outer configuration is compatible. if not, short circuit result     if (!isOuterSnapshotCompatible(castedNewSerializer)) {         return TypeSerializerSchemaCompatibility.incompatible().     }     final TypeSerializer<?>[] newNestedSerializers = getNestedSerializers(castedNewSerializer).     // check that nested serializer arity remains identical. if not, short circuit result     if (newNestedSerializers.length != snapshots.length) {         return TypeSerializerSchemaCompatibility.incompatible().     }     return constructFinalSchemaCompatibilityResult(newNestedSerializers, snapshots). }
false;;1;4;;@Internal void setNestedSerializersSnapshotDelegate(NestedSerializersSnapshotDelegate delegate) {     this.nestedSerializersSnapshotDelegate = checkNotNull(delegate). }
false;public,final;0;8;;@Override public final TypeSerializer<T> restoreSerializer() {     @SuppressWarnings("unchecked")     TypeSerializer<T> serializer = (TypeSerializer<T>) createOuterSerializerWithNestedSerializers(nestedSerializersSnapshotDelegate.getRestoredNestedSerializers()).     return serializer. }
true;protected,abstract;0;1;/**  * Returns the version of the current outer snapshot's written binary format.  *  * @return the version of the current outer snapshot's written binary format.  */ ;// ------------------------------------------------------------------------------------------ // Outer serializer access methods // ------------------------------------------------------------------------------------------ /**  * Returns the version of the current outer snapshot's written binary format.  *  * @return the version of the current outer snapshot's written binary format.  */ protected abstract int getCurrentOuterSnapshotVersion().
true;protected,abstract;1;1;/**  * Gets the nested serializers from the outer serializer.  *  * @param outerSerializer the outer serializer.  *  * @return the nested serializers.  */ ;/**  * Gets the nested serializers from the outer serializer.  *  * @param outerSerializer the outer serializer.  *  * @return the nested serializers.  */ protected abstract TypeSerializer<?>[] getNestedSerializers(S outerSerializer).
true;protected,abstract;1;1;/**  * Creates an instance of the outer serializer with a given array of its nested serializers.  *  * @param nestedSerializers array of nested serializers to create the outer serializer with.  *  * @return an instance of the outer serializer.  */ ;/**  * Creates an instance of the outer serializer with a given array of its nested serializers.  *  * @param nestedSerializers array of nested serializers to create the outer serializer with.  *  * @return an instance of the outer serializer.  */ protected abstract S createOuterSerializerWithNestedSerializers(TypeSerializer<?>[] nestedSerializers).
true;protected;1;1;/**  * Writes the outer snapshot, i.e. any information beyond the nested serializers of the outer serializer.  *  * <p>The base implementation of this methods writes nothing, i.e. it assumes that the outer serializer  * only has nested serializers and no extra information. Otherwise, if the outer serializer contains  * some extra information that needs to be persisted as part of the serializer snapshot, this  * must be overridden. Note that this method and the corresponding methods  * {@link #readOuterSnapshot(int, DataInputView, ClassLoader)}, {@link #isOuterSnapshotCompatible(TypeSerializer)}  * needs to be implemented.  *  * @param out the {@link DataOutputView} to write the outer snapshot to.  */ ;// ------------------------------------------------------------------------------------------ // Outer snapshot methods. need to be overridden if outer snapshot is not empty, // or in other words, the outer serializer has extra configuration beyond its nested serializers. // ------------------------------------------------------------------------------------------ /**  * Writes the outer snapshot, i.e. any information beyond the nested serializers of the outer serializer.  *  * <p>The base implementation of this methods writes nothing, i.e. it assumes that the outer serializer  * only has nested serializers and no extra information. Otherwise, if the outer serializer contains  * some extra information that needs to be persisted as part of the serializer snapshot, this  * must be overridden. Note that this method and the corresponding methods  * {@link #readOuterSnapshot(int, DataInputView, ClassLoader)}, {@link #isOuterSnapshotCompatible(TypeSerializer)}  * needs to be implemented.  *  * @param out the {@link DataOutputView} to write the outer snapshot to.  */ protected void writeOuterSnapshot(DataOutputView out) throws IOException { }
true;protected;3;1;/**  * Reads the outer snapshot, i.e. any information beyond the nested serializers of the outer serializer.  *  * <p>The base implementation of this methods reads nothing, i.e. it assumes that the outer serializer  * only has nested serializers and no extra information. Otherwise, if the outer serializer contains  * some extra information that has been persisted as part of the serializer snapshot, this  * must be overridden. Note that this method and the corresponding methods  * {@link #writeOuterSnapshot(DataOutputView)}, {@link #isOuterSnapshotCompatible(TypeSerializer)}  * needs to be implemented.  *  * @param readOuterSnapshotVersion the read version of the outer snapshot.  * @param in the {@link DataInputView} to read the outer snapshot from.  * @param userCodeClassLoader the user code class loader.  */ ;/**  * Reads the outer snapshot, i.e. any information beyond the nested serializers of the outer serializer.  *  * <p>The base implementation of this methods reads nothing, i.e. it assumes that the outer serializer  * only has nested serializers and no extra information. Otherwise, if the outer serializer contains  * some extra information that has been persisted as part of the serializer snapshot, this  * must be overridden. Note that this method and the corresponding methods  * {@link #writeOuterSnapshot(DataOutputView)}, {@link #isOuterSnapshotCompatible(TypeSerializer)}  * needs to be implemented.  *  * @param readOuterSnapshotVersion the read version of the outer snapshot.  * @param in the {@link DataInputView} to read the outer snapshot from.  * @param userCodeClassLoader the user code class loader.  */ protected void readOuterSnapshot(int readOuterSnapshotVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException { }
true;protected;1;3;/**  * Checks whether the outer snapshot is compatible with a given new serializer.  *  * <p>The base implementation of this method just returns {@code true}, i.e. it assumes that the outer serializer  * only has nested serializers and no extra information, and therefore the result of the check must always  * be true. Otherwise, if the outer serializer contains  * some extra information that has been persisted as part of the serializer snapshot, this  * must be overridden. Note that this method and the corresponding methods  * {@link #writeOuterSnapshot(DataOutputView)}, {@link #readOuterSnapshot(int, DataInputView, ClassLoader)}  * needs to be implemented.  *  * @param newSerializer the new serializer, which contains the new outer information to check against.  *  * @return a flag indicating whether or not the new serializer's outer information is compatible with the one  *         written in this snapshot.  */ ;/**  * Checks whether the outer snapshot is compatible with a given new serializer.  *  * <p>The base implementation of this method just returns {@code true}, i.e. it assumes that the outer serializer  * only has nested serializers and no extra information, and therefore the result of the check must always  * be true. Otherwise, if the outer serializer contains  * some extra information that has been persisted as part of the serializer snapshot, this  * must be overridden. Note that this method and the corresponding methods  * {@link #writeOuterSnapshot(DataOutputView)}, {@link #readOuterSnapshot(int, DataInputView, ClassLoader)}  * needs to be implemented.  *  * @param newSerializer the new serializer, which contains the new outer information to check against.  *  * @return a flag indicating whether or not the new serializer's outer information is compatible with the one  *         written in this snapshot.  */ protected boolean isOuterSnapshotCompatible(S newSerializer) {     return true. }
false;private;1;6;;// ------------------------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------------------------ private void internalWriteOuterSnapshot(DataOutputView out) throws IOException {     out.writeInt(MAGIC_NUMBER).     out.writeInt(getCurrentOuterSnapshotVersion()).     writeOuterSnapshot(out). }
false;private;2;10;;private void internalReadOuterSnapshot(DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     final int magicNumber = in.readInt().     if (magicNumber != MAGIC_NUMBER) {         throw new IOException(String.format("Corrupt data, magic number mismatch. Expected %8x, found %8x", MAGIC_NUMBER, magicNumber)).     }     final int outerSnapshotVersion = in.readInt().     readOuterSnapshot(outerSnapshotVersion, in, userCodeClassLoader). }
false;private;3;6;;private void legacyInternalReadOuterSnapshot(int legacyReadVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     // legacy versions did not contain the pre-fixed magic numbers. just read the outer snapshot     readOuterSnapshot(legacyReadVersion, in, userCodeClassLoader). }
false;private;2;15;;private TypeSerializerSchemaCompatibility<T> constructFinalSchemaCompatibilityResult(TypeSerializer<?>[] newNestedSerializers, TypeSerializerSnapshot<?>[] nestedSerializerSnapshots) {     IntermediateCompatibilityResult<T> intermediateResult = CompositeTypeSerializerUtil.constructIntermediateCompatibilityResult(newNestedSerializers, nestedSerializerSnapshots).     if (intermediateResult.isCompatibleWithReconfiguredSerializer()) {         @SuppressWarnings("unchecked")         TypeSerializer<T> reconfiguredCompositeSerializer = createOuterSerializerWithNestedSerializers(intermediateResult.getNestedSerializers()).         return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(reconfiguredCompositeSerializer).     }     return intermediateResult.getFinalResult(). }
