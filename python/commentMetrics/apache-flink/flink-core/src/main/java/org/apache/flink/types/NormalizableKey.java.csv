commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Gets the maximal length of normalized keys that the data type would produce to determine  * the order of instances solely by the normalized key. A value of {@link java.lang.Integer}.MAX_VALUE  * is interpreted as infinite.  * <p>  * For example, 32 bit integers return four, while Strings (potentially unlimited in length) return  * {@link java.lang.Integer}.MAX_VALUE.  *  * @return The maximal length of normalized keys.  */ ;/**  * Gets the maximal length of normalized keys that the data type would produce to determine  * the order of instances solely by the normalized key. A value of {@link java.lang.Integer}.MAX_VALUE  * is interpreted as infinite.  * <p>  * For example, 32 bit integers return four, while Strings (potentially unlimited in length) return  * {@link java.lang.Integer}.MAX_VALUE.  *  * @return The maximal length of normalized keys.  */ int getMaxNormalizedKeyLen().
true;;3;1;/**  * Writes a normalized key for the given record into the target byte array, starting at the specified position  * an writing exactly the given number of bytes. Note that the comparison of the bytes is treating the bytes  * as unsigned bytes: {@code int byteI = bytes[i] & 0xFF.}  * <p>  * If the meaningful part of the normalized key takes less than the given number of bytes, then it must be padded.  * Padding is typically required for variable length data types, such as strings. The padding uses a special  * character, either {@code 0} or {@code 0xff}, depending on whether shorter values are sorted to the beginning or  * the end.  *  * @param memory The memory segment to put the normalized key bytes into.  * @param offset The offset in the byte array where the normalized key's bytes should start.  * @param len The number of bytes to put.  */ ;/**  * Writes a normalized key for the given record into the target byte array, starting at the specified position  * an writing exactly the given number of bytes. Note that the comparison of the bytes is treating the bytes  * as unsigned bytes: {@code int byteI = bytes[i] & 0xFF.}  * <p>  * If the meaningful part of the normalized key takes less than the given number of bytes, then it must be padded.  * Padding is typically required for variable length data types, such as strings. The padding uses a special  * character, either {@code 0} or {@code 0xff}, depending on whether shorter values are sorted to the beginning or  * the end.  *  * @param memory The memory segment to put the normalized key bytes into.  * @param offset The offset in the byte array where the normalized key's bytes should start.  * @param len The number of bytes to put.  */ void copyNormalizedKey(MemorySegment memory, int offset, int len).
