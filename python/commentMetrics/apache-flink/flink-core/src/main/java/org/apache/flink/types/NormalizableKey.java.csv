# id;timestamp;commentText;codeText;commentWords;codeWords
NormalizableKey -> int getMaxNormalizedKeyLen()_;1405024514;Gets the maximal length of normalized keys that the data type would produce to determine_the order of instances solely by the normalized key. A value of {@link java.lang.Integer}.MAX_VALUE_is interpreted as infinite._<p>_For example, 32 bit integers return four, while Strings (potentially unlimited in length) return_{@link java.lang.Integer}.MAX_VALUE.__@return The maximal length of normalized keys.;int getMaxNormalizedKeyLen()_;gets,the,maximal,length,of,normalized,keys,that,the,data,type,would,produce,to,determine,the,order,of,instances,solely,by,the,normalized,key,a,value,of,link,java,lang,integer,is,interpreted,as,infinite,p,for,example,32,bit,integers,return,four,while,strings,potentially,unlimited,in,length,return,link,java,lang,integer,return,the,maximal,length,of,normalized,keys;int,get,max,normalized,key,len
NormalizableKey -> int getMaxNormalizedKeyLen()_;1405090423;Gets the maximal length of normalized keys that the data type would produce to determine_the order of instances solely by the normalized key. A value of {@link java.lang.Integer}.MAX_VALUE_is interpreted as infinite._<p>_For example, 32 bit integers return four, while Strings (potentially unlimited in length) return_{@link java.lang.Integer}.MAX_VALUE.__@return The maximal length of normalized keys.;int getMaxNormalizedKeyLen()_;gets,the,maximal,length,of,normalized,keys,that,the,data,type,would,produce,to,determine,the,order,of,instances,solely,by,the,normalized,key,a,value,of,link,java,lang,integer,is,interpreted,as,infinite,p,for,example,32,bit,integers,return,four,while,strings,potentially,unlimited,in,length,return,link,java,lang,integer,return,the,maximal,length,of,normalized,keys;int,get,max,normalized,key,len
NormalizableKey -> int getMaxNormalizedKeyLen()_;1411473593;Gets the maximal length of normalized keys that the data type would produce to determine_the order of instances solely by the normalized key. A value of {@link java.lang.Integer}.MAX_VALUE_is interpreted as infinite._<p>_For example, 32 bit integers return four, while Strings (potentially unlimited in length) return_{@link java.lang.Integer}.MAX_VALUE.__@return The maximal length of normalized keys.;int getMaxNormalizedKeyLen()_;gets,the,maximal,length,of,normalized,keys,that,the,data,type,would,produce,to,determine,the,order,of,instances,solely,by,the,normalized,key,a,value,of,link,java,lang,integer,is,interpreted,as,infinite,p,for,example,32,bit,integers,return,four,while,strings,potentially,unlimited,in,length,return,link,java,lang,integer,return,the,maximal,length,of,normalized,keys;int,get,max,normalized,key,len
NormalizableKey -> int getMaxNormalizedKeyLen()_;1452178883;Gets the maximal length of normalized keys that the data type would produce to determine_the order of instances solely by the normalized key. A value of {@link java.lang.Integer}.MAX_VALUE_is interpreted as infinite._<p>_For example, 32 bit integers return four, while Strings (potentially unlimited in length) return_{@link java.lang.Integer}.MAX_VALUE.__@return The maximal length of normalized keys.;int getMaxNormalizedKeyLen()_;gets,the,maximal,length,of,normalized,keys,that,the,data,type,would,produce,to,determine,the,order,of,instances,solely,by,the,normalized,key,a,value,of,link,java,lang,integer,is,interpreted,as,infinite,p,for,example,32,bit,integers,return,four,while,strings,potentially,unlimited,in,length,return,link,java,lang,integer,return,the,maximal,length,of,normalized,keys;int,get,max,normalized,key,len
NormalizableKey -> int getMaxNormalizedKeyLen()_;1457441341;Gets the maximal length of normalized keys that the data type would produce to determine_the order of instances solely by the normalized key. A value of {@link java.lang.Integer}.MAX_VALUE_is interpreted as infinite._<p>_For example, 32 bit integers return four, while Strings (potentially unlimited in length) return_{@link java.lang.Integer}.MAX_VALUE.__@return The maximal length of normalized keys.;int getMaxNormalizedKeyLen()_;gets,the,maximal,length,of,normalized,keys,that,the,data,type,would,produce,to,determine,the,order,of,instances,solely,by,the,normalized,key,a,value,of,link,java,lang,integer,is,interpreted,as,infinite,p,for,example,32,bit,integers,return,four,while,strings,potentially,unlimited,in,length,return,link,java,lang,integer,return,the,maximal,length,of,normalized,keys;int,get,max,normalized,key,len
NormalizableKey -> int getMaxNormalizedKeyLen()_;1464364603;Gets the maximal length of normalized keys that the data type would produce to determine_the order of instances solely by the normalized key. A value of {@link java.lang.Integer}.MAX_VALUE_is interpreted as infinite._<p>_For example, 32 bit integers return four, while Strings (potentially unlimited in length) return_{@link java.lang.Integer}.MAX_VALUE.__@return The maximal length of normalized keys.;int getMaxNormalizedKeyLen()_;gets,the,maximal,length,of,normalized,keys,that,the,data,type,would,produce,to,determine,the,order,of,instances,solely,by,the,normalized,key,a,value,of,link,java,lang,integer,is,interpreted,as,infinite,p,for,example,32,bit,integers,return,four,while,strings,potentially,unlimited,in,length,return,link,java,lang,integer,return,the,maximal,length,of,normalized,keys;int,get,max,normalized,key,len
NormalizableKey -> int getMaxNormalizedKeyLen()_;1551194270;Gets the maximal length of normalized keys that the data type would produce to determine_the order of instances solely by the normalized key. A value of {@link java.lang.Integer}.MAX_VALUE_is interpreted as infinite._<p>_For example, 32 bit integers return four, while Strings (potentially unlimited in length) return_{@link java.lang.Integer}.MAX_VALUE.__@return The maximal length of normalized keys.;int getMaxNormalizedKeyLen()_;gets,the,maximal,length,of,normalized,keys,that,the,data,type,would,produce,to,determine,the,order,of,instances,solely,by,the,normalized,key,a,value,of,link,java,lang,integer,is,interpreted,as,infinite,p,for,example,32,bit,integers,return,four,while,strings,potentially,unlimited,in,length,return,link,java,lang,integer,return,the,maximal,length,of,normalized,keys;int,get,max,normalized,key,len
NormalizableKey -> void copyNormalizedKey(MemorySegment memory, int offset, int len)_;1405024514;Writes a normalized key for the given record into the target byte array, starting at the specified position_an writing exactly the given number of bytes. Note that the comparison of the bytes is treating the bytes_as unsigned bytes: {@code int byteI = bytes[i] & 0xFF_}_<p>_If the meaningful part of the normalized key takes less than the given number of bytes, than it must be padded._Padding is typically required for variable length data types, such as strings. The padding uses a special_character, either {@code 0} or {@code 0xff}, depending on whether shorter values are sorted to the beginning or_the end.__@param memory The memory segment to put the normalized key bytes into._@param offset The offset in the byte array where the normalized key's bytes should start._@param len The number of bytes to put.;void copyNormalizedKey(MemorySegment memory, int offset, int len)_;writes,a,normalized,key,for,the,given,record,into,the,target,byte,array,starting,at,the,specified,position,an,writing,exactly,the,given,number,of,bytes,note,that,the,comparison,of,the,bytes,is,treating,the,bytes,as,unsigned,bytes,code,int,byte,i,bytes,i,0x,ff,p,if,the,meaningful,part,of,the,normalized,key,takes,less,than,the,given,number,of,bytes,than,it,must,be,padded,padding,is,typically,required,for,variable,length,data,types,such,as,strings,the,padding,uses,a,special,character,either,code,0,or,code,0xff,depending,on,whether,shorter,values,are,sorted,to,the,beginning,or,the,end,param,memory,the,memory,segment,to,put,the,normalized,key,bytes,into,param,offset,the,offset,in,the,byte,array,where,the,normalized,key,s,bytes,should,start,param,len,the,number,of,bytes,to,put;void,copy,normalized,key,memory,segment,memory,int,offset,int,len
NormalizableKey -> void copyNormalizedKey(MemorySegment memory, int offset, int len)_;1405090423;Writes a normalized key for the given record into the target byte array, starting at the specified position_an writing exactly the given number of bytes. Note that the comparison of the bytes is treating the bytes_as unsigned bytes: {@code int byteI = bytes[i] & 0xFF_}_<p>_If the meaningful part of the normalized key takes less than the given number of bytes, than it must be padded._Padding is typically required for variable length data types, such as strings. The padding uses a special_character, either {@code 0} or {@code 0xff}, depending on whether shorter values are sorted to the beginning or_the end.__@param memory The memory segment to put the normalized key bytes into._@param offset The offset in the byte array where the normalized key's bytes should start._@param len The number of bytes to put.;void copyNormalizedKey(MemorySegment memory, int offset, int len)_;writes,a,normalized,key,for,the,given,record,into,the,target,byte,array,starting,at,the,specified,position,an,writing,exactly,the,given,number,of,bytes,note,that,the,comparison,of,the,bytes,is,treating,the,bytes,as,unsigned,bytes,code,int,byte,i,bytes,i,0x,ff,p,if,the,meaningful,part,of,the,normalized,key,takes,less,than,the,given,number,of,bytes,than,it,must,be,padded,padding,is,typically,required,for,variable,length,data,types,such,as,strings,the,padding,uses,a,special,character,either,code,0,or,code,0xff,depending,on,whether,shorter,values,are,sorted,to,the,beginning,or,the,end,param,memory,the,memory,segment,to,put,the,normalized,key,bytes,into,param,offset,the,offset,in,the,byte,array,where,the,normalized,key,s,bytes,should,start,param,len,the,number,of,bytes,to,put;void,copy,normalized,key,memory,segment,memory,int,offset,int,len
NormalizableKey -> void copyNormalizedKey(MemorySegment memory, int offset, int len)_;1411473593;Writes a normalized key for the given record into the target byte array, starting at the specified position_an writing exactly the given number of bytes. Note that the comparison of the bytes is treating the bytes_as unsigned bytes: {@code int byteI = bytes[i] & 0xFF_}_<p>_If the meaningful part of the normalized key takes less than the given number of bytes, than it must be padded._Padding is typically required for variable length data types, such as strings. The padding uses a special_character, either {@code 0} or {@code 0xff}, depending on whether shorter values are sorted to the beginning or_the end.__@param memory The memory segment to put the normalized key bytes into._@param offset The offset in the byte array where the normalized key's bytes should start._@param len The number of bytes to put.;void copyNormalizedKey(MemorySegment memory, int offset, int len)_;writes,a,normalized,key,for,the,given,record,into,the,target,byte,array,starting,at,the,specified,position,an,writing,exactly,the,given,number,of,bytes,note,that,the,comparison,of,the,bytes,is,treating,the,bytes,as,unsigned,bytes,code,int,byte,i,bytes,i,0x,ff,p,if,the,meaningful,part,of,the,normalized,key,takes,less,than,the,given,number,of,bytes,than,it,must,be,padded,padding,is,typically,required,for,variable,length,data,types,such,as,strings,the,padding,uses,a,special,character,either,code,0,or,code,0xff,depending,on,whether,shorter,values,are,sorted,to,the,beginning,or,the,end,param,memory,the,memory,segment,to,put,the,normalized,key,bytes,into,param,offset,the,offset,in,the,byte,array,where,the,normalized,key,s,bytes,should,start,param,len,the,number,of,bytes,to,put;void,copy,normalized,key,memory,segment,memory,int,offset,int,len
NormalizableKey -> void copyNormalizedKey(MemorySegment memory, int offset, int len)_;1452178883;Writes a normalized key for the given record into the target byte array, starting at the specified position_an writing exactly the given number of bytes. Note that the comparison of the bytes is treating the bytes_as unsigned bytes: {@code int byteI = bytes[i] & 0xFF_}_<p>_If the meaningful part of the normalized key takes less than the given number of bytes, than it must be padded._Padding is typically required for variable length data types, such as strings. The padding uses a special_character, either {@code 0} or {@code 0xff}, depending on whether shorter values are sorted to the beginning or_the end.__@param memory The memory segment to put the normalized key bytes into._@param offset The offset in the byte array where the normalized key's bytes should start._@param len The number of bytes to put.;void copyNormalizedKey(MemorySegment memory, int offset, int len)_;writes,a,normalized,key,for,the,given,record,into,the,target,byte,array,starting,at,the,specified,position,an,writing,exactly,the,given,number,of,bytes,note,that,the,comparison,of,the,bytes,is,treating,the,bytes,as,unsigned,bytes,code,int,byte,i,bytes,i,0x,ff,p,if,the,meaningful,part,of,the,normalized,key,takes,less,than,the,given,number,of,bytes,than,it,must,be,padded,padding,is,typically,required,for,variable,length,data,types,such,as,strings,the,padding,uses,a,special,character,either,code,0,or,code,0xff,depending,on,whether,shorter,values,are,sorted,to,the,beginning,or,the,end,param,memory,the,memory,segment,to,put,the,normalized,key,bytes,into,param,offset,the,offset,in,the,byte,array,where,the,normalized,key,s,bytes,should,start,param,len,the,number,of,bytes,to,put;void,copy,normalized,key,memory,segment,memory,int,offset,int,len
NormalizableKey -> void copyNormalizedKey(MemorySegment memory, int offset, int len)_;1457441341;Writes a normalized key for the given record into the target byte array, starting at the specified position_an writing exactly the given number of bytes. Note that the comparison of the bytes is treating the bytes_as unsigned bytes: {@code int byteI = bytes[i] & 0xFF_}_<p>_If the meaningful part of the normalized key takes less than the given number of bytes, than it must be padded._Padding is typically required for variable length data types, such as strings. The padding uses a special_character, either {@code 0} or {@code 0xff}, depending on whether shorter values are sorted to the beginning or_the end.__@param memory The memory segment to put the normalized key bytes into._@param offset The offset in the byte array where the normalized key's bytes should start._@param len The number of bytes to put.;void copyNormalizedKey(MemorySegment memory, int offset, int len)_;writes,a,normalized,key,for,the,given,record,into,the,target,byte,array,starting,at,the,specified,position,an,writing,exactly,the,given,number,of,bytes,note,that,the,comparison,of,the,bytes,is,treating,the,bytes,as,unsigned,bytes,code,int,byte,i,bytes,i,0x,ff,p,if,the,meaningful,part,of,the,normalized,key,takes,less,than,the,given,number,of,bytes,than,it,must,be,padded,padding,is,typically,required,for,variable,length,data,types,such,as,strings,the,padding,uses,a,special,character,either,code,0,or,code,0xff,depending,on,whether,shorter,values,are,sorted,to,the,beginning,or,the,end,param,memory,the,memory,segment,to,put,the,normalized,key,bytes,into,param,offset,the,offset,in,the,byte,array,where,the,normalized,key,s,bytes,should,start,param,len,the,number,of,bytes,to,put;void,copy,normalized,key,memory,segment,memory,int,offset,int,len
NormalizableKey -> void copyNormalizedKey(MemorySegment memory, int offset, int len)_;1464364603;Writes a normalized key for the given record into the target byte array, starting at the specified position_an writing exactly the given number of bytes. Note that the comparison of the bytes is treating the bytes_as unsigned bytes: {@code int byteI = bytes[i] & 0xFF_}_<p>_If the meaningful part of the normalized key takes less than the given number of bytes, than it must be padded._Padding is typically required for variable length data types, such as strings. The padding uses a special_character, either {@code 0} or {@code 0xff}, depending on whether shorter values are sorted to the beginning or_the end.__@param memory The memory segment to put the normalized key bytes into._@param offset The offset in the byte array where the normalized key's bytes should start._@param len The number of bytes to put.;void copyNormalizedKey(MemorySegment memory, int offset, int len)_;writes,a,normalized,key,for,the,given,record,into,the,target,byte,array,starting,at,the,specified,position,an,writing,exactly,the,given,number,of,bytes,note,that,the,comparison,of,the,bytes,is,treating,the,bytes,as,unsigned,bytes,code,int,byte,i,bytes,i,0x,ff,p,if,the,meaningful,part,of,the,normalized,key,takes,less,than,the,given,number,of,bytes,than,it,must,be,padded,padding,is,typically,required,for,variable,length,data,types,such,as,strings,the,padding,uses,a,special,character,either,code,0,or,code,0xff,depending,on,whether,shorter,values,are,sorted,to,the,beginning,or,the,end,param,memory,the,memory,segment,to,put,the,normalized,key,bytes,into,param,offset,the,offset,in,the,byte,array,where,the,normalized,key,s,bytes,should,start,param,len,the,number,of,bytes,to,put;void,copy,normalized,key,memory,segment,memory,int,offset,int,len
NormalizableKey -> void copyNormalizedKey(MemorySegment memory, int offset, int len)_;1551194270;Writes a normalized key for the given record into the target byte array, starting at the specified position_an writing exactly the given number of bytes. Note that the comparison of the bytes is treating the bytes_as unsigned bytes: {@code int byteI = bytes[i] & 0xFF_}_<p>_If the meaningful part of the normalized key takes less than the given number of bytes, then it must be padded._Padding is typically required for variable length data types, such as strings. The padding uses a special_character, either {@code 0} or {@code 0xff}, depending on whether shorter values are sorted to the beginning or_the end.__@param memory The memory segment to put the normalized key bytes into._@param offset The offset in the byte array where the normalized key's bytes should start._@param len The number of bytes to put.;void copyNormalizedKey(MemorySegment memory, int offset, int len)_;writes,a,normalized,key,for,the,given,record,into,the,target,byte,array,starting,at,the,specified,position,an,writing,exactly,the,given,number,of,bytes,note,that,the,comparison,of,the,bytes,is,treating,the,bytes,as,unsigned,bytes,code,int,byte,i,bytes,i,0x,ff,p,if,the,meaningful,part,of,the,normalized,key,takes,less,than,the,given,number,of,bytes,then,it,must,be,padded,padding,is,typically,required,for,variable,length,data,types,such,as,strings,the,padding,uses,a,special,character,either,code,0,or,code,0xff,depending,on,whether,shorter,values,are,sorted,to,the,beginning,or,the,end,param,memory,the,memory,segment,to,put,the,normalized,key,bytes,into,param,offset,the,offset,in,the,byte,array,where,the,normalized,key,s,bytes,should,start,param,len,the,number,of,bytes,to,put;void,copy,normalized,key,memory,segment,memory,int,offset,int,len
