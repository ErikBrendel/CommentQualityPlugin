commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public long getCurrent() {     return this.current. }
false;public;0;3;;public long getTo() {     return this.to. }
false;public;0;4;;@Override public boolean hasNext() {     return current <= to. }
false;public;0;8;;@Override public Long next() {     if (current <= to) {         return current++.     } else {         throw new NoSuchElementException().     } }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;1;80;;@Override public NumberSequenceIterator[] split(int numPartitions) {     if (numPartitions < 1) {         throw new IllegalArgumentException("The number of partitions must be at least 1.").     }     if (numPartitions == 1) {         return new NumberSequenceIterator[] { new NumberSequenceIterator(current, to) }.     }     // here, numPartitions >= 2 !!!     long elementsPerSplit.     if (to - current + 1 >= 0) {         elementsPerSplit = (to - current + 1) / numPartitions.     } else {         // long overflow of the range.         // we compute based on half the distance, to prevent the overflow.         // in most cases it holds that: current < 0 and to > 0, except for: to == 0 and current == Long.MIN_VALUE         // the later needs a special case         // must be positive         final long halfDiff.         if (current == Long.MIN_VALUE) {             // this means to >= 0             halfDiff = (Long.MAX_VALUE / 2 + 1) + to / 2.         } else {             long posFrom = -current.             if (posFrom > to) {                 halfDiff = to + ((posFrom - to) / 2).             } else {                 halfDiff = posFrom + ((to - posFrom) / 2).             }         }         elementsPerSplit = halfDiff / numPartitions * 2.     }     if (elementsPerSplit < Long.MAX_VALUE) {         // figure out how many get one in addition         long numWithExtra = -(elementsPerSplit * numPartitions) + to - current + 1.         // based on rounding errors, we may have lost one)         if (numWithExtra > numPartitions) {             elementsPerSplit++.             numWithExtra -= numPartitions.             if (numWithExtra > numPartitions) {                 throw new RuntimeException("Bug in splitting logic. To much rounding loss.").             }         }         NumberSequenceIterator[] iters = new NumberSequenceIterator[numPartitions].         long curr = current.         int i = 0.         for (. i < numWithExtra. i++) {             long next = curr + elementsPerSplit + 1.             iters[i] = new NumberSequenceIterator(curr, next - 1).             curr = next.         }         for (. i < numPartitions. i++) {             long next = curr + elementsPerSplit.             iters[i] = new NumberSequenceIterator(curr, next - 1, true).             curr = next.         }         return iters.     } else {         // this can only be the case when there are two partitions         if (numPartitions != 2) {             throw new RuntimeException("Bug in splitting logic.").         }         return new NumberSequenceIterator[] { new NumberSequenceIterator(current, current + elementsPerSplit), new NumberSequenceIterator(current + elementsPerSplit, to) }.     } }
false;public;0;9;;@Override public int getMaximumNumberOfSplits() {     if (to >= Integer.MAX_VALUE || current <= Integer.MIN_VALUE || to - current + 1 >= Integer.MAX_VALUE) {         return Integer.MAX_VALUE.     } else {         return (int) (to - current + 1).     } }
