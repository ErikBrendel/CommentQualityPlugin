commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;2;1;/**  * Read from the provided {@link DataInputView in}. A flag {@code wasVersioned} can be  * used to determine whether or not the data to read was previously written  * by a {@link VersionedIOReadableWritable}.  */ ;/**  * Read from the provided {@link DataInputView in}. A flag {@code wasVersioned} can be  * used to determine whether or not the data to read was previously written  * by a {@link VersionedIOReadableWritable}.  */ protected abstract void read(DataInputView in, boolean wasVersioned) throws IOException.
false;public;1;5;;@Override public void write(DataOutputView out) throws IOException {     out.write(VERSIONED_IDENTIFIER).     super.write(out). }
true;public,final;1;16;/**  * This read attempts to first identify if the input view contains the special  * {@link #VERSIONED_IDENTIFIER} by reading and buffering the first few bytes.  * If identified to be versioned, the usual version resolution read path  * in {@link VersionedIOReadableWritable#read(DataInputView)} is invoked.  * Otherwise, we "reset" the input stream by pushing back the read buffered bytes  * into the stream.  */ ;/**  * This read attempts to first identify if the input view contains the special  * {@link #VERSIONED_IDENTIFIER} by reading and buffering the first few bytes.  * If identified to be versioned, the usual version resolution read path  * in {@link VersionedIOReadableWritable#read(DataInputView)} is invoked.  * Otherwise, we "reset" the input stream by pushing back the read buffered bytes  * into the stream.  */ public final void read(InputStream inputStream) throws IOException {     byte[] tmp = new byte[VERSIONED_IDENTIFIER.length].     inputStream.read(tmp).     if (Arrays.equals(tmp, VERSIONED_IDENTIFIER)) {         DataInputView inputView = new DataInputViewStreamWrapper(inputStream).         super.read(inputView).         read(inputView, true).     } else {         PushbackInputStream resetStream = new PushbackInputStream(inputStream, VERSIONED_IDENTIFIER.length).         resetStream.unread(tmp).         read(new DataInputViewStreamWrapper(resetStream), false).     } }
true;public,final;1;4;/**  * We do not support reading from a {@link DataInputView}, because it does not  * support pushing back already read bytes.  */ ;/**  * We do not support reading from a {@link DataInputView}, because it does not  * support pushing back already read bytes.  */ @Override public final void read(DataInputView in) throws IOException {     throw new UnsupportedOperationException("PostVersionedIOReadableWritable cannot read from a DataInputView."). }
