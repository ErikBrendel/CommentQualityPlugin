# id;timestamp;commentText;codeText;commentWords;codeWords
MemorySegment -> public final void putShort(int index, short value);1405024514;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		this.memory[index    ] = (byte) (value >> 8)__		this.memory[index + 1] = (byte) value__	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,this,memory,index,byte,value,8,this,memory,index,1,byte,value
MemorySegment -> public final void putShort(int index, short value);1405090423;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		this.memory[index    ] = (byte) (value >> 8)__		this.memory[index + 1] = (byte) value__	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,this,memory,index,byte,value,8,this,memory,index,1,byte,value
MemorySegment -> public final void putShort(int index, short value);1411473593;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		this.memory[index    ] = (byte) (value >> 8)__		this.memory[index + 1] = (byte) value__	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,this,memory,index,byte,value,8,this,memory,index,1,byte,value
MemorySegment -> public final void putShort(int index, short value);1418658367;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		this.memory[index    ] = (byte) (value >> 8)__		this.memory[index + 1] = (byte) value__	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,this,memory,index,byte,value,8,this,memory,index,1,byte,value
MemorySegment -> public final void putShort(int index, short value);1421050512;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		this.memory[index    ] = (byte) (value >> 8)__		this.memory[index + 1] = (byte) value__	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,this,memory,index,byte,value,8,this,memory,index,1,byte,value
MemorySegment -> public final void putShort(int index, short value);1441738685;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putShort(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,short,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putShort(int index, short value);1446112342;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putShort(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,short,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putShort(int index, short value);1455479358;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putShort(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,short,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putShort(int index, short value);1474380620;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putShort(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,short,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putShort(int index, short value);1507315082;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putShort(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,short,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putShort(int index, short value);1509981552;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putShort(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,short,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putShort(int index, short value);1513874825;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putShort(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,short,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putShort(int index, short value);1516285456;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putShort(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,short,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putShort(int index, short value);1550507508;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putShort(int index, short value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putShort(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,short,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putShort(int index, short value);1550567875;Writes the given short value into this buffer at the given position, using_the native byte order of the system.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 2.;public final void putShort(int index, short value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putShort(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,short,value,into,this,buffer,at,the,given,position,using,the,native,byte,order,of,the,system,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;public,final,void,put,short,int,index,short,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,short,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public MemorySegment(byte[] memory);1405024514;Creates a new memory segment that represents the data in the given byte array.__@param memory The byte array that holds the data.;public MemorySegment(byte[] memory) {_		this.memory = memory__	};creates,a,new,memory,segment,that,represents,the,data,in,the,given,byte,array,param,memory,the,byte,array,that,holds,the,data;public,memory,segment,byte,memory,this,memory,memory
MemorySegment -> public MemorySegment(byte[] memory);1405090423;Creates a new memory segment that represents the data in the given byte array.__@param memory The byte array that holds the data.;public MemorySegment(byte[] memory) {_		this.memory = memory__	};creates,a,new,memory,segment,that,represents,the,data,in,the,given,byte,array,param,memory,the,byte,array,that,holds,the,data;public,memory,segment,byte,memory,this,memory,memory
MemorySegment -> public MemorySegment(byte[] memory);1411473593;Creates a new memory segment that represents the data in the given byte array.__@param memory The byte array that holds the data.;public MemorySegment(byte[] memory) {_		this.memory = memory__	};creates,a,new,memory,segment,that,represents,the,data,in,the,given,byte,array,param,memory,the,byte,array,that,holds,the,data;public,memory,segment,byte,memory,this,memory,memory
MemorySegment -> public MemorySegment(byte[] memory);1418658367;Creates a new memory segment that represents the data in the given byte array.__@param memory The byte array that holds the data.;public MemorySegment(byte[] memory) {_		this.memory = memory__	};creates,a,new,memory,segment,that,represents,the,data,in,the,given,byte,array,param,memory,the,byte,array,that,holds,the,data;public,memory,segment,byte,memory,this,memory,memory
MemorySegment -> public MemorySegment(byte[] memory);1421050512;Creates a new memory segment that represents the data in the given byte array.__@param memory The byte array that holds the data.;public MemorySegment(byte[] memory) {_		this.memory = memory__	};creates,a,new,memory,segment,that,represents,the,data,in,the,given,byte,array,param,memory,the,byte,array,that,holds,the,data;public,memory,segment,byte,memory,this,memory,memory
MemorySegment -> public final void putBoolean(int index, boolean value);1405024514;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public final void putBoolean(int index, boolean value) {_		this.memory[index] = (byte) (value ? 1 : 0)__	};writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,final,void,put,boolean,int,index,boolean,value,this,memory,index,byte,value,1,0
MemorySegment -> public final void putBoolean(int index, boolean value);1405090423;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public final void putBoolean(int index, boolean value) {_		this.memory[index] = (byte) (value ? 1 : 0)__	};writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,final,void,put,boolean,int,index,boolean,value,this,memory,index,byte,value,1,0
MemorySegment -> public final void putBoolean(int index, boolean value);1411473593;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public final void putBoolean(int index, boolean value) {_		this.memory[index] = (byte) (value ? 1 : 0)__	};writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,final,void,put,boolean,int,index,boolean,value,this,memory,index,byte,value,1,0
MemorySegment -> public final void putBoolean(int index, boolean value);1418658367;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public final void putBoolean(int index, boolean value) {_		this.memory[index] = (byte) (value ? 1 : 0)__	};writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,final,void,put,boolean,int,index,boolean,value,this,memory,index,byte,value,1,0
MemorySegment -> public final void putBoolean(int index, boolean value);1421050512;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public final void putBoolean(int index, boolean value) {_		this.memory[index] = (byte) (value ? 1 : 0)__	};writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,final,void,put,boolean,int,index,boolean,value,this,memory,index,byte,value,1,0
MemorySegment -> public final void put(int index, byte[] src, int offset, int length);1405024514;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public final void put(int index, byte[] src, int offset, int length) {_		_		System.arraycopy(src, offset, this.memory, index, length)__	};bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,put,int,index,byte,src,int,offset,int,length,system,arraycopy,src,offset,this,memory,index,length
MemorySegment -> public final void put(int index, byte[] src, int offset, int length);1405090423;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public final void put(int index, byte[] src, int offset, int length) {_		_		System.arraycopy(src, offset, this.memory, index, length)__	};bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,put,int,index,byte,src,int,offset,int,length,system,arraycopy,src,offset,this,memory,index,length
MemorySegment -> public final void put(int index, byte[] src, int offset, int length);1411473593;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public final void put(int index, byte[] src, int offset, int length) {_		_		System.arraycopy(src, offset, this.memory, index, length)__	};bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,put,int,index,byte,src,int,offset,int,length,system,arraycopy,src,offset,this,memory,index,length
MemorySegment -> public final void put(int index, byte[] src, int offset, int length);1418658367;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public final void put(int index, byte[] src, int offset, int length) {_		_		System.arraycopy(src, offset, this.memory, index, length)__	};bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,put,int,index,byte,src,int,offset,int,length,system,arraycopy,src,offset,this,memory,index,length
MemorySegment -> public final void put(int index, byte[] src, int offset, int length);1421050512;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public final void put(int index, byte[] src, int offset, int length) {_		_		System.arraycopy(src, offset, this.memory, index, length)__	};bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,put,int,index,byte,src,int,offset,int,length,system,arraycopy,src,offset,this,memory,index,length
MemorySegment -> public final double getDoubleBigEndian(int index);1405024514;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1405090423;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1411473593;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1418658367;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1421050512;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1441738685;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1446112342;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1455479358;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1474380620;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1507315082;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1509981552;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1513874825;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1516285456;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1550507508;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> public final double getDoubleBigEndian(int index);1550567875;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final double getDoubleBigEndian(int index) {_		return Double.longBitsToDouble(getLongBigEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,double,get,double,big,endian,int,index,return,double,long,bits,to,double,get,long,big,endian,index
MemorySegment -> MemorySegment(byte[] buffer, Object owner);1441738685;Creates a new memory segment that represents the memory of the byte array._Since the byte array is backed by on-heap memory, this memory segment holds its_data on heap. The buffer must be at least of size 8 bytes.__@param buffer The byte array whose memory is represented by this memory segment.;MemorySegment(byte[] buffer, Object owner) {_		if (buffer == null) {_			throw new NullPointerException("buffer")__		}_		_		this.heapMemory = buffer__		this.address = BYTE_ARRAY_BASE_OFFSET__		this.size = buffer.length__		this.addressLimit = this.address + this.size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,of,the,byte,array,since,the,byte,array,is,backed,by,on,heap,memory,this,memory,segment,holds,its,data,on,heap,the,buffer,must,be,at,least,of,size,8,bytes,param,buffer,the,byte,array,whose,memory,is,represented,by,this,memory,segment;memory,segment,byte,buffer,object,owner,if,buffer,null,throw,new,null,pointer,exception,buffer,this,heap,memory,buffer,this,address,this,size,buffer,length,this,address,limit,this,address,this,size,this,owner,owner
MemorySegment -> MemorySegment(byte[] buffer, Object owner);1446112342;Creates a new memory segment that represents the memory of the byte array._Since the byte array is backed by on-heap memory, this memory segment holds its_data on heap. The buffer must be at least of size 8 bytes.__@param buffer The byte array whose memory is represented by this memory segment.;MemorySegment(byte[] buffer, Object owner) {_		if (buffer == null) {_			throw new NullPointerException("buffer")__		}_		_		this.heapMemory = buffer__		this.address = BYTE_ARRAY_BASE_OFFSET__		this.size = buffer.length__		this.addressLimit = this.address + this.size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,of,the,byte,array,since,the,byte,array,is,backed,by,on,heap,memory,this,memory,segment,holds,its,data,on,heap,the,buffer,must,be,at,least,of,size,8,bytes,param,buffer,the,byte,array,whose,memory,is,represented,by,this,memory,segment;memory,segment,byte,buffer,object,owner,if,buffer,null,throw,new,null,pointer,exception,buffer,this,heap,memory,buffer,this,address,this,size,buffer,length,this,address,limit,this,address,this,size,this,owner,owner
MemorySegment -> MemorySegment(byte[] buffer, Object owner);1455479358;Creates a new memory segment that represents the memory of the byte array._Since the byte array is backed by on-heap memory, this memory segment holds its_data on heap. The buffer must be at least of size 8 bytes.__@param buffer The byte array whose memory is represented by this memory segment.;MemorySegment(byte[] buffer, Object owner) {_		if (buffer == null) {_			throw new NullPointerException("buffer")__		}_		_		this.heapMemory = buffer__		this.address = BYTE_ARRAY_BASE_OFFSET__		this.size = buffer.length__		this.addressLimit = this.address + this.size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,of,the,byte,array,since,the,byte,array,is,backed,by,on,heap,memory,this,memory,segment,holds,its,data,on,heap,the,buffer,must,be,at,least,of,size,8,bytes,param,buffer,the,byte,array,whose,memory,is,represented,by,this,memory,segment;memory,segment,byte,buffer,object,owner,if,buffer,null,throw,new,null,pointer,exception,buffer,this,heap,memory,buffer,this,address,this,size,buffer,length,this,address,limit,this,address,this,size,this,owner,owner
MemorySegment -> MemorySegment(byte[] buffer, Object owner);1474380620;Creates a new memory segment that represents the memory of the byte array._Since the byte array is backed by on-heap memory, this memory segment holds its_data on heap. The buffer must be at least of size 8 bytes.__@param buffer The byte array whose memory is represented by this memory segment.;MemorySegment(byte[] buffer, Object owner) {_		if (buffer == null) {_			throw new NullPointerException("buffer")__		}_		_		this.heapMemory = buffer__		this.address = BYTE_ARRAY_BASE_OFFSET__		this.size = buffer.length__		this.addressLimit = this.address + this.size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,of,the,byte,array,since,the,byte,array,is,backed,by,on,heap,memory,this,memory,segment,holds,its,data,on,heap,the,buffer,must,be,at,least,of,size,8,bytes,param,buffer,the,byte,array,whose,memory,is,represented,by,this,memory,segment;memory,segment,byte,buffer,object,owner,if,buffer,null,throw,new,null,pointer,exception,buffer,this,heap,memory,buffer,this,address,this,size,buffer,length,this,address,limit,this,address,this,size,this,owner,owner
MemorySegment -> MemorySegment(byte[] buffer, Object owner);1507315082;Creates a new memory segment that represents the memory of the byte array.__<p>Since the byte array is backed by on-heap memory, this memory segment holds its_data on heap. The buffer must be at least of size 8 bytes.__@param buffer The byte array whose memory is represented by this memory segment.;MemorySegment(byte[] buffer, Object owner) {_		if (buffer == null) {_			throw new NullPointerException("buffer")__		}__		this.heapMemory = buffer__		this.address = BYTE_ARRAY_BASE_OFFSET__		this.size = buffer.length__		this.addressLimit = this.address + this.size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,of,the,byte,array,p,since,the,byte,array,is,backed,by,on,heap,memory,this,memory,segment,holds,its,data,on,heap,the,buffer,must,be,at,least,of,size,8,bytes,param,buffer,the,byte,array,whose,memory,is,represented,by,this,memory,segment;memory,segment,byte,buffer,object,owner,if,buffer,null,throw,new,null,pointer,exception,buffer,this,heap,memory,buffer,this,address,this,size,buffer,length,this,address,limit,this,address,this,size,this,owner,owner
MemorySegment -> MemorySegment(byte[] buffer, Object owner);1509981552;Creates a new memory segment that represents the memory of the byte array.__<p>Since the byte array is backed by on-heap memory, this memory segment holds its_data on heap. The buffer must be at least of size 8 bytes.__@param buffer The byte array whose memory is represented by this memory segment.;MemorySegment(byte[] buffer, Object owner) {_		if (buffer == null) {_			throw new NullPointerException("buffer")__		}__		this.heapMemory = buffer__		this.address = BYTE_ARRAY_BASE_OFFSET__		this.size = buffer.length__		this.addressLimit = this.address + this.size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,of,the,byte,array,p,since,the,byte,array,is,backed,by,on,heap,memory,this,memory,segment,holds,its,data,on,heap,the,buffer,must,be,at,least,of,size,8,bytes,param,buffer,the,byte,array,whose,memory,is,represented,by,this,memory,segment;memory,segment,byte,buffer,object,owner,if,buffer,null,throw,new,null,pointer,exception,buffer,this,heap,memory,buffer,this,address,this,size,buffer,length,this,address,limit,this,address,this,size,this,owner,owner
MemorySegment -> MemorySegment(byte[] buffer, Object owner);1513874825;Creates a new memory segment that represents the memory of the byte array.__<p>Since the byte array is backed by on-heap memory, this memory segment holds its_data on heap. The buffer must be at least of size 8 bytes.__@param buffer The byte array whose memory is represented by this memory segment.;MemorySegment(byte[] buffer, Object owner) {_		if (buffer == null) {_			throw new NullPointerException("buffer")__		}__		this.heapMemory = buffer__		this.address = BYTE_ARRAY_BASE_OFFSET__		this.size = buffer.length__		this.addressLimit = this.address + this.size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,of,the,byte,array,p,since,the,byte,array,is,backed,by,on,heap,memory,this,memory,segment,holds,its,data,on,heap,the,buffer,must,be,at,least,of,size,8,bytes,param,buffer,the,byte,array,whose,memory,is,represented,by,this,memory,segment;memory,segment,byte,buffer,object,owner,if,buffer,null,throw,new,null,pointer,exception,buffer,this,heap,memory,buffer,this,address,this,size,buffer,length,this,address,limit,this,address,this,size,this,owner,owner
MemorySegment -> MemorySegment(byte[] buffer, Object owner);1516285456;Creates a new memory segment that represents the memory of the byte array.__<p>Since the byte array is backed by on-heap memory, this memory segment holds its_data on heap. The buffer must be at least of size 8 bytes.__@param buffer The byte array whose memory is represented by this memory segment.;MemorySegment(byte[] buffer, Object owner) {_		if (buffer == null) {_			throw new NullPointerException("buffer")__		}__		this.heapMemory = buffer__		this.address = BYTE_ARRAY_BASE_OFFSET__		this.size = buffer.length__		this.addressLimit = this.address + this.size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,of,the,byte,array,p,since,the,byte,array,is,backed,by,on,heap,memory,this,memory,segment,holds,its,data,on,heap,the,buffer,must,be,at,least,of,size,8,bytes,param,buffer,the,byte,array,whose,memory,is,represented,by,this,memory,segment;memory,segment,byte,buffer,object,owner,if,buffer,null,throw,new,null,pointer,exception,buffer,this,heap,memory,buffer,this,address,this,size,buffer,length,this,address,limit,this,address,this,size,this,owner,owner
MemorySegment -> MemorySegment(byte[] buffer, Object owner);1550507508;Creates a new memory segment that represents the memory of the byte array.__<p>Since the byte array is backed by on-heap memory, this memory segment holds its_data on heap. The buffer must be at least of size 8 bytes.__@param buffer The byte array whose memory is represented by this memory segment.;MemorySegment(byte[] buffer, Object owner) {_		if (buffer == null) {_			throw new NullPointerException("buffer")__		}__		this.heapMemory = buffer__		this.address = BYTE_ARRAY_BASE_OFFSET__		this.size = buffer.length__		this.addressLimit = this.address + this.size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,of,the,byte,array,p,since,the,byte,array,is,backed,by,on,heap,memory,this,memory,segment,holds,its,data,on,heap,the,buffer,must,be,at,least,of,size,8,bytes,param,buffer,the,byte,array,whose,memory,is,represented,by,this,memory,segment;memory,segment,byte,buffer,object,owner,if,buffer,null,throw,new,null,pointer,exception,buffer,this,heap,memory,buffer,this,address,this,size,buffer,length,this,address,limit,this,address,this,size,this,owner,owner
MemorySegment -> MemorySegment(byte[] buffer, Object owner);1550567875;Creates a new memory segment that represents the memory of the byte array.__<p>Since the byte array is backed by on-heap memory, this memory segment holds its_data on heap. The buffer must be at least of size 8 bytes.__@param buffer The byte array whose memory is represented by this memory segment.;MemorySegment(byte[] buffer, Object owner) {_		if (buffer == null) {_			throw new NullPointerException("buffer")__		}__		this.heapMemory = buffer__		this.address = BYTE_ARRAY_BASE_OFFSET__		this.size = buffer.length__		this.addressLimit = this.address + this.size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,of,the,byte,array,p,since,the,byte,array,is,backed,by,on,heap,memory,this,memory,segment,holds,its,data,on,heap,the,buffer,must,be,at,least,of,size,8,bytes,param,buffer,the,byte,array,whose,memory,is,represented,by,this,memory,segment;memory,segment,byte,buffer,object,owner,if,buffer,null,throw,new,null,pointer,exception,buffer,this,heap,memory,buffer,this,address,this,size,buffer,length,this,address,limit,this,address,this,size,this,owner,owner
MemorySegment -> public final void putCharBigEndian(int index, char value);1441738685;Writes the given character (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharBigEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, Character.reverseBytes(value))__		} else {_			putChar(index, value)__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,big,endian,int,index,char,value,if,put,char,index,character,reverse,bytes,value,else,put,char,index,value
MemorySegment -> public final void putCharBigEndian(int index, char value);1446112342;Writes the given character (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharBigEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, Character.reverseBytes(value))__		} else {_			putChar(index, value)__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,big,endian,int,index,char,value,if,put,char,index,character,reverse,bytes,value,else,put,char,index,value
MemorySegment -> public final void putCharBigEndian(int index, char value);1455479358;Writes the given character (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharBigEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, Character.reverseBytes(value))__		} else {_			putChar(index, value)__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,big,endian,int,index,char,value,if,put,char,index,character,reverse,bytes,value,else,put,char,index,value
MemorySegment -> public final void putCharBigEndian(int index, char value);1474380620;Writes the given character (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharBigEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, Character.reverseBytes(value))__		} else {_			putChar(index, value)__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,big,endian,int,index,char,value,if,put,char,index,character,reverse,bytes,value,else,put,char,index,value
MemorySegment -> public final void putCharBigEndian(int index, char value);1507315082;Writes the given character (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharBigEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, Character.reverseBytes(value))__		} else {_			putChar(index, value)__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,big,endian,int,index,char,value,if,put,char,index,character,reverse,bytes,value,else,put,char,index,value
MemorySegment -> public final void putCharBigEndian(int index, char value);1509981552;Writes the given character (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharBigEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, Character.reverseBytes(value))__		} else {_			putChar(index, value)__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,big,endian,int,index,char,value,if,put,char,index,character,reverse,bytes,value,else,put,char,index,value
MemorySegment -> public final void putCharBigEndian(int index, char value);1513874825;Writes the given character (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharBigEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, Character.reverseBytes(value))__		} else {_			putChar(index, value)__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,big,endian,int,index,char,value,if,put,char,index,character,reverse,bytes,value,else,put,char,index,value
MemorySegment -> public final void putCharBigEndian(int index, char value);1516285456;Writes the given character (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharBigEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, Character.reverseBytes(value))__		} else {_			putChar(index, value)__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,big,endian,int,index,char,value,if,put,char,index,character,reverse,bytes,value,else,put,char,index,value
MemorySegment -> public final void putCharBigEndian(int index, char value);1550507508;Writes the given character (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharBigEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, Character.reverseBytes(value))__		} else {_			putChar(index, value)__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,big,endian,int,index,char,value,if,put,char,index,character,reverse,bytes,value,else,put,char,index,value
MemorySegment -> public final void putCharBigEndian(int index, char value);1550567875;Writes the given character (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment size minus 2.;public final void putCharBigEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, Character.reverseBytes(value))__		} else {_			putChar(index, value)__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;public,final,void,put,char,big,endian,int,index,char,value,if,put,char,index,character,reverse,bytes,value,else,put,char,index,value
MemorySegment -> public final short getShortLittleEndian(int index);1441738685;Reads an short integer value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getShort(index)__		} else {_			return Short.reverseBytes(getShort(index))__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,little,endian,int,index,if,return,get,short,index,else,return,short,reverse,bytes,get,short,index
MemorySegment -> public final short getShortLittleEndian(int index);1446112342;Reads an short integer value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getShort(index)__		} else {_			return Short.reverseBytes(getShort(index))__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,little,endian,int,index,if,return,get,short,index,else,return,short,reverse,bytes,get,short,index
MemorySegment -> public final short getShortLittleEndian(int index);1455479358;Reads an short integer value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getShort(index)__		} else {_			return Short.reverseBytes(getShort(index))__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,little,endian,int,index,if,return,get,short,index,else,return,short,reverse,bytes,get,short,index
MemorySegment -> public final short getShortLittleEndian(int index);1474380620;Reads an short integer value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getShort(index)__		} else {_			return Short.reverseBytes(getShort(index))__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,little,endian,int,index,if,return,get,short,index,else,return,short,reverse,bytes,get,short,index
MemorySegment -> public final short getShortLittleEndian(int index);1507315082;Reads an short integer value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getShort(index)__		} else {_			return Short.reverseBytes(getShort(index))__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,little,endian,int,index,if,return,get,short,index,else,return,short,reverse,bytes,get,short,index
MemorySegment -> public final short getShortLittleEndian(int index);1509981552;Reads an short integer value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getShort(index)__		} else {_			return Short.reverseBytes(getShort(index))__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,little,endian,int,index,if,return,get,short,index,else,return,short,reverse,bytes,get,short,index
MemorySegment -> public final short getShortLittleEndian(int index);1513874825;Reads a short integer value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getShort(index)__		} else {_			return Short.reverseBytes(getShort(index))__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,little,endian,int,index,if,return,get,short,index,else,return,short,reverse,bytes,get,short,index
MemorySegment -> public final short getShortLittleEndian(int index);1516285456;Reads a short integer value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getShort(index)__		} else {_			return Short.reverseBytes(getShort(index))__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,little,endian,int,index,if,return,get,short,index,else,return,short,reverse,bytes,get,short,index
MemorySegment -> public final short getShortLittleEndian(int index);1550507508;Reads a short integer value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getShort(index)__		} else {_			return Short.reverseBytes(getShort(index))__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,little,endian,int,index,if,return,get,short,index,else,return,short,reverse,bytes,get,short,index
MemorySegment -> public final short getShortLittleEndian(int index);1550567875;Reads a short integer value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment size minus 2.;public final short getShortLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getShort(index)__		} else {_			return Short.reverseBytes(getShort(index))__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;public,final,short,get,short,little,endian,int,index,if,return,get,short,index,else,return,short,reverse,bytes,get,short,index
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1405024514;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1405090423;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1411473593;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1418658367;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1421050512;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1441738685;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1446112342;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1455479358;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1474380620;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1507315082;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1509981552;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1513874825;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1516285456;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1550507508;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleBigEndian(int index, double value);1550567875;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final void putDoubleBigEndian(int index, double value) {_		putLongBigEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,void,put,double,big,endian,int,index,double,value,put,long,big,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1405024514;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1405090423;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1411473593;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1418658367;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1421050512;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1441738685;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1446112342;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1455479358;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1474380620;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1507315082;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1509981552;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1513874825;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1516285456;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1550507508;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public final void putIntLittleEndian(int index, int value);1550567875;Writes the given int value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 4.;public final void putIntLittleEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, value)__		} else {_			putInt(index, Integer.reverseBytes(value))__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,4;public,final,void,put,int,little,endian,int,index,int,value,if,put,int,index,value,else,put,int,index,integer,reverse,bytes,value
MemorySegment -> public abstract void put(int index, byte b)_;1441738685;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract void put(int index, byte b)_;writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,void,put,int,index,byte,b
MemorySegment -> public abstract void put(int index, byte b)_;1446112342;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract void put(int index, byte b)_;writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,void,put,int,index,byte,b
MemorySegment -> public abstract void put(int index, byte b)_;1455479358;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract void put(int index, byte b)_;writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,void,put,int,index,byte,b
MemorySegment -> public abstract void put(int index, byte b)_;1474380620;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract void put(int index, byte b)_;writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,void,put,int,index,byte,b
MemorySegment -> public abstract void put(int index, byte b)_;1507315082;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract void put(int index, byte b)_;writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,void,put,int,index,byte,b
MemorySegment -> public abstract void put(int index, byte b)_;1509981552;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract void put(int index, byte b)_;writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,void,put,int,index,byte,b
MemorySegment -> public abstract void put(int index, byte b)_;1513874825;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract void put(int index, byte b)_;writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,void,put,int,index,byte,b
MemorySegment -> public abstract void put(int index, byte b)_;1516285456;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract void put(int index, byte b)_;writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,void,put,int,index,byte,b
MemorySegment -> public abstract void put(int index, byte b)_;1550507508;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract void put(int index, byte b)_;writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,void,put,int,index,byte,b
MemorySegment -> public abstract void put(int index, byte b)_;1550567875;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract void put(int index, byte b)_;writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,void,put,int,index,byte,b
MemorySegment -> public final float getFloat(int index);1405024514;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1405090423;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1411473593;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1418658367;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1421050512;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1441738685;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1446112342;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1455479358;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1474380620;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1507315082;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1509981552;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1513874825;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1516285456;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1550507508;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final float getFloat(int index);1550567875;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in the system's_native byte order. This method offers the best speed for float reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The float value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 4.;public final float getFloat(int index) {_		return Float.intBitsToFloat(getInt(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,float,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,4;public,final,float,get,float,int,index,return,float,int,bits,to,float,get,int,index
MemorySegment -> public final short getShort(int index);1405024514;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		return (short) (_				((this.memory[index    ] & 0xff) << 8) |_				((this.memory[index + 1] & 0xff)) )__	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,return,short,this,memory,index,0xff,8,this,memory,index,1,0xff
MemorySegment -> public final short getShort(int index);1405090423;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		return (short) (_				((this.memory[index    ] & 0xff) << 8) |_				((this.memory[index + 1] & 0xff)) )__	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,return,short,this,memory,index,0xff,8,this,memory,index,1,0xff
MemorySegment -> public final short getShort(int index);1411473593;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		return (short) (_				((this.memory[index    ] & 0xff) << 8) |_				((this.memory[index + 1] & 0xff)) )__	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,return,short,this,memory,index,0xff,8,this,memory,index,1,0xff
MemorySegment -> public final short getShort(int index);1418658367;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		return (short) (_				((this.memory[index    ] & 0xff) << 8) |_				((this.memory[index + 1] & 0xff)) )__	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,return,short,this,memory,index,0xff,8,this,memory,index,1,0xff
MemorySegment -> public final short getShort(int index);1421050512;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		return (short) (_				((this.memory[index    ] & 0xff) << 8) |_				((this.memory[index + 1] & 0xff)) )__	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,return,short,this,memory,index,0xff,8,this,memory,index,1,0xff
MemorySegment -> public final short getShort(int index);1441738685;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getShort(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,short,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final short getShort(int index);1446112342;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getShort(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,short,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final short getShort(int index);1455479358;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getShort(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,short,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final short getShort(int index);1474380620;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getShort(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,short,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final short getShort(int index);1507315082;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getShort(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,short,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final short getShort(int index);1509981552;Reads two memory at the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getShort(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,two,memory,at,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,short,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final short getShort(int index);1513874825;Reads a short integer value (16 bit, 2 bytes) from the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getShort(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,short,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final short getShort(int index);1516285456;Reads a short integer value (16 bit, 2 bytes) from the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getShort(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,short,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final short getShort(int index);1550507508;Reads a short integer value (16 bit, 2 bytes) from the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final short getShort(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getShort(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,short,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final short getShort(int index);1550567875;Reads a short integer value (16 bit, 2 bytes) from the given position, composing them into a short value_according to the current byte order.__@param index The position from which the memory will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 2.;public final short getShort(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getShort(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,composing,them,into,a,short,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;public,final,short,get,short,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,short,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final char getCharLittleEndian(int index);1441738685;Reads an character value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getChar(index)__		} else {_			return Character.reverseBytes(getChar(index))__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,little,endian,int,index,if,return,get,char,index,else,return,character,reverse,bytes,get,char,index
MemorySegment -> public final char getCharLittleEndian(int index);1446112342;Reads an character value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getChar(index)__		} else {_			return Character.reverseBytes(getChar(index))__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,little,endian,int,index,if,return,get,char,index,else,return,character,reverse,bytes,get,char,index
MemorySegment -> public final char getCharLittleEndian(int index);1455479358;Reads an character value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getChar(index)__		} else {_			return Character.reverseBytes(getChar(index))__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,little,endian,int,index,if,return,get,char,index,else,return,character,reverse,bytes,get,char,index
MemorySegment -> public final char getCharLittleEndian(int index);1474380620;Reads an character value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getChar(index)__		} else {_			return Character.reverseBytes(getChar(index))__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,little,endian,int,index,if,return,get,char,index,else,return,character,reverse,bytes,get,char,index
MemorySegment -> public final char getCharLittleEndian(int index);1507315082;Reads an character value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getChar(index)__		} else {_			return Character.reverseBytes(getChar(index))__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,little,endian,int,index,if,return,get,char,index,else,return,character,reverse,bytes,get,char,index
MemorySegment -> public final char getCharLittleEndian(int index);1509981552;Reads an character value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getChar(index)__		} else {_			return Character.reverseBytes(getChar(index))__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,little,endian,int,index,if,return,get,char,index,else,return,character,reverse,bytes,get,char,index
MemorySegment -> public final char getCharLittleEndian(int index);1513874825;Reads a character value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getChar(index)__		} else {_			return Character.reverseBytes(getChar(index))__		}_	};reads,a,character,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,little,endian,int,index,if,return,get,char,index,else,return,character,reverse,bytes,get,char,index
MemorySegment -> public final char getCharLittleEndian(int index);1516285456;Reads a character value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getChar(index)__		} else {_			return Character.reverseBytes(getChar(index))__		}_	};reads,a,character,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,little,endian,int,index,if,return,get,char,index,else,return,character,reverse,bytes,get,char,index
MemorySegment -> public final char getCharLittleEndian(int index);1550507508;Reads a character value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getChar(index)__		} else {_			return Character.reverseBytes(getChar(index))__		}_	};reads,a,character,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,little,endian,int,index,if,return,get,char,index,else,return,character,reverse,bytes,get,char,index
MemorySegment -> public final char getCharLittleEndian(int index);1550567875;Reads a character value (16 bit, 2 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment size minus 2.;public final char getCharLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getChar(index)__		} else {_			return Character.reverseBytes(getChar(index))__		}_	};reads,a,character,value,16,bit,2,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;public,final,char,get,char,little,endian,int,index,if,return,get,char,index,else,return,character,reverse,bytes,get,char,index
MemorySegment -> public final byte get(int index);1405024514;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public final byte get(int index) {_		return this.memory[index]__	};reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,final,byte,get,int,index,return,this,memory,index
MemorySegment -> public final byte get(int index);1405090423;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public final byte get(int index) {_		return this.memory[index]__	};reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,final,byte,get,int,index,return,this,memory,index
MemorySegment -> public final byte get(int index);1411473593;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public final byte get(int index) {_		return this.memory[index]__	};reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,final,byte,get,int,index,return,this,memory,index
MemorySegment -> public final byte get(int index);1418658367;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public final byte get(int index) {_		return this.memory[index]__	};reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,final,byte,get,int,index,return,this,memory,index
MemorySegment -> public final byte get(int index);1421050512;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public final byte get(int index) {_		return this.memory[index]__	};reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,final,byte,get,int,index,return,this,memory,index
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1405024514;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1405090423;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1411473593;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1418658367;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1421050512;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1441738685;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1446112342;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1455479358;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1474380620;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1507315082;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1509981552;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1513874825;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1516285456;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1550507508;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatLittleEndian(int index, float value);1550567875;Writes the given single-precision float value (32bit, 4 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final void putFloatLittleEndian(int index, float value) {_		putIntLittleEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,void,put,float,little,endian,int,index,float,value,put,int,little,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public abstract byte get(int index)_;1441738685;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract byte get(int index)_;reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,byte,get,int,index
MemorySegment -> public abstract byte get(int index)_;1446112342;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract byte get(int index)_;reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,byte,get,int,index
MemorySegment -> public abstract byte get(int index)_;1455479358;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract byte get(int index)_;reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,byte,get,int,index
MemorySegment -> public abstract byte get(int index)_;1474380620;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract byte get(int index)_;reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,byte,get,int,index
MemorySegment -> public abstract byte get(int index)_;1507315082;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract byte get(int index)_;reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,byte,get,int,index
MemorySegment -> public abstract byte get(int index)_;1509981552;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract byte get(int index)_;reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,byte,get,int,index
MemorySegment -> public abstract byte get(int index)_;1513874825;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract byte get(int index)_;reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,byte,get,int,index
MemorySegment -> public abstract byte get(int index)_;1516285456;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract byte get(int index)_;reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,byte,get,int,index
MemorySegment -> public abstract byte get(int index)_;1550507508;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract byte get(int index)_;reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,byte,get,int,index
MemorySegment -> public abstract byte get(int index)_;1550567875;Reads the byte at the given position.__@param index The position from which the byte will be read_@return The byte at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public abstract byte get(int index)_;reads,the,byte,at,the,given,position,param,index,the,position,from,which,the,byte,will,be,read,return,the,byte,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,abstract,byte,get,int,index
MemorySegment -> public final void put(int offset, ByteBuffer source, int numBytes);1405024514;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public final void put(int offset, ByteBuffer source, int numBytes) {_		_		source.get(this.memory, offset, numBytes)__	};bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,final,void,put,int,offset,byte,buffer,source,int,num,bytes,source,get,this,memory,offset,num,bytes
MemorySegment -> public final void put(int offset, ByteBuffer source, int numBytes);1405090423;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public final void put(int offset, ByteBuffer source, int numBytes) {_		_		source.get(this.memory, offset, numBytes)__	};bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,final,void,put,int,offset,byte,buffer,source,int,num,bytes,source,get,this,memory,offset,num,bytes
MemorySegment -> public final void put(int offset, ByteBuffer source, int numBytes);1411473593;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public final void put(int offset, ByteBuffer source, int numBytes) {_		_		source.get(this.memory, offset, numBytes)__	};bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,final,void,put,int,offset,byte,buffer,source,int,num,bytes,source,get,this,memory,offset,num,bytes
MemorySegment -> public final void put(int offset, ByteBuffer source, int numBytes);1418658367;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public final void put(int offset, ByteBuffer source, int numBytes) {_		_		source.get(this.memory, offset, numBytes)__	};bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,final,void,put,int,offset,byte,buffer,source,int,num,bytes,source,get,this,memory,offset,num,bytes
MemorySegment -> public final void put(int offset, ByteBuffer source, int numBytes);1421050512;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public final void put(int offset, ByteBuffer source, int numBytes) {_		_		source.get(this.memory, offset, numBytes)__	};bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,final,void,put,int,offset,byte,buffer,source,int,num,bytes,source,get,this,memory,offset,num,bytes
MemorySegment -> public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len);1441738685;Swaps bytes between two memory segments, using the given auxiliary buffer.__@param tempBuffer The auxiliary buffer in which to put data during triangle swap._@param seg2 Segment to swap bytes with_@param offset1 Offset of this segment to start swapping_@param offset2 Offset of seg2 to start swapping_@param len Length of the swapped memory region;public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len) {_		if ( (offset1 | offset2 | len | (tempBuffer.length - len) ) >= 0) {_			final long thisPos = this.address + offset1__			final long otherPos = seg2.address + offset2__			_			if (thisPos <= this.addressLimit - len && otherPos <= seg2.addressLimit - len) {_				_				UNSAFE.copyMemory(this.heapMemory, thisPos, tempBuffer, BYTE_ARRAY_BASE_OFFSET, len)__	_				_				UNSAFE.copyMemory(seg2.heapMemory, otherPos, this.heapMemory, thisPos, len)__	_				_				UNSAFE.copyMemory(tempBuffer, BYTE_ARRAY_BASE_OFFSET, seg2.heapMemory, otherPos, len)__				return__			}_			else if (this.address > this.addressLimit) {_				throw new IllegalStateException("this memory segment has been freed.")__			}_			else if (seg2.address > seg2.addressLimit) {_				throw new IllegalStateException("other memory segment has been freed.")__			}_		}_		_		_		throw new IndexOutOfBoundsException(_					String.format("offset1=%d, offset2=%d, len=%d, bufferSize=%d, address1=%d, address2=%d",_							offset1, offset2, len, tempBuffer.length, this.address, seg2.address))__	};swaps,bytes,between,two,memory,segments,using,the,given,auxiliary,buffer,param,temp,buffer,the,auxiliary,buffer,in,which,to,put,data,during,triangle,swap,param,seg2,segment,to,swap,bytes,with,param,offset1,offset,of,this,segment,to,start,swapping,param,offset2,offset,of,seg2,to,start,swapping,param,len,length,of,the,swapped,memory,region;public,final,void,swap,bytes,byte,temp,buffer,memory,segment,seg2,int,offset1,int,offset2,int,len,if,offset1,offset2,len,temp,buffer,length,len,0,final,long,this,pos,this,address,offset1,final,long,other,pos,seg2,address,offset2,if,this,pos,this,address,limit,len,other,pos,seg2,address,limit,len,unsafe,copy,memory,this,heap,memory,this,pos,temp,buffer,len,unsafe,copy,memory,seg2,heap,memory,other,pos,this,heap,memory,this,pos,len,unsafe,copy,memory,temp,buffer,seg2,heap,memory,other,pos,len,return,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,seg2,address,seg2,address,limit,throw,new,illegal,state,exception,other,memory,segment,has,been,freed,throw,new,index,out,of,bounds,exception,string,format,offset1,d,offset2,d,len,d,buffer,size,d,address1,d,address2,d,offset1,offset2,len,temp,buffer,length,this,address,seg2,address
MemorySegment -> public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len);1446112342;Swaps bytes between two memory segments, using the given auxiliary buffer.__@param tempBuffer The auxiliary buffer in which to put data during triangle swap._@param seg2 Segment to swap bytes with_@param offset1 Offset of this segment to start swapping_@param offset2 Offset of seg2 to start swapping_@param len Length of the swapped memory region;public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len) {_		if ( (offset1 | offset2 | len | (tempBuffer.length - len) ) >= 0) {_			final long thisPos = this.address + offset1__			final long otherPos = seg2.address + offset2__			_			if (thisPos <= this.addressLimit - len && otherPos <= seg2.addressLimit - len) {_				_				UNSAFE.copyMemory(this.heapMemory, thisPos, tempBuffer, BYTE_ARRAY_BASE_OFFSET, len)__	_				_				UNSAFE.copyMemory(seg2.heapMemory, otherPos, this.heapMemory, thisPos, len)__	_				_				UNSAFE.copyMemory(tempBuffer, BYTE_ARRAY_BASE_OFFSET, seg2.heapMemory, otherPos, len)__				return__			}_			else if (this.address > this.addressLimit) {_				throw new IllegalStateException("this memory segment has been freed.")__			}_			else if (seg2.address > seg2.addressLimit) {_				throw new IllegalStateException("other memory segment has been freed.")__			}_		}_		_		_		throw new IndexOutOfBoundsException(_					String.format("offset1=%d, offset2=%d, len=%d, bufferSize=%d, address1=%d, address2=%d",_							offset1, offset2, len, tempBuffer.length, this.address, seg2.address))__	};swaps,bytes,between,two,memory,segments,using,the,given,auxiliary,buffer,param,temp,buffer,the,auxiliary,buffer,in,which,to,put,data,during,triangle,swap,param,seg2,segment,to,swap,bytes,with,param,offset1,offset,of,this,segment,to,start,swapping,param,offset2,offset,of,seg2,to,start,swapping,param,len,length,of,the,swapped,memory,region;public,final,void,swap,bytes,byte,temp,buffer,memory,segment,seg2,int,offset1,int,offset2,int,len,if,offset1,offset2,len,temp,buffer,length,len,0,final,long,this,pos,this,address,offset1,final,long,other,pos,seg2,address,offset2,if,this,pos,this,address,limit,len,other,pos,seg2,address,limit,len,unsafe,copy,memory,this,heap,memory,this,pos,temp,buffer,len,unsafe,copy,memory,seg2,heap,memory,other,pos,this,heap,memory,this,pos,len,unsafe,copy,memory,temp,buffer,seg2,heap,memory,other,pos,len,return,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,seg2,address,seg2,address,limit,throw,new,illegal,state,exception,other,memory,segment,has,been,freed,throw,new,index,out,of,bounds,exception,string,format,offset1,d,offset2,d,len,d,buffer,size,d,address1,d,address2,d,offset1,offset2,len,temp,buffer,length,this,address,seg2,address
MemorySegment -> public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len);1455479358;Swaps bytes between two memory segments, using the given auxiliary buffer.__@param tempBuffer The auxiliary buffer in which to put data during triangle swap._@param seg2 Segment to swap bytes with_@param offset1 Offset of this segment to start swapping_@param offset2 Offset of seg2 to start swapping_@param len Length of the swapped memory region;public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len) {_		if ( (offset1 | offset2 | len | (tempBuffer.length - len) ) >= 0) {_			final long thisPos = this.address + offset1__			final long otherPos = seg2.address + offset2__			_			if (thisPos <= this.addressLimit - len && otherPos <= seg2.addressLimit - len) {_				_				UNSAFE.copyMemory(this.heapMemory, thisPos, tempBuffer, BYTE_ARRAY_BASE_OFFSET, len)__	_				_				UNSAFE.copyMemory(seg2.heapMemory, otherPos, this.heapMemory, thisPos, len)__	_				_				UNSAFE.copyMemory(tempBuffer, BYTE_ARRAY_BASE_OFFSET, seg2.heapMemory, otherPos, len)__				return__			}_			else if (this.address > this.addressLimit) {_				throw new IllegalStateException("this memory segment has been freed.")__			}_			else if (seg2.address > seg2.addressLimit) {_				throw new IllegalStateException("other memory segment has been freed.")__			}_		}_		_		_		throw new IndexOutOfBoundsException(_					String.format("offset1=%d, offset2=%d, len=%d, bufferSize=%d, address1=%d, address2=%d",_							offset1, offset2, len, tempBuffer.length, this.address, seg2.address))__	};swaps,bytes,between,two,memory,segments,using,the,given,auxiliary,buffer,param,temp,buffer,the,auxiliary,buffer,in,which,to,put,data,during,triangle,swap,param,seg2,segment,to,swap,bytes,with,param,offset1,offset,of,this,segment,to,start,swapping,param,offset2,offset,of,seg2,to,start,swapping,param,len,length,of,the,swapped,memory,region;public,final,void,swap,bytes,byte,temp,buffer,memory,segment,seg2,int,offset1,int,offset2,int,len,if,offset1,offset2,len,temp,buffer,length,len,0,final,long,this,pos,this,address,offset1,final,long,other,pos,seg2,address,offset2,if,this,pos,this,address,limit,len,other,pos,seg2,address,limit,len,unsafe,copy,memory,this,heap,memory,this,pos,temp,buffer,len,unsafe,copy,memory,seg2,heap,memory,other,pos,this,heap,memory,this,pos,len,unsafe,copy,memory,temp,buffer,seg2,heap,memory,other,pos,len,return,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,seg2,address,seg2,address,limit,throw,new,illegal,state,exception,other,memory,segment,has,been,freed,throw,new,index,out,of,bounds,exception,string,format,offset1,d,offset2,d,len,d,buffer,size,d,address1,d,address2,d,offset1,offset2,len,temp,buffer,length,this,address,seg2,address
MemorySegment -> public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len);1474380620;Swaps bytes between two memory segments, using the given auxiliary buffer.__@param tempBuffer The auxiliary buffer in which to put data during triangle swap._@param seg2 Segment to swap bytes with_@param offset1 Offset of this segment to start swapping_@param offset2 Offset of seg2 to start swapping_@param len Length of the swapped memory region;public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len) {_		if ( (offset1 | offset2 | len | (tempBuffer.length - len) ) >= 0) {_			final long thisPos = this.address + offset1__			final long otherPos = seg2.address + offset2__			_			if (thisPos <= this.addressLimit - len && otherPos <= seg2.addressLimit - len) {_				_				UNSAFE.copyMemory(this.heapMemory, thisPos, tempBuffer, BYTE_ARRAY_BASE_OFFSET, len)__	_				_				UNSAFE.copyMemory(seg2.heapMemory, otherPos, this.heapMemory, thisPos, len)__	_				_				UNSAFE.copyMemory(tempBuffer, BYTE_ARRAY_BASE_OFFSET, seg2.heapMemory, otherPos, len)__				return__			}_			else if (this.address > this.addressLimit) {_				throw new IllegalStateException("this memory segment has been freed.")__			}_			else if (seg2.address > seg2.addressLimit) {_				throw new IllegalStateException("other memory segment has been freed.")__			}_		}_		_		_		throw new IndexOutOfBoundsException(_					String.format("offset1=%d, offset2=%d, len=%d, bufferSize=%d, address1=%d, address2=%d",_							offset1, offset2, len, tempBuffer.length, this.address, seg2.address))__	};swaps,bytes,between,two,memory,segments,using,the,given,auxiliary,buffer,param,temp,buffer,the,auxiliary,buffer,in,which,to,put,data,during,triangle,swap,param,seg2,segment,to,swap,bytes,with,param,offset1,offset,of,this,segment,to,start,swapping,param,offset2,offset,of,seg2,to,start,swapping,param,len,length,of,the,swapped,memory,region;public,final,void,swap,bytes,byte,temp,buffer,memory,segment,seg2,int,offset1,int,offset2,int,len,if,offset1,offset2,len,temp,buffer,length,len,0,final,long,this,pos,this,address,offset1,final,long,other,pos,seg2,address,offset2,if,this,pos,this,address,limit,len,other,pos,seg2,address,limit,len,unsafe,copy,memory,this,heap,memory,this,pos,temp,buffer,len,unsafe,copy,memory,seg2,heap,memory,other,pos,this,heap,memory,this,pos,len,unsafe,copy,memory,temp,buffer,seg2,heap,memory,other,pos,len,return,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,seg2,address,seg2,address,limit,throw,new,illegal,state,exception,other,memory,segment,has,been,freed,throw,new,index,out,of,bounds,exception,string,format,offset1,d,offset2,d,len,d,buffer,size,d,address1,d,address2,d,offset1,offset2,len,temp,buffer,length,this,address,seg2,address
MemorySegment -> public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len);1507315082;Swaps bytes between two memory segments, using the given auxiliary buffer.__@param tempBuffer The auxiliary buffer in which to put data during triangle swap._@param seg2 Segment to swap bytes with_@param offset1 Offset of this segment to start swapping_@param offset2 Offset of seg2 to start swapping_@param len Length of the swapped memory region;public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len) {_		if ((offset1 | offset2 | len | (tempBuffer.length - len)) >= 0) {_			final long thisPos = this.address + offset1__			final long otherPos = seg2.address + offset2___			if (thisPos <= this.addressLimit - len && otherPos <= seg2.addressLimit - len) {_				_				UNSAFE.copyMemory(this.heapMemory, thisPos, tempBuffer, BYTE_ARRAY_BASE_OFFSET, len)___				_				UNSAFE.copyMemory(seg2.heapMemory, otherPos, this.heapMemory, thisPos, len)___				_				UNSAFE.copyMemory(tempBuffer, BYTE_ARRAY_BASE_OFFSET, seg2.heapMemory, otherPos, len)__				return__			}_			else if (this.address > this.addressLimit) {_				throw new IllegalStateException("this memory segment has been freed.")__			}_			else if (seg2.address > seg2.addressLimit) {_				throw new IllegalStateException("other memory segment has been freed.")__			}_		}__		_		throw new IndexOutOfBoundsException(_					String.format("offset1=%d, offset2=%d, len=%d, bufferSize=%d, address1=%d, address2=%d",_							offset1, offset2, len, tempBuffer.length, this.address, seg2.address))__	};swaps,bytes,between,two,memory,segments,using,the,given,auxiliary,buffer,param,temp,buffer,the,auxiliary,buffer,in,which,to,put,data,during,triangle,swap,param,seg2,segment,to,swap,bytes,with,param,offset1,offset,of,this,segment,to,start,swapping,param,offset2,offset,of,seg2,to,start,swapping,param,len,length,of,the,swapped,memory,region;public,final,void,swap,bytes,byte,temp,buffer,memory,segment,seg2,int,offset1,int,offset2,int,len,if,offset1,offset2,len,temp,buffer,length,len,0,final,long,this,pos,this,address,offset1,final,long,other,pos,seg2,address,offset2,if,this,pos,this,address,limit,len,other,pos,seg2,address,limit,len,unsafe,copy,memory,this,heap,memory,this,pos,temp,buffer,len,unsafe,copy,memory,seg2,heap,memory,other,pos,this,heap,memory,this,pos,len,unsafe,copy,memory,temp,buffer,seg2,heap,memory,other,pos,len,return,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,seg2,address,seg2,address,limit,throw,new,illegal,state,exception,other,memory,segment,has,been,freed,throw,new,index,out,of,bounds,exception,string,format,offset1,d,offset2,d,len,d,buffer,size,d,address1,d,address2,d,offset1,offset2,len,temp,buffer,length,this,address,seg2,address
MemorySegment -> public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len);1509981552;Swaps bytes between two memory segments, using the given auxiliary buffer.__@param tempBuffer The auxiliary buffer in which to put data during triangle swap._@param seg2 Segment to swap bytes with_@param offset1 Offset of this segment to start swapping_@param offset2 Offset of seg2 to start swapping_@param len Length of the swapped memory region;public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len) {_		if ((offset1 | offset2 | len | (tempBuffer.length - len)) >= 0) {_			final long thisPos = this.address + offset1__			final long otherPos = seg2.address + offset2___			if (thisPos <= this.addressLimit - len && otherPos <= seg2.addressLimit - len) {_				_				UNSAFE.copyMemory(this.heapMemory, thisPos, tempBuffer, BYTE_ARRAY_BASE_OFFSET, len)___				_				UNSAFE.copyMemory(seg2.heapMemory, otherPos, this.heapMemory, thisPos, len)___				_				UNSAFE.copyMemory(tempBuffer, BYTE_ARRAY_BASE_OFFSET, seg2.heapMemory, otherPos, len)__				return__			}_			else if (this.address > this.addressLimit) {_				throw new IllegalStateException("this memory segment has been freed.")__			}_			else if (seg2.address > seg2.addressLimit) {_				throw new IllegalStateException("other memory segment has been freed.")__			}_		}__		_		throw new IndexOutOfBoundsException(_					String.format("offset1=%d, offset2=%d, len=%d, bufferSize=%d, address1=%d, address2=%d",_							offset1, offset2, len, tempBuffer.length, this.address, seg2.address))__	};swaps,bytes,between,two,memory,segments,using,the,given,auxiliary,buffer,param,temp,buffer,the,auxiliary,buffer,in,which,to,put,data,during,triangle,swap,param,seg2,segment,to,swap,bytes,with,param,offset1,offset,of,this,segment,to,start,swapping,param,offset2,offset,of,seg2,to,start,swapping,param,len,length,of,the,swapped,memory,region;public,final,void,swap,bytes,byte,temp,buffer,memory,segment,seg2,int,offset1,int,offset2,int,len,if,offset1,offset2,len,temp,buffer,length,len,0,final,long,this,pos,this,address,offset1,final,long,other,pos,seg2,address,offset2,if,this,pos,this,address,limit,len,other,pos,seg2,address,limit,len,unsafe,copy,memory,this,heap,memory,this,pos,temp,buffer,len,unsafe,copy,memory,seg2,heap,memory,other,pos,this,heap,memory,this,pos,len,unsafe,copy,memory,temp,buffer,seg2,heap,memory,other,pos,len,return,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,seg2,address,seg2,address,limit,throw,new,illegal,state,exception,other,memory,segment,has,been,freed,throw,new,index,out,of,bounds,exception,string,format,offset1,d,offset2,d,len,d,buffer,size,d,address1,d,address2,d,offset1,offset2,len,temp,buffer,length,this,address,seg2,address
MemorySegment -> public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len);1513874825;Swaps bytes between two memory segments, using the given auxiliary buffer.__@param tempBuffer The auxiliary buffer in which to put data during triangle swap._@param seg2 Segment to swap bytes with_@param offset1 Offset of this segment to start swapping_@param offset2 Offset of seg2 to start swapping_@param len Length of the swapped memory region;public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len) {_		if ((offset1 | offset2 | len | (tempBuffer.length - len)) >= 0) {_			final long thisPos = this.address + offset1__			final long otherPos = seg2.address + offset2___			if (thisPos <= this.addressLimit - len && otherPos <= seg2.addressLimit - len) {_				_				UNSAFE.copyMemory(this.heapMemory, thisPos, tempBuffer, BYTE_ARRAY_BASE_OFFSET, len)___				_				UNSAFE.copyMemory(seg2.heapMemory, otherPos, this.heapMemory, thisPos, len)___				_				UNSAFE.copyMemory(tempBuffer, BYTE_ARRAY_BASE_OFFSET, seg2.heapMemory, otherPos, len)__				return__			}_			else if (this.address > this.addressLimit) {_				throw new IllegalStateException("this memory segment has been freed.")__			}_			else if (seg2.address > seg2.addressLimit) {_				throw new IllegalStateException("other memory segment has been freed.")__			}_		}__		_		throw new IndexOutOfBoundsException(_					String.format("offset1=%d, offset2=%d, len=%d, bufferSize=%d, address1=%d, address2=%d",_							offset1, offset2, len, tempBuffer.length, this.address, seg2.address))__	};swaps,bytes,between,two,memory,segments,using,the,given,auxiliary,buffer,param,temp,buffer,the,auxiliary,buffer,in,which,to,put,data,during,triangle,swap,param,seg2,segment,to,swap,bytes,with,param,offset1,offset,of,this,segment,to,start,swapping,param,offset2,offset,of,seg2,to,start,swapping,param,len,length,of,the,swapped,memory,region;public,final,void,swap,bytes,byte,temp,buffer,memory,segment,seg2,int,offset1,int,offset2,int,len,if,offset1,offset2,len,temp,buffer,length,len,0,final,long,this,pos,this,address,offset1,final,long,other,pos,seg2,address,offset2,if,this,pos,this,address,limit,len,other,pos,seg2,address,limit,len,unsafe,copy,memory,this,heap,memory,this,pos,temp,buffer,len,unsafe,copy,memory,seg2,heap,memory,other,pos,this,heap,memory,this,pos,len,unsafe,copy,memory,temp,buffer,seg2,heap,memory,other,pos,len,return,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,seg2,address,seg2,address,limit,throw,new,illegal,state,exception,other,memory,segment,has,been,freed,throw,new,index,out,of,bounds,exception,string,format,offset1,d,offset2,d,len,d,buffer,size,d,address1,d,address2,d,offset1,offset2,len,temp,buffer,length,this,address,seg2,address
MemorySegment -> public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len);1516285456;Swaps bytes between two memory segments, using the given auxiliary buffer.__@param tempBuffer The auxiliary buffer in which to put data during triangle swap._@param seg2 Segment to swap bytes with_@param offset1 Offset of this segment to start swapping_@param offset2 Offset of seg2 to start swapping_@param len Length of the swapped memory region;public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len) {_		if ((offset1 | offset2 | len | (tempBuffer.length - len)) >= 0) {_			final long thisPos = this.address + offset1__			final long otherPos = seg2.address + offset2___			if (thisPos <= this.addressLimit - len && otherPos <= seg2.addressLimit - len) {_				_				UNSAFE.copyMemory(this.heapMemory, thisPos, tempBuffer, BYTE_ARRAY_BASE_OFFSET, len)___				_				UNSAFE.copyMemory(seg2.heapMemory, otherPos, this.heapMemory, thisPos, len)___				_				UNSAFE.copyMemory(tempBuffer, BYTE_ARRAY_BASE_OFFSET, seg2.heapMemory, otherPos, len)__				return__			}_			else if (this.address > this.addressLimit) {_				throw new IllegalStateException("this memory segment has been freed.")__			}_			else if (seg2.address > seg2.addressLimit) {_				throw new IllegalStateException("other memory segment has been freed.")__			}_		}__		_		throw new IndexOutOfBoundsException(_					String.format("offset1=%d, offset2=%d, len=%d, bufferSize=%d, address1=%d, address2=%d",_							offset1, offset2, len, tempBuffer.length, this.address, seg2.address))__	};swaps,bytes,between,two,memory,segments,using,the,given,auxiliary,buffer,param,temp,buffer,the,auxiliary,buffer,in,which,to,put,data,during,triangle,swap,param,seg2,segment,to,swap,bytes,with,param,offset1,offset,of,this,segment,to,start,swapping,param,offset2,offset,of,seg2,to,start,swapping,param,len,length,of,the,swapped,memory,region;public,final,void,swap,bytes,byte,temp,buffer,memory,segment,seg2,int,offset1,int,offset2,int,len,if,offset1,offset2,len,temp,buffer,length,len,0,final,long,this,pos,this,address,offset1,final,long,other,pos,seg2,address,offset2,if,this,pos,this,address,limit,len,other,pos,seg2,address,limit,len,unsafe,copy,memory,this,heap,memory,this,pos,temp,buffer,len,unsafe,copy,memory,seg2,heap,memory,other,pos,this,heap,memory,this,pos,len,unsafe,copy,memory,temp,buffer,seg2,heap,memory,other,pos,len,return,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,seg2,address,seg2,address,limit,throw,new,illegal,state,exception,other,memory,segment,has,been,freed,throw,new,index,out,of,bounds,exception,string,format,offset1,d,offset2,d,len,d,buffer,size,d,address1,d,address2,d,offset1,offset2,len,temp,buffer,length,this,address,seg2,address
MemorySegment -> public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len);1550507508;Swaps bytes between two memory segments, using the given auxiliary buffer.__@param tempBuffer The auxiliary buffer in which to put data during triangle swap._@param seg2 Segment to swap bytes with_@param offset1 Offset of this segment to start swapping_@param offset2 Offset of seg2 to start swapping_@param len Length of the swapped memory region;public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len) {_		if ((offset1 | offset2 | len | (tempBuffer.length - len)) >= 0) {_			final long thisPos = this.address + offset1__			final long otherPos = seg2.address + offset2___			if (thisPos <= this.addressLimit - len && otherPos <= seg2.addressLimit - len) {_				_				UNSAFE.copyMemory(this.heapMemory, thisPos, tempBuffer, BYTE_ARRAY_BASE_OFFSET, len)___				_				UNSAFE.copyMemory(seg2.heapMemory, otherPos, this.heapMemory, thisPos, len)___				_				UNSAFE.copyMemory(tempBuffer, BYTE_ARRAY_BASE_OFFSET, seg2.heapMemory, otherPos, len)__				return__			}_			else if (this.address > this.addressLimit) {_				throw new IllegalStateException("this memory segment has been freed.")__			}_			else if (seg2.address > seg2.addressLimit) {_				throw new IllegalStateException("other memory segment has been freed.")__			}_		}__		_		throw new IndexOutOfBoundsException(_					String.format("offset1=%d, offset2=%d, len=%d, bufferSize=%d, address1=%d, address2=%d",_							offset1, offset2, len, tempBuffer.length, this.address, seg2.address))__	};swaps,bytes,between,two,memory,segments,using,the,given,auxiliary,buffer,param,temp,buffer,the,auxiliary,buffer,in,which,to,put,data,during,triangle,swap,param,seg2,segment,to,swap,bytes,with,param,offset1,offset,of,this,segment,to,start,swapping,param,offset2,offset,of,seg2,to,start,swapping,param,len,length,of,the,swapped,memory,region;public,final,void,swap,bytes,byte,temp,buffer,memory,segment,seg2,int,offset1,int,offset2,int,len,if,offset1,offset2,len,temp,buffer,length,len,0,final,long,this,pos,this,address,offset1,final,long,other,pos,seg2,address,offset2,if,this,pos,this,address,limit,len,other,pos,seg2,address,limit,len,unsafe,copy,memory,this,heap,memory,this,pos,temp,buffer,len,unsafe,copy,memory,seg2,heap,memory,other,pos,this,heap,memory,this,pos,len,unsafe,copy,memory,temp,buffer,seg2,heap,memory,other,pos,len,return,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,seg2,address,seg2,address,limit,throw,new,illegal,state,exception,other,memory,segment,has,been,freed,throw,new,index,out,of,bounds,exception,string,format,offset1,d,offset2,d,len,d,buffer,size,d,address1,d,address2,d,offset1,offset2,len,temp,buffer,length,this,address,seg2,address
MemorySegment -> public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len);1550567875;Swaps bytes between two memory segments, using the given auxiliary buffer.__@param tempBuffer The auxiliary buffer in which to put data during triangle swap._@param seg2 Segment to swap bytes with_@param offset1 Offset of this segment to start swapping_@param offset2 Offset of seg2 to start swapping_@param len Length of the swapped memory region;public final void swapBytes(byte[] tempBuffer, MemorySegment seg2, int offset1, int offset2, int len) {_		if ((offset1 | offset2 | len | (tempBuffer.length - len)) >= 0) {_			final long thisPos = this.address + offset1__			final long otherPos = seg2.address + offset2___			if (thisPos <= this.addressLimit - len && otherPos <= seg2.addressLimit - len) {_				_				UNSAFE.copyMemory(this.heapMemory, thisPos, tempBuffer, BYTE_ARRAY_BASE_OFFSET, len)___				_				UNSAFE.copyMemory(seg2.heapMemory, otherPos, this.heapMemory, thisPos, len)___				_				UNSAFE.copyMemory(tempBuffer, BYTE_ARRAY_BASE_OFFSET, seg2.heapMemory, otherPos, len)__				return__			}_			else if (this.address > this.addressLimit) {_				throw new IllegalStateException("this memory segment has been freed.")__			}_			else if (seg2.address > seg2.addressLimit) {_				throw new IllegalStateException("other memory segment has been freed.")__			}_		}__		_		throw new IndexOutOfBoundsException(_					String.format("offset1=%d, offset2=%d, len=%d, bufferSize=%d, address1=%d, address2=%d",_							offset1, offset2, len, tempBuffer.length, this.address, seg2.address))__	};swaps,bytes,between,two,memory,segments,using,the,given,auxiliary,buffer,param,temp,buffer,the,auxiliary,buffer,in,which,to,put,data,during,triangle,swap,param,seg2,segment,to,swap,bytes,with,param,offset1,offset,of,this,segment,to,start,swapping,param,offset2,offset,of,seg2,to,start,swapping,param,len,length,of,the,swapped,memory,region;public,final,void,swap,bytes,byte,temp,buffer,memory,segment,seg2,int,offset1,int,offset2,int,len,if,offset1,offset2,len,temp,buffer,length,len,0,final,long,this,pos,this,address,offset1,final,long,other,pos,seg2,address,offset2,if,this,pos,this,address,limit,len,other,pos,seg2,address,limit,len,unsafe,copy,memory,this,heap,memory,this,pos,temp,buffer,len,unsafe,copy,memory,seg2,heap,memory,other,pos,this,heap,memory,this,pos,len,unsafe,copy,memory,temp,buffer,seg2,heap,memory,other,pos,len,return,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,seg2,address,seg2,address,limit,throw,new,illegal,state,exception,other,memory,segment,has,been,freed,throw,new,index,out,of,bounds,exception,string,format,offset1,d,offset2,d,len,d,buffer,size,d,address1,d,address2,d,offset1,offset2,len,temp,buffer,length,this,address,seg2,address
MemorySegment -> public long getAddress();1516285456;Returns the memory address of off-heap memory segments.__@return absolute memory address outside the heap__@throws IllegalStateException_if the memory segment does not represent off-heap memory;public long getAddress() {_		if (heapMemory == null) {_			return address__		} else {_			throw new IllegalStateException("Memory segment does not represent off heap memory")__		}_	};returns,the,memory,address,of,off,heap,memory,segments,return,absolute,memory,address,outside,the,heap,throws,illegal,state,exception,if,the,memory,segment,does,not,represent,off,heap,memory;public,long,get,address,if,heap,memory,null,return,address,else,throw,new,illegal,state,exception,memory,segment,does,not,represent,off,heap,memory
MemorySegment -> public long getAddress();1550507508;Returns the memory address of off-heap memory segments.__@return absolute memory address outside the heap__@throws IllegalStateException_if the memory segment does not represent off-heap memory;public long getAddress() {_		if (heapMemory == null) {_			return address__		} else {_			throw new IllegalStateException("Memory segment does not represent off heap memory")__		}_	};returns,the,memory,address,of,off,heap,memory,segments,return,absolute,memory,address,outside,the,heap,throws,illegal,state,exception,if,the,memory,segment,does,not,represent,off,heap,memory;public,long,get,address,if,heap,memory,null,return,address,else,throw,new,illegal,state,exception,memory,segment,does,not,represent,off,heap,memory
MemorySegment -> public long getAddress();1550567875;Returns the memory address of off-heap memory segments.__@return absolute memory address outside the heap__@throws IllegalStateException_if the memory segment does not represent off-heap memory;public long getAddress() {_		if (heapMemory == null) {_			return address__		} else {_			throw new IllegalStateException("Memory segment does not represent off heap memory")__		}_	};returns,the,memory,address,of,off,heap,memory,segments,return,absolute,memory,address,outside,the,heap,throws,illegal,state,exception,if,the,memory,segment,does,not,represent,off,heap,memory;public,long,get,address,if,heap,memory,null,return,address,else,throw,new,illegal,state,exception,memory,segment,does,not,represent,off,heap,memory
MemorySegment -> public final void putIntBigEndian(int index, int value);1405024514;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1405090423;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1411473593;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1418658367;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1421050512;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1441738685;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1446112342;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1455479358;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1474380620;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1507315082;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1509981552;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1513874825;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1516285456;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1550507508;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final void putIntBigEndian(int index, int value);1550567875;Writes the given int value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putInt(int, int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putInt(int, int)} is the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 4.;public final void putIntBigEndian(int index, int value) {_		if (LITTLE_ENDIAN) {_			putInt(index, Integer.reverseBytes(value))__		} else {_			putInt(index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,int,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,int,int,int,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,4;public,final,void,put,int,big,endian,int,index,int,value,if,put,int,index,integer,reverse,bytes,value,else,put,int,index,value
MemorySegment -> public final double getDouble(int index);1405024514;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1405090423;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1411473593;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1418658367;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1421050512;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1441738685;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1446112342;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1455479358;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1474380620;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1507315082;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1509981552;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1513874825;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1516285456;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1550507508;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public final double getDouble(int index);1550567875;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in the system's_native byte order. This method offers the best speed for double reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The double value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final double getDouble(int index) {_		return Double.longBitsToDouble(getLong(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,double,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,double,get,double,int,index,return,double,long,bits,to,double,get,long,index
MemorySegment -> public abstract boolean getBoolean(int index)_;1441738685;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract boolean getBoolean(int index)_;reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,boolean,get,boolean,int,index
MemorySegment -> public abstract boolean getBoolean(int index)_;1446112342;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract boolean getBoolean(int index)_;reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,boolean,get,boolean,int,index
MemorySegment -> public abstract boolean getBoolean(int index)_;1455479358;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract boolean getBoolean(int index)_;reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,boolean,get,boolean,int,index
MemorySegment -> public abstract boolean getBoolean(int index)_;1474380620;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract boolean getBoolean(int index)_;reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,boolean,get,boolean,int,index
MemorySegment -> public abstract boolean getBoolean(int index)_;1507315082;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract boolean getBoolean(int index)_;reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,boolean,get,boolean,int,index
MemorySegment -> public abstract boolean getBoolean(int index)_;1509981552;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract boolean getBoolean(int index)_;reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,boolean,get,boolean,int,index
MemorySegment -> public abstract boolean getBoolean(int index)_;1513874825;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract boolean getBoolean(int index)_;reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,boolean,get,boolean,int,index
MemorySegment -> public abstract boolean getBoolean(int index)_;1516285456;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract boolean getBoolean(int index)_;reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,boolean,get,boolean,int,index
MemorySegment -> public abstract boolean getBoolean(int index)_;1550507508;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract boolean getBoolean(int index)_;reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,boolean,get,boolean,int,index
MemorySegment -> public abstract boolean getBoolean(int index)_;1550567875;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 1.;public abstract boolean getBoolean(int index)_;reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,1;public,abstract,boolean,get,boolean,int,index
MemorySegment -> public final void putFloatBigEndian(int index, float value);1405024514;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1405090423;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1411473593;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1418658367;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1421050512;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1441738685;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1446112342;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1455479358;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1474380620;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1507315082;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1509981552;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1513874825;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1516285456;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1550507508;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloatBigEndian(int index, float value);1550567875;Writes the given single-precision float value (32bit, 4 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putFloat(int, float)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putFloat(int, float)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final void putFloatBigEndian(int index, float value) {_		putIntBigEndian(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,float,int,float,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,float,int,float,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,void,put,float,big,endian,int,index,float,value,put,int,big,endian,index,float,float,to,raw,int,bits,value
MemorySegment -> public final float getFloatBigEndian(int index);1405024514;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1405090423;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1411473593;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1418658367;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1421050512;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1441738685;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1446112342;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1455479358;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1474380620;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1507315082;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1509981552;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1513874825;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1516285456;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1550507508;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public final float getFloatBigEndian(int index);1550567875;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final float getFloatBigEndian(int index) {_		return Float.intBitsToFloat(getIntBigEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,float,get,float,big,endian,int,index,return,float,int,bits,to,float,get,int,big,endian,index
MemorySegment -> public void free();1441738685;Frees this memory segment. After this operation has been called, no further operations are_possible on the memory segment and will fail. The actual memory (heap or off-heap) will only_be released after this memory segment object has become garbage collected.;public void free() {_		_		_		address = addressLimit + 1__	};frees,this,memory,segment,after,this,operation,has,been,called,no,further,operations,are,possible,on,the,memory,segment,and,will,fail,the,actual,memory,heap,or,off,heap,will,only,be,released,after,this,memory,segment,object,has,become,garbage,collected;public,void,free,address,address,limit,1
MemorySegment -> public void free();1446112342;Frees this memory segment. After this operation has been called, no further operations are_possible on the memory segment and will fail. The actual memory (heap or off-heap) will only_be released after this memory segment object has become garbage collected.;public void free() {_		_		_		address = addressLimit + 1__	};frees,this,memory,segment,after,this,operation,has,been,called,no,further,operations,are,possible,on,the,memory,segment,and,will,fail,the,actual,memory,heap,or,off,heap,will,only,be,released,after,this,memory,segment,object,has,become,garbage,collected;public,void,free,address,address,limit,1
MemorySegment -> public void free();1455479358;Frees this memory segment. After this operation has been called, no further operations are_possible on the memory segment and will fail. The actual memory (heap or off-heap) will only_be released after this memory segment object has become garbage collected.;public void free() {_		_		_		address = addressLimit + 1__	};frees,this,memory,segment,after,this,operation,has,been,called,no,further,operations,are,possible,on,the,memory,segment,and,will,fail,the,actual,memory,heap,or,off,heap,will,only,be,released,after,this,memory,segment,object,has,become,garbage,collected;public,void,free,address,address,limit,1
MemorySegment -> public void free();1474380620;Frees this memory segment. After this operation has been called, no further operations are_possible on the memory segment and will fail. The actual memory (heap or off-heap) will only_be released after this memory segment object has become garbage collected.;public void free() {_		_		_		address = addressLimit + 1__	};frees,this,memory,segment,after,this,operation,has,been,called,no,further,operations,are,possible,on,the,memory,segment,and,will,fail,the,actual,memory,heap,or,off,heap,will,only,be,released,after,this,memory,segment,object,has,become,garbage,collected;public,void,free,address,address,limit,1
MemorySegment -> public void free();1507315082;Frees this memory segment.__<p>After this operation has been called, no further operations are possible on the memory_segment and will fail. The actual memory (heap or off-heap) will only be released after this_memory segment object has become garbage collected.;public void free() {_		_		_		address = addressLimit + 1__	};frees,this,memory,segment,p,after,this,operation,has,been,called,no,further,operations,are,possible,on,the,memory,segment,and,will,fail,the,actual,memory,heap,or,off,heap,will,only,be,released,after,this,memory,segment,object,has,become,garbage,collected;public,void,free,address,address,limit,1
MemorySegment -> public void free();1509981552;Frees this memory segment.__<p>After this operation has been called, no further operations are possible on the memory_segment and will fail. The actual memory (heap or off-heap) will only be released after this_memory segment object has become garbage collected.;public void free() {_		_		_		address = addressLimit + 1__	};frees,this,memory,segment,p,after,this,operation,has,been,called,no,further,operations,are,possible,on,the,memory,segment,and,will,fail,the,actual,memory,heap,or,off,heap,will,only,be,released,after,this,memory,segment,object,has,become,garbage,collected;public,void,free,address,address,limit,1
MemorySegment -> public void free();1513874825;Frees this memory segment.__<p>After this operation has been called, no further operations are possible on the memory_segment and will fail. The actual memory (heap or off-heap) will only be released after this_memory segment object has become garbage collected.;public void free() {_		_		_		address = addressLimit + 1__	};frees,this,memory,segment,p,after,this,operation,has,been,called,no,further,operations,are,possible,on,the,memory,segment,and,will,fail,the,actual,memory,heap,or,off,heap,will,only,be,released,after,this,memory,segment,object,has,become,garbage,collected;public,void,free,address,address,limit,1
MemorySegment -> public void free();1516285456;Frees this memory segment.__<p>After this operation has been called, no further operations are possible on the memory_segment and will fail. The actual memory (heap or off-heap) will only be released after this_memory segment object has become garbage collected.;public void free() {_		_		_		address = addressLimit + 1__	};frees,this,memory,segment,p,after,this,operation,has,been,called,no,further,operations,are,possible,on,the,memory,segment,and,will,fail,the,actual,memory,heap,or,off,heap,will,only,be,released,after,this,memory,segment,object,has,become,garbage,collected;public,void,free,address,address,limit,1
MemorySegment -> public void free();1550507508;Frees this memory segment.__<p>After this operation has been called, no further operations are possible on the memory_segment and will fail. The actual memory (heap or off-heap) will only be released after this_memory segment object has become garbage collected.;public void free() {_		_		_		address = addressLimit + 1__	};frees,this,memory,segment,p,after,this,operation,has,been,called,no,further,operations,are,possible,on,the,memory,segment,and,will,fail,the,actual,memory,heap,or,off,heap,will,only,be,released,after,this,memory,segment,object,has,become,garbage,collected;public,void,free,address,address,limit,1
MemorySegment -> public void free();1550567875;Frees this memory segment.__<p>After this operation has been called, no further operations are possible on the memory_segment and will fail. The actual memory (heap or off-heap) will only be released after this_memory segment object has become garbage collected.;public void free() {_		_		_		address = addressLimit + 1__	};frees,this,memory,segment,p,after,this,operation,has,been,called,no,further,operations,are,possible,on,the,memory,segment,and,will,fail,the,actual,memory,heap,or,off,heap,will,only,be,released,after,this,memory,segment,object,has,become,garbage,collected;public,void,free,address,address,limit,1
MemorySegment -> public final long getLongBigEndian(int index);1405024514;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1405090423;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1411473593;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1418658367;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1421050512;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1441738685;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1446112342;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1455479358;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1474380620;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1507315082;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1509981552;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1513874825;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1516285456;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1550507508;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public final long getLongBigEndian(int index);1550567875;Reads a long integer value (64bit, 8 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final long getLongBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Long.reverseBytes(getLong(index))__		} else {_			return getLong(index)__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,long,get,long,big,endian,int,index,if,return,long,reverse,bytes,get,long,index,else,return,get,long,index
MemorySegment -> public ByteBuffer wrap(int offset, int length);1405024514;Wraps the chunk of the underlying memory located between <tt>offset<tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer._@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public ByteBuffer wrap(int offset, int length) {_		if (offset > this.memory.length || offset > this.memory.length - length) {_			throw new IndexOutOfBoundsException()__		}_		_		if (this.wrapper == null) {_			this.wrapper = ByteBuffer.wrap(this.memory, offset, length)__		}_		else {_			this.wrapper.position(offset)__			this.wrapper.limit(offset + length)__		}_		_		return this.wrapper__	};wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,byte,buffer,wrap,int,offset,int,length,if,offset,this,memory,length,offset,this,memory,length,length,throw,new,index,out,of,bounds,exception,if,this,wrapper,null,this,wrapper,byte,buffer,wrap,this,memory,offset,length,else,this,wrapper,position,offset,this,wrapper,limit,offset,length,return,this,wrapper
MemorySegment -> public ByteBuffer wrap(int offset, int length);1405090423;Wraps the chunk of the underlying memory located between <tt>offset<tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer._@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public ByteBuffer wrap(int offset, int length) {_		if (offset > this.memory.length || offset > this.memory.length - length) {_			throw new IndexOutOfBoundsException()__		}_		_		if (this.wrapper == null) {_			this.wrapper = ByteBuffer.wrap(this.memory, offset, length)__		}_		else {_			this.wrapper.position(offset)__			this.wrapper.limit(offset + length)__		}_		_		return this.wrapper__	};wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,byte,buffer,wrap,int,offset,int,length,if,offset,this,memory,length,offset,this,memory,length,length,throw,new,index,out,of,bounds,exception,if,this,wrapper,null,this,wrapper,byte,buffer,wrap,this,memory,offset,length,else,this,wrapper,position,offset,this,wrapper,limit,offset,length,return,this,wrapper
MemorySegment -> public ByteBuffer wrap(int offset, int length);1411473593;Wraps the chunk of the underlying memory located between <tt>offset<tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer._@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public ByteBuffer wrap(int offset, int length) {_		if (offset > this.memory.length || offset > this.memory.length - length) {_			throw new IndexOutOfBoundsException()__		}_		_		if (this.wrapper == null) {_			this.wrapper = ByteBuffer.wrap(this.memory, offset, length)__		}_		else {_			this.wrapper.position(offset)__			this.wrapper.limit(offset + length)__		}_		_		return this.wrapper__	};wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,byte,buffer,wrap,int,offset,int,length,if,offset,this,memory,length,offset,this,memory,length,length,throw,new,index,out,of,bounds,exception,if,this,wrapper,null,this,wrapper,byte,buffer,wrap,this,memory,offset,length,else,this,wrapper,position,offset,this,wrapper,limit,offset,length,return,this,wrapper
MemorySegment -> public ByteBuffer wrap(int offset, int length);1418658367;Wraps the chunk of the underlying memory located between <tt>offset<tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer._@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public ByteBuffer wrap(int offset, int length) {_		if (offset > this.memory.length || offset > this.memory.length - length) {_			throw new IndexOutOfBoundsException()__		}_		_		if (this.wrapper == null) {_			this.wrapper = ByteBuffer.wrap(this.memory, offset, length)__		}_		else {_			this.wrapper.limit(offset + length)__			this.wrapper.position(offset)__		}_		_		return this.wrapper__	};wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,byte,buffer,wrap,int,offset,int,length,if,offset,this,memory,length,offset,this,memory,length,length,throw,new,index,out,of,bounds,exception,if,this,wrapper,null,this,wrapper,byte,buffer,wrap,this,memory,offset,length,else,this,wrapper,limit,offset,length,this,wrapper,position,offset,return,this,wrapper
MemorySegment -> public ByteBuffer wrap(int offset, int length);1421050512;Wraps the chunk of the underlying memory located between <tt>offset<tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer._@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public ByteBuffer wrap(int offset, int length) {_		if (offset > this.memory.length || offset > this.memory.length - length) {_			throw new IndexOutOfBoundsException()__		}_		_		if (this.wrapper == null) {_			this.wrapper = ByteBuffer.wrap(this.memory, offset, length)__		}_		else {_			this.wrapper.limit(offset + length)__			this.wrapper.position(offset)__		}__		return this.wrapper__	};wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,byte,buffer,wrap,int,offset,int,length,if,offset,this,memory,length,offset,this,memory,length,length,throw,new,index,out,of,bounds,exception,if,this,wrapper,null,this,wrapper,byte,buffer,wrap,this,memory,offset,length,else,this,wrapper,limit,offset,length,this,wrapper,position,offset,return,this,wrapper
MemorySegment -> public final int compare(MemorySegment seg2, int offset1, int offset2, int len);1441738685;Compares two memory segment regions.__@param seg2 Segment to compare this segment with_@param offset1 Offset of this segment to start comparing_@param offset2 Offset of seg2 to start comparing_@param len Length of the compared memory region__@return 0 if equal, -1 if seg1 < seg2, 1 otherwise;public final int compare(MemorySegment seg2, int offset1, int offset2, int len) {_		while (len >= 8) {_			long l1 = this.getLongBigEndian(offset1)__			long l2 = seg2.getLongBigEndian(offset2)___			if (l1 != l2) {_				return (l1 < l2) ^ (l1 < 0) ^ (l2 < 0) ? -1 : 1__			}__			offset1 += 8__			offset2 += 8__			len -= 8__		}_		while (len > 0) {_			int b1 = this.get(offset1) & 0xff__			int b2 = seg2.get(offset2) & 0xff__			int cmp = b1 - b2__			if (cmp != 0) {_				return cmp__			}_			offset1++__			offset2++__			len--__		}_		return 0__	};compares,two,memory,segment,regions,param,seg2,segment,to,compare,this,segment,with,param,offset1,offset,of,this,segment,to,start,comparing,param,offset2,offset,of,seg2,to,start,comparing,param,len,length,of,the,compared,memory,region,return,0,if,equal,1,if,seg1,seg2,1,otherwise;public,final,int,compare,memory,segment,seg2,int,offset1,int,offset2,int,len,while,len,8,long,l1,this,get,long,big,endian,offset1,long,l2,seg2,get,long,big,endian,offset2,if,l1,l2,return,l1,l2,l1,0,l2,0,1,1,offset1,8,offset2,8,len,8,while,len,0,int,b1,this,get,offset1,0xff,int,b2,seg2,get,offset2,0xff,int,cmp,b1,b2,if,cmp,0,return,cmp,offset1,offset2,len,return,0
MemorySegment -> public final int compare(MemorySegment seg2, int offset1, int offset2, int len);1446112342;Compares two memory segment regions.__@param seg2 Segment to compare this segment with_@param offset1 Offset of this segment to start comparing_@param offset2 Offset of seg2 to start comparing_@param len Length of the compared memory region__@return 0 if equal, -1 if seg1 &lt_ seg2, 1 otherwise;public final int compare(MemorySegment seg2, int offset1, int offset2, int len) {_		while (len >= 8) {_			long l1 = this.getLongBigEndian(offset1)__			long l2 = seg2.getLongBigEndian(offset2)___			if (l1 != l2) {_				return (l1 < l2) ^ (l1 < 0) ^ (l2 < 0) ? -1 : 1__			}__			offset1 += 8__			offset2 += 8__			len -= 8__		}_		while (len > 0) {_			int b1 = this.get(offset1) & 0xff__			int b2 = seg2.get(offset2) & 0xff__			int cmp = b1 - b2__			if (cmp != 0) {_				return cmp__			}_			offset1++__			offset2++__			len--__		}_		return 0__	};compares,two,memory,segment,regions,param,seg2,segment,to,compare,this,segment,with,param,offset1,offset,of,this,segment,to,start,comparing,param,offset2,offset,of,seg2,to,start,comparing,param,len,length,of,the,compared,memory,region,return,0,if,equal,1,if,seg1,lt,seg2,1,otherwise;public,final,int,compare,memory,segment,seg2,int,offset1,int,offset2,int,len,while,len,8,long,l1,this,get,long,big,endian,offset1,long,l2,seg2,get,long,big,endian,offset2,if,l1,l2,return,l1,l2,l1,0,l2,0,1,1,offset1,8,offset2,8,len,8,while,len,0,int,b1,this,get,offset1,0xff,int,b2,seg2,get,offset2,0xff,int,cmp,b1,b2,if,cmp,0,return,cmp,offset1,offset2,len,return,0
MemorySegment -> public final int compare(MemorySegment seg2, int offset1, int offset2, int len);1455479358;Compares two memory segment regions.__@param seg2 Segment to compare this segment with_@param offset1 Offset of this segment to start comparing_@param offset2 Offset of seg2 to start comparing_@param len Length of the compared memory region__@return 0 if equal, -1 if seg1 &lt_ seg2, 1 otherwise;public final int compare(MemorySegment seg2, int offset1, int offset2, int len) {_		while (len >= 8) {_			long l1 = this.getLongBigEndian(offset1)__			long l2 = seg2.getLongBigEndian(offset2)___			if (l1 != l2) {_				return (l1 < l2) ^ (l1 < 0) ^ (l2 < 0) ? -1 : 1__			}__			offset1 += 8__			offset2 += 8__			len -= 8__		}_		while (len > 0) {_			int b1 = this.get(offset1) & 0xff__			int b2 = seg2.get(offset2) & 0xff__			int cmp = b1 - b2__			if (cmp != 0) {_				return cmp__			}_			offset1++__			offset2++__			len--__		}_		return 0__	};compares,two,memory,segment,regions,param,seg2,segment,to,compare,this,segment,with,param,offset1,offset,of,this,segment,to,start,comparing,param,offset2,offset,of,seg2,to,start,comparing,param,len,length,of,the,compared,memory,region,return,0,if,equal,1,if,seg1,lt,seg2,1,otherwise;public,final,int,compare,memory,segment,seg2,int,offset1,int,offset2,int,len,while,len,8,long,l1,this,get,long,big,endian,offset1,long,l2,seg2,get,long,big,endian,offset2,if,l1,l2,return,l1,l2,l1,0,l2,0,1,1,offset1,8,offset2,8,len,8,while,len,0,int,b1,this,get,offset1,0xff,int,b2,seg2,get,offset2,0xff,int,cmp,b1,b2,if,cmp,0,return,cmp,offset1,offset2,len,return,0
MemorySegment -> public final int compare(MemorySegment seg2, int offset1, int offset2, int len);1474380620;Compares two memory segment regions.__@param seg2 Segment to compare this segment with_@param offset1 Offset of this segment to start comparing_@param offset2 Offset of seg2 to start comparing_@param len Length of the compared memory region__@return 0 if equal, -1 if seg1 &lt_ seg2, 1 otherwise;public final int compare(MemorySegment seg2, int offset1, int offset2, int len) {_		while (len >= 8) {_			long l1 = this.getLongBigEndian(offset1)__			long l2 = seg2.getLongBigEndian(offset2)___			if (l1 != l2) {_				return (l1 < l2) ^ (l1 < 0) ^ (l2 < 0) ? -1 : 1__			}__			offset1 += 8__			offset2 += 8__			len -= 8__		}_		while (len > 0) {_			int b1 = this.get(offset1) & 0xff__			int b2 = seg2.get(offset2) & 0xff__			int cmp = b1 - b2__			if (cmp != 0) {_				return cmp__			}_			offset1++__			offset2++__			len--__		}_		return 0__	};compares,two,memory,segment,regions,param,seg2,segment,to,compare,this,segment,with,param,offset1,offset,of,this,segment,to,start,comparing,param,offset2,offset,of,seg2,to,start,comparing,param,len,length,of,the,compared,memory,region,return,0,if,equal,1,if,seg1,lt,seg2,1,otherwise;public,final,int,compare,memory,segment,seg2,int,offset1,int,offset2,int,len,while,len,8,long,l1,this,get,long,big,endian,offset1,long,l2,seg2,get,long,big,endian,offset2,if,l1,l2,return,l1,l2,l1,0,l2,0,1,1,offset1,8,offset2,8,len,8,while,len,0,int,b1,this,get,offset1,0xff,int,b2,seg2,get,offset2,0xff,int,cmp,b1,b2,if,cmp,0,return,cmp,offset1,offset2,len,return,0
MemorySegment -> public final int compare(MemorySegment seg2, int offset1, int offset2, int len);1507315082;Compares two memory segment regions.__@param seg2 Segment to compare this segment with_@param offset1 Offset of this segment to start comparing_@param offset2 Offset of seg2 to start comparing_@param len Length of the compared memory region__@return 0 if equal, -1 if seg1 &lt_ seg2, 1 otherwise;public final int compare(MemorySegment seg2, int offset1, int offset2, int len) {_		while (len >= 8) {_			long l1 = this.getLongBigEndian(offset1)__			long l2 = seg2.getLongBigEndian(offset2)___			if (l1 != l2) {_				return (l1 < l2) ^ (l1 < 0) ^ (l2 < 0) ? -1 : 1__			}__			offset1 += 8__			offset2 += 8__			len -= 8__		}_		while (len > 0) {_			int b1 = this.get(offset1) & 0xff__			int b2 = seg2.get(offset2) & 0xff__			int cmp = b1 - b2__			if (cmp != 0) {_				return cmp__			}_			offset1++__			offset2++__			len--__		}_		return 0__	};compares,two,memory,segment,regions,param,seg2,segment,to,compare,this,segment,with,param,offset1,offset,of,this,segment,to,start,comparing,param,offset2,offset,of,seg2,to,start,comparing,param,len,length,of,the,compared,memory,region,return,0,if,equal,1,if,seg1,lt,seg2,1,otherwise;public,final,int,compare,memory,segment,seg2,int,offset1,int,offset2,int,len,while,len,8,long,l1,this,get,long,big,endian,offset1,long,l2,seg2,get,long,big,endian,offset2,if,l1,l2,return,l1,l2,l1,0,l2,0,1,1,offset1,8,offset2,8,len,8,while,len,0,int,b1,this,get,offset1,0xff,int,b2,seg2,get,offset2,0xff,int,cmp,b1,b2,if,cmp,0,return,cmp,offset1,offset2,len,return,0
MemorySegment -> public final int compare(MemorySegment seg2, int offset1, int offset2, int len);1509981552;Compares two memory segment regions.__@param seg2 Segment to compare this segment with_@param offset1 Offset of this segment to start comparing_@param offset2 Offset of seg2 to start comparing_@param len Length of the compared memory region__@return 0 if equal, -1 if seg1 &lt_ seg2, 1 otherwise;public final int compare(MemorySegment seg2, int offset1, int offset2, int len) {_		while (len >= 8) {_			long l1 = this.getLongBigEndian(offset1)__			long l2 = seg2.getLongBigEndian(offset2)___			if (l1 != l2) {_				return (l1 < l2) ^ (l1 < 0) ^ (l2 < 0) ? -1 : 1__			}__			offset1 += 8__			offset2 += 8__			len -= 8__		}_		while (len > 0) {_			int b1 = this.get(offset1) & 0xff__			int b2 = seg2.get(offset2) & 0xff__			int cmp = b1 - b2__			if (cmp != 0) {_				return cmp__			}_			offset1++__			offset2++__			len--__		}_		return 0__	};compares,two,memory,segment,regions,param,seg2,segment,to,compare,this,segment,with,param,offset1,offset,of,this,segment,to,start,comparing,param,offset2,offset,of,seg2,to,start,comparing,param,len,length,of,the,compared,memory,region,return,0,if,equal,1,if,seg1,lt,seg2,1,otherwise;public,final,int,compare,memory,segment,seg2,int,offset1,int,offset2,int,len,while,len,8,long,l1,this,get,long,big,endian,offset1,long,l2,seg2,get,long,big,endian,offset2,if,l1,l2,return,l1,l2,l1,0,l2,0,1,1,offset1,8,offset2,8,len,8,while,len,0,int,b1,this,get,offset1,0xff,int,b2,seg2,get,offset2,0xff,int,cmp,b1,b2,if,cmp,0,return,cmp,offset1,offset2,len,return,0
MemorySegment -> public final int compare(MemorySegment seg2, int offset1, int offset2, int len);1513874825;Compares two memory segment regions.__@param seg2 Segment to compare this segment with_@param offset1 Offset of this segment to start comparing_@param offset2 Offset of seg2 to start comparing_@param len Length of the compared memory region__@return 0 if equal, -1 if seg1 &lt_ seg2, 1 otherwise;public final int compare(MemorySegment seg2, int offset1, int offset2, int len) {_		while (len >= 8) {_			long l1 = this.getLongBigEndian(offset1)__			long l2 = seg2.getLongBigEndian(offset2)___			if (l1 != l2) {_				return (l1 < l2) ^ (l1 < 0) ^ (l2 < 0) ? -1 : 1__			}__			offset1 += 8__			offset2 += 8__			len -= 8__		}_		while (len > 0) {_			int b1 = this.get(offset1) & 0xff__			int b2 = seg2.get(offset2) & 0xff__			int cmp = b1 - b2__			if (cmp != 0) {_				return cmp__			}_			offset1++__			offset2++__			len--__		}_		return 0__	};compares,two,memory,segment,regions,param,seg2,segment,to,compare,this,segment,with,param,offset1,offset,of,this,segment,to,start,comparing,param,offset2,offset,of,seg2,to,start,comparing,param,len,length,of,the,compared,memory,region,return,0,if,equal,1,if,seg1,lt,seg2,1,otherwise;public,final,int,compare,memory,segment,seg2,int,offset1,int,offset2,int,len,while,len,8,long,l1,this,get,long,big,endian,offset1,long,l2,seg2,get,long,big,endian,offset2,if,l1,l2,return,l1,l2,l1,0,l2,0,1,1,offset1,8,offset2,8,len,8,while,len,0,int,b1,this,get,offset1,0xff,int,b2,seg2,get,offset2,0xff,int,cmp,b1,b2,if,cmp,0,return,cmp,offset1,offset2,len,return,0
MemorySegment -> public final int compare(MemorySegment seg2, int offset1, int offset2, int len);1516285456;Compares two memory segment regions.__@param seg2 Segment to compare this segment with_@param offset1 Offset of this segment to start comparing_@param offset2 Offset of seg2 to start comparing_@param len Length of the compared memory region__@return 0 if equal, -1 if seg1 &lt_ seg2, 1 otherwise;public final int compare(MemorySegment seg2, int offset1, int offset2, int len) {_		while (len >= 8) {_			long l1 = this.getLongBigEndian(offset1)__			long l2 = seg2.getLongBigEndian(offset2)___			if (l1 != l2) {_				return (l1 < l2) ^ (l1 < 0) ^ (l2 < 0) ? -1 : 1__			}__			offset1 += 8__			offset2 += 8__			len -= 8__		}_		while (len > 0) {_			int b1 = this.get(offset1) & 0xff__			int b2 = seg2.get(offset2) & 0xff__			int cmp = b1 - b2__			if (cmp != 0) {_				return cmp__			}_			offset1++__			offset2++__			len--__		}_		return 0__	};compares,two,memory,segment,regions,param,seg2,segment,to,compare,this,segment,with,param,offset1,offset,of,this,segment,to,start,comparing,param,offset2,offset,of,seg2,to,start,comparing,param,len,length,of,the,compared,memory,region,return,0,if,equal,1,if,seg1,lt,seg2,1,otherwise;public,final,int,compare,memory,segment,seg2,int,offset1,int,offset2,int,len,while,len,8,long,l1,this,get,long,big,endian,offset1,long,l2,seg2,get,long,big,endian,offset2,if,l1,l2,return,l1,l2,l1,0,l2,0,1,1,offset1,8,offset2,8,len,8,while,len,0,int,b1,this,get,offset1,0xff,int,b2,seg2,get,offset2,0xff,int,cmp,b1,b2,if,cmp,0,return,cmp,offset1,offset2,len,return,0
MemorySegment -> public final int compare(MemorySegment seg2, int offset1, int offset2, int len);1550507508;Compares two memory segment regions.__@param seg2 Segment to compare this segment with_@param offset1 Offset of this segment to start comparing_@param offset2 Offset of seg2 to start comparing_@param len Length of the compared memory region__@return 0 if equal, -1 if seg1 &lt_ seg2, 1 otherwise;public final int compare(MemorySegment seg2, int offset1, int offset2, int len) {_		while (len >= 8) {_			long l1 = this.getLongBigEndian(offset1)__			long l2 = seg2.getLongBigEndian(offset2)___			if (l1 != l2) {_				return (l1 < l2) ^ (l1 < 0) ^ (l2 < 0) ? -1 : 1__			}__			offset1 += 8__			offset2 += 8__			len -= 8__		}_		while (len > 0) {_			int b1 = this.get(offset1) & 0xff__			int b2 = seg2.get(offset2) & 0xff__			int cmp = b1 - b2__			if (cmp != 0) {_				return cmp__			}_			offset1++__			offset2++__			len--__		}_		return 0__	};compares,two,memory,segment,regions,param,seg2,segment,to,compare,this,segment,with,param,offset1,offset,of,this,segment,to,start,comparing,param,offset2,offset,of,seg2,to,start,comparing,param,len,length,of,the,compared,memory,region,return,0,if,equal,1,if,seg1,lt,seg2,1,otherwise;public,final,int,compare,memory,segment,seg2,int,offset1,int,offset2,int,len,while,len,8,long,l1,this,get,long,big,endian,offset1,long,l2,seg2,get,long,big,endian,offset2,if,l1,l2,return,l1,l2,l1,0,l2,0,1,1,offset1,8,offset2,8,len,8,while,len,0,int,b1,this,get,offset1,0xff,int,b2,seg2,get,offset2,0xff,int,cmp,b1,b2,if,cmp,0,return,cmp,offset1,offset2,len,return,0
MemorySegment -> public final int compare(MemorySegment seg2, int offset1, int offset2, int len);1550567875;Compares two memory segment regions.__@param seg2 Segment to compare this segment with_@param offset1 Offset of this segment to start comparing_@param offset2 Offset of seg2 to start comparing_@param len Length of the compared memory region__@return 0 if equal, -1 if seg1 &lt_ seg2, 1 otherwise;public final int compare(MemorySegment seg2, int offset1, int offset2, int len) {_		while (len >= 8) {_			long l1 = this.getLongBigEndian(offset1)__			long l2 = seg2.getLongBigEndian(offset2)___			if (l1 != l2) {_				return (l1 < l2) ^ (l1 < 0) ^ (l2 < 0) ? -1 : 1__			}__			offset1 += 8__			offset2 += 8__			len -= 8__		}_		while (len > 0) {_			int b1 = this.get(offset1) & 0xff__			int b2 = seg2.get(offset2) & 0xff__			int cmp = b1 - b2__			if (cmp != 0) {_				return cmp__			}_			offset1++__			offset2++__			len--__		}_		return 0__	};compares,two,memory,segment,regions,param,seg2,segment,to,compare,this,segment,with,param,offset1,offset,of,this,segment,to,start,comparing,param,offset2,offset,of,seg2,to,start,comparing,param,len,length,of,the,compared,memory,region,return,0,if,equal,1,if,seg1,lt,seg2,1,otherwise;public,final,int,compare,memory,segment,seg2,int,offset1,int,offset2,int,len,while,len,8,long,l1,this,get,long,big,endian,offset1,long,l2,seg2,get,long,big,endian,offset2,if,l1,l2,return,l1,l2,l1,0,l2,0,1,1,offset1,8,offset2,8,len,8,while,len,0,int,b1,this,get,offset1,0xff,int,b2,seg2,get,offset2,0xff,int,cmp,b1,b2,if,cmp,0,return,cmp,offset1,offset2,len,return,0
MemorySegment -> public final void putChar(int index, char value);1405024514;Writes two memory containing the given char value, in the current byte_order, into this buffer at the given position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putChar(int index, char value) {_		this.memory[index    ] = (byte) (value >> 8)__		this.memory[index + 1] = (byte) value__	};writes,two,memory,containing,the,given,char,value,in,the,current,byte,order,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,int,index,char,value,this,memory,index,byte,value,8,this,memory,index,1,byte,value
MemorySegment -> public final void putChar(int index, char value);1405090423;Writes two memory containing the given char value, in the current byte_order, into this buffer at the given position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putChar(int index, char value) {_		this.memory[index    ] = (byte) (value >> 8)__		this.memory[index + 1] = (byte) value__	};writes,two,memory,containing,the,given,char,value,in,the,current,byte,order,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,int,index,char,value,this,memory,index,byte,value,8,this,memory,index,1,byte,value
MemorySegment -> public final void putChar(int index, char value);1411473593;Writes two memory containing the given char value, in the current byte_order, into this buffer at the given position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putChar(int index, char value) {_		this.memory[index    ] = (byte) (value >> 8)__		this.memory[index + 1] = (byte) value__	};writes,two,memory,containing,the,given,char,value,in,the,current,byte,order,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,int,index,char,value,this,memory,index,byte,value,8,this,memory,index,1,byte,value
MemorySegment -> public final void putChar(int index, char value);1418658367;Writes two memory containing the given char value, in the current byte_order, into this buffer at the given position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putChar(int index, char value) {_		this.memory[index    ] = (byte) (value >> 8)__		this.memory[index + 1] = (byte) value__	};writes,two,memory,containing,the,given,char,value,in,the,current,byte,order,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,int,index,char,value,this,memory,index,byte,value,8,this,memory,index,1,byte,value
MemorySegment -> public final void putChar(int index, char value);1421050512;Writes two memory containing the given char value, in the current byte_order, into this buffer at the given position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final void putChar(int index, char value) {_		this.memory[index    ] = (byte) (value >> 8)__		this.memory[index + 1] = (byte) value__	};writes,two,memory,containing,the,given,char,value,in,the,current,byte,order,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,int,index,char,value,this,memory,index,byte,value,8,this,memory,index,1,byte,value
MemorySegment -> @SuppressWarnings("restriction") 	public final int getInt(int index);1405024514;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;@SuppressWarnings("restriction")_	public final int getInt(int index) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 4) {_				return UNSAFE.getInt(this.memory, BASE_OFFSET + index)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			return UNSAFE.getInt(this.memory, BASE_OFFSET + index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;suppress,warnings,restriction,public,final,int,get,int,int,index,if,checked,if,index,0,index,this,memory,length,4,return,unsafe,get,int,this,memory,index,else,throw,new,index,out,of,bounds,exception,else,return,unsafe,get,int,this,memory,index
MemorySegment -> @SuppressWarnings("restriction") 	public final int getInt(int index);1405090423;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;@SuppressWarnings("restriction")_	public final int getInt(int index) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 4) {_				return UNSAFE.getInt(this.memory, BASE_OFFSET + index)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			return UNSAFE.getInt(this.memory, BASE_OFFSET + index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;suppress,warnings,restriction,public,final,int,get,int,int,index,if,checked,if,index,0,index,this,memory,length,4,return,unsafe,get,int,this,memory,index,else,throw,new,index,out,of,bounds,exception,else,return,unsafe,get,int,this,memory,index
MemorySegment -> @SuppressWarnings("restriction") 	public final int getInt(int index);1411473593;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;@SuppressWarnings("restriction")_	public final int getInt(int index) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 4) {_				return UNSAFE.getInt(this.memory, BASE_OFFSET + index)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			return UNSAFE.getInt(this.memory, BASE_OFFSET + index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;suppress,warnings,restriction,public,final,int,get,int,int,index,if,checked,if,index,0,index,this,memory,length,4,return,unsafe,get,int,this,memory,index,else,throw,new,index,out,of,bounds,exception,else,return,unsafe,get,int,this,memory,index
MemorySegment -> @SuppressWarnings("restriction") 	public final int getInt(int index);1418658367;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;@SuppressWarnings("restriction")_	public final int getInt(int index) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 4) {_				return UNSAFE.getInt(this.memory, BASE_OFFSET + index)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			return UNSAFE.getInt(this.memory, BASE_OFFSET + index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;suppress,warnings,restriction,public,final,int,get,int,int,index,if,checked,if,index,0,index,this,memory,length,4,return,unsafe,get,int,this,memory,index,else,throw,new,index,out,of,bounds,exception,else,return,unsafe,get,int,this,memory,index
MemorySegment -> @SuppressWarnings("restriction") 	public final int getInt(int index);1421050512;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;@SuppressWarnings("restriction")_	public final int getInt(int index) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 4) {_				return UNSAFE.getInt(this.memory, BASE_OFFSET + index)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			return UNSAFE.getInt(this.memory, BASE_OFFSET + index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;suppress,warnings,restriction,public,final,int,get,int,int,index,if,checked,if,index,0,index,this,memory,length,4,return,unsafe,get,int,this,memory,index,else,throw,new,index,out,of,bounds,exception,else,return,unsafe,get,int,this,memory,index
MemorySegment -> public final char getCharBigEndian(int index);1441738685;Reads an character value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Character.reverseBytes(getChar(index))__		} else {_			return getChar(index)__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,big,endian,int,index,if,return,character,reverse,bytes,get,char,index,else,return,get,char,index
MemorySegment -> public final char getCharBigEndian(int index);1446112342;Reads an character value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Character.reverseBytes(getChar(index))__		} else {_			return getChar(index)__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,big,endian,int,index,if,return,character,reverse,bytes,get,char,index,else,return,get,char,index
MemorySegment -> public final char getCharBigEndian(int index);1455479358;Reads an character value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Character.reverseBytes(getChar(index))__		} else {_			return getChar(index)__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,big,endian,int,index,if,return,character,reverse,bytes,get,char,index,else,return,get,char,index
MemorySegment -> public final char getCharBigEndian(int index);1474380620;Reads an character value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Character.reverseBytes(getChar(index))__		} else {_			return getChar(index)__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,big,endian,int,index,if,return,character,reverse,bytes,get,char,index,else,return,get,char,index
MemorySegment -> public final char getCharBigEndian(int index);1507315082;Reads an character value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Character.reverseBytes(getChar(index))__		} else {_			return getChar(index)__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,big,endian,int,index,if,return,character,reverse,bytes,get,char,index,else,return,get,char,index
MemorySegment -> public final char getCharBigEndian(int index);1509981552;Reads an character value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Character.reverseBytes(getChar(index))__		} else {_			return getChar(index)__		}_	};reads,an,character,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,big,endian,int,index,if,return,character,reverse,bytes,get,char,index,else,return,get,char,index
MemorySegment -> public final char getCharBigEndian(int index);1513874825;Reads a character value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Character.reverseBytes(getChar(index))__		} else {_			return getChar(index)__		}_	};reads,a,character,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,big,endian,int,index,if,return,character,reverse,bytes,get,char,index,else,return,get,char,index
MemorySegment -> public final char getCharBigEndian(int index);1516285456;Reads a character value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Character.reverseBytes(getChar(index))__		} else {_			return getChar(index)__		}_	};reads,a,character,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,big,endian,int,index,if,return,character,reverse,bytes,get,char,index,else,return,get,char,index
MemorySegment -> public final char getCharBigEndian(int index);1550507508;Reads a character value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final char getCharBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Character.reverseBytes(getChar(index))__		} else {_			return getChar(index)__		}_	};reads,a,character,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,big,endian,int,index,if,return,character,reverse,bytes,get,char,index,else,return,get,char,index
MemorySegment -> public final char getCharBigEndian(int index);1550567875;Reads a character value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getChar(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getChar(int)} is the preferable choice.__@param index The position from which the value will be read._@return The character value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment size minus 2.;public final char getCharBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Character.reverseBytes(getChar(index))__		} else {_			return getChar(index)__		}_	};reads,a,character,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,char,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,char,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,character,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;public,final,char,get,char,big,endian,int,index,if,return,character,reverse,bytes,get,char,index,else,return,get,char,index
MemorySegment -> @SuppressWarnings("restriction") 	public final void putLong(int index, long value);1405024514;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;@SuppressWarnings("restriction")_	public final void putLong(int index, long value) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 8) {_				UNSAFE.putLong(this.memory, BASE_OFFSET + index, value)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			UNSAFE.putLong(this.memory, BASE_OFFSET + index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;suppress,warnings,restriction,public,final,void,put,long,int,index,long,value,if,checked,if,index,0,index,this,memory,length,8,unsafe,put,long,this,memory,index,value,else,throw,new,index,out,of,bounds,exception,else,unsafe,put,long,this,memory,index,value
MemorySegment -> @SuppressWarnings("restriction") 	public final void putLong(int index, long value);1405090423;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;@SuppressWarnings("restriction")_	public final void putLong(int index, long value) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 8) {_				UNSAFE.putLong(this.memory, BASE_OFFSET + index, value)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			UNSAFE.putLong(this.memory, BASE_OFFSET + index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;suppress,warnings,restriction,public,final,void,put,long,int,index,long,value,if,checked,if,index,0,index,this,memory,length,8,unsafe,put,long,this,memory,index,value,else,throw,new,index,out,of,bounds,exception,else,unsafe,put,long,this,memory,index,value
MemorySegment -> @SuppressWarnings("restriction") 	public final void putLong(int index, long value);1411473593;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;@SuppressWarnings("restriction")_	public final void putLong(int index, long value) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 8) {_				UNSAFE.putLong(this.memory, BASE_OFFSET + index, value)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			UNSAFE.putLong(this.memory, BASE_OFFSET + index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;suppress,warnings,restriction,public,final,void,put,long,int,index,long,value,if,checked,if,index,0,index,this,memory,length,8,unsafe,put,long,this,memory,index,value,else,throw,new,index,out,of,bounds,exception,else,unsafe,put,long,this,memory,index,value
MemorySegment -> @SuppressWarnings("restriction") 	public final void putLong(int index, long value);1418658367;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;@SuppressWarnings("restriction")_	public final void putLong(int index, long value) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 8) {_				UNSAFE.putLong(this.memory, BASE_OFFSET + index, value)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			UNSAFE.putLong(this.memory, BASE_OFFSET + index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;suppress,warnings,restriction,public,final,void,put,long,int,index,long,value,if,checked,if,index,0,index,this,memory,length,8,unsafe,put,long,this,memory,index,value,else,throw,new,index,out,of,bounds,exception,else,unsafe,put,long,this,memory,index,value
MemorySegment -> @SuppressWarnings("restriction") 	public final void putLong(int index, long value);1421050512;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;@SuppressWarnings("restriction")_	public final void putLong(int index, long value) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 8) {_				UNSAFE.putLong(this.memory, BASE_OFFSET + index, value)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			UNSAFE.putLong(this.memory, BASE_OFFSET + index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;suppress,warnings,restriction,public,final,void,put,long,int,index,long,value,if,checked,if,index,0,index,this,memory,length,8,unsafe,put,long,this,memory,index,value,else,throw,new,index,out,of,bounds,exception,else,unsafe,put,long,this,memory,index,value
MemorySegment -> public boolean isOffHeap();1441738685;Checks whether this memory segment is backed by off-heap memory._@return True, if the memory segment is backed by off-heap memory, false if it is backed_by heap memory.;public boolean isOffHeap() {_		return heapMemory == null__	};checks,whether,this,memory,segment,is,backed,by,off,heap,memory,return,true,if,the,memory,segment,is,backed,by,off,heap,memory,false,if,it,is,backed,by,heap,memory;public,boolean,is,off,heap,return,heap,memory,null
MemorySegment -> public boolean isOffHeap();1446112342;Checks whether this memory segment is backed by off-heap memory._@return True, if the memory segment is backed by off-heap memory, false if it is backed_by heap memory.;public boolean isOffHeap() {_		return heapMemory == null__	};checks,whether,this,memory,segment,is,backed,by,off,heap,memory,return,true,if,the,memory,segment,is,backed,by,off,heap,memory,false,if,it,is,backed,by,heap,memory;public,boolean,is,off,heap,return,heap,memory,null
MemorySegment -> public boolean isOffHeap();1455479358;Checks whether this memory segment is backed by off-heap memory._@return True, if the memory segment is backed by off-heap memory, false if it is backed_by heap memory.;public boolean isOffHeap() {_		return heapMemory == null__	};checks,whether,this,memory,segment,is,backed,by,off,heap,memory,return,true,if,the,memory,segment,is,backed,by,off,heap,memory,false,if,it,is,backed,by,heap,memory;public,boolean,is,off,heap,return,heap,memory,null
MemorySegment -> public boolean isOffHeap();1474380620;Checks whether this memory segment is backed by off-heap memory._@return True, if the memory segment is backed by off-heap memory, false if it is backed_by heap memory.;public boolean isOffHeap() {_		return heapMemory == null__	};checks,whether,this,memory,segment,is,backed,by,off,heap,memory,return,true,if,the,memory,segment,is,backed,by,off,heap,memory,false,if,it,is,backed,by,heap,memory;public,boolean,is,off,heap,return,heap,memory,null
MemorySegment -> public boolean isOffHeap();1507315082;Checks whether this memory segment is backed by off-heap memory.__@return <tt>true</tt>, if the memory segment is backed by off-heap memory, <tt>false</tt> if_it is backed by heap memory.;public boolean isOffHeap() {_		return heapMemory == null__	};checks,whether,this,memory,segment,is,backed,by,off,heap,memory,return,tt,true,tt,if,the,memory,segment,is,backed,by,off,heap,memory,tt,false,tt,if,it,is,backed,by,heap,memory;public,boolean,is,off,heap,return,heap,memory,null
MemorySegment -> public boolean isOffHeap();1509981552;Checks whether this memory segment is backed by off-heap memory.__@return <tt>true</tt>, if the memory segment is backed by off-heap memory, <tt>false</tt> if_it is backed by heap memory.;public boolean isOffHeap() {_		return heapMemory == null__	};checks,whether,this,memory,segment,is,backed,by,off,heap,memory,return,tt,true,tt,if,the,memory,segment,is,backed,by,off,heap,memory,tt,false,tt,if,it,is,backed,by,heap,memory;public,boolean,is,off,heap,return,heap,memory,null
MemorySegment -> public boolean isOffHeap();1513874825;Checks whether this memory segment is backed by off-heap memory.__@return <tt>true</tt>, if the memory segment is backed by off-heap memory, <tt>false</tt> if_it is backed by heap memory.;public boolean isOffHeap() {_		return heapMemory == null__	};checks,whether,this,memory,segment,is,backed,by,off,heap,memory,return,tt,true,tt,if,the,memory,segment,is,backed,by,off,heap,memory,tt,false,tt,if,it,is,backed,by,heap,memory;public,boolean,is,off,heap,return,heap,memory,null
MemorySegment -> public boolean isOffHeap();1516285456;Checks whether this memory segment is backed by off-heap memory.__@return <tt>true</tt>, if the memory segment is backed by off-heap memory, <tt>false</tt> if_it is backed by heap memory.;public boolean isOffHeap() {_		return heapMemory == null__	};checks,whether,this,memory,segment,is,backed,by,off,heap,memory,return,tt,true,tt,if,the,memory,segment,is,backed,by,off,heap,memory,tt,false,tt,if,it,is,backed,by,heap,memory;public,boolean,is,off,heap,return,heap,memory,null
MemorySegment -> public boolean isOffHeap();1550507508;Checks whether this memory segment is backed by off-heap memory.__@return <tt>true</tt>, if the memory segment is backed by off-heap memory, <tt>false</tt> if_it is backed by heap memory.;public boolean isOffHeap() {_		return heapMemory == null__	};checks,whether,this,memory,segment,is,backed,by,off,heap,memory,return,tt,true,tt,if,the,memory,segment,is,backed,by,off,heap,memory,tt,false,tt,if,it,is,backed,by,heap,memory;public,boolean,is,off,heap,return,heap,memory,null
MemorySegment -> public boolean isOffHeap();1550567875;Checks whether this memory segment is backed by off-heap memory.__@return <tt>true</tt>, if the memory segment is backed by off-heap memory, <tt>false</tt> if_it is backed by heap memory.;public boolean isOffHeap() {_		return heapMemory == null__	};checks,whether,this,memory,segment,is,backed,by,off,heap,memory,return,tt,true,tt,if,the,memory,segment,is,backed,by,off,heap,memory,tt,false,tt,if,it,is,backed,by,heap,memory;public,boolean,is,off,heap,return,heap,memory,null
MemorySegment -> public final char getChar(int index);1405024514;Reads two memory at the given position, composing them into a char value_according to the current byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final char getChar(int index) {_		return (char) ( ((this.memory[index    ] & 0xff) << 8) | _						(this.memory[index + 1] & 0xff) )__	};reads,two,memory,at,the,given,position,composing,them,into,a,char,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,int,index,return,char,this,memory,index,0xff,8,this,memory,index,1,0xff
MemorySegment -> public final char getChar(int index);1405090423;Reads two memory at the given position, composing them into a char value_according to the current byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final char getChar(int index) {_		return (char) ( ((this.memory[index    ] & 0xff) << 8) | _						(this.memory[index + 1] & 0xff) )__	};reads,two,memory,at,the,given,position,composing,them,into,a,char,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,int,index,return,char,this,memory,index,0xff,8,this,memory,index,1,0xff
MemorySegment -> public final char getChar(int index);1411473593;Reads two memory at the given position, composing them into a char value_according to the current byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final char getChar(int index) {_		return (char) ( ((this.memory[index    ] & 0xff) << 8) | _						(this.memory[index + 1] & 0xff) )__	};reads,two,memory,at,the,given,position,composing,them,into,a,char,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,int,index,return,char,this,memory,index,0xff,8,this,memory,index,1,0xff
MemorySegment -> public final char getChar(int index);1418658367;Reads two memory at the given position, composing them into a char value_according to the current byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final char getChar(int index) {_		return (char) ( ((this.memory[index    ] & 0xff) << 8) | _						(this.memory[index + 1] & 0xff) )__	};reads,two,memory,at,the,given,position,composing,them,into,a,char,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,int,index,return,char,this,memory,index,0xff,8,this,memory,index,1,0xff
MemorySegment -> public final char getChar(int index);1421050512;Reads two memory at the given position, composing them into a char value_according to the current byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;public final char getChar(int index) {_		return (char) ( ((this.memory[index    ] & 0xff) << 8) | _						(this.memory[index + 1] & 0xff) )__	};reads,two,memory,at,the,given,position,composing,them,into,a,char,value,according,to,the,current,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,char,get,char,int,index,return,char,this,memory,index,0xff,8,this,memory,index,1,0xff
MemorySegment -> public final int getIntLittleEndian(int index);1405024514;Reads an int value (32bit, 4 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1405090423;Reads an int value (32bit, 4 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1411473593;Reads an int value (32bit, 4 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1418658367;Reads an int value (32bit, 4 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1421050512;Reads an int value (32bit, 4 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1441738685;Reads an int value (32bit, 4 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1446112342;Reads an int value (32bit, 4 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1455479358;Reads an int value (32bit, 4 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1474380620;Reads an int value (32bit, 4 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1507315082;Reads an int value (32bit, 4 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1509981552;Reads an int value (32bit, 4 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1513874825;Reads an int value (32bit, 4 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1516285456;Reads an int value (32bit, 4 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1550507508;Reads an int value (32bit, 4 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final int getIntLittleEndian(int index);1550567875;Reads an int value (32bit, 4 bytes) from the given position, in little-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 4.;public final int getIntLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getInt(index)__		} else {_			return Integer.reverseBytes(getInt(index))__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,4;public,final,int,get,int,little,endian,int,index,if,return,get,int,index,else,return,integer,reverse,bytes,get,int,index
MemorySegment -> public final void putCharLittleEndian(int index, char value);1441738685;Writes the given character (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharLittleEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, value)__		} else {_			putChar(index, Character.reverseBytes(value))__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,little,endian,int,index,char,value,if,put,char,index,value,else,put,char,index,character,reverse,bytes,value
MemorySegment -> public final void putCharLittleEndian(int index, char value);1446112342;Writes the given character (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharLittleEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, value)__		} else {_			putChar(index, Character.reverseBytes(value))__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,little,endian,int,index,char,value,if,put,char,index,value,else,put,char,index,character,reverse,bytes,value
MemorySegment -> public final void putCharLittleEndian(int index, char value);1455479358;Writes the given character (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharLittleEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, value)__		} else {_			putChar(index, Character.reverseBytes(value))__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,little,endian,int,index,char,value,if,put,char,index,value,else,put,char,index,character,reverse,bytes,value
MemorySegment -> public final void putCharLittleEndian(int index, char value);1474380620;Writes the given character (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharLittleEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, value)__		} else {_			putChar(index, Character.reverseBytes(value))__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,little,endian,int,index,char,value,if,put,char,index,value,else,put,char,index,character,reverse,bytes,value
MemorySegment -> public final void putCharLittleEndian(int index, char value);1507315082;Writes the given character (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharLittleEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, value)__		} else {_			putChar(index, Character.reverseBytes(value))__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,little,endian,int,index,char,value,if,put,char,index,value,else,put,char,index,character,reverse,bytes,value
MemorySegment -> public final void putCharLittleEndian(int index, char value);1509981552;Writes the given character (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharLittleEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, value)__		} else {_			putChar(index, Character.reverseBytes(value))__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,little,endian,int,index,char,value,if,put,char,index,value,else,put,char,index,character,reverse,bytes,value
MemorySegment -> public final void putCharLittleEndian(int index, char value);1513874825;Writes the given character (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharLittleEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, value)__		} else {_			putChar(index, Character.reverseBytes(value))__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,little,endian,int,index,char,value,if,put,char,index,value,else,put,char,index,character,reverse,bytes,value
MemorySegment -> public final void putCharLittleEndian(int index, char value);1516285456;Writes the given character (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharLittleEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, value)__		} else {_			putChar(index, Character.reverseBytes(value))__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,little,endian,int,index,char,value,if,put,char,index,value,else,put,char,index,character,reverse,bytes,value
MemorySegment -> public final void putCharLittleEndian(int index, char value);1550507508;Writes the given character (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putCharLittleEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, value)__		} else {_			putChar(index, Character.reverseBytes(value))__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,char,little,endian,int,index,char,value,if,put,char,index,value,else,put,char,index,character,reverse,bytes,value
MemorySegment -> public final void putCharLittleEndian(int index, char value);1550567875;Writes the given character (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putChar(int, char)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putChar(int, char)} is the preferable choice.__@param index The position at which the value will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment size minus 2.;public final void putCharLittleEndian(int index, char value) {_		if (LITTLE_ENDIAN) {_			putChar(index, value)__		} else {_			putChar(index, Character.reverseBytes(value))__		}_	};writes,the,given,character,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,char,int,char,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,char,int,char,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;public,final,void,put,char,little,endian,int,index,char,value,if,put,char,index,value,else,put,char,index,character,reverse,bytes,value
MemorySegment -> public final void putDouble(int index, double value);1405024514;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1405090423;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1411473593;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1418658367;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1421050512;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1441738685;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1446112342;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1455479358;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1474380620;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1507315082;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1509981552;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1513874825;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1516285456;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1550507508;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDouble(int index, double value);1550567875;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in the_system's native byte order. This method offers the best speed for double writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the memory will be written._@param value The double value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final void putDouble(int index, double value) {_		putLong(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,double,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,double,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,void,put,double,int,index,double,value,put,long,index,double,double,to,raw,long,bits,value
MemorySegment -> public abstract void put(int index, byte[] src)_;1441738685;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src)_;bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src
MemorySegment -> public abstract void put(int index, byte[] src)_;1446112342;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src)_;bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src
MemorySegment -> public abstract void put(int index, byte[] src)_;1455479358;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src)_;bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src
MemorySegment -> public abstract void put(int index, byte[] src)_;1474380620;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src)_;bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src
MemorySegment -> public abstract void put(int index, byte[] src)_;1507315082;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src)_;bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src
MemorySegment -> public abstract void put(int index, byte[] src)_;1509981552;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src)_;bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src
MemorySegment -> public abstract void put(int index, byte[] src)_;1513874825;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src)_;bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src
MemorySegment -> public abstract void put(int index, byte[] src)_;1516285456;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src)_;bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src
MemorySegment -> public abstract void put(int index, byte[] src)_;1550507508;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src)_;bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src
MemorySegment -> public abstract void put(int index, byte[] src)_;1550567875;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src)_;bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src
MemorySegment -> public final void putShortLittleEndian(int index, short value);1441738685;Writes the given short integer value (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortLittleEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, value)__		} else {_			putShort(index, Short.reverseBytes(value))__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,little,endian,int,index,short,value,if,put,short,index,value,else,put,short,index,short,reverse,bytes,value
MemorySegment -> public final void putShortLittleEndian(int index, short value);1446112342;Writes the given short integer value (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortLittleEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, value)__		} else {_			putShort(index, Short.reverseBytes(value))__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,little,endian,int,index,short,value,if,put,short,index,value,else,put,short,index,short,reverse,bytes,value
MemorySegment -> public final void putShortLittleEndian(int index, short value);1455479358;Writes the given short integer value (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortLittleEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, value)__		} else {_			putShort(index, Short.reverseBytes(value))__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,little,endian,int,index,short,value,if,put,short,index,value,else,put,short,index,short,reverse,bytes,value
MemorySegment -> public final void putShortLittleEndian(int index, short value);1474380620;Writes the given short integer value (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortLittleEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, value)__		} else {_			putShort(index, Short.reverseBytes(value))__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,little,endian,int,index,short,value,if,put,short,index,value,else,put,short,index,short,reverse,bytes,value
MemorySegment -> public final void putShortLittleEndian(int index, short value);1507315082;Writes the given short integer value (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortLittleEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, value)__		} else {_			putShort(index, Short.reverseBytes(value))__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,little,endian,int,index,short,value,if,put,short,index,value,else,put,short,index,short,reverse,bytes,value
MemorySegment -> public final void putShortLittleEndian(int index, short value);1509981552;Writes the given short integer value (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortLittleEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, value)__		} else {_			putShort(index, Short.reverseBytes(value))__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,little,endian,int,index,short,value,if,put,short,index,value,else,put,short,index,short,reverse,bytes,value
MemorySegment -> public final void putShortLittleEndian(int index, short value);1513874825;Writes the given short integer value (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortLittleEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, value)__		} else {_			putShort(index, Short.reverseBytes(value))__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,little,endian,int,index,short,value,if,put,short,index,value,else,put,short,index,short,reverse,bytes,value
MemorySegment -> public final void putShortLittleEndian(int index, short value);1516285456;Writes the given short integer value (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortLittleEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, value)__		} else {_			putShort(index, Short.reverseBytes(value))__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,little,endian,int,index,short,value,if,put,short,index,value,else,put,short,index,short,reverse,bytes,value
MemorySegment -> public final void putShortLittleEndian(int index, short value);1550507508;Writes the given short integer value (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortLittleEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, value)__		} else {_			putShort(index, Short.reverseBytes(value))__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,little,endian,int,index,short,value,if,put,short,index,value,else,put,short,index,short,reverse,bytes,value
MemorySegment -> public final void putShortLittleEndian(int index, short value);1550567875;Writes the given short integer value (16 bit, 2 bytes) to the given position in little-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment size minus 2.;public final void putShortLittleEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, value)__		} else {_			putShort(index, Short.reverseBytes(value))__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;public,final,void,put,short,little,endian,int,index,short,value,if,put,short,index,value,else,put,short,index,short,reverse,bytes,value
MemorySegment -> public final double getDoubleLittleEndian(int index);1405024514;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1405090423;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1411473593;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1418658367;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1421050512;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1441738685;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1446112342;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1455479358;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1474380620;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1507315082;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1509981552;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1513874825;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1516285456;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1550507508;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> public final double getDoubleLittleEndian(int index);1550567875;Reads a double-precision floating point value (64bit, 8 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getDouble(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getDouble(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final double getDoubleLittleEndian(int index) {_		return Double.longBitsToDouble(getLongLittleEndian(index))__	};reads,a,double,precision,floating,point,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,double,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,double,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,double,get,double,little,endian,int,index,return,double,long,bits,to,double,get,long,little,endian,index
MemorySegment -> @SuppressWarnings("restriction") 	public final char getChar(int index);1441738685;Reads a char value from the given position, in the system's native byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final char getChar(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getChar(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("This segment has been freed.")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,char,value,from,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,char,get,char,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,char,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,this,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final char getChar(int index);1446112342;Reads a char value from the given position, in the system's native byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final char getChar(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getChar(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("This segment has been freed.")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,char,value,from,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,char,get,char,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,char,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,this,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final char getChar(int index);1455479358;Reads a char value from the given position, in the system's native byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final char getChar(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getChar(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("This segment has been freed.")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,char,value,from,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,char,get,char,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,char,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,this,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final char getChar(int index);1474380620;Reads a char value from the given position, in the system's native byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final char getChar(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getChar(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("This segment has been freed.")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,char,value,from,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,char,get,char,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,char,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,this,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final char getChar(int index);1507315082;Reads a char value from the given position, in the system's native byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final char getChar(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getChar(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("This segment has been freed.")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,char,value,from,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,char,get,char,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,char,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,this,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final char getChar(int index);1509981552;Reads a char value from the given position, in the system's native byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final char getChar(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getChar(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("This segment has been freed.")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,char,value,from,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,char,get,char,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,char,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,this,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final char getChar(int index);1513874825;Reads a char value from the given position, in the system's native byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final char getChar(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getChar(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("This segment has been freed.")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,char,value,from,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,char,get,char,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,char,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,this,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final char getChar(int index);1516285456;Reads a char value from the given position, in the system's native byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final char getChar(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getChar(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("This segment has been freed.")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,char,value,from,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,char,get,char,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,char,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,this,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final char getChar(int index);1550507508;Reads a char value from the given position, in the system's native byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final char getChar(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getChar(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("This segment has been freed.")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,char,value,from,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,char,get,char,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,char,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,this,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final char getChar(int index);1550567875;Reads a char value from the given position, in the system's native byte order.__@param index The position from which the memory will be read._@return The char value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 2.;@SuppressWarnings("restriction")_	public final char getChar(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			return UNSAFE.getChar(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("This segment has been freed.")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,char,value,from,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,from,which,the,memory,will,be,read,return,the,char,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;suppress,warnings,restriction,public,final,char,get,char,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,2,return,unsafe,get,char,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,this,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final int getIntBigEndian(int index);1405024514;Reads an int value (32bit, 4 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1405090423;Reads an int value (32bit, 4 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1411473593;Reads an int value (32bit, 4 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1418658367;Reads an int value (32bit, 4 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1421050512;Reads an int value (32bit, 4 bytes) from the given position, in big endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1441738685;Reads an int value (32bit, 4 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1446112342;Reads an int value (32bit, 4 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1455479358;Reads an int value (32bit, 4 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1474380620;Reads an int value (32bit, 4 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1507315082;Reads an int value (32bit, 4 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1509981552;Reads an int value (32bit, 4 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1513874825;Reads an int value (32bit, 4 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1516285456;Reads an int value (32bit, 4 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1550507508;Reads an int value (32bit, 4 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final int getIntBigEndian(int index);1550567875;Reads an int value (32bit, 4 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getInt(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getInt(int)} is the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 4.;public final int getIntBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Integer.reverseBytes(getInt(index))__		} else {_			return getInt(index)__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,int,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,int,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,4;public,final,int,get,int,big,endian,int,index,if,return,integer,reverse,bytes,get,int,index,else,return,get,int,index
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1405024514;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1405090423;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1411473593;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1418658367;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1421050512;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1441738685;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1446112342;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1455479358;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1474380620;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1507315082;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1509981552;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1513874825;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1516285456;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1550507508;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public final void putDoubleLittleEndian(int index, double value);1550567875;Writes the given double-precision floating-point value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putDouble(int, double)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putDouble(int, double)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final void putDoubleLittleEndian(int index, double value) {_		putLongLittleEndian(index, Double.doubleToRawLongBits(value))__	};writes,the,given,double,precision,floating,point,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,double,int,double,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,double,int,double,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,void,put,double,little,endian,int,index,double,value,put,long,little,endian,index,double,double,to,raw,long,bits,value
MemorySegment -> public abstract void put(DataInput in, int offset, int length) throws IOException_;1441738685;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public abstract void put(DataInput in, int offset, int length) throws IOException_;bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,abstract,void,put,data,input,in,int,offset,int,length,throws,ioexception
MemorySegment -> public abstract void put(DataInput in, int offset, int length) throws IOException_;1446112342;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public abstract void put(DataInput in, int offset, int length) throws IOException_;bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,abstract,void,put,data,input,in,int,offset,int,length,throws,ioexception
MemorySegment -> public abstract void put(DataInput in, int offset, int length) throws IOException_;1455479358;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public abstract void put(DataInput in, int offset, int length) throws IOException_;bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,abstract,void,put,data,input,in,int,offset,int,length,throws,ioexception
MemorySegment -> public abstract void put(DataInput in, int offset, int length) throws IOException_;1474380620;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public abstract void put(DataInput in, int offset, int length) throws IOException_;bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,abstract,void,put,data,input,in,int,offset,int,length,throws,ioexception
MemorySegment -> public abstract void put(DataInput in, int offset, int length) throws IOException_;1507315082;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public abstract void put(DataInput in, int offset, int length) throws IOException_;bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,abstract,void,put,data,input,in,int,offset,int,length,throws,ioexception
MemorySegment -> public abstract void put(DataInput in, int offset, int length) throws IOException_;1509981552;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public abstract void put(DataInput in, int offset, int length) throws IOException_;bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,abstract,void,put,data,input,in,int,offset,int,length,throws,ioexception
MemorySegment -> public abstract void put(DataInput in, int offset, int length) throws IOException_;1513874825;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public abstract void put(DataInput in, int offset, int length) throws IOException_;bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,abstract,void,put,data,input,in,int,offset,int,length,throws,ioexception
MemorySegment -> public abstract void put(DataInput in, int offset, int length) throws IOException_;1516285456;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public abstract void put(DataInput in, int offset, int length) throws IOException_;bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,abstract,void,put,data,input,in,int,offset,int,length,throws,ioexception
MemorySegment -> public abstract void put(DataInput in, int offset, int length) throws IOException_;1550507508;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public abstract void put(DataInput in, int offset, int length) throws IOException_;bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,abstract,void,put,data,input,in,int,offset,int,length,throws,ioexception
MemorySegment -> public abstract void put(DataInput in, int offset, int length) throws IOException_;1550567875;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public abstract void put(DataInput in, int offset, int length) throws IOException_;bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,abstract,void,put,data,input,in,int,offset,int,length,throws,ioexception
MemorySegment -> public final void putShortBigEndian(int index, short value);1441738685;Writes the given short integer value (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortBigEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, Short.reverseBytes(value))__		} else {_			putShort(index, value)__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,big,endian,int,index,short,value,if,put,short,index,short,reverse,bytes,value,else,put,short,index,value
MemorySegment -> public final void putShortBigEndian(int index, short value);1446112342;Writes the given short integer value (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortBigEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, Short.reverseBytes(value))__		} else {_			putShort(index, value)__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,big,endian,int,index,short,value,if,put,short,index,short,reverse,bytes,value,else,put,short,index,value
MemorySegment -> public final void putShortBigEndian(int index, short value);1455479358;Writes the given short integer value (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortBigEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, Short.reverseBytes(value))__		} else {_			putShort(index, value)__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,big,endian,int,index,short,value,if,put,short,index,short,reverse,bytes,value,else,put,short,index,value
MemorySegment -> public final void putShortBigEndian(int index, short value);1474380620;Writes the given short integer value (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortBigEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, Short.reverseBytes(value))__		} else {_			putShort(index, value)__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,big,endian,int,index,short,value,if,put,short,index,short,reverse,bytes,value,else,put,short,index,value
MemorySegment -> public final void putShortBigEndian(int index, short value);1507315082;Writes the given short integer value (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortBigEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, Short.reverseBytes(value))__		} else {_			putShort(index, value)__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,big,endian,int,index,short,value,if,put,short,index,short,reverse,bytes,value,else,put,short,index,value
MemorySegment -> public final void putShortBigEndian(int index, short value);1509981552;Writes the given short integer value (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortBigEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, Short.reverseBytes(value))__		} else {_			putShort(index, value)__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,big,endian,int,index,short,value,if,put,short,index,short,reverse,bytes,value,else,put,short,index,value
MemorySegment -> public final void putShortBigEndian(int index, short value);1513874825;Writes the given short integer value (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortBigEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, Short.reverseBytes(value))__		} else {_			putShort(index, value)__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,big,endian,int,index,short,value,if,put,short,index,short,reverse,bytes,value,else,put,short,index,value
MemorySegment -> public final void putShortBigEndian(int index, short value);1516285456;Writes the given short integer value (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortBigEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, Short.reverseBytes(value))__		} else {_			putShort(index, value)__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,big,endian,int,index,short,value,if,put,short,index,short,reverse,bytes,value,else,put,short,index,value
MemorySegment -> public final void putShortBigEndian(int index, short value);1550507508;Writes the given short integer value (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final void putShortBigEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, Short.reverseBytes(value))__		} else {_			putShort(index, value)__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,void,put,short,big,endian,int,index,short,value,if,put,short,index,short,reverse,bytes,value,else,put,short,index,value
MemorySegment -> public final void putShortBigEndian(int index, short value);1550567875;Writes the given short integer value (16 bit, 2 bytes) to the given position in big-endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putShort(int, short)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putShort(int, short)} is the preferable choice.__@param index The position at which the value will be written._@param value The short value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment size minus 2.;public final void putShortBigEndian(int index, short value) {_		if (LITTLE_ENDIAN) {_			putShort(index, Short.reverseBytes(value))__		} else {_			putShort(index, value)__		}_	};writes,the,given,short,integer,value,16,bit,2,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,short,int,short,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,short,int,short,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,short,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;public,final,void,put,short,big,endian,int,index,short,value,if,put,short,index,short,reverse,bytes,value,else,put,short,index,value
MemorySegment -> public final long getLongLittleEndian(int index);1405024514;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1405090423;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1411473593;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1418658367;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1421050512;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1441738685;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1446112342;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1455479358;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1474380620;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1507315082;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1509981552;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1513874825;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1516285456;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1550507508;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public final long getLongLittleEndian(int index);1550567875;Reads a long integer value (64bit, 8 bytes) from the given position, in little endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getLong(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getLong(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final long getLongLittleEndian(int index) {_		if (LITTLE_ENDIAN) {_			return getLong(index)__		} else {_			return Long.reverseBytes(getLong(index))__		}_	};reads,a,long,integer,value,64bit,8,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,long,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,long,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,long,get,long,little,endian,int,index,if,return,get,long,index,else,return,long,reverse,bytes,get,long,index
MemorySegment -> public int size();1441738685;Gets the size of the memory segment, in bytes._@return The size of the memory segment.;public int size() {_		return size__	};gets,the,size,of,the,memory,segment,in,bytes,return,the,size,of,the,memory,segment;public,int,size,return,size
MemorySegment -> public int size();1446112342;Gets the size of the memory segment, in bytes._@return The size of the memory segment.;public int size() {_		return size__	};gets,the,size,of,the,memory,segment,in,bytes,return,the,size,of,the,memory,segment;public,int,size,return,size
MemorySegment -> public int size();1455479358;Gets the size of the memory segment, in bytes._@return The size of the memory segment.;public int size() {_		return size__	};gets,the,size,of,the,memory,segment,in,bytes,return,the,size,of,the,memory,segment;public,int,size,return,size
MemorySegment -> public int size();1474380620;Gets the size of the memory segment, in bytes._@return The size of the memory segment.;public int size() {_		return size__	};gets,the,size,of,the,memory,segment,in,bytes,return,the,size,of,the,memory,segment;public,int,size,return,size
MemorySegment -> public int size();1507315082;Gets the size of the memory segment, in bytes.__@return The size of the memory segment.;public int size() {_		return size__	};gets,the,size,of,the,memory,segment,in,bytes,return,the,size,of,the,memory,segment;public,int,size,return,size
MemorySegment -> public int size();1509981552;Gets the size of the memory segment, in bytes.__@return The size of the memory segment.;public int size() {_		return size__	};gets,the,size,of,the,memory,segment,in,bytes,return,the,size,of,the,memory,segment;public,int,size,return,size
MemorySegment -> public int size();1513874825;Gets the size of the memory segment, in bytes.__@return The size of the memory segment.;public int size() {_		return size__	};gets,the,size,of,the,memory,segment,in,bytes,return,the,size,of,the,memory,segment;public,int,size,return,size
MemorySegment -> public int size();1516285456;Gets the size of the memory segment, in bytes.__@return The size of the memory segment.;public int size() {_		return size__	};gets,the,size,of,the,memory,segment,in,bytes,return,the,size,of,the,memory,segment;public,int,size,return,size
MemorySegment -> public int size();1550507508;Gets the size of the memory segment, in bytes.__@return The size of the memory segment.;public int size() {_		return size__	};gets,the,size,of,the,memory,segment,in,bytes,return,the,size,of,the,memory,segment;public,int,size,return,size
MemorySegment -> public int size();1550567875;Gets the size of the memory segment, in bytes.__@return The size of the memory segment.;public int size() {_		return size__	};gets,the,size,of,the,memory,segment,in,bytes,return,the,size,of,the,memory,segment;public,int,size,return,size
MemorySegment -> public final void get(int offset, ByteBuffer target, int numBytes);1405024514;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes.;public final void get(int offset, ByteBuffer target, int numBytes) {_		_		target.put(this.memory, offset, numBytes)__	};bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes;public,final,void,get,int,offset,byte,buffer,target,int,num,bytes,target,put,this,memory,offset,num,bytes
MemorySegment -> public final void get(int offset, ByteBuffer target, int numBytes);1405090423;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes.;public final void get(int offset, ByteBuffer target, int numBytes) {_		_		target.put(this.memory, offset, numBytes)__	};bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes;public,final,void,get,int,offset,byte,buffer,target,int,num,bytes,target,put,this,memory,offset,num,bytes
MemorySegment -> public final void get(int offset, ByteBuffer target, int numBytes);1411473593;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes.;public final void get(int offset, ByteBuffer target, int numBytes) {_		_		target.put(this.memory, offset, numBytes)__	};bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes;public,final,void,get,int,offset,byte,buffer,target,int,num,bytes,target,put,this,memory,offset,num,bytes
MemorySegment -> public final void get(int offset, ByteBuffer target, int numBytes);1418658367;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes.;public final void get(int offset, ByteBuffer target, int numBytes) {_		_		target.put(this.memory, offset, numBytes)__	};bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes;public,final,void,get,int,offset,byte,buffer,target,int,num,bytes,target,put,this,memory,offset,num,bytes
MemorySegment -> public final void get(int offset, ByteBuffer target, int numBytes);1421050512;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes.;public final void get(int offset, ByteBuffer target, int numBytes) {_		_		target.put(this.memory, offset, numBytes)__	};bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes;public,final,void,get,int,offset,byte,buffer,target,int,num,bytes,target,put,this,memory,offset,num,bytes
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1405024514;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		_		System.arraycopy(this.memory, offset, target.memory, targetOffset, numBytes)__	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,system,arraycopy,this,memory,offset,target,memory,target,offset,num,bytes
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1405090423;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		_		System.arraycopy(this.memory, offset, target.memory, targetOffset, numBytes)__	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,system,arraycopy,this,memory,offset,target,memory,target,offset,num,bytes
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1411473593;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		_		System.arraycopy(this.memory, offset, target.memory, targetOffset, numBytes)__	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,system,arraycopy,this,memory,offset,target,memory,target,offset,num,bytes
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1418658367;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		_		System.arraycopy(this.memory, offset, target.memory, targetOffset, numBytes)__	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,system,arraycopy,this,memory,offset,target,memory,target,offset,num,bytes
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1421050512;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		_		System.arraycopy(this.memory, offset, target.memory, targetOffset, numBytes)__	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,system,arraycopy,this,memory,offset,target,memory,target,offset,num,bytes
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1441738685;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		final byte[] thisHeapRef = this.heapMemory__		final byte[] otherHeapRef = target.heapMemory__		final long thisPointer = this.address + offset__		final long otherPointer = target.address + targetOffset___		if ( (numBytes | offset | targetOffset) >= 0 &&_				thisPointer <= this.addressLimit - numBytes && otherPointer <= target.addressLimit - numBytes)_		{_			UNSAFE.copyMemory(thisHeapRef, thisPointer, otherHeapRef, otherPointer, numBytes)__		}_		else if (this.address > this.addressLimit) {_			throw new IllegalStateException("this memory segment has been freed.")__		}_		else if (target.address > target.addressLimit) {_			throw new IllegalStateException("target memory segment has been freed.")__		}_		else {_			throw new IndexOutOfBoundsException(_					String.format("offset=%d, targetOffset=%d, numBytes=%d, address=%d, targetAddress=%d",_					offset, targetOffset, numBytes, this.address, target.address))__		}_	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,final,byte,this,heap,ref,this,heap,memory,final,byte,other,heap,ref,target,heap,memory,final,long,this,pointer,this,address,offset,final,long,other,pointer,target,address,target,offset,if,num,bytes,offset,target,offset,0,this,pointer,this,address,limit,num,bytes,other,pointer,target,address,limit,num,bytes,unsafe,copy,memory,this,heap,ref,this,pointer,other,heap,ref,other,pointer,num,bytes,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,target,address,target,address,limit,throw,new,illegal,state,exception,target,memory,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception,string,format,offset,d,target,offset,d,num,bytes,d,address,d,target,address,d,offset,target,offset,num,bytes,this,address,target,address
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1446112342;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		final byte[] thisHeapRef = this.heapMemory__		final byte[] otherHeapRef = target.heapMemory__		final long thisPointer = this.address + offset__		final long otherPointer = target.address + targetOffset___		if ( (numBytes | offset | targetOffset) >= 0 &&_				thisPointer <= this.addressLimit - numBytes && otherPointer <= target.addressLimit - numBytes)_		{_			UNSAFE.copyMemory(thisHeapRef, thisPointer, otherHeapRef, otherPointer, numBytes)__		}_		else if (this.address > this.addressLimit) {_			throw new IllegalStateException("this memory segment has been freed.")__		}_		else if (target.address > target.addressLimit) {_			throw new IllegalStateException("target memory segment has been freed.")__		}_		else {_			throw new IndexOutOfBoundsException(_					String.format("offset=%d, targetOffset=%d, numBytes=%d, address=%d, targetAddress=%d",_					offset, targetOffset, numBytes, this.address, target.address))__		}_	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,final,byte,this,heap,ref,this,heap,memory,final,byte,other,heap,ref,target,heap,memory,final,long,this,pointer,this,address,offset,final,long,other,pointer,target,address,target,offset,if,num,bytes,offset,target,offset,0,this,pointer,this,address,limit,num,bytes,other,pointer,target,address,limit,num,bytes,unsafe,copy,memory,this,heap,ref,this,pointer,other,heap,ref,other,pointer,num,bytes,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,target,address,target,address,limit,throw,new,illegal,state,exception,target,memory,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception,string,format,offset,d,target,offset,d,num,bytes,d,address,d,target,address,d,offset,target,offset,num,bytes,this,address,target,address
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1455479358;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		final byte[] thisHeapRef = this.heapMemory__		final byte[] otherHeapRef = target.heapMemory__		final long thisPointer = this.address + offset__		final long otherPointer = target.address + targetOffset___		if ( (numBytes | offset | targetOffset) >= 0 &&_				thisPointer <= this.addressLimit - numBytes && otherPointer <= target.addressLimit - numBytes)_		{_			UNSAFE.copyMemory(thisHeapRef, thisPointer, otherHeapRef, otherPointer, numBytes)__		}_		else if (this.address > this.addressLimit) {_			throw new IllegalStateException("this memory segment has been freed.")__		}_		else if (target.address > target.addressLimit) {_			throw new IllegalStateException("target memory segment has been freed.")__		}_		else {_			throw new IndexOutOfBoundsException(_					String.format("offset=%d, targetOffset=%d, numBytes=%d, address=%d, targetAddress=%d",_					offset, targetOffset, numBytes, this.address, target.address))__		}_	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,final,byte,this,heap,ref,this,heap,memory,final,byte,other,heap,ref,target,heap,memory,final,long,this,pointer,this,address,offset,final,long,other,pointer,target,address,target,offset,if,num,bytes,offset,target,offset,0,this,pointer,this,address,limit,num,bytes,other,pointer,target,address,limit,num,bytes,unsafe,copy,memory,this,heap,ref,this,pointer,other,heap,ref,other,pointer,num,bytes,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,target,address,target,address,limit,throw,new,illegal,state,exception,target,memory,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception,string,format,offset,d,target,offset,d,num,bytes,d,address,d,target,address,d,offset,target,offset,num,bytes,this,address,target,address
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1474380620;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		final byte[] thisHeapRef = this.heapMemory__		final byte[] otherHeapRef = target.heapMemory__		final long thisPointer = this.address + offset__		final long otherPointer = target.address + targetOffset___		if ( (numBytes | offset | targetOffset) >= 0 &&_				thisPointer <= this.addressLimit - numBytes && otherPointer <= target.addressLimit - numBytes)_		{_			UNSAFE.copyMemory(thisHeapRef, thisPointer, otherHeapRef, otherPointer, numBytes)__		}_		else if (this.address > this.addressLimit) {_			throw new IllegalStateException("this memory segment has been freed.")__		}_		else if (target.address > target.addressLimit) {_			throw new IllegalStateException("target memory segment has been freed.")__		}_		else {_			throw new IndexOutOfBoundsException(_					String.format("offset=%d, targetOffset=%d, numBytes=%d, address=%d, targetAddress=%d",_					offset, targetOffset, numBytes, this.address, target.address))__		}_	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,final,byte,this,heap,ref,this,heap,memory,final,byte,other,heap,ref,target,heap,memory,final,long,this,pointer,this,address,offset,final,long,other,pointer,target,address,target,offset,if,num,bytes,offset,target,offset,0,this,pointer,this,address,limit,num,bytes,other,pointer,target,address,limit,num,bytes,unsafe,copy,memory,this,heap,ref,this,pointer,other,heap,ref,other,pointer,num,bytes,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,target,address,target,address,limit,throw,new,illegal,state,exception,target,memory,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception,string,format,offset,d,target,offset,d,num,bytes,d,address,d,target,address,d,offset,target,offset,num,bytes,this,address,target,address
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1507315082;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		final byte[] thisHeapRef = this.heapMemory__		final byte[] otherHeapRef = target.heapMemory__		final long thisPointer = this.address + offset__		final long otherPointer = target.address + targetOffset___		if ((numBytes | offset | targetOffset) >= 0 &&_				thisPointer <= this.addressLimit - numBytes && otherPointer <= target.addressLimit - numBytes) {_			UNSAFE.copyMemory(thisHeapRef, thisPointer, otherHeapRef, otherPointer, numBytes)__		}_		else if (this.address > this.addressLimit) {_			throw new IllegalStateException("this memory segment has been freed.")__		}_		else if (target.address > target.addressLimit) {_			throw new IllegalStateException("target memory segment has been freed.")__		}_		else {_			throw new IndexOutOfBoundsException(_					String.format("offset=%d, targetOffset=%d, numBytes=%d, address=%d, targetAddress=%d",_					offset, targetOffset, numBytes, this.address, target.address))__		}_	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,final,byte,this,heap,ref,this,heap,memory,final,byte,other,heap,ref,target,heap,memory,final,long,this,pointer,this,address,offset,final,long,other,pointer,target,address,target,offset,if,num,bytes,offset,target,offset,0,this,pointer,this,address,limit,num,bytes,other,pointer,target,address,limit,num,bytes,unsafe,copy,memory,this,heap,ref,this,pointer,other,heap,ref,other,pointer,num,bytes,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,target,address,target,address,limit,throw,new,illegal,state,exception,target,memory,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception,string,format,offset,d,target,offset,d,num,bytes,d,address,d,target,address,d,offset,target,offset,num,bytes,this,address,target,address
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1509981552;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		final byte[] thisHeapRef = this.heapMemory__		final byte[] otherHeapRef = target.heapMemory__		final long thisPointer = this.address + offset__		final long otherPointer = target.address + targetOffset___		if ((numBytes | offset | targetOffset) >= 0 &&_				thisPointer <= this.addressLimit - numBytes && otherPointer <= target.addressLimit - numBytes) {_			UNSAFE.copyMemory(thisHeapRef, thisPointer, otherHeapRef, otherPointer, numBytes)__		}_		else if (this.address > this.addressLimit) {_			throw new IllegalStateException("this memory segment has been freed.")__		}_		else if (target.address > target.addressLimit) {_			throw new IllegalStateException("target memory segment has been freed.")__		}_		else {_			throw new IndexOutOfBoundsException(_					String.format("offset=%d, targetOffset=%d, numBytes=%d, address=%d, targetAddress=%d",_					offset, targetOffset, numBytes, this.address, target.address))__		}_	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,final,byte,this,heap,ref,this,heap,memory,final,byte,other,heap,ref,target,heap,memory,final,long,this,pointer,this,address,offset,final,long,other,pointer,target,address,target,offset,if,num,bytes,offset,target,offset,0,this,pointer,this,address,limit,num,bytes,other,pointer,target,address,limit,num,bytes,unsafe,copy,memory,this,heap,ref,this,pointer,other,heap,ref,other,pointer,num,bytes,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,target,address,target,address,limit,throw,new,illegal,state,exception,target,memory,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception,string,format,offset,d,target,offset,d,num,bytes,d,address,d,target,address,d,offset,target,offset,num,bytes,this,address,target,address
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1513874825;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		final byte[] thisHeapRef = this.heapMemory__		final byte[] otherHeapRef = target.heapMemory__		final long thisPointer = this.address + offset__		final long otherPointer = target.address + targetOffset___		if ((numBytes | offset | targetOffset) >= 0 &&_				thisPointer <= this.addressLimit - numBytes && otherPointer <= target.addressLimit - numBytes) {_			UNSAFE.copyMemory(thisHeapRef, thisPointer, otherHeapRef, otherPointer, numBytes)__		}_		else if (this.address > this.addressLimit) {_			throw new IllegalStateException("this memory segment has been freed.")__		}_		else if (target.address > target.addressLimit) {_			throw new IllegalStateException("target memory segment has been freed.")__		}_		else {_			throw new IndexOutOfBoundsException(_					String.format("offset=%d, targetOffset=%d, numBytes=%d, address=%d, targetAddress=%d",_					offset, targetOffset, numBytes, this.address, target.address))__		}_	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,final,byte,this,heap,ref,this,heap,memory,final,byte,other,heap,ref,target,heap,memory,final,long,this,pointer,this,address,offset,final,long,other,pointer,target,address,target,offset,if,num,bytes,offset,target,offset,0,this,pointer,this,address,limit,num,bytes,other,pointer,target,address,limit,num,bytes,unsafe,copy,memory,this,heap,ref,this,pointer,other,heap,ref,other,pointer,num,bytes,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,target,address,target,address,limit,throw,new,illegal,state,exception,target,memory,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception,string,format,offset,d,target,offset,d,num,bytes,d,address,d,target,address,d,offset,target,offset,num,bytes,this,address,target,address
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1516285456;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		final byte[] thisHeapRef = this.heapMemory__		final byte[] otherHeapRef = target.heapMemory__		final long thisPointer = this.address + offset__		final long otherPointer = target.address + targetOffset___		if ((numBytes | offset | targetOffset) >= 0 &&_				thisPointer <= this.addressLimit - numBytes && otherPointer <= target.addressLimit - numBytes) {_			UNSAFE.copyMemory(thisHeapRef, thisPointer, otherHeapRef, otherPointer, numBytes)__		}_		else if (this.address > this.addressLimit) {_			throw new IllegalStateException("this memory segment has been freed.")__		}_		else if (target.address > target.addressLimit) {_			throw new IllegalStateException("target memory segment has been freed.")__		}_		else {_			throw new IndexOutOfBoundsException(_					String.format("offset=%d, targetOffset=%d, numBytes=%d, address=%d, targetAddress=%d",_					offset, targetOffset, numBytes, this.address, target.address))__		}_	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,final,byte,this,heap,ref,this,heap,memory,final,byte,other,heap,ref,target,heap,memory,final,long,this,pointer,this,address,offset,final,long,other,pointer,target,address,target,offset,if,num,bytes,offset,target,offset,0,this,pointer,this,address,limit,num,bytes,other,pointer,target,address,limit,num,bytes,unsafe,copy,memory,this,heap,ref,this,pointer,other,heap,ref,other,pointer,num,bytes,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,target,address,target,address,limit,throw,new,illegal,state,exception,target,memory,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception,string,format,offset,d,target,offset,d,num,bytes,d,address,d,target,address,d,offset,target,offset,num,bytes,this,address,target,address
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1550507508;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		final byte[] thisHeapRef = this.heapMemory__		final byte[] otherHeapRef = target.heapMemory__		final long thisPointer = this.address + offset__		final long otherPointer = target.address + targetOffset___		if ((numBytes | offset | targetOffset) >= 0 &&_				thisPointer <= this.addressLimit - numBytes && otherPointer <= target.addressLimit - numBytes) {_			UNSAFE.copyMemory(thisHeapRef, thisPointer, otherHeapRef, otherPointer, numBytes)__		}_		else if (this.address > this.addressLimit) {_			throw new IllegalStateException("this memory segment has been freed.")__		}_		else if (target.address > target.addressLimit) {_			throw new IllegalStateException("target memory segment has been freed.")__		}_		else {_			throw new IndexOutOfBoundsException(_					String.format("offset=%d, targetOffset=%d, numBytes=%d, address=%d, targetAddress=%d",_					offset, targetOffset, numBytes, this.address, target.address))__		}_	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,final,byte,this,heap,ref,this,heap,memory,final,byte,other,heap,ref,target,heap,memory,final,long,this,pointer,this,address,offset,final,long,other,pointer,target,address,target,offset,if,num,bytes,offset,target,offset,0,this,pointer,this,address,limit,num,bytes,other,pointer,target,address,limit,num,bytes,unsafe,copy,memory,this,heap,ref,this,pointer,other,heap,ref,other,pointer,num,bytes,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,target,address,target,address,limit,throw,new,illegal,state,exception,target,memory,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception,string,format,offset,d,target,offset,d,num,bytes,d,address,d,target,address,d,offset,target,offset,num,bytes,this,address,target,address
MemorySegment -> public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes);1550567875;Bulk copy method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target memory segment. The bytes will be put into the target segment_starting at position {@code targetOffset}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The memory segment to copy the bytes to._@param targetOffset The position in the target memory segment to copy the chunk to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If either of the offsets is invalid, or the source segment does not_contain the given number of bytes (starting from offset), or the target segment does_not have enough space for the bytes (counting from targetOffset).;public final void copyTo(int offset, MemorySegment target, int targetOffset, int numBytes) {_		final byte[] thisHeapRef = this.heapMemory__		final byte[] otherHeapRef = target.heapMemory__		final long thisPointer = this.address + offset__		final long otherPointer = target.address + targetOffset___		if ((numBytes | offset | targetOffset) >= 0 &&_				thisPointer <= this.addressLimit - numBytes && otherPointer <= target.addressLimit - numBytes) {_			UNSAFE.copyMemory(thisHeapRef, thisPointer, otherHeapRef, otherPointer, numBytes)__		}_		else if (this.address > this.addressLimit) {_			throw new IllegalStateException("this memory segment has been freed.")__		}_		else if (target.address > target.addressLimit) {_			throw new IllegalStateException("target memory segment has been freed.")__		}_		else {_			throw new IndexOutOfBoundsException(_					String.format("offset=%d, targetOffset=%d, numBytes=%d, address=%d, targetAddress=%d",_					offset, targetOffset, numBytes, this.address, target.address))__		}_	};bulk,copy,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,memory,segment,the,bytes,will,be,put,into,the,target,segment,starting,at,position,code,target,offset,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,memory,segment,to,copy,the,bytes,to,param,target,offset,the,position,in,the,target,memory,segment,to,copy,the,chunk,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,either,of,the,offsets,is,invalid,or,the,source,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,segment,does,not,have,enough,space,for,the,bytes,counting,from,target,offset;public,final,void,copy,to,int,offset,memory,segment,target,int,target,offset,int,num,bytes,final,byte,this,heap,ref,this,heap,memory,final,byte,other,heap,ref,target,heap,memory,final,long,this,pointer,this,address,offset,final,long,other,pointer,target,address,target,offset,if,num,bytes,offset,target,offset,0,this,pointer,this,address,limit,num,bytes,other,pointer,target,address,limit,num,bytes,unsafe,copy,memory,this,heap,ref,this,pointer,other,heap,ref,other,pointer,num,bytes,else,if,this,address,this,address,limit,throw,new,illegal,state,exception,this,memory,segment,has,been,freed,else,if,target,address,target,address,limit,throw,new,illegal,state,exception,target,memory,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception,string,format,offset,d,target,offset,d,num,bytes,d,address,d,target,address,d,offset,target,offset,num,bytes,this,address,target,address
MemorySegment -> public final void put(int index, byte b);1405024514;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public final void put(int index, byte b) {_		this.memory[index] = b__	};writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,final,void,put,int,index,byte,b,this,memory,index,b
MemorySegment -> public final void put(int index, byte b);1405090423;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public final void put(int index, byte b) {_		this.memory[index] = b__	};writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,final,void,put,int,index,byte,b,this,memory,index,b
MemorySegment -> public final void put(int index, byte b);1411473593;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public final void put(int index, byte b) {_		this.memory[index] = b__	};writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,final,void,put,int,index,byte,b,this,memory,index,b
MemorySegment -> public final void put(int index, byte b);1418658367;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public final void put(int index, byte b) {_		this.memory[index] = b__	};writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,final,void,put,int,index,byte,b,this,memory,index,b
MemorySegment -> public final void put(int index, byte b);1421050512;Writes the given byte into this buffer at the given position.__@param index The index at which the byte will be written._@param b The byte value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger or equal to the size of_the memory segment.;public final void put(int index, byte b) {_		this.memory[index] = b__	};writes,the,given,byte,into,this,buffer,at,the,given,position,param,index,the,index,at,which,the,byte,will,be,written,param,b,the,byte,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,or,equal,to,the,size,of,the,memory,segment;public,final,void,put,int,index,byte,b,this,memory,index,b
MemorySegment -> public final float getFloatLittleEndian(int index);1405024514;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1405090423;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1411473593;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1418658367;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1421050512;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1441738685;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1446112342;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1455479358;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1474380620;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1507315082;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1509981552;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1513874825;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1516285456;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1550507508;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public final float getFloatLittleEndian(int index);1550567875;Reads a single-precision floating point value (32bit, 4 bytes) from the given position, in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getFloat(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getFloat(int)} is the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final float getFloatLittleEndian(int index) {_		return Float.intBitsToFloat(getIntLittleEndian(index))__	};reads,a,single,precision,floating,point,value,32bit,4,bytes,from,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,float,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,float,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,float,get,float,little,endian,int,index,return,float,int,bits,to,float,get,int,little,endian,index
MemorySegment -> public Object getOwner();1441738685;Gets the owner of this memory segment. Returns null, if the owner was not set._@return The owner of the memory segment, or null, if it does not have an owner.;public Object getOwner() {_		return owner__	};gets,the,owner,of,this,memory,segment,returns,null,if,the,owner,was,not,set,return,the,owner,of,the,memory,segment,or,null,if,it,does,not,have,an,owner;public,object,get,owner,return,owner
MemorySegment -> public Object getOwner();1446112342;Gets the owner of this memory segment. Returns null, if the owner was not set._@return The owner of the memory segment, or null, if it does not have an owner.;public Object getOwner() {_		return owner__	};gets,the,owner,of,this,memory,segment,returns,null,if,the,owner,was,not,set,return,the,owner,of,the,memory,segment,or,null,if,it,does,not,have,an,owner;public,object,get,owner,return,owner
MemorySegment -> public Object getOwner();1455479358;Gets the owner of this memory segment. Returns null, if the owner was not set._@return The owner of the memory segment, or null, if it does not have an owner.;public Object getOwner() {_		return owner__	};gets,the,owner,of,this,memory,segment,returns,null,if,the,owner,was,not,set,return,the,owner,of,the,memory,segment,or,null,if,it,does,not,have,an,owner;public,object,get,owner,return,owner
MemorySegment -> public Object getOwner();1474380620;Gets the owner of this memory segment. Returns null, if the owner was not set._@return The owner of the memory segment, or null, if it does not have an owner.;public Object getOwner() {_		return owner__	};gets,the,owner,of,this,memory,segment,returns,null,if,the,owner,was,not,set,return,the,owner,of,the,memory,segment,or,null,if,it,does,not,have,an,owner;public,object,get,owner,return,owner
MemorySegment -> public Object getOwner();1507315082;Gets the owner of this memory segment. Returns null, if the owner was not set.__@return The owner of the memory segment, or null, if it does not have an owner.;public Object getOwner() {_		return owner__	};gets,the,owner,of,this,memory,segment,returns,null,if,the,owner,was,not,set,return,the,owner,of,the,memory,segment,or,null,if,it,does,not,have,an,owner;public,object,get,owner,return,owner
MemorySegment -> public Object getOwner();1509981552;Gets the owner of this memory segment. Returns null, if the owner was not set.__@return The owner of the memory segment, or null, if it does not have an owner.;public Object getOwner() {_		return owner__	};gets,the,owner,of,this,memory,segment,returns,null,if,the,owner,was,not,set,return,the,owner,of,the,memory,segment,or,null,if,it,does,not,have,an,owner;public,object,get,owner,return,owner
MemorySegment -> public Object getOwner();1513874825;Gets the owner of this memory segment. Returns null, if the owner was not set.__@return The owner of the memory segment, or null, if it does not have an owner.;public Object getOwner() {_		return owner__	};gets,the,owner,of,this,memory,segment,returns,null,if,the,owner,was,not,set,return,the,owner,of,the,memory,segment,or,null,if,it,does,not,have,an,owner;public,object,get,owner,return,owner
MemorySegment -> public Object getOwner();1516285456;Gets the owner of this memory segment. Returns null, if the owner was not set.__@return The owner of the memory segment, or null, if it does not have an owner.;public Object getOwner() {_		return owner__	};gets,the,owner,of,this,memory,segment,returns,null,if,the,owner,was,not,set,return,the,owner,of,the,memory,segment,or,null,if,it,does,not,have,an,owner;public,object,get,owner,return,owner
MemorySegment -> public Object getOwner();1550507508;Gets the owner of this memory segment. Returns null, if the owner was not set.__@return The owner of the memory segment, or null, if it does not have an owner.;public Object getOwner() {_		return owner__	};gets,the,owner,of,this,memory,segment,returns,null,if,the,owner,was,not,set,return,the,owner,of,the,memory,segment,or,null,if,it,does,not,have,an,owner;public,object,get,owner,return,owner
MemorySegment -> public Object getOwner();1550567875;Gets the owner of this memory segment. Returns null, if the owner was not set.__@return The owner of the memory segment, or null, if it does not have an owner.;public Object getOwner() {_		return owner__	};gets,the,owner,of,this,memory,segment,returns,null,if,the,owner,was,not,set,return,the,owner,of,the,memory,segment,or,null,if,it,does,not,have,an,owner;public,object,get,owner,return,owner
MemorySegment -> public final boolean isFreed();1405024514;Checks whether this memory segment has already been freed. In that case, the_segment must not be used any more.__@return True, if the segment has been freed, false otherwise.;public final boolean isFreed() {_		return this.memory == null__	};checks,whether,this,memory,segment,has,already,been,freed,in,that,case,the,segment,must,not,be,used,any,more,return,true,if,the,segment,has,been,freed,false,otherwise;public,final,boolean,is,freed,return,this,memory,null
MemorySegment -> public final boolean isFreed();1405090423;Checks whether this memory segment has already been freed. In that case, the_segment must not be used any more.__@return True, if the segment has been freed, false otherwise.;public final boolean isFreed() {_		return this.memory == null__	};checks,whether,this,memory,segment,has,already,been,freed,in,that,case,the,segment,must,not,be,used,any,more,return,true,if,the,segment,has,been,freed,false,otherwise;public,final,boolean,is,freed,return,this,memory,null
MemorySegment -> public final boolean isFreed();1411473593;Checks whether this memory segment has already been freed. In that case, the_segment must not be used any more.__@return True, if the segment has been freed, false otherwise.;public final boolean isFreed() {_		return this.memory == null__	};checks,whether,this,memory,segment,has,already,been,freed,in,that,case,the,segment,must,not,be,used,any,more,return,true,if,the,segment,has,been,freed,false,otherwise;public,final,boolean,is,freed,return,this,memory,null
MemorySegment -> public final boolean isFreed();1418658367;Checks whether this memory segment has already been freed. In that case, the_segment must not be used any more.__@return True, if the segment has been freed, false otherwise.;public final boolean isFreed() {_		return this.memory == null__	};checks,whether,this,memory,segment,has,already,been,freed,in,that,case,the,segment,must,not,be,used,any,more,return,true,if,the,segment,has,been,freed,false,otherwise;public,final,boolean,is,freed,return,this,memory,null
MemorySegment -> public final boolean isFreed();1421050512;Checks whether this memory segment has already been freed. In that case, the_segment must not be used any more.__@return True, if the segment has been freed, false otherwise.;public final boolean isFreed() {_		return this.memory == null__	};checks,whether,this,memory,segment,has,already,been,freed,in,that,case,the,segment,must,not,be,used,any,more,return,true,if,the,segment,has,been,freed,false,otherwise;public,final,boolean,is,freed,return,this,memory,null
MemorySegment -> public final void putFloat(int index, float value);1405024514;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1405090423;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1411473593;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1418658367;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1421050512;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1441738685;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1446112342;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1455479358;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1474380620;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1507315082;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1509981552;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1513874825;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1516285456;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1550507508;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final void putFloat(int index, float value);1550567875;Writes the given single-precision float value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for float writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The float value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 4.;public final void putFloat(int index, float value) {_		putInt(index, Float.floatToRawIntBits(value))__	};writes,the,given,single,precision,float,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,float,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,float,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,4;public,final,void,put,float,int,index,float,value,put,int,index,float,float,to,raw,int,bits,value
MemorySegment -> public final int getInt(int index);1441738685;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getInt(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			return UNSAFE.getInt(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,4,return,unsafe,get,int,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final int getInt(int index);1446112342;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getInt(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			return UNSAFE.getInt(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,4,return,unsafe,get,int,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final int getInt(int index);1455479358;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getInt(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			return UNSAFE.getInt(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,4,return,unsafe,get,int,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final int getInt(int index);1474380620;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getInt(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			return UNSAFE.getInt(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,4,return,unsafe,get,int,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final int getInt(int index);1507315082;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getInt(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			return UNSAFE.getInt(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,4,return,unsafe,get,int,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final int getInt(int index);1509981552;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getInt(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			return UNSAFE.getInt(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,4,return,unsafe,get,int,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final int getInt(int index);1513874825;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getInt(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			return UNSAFE.getInt(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,4,return,unsafe,get,int,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final int getInt(int index);1516285456;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getInt(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			return UNSAFE.getInt(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,4,return,unsafe,get,int,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final int getInt(int index);1550507508;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final int getInt(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			return UNSAFE.getInt(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,int,get,int,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,4,return,unsafe,get,int,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final int getInt(int index);1550567875;Reads an int value (32bit, 4 bytes) from the given position, in the system's native byte order._This method offers the best speed for integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The int value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 4.;public final int getInt(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			return UNSAFE.getInt(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,an,int,value,32bit,4,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,int,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,4;public,final,int,get,int,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,4,return,unsafe,get,int,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final void putInt(int index, int value);1405024514;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;@SuppressWarnings("restriction")_	public final void putInt(int index, int value) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 4) {_				UNSAFE.putInt(this.memory, BASE_OFFSET + index, value)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			UNSAFE.putInt(this.memory, BASE_OFFSET + index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;suppress,warnings,restriction,public,final,void,put,int,int,index,int,value,if,checked,if,index,0,index,this,memory,length,4,unsafe,put,int,this,memory,index,value,else,throw,new,index,out,of,bounds,exception,else,unsafe,put,int,this,memory,index,value
MemorySegment -> @SuppressWarnings("restriction") 	public final void putInt(int index, int value);1405090423;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;@SuppressWarnings("restriction")_	public final void putInt(int index, int value) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 4) {_				UNSAFE.putInt(this.memory, BASE_OFFSET + index, value)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			UNSAFE.putInt(this.memory, BASE_OFFSET + index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;suppress,warnings,restriction,public,final,void,put,int,int,index,int,value,if,checked,if,index,0,index,this,memory,length,4,unsafe,put,int,this,memory,index,value,else,throw,new,index,out,of,bounds,exception,else,unsafe,put,int,this,memory,index,value
MemorySegment -> @SuppressWarnings("restriction") 	public final void putInt(int index, int value);1411473593;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;@SuppressWarnings("restriction")_	public final void putInt(int index, int value) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 4) {_				UNSAFE.putInt(this.memory, BASE_OFFSET + index, value)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			UNSAFE.putInt(this.memory, BASE_OFFSET + index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;suppress,warnings,restriction,public,final,void,put,int,int,index,int,value,if,checked,if,index,0,index,this,memory,length,4,unsafe,put,int,this,memory,index,value,else,throw,new,index,out,of,bounds,exception,else,unsafe,put,int,this,memory,index,value
MemorySegment -> @SuppressWarnings("restriction") 	public final void putInt(int index, int value);1418658367;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;@SuppressWarnings("restriction")_	public final void putInt(int index, int value) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 4) {_				UNSAFE.putInt(this.memory, BASE_OFFSET + index, value)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			UNSAFE.putInt(this.memory, BASE_OFFSET + index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;suppress,warnings,restriction,public,final,void,put,int,int,index,int,value,if,checked,if,index,0,index,this,memory,length,4,unsafe,put,int,this,memory,index,value,else,throw,new,index,out,of,bounds,exception,else,unsafe,put,int,this,memory,index,value
MemorySegment -> @SuppressWarnings("restriction") 	public final void putInt(int index, int value);1421050512;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;@SuppressWarnings("restriction")_	public final void putInt(int index, int value) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 4) {_				UNSAFE.putInt(this.memory, BASE_OFFSET + index, value)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			UNSAFE.putInt(this.memory, BASE_OFFSET + index, value)__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;suppress,warnings,restriction,public,final,void,put,int,int,index,int,value,if,checked,if,index,0,index,this,memory,length,4,unsafe,put,int,this,memory,index,value,else,throw,new,index,out,of,bounds,exception,else,unsafe,put,int,this,memory,index,value
MemorySegment -> public byte[] getArray();1516285456;Returns the byte array of on-heap memory segments.__@return underlying byte array__@throws IllegalStateException_if the memory segment does not represent on-heap memory;public byte[] getArray() {_		if (heapMemory != null) {_			return heapMemory__		} else {_			throw new IllegalStateException("Memory segment does not represent heap memory")__		}_	};returns,the,byte,array,of,on,heap,memory,segments,return,underlying,byte,array,throws,illegal,state,exception,if,the,memory,segment,does,not,represent,on,heap,memory;public,byte,get,array,if,heap,memory,null,return,heap,memory,else,throw,new,illegal,state,exception,memory,segment,does,not,represent,heap,memory
MemorySegment -> public byte[] getArray();1550507508;Returns the byte array of on-heap memory segments.__@return underlying byte array__@throws IllegalStateException_if the memory segment does not represent on-heap memory;public byte[] getArray() {_		if (heapMemory != null) {_			return heapMemory__		} else {_			throw new IllegalStateException("Memory segment does not represent heap memory")__		}_	};returns,the,byte,array,of,on,heap,memory,segments,return,underlying,byte,array,throws,illegal,state,exception,if,the,memory,segment,does,not,represent,on,heap,memory;public,byte,get,array,if,heap,memory,null,return,heap,memory,else,throw,new,illegal,state,exception,memory,segment,does,not,represent,heap,memory
MemorySegment -> public byte[] getArray();1550567875;Returns the byte array of on-heap memory segments.__@return underlying byte array__@throws IllegalStateException_if the memory segment does not represent on-heap memory;public byte[] getArray() {_		if (heapMemory != null) {_			return heapMemory__		} else {_			throw new IllegalStateException("Memory segment does not represent heap memory")__		}_	};returns,the,byte,array,of,on,heap,memory,segments,return,underlying,byte,array,throws,illegal,state,exception,if,the,memory,segment,does,not,represent,on,heap,memory;public,byte,get,array,if,heap,memory,null,return,heap,memory,else,throw,new,illegal,state,exception,memory,segment,does,not,represent,heap,memory
MemorySegment -> public final void putLongLittleEndian(int index, long value);1405024514;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1405090423;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1411473593;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1418658367;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1421050512;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1441738685;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1446112342;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1455479358;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1474380620;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1507315082;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1509981552;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1513874825;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1516285456;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1550507508;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void putLongLittleEndian(int index, long value);1550567875;Writes the given long value (64bit, 8 bytes) to the given position in little endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final void putLongLittleEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, value)__		} else {_			putLong(index, Long.reverseBytes(value))__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,little,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,void,put,long,little,endian,int,index,long,value,if,put,long,index,value,else,put,long,index,long,reverse,bytes,value
MemorySegment -> public final void get(int index, byte[] dst, int offset, int length);1405024514;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public final void get(int index, byte[] dst, int offset, int length) {_		_		System.arraycopy(this.memory, index, dst, offset, length)__	};bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,get,int,index,byte,dst,int,offset,int,length,system,arraycopy,this,memory,index,dst,offset,length
MemorySegment -> public final void get(int index, byte[] dst, int offset, int length);1405090423;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public final void get(int index, byte[] dst, int offset, int length) {_		_		System.arraycopy(this.memory, index, dst, offset, length)__	};bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,get,int,index,byte,dst,int,offset,int,length,system,arraycopy,this,memory,index,dst,offset,length
MemorySegment -> public final void get(int index, byte[] dst, int offset, int length);1411473593;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public final void get(int index, byte[] dst, int offset, int length) {_		_		System.arraycopy(this.memory, index, dst, offset, length)__	};bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,get,int,index,byte,dst,int,offset,int,length,system,arraycopy,this,memory,index,dst,offset,length
MemorySegment -> public final void get(int index, byte[] dst, int offset, int length);1418658367;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public final void get(int index, byte[] dst, int offset, int length) {_		_		System.arraycopy(this.memory, index, dst, offset, length)__	};bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,get,int,index,byte,dst,int,offset,int,length,system,arraycopy,this,memory,index,dst,offset,length
MemorySegment -> public final void get(int index, byte[] dst, int offset, int length);1421050512;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public final void get(int index, byte[] dst, int offset, int length) {_		_		System.arraycopy(this.memory, index, dst, offset, length)__	};bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,get,int,index,byte,dst,int,offset,int,length,system,arraycopy,this,memory,index,dst,offset,length
MemorySegment -> public final void get(int index, byte[] dst);1405024514;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public final void get(int index, byte[] dst) {_		get(index, dst, 0, dst.length)__	};bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,final,void,get,int,index,byte,dst,get,index,dst,0,dst,length
MemorySegment -> public final void get(int index, byte[] dst);1405090423;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public final void get(int index, byte[] dst) {_		get(index, dst, 0, dst.length)__	};bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,final,void,get,int,index,byte,dst,get,index,dst,0,dst,length
MemorySegment -> public final void get(int index, byte[] dst);1411473593;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public final void get(int index, byte[] dst) {_		get(index, dst, 0, dst.length)__	};bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,final,void,get,int,index,byte,dst,get,index,dst,0,dst,length
MemorySegment -> public final void get(int index, byte[] dst);1418658367;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public final void get(int index, byte[] dst) {_		get(index, dst, 0, dst.length)__	};bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,final,void,get,int,index,byte,dst,get,index,dst,0,dst,length
MemorySegment -> public final void get(int index, byte[] dst);1421050512;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public final void get(int index, byte[] dst) {_		get(index, dst, 0, dst.length)__	};bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,final,void,get,int,index,byte,dst,get,index,dst,0,dst,length
MemorySegment -> public final void get(DataOutput out, int offset, int length) throws IOException;1405024514;Bulk get method. Copies length memory from the specified offset to the_provided <tt>DataOutput</tt>.__@param out The data output object to copy the data to._@param offset The first byte to by copied._@param length The number of bytes to copy.__@throws IOException Thrown, if the DataOutput encountered a problem upon writing.;public final void get(DataOutput out, int offset, int length) throws IOException {_		out.write(this.memory, offset, length)__	};bulk,get,method,copies,length,memory,from,the,specified,offset,to,the,provided,tt,data,output,tt,param,out,the,data,output,object,to,copy,the,data,to,param,offset,the,first,byte,to,by,copied,param,length,the,number,of,bytes,to,copy,throws,ioexception,thrown,if,the,data,output,encountered,a,problem,upon,writing;public,final,void,get,data,output,out,int,offset,int,length,throws,ioexception,out,write,this,memory,offset,length
MemorySegment -> public final void get(DataOutput out, int offset, int length) throws IOException;1405090423;Bulk get method. Copies length memory from the specified offset to the_provided <tt>DataOutput</tt>.__@param out The data output object to copy the data to._@param offset The first byte to by copied._@param length The number of bytes to copy.__@throws IOException Thrown, if the DataOutput encountered a problem upon writing.;public final void get(DataOutput out, int offset, int length) throws IOException {_		out.write(this.memory, offset, length)__	};bulk,get,method,copies,length,memory,from,the,specified,offset,to,the,provided,tt,data,output,tt,param,out,the,data,output,object,to,copy,the,data,to,param,offset,the,first,byte,to,by,copied,param,length,the,number,of,bytes,to,copy,throws,ioexception,thrown,if,the,data,output,encountered,a,problem,upon,writing;public,final,void,get,data,output,out,int,offset,int,length,throws,ioexception,out,write,this,memory,offset,length
MemorySegment -> public final void get(DataOutput out, int offset, int length) throws IOException;1411473593;Bulk get method. Copies length memory from the specified offset to the_provided <tt>DataOutput</tt>.__@param out The data output object to copy the data to._@param offset The first byte to by copied._@param length The number of bytes to copy.__@throws IOException Thrown, if the DataOutput encountered a problem upon writing.;public final void get(DataOutput out, int offset, int length) throws IOException {_		out.write(this.memory, offset, length)__	};bulk,get,method,copies,length,memory,from,the,specified,offset,to,the,provided,tt,data,output,tt,param,out,the,data,output,object,to,copy,the,data,to,param,offset,the,first,byte,to,by,copied,param,length,the,number,of,bytes,to,copy,throws,ioexception,thrown,if,the,data,output,encountered,a,problem,upon,writing;public,final,void,get,data,output,out,int,offset,int,length,throws,ioexception,out,write,this,memory,offset,length
MemorySegment -> public final void get(DataOutput out, int offset, int length) throws IOException;1418658367;Bulk get method. Copies length memory from the specified offset to the_provided <tt>DataOutput</tt>.__@param out The data output object to copy the data to._@param offset The first byte to by copied._@param length The number of bytes to copy.__@throws IOException Thrown, if the DataOutput encountered a problem upon writing.;public final void get(DataOutput out, int offset, int length) throws IOException {_		out.write(this.memory, offset, length)__	};bulk,get,method,copies,length,memory,from,the,specified,offset,to,the,provided,tt,data,output,tt,param,out,the,data,output,object,to,copy,the,data,to,param,offset,the,first,byte,to,by,copied,param,length,the,number,of,bytes,to,copy,throws,ioexception,thrown,if,the,data,output,encountered,a,problem,upon,writing;public,final,void,get,data,output,out,int,offset,int,length,throws,ioexception,out,write,this,memory,offset,length
MemorySegment -> public final void get(DataOutput out, int offset, int length) throws IOException;1421050512;Bulk get method. Copies length memory from the specified offset to the_provided <tt>DataOutput</tt>.__@param out The data output object to copy the data to._@param offset The first byte to by copied._@param length The number of bytes to copy.__@throws IOException Thrown, if the DataOutput encountered a problem upon writing.;public final void get(DataOutput out, int offset, int length) throws IOException {_		out.write(this.memory, offset, length)__	};bulk,get,method,copies,length,memory,from,the,specified,offset,to,the,provided,tt,data,output,tt,param,out,the,data,output,object,to,copy,the,data,to,param,offset,the,first,byte,to,by,copied,param,length,the,number,of,bytes,to,copy,throws,ioexception,thrown,if,the,data,output,encountered,a,problem,upon,writing;public,final,void,get,data,output,out,int,offset,int,length,throws,ioexception,out,write,this,memory,offset,length
MemorySegment -> public final short getShortBigEndian(int index);1441738685;Reads an short integer value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Short.reverseBytes(getShort(index))__		} else {_			return getShort(index)__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,big,endian,int,index,if,return,short,reverse,bytes,get,short,index,else,return,get,short,index
MemorySegment -> public final short getShortBigEndian(int index);1446112342;Reads an short integer value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Short.reverseBytes(getShort(index))__		} else {_			return getShort(index)__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,big,endian,int,index,if,return,short,reverse,bytes,get,short,index,else,return,get,short,index
MemorySegment -> public final short getShortBigEndian(int index);1455479358;Reads an short integer value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Short.reverseBytes(getShort(index))__		} else {_			return getShort(index)__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,big,endian,int,index,if,return,short,reverse,bytes,get,short,index,else,return,get,short,index
MemorySegment -> public final short getShortBigEndian(int index);1474380620;Reads an short integer value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Short.reverseBytes(getShort(index))__		} else {_			return getShort(index)__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,big,endian,int,index,if,return,short,reverse,bytes,get,short,index,else,return,get,short,index
MemorySegment -> public final short getShortBigEndian(int index);1507315082;Reads an short integer value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Short.reverseBytes(getShort(index))__		} else {_			return getShort(index)__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,big,endian,int,index,if,return,short,reverse,bytes,get,short,index,else,return,get,short,index
MemorySegment -> public final short getShortBigEndian(int index);1509981552;Reads an short integer value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Short.reverseBytes(getShort(index))__		} else {_			return getShort(index)__		}_	};reads,an,short,integer,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,big,endian,int,index,if,return,short,reverse,bytes,get,short,index,else,return,get,short,index
MemorySegment -> public final short getShortBigEndian(int index);1513874825;Reads a short integer value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Short.reverseBytes(getShort(index))__		} else {_			return getShort(index)__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,big,endian,int,index,if,return,short,reverse,bytes,get,short,index,else,return,get,short,index
MemorySegment -> public final short getShortBigEndian(int index);1516285456;Reads a short integer value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Short.reverseBytes(getShort(index))__		} else {_			return getShort(index)__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,big,endian,int,index,if,return,short,reverse,bytes,get,short,index,else,return,get,short,index
MemorySegment -> public final short getShortBigEndian(int index);1550507508;Reads a short integer value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment size minus 2.;public final short getShortBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Short.reverseBytes(getShort(index))__		} else {_			return getShort(index)__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;public,final,short,get,short,big,endian,int,index,if,return,short,reverse,bytes,get,short,index,else,return,get,short,index
MemorySegment -> public final short getShortBigEndian(int index);1550567875;Reads a short integer value (16 bit, 2 bytes) from the given position, in big-endian byte order._This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #getShort(int)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #getShort(int)} is the preferable choice.__@param index The position from which the value will be read._@return The short value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment size minus 2.;public final short getShortBigEndian(int index) {_		if (LITTLE_ENDIAN) {_			return Short.reverseBytes(getShort(index))__		} else {_			return getShort(index)__		}_	};reads,a,short,integer,value,16,bit,2,bytes,from,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,get,short,int,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,get,short,int,is,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,short,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;public,final,short,get,short,big,endian,int,index,if,return,short,reverse,bytes,get,short,index,else,return,get,short,index
MemorySegment -> public final void put(DataInput in, int offset, int length) throws IOException;1405024514;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public final void put(DataInput in, int offset, int length) throws IOException {_		in.readFully(this.memory, offset, length)__	};bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,final,void,put,data,input,in,int,offset,int,length,throws,ioexception,in,read,fully,this,memory,offset,length
MemorySegment -> public final void put(DataInput in, int offset, int length) throws IOException;1405090423;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public final void put(DataInput in, int offset, int length) throws IOException {_		in.readFully(this.memory, offset, length)__	};bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,final,void,put,data,input,in,int,offset,int,length,throws,ioexception,in,read,fully,this,memory,offset,length
MemorySegment -> public final void put(DataInput in, int offset, int length) throws IOException;1411473593;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public final void put(DataInput in, int offset, int length) throws IOException {_		in.readFully(this.memory, offset, length)__	};bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,final,void,put,data,input,in,int,offset,int,length,throws,ioexception,in,read,fully,this,memory,offset,length
MemorySegment -> public final void put(DataInput in, int offset, int length) throws IOException;1418658367;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public final void put(DataInput in, int offset, int length) throws IOException {_		in.readFully(this.memory, offset, length)__	};bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,final,void,put,data,input,in,int,offset,int,length,throws,ioexception,in,read,fully,this,memory,offset,length
MemorySegment -> public final void put(DataInput in, int offset, int length) throws IOException;1421050512;Bulk put method. Copies length memory from the given DataInput to the_memory starting at position offset.__@param in The DataInput to get the data from._@param offset The position in the memory segment to copy the chunk to._@param length The number of bytes to get.__@throws IOException Thrown, if the DataInput encountered a problem upon reading,_such as an End-Of-File.;public final void put(DataInput in, int offset, int length) throws IOException {_		in.readFully(this.memory, offset, length)__	};bulk,put,method,copies,length,memory,from,the,given,data,input,to,the,memory,starting,at,position,offset,param,in,the,data,input,to,get,the,data,from,param,offset,the,position,in,the,memory,segment,to,copy,the,chunk,to,param,length,the,number,of,bytes,to,get,throws,ioexception,thrown,if,the,data,input,encountered,a,problem,upon,reading,such,as,an,end,of,file;public,final,void,put,data,input,in,int,offset,int,length,throws,ioexception,in,read,fully,this,memory,offset,length
MemorySegment -> public abstract void get(int index, byte[] dst)_;1441738685;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public abstract void get(int index, byte[] dst)_;bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,abstract,void,get,int,index,byte,dst
MemorySegment -> public abstract void get(int index, byte[] dst)_;1446112342;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public abstract void get(int index, byte[] dst)_;bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,abstract,void,get,int,index,byte,dst
MemorySegment -> public abstract void get(int index, byte[] dst)_;1455479358;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public abstract void get(int index, byte[] dst)_;bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,abstract,void,get,int,index,byte,dst
MemorySegment -> public abstract void get(int index, byte[] dst)_;1474380620;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public abstract void get(int index, byte[] dst)_;bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,abstract,void,get,int,index,byte,dst
MemorySegment -> public abstract void get(int index, byte[] dst)_;1507315082;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public abstract void get(int index, byte[] dst)_;bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,abstract,void,get,int,index,byte,dst
MemorySegment -> public abstract void get(int index, byte[] dst)_;1509981552;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public abstract void get(int index, byte[] dst)_;bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,abstract,void,get,int,index,byte,dst
MemorySegment -> public abstract void get(int index, byte[] dst)_;1513874825;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public abstract void get(int index, byte[] dst)_;bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,abstract,void,get,int,index,byte,dst
MemorySegment -> public abstract void get(int index, byte[] dst)_;1516285456;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public abstract void get(int index, byte[] dst)_;bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,abstract,void,get,int,index,byte,dst
MemorySegment -> public abstract void get(int index, byte[] dst)_;1550507508;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public abstract void get(int index, byte[] dst)_;bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,abstract,void,get,int,index,byte,dst
MemorySegment -> public abstract void get(int index, byte[] dst)_;1550567875;Bulk get method. Copies dst.length memory from the specified position to_the destination memory.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the data between the_index and the memory segment end is not enough to fill the destination array.;public abstract void get(int index, byte[] dst)_;bulk,get,method,copies,dst,length,memory,from,the,specified,position,to,the,destination,memory,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,data,between,the,index,and,the,memory,segment,end,is,not,enough,to,fill,the,destination,array;public,abstract,void,get,int,index,byte,dst
MemorySegment -> public final void put(int index, byte[] src);1405024514;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public final void put(int index, byte[] src) {_		put(index, src, 0, src.length)__	};bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,put,int,index,byte,src,put,index,src,0,src,length
MemorySegment -> public final void put(int index, byte[] src);1405090423;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public final void put(int index, byte[] src) {_		put(index, src, 0, src.length)__	};bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,put,int,index,byte,src,put,index,src,0,src,length
MemorySegment -> public final void put(int index, byte[] src);1411473593;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public final void put(int index, byte[] src) {_		put(index, src, 0, src.length)__	};bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,put,int,index,byte,src,put,index,src,0,src,length
MemorySegment -> public final void put(int index, byte[] src);1418658367;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public final void put(int index, byte[] src) {_		put(index, src, 0, src.length)__	};bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,put,int,index,byte,src,put,index,src,0,src,length
MemorySegment -> public final void put(int index, byte[] src);1421050512;Bulk put method. Copies src.length memory from the source memory into the_memory segment beginning at the specified position.__@param index The index in the memory segment array, where the data is put._@param src The source array to copy the data from.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_size exceed the amount of memory between the index and the memory_segment's end.;public final void put(int index, byte[] src) {_		put(index, src, 0, src.length)__	};bulk,put,method,copies,src,length,memory,from,the,source,memory,into,the,memory,segment,beginning,at,the,specified,position,param,index,the,index,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,size,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,final,void,put,int,index,byte,src,put,index,src,0,src,length
MemorySegment -> public final void putLong(int index, long value);1441738685;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLong(int index, long value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			UNSAFE.putLong(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,int,index,long,value,final,long,pos,address,index,if,index,0,pos,address,limit,8,unsafe,put,long,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putLong(int index, long value);1446112342;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLong(int index, long value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			UNSAFE.putLong(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,int,index,long,value,final,long,pos,address,index,if,index,0,pos,address,limit,8,unsafe,put,long,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putLong(int index, long value);1455479358;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLong(int index, long value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			UNSAFE.putLong(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,int,index,long,value,final,long,pos,address,index,if,index,0,pos,address,limit,8,unsafe,put,long,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putLong(int index, long value);1474380620;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLong(int index, long value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			UNSAFE.putLong(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,int,index,long,value,final,long,pos,address,index,if,index,0,pos,address,limit,8,unsafe,put,long,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putLong(int index, long value);1507315082;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLong(int index, long value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			UNSAFE.putLong(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,int,index,long,value,final,long,pos,address,index,if,index,0,pos,address,limit,8,unsafe,put,long,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putLong(int index, long value);1509981552;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLong(int index, long value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			UNSAFE.putLong(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,int,index,long,value,final,long,pos,address,index,if,index,0,pos,address,limit,8,unsafe,put,long,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putLong(int index, long value);1513874825;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLong(int index, long value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			UNSAFE.putLong(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,int,index,long,value,final,long,pos,address,index,if,index,0,pos,address,limit,8,unsafe,put,long,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putLong(int index, long value);1516285456;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLong(int index, long value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			UNSAFE.putLong(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,int,index,long,value,final,long,pos,address,index,if,index,0,pos,address,limit,8,unsafe,put,long,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putLong(int index, long value);1550507508;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLong(int index, long value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			UNSAFE.putLong(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,int,index,long,value,final,long,pos,address,index,if,index,0,pos,address,limit,8,unsafe,put,long,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putLong(int index, long value);1550567875;Writes the given long value (64bit, 8 bytes) to the given position in the system's native_byte order. This method offers the best speed for long integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final void putLong(int index, long value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			UNSAFE.putLong(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,void,put,long,int,index,long,value,final,long,pos,address,index,if,index,0,pos,address,limit,8,unsafe,put,long,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public abstract void put(int index, byte[] src, int offset, int length)_;1441738685;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src, int offset, int length)_;bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src,int,offset,int,length
MemorySegment -> public abstract void put(int index, byte[] src, int offset, int length)_;1446112342;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src, int offset, int length)_;bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src,int,offset,int,length
MemorySegment -> public abstract void put(int index, byte[] src, int offset, int length)_;1455479358;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src, int offset, int length)_;bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src,int,offset,int,length
MemorySegment -> public abstract void put(int index, byte[] src, int offset, int length)_;1474380620;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src, int offset, int length)_;bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src,int,offset,int,length
MemorySegment -> public abstract void put(int index, byte[] src, int offset, int length)_;1507315082;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src, int offset, int length)_;bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src,int,offset,int,length
MemorySegment -> public abstract void put(int index, byte[] src, int offset, int length)_;1509981552;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src, int offset, int length)_;bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src,int,offset,int,length
MemorySegment -> public abstract void put(int index, byte[] src, int offset, int length)_;1513874825;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src, int offset, int length)_;bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src,int,offset,int,length
MemorySegment -> public abstract void put(int index, byte[] src, int offset, int length)_;1516285456;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src, int offset, int length)_;bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src,int,offset,int,length
MemorySegment -> public abstract void put(int index, byte[] src, int offset, int length)_;1550507508;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src, int offset, int length)_;bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src,int,offset,int,length
MemorySegment -> public abstract void put(int index, byte[] src, int offset, int length)_;1550567875;Bulk put method. Copies length memory starting at position offset from_the source memory into the memory segment starting at the specified_index.__@param index The position in the memory segment array, where the data is put._@param src The source array to copy the data from._@param offset The offset in the source array where the copying is started._@param length The number of bytes to copy.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large such that the array_portion to copy exceed the amount of memory between the index and the memory_segment's end.;public abstract void put(int index, byte[] src, int offset, int length)_;bulk,put,method,copies,length,memory,starting,at,position,offset,from,the,source,memory,into,the,memory,segment,starting,at,the,specified,index,param,index,the,position,in,the,memory,segment,array,where,the,data,is,put,param,src,the,source,array,to,copy,the,data,from,param,offset,the,offset,in,the,source,array,where,the,copying,is,started,param,length,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,such,that,the,array,portion,to,copy,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,put,int,index,byte,src,int,offset,int,length
MemorySegment -> public final int size();1405024514;Gets the size of the memory segment, in bytes. Because segments_are backed by arrays, they cannot be larger than two GiBytes.__@return The size in bytes.;public final int size() {_		return this.memory.length__	};gets,the,size,of,the,memory,segment,in,bytes,because,segments,are,backed,by,arrays,they,cannot,be,larger,than,two,gi,bytes,return,the,size,in,bytes;public,final,int,size,return,this,memory,length
MemorySegment -> public final int size();1405090423;Gets the size of the memory segment, in bytes. Because segments_are backed by arrays, they cannot be larger than two GiBytes.__@return The size in bytes.;public final int size() {_		return this.memory.length__	};gets,the,size,of,the,memory,segment,in,bytes,because,segments,are,backed,by,arrays,they,cannot,be,larger,than,two,gi,bytes,return,the,size,in,bytes;public,final,int,size,return,this,memory,length
MemorySegment -> public final int size();1411473593;Gets the size of the memory segment, in bytes. Because segments_are backed by arrays, they cannot be larger than two GiBytes.__@return The size in bytes.;public final int size() {_		return this.memory.length__	};gets,the,size,of,the,memory,segment,in,bytes,because,segments,are,backed,by,arrays,they,cannot,be,larger,than,two,gi,bytes,return,the,size,in,bytes;public,final,int,size,return,this,memory,length
MemorySegment -> public final int size();1418658367;Gets the size of the memory segment, in bytes. Because segments_are backed by arrays, they cannot be larger than two GiBytes.__@return The size in bytes.;public final int size() {_		return this.memory.length__	};gets,the,size,of,the,memory,segment,in,bytes,because,segments,are,backed,by,arrays,they,cannot,be,larger,than,two,gi,bytes,return,the,size,in,bytes;public,final,int,size,return,this,memory,length
MemorySegment -> public final int size();1421050512;Gets the size of the memory segment, in bytes. Because segments_are backed by arrays, they cannot be larger than two GiBytes.__@return The size in bytes.;public final int size() {_		return this.memory.length__	};gets,the,size,of,the,memory,segment,in,bytes,because,segments,are,backed,by,arrays,they,cannot,be,larger,than,two,gi,bytes,return,the,size,in,bytes;public,final,int,size,return,this,memory,length
MemorySegment -> public abstract void putBoolean(int index, boolean value)_;1441738685;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract void putBoolean(int index, boolean value)_;writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,void,put,boolean,int,index,boolean,value
MemorySegment -> public abstract void putBoolean(int index, boolean value)_;1446112342;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract void putBoolean(int index, boolean value)_;writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,void,put,boolean,int,index,boolean,value
MemorySegment -> public abstract void putBoolean(int index, boolean value)_;1455479358;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract void putBoolean(int index, boolean value)_;writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,void,put,boolean,int,index,boolean,value
MemorySegment -> public abstract void putBoolean(int index, boolean value)_;1474380620;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract void putBoolean(int index, boolean value)_;writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,void,put,boolean,int,index,boolean,value
MemorySegment -> public abstract void putBoolean(int index, boolean value)_;1507315082;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract void putBoolean(int index, boolean value)_;writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,void,put,boolean,int,index,boolean,value
MemorySegment -> public abstract void putBoolean(int index, boolean value)_;1509981552;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract void putBoolean(int index, boolean value)_;writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,void,put,boolean,int,index,boolean,value
MemorySegment -> public abstract void putBoolean(int index, boolean value)_;1513874825;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract void putBoolean(int index, boolean value)_;writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,void,put,boolean,int,index,boolean,value
MemorySegment -> public abstract void putBoolean(int index, boolean value)_;1516285456;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract void putBoolean(int index, boolean value)_;writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,void,put,boolean,int,index,boolean,value
MemorySegment -> public abstract void putBoolean(int index, boolean value)_;1550507508;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public abstract void putBoolean(int index, boolean value)_;writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,abstract,void,put,boolean,int,index,boolean,value
MemorySegment -> public abstract void putBoolean(int index, boolean value)_;1550567875;Writes one byte containing the byte value into this buffer at the given_position.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 1.;public abstract void putBoolean(int index, boolean value)_;writes,one,byte,containing,the,byte,value,into,this,buffer,at,the,given,position,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,1;public,abstract,void,put,boolean,int,index,boolean,value
MemorySegment -> public abstract ByteBuffer wrap(int offset, int length)_;1441738685;Wraps the chunk of the underlying memory located between <tt>offset<tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer._@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public abstract ByteBuffer wrap(int offset, int length)_;wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,abstract,byte,buffer,wrap,int,offset,int,length
MemorySegment -> public abstract ByteBuffer wrap(int offset, int length)_;1446112342;Wraps the chunk of the underlying memory located between <tt>offset</tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer._@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public abstract ByteBuffer wrap(int offset, int length)_;wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,abstract,byte,buffer,wrap,int,offset,int,length
MemorySegment -> public abstract ByteBuffer wrap(int offset, int length)_;1455479358;Wraps the chunk of the underlying memory located between <tt>offset</tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer._@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public abstract ByteBuffer wrap(int offset, int length)_;wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,abstract,byte,buffer,wrap,int,offset,int,length
MemorySegment -> public abstract ByteBuffer wrap(int offset, int length)_;1474380620;Wraps the chunk of the underlying memory located between <tt>offset</tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer._@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public abstract ByteBuffer wrap(int offset, int length)_;wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,abstract,byte,buffer,wrap,int,offset,int,length
MemorySegment -> public abstract ByteBuffer wrap(int offset, int length)_;1507315082;Wraps the chunk of the underlying memory located between <tt>offset</tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer.__@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public abstract ByteBuffer wrap(int offset, int length)_;wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,abstract,byte,buffer,wrap,int,offset,int,length
MemorySegment -> public abstract ByteBuffer wrap(int offset, int length)_;1509981552;Wraps the chunk of the underlying memory located between <tt>offset</tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer.__@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public abstract ByteBuffer wrap(int offset, int length)_;wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,abstract,byte,buffer,wrap,int,offset,int,length
MemorySegment -> public abstract ByteBuffer wrap(int offset, int length)_;1513874825;Wraps the chunk of the underlying memory located between <tt>offset</tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer.__@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public abstract ByteBuffer wrap(int offset, int length)_;wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,abstract,byte,buffer,wrap,int,offset,int,length
MemorySegment -> public abstract ByteBuffer wrap(int offset, int length)_;1516285456;Wraps the chunk of the underlying memory located between <tt>offset</tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer.__@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public abstract ByteBuffer wrap(int offset, int length)_;wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,abstract,byte,buffer,wrap,int,offset,int,length
MemorySegment -> public abstract ByteBuffer wrap(int offset, int length)_;1550507508;Wraps the chunk of the underlying memory located between <tt>offset</tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer.__@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public abstract ByteBuffer wrap(int offset, int length)_;wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,abstract,byte,buffer,wrap,int,offset,int,length
MemorySegment -> public abstract ByteBuffer wrap(int offset, int length)_;1550567875;Wraps the chunk of the underlying memory located between <tt>offset</tt> and_<tt>length</tt> in a NIO ByteBuffer.__@param offset The offset in the memory segment._@param length The number of bytes to be wrapped as a buffer.__@return A <tt>ByteBuffer</tt> backed by the specified portion of the memory segment._@throws IndexOutOfBoundsException Thrown, if offset is negative or larger than the memory segment size,_or if the offset plus the length is larger than the segment size.;public abstract ByteBuffer wrap(int offset, int length)_;wraps,the,chunk,of,the,underlying,memory,located,between,tt,offset,tt,and,tt,length,tt,in,a,nio,byte,buffer,param,offset,the,offset,in,the,memory,segment,param,length,the,number,of,bytes,to,be,wrapped,as,a,buffer,return,a,tt,byte,buffer,tt,backed,by,the,specified,portion,of,the,memory,segment,throws,index,out,of,bounds,exception,thrown,if,offset,is,negative,or,larger,than,the,memory,segment,size,or,if,the,offset,plus,the,length,is,larger,than,the,segment,size;public,abstract,byte,buffer,wrap,int,offset,int,length
MemorySegment -> public final void putInt(int index, int value);1441738685;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putInt(int index, int value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			UNSAFE.putInt(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,int,index,int,value,final,long,pos,address,index,if,index,0,pos,address,limit,4,unsafe,put,int,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putInt(int index, int value);1446112342;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putInt(int index, int value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			UNSAFE.putInt(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,int,index,int,value,final,long,pos,address,index,if,index,0,pos,address,limit,4,unsafe,put,int,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putInt(int index, int value);1455479358;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putInt(int index, int value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			UNSAFE.putInt(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,int,index,int,value,final,long,pos,address,index,if,index,0,pos,address,limit,4,unsafe,put,int,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putInt(int index, int value);1474380620;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putInt(int index, int value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			UNSAFE.putInt(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,int,index,int,value,final,long,pos,address,index,if,index,0,pos,address,limit,4,unsafe,put,int,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putInt(int index, int value);1507315082;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putInt(int index, int value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			UNSAFE.putInt(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,int,index,int,value,final,long,pos,address,index,if,index,0,pos,address,limit,4,unsafe,put,int,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putInt(int index, int value);1509981552;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putInt(int index, int value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			UNSAFE.putInt(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,int,index,int,value,final,long,pos,address,index,if,index,0,pos,address,limit,4,unsafe,put,int,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putInt(int index, int value);1513874825;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putInt(int index, int value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			UNSAFE.putInt(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,int,index,int,value,final,long,pos,address,index,if,index,0,pos,address,limit,4,unsafe,put,int,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putInt(int index, int value);1516285456;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putInt(int index, int value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			UNSAFE.putInt(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,int,index,int,value,final,long,pos,address,index,if,index,0,pos,address,limit,4,unsafe,put,int,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putInt(int index, int value);1550507508;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 4.;public final void putInt(int index, int value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			UNSAFE.putInt(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,4;public,final,void,put,int,int,index,int,value,final,long,pos,address,index,if,index,0,pos,address,limit,4,unsafe,put,int,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putInt(int index, int value);1550567875;Writes the given int value (32bit, 4 bytes) to the given position in the system's native_byte order. This method offers the best speed for integer writing and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position at which the value will be written._@param value The int value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 4.;public final void putInt(int index, int value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 4) {_			UNSAFE.putInt(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,the,given,int,value,32bit,4,bytes,to,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,integer,writing,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,int,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,4;public,final,void,put,int,int,index,int,value,final,long,pos,address,index,if,index,0,pos,address,limit,4,unsafe,put,int,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final boolean getBoolean(int index);1405024514;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public final boolean getBoolean(int index) {_		return this.memory[index] != 0__	};reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,final,boolean,get,boolean,int,index,return,this,memory,index,0
MemorySegment -> public final boolean getBoolean(int index);1405090423;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public final boolean getBoolean(int index) {_		return this.memory[index] != 0__	};reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,final,boolean,get,boolean,int,index,return,this,memory,index,0
MemorySegment -> public final boolean getBoolean(int index);1411473593;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public final boolean getBoolean(int index) {_		return this.memory[index] != 0__	};reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,final,boolean,get,boolean,int,index,return,this,memory,index,0
MemorySegment -> public final boolean getBoolean(int index);1418658367;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public final boolean getBoolean(int index) {_		return this.memory[index] != 0__	};reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,final,boolean,get,boolean,int,index,return,this,memory,index,0
MemorySegment -> public final boolean getBoolean(int index);1421050512;Reads one byte at the given position and returns its boolean_representation.__@param index The position from which the memory will be read._@return The boolean value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 1.;public final boolean getBoolean(int index) {_		return this.memory[index] != 0__	};reads,one,byte,at,the,given,position,and,returns,its,boolean,representation,param,index,the,position,from,which,the,memory,will,be,read,return,the,boolean,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,1;public,final,boolean,get,boolean,int,index,return,this,memory,index,0
MemorySegment -> public abstract void get(int index, byte[] dst, int offset, int length)_;1441738685;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public abstract void get(int index, byte[] dst, int offset, int length)_;bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,get,int,index,byte,dst,int,offset,int,length
MemorySegment -> public abstract void get(int index, byte[] dst, int offset, int length)_;1446112342;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public abstract void get(int index, byte[] dst, int offset, int length)_;bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,get,int,index,byte,dst,int,offset,int,length
MemorySegment -> public abstract void get(int index, byte[] dst, int offset, int length)_;1455479358;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public abstract void get(int index, byte[] dst, int offset, int length)_;bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,get,int,index,byte,dst,int,offset,int,length
MemorySegment -> public abstract void get(int index, byte[] dst, int offset, int length)_;1474380620;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public abstract void get(int index, byte[] dst, int offset, int length)_;bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,get,int,index,byte,dst,int,offset,int,length
MemorySegment -> public abstract void get(int index, byte[] dst, int offset, int length)_;1507315082;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public abstract void get(int index, byte[] dst, int offset, int length)_;bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,get,int,index,byte,dst,int,offset,int,length
MemorySegment -> public abstract void get(int index, byte[] dst, int offset, int length)_;1509981552;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public abstract void get(int index, byte[] dst, int offset, int length)_;bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,get,int,index,byte,dst,int,offset,int,length
MemorySegment -> public abstract void get(int index, byte[] dst, int offset, int length)_;1513874825;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public abstract void get(int index, byte[] dst, int offset, int length)_;bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,get,int,index,byte,dst,int,offset,int,length
MemorySegment -> public abstract void get(int index, byte[] dst, int offset, int length)_;1516285456;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public abstract void get(int index, byte[] dst, int offset, int length)_;bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,get,int,index,byte,dst,int,offset,int,length
MemorySegment -> public abstract void get(int index, byte[] dst, int offset, int length)_;1550507508;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public abstract void get(int index, byte[] dst, int offset, int length)_;bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,get,int,index,byte,dst,int,offset,int,length
MemorySegment -> public abstract void get(int index, byte[] dst, int offset, int length)_;1550567875;Bulk get method. Copies length memory from the specified position to the_destination memory, beginning at the given offset.__@param index The position at which the first byte will be read._@param dst The memory into which the memory will be copied._@param offset The copying offset in the destination memory._@param length The number of bytes to be copied.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or too large that the requested number of_bytes exceed the amount of memory between the index and the memory_segment's end.;public abstract void get(int index, byte[] dst, int offset, int length)_;bulk,get,method,copies,length,memory,from,the,specified,position,to,the,destination,memory,beginning,at,the,given,offset,param,index,the,position,at,which,the,first,byte,will,be,read,param,dst,the,memory,into,which,the,memory,will,be,copied,param,offset,the,copying,offset,in,the,destination,memory,param,length,the,number,of,bytes,to,be,copied,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,too,large,that,the,requested,number,of,bytes,exceed,the,amount,of,memory,between,the,index,and,the,memory,segment,s,end;public,abstract,void,get,int,index,byte,dst,int,offset,int,length
MemorySegment -> MemorySegment(long offHeapAddress, int size, Object owner);1441738685;Creates a new memory segment that represents the memory at the absolute address given_by the pointer.__@param offHeapAddress The address of the memory represented by this memory segment._@param size The size of this memory segment.;MemorySegment(long offHeapAddress, int size, Object owner) {_		if (offHeapAddress <= 0) {_			throw new IllegalArgumentException("negative pointer or size")__		}_		if (offHeapAddress >= Long.MAX_VALUE - Integer.MAX_VALUE) {_			_			throw new IllegalArgumentException("Segment initialized with too large address: " + address_					+ " _ Max allowed address is " + (Long.MAX_VALUE - Integer.MAX_VALUE - 1))__		}_		_		this.heapMemory = null__		this.address = offHeapAddress__		this.addressLimit = this.address + size__		this.size = size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,at,the,absolute,address,given,by,the,pointer,param,off,heap,address,the,address,of,the,memory,represented,by,this,memory,segment,param,size,the,size,of,this,memory,segment;memory,segment,long,off,heap,address,int,size,object,owner,if,off,heap,address,0,throw,new,illegal,argument,exception,negative,pointer,or,size,if,off,heap,address,long,integer,throw,new,illegal,argument,exception,segment,initialized,with,too,large,address,address,max,allowed,address,is,long,integer,1,this,heap,memory,null,this,address,off,heap,address,this,address,limit,this,address,size,this,size,size,this,owner,owner
MemorySegment -> MemorySegment(long offHeapAddress, int size, Object owner);1446112342;Creates a new memory segment that represents the memory at the absolute address given_by the pointer.__@param offHeapAddress The address of the memory represented by this memory segment._@param size The size of this memory segment.;MemorySegment(long offHeapAddress, int size, Object owner) {_		if (offHeapAddress <= 0) {_			throw new IllegalArgumentException("negative pointer or size")__		}_		if (offHeapAddress >= Long.MAX_VALUE - Integer.MAX_VALUE) {_			_			throw new IllegalArgumentException("Segment initialized with too large address: " + address_					+ " _ Max allowed address is " + (Long.MAX_VALUE - Integer.MAX_VALUE - 1))__		}_		_		this.heapMemory = null__		this.address = offHeapAddress__		this.addressLimit = this.address + size__		this.size = size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,at,the,absolute,address,given,by,the,pointer,param,off,heap,address,the,address,of,the,memory,represented,by,this,memory,segment,param,size,the,size,of,this,memory,segment;memory,segment,long,off,heap,address,int,size,object,owner,if,off,heap,address,0,throw,new,illegal,argument,exception,negative,pointer,or,size,if,off,heap,address,long,integer,throw,new,illegal,argument,exception,segment,initialized,with,too,large,address,address,max,allowed,address,is,long,integer,1,this,heap,memory,null,this,address,off,heap,address,this,address,limit,this,address,size,this,size,size,this,owner,owner
MemorySegment -> MemorySegment(long offHeapAddress, int size, Object owner);1455479358;Creates a new memory segment that represents the memory at the absolute address given_by the pointer.__@param offHeapAddress The address of the memory represented by this memory segment._@param size The size of this memory segment.;MemorySegment(long offHeapAddress, int size, Object owner) {_		if (offHeapAddress <= 0) {_			throw new IllegalArgumentException("negative pointer or size")__		}_		if (offHeapAddress >= Long.MAX_VALUE - Integer.MAX_VALUE) {_			_			throw new IllegalArgumentException("Segment initialized with too large address: " + address_					+ " _ Max allowed address is " + (Long.MAX_VALUE - Integer.MAX_VALUE - 1))__		}_		_		this.heapMemory = null__		this.address = offHeapAddress__		this.addressLimit = this.address + size__		this.size = size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,at,the,absolute,address,given,by,the,pointer,param,off,heap,address,the,address,of,the,memory,represented,by,this,memory,segment,param,size,the,size,of,this,memory,segment;memory,segment,long,off,heap,address,int,size,object,owner,if,off,heap,address,0,throw,new,illegal,argument,exception,negative,pointer,or,size,if,off,heap,address,long,integer,throw,new,illegal,argument,exception,segment,initialized,with,too,large,address,address,max,allowed,address,is,long,integer,1,this,heap,memory,null,this,address,off,heap,address,this,address,limit,this,address,size,this,size,size,this,owner,owner
MemorySegment -> MemorySegment(long offHeapAddress, int size, Object owner);1474380620;Creates a new memory segment that represents the memory at the absolute address given_by the pointer.__@param offHeapAddress The address of the memory represented by this memory segment._@param size The size of this memory segment.;MemorySegment(long offHeapAddress, int size, Object owner) {_		if (offHeapAddress <= 0) {_			throw new IllegalArgumentException("negative pointer or size")__		}_		if (offHeapAddress >= Long.MAX_VALUE - Integer.MAX_VALUE) {_			_			throw new IllegalArgumentException("Segment initialized with too large address: " + offHeapAddress_					+ " _ Max allowed address is " + (Long.MAX_VALUE - Integer.MAX_VALUE - 1))__		}_		_		this.heapMemory = null__		this.address = offHeapAddress__		this.addressLimit = this.address + size__		this.size = size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,at,the,absolute,address,given,by,the,pointer,param,off,heap,address,the,address,of,the,memory,represented,by,this,memory,segment,param,size,the,size,of,this,memory,segment;memory,segment,long,off,heap,address,int,size,object,owner,if,off,heap,address,0,throw,new,illegal,argument,exception,negative,pointer,or,size,if,off,heap,address,long,integer,throw,new,illegal,argument,exception,segment,initialized,with,too,large,address,off,heap,address,max,allowed,address,is,long,integer,1,this,heap,memory,null,this,address,off,heap,address,this,address,limit,this,address,size,this,size,size,this,owner,owner
MemorySegment -> MemorySegment(long offHeapAddress, int size, Object owner);1507315082;Creates a new memory segment that represents the memory at the absolute address given_by the pointer.__@param offHeapAddress The address of the memory represented by this memory segment._@param size The size of this memory segment.;MemorySegment(long offHeapAddress, int size, Object owner) {_		if (offHeapAddress <= 0) {_			throw new IllegalArgumentException("negative pointer or size")__		}_		if (offHeapAddress >= Long.MAX_VALUE - Integer.MAX_VALUE) {_			_			throw new IllegalArgumentException("Segment initialized with too large address: " + offHeapAddress_					+ " _ Max allowed address is " + (Long.MAX_VALUE - Integer.MAX_VALUE - 1))__		}__		this.heapMemory = null__		this.address = offHeapAddress__		this.addressLimit = this.address + size__		this.size = size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,at,the,absolute,address,given,by,the,pointer,param,off,heap,address,the,address,of,the,memory,represented,by,this,memory,segment,param,size,the,size,of,this,memory,segment;memory,segment,long,off,heap,address,int,size,object,owner,if,off,heap,address,0,throw,new,illegal,argument,exception,negative,pointer,or,size,if,off,heap,address,long,integer,throw,new,illegal,argument,exception,segment,initialized,with,too,large,address,off,heap,address,max,allowed,address,is,long,integer,1,this,heap,memory,null,this,address,off,heap,address,this,address,limit,this,address,size,this,size,size,this,owner,owner
MemorySegment -> MemorySegment(long offHeapAddress, int size, Object owner);1509981552;Creates a new memory segment that represents the memory at the absolute address given_by the pointer.__@param offHeapAddress The address of the memory represented by this memory segment._@param size The size of this memory segment.;MemorySegment(long offHeapAddress, int size, Object owner) {_		if (offHeapAddress <= 0) {_			throw new IllegalArgumentException("negative pointer or size")__		}_		if (offHeapAddress >= Long.MAX_VALUE - Integer.MAX_VALUE) {_			_			throw new IllegalArgumentException("Segment initialized with too large address: " + offHeapAddress_					+ " _ Max allowed address is " + (Long.MAX_VALUE - Integer.MAX_VALUE - 1))__		}__		this.heapMemory = null__		this.address = offHeapAddress__		this.addressLimit = this.address + size__		this.size = size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,at,the,absolute,address,given,by,the,pointer,param,off,heap,address,the,address,of,the,memory,represented,by,this,memory,segment,param,size,the,size,of,this,memory,segment;memory,segment,long,off,heap,address,int,size,object,owner,if,off,heap,address,0,throw,new,illegal,argument,exception,negative,pointer,or,size,if,off,heap,address,long,integer,throw,new,illegal,argument,exception,segment,initialized,with,too,large,address,off,heap,address,max,allowed,address,is,long,integer,1,this,heap,memory,null,this,address,off,heap,address,this,address,limit,this,address,size,this,size,size,this,owner,owner
MemorySegment -> MemorySegment(long offHeapAddress, int size, Object owner);1513874825;Creates a new memory segment that represents the memory at the absolute address given_by the pointer.__@param offHeapAddress The address of the memory represented by this memory segment._@param size The size of this memory segment.;MemorySegment(long offHeapAddress, int size, Object owner) {_		if (offHeapAddress <= 0) {_			throw new IllegalArgumentException("negative pointer or size")__		}_		if (offHeapAddress >= Long.MAX_VALUE - Integer.MAX_VALUE) {_			_			throw new IllegalArgumentException("Segment initialized with too large address: " + offHeapAddress_					+ " _ Max allowed address is " + (Long.MAX_VALUE - Integer.MAX_VALUE - 1))__		}__		this.heapMemory = null__		this.address = offHeapAddress__		this.addressLimit = this.address + size__		this.size = size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,at,the,absolute,address,given,by,the,pointer,param,off,heap,address,the,address,of,the,memory,represented,by,this,memory,segment,param,size,the,size,of,this,memory,segment;memory,segment,long,off,heap,address,int,size,object,owner,if,off,heap,address,0,throw,new,illegal,argument,exception,negative,pointer,or,size,if,off,heap,address,long,integer,throw,new,illegal,argument,exception,segment,initialized,with,too,large,address,off,heap,address,max,allowed,address,is,long,integer,1,this,heap,memory,null,this,address,off,heap,address,this,address,limit,this,address,size,this,size,size,this,owner,owner
MemorySegment -> MemorySegment(long offHeapAddress, int size, Object owner);1516285456;Creates a new memory segment that represents the memory at the absolute address given_by the pointer.__@param offHeapAddress The address of the memory represented by this memory segment._@param size The size of this memory segment.;MemorySegment(long offHeapAddress, int size, Object owner) {_		if (offHeapAddress <= 0) {_			throw new IllegalArgumentException("negative pointer or size")__		}_		if (offHeapAddress >= Long.MAX_VALUE - Integer.MAX_VALUE) {_			_			throw new IllegalArgumentException("Segment initialized with too large address: " + offHeapAddress_					+ " _ Max allowed address is " + (Long.MAX_VALUE - Integer.MAX_VALUE - 1))__		}__		this.heapMemory = null__		this.address = offHeapAddress__		this.addressLimit = this.address + size__		this.size = size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,at,the,absolute,address,given,by,the,pointer,param,off,heap,address,the,address,of,the,memory,represented,by,this,memory,segment,param,size,the,size,of,this,memory,segment;memory,segment,long,off,heap,address,int,size,object,owner,if,off,heap,address,0,throw,new,illegal,argument,exception,negative,pointer,or,size,if,off,heap,address,long,integer,throw,new,illegal,argument,exception,segment,initialized,with,too,large,address,off,heap,address,max,allowed,address,is,long,integer,1,this,heap,memory,null,this,address,off,heap,address,this,address,limit,this,address,size,this,size,size,this,owner,owner
MemorySegment -> MemorySegment(long offHeapAddress, int size, Object owner);1550507508;Creates a new memory segment that represents the memory at the absolute address given_by the pointer.__@param offHeapAddress The address of the memory represented by this memory segment._@param size The size of this memory segment.;MemorySegment(long offHeapAddress, int size, Object owner) {_		if (offHeapAddress <= 0) {_			throw new IllegalArgumentException("negative pointer or size")__		}_		if (offHeapAddress >= Long.MAX_VALUE - Integer.MAX_VALUE) {_			_			throw new IllegalArgumentException("Segment initialized with too large address: " + offHeapAddress_					+ " _ Max allowed address is " + (Long.MAX_VALUE - Integer.MAX_VALUE - 1))__		}__		this.heapMemory = null__		this.address = offHeapAddress__		this.addressLimit = this.address + size__		this.size = size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,at,the,absolute,address,given,by,the,pointer,param,off,heap,address,the,address,of,the,memory,represented,by,this,memory,segment,param,size,the,size,of,this,memory,segment;memory,segment,long,off,heap,address,int,size,object,owner,if,off,heap,address,0,throw,new,illegal,argument,exception,negative,pointer,or,size,if,off,heap,address,long,integer,throw,new,illegal,argument,exception,segment,initialized,with,too,large,address,off,heap,address,max,allowed,address,is,long,integer,1,this,heap,memory,null,this,address,off,heap,address,this,address,limit,this,address,size,this,size,size,this,owner,owner
MemorySegment -> MemorySegment(long offHeapAddress, int size, Object owner);1550567875;Creates a new memory segment that represents the memory at the absolute address given_by the pointer.__@param offHeapAddress The address of the memory represented by this memory segment._@param size The size of this memory segment.;MemorySegment(long offHeapAddress, int size, Object owner) {_		if (offHeapAddress <= 0) {_			throw new IllegalArgumentException("negative pointer or size")__		}_		if (offHeapAddress >= Long.MAX_VALUE - Integer.MAX_VALUE) {_			_			throw new IllegalArgumentException("Segment initialized with too large address: " + offHeapAddress_					+ " _ Max allowed address is " + (Long.MAX_VALUE - Integer.MAX_VALUE - 1))__		}__		this.heapMemory = null__		this.address = offHeapAddress__		this.addressLimit = this.address + size__		this.size = size__		this.owner = owner__	};creates,a,new,memory,segment,that,represents,the,memory,at,the,absolute,address,given,by,the,pointer,param,off,heap,address,the,address,of,the,memory,represented,by,this,memory,segment,param,size,the,size,of,this,memory,segment;memory,segment,long,off,heap,address,int,size,object,owner,if,off,heap,address,0,throw,new,illegal,argument,exception,negative,pointer,or,size,if,off,heap,address,long,integer,throw,new,illegal,argument,exception,segment,initialized,with,too,large,address,off,heap,address,max,allowed,address,is,long,integer,1,this,heap,memory,null,this,address,off,heap,address,this,address,limit,this,address,size,this,size,size,this,owner,owner
MemorySegment -> public abstract void get(int offset, ByteBuffer target, int numBytes)_;1441738685;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes.;public abstract void get(int offset, ByteBuffer target, int numBytes)_;bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes;public,abstract,void,get,int,offset,byte,buffer,target,int,num,bytes
MemorySegment -> public abstract void get(int offset, ByteBuffer target, int numBytes)_;1446112342;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes.;public abstract void get(int offset, ByteBuffer target, int numBytes)_;bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes;public,abstract,void,get,int,offset,byte,buffer,target,int,num,bytes
MemorySegment -> public abstract void get(int offset, ByteBuffer target, int numBytes)_;1455479358;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes.;public abstract void get(int offset, ByteBuffer target, int numBytes)_;bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes;public,abstract,void,get,int,offset,byte,buffer,target,int,num,bytes
MemorySegment -> public abstract void get(int offset, ByteBuffer target, int numBytes)_;1474380620;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes.;public abstract void get(int offset, ByteBuffer target, int numBytes)_;bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes;public,abstract,void,get,int,offset,byte,buffer,target,int,num,bytes
MemorySegment -> public abstract void get(int offset, ByteBuffer target, int numBytes)_;1507315082;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes.;public abstract void get(int offset, ByteBuffer target, int numBytes)_;bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes;public,abstract,void,get,int,offset,byte,buffer,target,int,num,bytes
MemorySegment -> public abstract void get(int offset, ByteBuffer target, int numBytes)_;1509981552;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes._@throws ReadOnlyBufferException If the target buffer is read-only.;public abstract void get(int offset, ByteBuffer target, int numBytes)_;bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes,throws,read,only,buffer,exception,if,the,target,buffer,is,read,only;public,abstract,void,get,int,offset,byte,buffer,target,int,num,bytes
MemorySegment -> public abstract void get(int offset, ByteBuffer target, int numBytes)_;1513874825;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes._@throws ReadOnlyBufferException If the target buffer is read-only.;public abstract void get(int offset, ByteBuffer target, int numBytes)_;bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes,throws,read,only,buffer,exception,if,the,target,buffer,is,read,only;public,abstract,void,get,int,offset,byte,buffer,target,int,num,bytes
MemorySegment -> public abstract void get(int offset, ByteBuffer target, int numBytes)_;1516285456;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes._@throws ReadOnlyBufferException If the target buffer is read-only.;public abstract void get(int offset, ByteBuffer target, int numBytes)_;bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes,throws,read,only,buffer,exception,if,the,target,buffer,is,read,only;public,abstract,void,get,int,offset,byte,buffer,target,int,num,bytes
MemorySegment -> public abstract void get(int offset, ByteBuffer target, int numBytes)_;1550507508;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes._@throws ReadOnlyBufferException If the target buffer is read-only.;public abstract void get(int offset, ByteBuffer target, int numBytes)_;bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes,throws,read,only,buffer,exception,if,the,target,buffer,is,read,only;public,abstract,void,get,int,offset,byte,buffer,target,int,num,bytes
MemorySegment -> public abstract void get(int offset, ByteBuffer target, int numBytes)_;1550567875;Bulk get method. Copies {@code numBytes} bytes from this memory segment, starting at position_{@code offset} to the target {@code ByteBuffer}. The bytes will be put into the target buffer_starting at the buffer's current position. If this method attempts to write more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferOverflowException}.__@param offset The position where the bytes are started to be read from in this memory segment._@param target The ByteBuffer to copy the bytes to._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or this segment does not_contain the given number of bytes (starting from offset), or the target byte buffer does_not have enough space for the bytes._@throws ReadOnlyBufferException If the target buffer is read-only.;public abstract void get(int offset, ByteBuffer target, int numBytes)_;bulk,get,method,copies,code,num,bytes,bytes,from,this,memory,segment,starting,at,position,code,offset,to,the,target,code,byte,buffer,the,bytes,will,be,put,into,the,target,buffer,starting,at,the,buffer,s,current,position,if,this,method,attempts,to,write,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,overflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,read,from,in,this,memory,segment,param,target,the,byte,buffer,to,copy,the,bytes,to,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,this,segment,does,not,contain,the,given,number,of,bytes,starting,from,offset,or,the,target,byte,buffer,does,not,have,enough,space,for,the,bytes,throws,read,only,buffer,exception,if,the,target,buffer,is,read,only;public,abstract,void,get,int,offset,byte,buffer,target,int,num,bytes
MemorySegment -> @SuppressWarnings("restriction") 	public final long getLong(int index);1405024514;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;@SuppressWarnings("restriction")_	public final long getLong(int index) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 8) {_				return UNSAFE.getLong(this.memory, BASE_OFFSET + index)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			return UNSAFE.getLong(this.memory, BASE_OFFSET + index)__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;suppress,warnings,restriction,public,final,long,get,long,int,index,if,checked,if,index,0,index,this,memory,length,8,return,unsafe,get,long,this,memory,index,else,throw,new,index,out,of,bounds,exception,else,return,unsafe,get,long,this,memory,index
MemorySegment -> @SuppressWarnings("restriction") 	public final long getLong(int index);1405090423;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;@SuppressWarnings("restriction")_	public final long getLong(int index) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 8) {_				return UNSAFE.getLong(this.memory, BASE_OFFSET + index)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			return UNSAFE.getLong(this.memory, BASE_OFFSET + index)__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;suppress,warnings,restriction,public,final,long,get,long,int,index,if,checked,if,index,0,index,this,memory,length,8,return,unsafe,get,long,this,memory,index,else,throw,new,index,out,of,bounds,exception,else,return,unsafe,get,long,this,memory,index
MemorySegment -> @SuppressWarnings("restriction") 	public final long getLong(int index);1411473593;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;@SuppressWarnings("restriction")_	public final long getLong(int index) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 8) {_				return UNSAFE.getLong(this.memory, BASE_OFFSET + index)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			return UNSAFE.getLong(this.memory, BASE_OFFSET + index)__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;suppress,warnings,restriction,public,final,long,get,long,int,index,if,checked,if,index,0,index,this,memory,length,8,return,unsafe,get,long,this,memory,index,else,throw,new,index,out,of,bounds,exception,else,return,unsafe,get,long,this,memory,index
MemorySegment -> @SuppressWarnings("restriction") 	public final long getLong(int index);1418658367;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;@SuppressWarnings("restriction")_	public final long getLong(int index) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 8) {_				return UNSAFE.getLong(this.memory, BASE_OFFSET + index)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			return UNSAFE.getLong(this.memory, BASE_OFFSET + index)__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;suppress,warnings,restriction,public,final,long,get,long,int,index,if,checked,if,index,0,index,this,memory,length,8,return,unsafe,get,long,this,memory,index,else,throw,new,index,out,of,bounds,exception,else,return,unsafe,get,long,this,memory,index
MemorySegment -> @SuppressWarnings("restriction") 	public final long getLong(int index);1421050512;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;@SuppressWarnings("restriction")_	public final long getLong(int index) {_		if (CHECKED) {_			if (index >= 0 && index <= this.memory.length - 8) {_				return UNSAFE.getLong(this.memory, BASE_OFFSET + index)__			} else {_				throw new IndexOutOfBoundsException()__			}_		} else {_			return UNSAFE.getLong(this.memory, BASE_OFFSET + index)__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;suppress,warnings,restriction,public,final,long,get,long,int,index,if,checked,if,index,0,index,this,memory,length,8,return,unsafe,get,long,this,memory,index,else,throw,new,index,out,of,bounds,exception,else,return,unsafe,get,long,this,memory,index
MemorySegment -> public boolean isFreed();1441738685;Checks whether the memory segment was freed._@return True, if the memory segment has been freed, false otherwise.;public boolean isFreed() {_		return address > addressLimit__	};checks,whether,the,memory,segment,was,freed,return,true,if,the,memory,segment,has,been,freed,false,otherwise;public,boolean,is,freed,return,address,address,limit
MemorySegment -> public boolean isFreed();1446112342;Checks whether the memory segment was freed._@return True, if the memory segment has been freed, false otherwise.;public boolean isFreed() {_		return address > addressLimit__	};checks,whether,the,memory,segment,was,freed,return,true,if,the,memory,segment,has,been,freed,false,otherwise;public,boolean,is,freed,return,address,address,limit
MemorySegment -> public boolean isFreed();1455479358;Checks whether the memory segment was freed._@return True, if the memory segment has been freed, false otherwise.;public boolean isFreed() {_		return address > addressLimit__	};checks,whether,the,memory,segment,was,freed,return,true,if,the,memory,segment,has,been,freed,false,otherwise;public,boolean,is,freed,return,address,address,limit
MemorySegment -> public boolean isFreed();1474380620;Checks whether the memory segment was freed._@return True, if the memory segment has been freed, false otherwise.;public boolean isFreed() {_		return address > addressLimit__	};checks,whether,the,memory,segment,was,freed,return,true,if,the,memory,segment,has,been,freed,false,otherwise;public,boolean,is,freed,return,address,address,limit
MemorySegment -> public boolean isFreed();1507315082;Checks whether the memory segment was freed.__@return <tt>true</tt>, if the memory segment has been freed, <tt>false</tt> otherwise.;public boolean isFreed() {_		return address > addressLimit__	};checks,whether,the,memory,segment,was,freed,return,tt,true,tt,if,the,memory,segment,has,been,freed,tt,false,tt,otherwise;public,boolean,is,freed,return,address,address,limit
MemorySegment -> public boolean isFreed();1509981552;Checks whether the memory segment was freed.__@return <tt>true</tt>, if the memory segment has been freed, <tt>false</tt> otherwise.;public boolean isFreed() {_		return address > addressLimit__	};checks,whether,the,memory,segment,was,freed,return,tt,true,tt,if,the,memory,segment,has,been,freed,tt,false,tt,otherwise;public,boolean,is,freed,return,address,address,limit
MemorySegment -> public boolean isFreed();1513874825;Checks whether the memory segment was freed.__@return <tt>true</tt>, if the memory segment has been freed, <tt>false</tt> otherwise.;public boolean isFreed() {_		return address > addressLimit__	};checks,whether,the,memory,segment,was,freed,return,tt,true,tt,if,the,memory,segment,has,been,freed,tt,false,tt,otherwise;public,boolean,is,freed,return,address,address,limit
MemorySegment -> public boolean isFreed();1516285456;Checks whether the memory segment was freed.__@return <tt>true</tt>, if the memory segment has been freed, <tt>false</tt> otherwise.;public boolean isFreed() {_		return address > addressLimit__	};checks,whether,the,memory,segment,was,freed,return,tt,true,tt,if,the,memory,segment,has,been,freed,tt,false,tt,otherwise;public,boolean,is,freed,return,address,address,limit
MemorySegment -> public boolean isFreed();1550507508;Checks whether the memory segment was freed.__@return <tt>true</tt>, if the memory segment has been freed, <tt>false</tt> otherwise.;public boolean isFreed() {_		return address > addressLimit__	};checks,whether,the,memory,segment,was,freed,return,tt,true,tt,if,the,memory,segment,has,been,freed,tt,false,tt,otherwise;public,boolean,is,freed,return,address,address,limit
MemorySegment -> public boolean isFreed();1550567875;Checks whether the memory segment was freed.__@return <tt>true</tt>, if the memory segment has been freed, <tt>false</tt> otherwise.;public boolean isFreed() {_		return address > addressLimit__	};checks,whether,the,memory,segment,was,freed,return,tt,true,tt,if,the,memory,segment,has,been,freed,tt,false,tt,otherwise;public,boolean,is,freed,return,address,address,limit
MemorySegment -> public abstract void put(int offset, ByteBuffer source, int numBytes)_;1441738685;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public abstract void put(int offset, ByteBuffer source, int numBytes)_;bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,abstract,void,put,int,offset,byte,buffer,source,int,num,bytes
MemorySegment -> public abstract void put(int offset, ByteBuffer source, int numBytes)_;1446112342;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public abstract void put(int offset, ByteBuffer source, int numBytes)_;bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,abstract,void,put,int,offset,byte,buffer,source,int,num,bytes
MemorySegment -> public abstract void put(int offset, ByteBuffer source, int numBytes)_;1455479358;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public abstract void put(int offset, ByteBuffer source, int numBytes)_;bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,abstract,void,put,int,offset,byte,buffer,source,int,num,bytes
MemorySegment -> public abstract void put(int offset, ByteBuffer source, int numBytes)_;1474380620;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public abstract void put(int offset, ByteBuffer source, int numBytes)_;bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,abstract,void,put,int,offset,byte,buffer,source,int,num,bytes
MemorySegment -> public abstract void put(int offset, ByteBuffer source, int numBytes)_;1507315082;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public abstract void put(int offset, ByteBuffer source, int numBytes)_;bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,abstract,void,put,int,offset,byte,buffer,source,int,num,bytes
MemorySegment -> public abstract void put(int offset, ByteBuffer source, int numBytes)_;1509981552;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public abstract void put(int offset, ByteBuffer source, int numBytes)_;bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,abstract,void,put,int,offset,byte,buffer,source,int,num,bytes
MemorySegment -> public abstract void put(int offset, ByteBuffer source, int numBytes)_;1513874825;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public abstract void put(int offset, ByteBuffer source, int numBytes)_;bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,abstract,void,put,int,offset,byte,buffer,source,int,num,bytes
MemorySegment -> public abstract void put(int offset, ByteBuffer source, int numBytes)_;1516285456;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public abstract void put(int offset, ByteBuffer source, int numBytes)_;bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,abstract,void,put,int,offset,byte,buffer,source,int,num,bytes
MemorySegment -> public abstract void put(int offset, ByteBuffer source, int numBytes)_;1550507508;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public abstract void put(int offset, ByteBuffer source, int numBytes)_;bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,abstract,void,put,int,offset,byte,buffer,source,int,num,bytes
MemorySegment -> public abstract void put(int offset, ByteBuffer source, int numBytes)_;1550567875;Bulk put method. Copies {@code numBytes} bytes from the given {@code ByteBuffer}, into_this memory segment. The bytes will be read from the target buffer_starting at the buffer's current position, and will be written to this memory segment starting_at {@code offset}._If this method attempts to read more bytes than_the target byte buffer has remaining (with respect to {@link ByteBuffer#remaining()}),_this method will cause a {@link java.nio.BufferUnderflowException}.__@param offset The position where the bytes are started to be written to in this memory segment._@param source The ByteBuffer to copy the bytes from._@param numBytes The number of bytes to copy.__@throws IndexOutOfBoundsException If the offset is invalid, or the source buffer does not_contain the given number of bytes, or this segment does_not have enough space for the bytes (counting from offset).;public abstract void put(int offset, ByteBuffer source, int numBytes)_;bulk,put,method,copies,code,num,bytes,bytes,from,the,given,code,byte,buffer,into,this,memory,segment,the,bytes,will,be,read,from,the,target,buffer,starting,at,the,buffer,s,current,position,and,will,be,written,to,this,memory,segment,starting,at,code,offset,if,this,method,attempts,to,read,more,bytes,than,the,target,byte,buffer,has,remaining,with,respect,to,link,byte,buffer,remaining,this,method,will,cause,a,link,java,nio,buffer,underflow,exception,param,offset,the,position,where,the,bytes,are,started,to,be,written,to,in,this,memory,segment,param,source,the,byte,buffer,to,copy,the,bytes,from,param,num,bytes,the,number,of,bytes,to,copy,throws,index,out,of,bounds,exception,if,the,offset,is,invalid,or,the,source,buffer,does,not,contain,the,given,number,of,bytes,or,this,segment,does,not,have,enough,space,for,the,bytes,counting,from,offset;public,abstract,void,put,int,offset,byte,buffer,source,int,num,bytes
MemorySegment -> @SuppressWarnings("restriction") 	public final void putChar(int index, char value);1441738685;Writes a char value to teh given position, in the system's native byte order.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final void putChar(int index, char value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putChar(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,a,char,value,to,teh,given,position,in,the,system,s,native,byte,order,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,void,put,char,int,index,char,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,char,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final void putChar(int index, char value);1446112342;Writes a char value to teh given position, in the system's native byte order.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final void putChar(int index, char value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putChar(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,a,char,value,to,teh,given,position,in,the,system,s,native,byte,order,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,void,put,char,int,index,char,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,char,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final void putChar(int index, char value);1455479358;Writes a char value to teh given position, in the system's native byte order.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final void putChar(int index, char value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putChar(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,a,char,value,to,teh,given,position,in,the,system,s,native,byte,order,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,void,put,char,int,index,char,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,char,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final void putChar(int index, char value);1474380620;Writes a char value to teh given position, in the system's native byte order.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final void putChar(int index, char value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putChar(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,a,char,value,to,teh,given,position,in,the,system,s,native,byte,order,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,void,put,char,int,index,char,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,char,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final void putChar(int index, char value);1507315082;Writes a char value to teh given position, in the system's native byte order.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final void putChar(int index, char value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putChar(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,a,char,value,to,teh,given,position,in,the,system,s,native,byte,order,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,void,put,char,int,index,char,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,char,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final void putChar(int index, char value);1509981552;Writes a char value to teh given position, in the system's native byte order.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final void putChar(int index, char value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putChar(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,a,char,value,to,teh,given,position,in,the,system,s,native,byte,order,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,void,put,char,int,index,char,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,char,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final void putChar(int index, char value);1513874825;Writes a char value to the given position, in the system's native byte order.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final void putChar(int index, char value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putChar(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,a,char,value,to,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,void,put,char,int,index,char,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,char,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final void putChar(int index, char value);1516285456;Writes a char value to the given position, in the system's native byte order.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final void putChar(int index, char value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putChar(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,a,char,value,to,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,void,put,char,int,index,char,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,char,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final void putChar(int index, char value);1550507508;Writes a char value to the given position, in the system's native byte order.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 2.;@SuppressWarnings("restriction")_	public final void putChar(int index, char value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putChar(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,a,char,value,to,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,2;suppress,warnings,restriction,public,final,void,put,char,int,index,char,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,char,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> @SuppressWarnings("restriction") 	public final void putChar(int index, char value);1550567875;Writes a char value to the given position, in the system's native byte order.__@param index The position at which the memory will be written._@param value The char value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 2.;@SuppressWarnings("restriction")_	public final void putChar(int index, char value) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 2) {_			UNSAFE.putChar(heapMemory, pos, value)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};writes,a,char,value,to,the,given,position,in,the,system,s,native,byte,order,param,index,the,position,at,which,the,memory,will,be,written,param,value,the,char,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,2;suppress,warnings,restriction,public,final,void,put,char,int,index,char,value,final,long,pos,address,index,if,index,0,pos,address,limit,2,unsafe,put,char,heap,memory,pos,value,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final void putLongBigEndian(int index, long value);1405024514;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1405090423;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1411473593;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1418658367;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1421050512;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1441738685;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1446112342;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1455479358;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1474380620;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1507315082;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1509981552;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1513874825;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1516285456;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1550507508;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final void putLongBigEndian(int index, long value);1550567875;Writes the given long value (64bit, 8 bytes) to the given position in big endian_byte order. This method's speed depends on the system's native byte order, and it_is possibly slower than {@link #putLong(int, long)}. For most cases (such as_transient storage in memory or serialization for I/O and network),_it suffices to know that the byte order in which the value is written is the same as the_one in which it is read, and {@link #putLong(int, long)} is the preferable choice.__@param index The position at which the value will be written._@param value The long value to be written.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final void putLongBigEndian(int index, long value) {_		if (LITTLE_ENDIAN) {_			putLong(index, Long.reverseBytes(value))__		} else {_			putLong(index, value)__		}_	};writes,the,given,long,value,64bit,8,bytes,to,the,given,position,in,big,endian,byte,order,this,method,s,speed,depends,on,the,system,s,native,byte,order,and,it,is,possibly,slower,than,link,put,long,int,long,for,most,cases,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,and,link,put,long,int,long,is,the,preferable,choice,param,index,the,position,at,which,the,value,will,be,written,param,value,the,long,value,to,be,written,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,void,put,long,big,endian,int,index,long,value,if,put,long,index,long,reverse,bytes,value,else,put,long,index,value
MemorySegment -> public final long getLong(int index);1441738685;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLong(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			return UNSAFE.getLong(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,8,return,unsafe,get,long,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final long getLong(int index);1446112342;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLong(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			return UNSAFE.getLong(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,8,return,unsafe,get,long,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final long getLong(int index);1455479358;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLong(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			return UNSAFE.getLong(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,8,return,unsafe,get,long,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final long getLong(int index);1474380620;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLong(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			return UNSAFE.getLong(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,8,return,unsafe,get,long,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final long getLong(int index);1507315082;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLong(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			return UNSAFE.getLong(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,8,return,unsafe,get,long,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final long getLong(int index);1509981552;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLong(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			return UNSAFE.getLong(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,8,return,unsafe,get,long,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final long getLong(int index);1513874825;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLong(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			return UNSAFE.getLong(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,8,return,unsafe,get,long,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final long getLong(int index);1516285456;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLong(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			return UNSAFE.getLong(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,8,return,unsafe,get,long,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final long getLong(int index);1550507508;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger then the segment_size minus 8.;public final long getLong(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			return UNSAFE.getLong(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,then,the,segment,size,minus,8;public,final,long,get,long,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,8,return,unsafe,get,long,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
MemorySegment -> public final long getLong(int index);1550567875;Reads a long value (64bit, 8 bytes) from the given position, in the system's native byte order._This method offers the best speed for long integer reading and should be used_unless a specific byte order is required. In most cases, it suffices to know that the_byte order in which the value is written is the same as the one in which it is read_(such as transient storage in memory, or serialization for I/O and network), making this_method the preferable choice.__@param index The position from which the value will be read._@return The long value at the given position.__@throws IndexOutOfBoundsException Thrown, if the index is negative, or larger than the segment_size minus 8.;public final long getLong(int index) {_		final long pos = address + index__		if (index >= 0 && pos <= addressLimit - 8) {_			return UNSAFE.getLong(heapMemory, pos)__		}_		else if (address > addressLimit) {_			throw new IllegalStateException("segment has been freed")__		}_		else {_			_			throw new IndexOutOfBoundsException()__		}_	};reads,a,long,value,64bit,8,bytes,from,the,given,position,in,the,system,s,native,byte,order,this,method,offers,the,best,speed,for,long,integer,reading,and,should,be,used,unless,a,specific,byte,order,is,required,in,most,cases,it,suffices,to,know,that,the,byte,order,in,which,the,value,is,written,is,the,same,as,the,one,in,which,it,is,read,such,as,transient,storage,in,memory,or,serialization,for,i,o,and,network,making,this,method,the,preferable,choice,param,index,the,position,from,which,the,value,will,be,read,return,the,long,value,at,the,given,position,throws,index,out,of,bounds,exception,thrown,if,the,index,is,negative,or,larger,than,the,segment,size,minus,8;public,final,long,get,long,int,index,final,long,pos,address,index,if,index,0,pos,address,limit,8,return,unsafe,get,long,heap,memory,pos,else,if,address,address,limit,throw,new,illegal,state,exception,segment,has,been,freed,else,throw,new,index,out,of,bounds,exception
