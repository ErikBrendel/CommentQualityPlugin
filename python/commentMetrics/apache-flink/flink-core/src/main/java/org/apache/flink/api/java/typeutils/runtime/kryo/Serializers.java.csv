commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;17;;public static void recursivelyRegisterType(TypeInformation<?> typeInfo, ExecutionConfig config, Set<Class<?>> alreadySeen) {     if (typeInfo instanceof GenericTypeInfo) {         GenericTypeInfo<?> genericTypeInfo = (GenericTypeInfo<?>) typeInfo.         Serializers.recursivelyRegisterType(genericTypeInfo.getTypeClass(), config, alreadySeen).     } else if (typeInfo instanceof CompositeType) {         List<GenericTypeInfo<?>> genericTypesInComposite = new ArrayList<>().         getContainedGenericTypes((CompositeType<?>) typeInfo, genericTypesInComposite).         for (GenericTypeInfo<?> gt : genericTypesInComposite) {             Serializers.recursivelyRegisterType(gt.getTypeClass(), config, alreadySeen).         }     } else if (typeInfo instanceof ObjectArrayTypeInfo) {         ObjectArrayTypeInfo<?, ?> objectArrayTypeInfo = (ObjectArrayTypeInfo<?, ?>) typeInfo.         recursivelyRegisterType(objectArrayTypeInfo.getComponentInfo(), config, alreadySeen).     } }
false;public,static;3;29;;public static void recursivelyRegisterType(Class<?> type, ExecutionConfig config, Set<Class<?>> alreadySeen) {     // don't register or remember primitives     if (type == null || type.isPrimitive() || type == Object.class) {         return.     }     // prevent infinite recursion for recursive types     if (!alreadySeen.add(type)) {         return.     }     if (type.isArray()) {         recursivelyRegisterType(type.getComponentType(), config, alreadySeen).     } else {         config.registerKryoType(type).         // add serializers for Avro type if necessary         AvroUtils.getAvroUtils().addAvroSerializersIfRequired(config, type).         Field[] fields = type.getDeclaredFields().         for (Field field : fields) {             if (Modifier.isStatic(field.getModifiers()) || Modifier.isTransient(field.getModifiers())) {                 continue.             }             Type fieldType = field.getGenericType().             recursivelyRegisterGenericType(fieldType, config, alreadySeen).         }     } }
false;private,static;3;22;;private static void recursivelyRegisterGenericType(Type fieldType, ExecutionConfig config, Set<Class<?>> alreadySeen) {     if (fieldType instanceof ParameterizedType) {         // field has generics         ParameterizedType parameterizedFieldType = (ParameterizedType) fieldType.         for (Type t : parameterizedFieldType.getActualTypeArguments()) {             if (TypeExtractionUtils.isClassType(t)) {                 recursivelyRegisterType(TypeExtractionUtils.typeToClass(t), config, alreadySeen).             }         }         recursivelyRegisterGenericType(parameterizedFieldType.getRawType(), config, alreadySeen).     } else if (fieldType instanceof GenericArrayType) {         GenericArrayType genericArrayType = (GenericArrayType) fieldType.         recursivelyRegisterGenericType(genericArrayType.getGenericComponentType(), config, alreadySeen).     } else if (fieldType instanceof Class) {         Class<?> clazz = (Class<?>) fieldType.         recursivelyRegisterType(clazz, config, alreadySeen).     } }
true;private,static;2;12;/**  * Returns all GenericTypeInfos contained in a composite type.  *  * @param typeInfo {@link CompositeType}  */ ;/**  * Returns all GenericTypeInfos contained in a composite type.  *  * @param typeInfo {@link CompositeType}  */ private static void getContainedGenericTypes(CompositeType<?> typeInfo, List<GenericTypeInfo<?>> target) {     for (int i = 0. i < typeInfo.getArity(). i++) {         TypeInformation<?> type = typeInfo.getTypeAt(i).         if (type instanceof CompositeType) {             getContainedGenericTypes((CompositeType<?>) type, target).         } else if (type instanceof GenericTypeInfo) {             if (!target.contains(type)) {                 target.add((GenericTypeInfo<?>) type).             }         }     } }
false;public;3;4;;@Override public void write(Kryo kryo, Output output, Object o) {     throw new UnsupportedOperationException("Could not find required Avro dependency."). }
false;public;3;4;;@Override public T read(Kryo kryo, Input input, Class<T> aClass) {     throw new UnsupportedOperationException("Could not find required Avro dependency."). }
false;protected;3;4;;@Override protected Collection create(Kryo kryo, Input input, Class<Collection> type) {     return kryo.newInstance(this.type). }
false;protected;2;4;;@Override protected Collection createCopy(Kryo kryo, Collection original) {     return kryo.newInstance(this.type). }
