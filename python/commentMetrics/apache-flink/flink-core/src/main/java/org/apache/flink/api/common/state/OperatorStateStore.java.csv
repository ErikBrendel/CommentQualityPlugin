commented;modifiers;parameterAmount;loc;comment;code
true;;1;1;/**  * Creates (or restores) a {@link BroadcastState broadcast state}. This type of state can only be created to store  * the state of a {@code BroadcastStream}. Each state is registered under a unique name.  * The provided serializer is used to de/serialize the state in case of checkpointing (snapshot/restore).  * The returned broadcast state has {@code key-value} format.  *  * <p><b>CAUTION: the user has to guarantee that all task instances store the same elements in this type of state.</b>  *  * <p>Each operator instance individually maintains and stores elements in the broadcast state. The fact that the  * incoming stream is a broadcast one guarantees that all instances see all the elements. Upon recovery  * or re-scaling, the same state is given to each of the instances. To avoid hotspots, each task reads its previous  * partition, and if there are more tasks (scale up), then the new instances read from the old instances in a round  * robin fashion. This is why each instance has to guarantee that it stores the same elements as the rest. If not,  * upon recovery or rescaling you may have unpredictable redistribution of the partitions, thus unpredictable results.  *  * @param stateDescriptor The descriptor for this state, providing a name, a serializer for the keys and one for the  *                        values.  * @param <K> The type of the keys in the broadcast state.  * @param <V> The type of the values in the broadcast state.  *  * @return The Broadcast State  */ ;/**  * Creates (or restores) a {@link BroadcastState broadcast state}. This type of state can only be created to store  * the state of a {@code BroadcastStream}. Each state is registered under a unique name.  * The provided serializer is used to de/serialize the state in case of checkpointing (snapshot/restore).  * The returned broadcast state has {@code key-value} format.  *  * <p><b>CAUTION: the user has to guarantee that all task instances store the same elements in this type of state.</b>  *  * <p>Each operator instance individually maintains and stores elements in the broadcast state. The fact that the  * incoming stream is a broadcast one guarantees that all instances see all the elements. Upon recovery  * or re-scaling, the same state is given to each of the instances. To avoid hotspots, each task reads its previous  * partition, and if there are more tasks (scale up), then the new instances read from the old instances in a round  * robin fashion. This is why each instance has to guarantee that it stores the same elements as the rest. If not,  * upon recovery or rescaling you may have unpredictable redistribution of the partitions, thus unpredictable results.  *  * @param stateDescriptor The descriptor for this state, providing a name, a serializer for the keys and one for the  *                        values.  * @param <K> The type of the keys in the broadcast state.  * @param <V> The type of the values in the broadcast state.  *  * @return The Broadcast State  */ <K, V> BroadcastState<K, V> getBroadcastState(MapStateDescriptor<K, V> stateDescriptor) throws Exception.
true;;1;1;/**  * Creates (or restores) a list state. Each state is registered under a unique name.  * The provided serializer is used to de/serialize the state in case of checkpointing (snapshot/restore).  *  * <p>Note the semantic differences between an operator list state and a keyed list state  * (see {@link KeyedStateStore#getListState(ListStateDescriptor)}). Under the context of operator state,  * the list is a collection of state items that are independent from each other and eligible for redistribution  * across operator instances in case of changed operator parallelism. In other words, these state items are  * the finest granularity at which non-keyed state can be redistributed, and should not be correlated with  * each other.  *  * <p>The redistribution scheme of this list state upon operator rescaling is a round-robin pattern, such that  * the logical whole state (a concatenation of all the lists of state elements previously managed by each operator  * before the restore) is evenly divided into as many sublists as there are parallel operators.  *  * @param stateDescriptor The descriptor for this state, providing a name and serializer.  * @param <S> The generic type of the state  *  * @return A list for all state partitions.  */ ;/**  * Creates (or restores) a list state. Each state is registered under a unique name.  * The provided serializer is used to de/serialize the state in case of checkpointing (snapshot/restore).  *  * <p>Note the semantic differences between an operator list state and a keyed list state  * (see {@link KeyedStateStore#getListState(ListStateDescriptor)}). Under the context of operator state,  * the list is a collection of state items that are independent from each other and eligible for redistribution  * across operator instances in case of changed operator parallelism. In other words, these state items are  * the finest granularity at which non-keyed state can be redistributed, and should not be correlated with  * each other.  *  * <p>The redistribution scheme of this list state upon operator rescaling is a round-robin pattern, such that  * the logical whole state (a concatenation of all the lists of state elements previously managed by each operator  * before the restore) is evenly divided into as many sublists as there are parallel operators.  *  * @param stateDescriptor The descriptor for this state, providing a name and serializer.  * @param <S> The generic type of the state  *  * @return A list for all state partitions.  */ <S> ListState<S> getListState(ListStateDescriptor<S> stateDescriptor) throws Exception.
true;;1;1;/**  * Creates (or restores) a list state. Each state is registered under a unique name.  * The provided serializer is used to de/serialize the state in case of checkpointing (snapshot/restore).  *  * <p>Note the semantic differences between an operator list state and a keyed list state  * (see {@link KeyedStateStore#getListState(ListStateDescriptor)}). Under the context of operator state,  * the list is a collection of state items that are independent from each other and eligible for redistribution  * across operator instances in case of changed operator parallelism. In other words, these state items are  * the finest granularity at which non-keyed state can be redistributed, and should not be correlated with  * each other.  *  * <p>The redistribution scheme of this list state upon operator rescaling is a broadcast pattern, such that  * the logical whole state (a concatenation of all the lists of state elements previously managed by each operator  * before the restore) is restored to all parallel operators so that each of them will get the union of all state  * items before the restore.  *  * @param stateDescriptor The descriptor for this state, providing a name and serializer.  * @param <S> The generic type of the state  *  * @return A list for all state partitions.  */ ;/**  * Creates (or restores) a list state. Each state is registered under a unique name.  * The provided serializer is used to de/serialize the state in case of checkpointing (snapshot/restore).  *  * <p>Note the semantic differences between an operator list state and a keyed list state  * (see {@link KeyedStateStore#getListState(ListStateDescriptor)}). Under the context of operator state,  * the list is a collection of state items that are independent from each other and eligible for redistribution  * across operator instances in case of changed operator parallelism. In other words, these state items are  * the finest granularity at which non-keyed state can be redistributed, and should not be correlated with  * each other.  *  * <p>The redistribution scheme of this list state upon operator rescaling is a broadcast pattern, such that  * the logical whole state (a concatenation of all the lists of state elements previously managed by each operator  * before the restore) is restored to all parallel operators so that each of them will get the union of all state  * items before the restore.  *  * @param stateDescriptor The descriptor for this state, providing a name and serializer.  * @param <S> The generic type of the state  *  * @return A list for all state partitions.  */ <S> ListState<S> getUnionListState(ListStateDescriptor<S> stateDescriptor) throws Exception.
true;;0;1;/**  * Returns a set with the names of all currently registered states.  *  * @return set of names for all registered states.  */ ;/**  * Returns a set with the names of all currently registered states.  *  * @return set of names for all registered states.  */ Set<String> getRegisteredStateNames().
true;;0;1;/**  * Returns a set with the names of all currently registered broadcast states.  *  * @return set of names for all registered broadcast states.  */ ;/**  * Returns a set with the names of all currently registered broadcast states.  *  * @return set of names for all registered broadcast states.  */ Set<String> getRegisteredBroadcastStateNames().
true;;1;2;/**  * Creates (or restores) a list state. Each state is registered under a unique name.  * The provided serializer is used to de/serialize the state in case of checkpointing (snapshot/restore).  *  * <p>The items in the list are repartitionable by the system in case of changed operator parallelism.  *  * @param stateDescriptor The descriptor for this state, providing a name and serializer.  * @param <S> The generic type of the state  *  * @return A list for all state partitions.  *  * @deprecated since 1.3.0. This was deprecated as part of a refinement to the function names.  *             Please use {@link #getListState(ListStateDescriptor)} instead.  */ ;// ------------------------------------------------------------------------------------------- // Deprecated methods // ------------------------------------------------------------------------------------------- /**  * Creates (or restores) a list state. Each state is registered under a unique name.  * The provided serializer is used to de/serialize the state in case of checkpointing (snapshot/restore).  *  * <p>The items in the list are repartitionable by the system in case of changed operator parallelism.  *  * @param stateDescriptor The descriptor for this state, providing a name and serializer.  * @param <S> The generic type of the state  *  * @return A list for all state partitions.  *  * @deprecated since 1.3.0. This was deprecated as part of a refinement to the function names.  *             Please use {@link #getListState(ListStateDescriptor)} instead.  */ @Deprecated <S> ListState<S> getOperatorState(ListStateDescriptor<S> stateDescriptor) throws Exception.
true;;1;2;/**  * Creates a state of the given name that uses Java serialization to persist the state. The items in the list  * are repartitionable by the system in case of changed operator parallelism.  *  * <p>This is a simple convenience method. For more flexibility on how state serialization  * should happen, use the {@link #getListState(ListStateDescriptor)} method.  *  * @param stateName The name of state to create  * @return A list state using Java serialization to serialize state objects.  *  * @deprecated since 1.3.0. Using Java serialization for persisting state is not encouraged.  *             Please use {@link #getListState(ListStateDescriptor)} instead.  */ ;/**  * Creates a state of the given name that uses Java serialization to persist the state. The items in the list  * are repartitionable by the system in case of changed operator parallelism.  *  * <p>This is a simple convenience method. For more flexibility on how state serialization  * should happen, use the {@link #getListState(ListStateDescriptor)} method.  *  * @param stateName The name of state to create  * @return A list state using Java serialization to serialize state objects.  *  * @deprecated since 1.3.0. Using Java serialization for persisting state is not encouraged.  *             Please use {@link #getListState(ListStateDescriptor)} instead.  */ @Deprecated <T extends Serializable> ListState<T> getSerializableListState(String stateName) throws Exception.
