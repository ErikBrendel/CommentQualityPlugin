commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Create a Left value of Either  */ ;/**  * Create a Left value of Either  */ public static <L, R> Either<L, R> Left(L value) {     return new Left<L, R>(value). }
true;public,static;1;3;/**  * Create a Right value of Either  */ ;/**  * Create a Right value of Either  */ public static <L, R> Either<L, R> Right(R value) {     return new Right<L, R>(value). }
true;public,abstract;0;1;/**  * Retrieve the Left value of Either.  *  * @return the Left value  * @throws IllegalStateException  *             if called on a Right  */ ;/**  * Retrieve the Left value of Either.  *  * @return the Left value  * @throws IllegalStateException  *             if called on a Right  */ public abstract L left() throws IllegalStateException.
true;public,abstract;0;1;/**  * Retrieve the Right value of Either.  *  * @return the Right value  * @throws IllegalStateException  *             if called on a Left  */ ;/**  * Retrieve the Right value of Either.  *  * @return the Right value  * @throws IllegalStateException  *             if called on a Left  */ public abstract R right() throws IllegalStateException.
true;public,final;0;3;/**  * @return true if this is a Left value, false if this is a Right value  */ ;/**  * @return true if this is a Left value, false if this is a Right value  */ public final boolean isLeft() {     return getClass() == Left.class. }
true;public,final;0;3;/**  * @return true if this is a Right value, false if this is a Left value  */ ;/**  * @return true if this is a Right value, false if this is a Left value  */ public final boolean isRight() {     return getClass() == Right.class. }
false;public;0;4;;@Override public L left() {     return value. }
false;public;0;4;;@Override public R right() {     throw new IllegalStateException("Cannot retrieve Right value on a Left"). }
true;public;1;3;/**  * Sets the encapsulated value to another value  *  * @param value the new value of the encapsulated value  */ ;/**  * Sets the encapsulated value to another value  *  * @param value the new value of the encapsulated value  */ public void setValue(L value) {     this.value = value. }
false;public;1;8;;@Override public boolean equals(Object object) {     if (object instanceof Left<?, ?>) {         final Left<?, ?> other = (Left<?, ?>) object.         return value.equals(other.value).     }     return false. }
false;public;0;4;;@Override public int hashCode() {     return value.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "Left(" + value.toString() + ")". }
true;public,static;1;3;/**  * Creates a left value of {@link Either}  */ ;/**  * Creates a left value of {@link Either}  */ public static <L, R> Left<L, R> of(L left) {     return new Left<L, R>(left). }
false;public;0;4;;@Override public L left() {     throw new IllegalStateException("Cannot retrieve Left value on a Right"). }
false;public;0;4;;@Override public R right() {     return value. }
true;public;1;3;/**  * Sets the encapsulated value to another value  *  * @param value the new value of the encapsulated value  */ ;/**  * Sets the encapsulated value to another value  *  * @param value the new value of the encapsulated value  */ public void setValue(R value) {     this.value = value. }
false;public;1;8;;@Override public boolean equals(Object object) {     if (object instanceof Right<?, ?>) {         final Right<?, ?> other = (Right<?, ?>) object.         return value.equals(other.value).     }     return false. }
false;public;0;4;;@Override public int hashCode() {     return value.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "Right(" + value.toString() + ")". }
true;public,static;1;3;/**  * Creates a right value of {@link Either}  */ ;/**  * Creates a right value of {@link Either}  */ public static <L, R> Right<L, R> of(R right) {     return new Right<L, R>(right). }
true;public,static;2;13;/**  * Utility function for {@link EitherSerializer} to support object reuse.  *  * To support object reuse both subclasses of Either contain a reference to  * an instance of the other type. This method provides access to and  * initializes the cross-reference.  *  * @param input container for Left or Right value  * @param leftSerializer for creating an instance of the left type  * @param <L>  *            the type of Left  * @param <R>  *            the type of Right  * @return input if Left type else input's Left reference  */ ;/**  * Utility function for {@link EitherSerializer} to support object reuse.  *  * To support object reuse both subclasses of Either contain a reference to  * an instance of the other type. This method provides access to and  * initializes the cross-reference.  *  * @param input container for Left or Right value  * @param leftSerializer for creating an instance of the left type  * @param <L>  *            the type of Left  * @param <R>  *            the type of Right  * @return input if Left type else input's Left reference  */ @Internal public static <L, R> Left<L, R> obtainLeft(Either<L, R> input, TypeSerializer<L> leftSerializer) {     if (input.isLeft()) {         return (Left<L, R>) input.     } else {         Right<L, R> right = (Right<L, R>) input.         if (right.left == null) {             right.left = Left.of(leftSerializer.createInstance()).             right.left.right = right.         }         return right.left.     } }
true;public,static;2;13;/**  * Utility function for {@link EitherSerializer} to support object reuse.  *  * To support object reuse both subclasses of Either contain a reference to  * an instance of the other type. This method provides access to and  * initializes the cross-reference.  *  * @param input container for Left or Right value  * @param rightSerializer for creating an instance of the right type  * @param <L>  *            the type of Left  * @param <R>  *            the type of Right  * @return input if Right type else input's Right reference  */ ;/**  * Utility function for {@link EitherSerializer} to support object reuse.  *  * To support object reuse both subclasses of Either contain a reference to  * an instance of the other type. This method provides access to and  * initializes the cross-reference.  *  * @param input container for Left or Right value  * @param rightSerializer for creating an instance of the right type  * @param <L>  *            the type of Left  * @param <R>  *            the type of Right  * @return input if Right type else input's Right reference  */ @Internal public static <L, R> Right<L, R> obtainRight(Either<L, R> input, TypeSerializer<R> rightSerializer) {     if (input.isRight()) {         return (Right<L, R>) input.     } else {         Left<L, R> left = (Left<L, R>) input.         if (left.right == null) {             left.right = Right.of(rightSerializer.createInstance()).             left.right.left = left.         }         return left.right.     } }
