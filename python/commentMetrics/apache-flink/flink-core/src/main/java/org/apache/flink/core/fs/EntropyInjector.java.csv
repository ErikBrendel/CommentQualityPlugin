commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;14;/**  * Handles entropy injection across regular and entropy-aware file systems.  *  * <p>If the given file system is entropy-aware (a implements {@link EntropyInjectingFileSystem}),  * then this method replaces the entropy marker in the path with random characters.  * The entropy marker is defined by {@link EntropyInjectingFileSystem#getEntropyInjectionKey()}.  *  * <p>If the given file system does not implement {@code EntropyInjectingFileSystem},  * then this method delegates to {@link FileSystem#create(Path, WriteMode)} and  * returns the same path in the resulting {@code OutputStreamAndPath}.  */ ;/**  * Handles entropy injection across regular and entropy-aware file systems.  *  * <p>If the given file system is entropy-aware (a implements {@link EntropyInjectingFileSystem}),  * then this method replaces the entropy marker in the path with random characters.  * The entropy marker is defined by {@link EntropyInjectingFileSystem#getEntropyInjectionKey()}.  *  * <p>If the given file system does not implement {@code EntropyInjectingFileSystem},  * then this method delegates to {@link FileSystem#create(Path, WriteMode)} and  * returns the same path in the resulting {@code OutputStreamAndPath}.  */ public static OutputStreamAndPath createEntropyAware(FileSystem fs, Path path, WriteMode writeMode) throws IOException {     // check and possibly inject entropy into the path     final EntropyInjectingFileSystem efs = getEntropyFs(fs).     final Path processedPath = efs == null ? path : resolveEntropy(path, efs, true).     // create the stream on the original file system to let the safety net     // take its effect     final FSDataOutputStream out = fs.create(processedPath, writeMode).     return new OutputStreamAndPath(out, processedPath). }
true;public,static;2;16;/**  * Removes the entropy marker string from the path, if the given file system is an  * entropy-injecting file system (implements {@link EntropyInjectingFileSystem}) and  * the entropy marker key is present. Otherwise, this returns the path as is.  *  * @param path The path to filter.  * @return The path without the marker string.  */ ;/**  * Removes the entropy marker string from the path, if the given file system is an  * entropy-injecting file system (implements {@link EntropyInjectingFileSystem}) and  * the entropy marker key is present. Otherwise, this returns the path as is.  *  * @param path The path to filter.  * @return The path without the marker string.  */ public static Path removeEntropyMarkerIfPresent(FileSystem fs, Path path) {     final EntropyInjectingFileSystem efs = getEntropyFs(fs).     if (efs == null) {         return path.     } else {         try {             return resolveEntropy(path, efs, false).         } catch (IOException e) {             // rethrow to silence the compiler             throw new FlinkRuntimeException(e.getMessage(), e).         }     } }
false;private,static;1;18;;// ------------------------------------------------------------------------ @Nullable private static EntropyInjectingFileSystem getEntropyFs(FileSystem fs) {     if (fs instanceof EntropyInjectingFileSystem) {         return (EntropyInjectingFileSystem) fs.     } else if (fs instanceof SafetyNetWrapperFileSystem) {         FileSystem delegate = ((SafetyNetWrapperFileSystem) fs).getWrappedDelegate().         if (delegate instanceof EntropyInjectingFileSystem) {             return (EntropyInjectingFileSystem) delegate.         } else {             return null.         }     } else {         return null.     } }
false;static;3;41;;@VisibleForTesting static Path resolveEntropy(Path path, EntropyInjectingFileSystem efs, boolean injectEntropy) throws IOException {     final String entropyInjectionKey = efs.getEntropyInjectionKey().     if (entropyInjectionKey == null) {         return path.     } else {         final URI originalUri = path.toUri().         final String checkpointPath = originalUri.getPath().         final int indexOfKey = checkpointPath.indexOf(entropyInjectionKey).         if (indexOfKey == -1) {             return path.         } else {             final StringBuilder buffer = new StringBuilder(checkpointPath.length()).             buffer.append(checkpointPath, 0, indexOfKey).             if (injectEntropy) {                 buffer.append(efs.generateEntropy()).             }             buffer.append(checkpointPath, indexOfKey + entropyInjectionKey.length(), checkpointPath.length()).             final String rewrittenPath = buffer.toString().             try {                 return new Path(new URI(originalUri.getScheme(), originalUri.getAuthority(), rewrittenPath, originalUri.getQuery(), originalUri.getFragment()).normalize()).             } catch (URISyntaxException e) {                 // this could only happen if the injected entropy string contains invalid characters                 throw new IOException("URI format error while processing path for entropy injection", e).             }         }     } }
