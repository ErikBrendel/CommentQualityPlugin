commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int getCurrentVersion() {     return VERSION. }
false;public;1;4;;@Override public void writeSnapshot(DataOutputView out) throws IOException {     snapshotData.writeSnapshotData(out). }
false;public;3;4;;@Override public void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     this.snapshotData = createFrom(in, userCodeClassLoader). }
false;public;0;8;;@Override public TypeSerializer<T> restoreSerializer() {     return new KryoSerializer<>(snapshotData.getTypeClass(), snapshotData.getDefaultKryoSerializers().unwrapOptionals(), snapshotData.getDefaultKryoSerializerClasses().unwrapOptionals(), snapshotData.getKryoRegistrations().unwrapOptionals()). }
false;public;1;11;;@Override public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializer<T> newSerializer) {     if (!(newSerializer instanceof KryoSerializer)) {         return TypeSerializerSchemaCompatibility.incompatible().     }     KryoSerializer<T> kryoSerializer = (KryoSerializer<T>) newSerializer.     if (kryoSerializer.getType() != snapshotData.getTypeClass()) {         return TypeSerializerSchemaCompatibility.incompatible().     }     return resolveSchemaCompatibility(kryoSerializer). }
false;private;1;37;;private TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(KryoSerializer<T> newSerializer) {     // merge the default serializers     final MergeResult<Class<?>, SerializableSerializer<?>> reconfiguredDefaultKryoSerializers = mergeRightIntoLeft(snapshotData.getDefaultKryoSerializers(), optionalMapOf(newSerializer.getDefaultKryoSerializers(), Class::getName)).     if (reconfiguredDefaultKryoSerializers.hasMissingKeys()) {         logMissingKeys(reconfiguredDefaultKryoSerializers).         return TypeSerializerSchemaCompatibility.incompatible().     }     // merge default serializer classes     final MergeResult<Class<?>, Class<? extends Serializer<?>>> reconfiguredDefaultKryoSerializerClasses = mergeRightIntoLeft(snapshotData.getDefaultKryoSerializerClasses(), optionalMapOf(newSerializer.getDefaultKryoSerializerClasses(), Class::getName)).     if (reconfiguredDefaultKryoSerializerClasses.hasMissingKeys()) {         logMissingKeys(reconfiguredDefaultKryoSerializerClasses).         return TypeSerializerSchemaCompatibility.incompatible().     }     // merge registration     final MergeResult<String, KryoRegistration> reconfiguredRegistrations = mergeRightIntoLeft(snapshotData.getKryoRegistrations(), optionalMapOf(newSerializer.getKryoRegistrations(), Function.identity())).     if (reconfiguredRegistrations.hasMissingKeys()) {         logMissingKeys(reconfiguredRegistrations).         return TypeSerializerSchemaCompatibility.incompatible().     }     // there are no missing keys, now we have to decide whether we are compatible as-is or we require reconfiguration.     return resolveSchemaCompatibility(reconfiguredDefaultKryoSerializers, reconfiguredDefaultKryoSerializerClasses, reconfiguredRegistrations). }
false;private;3;21;;private TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(MergeResult<Class<?>, SerializableSerializer<?>> reconfiguredDefaultKryoSerializers, MergeResult<Class<?>, Class<? extends Serializer<?>>> reconfiguredDefaultKryoSerializerClasses, MergeResult<String, KryoRegistration> reconfiguredRegistrations) {     if (reconfiguredDefaultKryoSerializers.isOrderedSubset() && reconfiguredDefaultKryoSerializerClasses.isOrderedSubset() && reconfiguredRegistrations.isOrderedSubset()) {         return TypeSerializerSchemaCompatibility.compatibleAsIs().     }     // reconfigure a new KryoSerializer     KryoSerializer<T> reconfiguredSerializer = new KryoSerializer<>(snapshotData.getTypeClass(), reconfiguredDefaultKryoSerializers.getMerged(), reconfiguredDefaultKryoSerializerClasses.getMerged(), reconfiguredRegistrations.getMerged()).     return TypeSerializerSchemaCompatibility.compatibleWithReconfiguredSerializer(reconfiguredSerializer). }
false;private;1;5;;private void logMissingKeys(MergeResult<?, ?> mergeResult) {     mergeResult.missingKeys().forEach(key -> LOG.warn("The Kryo registration for a previously registered class {} does not have a " + "proper serializer, because its previous serializer cannot be loaded or is no " + "longer valid but a new serializer is not available", key)). }
