commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override @PublicEvolving public int getArity() {     return 1. }
false;public;0;5;;@Override @PublicEvolving public int getTotalFields() {     return 1. }
false;public;0;5;;@Override @PublicEvolving public Class<T> getTypeClass() {     return this.type. }
false;public;0;5;;@Override @PublicEvolving public boolean isBasicType() {     return false. }
false;public;0;6;;@PublicEvolving public boolean isBasicValueType() {     return type.equals(StringValue.class) || type.equals(ByteValue.class) || type.equals(ShortValue.class) || type.equals(CharValue.class) || type.equals(DoubleValue.class) || type.equals(FloatValue.class) || type.equals(IntValue.class) || type.equals(LongValue.class) || type.equals(NullValue.class) || type.equals(BooleanValue.class). }
false;public;0;5;;@Override @PublicEvolving public boolean isTupleType() {     return false. }
false;public;0;5;;@Override @PublicEvolving public boolean isKeyType() {     return Comparable.class.isAssignableFrom(type). }
false;public;1;41;;@Override @SuppressWarnings("unchecked") @PublicEvolving public TypeSerializer<T> createSerializer(ExecutionConfig executionConfig) {     if (BooleanValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) BooleanValueSerializer.INSTANCE.     } else if (ByteValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) ByteValueSerializer.INSTANCE.     } else if (CharValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) CharValueSerializer.INSTANCE.     } else if (DoubleValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) DoubleValueSerializer.INSTANCE.     } else if (FloatValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) FloatValueSerializer.INSTANCE.     } else if (IntValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) IntValueSerializer.INSTANCE.     } else if (LongValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) LongValueSerializer.INSTANCE.     } else if (NullValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) NullValueSerializer.INSTANCE.     } else if (ShortValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) ShortValueSerializer.INSTANCE.     } else if (StringValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) StringValueSerializer.INSTANCE.     } else if (CopyableValue.class.isAssignableFrom(type)) {         return (TypeSerializer<T>) createCopyableValueSerializer(type.asSubclass(CopyableValue.class)).     } else {         return new ValueSerializer<T>(type).     } }
false;public;2;45;;@SuppressWarnings({ "unchecked", "rawtypes" }) @Override @PublicEvolving public TypeComparator<T> createComparator(boolean sortOrderAscending, ExecutionConfig executionConfig) {     if (!isKeyType()) {         throw new RuntimeException("The type " + type.getName() + " is not Comparable.").     }     if (BooleanValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) new BooleanValueComparator(sortOrderAscending).     } else if (ByteValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) new ByteValueComparator(sortOrderAscending).     } else if (CharValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) new CharValueComparator(sortOrderAscending).     } else if (DoubleValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) new DoubleValueComparator(sortOrderAscending).     } else if (FloatValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) new FloatValueComparator(sortOrderAscending).     } else if (IntValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) new IntValueComparator(sortOrderAscending).     } else if (LongValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) new LongValueComparator(sortOrderAscending).     } else if (NullValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) NullValueComparator.getInstance().     } else if (ShortValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) new ShortValueComparator(sortOrderAscending).     } else if (StringValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) new StringValueComparator(sortOrderAscending).     } else if (CopyableValue.class.isAssignableFrom(type)) {         return (TypeComparator<T>) new CopyableValueComparator(sortOrderAscending, type).     } else {         return (TypeComparator<T>) new ValueComparator(sortOrderAscending, type).     } }
true;private,static;1;3;// utility method to summon the necessary bound ;// utility method to summon the necessary bound private static <X extends CopyableValue<X>> CopyableValueSerializer<X> createCopyableValueSerializer(Class<X> clazz) {     return new CopyableValueSerializer<X>(clazz). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public int hashCode() {     return this.type.hashCode(). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (obj instanceof ValueTypeInfo) {         @SuppressWarnings("unchecked")         ValueTypeInfo<T> valueTypeInfo = (ValueTypeInfo<T>) obj.         return valueTypeInfo.canEqual(this) && type == valueTypeInfo.type.     } else {         return false.     } }
false;public;1;4;;@Override public boolean canEqual(Object obj) {     return obj instanceof ValueTypeInfo. }
false;public;0;4;;@Override public String toString() {     return "ValueType<" + type.getSimpleName() + ">". }
false;static;1;9;;// -------------------------------------------------------------------------------------------- @PublicEvolving static <X extends Value> TypeInformation<X> getValueTypeInfo(Class<X> typeClass) {     if (Value.class.isAssignableFrom(typeClass) && !typeClass.equals(Value.class)) {         return new ValueTypeInfo<X>(typeClass).     } else {         throw new InvalidTypesException("The given class is no subclass of " + Value.class.getName()).     } }
