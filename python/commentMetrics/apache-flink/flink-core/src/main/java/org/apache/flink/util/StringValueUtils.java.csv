commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;8;/**  * Converts the given <code>StringValue</code> into a lower case variant.  *  * @param string The string to convert to lower case.  */ ;/**  * Converts the given <code>StringValue</code> into a lower case variant.  *  * @param string The string to convert to lower case.  */ public static void toLowerCase(StringValue string) {     final char[] chars = string.getCharArray().     final int len = string.length().     for (int i = 0. i < len. i++) {         chars[i] = Character.toLowerCase(chars[i]).     } }
true;public,static;2;11;/**  * Replaces all non-word characters in a string by a given character. The only  * characters not replaced are the characters that qualify as word characters  * or digit characters with respect to {@link Character#isLetter(char)} or  * {@link Character#isDigit(char)}, as well as the underscore character.  *  * <p>This operation is intended to simplify strings for counting distinct words.  *  * @param string The string value to have the non-word characters replaced.  * @param replacement The character to use as the replacement.  */ ;/**  * Replaces all non-word characters in a string by a given character. The only  * characters not replaced are the characters that qualify as word characters  * or digit characters with respect to {@link Character#isLetter(char)} or  * {@link Character#isDigit(char)}, as well as the underscore character.  *  * <p>This operation is intended to simplify strings for counting distinct words.  *  * @param string The string value to have the non-word characters replaced.  * @param replacement The character to use as the replacement.  */ public static void replaceNonWordChars(StringValue string, char replacement) {     final char[] chars = string.getCharArray().     final int len = string.length().     for (int i = 0. i < len. i++) {         final char c = chars[i].         if (!(Character.isLetter(c) || Character.isDigit(c) || c == '_')) {             chars[i] = replacement.         }     } }
true;public;1;5;/**  * Sets the string to be tokenized and resets the state of the tokenizer.  *  * @param string The string value to be tokenized.  */ ;/**  * Sets the string to be tokenized and resets the state of the tokenizer.  *  * @param string The string value to be tokenized.  */ public void setStringToTokenize(StringValue string) {     this.toTokenize = string.     this.pos = 0.     this.limit = string.length(). }
true;public;1;22;/**  * Gets the next token from the string. If another token is available, the token is stored  * in the given target StringValue object.  *  * @param target The StringValue object to store the next token in.  * @return True, if there was another token, false if not.  */ ;/**  * Gets the next token from the string. If another token is available, the token is stored  * in the given target StringValue object.  *  * @param target The StringValue object to store the next token in.  * @return True, if there was another token, false if not.  */ public boolean next(StringValue target) {     final char[] data = this.toTokenize.getCharArray().     final int limit = this.limit.     int pos = this.pos.     // skip the delimiter     for (. pos < limit && Character.isWhitespace(data[pos]). pos++) {     }     if (pos >= limit) {         this.pos = pos.         return false.     }     final int start = pos.     for (. pos < limit && !Character.isWhitespace(data[pos]). pos++) {     }     this.pos = pos.     target.setValue(this.toTokenize, start, pos - start).     return true. }
