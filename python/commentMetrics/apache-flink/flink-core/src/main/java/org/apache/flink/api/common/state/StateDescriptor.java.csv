commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the name of this {@code StateDescriptor}.  */ ;// ------------------------------------------------------------------------ /**  * Returns the name of this {@code StateDescriptor}.  */ public String getName() {     return name. }
true;public;0;11;/**  * Returns the default value.  */ ;/**  * Returns the default value.  */ public T getDefaultValue() {     if (defaultValue != null) {         if (serializer != null) {             return serializer.copy(defaultValue).         } else {             throw new IllegalStateException("Serializer not yet initialized.").         }     } else {         return null.     } }
true;public;0;7;/**  * Returns the {@link TypeSerializer} that can be used to serialize the value in the state.  * Note that the serializer may initialized lazily and is only guaranteed to exist after  * calling {@link #initializeSerializerUnlessSet(ExecutionConfig)}.  */ ;/**  * Returns the {@link TypeSerializer} that can be used to serialize the value in the state.  * Note that the serializer may initialized lazily and is only guaranteed to exist after  * calling {@link #initializeSerializerUnlessSet(ExecutionConfig)}.  */ public TypeSerializer<T> getSerializer() {     if (serializer != null) {         return serializer.duplicate().     } else {         throw new IllegalStateException("Serializer not yet initialized.").     } }
true;public;1;10;/**  * Sets the name for queries of state created from this descriptor.  *  * <p>If a name is set, the created state will be published for queries  * during runtime. The name needs to be unique per job. If there is another  * state instance published under the same name, the job will fail during runtime.  *  * @param queryableStateName State name for queries (unique name per job)  * @throws IllegalStateException If queryable state name already set  */ ;/**  * Sets the name for queries of state created from this descriptor.  *  * <p>If a name is set, the created state will be published for queries  * during runtime. The name needs to be unique per job. If there is another  * state instance published under the same name, the job will fail during runtime.  *  * @param queryableStateName State name for queries (unique name per job)  * @throws IllegalStateException If queryable state name already set  */ public void setQueryable(String queryableStateName) {     Preconditions.checkArgument(ttlConfig.getUpdateType() == StateTtlConfig.UpdateType.Disabled, "Queryable state is currently not supported with TTL").     if (this.queryableStateName == null) {         this.queryableStateName = Preconditions.checkNotNull(queryableStateName, "Registration name").     } else {         throw new IllegalStateException("Queryable state name already set").     } }
true;public;0;4;/**  * Returns the queryable state name.  *  * @return Queryable state name or <code>null</code> if not set.  */ ;/**  * Returns the queryable state name.  *  * @return Queryable state name or <code>null</code> if not set.  */ @Nullable public String getQueryableStateName() {     return queryableStateName. }
true;public;0;3;/**  * Returns whether the state created from this descriptor is queryable.  *  * @return <code>true</code> if state is queryable, <code>false</code>  * otherwise.  */ ;/**  * Returns whether the state created from this descriptor is queryable.  *  * @return <code>true</code> if state is queryable, <code>false</code>  * otherwise.  */ public boolean isQueryable() {     return queryableStateName != null. }
true;public;1;8;/**  * Configures optional activation of state time-to-live (TTL).  *  * <p>State user value will expire, become unavailable and be cleaned up in storage  * depending on configured {@link StateTtlConfig}.  *  * @param ttlConfig configuration of state TTL  */ ;/**  * Configures optional activation of state time-to-live (TTL).  *  * <p>State user value will expire, become unavailable and be cleaned up in storage  * depending on configured {@link StateTtlConfig}.  *  * @param ttlConfig configuration of state TTL  */ public void enableTimeToLive(StateTtlConfig ttlConfig) {     Preconditions.checkNotNull(ttlConfig).     Preconditions.checkArgument(ttlConfig.getUpdateType() != StateTtlConfig.UpdateType.Disabled && queryableStateName == null, "Queryable state is currently not supported with TTL").     this.ttlConfig = ttlConfig. }
false;public;0;5;;@Nonnull @Internal public StateTtlConfig getTtlConfig() {     return ttlConfig. }
true;public;0;3;/**  * Checks whether the serializer has been initialized. Serializer initialization is lazy,  * to allow parametrization of serializers with an {@link ExecutionConfig} via  * {@link #initializeSerializerUnlessSet(ExecutionConfig)}.  *  * @return True if the serializers have been initialized, false otherwise.  */ ;// ------------------------------------------------------------------------ /**  * Checks whether the serializer has been initialized. Serializer initialization is lazy,  * to allow parametrization of serializers with an {@link ExecutionConfig} via  * {@link #initializeSerializerUnlessSet(ExecutionConfig)}.  *  * @return True if the serializers have been initialized, false otherwise.  */ public boolean isSerializerInitialized() {     return serializer != null. }
true;public;1;11;/**  * Initializes the serializer, unless it has been initialized before.  *  * @param executionConfig The execution config to use when creating the serializer.  */ ;/**  * Initializes the serializer, unless it has been initialized before.  *  * @param executionConfig The execution config to use when creating the serializer.  */ public void initializeSerializerUnlessSet(ExecutionConfig executionConfig) {     if (serializer == null) {         checkState(typeInfo != null, "no serializer and no type info").         // instantiate the serializer         serializer = typeInfo.createSerializer(executionConfig).         // we can drop the type info now, no longer needed         typeInfo = null.     } }
false;public,final;0;4;;// ------------------------------------------------------------------------ // Standard Utils // ------------------------------------------------------------------------ @Override public final int hashCode() {     return name.hashCode() + 31 * getClass().hashCode(). }
false;public,final;1;13;;@Override public final boolean equals(Object o) {     if (o == this) {         return true.     } else if (o != null && o.getClass() == this.getClass()) {         final StateDescriptor<?, ?> that = (StateDescriptor<?, ?>) o.         return this.name.equals(that.name).     } else {         return false.     } }
false;public;0;9;;@Override public String toString() {     return getClass().getSimpleName() + "{name=" + name + ", defaultValue=" + defaultValue + ", serializer=" + serializer + (isQueryable() ? ", queryableStateName=" + queryableStateName + "" : "") + '}'. }
false;public,abstract;0;1;;public abstract Type getType().
false;private;1;31;;// ------------------------------------------------------------------------ // Serialization // ------------------------------------------------------------------------ private void writeObject(final ObjectOutputStream out) throws IOException {     // write all the non-transient fields     out.defaultWriteObject().     // write the non-serializable default value field     if (defaultValue == null) {         // we don't have a default value         out.writeBoolean(false).     } else {         // we have a default value         out.writeBoolean(true).         byte[] serializedDefaultValue.         try (ByteArrayOutputStream baos = new ByteArrayOutputStream().             DataOutputViewStreamWrapper outView = new DataOutputViewStreamWrapper(baos)) {             TypeSerializer<T> duplicateSerializer = serializer.duplicate().             duplicateSerializer.serialize(defaultValue, outView).             outView.flush().             serializedDefaultValue = baos.toByteArray().         } catch (Exception e) {             throw new IOException("Unable to serialize default value of type " + defaultValue.getClass().getSimpleName() + ".", e).         }         out.writeInt(serializedDefaultValue.length).         out.write(serializedDefaultValue).     } }
false;private;1;25;;private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {     // read the non-transient fields     in.defaultReadObject().     // read the default value field     boolean hasDefaultValue = in.readBoolean().     if (hasDefaultValue) {         int size = in.readInt().         byte[] buffer = new byte[size].         in.readFully(buffer).         try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer).             DataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(bais)) {             defaultValue = serializer.deserialize(inView).         } catch (Exception e) {             throw new IOException("Unable to deserialize default value.", e).         }     } else {         defaultValue = null.     } }
