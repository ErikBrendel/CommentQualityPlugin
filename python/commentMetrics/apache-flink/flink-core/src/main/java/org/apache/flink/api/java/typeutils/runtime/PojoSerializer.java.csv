commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isImmutableType() {     return false. }
false;public;0;21;;@Override public PojoSerializer<T> duplicate() {     boolean stateful = false.     TypeSerializer<?>[] duplicateFieldSerializers = new TypeSerializer[fieldSerializers.length].     for (int i = 0. i < fieldSerializers.length. i++) {         duplicateFieldSerializers[i] = fieldSerializers[i].duplicate().         if (duplicateFieldSerializers[i] != fieldSerializers[i]) {             // at least one of them is stateful             stateful = true.         }     }     if (!stateful) {         // as a small memory optimization, we can share the same object between instances         duplicateFieldSerializers = fieldSerializers.     }     // we must create a new instance, otherwise the subclassSerializerCache can create concurrency problems     return new PojoSerializer<>(clazz, duplicateFieldSerializers, fields, executionConfig). }
false;public;0;14;;@Override public T createInstance() {     if (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {         return null.     }     try {         T t = clazz.newInstance().         initializeFields(t).         return t.     } catch (Exception e) {         throw new RuntimeException("Cannot instantiate class.", e).     } }
false;protected;1;11;;protected void initializeFields(T t) {     for (int i = 0. i < numFields. i++) {         if (fields[i] != null) {             try {                 fields[i].set(t, fieldSerializers[i].createInstance()).             } catch (IllegalAccessException e) {                 throw new RuntimeException("Cannot initialize fields.", e).             }         }     } }
false;public;1;40;;@Override @SuppressWarnings({ "unchecked", "rawtypes" }) public T copy(T from) {     if (from == null) {         return null.     }     Class<?> actualType = from.getClass().     if (actualType == clazz) {         T target.         try {             target = (T) from.getClass().newInstance().         } catch (Throwable t) {             throw new RuntimeException("Cannot instantiate class.", t).         }         // no subclass         try {             for (int i = 0. i < numFields. i++) {                 if (fields[i] != null) {                     Object value = fields[i].get(from).                     if (value != null) {                         Object copy = fieldSerializers[i].copy(value).                         fields[i].set(target, copy).                     } else {                         fields[i].set(target, null).                     }                 }             }         } catch (IllegalAccessException e) {             throw new RuntimeException("Error during POJO copy, this should not happen since we check the fields before.").         }         return target.     } else {         // subclass         TypeSerializer subclassSerializer = getSubclassSerializer(actualType).         return (T) subclassSerializer.copy(from).     } }
false;public;2;42;;@Override @SuppressWarnings({ "unchecked", "rawtypes" }) public T copy(T from, T reuse) {     if (from == null) {         return null.     }     Class<?> actualType = from.getClass().     if (reuse == null || actualType != reuse.getClass()) {         // cannot reuse, do a non-reuse copy         return copy(from).     }     if (actualType == clazz) {         try {             for (int i = 0. i < numFields. i++) {                 if (fields[i] != null) {                     Object value = fields[i].get(from).                     if (value != null) {                         Object reuseValue = fields[i].get(reuse).                         Object copy.                         if (reuseValue != null) {                             copy = fieldSerializers[i].copy(value, reuseValue).                         } else {                             copy = fieldSerializers[i].copy(value).                         }                         fields[i].set(reuse, copy).                     } else {                         fields[i].set(reuse, null).                     }                 }             }         } catch (IllegalAccessException e) {             throw new RuntimeException("Error during POJO copy, this should not happen since we check the fields before.", e).         }     } else {         TypeSerializer subclassSerializer = getSubclassSerializer(actualType).         reuse = (T) subclassSerializer.copy(from, reuse).     }     return reuse. }
false;public;0;4;;@Override public int getLength() {     return -1. }
false;public;2;59;;@Override @SuppressWarnings({ "unchecked", "rawtypes" }) public void serialize(T value, DataOutputView target) throws IOException {     int flags = 0.     // handle null values     if (value == null) {         flags |= IS_NULL.         target.writeByte(flags).         return.     }     Integer subclassTag = -1.     Class<?> actualClass = value.getClass().     TypeSerializer subclassSerializer = null.     if (clazz != actualClass) {         subclassTag = registeredClasses.get(actualClass).         if (subclassTag != null) {             flags |= IS_TAGGED_SUBCLASS.             subclassSerializer = registeredSerializers[subclassTag].         } else {             flags |= IS_SUBCLASS.             subclassSerializer = getSubclassSerializer(actualClass).         }     } else {         flags |= NO_SUBCLASS.     }     target.writeByte(flags).     // if its a registered subclass, write the class tag id, otherwise write the full classname     if ((flags & IS_SUBCLASS) != 0) {         target.writeUTF(actualClass.getName()).     } else if ((flags & IS_TAGGED_SUBCLASS) != 0) {         target.writeByte(subclassTag).     }     // otherwise serialize each field with our field serializers     if ((flags & NO_SUBCLASS) != 0) {         try {             for (int i = 0. i < numFields. i++) {                 Object o = (fields[i] != null) ? fields[i].get(value) : null.                 if (o == null) {                     // null field handling                     target.writeBoolean(true).                 } else {                     target.writeBoolean(false).                     fieldSerializers[i].serialize(o, target).                 }             }         } catch (IllegalAccessException e) {             throw new RuntimeException("Error during POJO copy, this should not happen since we check the fields before.", e).         }     } else {         // subclass         if (subclassSerializer != null) {             subclassSerializer.serialize(value, target).         }     } }
false;public;1;62;;@Override @SuppressWarnings({ "unchecked", "rawtypes" }) public T deserialize(DataInputView source) throws IOException {     int flags = source.readByte().     if ((flags & IS_NULL) != 0) {         return null.     }     T target.     Class<?> actualSubclass = null.     TypeSerializer subclassSerializer = null.     if ((flags & IS_SUBCLASS) != 0) {         String subclassName = source.readUTF().         try {             actualSubclass = Class.forName(subclassName, true, cl).         } catch (ClassNotFoundException e) {             throw new RuntimeException("Cannot instantiate class.", e).         }         subclassSerializer = getSubclassSerializer(actualSubclass).         target = (T) subclassSerializer.createInstance().         // also initialize fields for which the subclass serializer is not responsible         initializeFields(target).     } else if ((flags & IS_TAGGED_SUBCLASS) != 0) {         int subclassTag = source.readByte().         subclassSerializer = registeredSerializers[subclassTag].         target = (T) subclassSerializer.createInstance().         // also initialize fields for which the subclass serializer is not responsible         initializeFields(target).     } else {         target = createInstance().     }     if ((flags & NO_SUBCLASS) != 0) {         try {             for (int i = 0. i < numFields. i++) {                 boolean isNull = source.readBoolean().                 if (fields[i] != null) {                     if (isNull) {                         fields[i].set(target, null).                     } else {                         Object field = fieldSerializers[i].deserialize(source).                         fields[i].set(target, field).                     }                 } else if (!isNull) {                     // read and dump a pre-existing field value                     fieldSerializers[i].deserialize(source).                 }             }         } catch (IllegalAccessException e) {             throw new RuntimeException("Error during POJO copy, this should not happen since we check the fields before.", e).         }     } else {         if (subclassSerializer != null) {             target = (T) subclassSerializer.deserialize(target, source).         }     }     return target. }
false;public;2;79;;@Override @SuppressWarnings({ "unchecked", "rawtypes" }) public T deserialize(T reuse, DataInputView source) throws IOException {     // handle null values     int flags = source.readByte().     if ((flags & IS_NULL) != 0) {         return null.     }     Class<?> subclass = null.     TypeSerializer subclassSerializer = null.     if ((flags & IS_SUBCLASS) != 0) {         String subclassName = source.readUTF().         try {             subclass = Class.forName(subclassName, true, cl).         } catch (ClassNotFoundException e) {             throw new RuntimeException("Cannot instantiate class.", e).         }         subclassSerializer = getSubclassSerializer(subclass).         if (reuse == null || subclass != reuse.getClass()) {             // cannot reuse             reuse = (T) subclassSerializer.createInstance().             // also initialize fields for which the subclass serializer is not responsible             initializeFields(reuse).         }     } else if ((flags & IS_TAGGED_SUBCLASS) != 0) {         int subclassTag = source.readByte().         subclassSerializer = registeredSerializers[subclassTag].         if (reuse == null || ((PojoSerializer) subclassSerializer).clazz != reuse.getClass()) {             // cannot reuse             reuse = (T) subclassSerializer.createInstance().             // also initialize fields for which the subclass serializer is not responsible             initializeFields(reuse).         }     } else {         if (reuse == null || clazz != reuse.getClass()) {             reuse = createInstance().         }     }     if ((flags & NO_SUBCLASS) != 0) {         try {             for (int i = 0. i < numFields. i++) {                 boolean isNull = source.readBoolean().                 if (fields[i] != null) {                     if (isNull) {                         fields[i].set(reuse, null).                     } else {                         Object field.                         Object reuseField = fields[i].get(reuse).                         if (reuseField != null) {                             field = fieldSerializers[i].deserialize(reuseField, source).                         } else {                             field = fieldSerializers[i].deserialize(source).                         }                         fields[i].set(reuse, field).                     }                 } else if (!isNull) {                     // read and dump a pre-existing field value                     fieldSerializers[i].deserialize(source).                 }             }         } catch (IllegalAccessException e) {             throw new RuntimeException("Error during POJO copy, this should not happen since we check the fields before.", e).         }     } else {         if (subclassSerializer != null) {             reuse = (T) subclassSerializer.deserialize(reuse, source).         }     }     return reuse. }
false;public;2;42;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     // copy the flags     int flags = source.readByte().     target.writeByte(flags).     if ((flags & IS_NULL) != 0) {         // is a null value, nothing further to copy         return.     }     TypeSerializer<?> subclassSerializer = null.     if ((flags & IS_SUBCLASS) != 0) {         String className = source.readUTF().         target.writeUTF(className).         try {             Class<?> subclass = Class.forName(className, true, Thread.currentThread().getContextClassLoader()).             subclassSerializer = getSubclassSerializer(subclass).         } catch (ClassNotFoundException e) {             throw new RuntimeException("Cannot instantiate class.", e).         }     } else if ((flags & IS_TAGGED_SUBCLASS) != 0) {         int subclassTag = source.readByte().         target.writeByte(subclassTag).         subclassSerializer = registeredSerializers[subclassTag].     }     if ((flags & NO_SUBCLASS) != 0) {         for (int i = 0. i < numFields. i++) {             boolean isNull = source.readBoolean().             target.writeBoolean(isNull).             if (!isNull) {                 fieldSerializers[i].copy(source, target).             }         }     } else {         if (subclassSerializer != null) {             subclassSerializer.copy(source, target).         }     } }
false;public;0;5;;@Override public int hashCode() {     return 31 * (31 * Arrays.hashCode(fieldSerializers) + Arrays.hashCode(registeredSerializers)) + Objects.hash(clazz, numFields, registeredClasses). }
false;public;1;14;;@Override public boolean equals(Object obj) {     if (obj instanceof PojoSerializer) {         PojoSerializer<?> other = (PojoSerializer<?>) obj.         return clazz == other.clazz && Arrays.equals(fieldSerializers, other.fieldSerializers) && Arrays.equals(registeredSerializers, other.registeredSerializers) && numFields == other.numFields && registeredClasses.equals(other.registeredClasses).     } else {         return false.     } }
false;public;0;10;;// -------------------------------------------------------------------------------------------- // Serializer configuration snapshotting & compatibility // -------------------------------------------------------------------------------------------- @Override public PojoSerializerSnapshot<T> snapshotConfiguration() {     return buildSnapshot(clazz, registeredClasses, registeredSerializers, fields, fieldSerializers, subclassSerializerCache). }
true;public;1;22;/**  * This legacy snapshot delegates compatibility checks to the {@link PojoSerializerSnapshot}.  */ ;/**  * This legacy snapshot delegates compatibility checks to the {@link PojoSerializerSnapshot}.  */ @Override public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializer<T> newSerializer) {     LinkedHashMap<String, TypeSerializerSnapshot<?>> legacyFieldSerializerSnapshots = preprocessLegacySerializerSnapshotTuples(fieldToSerializerConfigSnapshot).     int numFields = legacyFieldSerializerSnapshots.size().     ArrayList<Field> fields = new ArrayList<>(numFields).     ArrayList<TypeSerializerSnapshot<?>> fieldSerializerSnapshots = new ArrayList<>(numFields).     legacyFieldSerializerSnapshots.forEach((fieldName, fieldSerializerSnapshot) -> {         fields.add(PojoFieldUtils.getField(fieldName, getTypeClass())).         fieldSerializerSnapshots.add(fieldSerializerSnapshot).     }).     PojoSerializerSnapshot<T> newSnapshot = new PojoSerializerSnapshot<>(getTypeClass(), fields.toArray(new Field[numFields]), fieldSerializerSnapshots.toArray(new TypeSerializerSnapshot[numFields]), preprocessLegacySerializerSnapshotTuples(registeredSubclassesToSerializerConfigSnapshots), preprocessLegacySerializerSnapshotTuples(nonRegisteredSubclassesToSerializerConfigSnapshots)).     return newSnapshot.resolveSchemaCompatibility(newSerializer). }
false;private,static;1;21;;@SuppressWarnings("unchecked") private static <K> LinkedHashMap<K, TypeSerializerSnapshot<?>> preprocessLegacySerializerSnapshotTuples(Map<K, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> originalMap) {     LinkedHashMap<K, TypeSerializerSnapshot<?>> converted = new LinkedHashMap<>(originalMap.size()).     originalMap.forEach((key, serializerSnapshotTuple) -> {         TypeSerializer<?> serializer = serializerSnapshotTuple.f0.         TypeSerializerSnapshot<?> snapshot = serializerSnapshotTuple.f1.         if (snapshot instanceof TypeSerializerConfigSnapshot) {             ((TypeSerializerConfigSnapshot) snapshot).setPriorSerializer(serializer).         }         if (serializer instanceof LegacySerializerSnapshotTransformer) {             snapshot = ((LegacySerializerSnapshotTransformer) serializer).transformLegacySerializerSnapshot(snapshot).         }         converted.put(key, snapshot).     }).     return converted. }
false;public;1;66;;@Override public void write(DataOutputView out) throws IOException {     super.write(out).     try (ByteArrayOutputStreamWithPos outWithPos = new ByteArrayOutputStreamWithPos().         DataOutputViewStreamWrapper outViewWrapper = new DataOutputViewStreamWrapper(outWithPos)) {         // --- write fields and their serializers, in order         out.writeInt(fieldToSerializerConfigSnapshot.size()).         for (Map.Entry<String, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> entry : fieldToSerializerConfigSnapshot.entrySet()) {             outViewWrapper.writeUTF(entry.getKey()).             out.writeInt(outWithPos.getPosition()).             if (!ignoreTypeSerializerSerialization) {                 TypeSerializerSerializationUtil.writeSerializer(outViewWrapper, entry.getValue().f0).             }             out.writeInt(outWithPos.getPosition()).             TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(outViewWrapper, (TypeSerializerSnapshot) entry.getValue().f1, entry.getValue().f0).         }         // --- write registered subclasses and their serializers, in registration order         out.writeInt(registeredSubclassesToSerializerConfigSnapshots.size()).         for (Map.Entry<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> entry : registeredSubclassesToSerializerConfigSnapshots.entrySet()) {             outViewWrapper.writeUTF(entry.getKey().getName()).             out.writeInt(outWithPos.getPosition()).             if (!ignoreTypeSerializerSerialization) {                 TypeSerializerSerializationUtil.writeSerializer(outViewWrapper, entry.getValue().f0).             }             out.writeInt(outWithPos.getPosition()).             TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(outViewWrapper, (TypeSerializerSnapshot) entry.getValue().f1, entry.getValue().f0).         }         // --- write snapshot of non-registered subclass serializer cache         out.writeInt(nonRegisteredSubclassesToSerializerConfigSnapshots.size()).         for (Map.Entry<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> entry : nonRegisteredSubclassesToSerializerConfigSnapshots.entrySet()) {             outViewWrapper.writeUTF(entry.getKey().getName()).             out.writeInt(outWithPos.getPosition()).             if (!ignoreTypeSerializerSerialization) {                 TypeSerializerSerializationUtil.writeSerializer(outViewWrapper, entry.getValue().f0).             }             out.writeInt(outWithPos.getPosition()).             TypeSerializerSnapshotSerializationUtil.writeSerializerSnapshot(outViewWrapper, (TypeSerializerSnapshot) entry.getValue().f1, entry.getValue().f0).         }         out.writeInt(outWithPos.getPosition()).         out.write(outWithPos.getBuf(), 0, outWithPos.getPosition()).     } }
false;public;1;110;;@Override public void read(DataInputView in) throws IOException {     super.read(in).     int numFields = in.readInt().     int[] fieldSerializerOffsets = new int[numFields * 2].     for (int i = 0. i < numFields. i++) {         fieldSerializerOffsets[i * 2] = in.readInt().         fieldSerializerOffsets[i * 2 + 1] = in.readInt().     }     int numRegisteredSubclasses = in.readInt().     int[] registeredSerializerOffsets = new int[numRegisteredSubclasses * 2].     for (int i = 0. i < numRegisteredSubclasses. i++) {         registeredSerializerOffsets[i * 2] = in.readInt().         registeredSerializerOffsets[i * 2 + 1] = in.readInt().     }     int numCachedSubclassSerializers = in.readInt().     int[] cachedSerializerOffsets = new int[numCachedSubclassSerializers * 2].     for (int i = 0. i < numCachedSubclassSerializers. i++) {         cachedSerializerOffsets[i * 2] = in.readInt().         cachedSerializerOffsets[i * 2 + 1] = in.readInt().     }     int totalBytes = in.readInt().     byte[] buffer = new byte[totalBytes].     in.readFully(buffer).     try (ByteArrayInputStreamWithPos inWithPos = new ByteArrayInputStreamWithPos(buffer).         DataInputViewStreamWrapper inViewWrapper = new DataInputViewStreamWrapper(inWithPos)) {         // --- read fields and their serializers, in order         this.fieldToSerializerConfigSnapshot = new LinkedHashMap<>(numFields).         String fieldName.         TypeSerializer<?> fieldSerializer.         TypeSerializerSnapshot fieldSerializerConfigSnapshot.         for (int i = 0. i < numFields. i++) {             fieldName = inViewWrapper.readUTF().             inWithPos.setPosition(fieldSerializerOffsets[i * 2]).             fieldSerializer = TypeSerializerSerializationUtil.tryReadSerializer(inViewWrapper, getUserCodeClassLoader(), true).             inWithPos.setPosition(fieldSerializerOffsets[i * 2 + 1]).             fieldSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(inViewWrapper, getUserCodeClassLoader(), fieldSerializer).             fieldToSerializerConfigSnapshot.put(fieldName, new Tuple2<>(fieldSerializer, fieldSerializerConfigSnapshot)).         }         // --- read registered subclasses and their serializers, in registration order         this.registeredSubclassesToSerializerConfigSnapshots = new LinkedHashMap<>(numRegisteredSubclasses).         String registeredSubclassname.         Class<?> registeredSubclass.         TypeSerializer<?> registeredSubclassSerializer.         TypeSerializerSnapshot registeredSubclassSerializerConfigSnapshot.         for (int i = 0. i < numRegisteredSubclasses. i++) {             registeredSubclassname = inViewWrapper.readUTF().             try {                 registeredSubclass = Class.forName(registeredSubclassname, true, getUserCodeClassLoader()).             } catch (ClassNotFoundException e) {                 throw new IOException("Cannot find requested class " + registeredSubclassname + " in classpath.", e).             }             inWithPos.setPosition(registeredSerializerOffsets[i * 2]).             registeredSubclassSerializer = TypeSerializerSerializationUtil.tryReadSerializer(inViewWrapper, getUserCodeClassLoader(), true).             inWithPos.setPosition(registeredSerializerOffsets[i * 2 + 1]).             registeredSubclassSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(inViewWrapper, getUserCodeClassLoader(), registeredSubclassSerializer).             this.registeredSubclassesToSerializerConfigSnapshots.put(registeredSubclass, new Tuple2<>(registeredSubclassSerializer, registeredSubclassSerializerConfigSnapshot)).         }         // --- read snapshot of non-registered subclass serializer cache         this.nonRegisteredSubclassesToSerializerConfigSnapshots = new HashMap<>(numCachedSubclassSerializers).         String cachedSubclassname.         Class<?> cachedSubclass.         TypeSerializer<?> cachedSubclassSerializer.         TypeSerializerSnapshot cachedSubclassSerializerConfigSnapshot.         for (int i = 0. i < numCachedSubclassSerializers. i++) {             cachedSubclassname = inViewWrapper.readUTF().             try {                 cachedSubclass = Class.forName(cachedSubclassname, true, getUserCodeClassLoader()).             } catch (ClassNotFoundException e) {                 throw new IOException("Cannot find requested class " + cachedSubclassname + " in classpath.", e).             }             inWithPos.setPosition(cachedSerializerOffsets[i * 2]).             cachedSubclassSerializer = TypeSerializerSerializationUtil.tryReadSerializer(inViewWrapper, getUserCodeClassLoader(), true).             inWithPos.setPosition(cachedSerializerOffsets[i * 2 + 1]).             cachedSubclassSerializerConfigSnapshot = TypeSerializerSnapshotSerializationUtil.readSerializerSnapshot(inViewWrapper, getUserCodeClassLoader(), cachedSubclassSerializer).             this.nonRegisteredSubclassesToSerializerConfigSnapshots.put(cachedSubclass, new Tuple2<>(cachedSubclassSerializer, cachedSubclassSerializerConfigSnapshot)).         }     } }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
false;public;0;3;;public LinkedHashMap<String, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> getFieldToSerializerConfigSnapshot() {     return fieldToSerializerConfigSnapshot. }
false;public;0;3;;public LinkedHashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> getRegisteredSubclassesToSerializerConfigSnapshots() {     return registeredSubclassesToSerializerConfigSnapshots. }
false;public;0;3;;public HashMap<Class<?>, Tuple2<TypeSerializer<?>, TypeSerializerSnapshot<?>>> getNonRegisteredSubclassesToSerializerConfigSnapshots() {     return nonRegisteredSubclassesToSerializerConfigSnapshots. }
false;public;1;8;;@Override public boolean equals(Object obj) {     return super.equals(obj) && (obj instanceof PojoSerializerConfigSnapshot) && fieldToSerializerConfigSnapshot.equals(((PojoSerializerConfigSnapshot) obj).getFieldToSerializerConfigSnapshot()) && registeredSubclassesToSerializerConfigSnapshots.equals(((PojoSerializerConfigSnapshot) obj).getRegisteredSubclassesToSerializerConfigSnapshots()) && nonRegisteredSubclassesToSerializerConfigSnapshots.equals(((PojoSerializerConfigSnapshot) obj).nonRegisteredSubclassesToSerializerConfigSnapshots). }
false;public;0;8;;@Override public int hashCode() {     return super.hashCode() + Objects.hash(fieldToSerializerConfigSnapshot, registeredSubclassesToSerializerConfigSnapshots, nonRegisteredSubclassesToSerializerConfigSnapshots). }
false;private;1;7;;// -------------------------------------------------------------------------------------------- private void writeObject(ObjectOutputStream out) throws IOException, ClassNotFoundException {     out.defaultWriteObject().     out.writeInt(fields.length).     for (Field field : fields) {         FieldSerializer.serializeField(field, out).     } }
false;private;1;14;;private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {     in.defaultReadObject().     int numFields = in.readInt().     fields = new Field[numFields].     for (int i = 0. i < numFields. i++) {         // the deserialized Field may be null if the field no longer exists in the POJO.         // in this case, when de-/serializing and copying instances using this serializer         // instance, the missing fields will simply be skipped         fields[i] = FieldSerializer.deserializeField(in).     }     cl = Thread.currentThread().getContextClassLoader().     subclassSerializerCache = new HashMap<Class<?>, TypeSerializer<?>>(). }
false;;0;3;;// -------------------------------------------------------------------------------------------- // Configuration access // -------------------------------------------------------------------------------------------- Class<T> getPojoClass() {     return clazz. }
false;;0;3;;Field[] getFields() {     return fields. }
false;;0;3;;TypeSerializer<?>[] getFieldSerializers() {     return fieldSerializers. }
false;;1;7;;TypeSerializer<?> getFieldSerializer(Field targetField) {     int fieldIndex = findField(targetField.getName()).     if (fieldIndex == -1) {         return null.     }     return fieldSerializers[fieldIndex]. }
false;;0;3;;ExecutionConfig getExecutionConfig() {     return executionConfig. }
false;;0;3;;LinkedHashMap<Class<?>, Integer> getRegisteredClasses() {     return registeredClasses. }
false;;0;3;;TypeSerializer<?>[] getRegisteredSerializers() {     return registeredSerializers. }
false;;0;5;;LinkedHashMap<Class<?>, TypeSerializer<?>> getBundledSubclassSerializerRegistry() {     final LinkedHashMap<Class<?>, TypeSerializer<?>> result = new LinkedHashMap<>(registeredClasses.size()).     registeredClasses.forEach((registeredClass, id) -> result.put(registeredClass, registeredSerializers[id])).     return result. }
false;;0;3;;Map<Class<?>, TypeSerializer<?>> getSubclassSerializerCache() {     return subclassSerializerCache. }
true;private,static;2;17;/**  * Extracts the subclasses of the base POJO class registered in the execution config.  */ ;// -------------------------------------------------------------------------------------------- // Utilities // -------------------------------------------------------------------------------------------- /**  * Extracts the subclasses of the base POJO class registered in the execution config.  */ private static LinkedHashSet<Class<?>> getRegisteredSubclassesFromExecutionConfig(Class<?> basePojoClass, ExecutionConfig executionConfig) {     LinkedHashSet<Class<?>> subclassesInRegistrationOrder = new LinkedHashSet<>(executionConfig.getRegisteredPojoTypes().size()).     for (Class<?> registeredClass : executionConfig.getRegisteredPojoTypes()) {         if (registeredClass.equals(basePojoClass)) {             continue.         }         if (!basePojoClass.isAssignableFrom(registeredClass)) {             continue.         }         subclassesInRegistrationOrder.add(registeredClass).     }     return subclassesInRegistrationOrder. }
true;private,static;1;11;/**  * Builds map of registered subclasses to their class tags.  * Class tags will be integers starting from 0, assigned incrementally with the order of provided subclasses.  */ ;/**  * Builds map of registered subclasses to their class tags.  * Class tags will be integers starting from 0, assigned incrementally with the order of provided subclasses.  */ private static LinkedHashMap<Class<?>, Integer> createRegisteredSubclassTags(LinkedHashSet<Class<?>> registeredSubclasses) {     final LinkedHashMap<Class<?>, Integer> classToTag = new LinkedHashMap<>().     int id = 0.     for (Class<?> registeredClass : registeredSubclasses) {         classToTag.put(registeredClass, id).         id++.     }     return classToTag. }
true;private,static;2;14;/**  * Creates an array of serializers for provided list of registered subclasses.  * Order of returned serializers will correspond to order of provided subclasses.  */ ;/**  * Creates an array of serializers for provided list of registered subclasses.  * Order of returned serializers will correspond to order of provided subclasses.  */ private static TypeSerializer<?>[] createRegisteredSubclassSerializers(LinkedHashSet<Class<?>> registeredSubclasses, ExecutionConfig executionConfig) {     final TypeSerializer<?>[] subclassSerializers = new TypeSerializer[registeredSubclasses.size()].     int i = 0.     for (Class<?> registeredClass : registeredSubclasses) {         subclassSerializers[i] = TypeExtractor.createTypeInfo(registeredClass).createSerializer(executionConfig).         i++.     }     return subclassSerializers. }
true;;1;8;/**  * Fetches cached serializer for a non-registered subclass.  * also creates the serializer if it doesn't exist yet.  *  * This method is also exposed to package-private access  * for testing purposes.  */ ;/**  * Fetches cached serializer for a non-registered subclass.  * also creates the serializer if it doesn't exist yet.  *  * This method is also exposed to package-private access  * for testing purposes.  */ TypeSerializer<?> getSubclassSerializer(Class<?> subclass) {     TypeSerializer<?> result = subclassSerializerCache.get(subclass).     if (result == null) {         result = createSubclassSerializer(subclass).         subclassSerializerCache.put(subclass, result).     }     return result. }
false;private;1;10;;private TypeSerializer<?> createSubclassSerializer(Class<?> subclass) {     TypeSerializer<?> serializer = TypeExtractor.createTypeInfo(subclass).createSerializer(executionConfig).     if (serializer instanceof PojoSerializer) {         PojoSerializer<?> subclassSerializer = (PojoSerializer<?>) serializer.         subclassSerializer.copyBaseFieldOrder(this).     }     return serializer. }
true;private;1;12;/**  * Finds and returns the order (0-based) of a POJO field.  * Returns -1 if the field does not exist for this POJO.  */ ;/**  * Finds and returns the order (0-based) of a POJO field.  * Returns -1 if the field does not exist for this POJO.  */ private int findField(String fieldName) {     int foundIndex = 0.     for (Field field : fields) {         if (field != null && fieldName.equals(field.getName())) {             return foundIndex.         }         foundIndex++.     }     return -1. }
false;private;1;5;;private void copyBaseFieldOrder(PojoSerializer<?> baseSerializer) { // do nothing for now, but in the future, adapt subclass serializer to have same // ordering as base class serializer so that binary comparison on base class fields // can work }
true;private,static;6;21;/**  * Build and return a snapshot of the serializer's parameters and currently cached serializers.  */ ;/**  * Build and return a snapshot of the serializer's parameters and currently cached serializers.  */ private static <T> PojoSerializerSnapshot<T> buildSnapshot(Class<T> pojoType, LinkedHashMap<Class<?>, Integer> registeredSubclassesToTags, TypeSerializer<?>[] registeredSubclassSerializers, Field[] fields, TypeSerializer<?>[] fieldSerializers, Map<Class<?>, TypeSerializer<?>> nonRegisteredSubclassSerializerCache) {     final LinkedHashMap<Class<?>, TypeSerializer<?>> subclassRegistry = new LinkedHashMap<>(registeredSubclassesToTags.size()).     for (Map.Entry<Class<?>, Integer> entry : registeredSubclassesToTags.entrySet()) {         subclassRegistry.put(entry.getKey(), registeredSubclassSerializers[entry.getValue()]).     }     return new PojoSerializerSnapshot<>(pojoType, fields, fieldSerializers, subclassRegistry, nonRegisteredSubclassSerializerCache). }
