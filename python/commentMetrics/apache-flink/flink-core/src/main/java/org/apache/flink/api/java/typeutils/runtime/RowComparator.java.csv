commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;// -------------------------------------------------------------------------------------------- // Comparator Methods // -------------------------------------------------------------------------------------------- @Override public void getFlatComparator(List<TypeComparator> flatComparators) {     for (NullAwareComparator<Object> c : comparators) {         Collections.addAll(flatComparators, c.getFlatComparators()).     } }
false;public;1;17;;@Override public int hash(Row record) {     int code = 0.     int i = 0.     try {         for (. i < keyPositions.length. i++) {             code *= TupleComparatorBase.HASH_SALT[i & 0x1F].             // element can be null             Object element = record.getField(keyPositions[i]).             code += comparators[i].hash(element).         }     } catch (IndexOutOfBoundsException e) {         throw new KeyFieldOutOfBoundsException(keyPositions[i]).     }     return code. }
false;public;1;13;;@Override public void setReference(Row toCompare) {     int i = 0.     try {         for (. i < keyPositions.length. i++) {             TypeComparator<Object> comparator = comparators[i].             Object element = toCompare.getField(keyPositions[i]).             // element can be null             comparator.setReference(element).         }     } catch (IndexOutOfBoundsException e) {         throw new KeyFieldOutOfBoundsException(keyPositions[i]).     } }
false;public;1;17;;@Override public boolean equalToReference(Row candidate) {     int i = 0.     try {         for (. i < keyPositions.length. i++) {             TypeComparator<Object> comparator = comparators[i].             // element can be null             Object element = candidate.getField(keyPositions[i]).             // check if reference is not equal             if (!comparator.equalToReference(element)) {                 return false.             }         }     } catch (IndexOutOfBoundsException e) {         throw new KeyFieldOutOfBoundsException(keyPositions[i]).     }     return true. }
false;public;1;16;;@Override public int compareToReference(TypeComparator<Row> referencedComparator) {     RowComparator other = (RowComparator) referencedComparator.     int i = 0.     try {         for (. i < keyPositions.length. i++) {             int cmp = comparators[i].compareToReference(other.comparators[i]).             if (cmp != 0) {                 return cmp.             }         }     } catch (IndexOutOfBoundsException e) {         throw new KeyFieldOutOfBoundsException(keyPositions[i]).     }     return 0. }
false;public;2;20;;@Override public int compare(Row first, Row second) {     int i = 0.     try {         for (. i < keyPositions.length. i++) {             int keyPos = keyPositions[i].             TypeComparator<Object> comparator = comparators[i].             // element can be null             Object firstElement = first.getField(keyPos).             // element can be null             Object secondElement = second.getField(keyPos).             int cmp = comparator.compare(firstElement, secondElement).             if (cmp != 0) {                 return cmp.             }         }     } catch (IndexOutOfBoundsException e) {         throw new KeyFieldOutOfBoundsException(keyPositions[i]).     }     return 0. }
false;public;2;65;;@Override public int compareSerialized(DataInputView firstSource, DataInputView secondSource) throws IOException {     int len = serializers.length.     int keyLen = keyPositions.length.     readIntoNullMask(arity, firstSource, nullMask1).     readIntoNullMask(arity, secondSource, nullMask2).     // deserialize     for (int i = 0. i < len. i++) {         TypeSerializer<Object> serializer = serializers[i].         // deserialize field 1         if (!nullMask1[i]) {             deserializedKeyFields1[i] = serializer.deserialize(deserializedKeyFields1[i], firstSource).         }         // deserialize field 2         if (!nullMask2[i]) {             deserializedKeyFields2[i] = serializer.deserialize(deserializedKeyFields2[i], secondSource).         }     }     // compare     for (int i = 0. i < keyLen. i++) {         int keyPos = keyPositions[i].         TypeComparator<Object> comparator = comparators[i].         boolean isNull1 = nullMask1[keyPos].         boolean isNull2 = nullMask2[keyPos].         int cmp = 0.         // both values are null -> equality         if (isNull1 && isNull2) {             cmp = 0.         } else // first value is null -> inequality         if (isNull1) {             cmp = comparator.compare(null, deserializedKeyFields2[keyPos]).         } else // second value is null -> inequality         if (isNull2) {             cmp = comparator.compare(deserializedKeyFields1[keyPos], null).         } else // no null values         {             cmp = comparator.compare(deserializedKeyFields1[keyPos], deserializedKeyFields2[keyPos]).         }         if (cmp != 0) {             return cmp.         }     }     return 0. }
false;public;0;4;;@Override public boolean supportsNormalizedKey() {     return numLeadingNormalizableKeys > 0. }
false;public;0;4;;@Override public boolean supportsSerializationWithKeyNormalization() {     return false. }
false;public;0;4;;@Override public int getNormalizeKeyLen() {     return normalizableKeyPrefixLen. }
false;public;1;6;;@Override public boolean isNormalizedKeyPrefixOnly(int keyBytes) {     return numLeadingNormalizableKeys < keyPositions.length || normalizableKeyPrefixLen == Integer.MAX_VALUE || normalizableKeyPrefixLen > keyBytes. }
false;public;4;19;;@Override public void putNormalizedKey(Row record, MemorySegment target, int offset, int numBytes) {     int bytesLeft = numBytes.     int currentOffset = offset.     for (int i = 0. i < numLeadingNormalizableKeys && bytesLeft > 0. i++) {         int len = normalizedKeyLengths[i].         len = bytesLeft >= len ? len : bytesLeft.         TypeComparator<Object> comparator = comparators[i].         // element can be null         Object element = record.getField(keyPositions[i]).         // write key         comparator.putNormalizedKey(element, target, currentOffset, len).         bytesLeft -= len.         currentOffset += len.     } }
false;public;2;5;;@Override public void writeWithKeyNormalization(Row record, DataOutputView target) throws IOException {     throw new UnsupportedOperationException("Record serialization with leading normalized keys not supported."). }
false;public;2;5;;@Override public Row readWithKeyDenormalization(Row reuse, DataInputView source) throws IOException {     throw new UnsupportedOperationException("Record deserialization with leading normalized keys not supported."). }
false;public;0;4;;@Override public boolean invertNormalizedKey() {     return invertNormKey. }
false;public;0;22;;@Override public TypeComparator<Row> duplicate() {     NullAwareComparator<?>[] comparatorsCopy = new NullAwareComparator<?>[comparators.length].     for (int i = 0. i < comparators.length. i++) {         comparatorsCopy[i] = (NullAwareComparator<?>) comparators[i].duplicate().     }     TypeSerializer<?>[] serializersCopy = new TypeSerializer<?>[serializers.length].     for (int i = 0. i < serializers.length. i++) {         serializersCopy[i] = serializers[i].duplicate().     }     return new RowComparator(arity, keyPositions, (NullAwareComparator<Object>[]) comparatorsCopy, (TypeSerializer<Object>[]) serializersCopy, normalizedKeyLengths, numLeadingNormalizableKeys, normalizableKeyPrefixLen, invertNormKey). }
false;public;3;10;;@Override public int extractKeys(Object record, Object[] target, int index) {     int len = comparators.length.     int localIndex = index.     for (int i = 0. i < len. i++) {         // element can be null         Object element = ((Row) record).getField(keyPositions[i]).         localIndex += comparators[i].extractKeys(element, target, localIndex).     }     return localIndex - index. }
false;private;0;7;;private Object[] instantiateDeserializationFields() {     Object[] newFields = new Object[serializers.length].     for (int i = 0. i < serializers.length. i++) {         newFields[i] = serializers[i].createInstance().     }     return newFields. }
true;private,static;2;55;/**  * @return creates auxiliary fields for normalized key support  */ ;/**  * @return creates auxiliary fields for normalized key support  */ private static Tuple4<int[], Integer, Integer, Boolean> createAuxiliaryFields(int[] keyPositions, NullAwareComparator<Object>[] comparators) {     int[] normalizedKeyLengths = new int[keyPositions.length].     int numLeadingNormalizableKeys = 0.     int normalizableKeyPrefixLen = 0.     boolean inverted = false.     for (int i = 0. i < keyPositions.length. i++) {         NullAwareComparator<Object> k = comparators[i].         // as long as the leading keys support normalized keys, we can build up the composite key         if (k.supportsNormalizedKey()) {             if (i == 0) {                 // the first comparator decides whether we need to invert the key direction                 inverted = k.invertNormalizedKey().             } else if (k.invertNormalizedKey() != inverted) {                 // normalized key                 return new Tuple4<>(normalizedKeyLengths, numLeadingNormalizableKeys, normalizableKeyPrefixLen, inverted).             }             numLeadingNormalizableKeys++.             int len = k.getNormalizeKeyLen().             if (len < 0) {                 throw new RuntimeException("Comparator " + k.getClass().getName() + " specifies an invalid length for the normalized key: " + len).             }             normalizedKeyLengths[i] = len.             normalizableKeyPrefixLen += len.             if (normalizableKeyPrefixLen < 0) {                 // overflow, which means we are out of budget for normalized key space anyways                 return new Tuple4<>(normalizedKeyLengths, numLeadingNormalizableKeys, Integer.MAX_VALUE, inverted).             }         } else {             return new Tuple4<>(normalizedKeyLengths, numLeadingNormalizableKeys, normalizableKeyPrefixLen, inverted).         }     }     return new Tuple4<>(normalizedKeyLengths, numLeadingNormalizableKeys, normalizableKeyPrefixLen, inverted). }
false;private,static;2;11;;private static NullAwareComparator<Object>[] makeNullAware(TypeComparator<Object>[] comparators, boolean[] orders) {     checkArgument(comparators.length == orders.length).     NullAwareComparator<?>[] result = new NullAwareComparator<?>[comparators.length].     for (int i = 0. i < comparators.length. i++) {         result[i] = new NullAwareComparator<Object>(comparators[i], orders[i]).     }     return (NullAwareComparator<Object>[]) result. }
