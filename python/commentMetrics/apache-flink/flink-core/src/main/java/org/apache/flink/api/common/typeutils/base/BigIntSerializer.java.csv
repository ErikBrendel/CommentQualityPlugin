commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean isImmutableType() {     return true. }
false;public;0;4;;@Override public BigInteger createInstance() {     return BigInteger.ZERO. }
false;public;1;4;;@Override public BigInteger copy(BigInteger from) {     return from. }
false;public;2;4;;@Override public BigInteger copy(BigInteger from, BigInteger reuse) {     return from. }
false;public;0;4;;@Override public int getLength() {     return -1. }
false;public;2;4;;@Override public void serialize(BigInteger record, DataOutputView target) throws IOException {     writeBigInteger(record, target). }
false;public;1;4;;@Override public BigInteger deserialize(DataInputView source) throws IOException {     return readBigInteger(source). }
false;public;2;4;;@Override public BigInteger deserialize(BigInteger reuse, DataInputView source) throws IOException {     return readBigInteger(source). }
false;public;2;4;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     copyBigInteger(source, target). }
false;public,static;2;26;;// -------------------------------------------------------------------------------------------- // Static Helpers for BigInteger Serialization // -------------------------------------------------------------------------------------------- public static void writeBigInteger(BigInteger record, DataOutputView target) throws IOException {     // null value support     if (record == null) {         target.writeInt(0).         return.     } else // only reference equality is checked because equals would be too expensive     if (record == BigInteger.ZERO) {         target.writeInt(1).         return.     } else if (record == BigInteger.ONE) {         target.writeInt(2).         return.     } else if (record == BigInteger.TEN) {         target.writeInt(3).         return.     }     // default     final byte[] bytes = record.toByteArray().     // the length we write is offset by four, because null and short-paths for ZERO, ONE, and TEN     target.writeInt(bytes.length + 4).     target.write(bytes). }
false;public,static;1;18;;public static BigInteger readBigInteger(DataInputView source) throws IOException {     final int len = source.readInt().     if (len < 4) {         switch(len) {             case 0:                 return null.             case 1:                 return BigInteger.ZERO.             case 2:                 return BigInteger.ONE.             case 3:                 return BigInteger.TEN.         }     }     final byte[] bytes = new byte[len - 4].     source.readFully(bytes).     return new BigInteger(bytes). }
false;public,static;2;8;;public static boolean copyBigInteger(DataInputView source, DataOutputView target) throws IOException {     final int len = source.readInt().     target.writeInt(len).     if (len > 4) {         target.write(source, len - 4).     }     // returns true if the copied record was null     return len == 0. }
false;public;0;4;;@Override public TypeSerializerSnapshot<BigInteger> snapshotConfiguration() {     return new BigIntSerializerSnapshot(). }
