commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Get the number of fields in the Row.  * @return The number of fields in the Row.  */ ;/**  * Get the number of fields in the Row.  * @return The number of fields in the Row.  */ public int getArity() {     return fields.length. }
true;public;1;3;/**  * Gets the field at the specified position.  * @param pos The position of the field, 0-based.  * @return The field at the specified position.  * @throws IndexOutOfBoundsException Thrown, if the position is negative, or equal to, or larger than the number of fields.  */ ;/**  * Gets the field at the specified position.  * @param pos The position of the field, 0-based.  * @return The field at the specified position.  * @throws IndexOutOfBoundsException Thrown, if the position is negative, or equal to, or larger than the number of fields.  */ public Object getField(int pos) {     return fields[pos]. }
true;public;2;3;/**  * Sets the field at the specified position.  *  * @param pos The position of the field, 0-based.  * @param value The value to be assigned to the field at the specified position.  * @throws IndexOutOfBoundsException Thrown, if the position is negative, or equal to, or larger than the number of fields.  */ ;/**  * Sets the field at the specified position.  *  * @param pos The position of the field, 0-based.  * @param value The value to be assigned to the field at the specified position.  * @throws IndexOutOfBoundsException Thrown, if the position is negative, or equal to, or larger than the number of fields.  */ public void setField(int pos, Object value) {     fields[pos] = value. }
false;public;0;11;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     for (int i = 0. i < fields.length. i++) {         if (i > 0) {             sb.append(",").         }         sb.append(StringUtils.arrayAwareToString(fields[i])).     }     return sb.toString(). }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     Row row = (Row) o.     return Arrays.deepEquals(fields, row.fields). }
false;public;0;4;;@Override public int hashCode() {     return Arrays.deepHashCode(fields). }
true;public,static;1;7;/**  * Creates a new Row and assigns the given values to the Row's fields.  * This is more convenient than using the constructor.  *  * <p>For example:  *  * <pre>  *     Row.of("hello", true, 1L).}  * </pre>  * instead of  * <pre>  *     Row row = new Row(3).  *     row.setField(0, "hello").  *     row.setField(1, true).  *     row.setField(2, 1L).  * </pre>  */ ;/**  * Creates a new Row and assigns the given values to the Row's fields.  * This is more convenient than using the constructor.  *  * <p>For example:  *  * <pre>  *     Row.of("hello", true, 1L).}  * </pre>  * instead of  * <pre>  *     Row row = new Row(3).  *     row.setField(0, "hello").  *     row.setField(1, true).  *     row.setField(2, 1L).  * </pre>  */ public static Row of(Object... values) {     Row row = new Row(values.length).     for (int i = 0. i < values.length. i++) {         row.setField(i, values[i]).     }     return row. }
true;public,static;1;5;/**  * Creates a new Row which copied from another row.  * This method does not perform a deep copy.  *  * @param row The row being copied.  * @return The cloned new Row  */ ;/**  * Creates a new Row which copied from another row.  * This method does not perform a deep copy.  *  * @param row The row being copied.  * @return The cloned new Row  */ public static Row copy(Row row) {     final Row newRow = new Row(row.fields.length).     System.arraycopy(row.fields, 0, newRow.fields, 0, row.fields.length).     return newRow. }
true;public,static;2;7;/**  * Creates a new Row with projected fields from another row.  * This method does not perform a deep copy.  *  * @param fields fields to be projected  * @return the new projected Row  */ ;/**  * Creates a new Row with projected fields from another row.  * This method does not perform a deep copy.  *  * @param fields fields to be projected  * @return the new projected Row  */ public static Row project(Row row, int[] fields) {     final Row newRow = new Row(fields.length).     for (int i = 0. i < fields.length. i++) {         newRow.fields[i] = row.fields[fields[i]].     }     return newRow. }
