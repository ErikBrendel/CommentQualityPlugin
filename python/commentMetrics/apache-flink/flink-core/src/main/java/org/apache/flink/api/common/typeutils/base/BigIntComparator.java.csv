commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;@Override public int compareSerialized(DataInputView firstSource, DataInputView secondSource) throws IOException {     BigInteger bi1 = BigIntSerializer.readBigInteger(firstSource).     BigInteger bi2 = BigIntSerializer.readBigInteger(secondSource).     // null is not supported     int comp = bi1.compareTo(bi2).     return ascendingComparison ? comp : -comp. }
false;public;0;4;;@Override public boolean supportsNormalizedKey() {     return true. }
false;public;0;4;;@Override public boolean supportsSerializationWithKeyNormalization() {     return false. }
false;public;0;4;;@Override public int getNormalizeKeyLen() {     return Integer.MAX_VALUE. }
false;public;1;4;;@Override public boolean isNormalizedKeyPrefixOnly(int keyBytes) {     return true. }
true;public;4;39;/**  * Adds a normalized key containing the normalized number of bits and MSBs of the given record.  * 1 bit determines the sign (negative, zero/positive), 31 bit the bit length of the record.  * Remaining bytes contain the most significant bits of the record.  */ ;/**  * Adds a normalized key containing the normalized number of bits and MSBs of the given record.  * 1 bit determines the sign (negative, zero/positive), 31 bit the bit length of the record.  * Remaining bytes contain the most significant bits of the record.  */ @Override public void putNormalizedKey(BigInteger record, MemorySegment target, int offset, int len) {     // add normalized bit length (the larger the length, the larger the value)     int bitLen = 0.     if (len > 0) {         final int signum = record.signum().         bitLen = record.bitLength().         // normalize dependent on sign         // from 0 to Integer.MAX         // OR from Integer.MAX to 0         int normBitLen = signum < 0 ? Integer.MAX_VALUE - bitLen : bitLen.         // add sign         if (signum >= 0) {             normBitLen |= (1 << 31).         }         for (int i = 0. i < 4 && len > 0. i++, len--) {             final byte b = (byte) (normBitLen >>> (8 * (3 - i))).             target.put(offset++, b).         }     }     // fill remaining bytes with most significant bits     int bitPos = bitLen - 1.     for (. len > 0. len--) {         byte b = 0.         for (int bytePos = 0. bytePos < 8 && bitPos >= 0. bytePos++, bitPos--) {             b <<= 1.             if (record.testBit(bitPos)) {                 b |= 1.             }         }         // the last byte might be partially filled, but that's ok within an equal bit length.         // no need for padding bits.         target.put(offset++, b).     } }
false;public;0;4;;@Override public BigIntComparator duplicate() {     return new BigIntComparator(ascendingComparison). }
