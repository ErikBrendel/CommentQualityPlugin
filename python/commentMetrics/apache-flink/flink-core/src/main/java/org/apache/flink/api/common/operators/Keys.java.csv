commented;modifiers;parameterAmount;loc;comment;code
false;public,abstract;0;1;;public abstract int getNumberOfKeyFields().
false;public,abstract;0;1;;public abstract int[] computeLogicalKeyPositions().
false;public,abstract;0;1;;public abstract TypeInformation<?>[] getKeyFieldTypes().
false;public,abstract;0;1;;public abstract TypeInformation<?>[] getOriginalKeyFieldTypes().
false;public,abstract;2;1;;public abstract <E> void validateCustomPartitioner(Partitioner<E> partitioner, TypeInformation<E> typeInfo).
false;public;0;3;;public boolean isEmpty() {     return getNumberOfKeyFields() == 0. }
true;public;1;16;/**  * Check if two sets of keys are compatible to each other (matching types, key counts)  */ ;/**  * Check if two sets of keys are compatible to each other (matching types, key counts)  */ public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException {     TypeInformation<?>[] thisKeyFieldTypes = this.getKeyFieldTypes().     TypeInformation<?>[] otherKeyFieldTypes = other.getKeyFieldTypes().     if (thisKeyFieldTypes.length != otherKeyFieldTypes.length) {         throw new IncompatibleKeysException(IncompatibleKeysException.SIZE_MISMATCH_MESSAGE).     } else {         for (int i = 0. i < thisKeyFieldTypes.length. i++) {             if (!thisKeyFieldTypes[i].equals(otherKeyFieldTypes[i])) {                 throw new IncompatibleKeysException(thisKeyFieldTypes[i], otherKeyFieldTypes[i]).             }         }     }     return true. }
false;public;0;3;;public TypeInformation<K> getKeyType() {     return keyType. }
false;public;0;3;;public TypeInformation<T> getInputType() {     return inputType. }
false;public;0;3;;public KeySelector<T, K> getKeyExtractor() {     return keyExtractor. }
false;public;0;4;;@Override public int getNumberOfKeyFields() {     return keyFields.size(). }
false;public;0;8;;@Override public int[] computeLogicalKeyPositions() {     int[] logicalKeys = new int[keyFields.size()].     for (int i = 0. i < keyFields.size(). i++) {         logicalKeys[i] = keyFields.get(i).getPosition().     }     return logicalKeys. }
false;public;0;8;;@Override public TypeInformation<?>[] getKeyFieldTypes() {     TypeInformation<?>[] fieldTypes = new TypeInformation[keyFields.size()].     for (int i = 0. i < keyFields.size(). i++) {         fieldTypes[i] = keyFields.get(i).getType().     }     return fieldTypes. }
false;public;0;4;;@Override public TypeInformation<?>[] getOriginalKeyFieldTypes() {     return originalKeyTypes. }
false;public;2;26;;@Override public <E> void validateCustomPartitioner(Partitioner<E> partitioner, TypeInformation<E> typeInfo) {     if (keyFields.size() != 1) {         throw new InvalidProgramException("Custom partitioners can only be used with keys that have one key field.").     }     if (typeInfo == null) {         // try to extract key type from partitioner         try {             typeInfo = TypeExtractor.getPartitionerTypes(partitioner).         } catch (Throwable t) {         // best effort check, so we ignore exceptions         }     }     // only check if type is known and not a generic type     if (typeInfo != null && !(typeInfo instanceof GenericTypeInfo)) {         // check equality of key and partitioner type         if (!keyType.equals(typeInfo)) {             throw new InvalidProgramException("The partitioner is incompatible with the key type. " + "Partitioner type: " + typeInfo + " , key type: " + keyType).         }     } }
false;public;0;4;;@Override public String toString() {     return "Key function (Type: " + keyType + ")". }
false;public;0;7;;@Override public int getNumberOfKeyFields() {     if (keyFields == null) {         return 0.     }     return keyFields.size(). }
false;public;0;8;;@Override public int[] computeLogicalKeyPositions() {     int[] logicalKeys = new int[keyFields.size()].     for (int i = 0. i < keyFields.size(). i++) {         logicalKeys[i] = keyFields.get(i).getPosition().     }     return logicalKeys. }
false;public;0;8;;@Override public TypeInformation<?>[] getKeyFieldTypes() {     TypeInformation<?>[] fieldTypes = new TypeInformation[keyFields.size()].     for (int i = 0. i < keyFields.size(). i++) {         fieldTypes[i] = keyFields.get(i).getType().     }     return fieldTypes. }
false;public;0;4;;@Override public TypeInformation<?>[] getOriginalKeyFieldTypes() {     return originalKeyTypes. }
false;public;2;27;;@Override public <E> void validateCustomPartitioner(Partitioner<E> partitioner, TypeInformation<E> typeInfo) {     if (keyFields.size() != 1) {         throw new InvalidProgramException("Custom partitioners can only be used with keys that have one key field.").     }     if (typeInfo == null) {         // try to extract key type from partitioner         try {             typeInfo = TypeExtractor.getPartitionerTypes(partitioner).         } catch (Throwable t) {         // best effort check, so we ignore exceptions         }     }     if (typeInfo != null && !(typeInfo instanceof GenericTypeInfo)) {         // only check type compatibility if type is known and not a generic type         TypeInformation<?> keyType = keyFields.get(0).getType().         if (!keyType.equals(typeInfo)) {             throw new InvalidProgramException("The partitioner is incompatible with the key type. " + "Partitioner type: " + typeInfo + " , key type: " + keyType).         }     } }
false;public;0;4;;@Override public String toString() {     return "ExpressionKeys: " + StringUtils.join(keyFields, '.'). }
false;public,static;2;17;;public static boolean isSortKey(int fieldPos, TypeInformation<?> type) {     if (!type.isTupleType() || !(type instanceof CompositeType)) {         throw new InvalidProgramException("Specifying keys via field positions is only valid " + "for tuple data types. Type: " + type).     }     if (type.getArity() == 0) {         throw new InvalidProgramException("Tuple size must be greater than 0. Size: " + type.getArity()).     }     if (fieldPos < 0 || fieldPos >= type.getArity()) {         throw new IndexOutOfBoundsException("Tuple position is out of range: " + fieldPos).     }     TypeInformation<?> sortKeyType = ((CompositeType<?>) type).getTypeAt(fieldPos).     return sortKeyType.isSortKeyType(). }
false;public,static;2;20;;public static boolean isSortKey(String fieldExpr, TypeInformation<?> type) {     TypeInformation<?> sortKeyType.     fieldExpr = fieldExpr.trim().     if (SELECT_ALL_CHAR.equals(fieldExpr) || SELECT_ALL_CHAR_SCALA.equals(fieldExpr)) {         sortKeyType = type.     } else {         if (type instanceof CompositeType) {             sortKeyType = ((CompositeType<?>) type).getTypeAt(fieldExpr).         } else {             throw new InvalidProgramException("Field expression must be equal to '" + SELECT_ALL_CHAR + "' or '" + SELECT_ALL_CHAR_SCALA + "' for atomic types.").         }     }     return sortKeyType.isSortKeyType(). }
false;private,static;1;7;;// -------------------------------------------------------------------------------------------- // -------------------------------------------------------------------------------------------- // Utilities // -------------------------------------------------------------------------------------------- private static int[] createIncrIntArray(int numKeys) {     int[] keyFields = new int[numKeys].     for (int i = 0. i < numKeys. i++) {         keyFields[i] = i.     }     return keyFields. }
false;private,static;2;8;;private static void rangeCheckFields(int[] fields, int maxAllowedField) {     for (int f : fields) {         if (f < 0 || f > maxAllowedField) {             throw new IndexOutOfBoundsException("Tuple position is out of range: " + f).         }     } }
