# id;timestamp;commentText;codeText;commentWords;codeWords
Keys -> ExpressionKeys -> public ExpressionKeys(int[] keyPositions, TypeInformation<T> type);1454428544;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int[] keyPositions, TypeInformation<T> type) {_			this(keyPositions, type, false)__		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,positions,type,information,t,type,this,key,positions,type,false
Keys -> ExpressionKeys -> public ExpressionKeys(int[] keyPositions, TypeInformation<T> type);1455479358;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int[] keyPositions, TypeInformation<T> type) {_			this(keyPositions, type, false)__		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,positions,type,information,t,type,this,key,positions,type,false
Keys -> ExpressionKeys -> public ExpressionKeys(int[] keyPositions, TypeInformation<T> type);1458743533;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int[] keyPositions, TypeInformation<T> type) {_			this(keyPositions, type, false)__		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,positions,type,information,t,type,this,key,positions,type,false
Keys -> ExpressionKeys -> public ExpressionKeys(int[] keyPositions, TypeInformation<T> type);1460741894;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int[] keyPositions, TypeInformation<T> type) {_			this(keyPositions, type, false)__		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,positions,type,information,t,type,this,key,positions,type,false
Keys -> ExpressionKeys -> public ExpressionKeys(int[] keyPositions, TypeInformation<T> type);1461185548;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int[] keyPositions, TypeInformation<T> type) {_			this(keyPositions, type, false)__		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,positions,type,information,t,type,this,key,positions,type,false
Keys -> ExpressionKeys -> public ExpressionKeys(int keyPosition, TypeInformation<T> type);1454428544;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int keyPosition, TypeInformation<T> type) {_			this(new int[]{keyPosition}, type, false)__		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,position,type,information,t,type,this,new,int,key,position,type,false
Keys -> ExpressionKeys -> public ExpressionKeys(int keyPosition, TypeInformation<T> type);1455479358;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int keyPosition, TypeInformation<T> type) {_			this(new int[]{keyPosition}, type, false)__		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,position,type,information,t,type,this,new,int,key,position,type,false
Keys -> ExpressionKeys -> public ExpressionKeys(int keyPosition, TypeInformation<T> type);1458743533;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int keyPosition, TypeInformation<T> type) {_			this(new int[]{keyPosition}, type, false)__		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,position,type,information,t,type,this,new,int,key,position,type,false
Keys -> ExpressionKeys -> public ExpressionKeys(int keyPosition, TypeInformation<T> type);1460741894;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int keyPosition, TypeInformation<T> type) {_			this(new int[]{keyPosition}, type, false)__		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,position,type,information,t,type,this,new,int,key,position,type,false
Keys -> ExpressionKeys -> public ExpressionKeys(int keyPosition, TypeInformation<T> type);1461185548;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int keyPosition, TypeInformation<T> type) {_			this(new int[]{keyPosition}, type, false)__		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,position,type,information,t,type,this,new,int,key,position,type,false
Keys -> public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException;1454428544;Check if two sets of keys are compatible to each other (matching types, key counts);public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException {__		TypeInformation<?>[] thisKeyFieldTypes = this.getKeyFieldTypes()__		TypeInformation<?>[] otherKeyFieldTypes = other.getKeyFieldTypes()___		if (thisKeyFieldTypes.length != otherKeyFieldTypes.length) {_			throw new IncompatibleKeysException(IncompatibleKeysException.SIZE_MISMATCH_MESSAGE)__		} else {_			for (int i = 0_ i < thisKeyFieldTypes.length_ i++) {_				if (!thisKeyFieldTypes[i].equals(otherKeyFieldTypes[i])) {_					throw new IncompatibleKeysException(thisKeyFieldTypes[i], otherKeyFieldTypes[i] )__				}_			}_		}_		return true__	};check,if,two,sets,of,keys,are,compatible,to,each,other,matching,types,key,counts;public,boolean,are,compatible,keys,other,throws,incompatible,keys,exception,type,information,this,key,field,types,this,get,key,field,types,type,information,other,key,field,types,other,get,key,field,types,if,this,key,field,types,length,other,key,field,types,length,throw,new,incompatible,keys,exception,incompatible,keys,exception,else,for,int,i,0,i,this,key,field,types,length,i,if,this,key,field,types,i,equals,other,key,field,types,i,throw,new,incompatible,keys,exception,this,key,field,types,i,other,key,field,types,i,return,true
Keys -> public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException;1455479358;Check if two sets of keys are compatible to each other (matching types, key counts);public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException {__		TypeInformation<?>[] thisKeyFieldTypes = this.getKeyFieldTypes()__		TypeInformation<?>[] otherKeyFieldTypes = other.getKeyFieldTypes()___		if (thisKeyFieldTypes.length != otherKeyFieldTypes.length) {_			throw new IncompatibleKeysException(IncompatibleKeysException.SIZE_MISMATCH_MESSAGE)__		} else {_			for (int i = 0_ i < thisKeyFieldTypes.length_ i++) {_				if (!thisKeyFieldTypes[i].equals(otherKeyFieldTypes[i])) {_					throw new IncompatibleKeysException(thisKeyFieldTypes[i], otherKeyFieldTypes[i] )__				}_			}_		}_		return true__	};check,if,two,sets,of,keys,are,compatible,to,each,other,matching,types,key,counts;public,boolean,are,compatible,keys,other,throws,incompatible,keys,exception,type,information,this,key,field,types,this,get,key,field,types,type,information,other,key,field,types,other,get,key,field,types,if,this,key,field,types,length,other,key,field,types,length,throw,new,incompatible,keys,exception,incompatible,keys,exception,else,for,int,i,0,i,this,key,field,types,length,i,if,this,key,field,types,i,equals,other,key,field,types,i,throw,new,incompatible,keys,exception,this,key,field,types,i,other,key,field,types,i,return,true
Keys -> public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException;1458743533;Check if two sets of keys are compatible to each other (matching types, key counts);public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException {__		TypeInformation<?>[] thisKeyFieldTypes = this.getKeyFieldTypes()__		TypeInformation<?>[] otherKeyFieldTypes = other.getKeyFieldTypes()___		if (thisKeyFieldTypes.length != otherKeyFieldTypes.length) {_			throw new IncompatibleKeysException(IncompatibleKeysException.SIZE_MISMATCH_MESSAGE)__		} else {_			for (int i = 0_ i < thisKeyFieldTypes.length_ i++) {_				if (!thisKeyFieldTypes[i].equals(otherKeyFieldTypes[i])) {_					throw new IncompatibleKeysException(thisKeyFieldTypes[i], otherKeyFieldTypes[i] )__				}_			}_		}_		return true__	};check,if,two,sets,of,keys,are,compatible,to,each,other,matching,types,key,counts;public,boolean,are,compatible,keys,other,throws,incompatible,keys,exception,type,information,this,key,field,types,this,get,key,field,types,type,information,other,key,field,types,other,get,key,field,types,if,this,key,field,types,length,other,key,field,types,length,throw,new,incompatible,keys,exception,incompatible,keys,exception,else,for,int,i,0,i,this,key,field,types,length,i,if,this,key,field,types,i,equals,other,key,field,types,i,throw,new,incompatible,keys,exception,this,key,field,types,i,other,key,field,types,i,return,true
Keys -> public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException;1460741894;Check if two sets of keys are compatible to each other (matching types, key counts);public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException {__		TypeInformation<?>[] thisKeyFieldTypes = this.getKeyFieldTypes()__		TypeInformation<?>[] otherKeyFieldTypes = other.getKeyFieldTypes()___		if (thisKeyFieldTypes.length != otherKeyFieldTypes.length) {_			throw new IncompatibleKeysException(IncompatibleKeysException.SIZE_MISMATCH_MESSAGE)__		} else {_			for (int i = 0_ i < thisKeyFieldTypes.length_ i++) {_				if (!thisKeyFieldTypes[i].equals(otherKeyFieldTypes[i])) {_					throw new IncompatibleKeysException(thisKeyFieldTypes[i], otherKeyFieldTypes[i] )__				}_			}_		}_		return true__	};check,if,two,sets,of,keys,are,compatible,to,each,other,matching,types,key,counts;public,boolean,are,compatible,keys,other,throws,incompatible,keys,exception,type,information,this,key,field,types,this,get,key,field,types,type,information,other,key,field,types,other,get,key,field,types,if,this,key,field,types,length,other,key,field,types,length,throw,new,incompatible,keys,exception,incompatible,keys,exception,else,for,int,i,0,i,this,key,field,types,length,i,if,this,key,field,types,i,equals,other,key,field,types,i,throw,new,incompatible,keys,exception,this,key,field,types,i,other,key,field,types,i,return,true
Keys -> public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException;1461185548;Check if two sets of keys are compatible to each other (matching types, key counts);public boolean areCompatible(Keys<?> other) throws IncompatibleKeysException {__		TypeInformation<?>[] thisKeyFieldTypes = this.getKeyFieldTypes()__		TypeInformation<?>[] otherKeyFieldTypes = other.getKeyFieldTypes()___		if (thisKeyFieldTypes.length != otherKeyFieldTypes.length) {_			throw new IncompatibleKeysException(IncompatibleKeysException.SIZE_MISMATCH_MESSAGE)__		} else {_			for (int i = 0_ i < thisKeyFieldTypes.length_ i++) {_				if (!thisKeyFieldTypes[i].equals(otherKeyFieldTypes[i])) {_					throw new IncompatibleKeysException(thisKeyFieldTypes[i], otherKeyFieldTypes[i] )__				}_			}_		}_		return true__	};check,if,two,sets,of,keys,are,compatible,to,each,other,matching,types,key,counts;public,boolean,are,compatible,keys,other,throws,incompatible,keys,exception,type,information,this,key,field,types,this,get,key,field,types,type,information,other,key,field,types,other,get,key,field,types,if,this,key,field,types,length,other,key,field,types,length,throw,new,incompatible,keys,exception,incompatible,keys,exception,else,for,int,i,0,i,this,key,field,types,length,i,if,this,key,field,types,i,equals,other,key,field,types,i,throw,new,incompatible,keys,exception,this,key,field,types,i,other,key,field,types,i,return,true
Keys -> ExpressionKeys -> public ExpressionKeys(String keyExpression, TypeInformation<T> type);1454428544;Create String-based (nested) field expression keys on a composite type.;public ExpressionKeys(String keyExpression, TypeInformation<T> type) {_			this(new String[]{keyExpression}, type)__		};create,string,based,nested,field,expression,keys,on,a,composite,type;public,expression,keys,string,key,expression,type,information,t,type,this,new,string,key,expression,type
Keys -> ExpressionKeys -> public ExpressionKeys(String keyExpression, TypeInformation<T> type);1455479358;Create String-based (nested) field expression keys on a composite type.;public ExpressionKeys(String keyExpression, TypeInformation<T> type) {_			this(new String[]{keyExpression}, type)__		};create,string,based,nested,field,expression,keys,on,a,composite,type;public,expression,keys,string,key,expression,type,information,t,type,this,new,string,key,expression,type
Keys -> ExpressionKeys -> public ExpressionKeys(String keyExpression, TypeInformation<T> type);1458743533;Create String-based (nested) field expression keys on a composite type.;public ExpressionKeys(String keyExpression, TypeInformation<T> type) {_			this(new String[]{keyExpression}, type)__		};create,string,based,nested,field,expression,keys,on,a,composite,type;public,expression,keys,string,key,expression,type,information,t,type,this,new,string,key,expression,type
Keys -> ExpressionKeys -> public ExpressionKeys(String keyExpression, TypeInformation<T> type);1460741894;Create String-based (nested) field expression keys on a composite type.;public ExpressionKeys(String keyExpression, TypeInformation<T> type) {_			this(new String[]{keyExpression}, type)__		};create,string,based,nested,field,expression,keys,on,a,composite,type;public,expression,keys,string,key,expression,type,information,t,type,this,new,string,key,expression,type
Keys -> ExpressionKeys -> public ExpressionKeys(String keyExpression, TypeInformation<T> type);1461185548;Create String-based (nested) field expression keys on a composite type.;public ExpressionKeys(String keyExpression, TypeInformation<T> type) {_			this(new String[]{keyExpression}, type)__		};create,string,based,nested,field,expression,keys,on,a,composite,type;public,expression,keys,string,key,expression,type,information,t,type,this,new,string,key,expression,type
Keys -> ExpressionKeys -> public ExpressionKeys(int[] keyPositions, TypeInformation<T> type, boolean allowEmpty);1454428544;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int[] keyPositions, TypeInformation<T> type, boolean allowEmpty) {__			if (!type.isTupleType() || !(type instanceof CompositeType)) {_				throw new InvalidProgramException("Specifying keys via field positions is only valid " +_						"for tuple data types. Type: " + type)__			}_			if (type.getArity() == 0) {_				throw new InvalidProgramException("Tuple size must be greater than 0. Size: " + type.getArity())__			}_			if (!allowEmpty && (keyPositions == null || keyPositions.length == 0)) {_				throw new IllegalArgumentException("The grouping fields must not be empty.")__			}__			this.keyFields = new ArrayList<>()___			if (keyPositions == null || keyPositions.length == 0) {_				_				keyPositions = createIncrIntArray(type.getArity())__			} else {_				rangeCheckFields(keyPositions, type.getArity() - 1)__			}_			Preconditions.checkArgument(keyPositions.length > 0, "Grouping fields can not be empty at this point")___			_			CompositeType<T> cType = (CompositeType<T>)type__			this.keyFields = new ArrayList<>(type.getTotalFields())___			_			String[] fieldNames = cType.getFieldNames()__			ArrayList<FlatFieldDescriptor> tmpList = new ArrayList<>()__			for (int keyPos : keyPositions) {_				tmpList.clear()__				_				cType.getFlatFields(fieldNames[keyPos], 0, tmpList)__				_				for(FlatFieldDescriptor ffd : tmpList) {_					if(!ffd.getType().isKeyType()) {_						throw new InvalidProgramException("This type (" + ffd.getType() + ") cannot be used as key.")__					}_				}_				this.keyFields.addAll(tmpList)__			}_		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,positions,type,information,t,type,boolean,allow,empty,if,type,is,tuple,type,type,instanceof,composite,type,throw,new,invalid,program,exception,specifying,keys,via,field,positions,is,only,valid,for,tuple,data,types,type,type,if,type,get,arity,0,throw,new,invalid,program,exception,tuple,size,must,be,greater,than,0,size,type,get,arity,if,allow,empty,key,positions,null,key,positions,length,0,throw,new,illegal,argument,exception,the,grouping,fields,must,not,be,empty,this,key,fields,new,array,list,if,key,positions,null,key,positions,length,0,key,positions,create,incr,int,array,type,get,arity,else,range,check,fields,key,positions,type,get,arity,1,preconditions,check,argument,key,positions,length,0,grouping,fields,can,not,be,empty,at,this,point,composite,type,t,c,type,composite,type,t,type,this,key,fields,new,array,list,type,get,total,fields,string,field,names,c,type,get,field,names,array,list,flat,field,descriptor,tmp,list,new,array,list,for,int,key,pos,key,positions,tmp,list,clear,c,type,get,flat,fields,field,names,key,pos,0,tmp,list,for,flat,field,descriptor,ffd,tmp,list,if,ffd,get,type,is,key,type,throw,new,invalid,program,exception,this,type,ffd,get,type,cannot,be,used,as,key,this,key,fields,add,all,tmp,list
Keys -> ExpressionKeys -> public ExpressionKeys(int[] keyPositions, TypeInformation<T> type, boolean allowEmpty);1455479358;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int[] keyPositions, TypeInformation<T> type, boolean allowEmpty) {__			if (!type.isTupleType() || !(type instanceof CompositeType)) {_				throw new InvalidProgramException("Specifying keys via field positions is only valid " +_						"for tuple data types. Type: " + type)__			}_			if (type.getArity() == 0) {_				throw new InvalidProgramException("Tuple size must be greater than 0. Size: " + type.getArity())__			}_			if (!allowEmpty && (keyPositions == null || keyPositions.length == 0)) {_				throw new IllegalArgumentException("The grouping fields must not be empty.")__			}__			this.keyFields = new ArrayList<>()___			if (keyPositions == null || keyPositions.length == 0) {_				_				keyPositions = createIncrIntArray(type.getArity())__			} else {_				rangeCheckFields(keyPositions, type.getArity() - 1)__			}_			Preconditions.checkArgument(keyPositions.length > 0, "Grouping fields can not be empty at this point")___			_			CompositeType<T> cType = (CompositeType<T>)type__			this.keyFields = new ArrayList<>(type.getTotalFields())___			_			String[] fieldNames = cType.getFieldNames()__			ArrayList<FlatFieldDescriptor> tmpList = new ArrayList<>()__			for (int keyPos : keyPositions) {_				tmpList.clear()__				_				cType.getFlatFields(fieldNames[keyPos], 0, tmpList)__				_				for(FlatFieldDescriptor ffd : tmpList) {_					if(!ffd.getType().isKeyType()) {_						throw new InvalidProgramException("This type (" + ffd.getType() + ") cannot be used as key.")__					}_				}_				this.keyFields.addAll(tmpList)__			}_		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,positions,type,information,t,type,boolean,allow,empty,if,type,is,tuple,type,type,instanceof,composite,type,throw,new,invalid,program,exception,specifying,keys,via,field,positions,is,only,valid,for,tuple,data,types,type,type,if,type,get,arity,0,throw,new,invalid,program,exception,tuple,size,must,be,greater,than,0,size,type,get,arity,if,allow,empty,key,positions,null,key,positions,length,0,throw,new,illegal,argument,exception,the,grouping,fields,must,not,be,empty,this,key,fields,new,array,list,if,key,positions,null,key,positions,length,0,key,positions,create,incr,int,array,type,get,arity,else,range,check,fields,key,positions,type,get,arity,1,preconditions,check,argument,key,positions,length,0,grouping,fields,can,not,be,empty,at,this,point,composite,type,t,c,type,composite,type,t,type,this,key,fields,new,array,list,type,get,total,fields,string,field,names,c,type,get,field,names,array,list,flat,field,descriptor,tmp,list,new,array,list,for,int,key,pos,key,positions,tmp,list,clear,c,type,get,flat,fields,field,names,key,pos,0,tmp,list,for,flat,field,descriptor,ffd,tmp,list,if,ffd,get,type,is,key,type,throw,new,invalid,program,exception,this,type,ffd,get,type,cannot,be,used,as,key,this,key,fields,add,all,tmp,list
Keys -> ExpressionKeys -> public ExpressionKeys(int[] keyPositions, TypeInformation<T> type, boolean allowEmpty);1458743533;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int[] keyPositions, TypeInformation<T> type, boolean allowEmpty) {__			if (!type.isTupleType() || !(type instanceof CompositeType)) {_				throw new InvalidProgramException("Specifying keys via field positions is only valid " +_						"for tuple data types. Type: " + type)__			}_			if (type.getArity() == 0) {_				throw new InvalidProgramException("Tuple size must be greater than 0. Size: " + type.getArity())__			}_			if (!allowEmpty && (keyPositions == null || keyPositions.length == 0)) {_				throw new IllegalArgumentException("The grouping fields must not be empty.")__			}__			this.keyFields = new ArrayList<>()___			if (keyPositions == null || keyPositions.length == 0) {_				_				keyPositions = createIncrIntArray(type.getArity())__			} else {_				rangeCheckFields(keyPositions, type.getArity() - 1)__			}_			Preconditions.checkArgument(keyPositions.length > 0, "Grouping fields can not be empty at this point")___			_			CompositeType<T> cType = (CompositeType<T>)type__			this.keyFields = new ArrayList<>(type.getTotalFields())___			_			String[] fieldNames = cType.getFieldNames()__			ArrayList<FlatFieldDescriptor> tmpList = new ArrayList<>()__			for (int keyPos : keyPositions) {_				tmpList.clear()__				_				cType.getFlatFields(fieldNames[keyPos], 0, tmpList)__				_				for(FlatFieldDescriptor ffd : tmpList) {_					if(!ffd.getType().isKeyType()) {_						throw new InvalidProgramException("This type (" + ffd.getType() + ") cannot be used as key.")__					}_				}_				this.keyFields.addAll(tmpList)__			}_		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,positions,type,information,t,type,boolean,allow,empty,if,type,is,tuple,type,type,instanceof,composite,type,throw,new,invalid,program,exception,specifying,keys,via,field,positions,is,only,valid,for,tuple,data,types,type,type,if,type,get,arity,0,throw,new,invalid,program,exception,tuple,size,must,be,greater,than,0,size,type,get,arity,if,allow,empty,key,positions,null,key,positions,length,0,throw,new,illegal,argument,exception,the,grouping,fields,must,not,be,empty,this,key,fields,new,array,list,if,key,positions,null,key,positions,length,0,key,positions,create,incr,int,array,type,get,arity,else,range,check,fields,key,positions,type,get,arity,1,preconditions,check,argument,key,positions,length,0,grouping,fields,can,not,be,empty,at,this,point,composite,type,t,c,type,composite,type,t,type,this,key,fields,new,array,list,type,get,total,fields,string,field,names,c,type,get,field,names,array,list,flat,field,descriptor,tmp,list,new,array,list,for,int,key,pos,key,positions,tmp,list,clear,c,type,get,flat,fields,field,names,key,pos,0,tmp,list,for,flat,field,descriptor,ffd,tmp,list,if,ffd,get,type,is,key,type,throw,new,invalid,program,exception,this,type,ffd,get,type,cannot,be,used,as,key,this,key,fields,add,all,tmp,list
Keys -> ExpressionKeys -> public ExpressionKeys(int[] keyPositions, TypeInformation<T> type, boolean allowEmpty);1460741894;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int[] keyPositions, TypeInformation<T> type, boolean allowEmpty) {__			if (!type.isTupleType() || !(type instanceof CompositeType)) {_				throw new InvalidProgramException("Specifying keys via field positions is only valid " +_						"for tuple data types. Type: " + type)__			}_			if (type.getArity() == 0) {_				throw new InvalidProgramException("Tuple size must be greater than 0. Size: " + type.getArity())__			}_			if (!allowEmpty && (keyPositions == null || keyPositions.length == 0)) {_				throw new IllegalArgumentException("The grouping fields must not be empty.")__			}__			this.keyFields = new ArrayList<>()___			if (keyPositions == null || keyPositions.length == 0) {_				_				keyPositions = createIncrIntArray(type.getArity())__			} else {_				rangeCheckFields(keyPositions, type.getArity() - 1)__			}_			_			checkArgument(keyPositions.length > 0, "Grouping fields can not be empty at this point")___			_			CompositeType<T> cType = (CompositeType<T>)type__			this.keyFields = new ArrayList<>(type.getTotalFields())___			_			String[] fieldNames = cType.getFieldNames()__			ArrayList<FlatFieldDescriptor> tmpList = new ArrayList<>()__			for (int keyPos : keyPositions) {_				tmpList.clear()__				_				cType.getFlatFields(fieldNames[keyPos], 0, tmpList)__				_				for(FlatFieldDescriptor ffd : tmpList) {_					if(!ffd.getType().isKeyType()) {_						throw new InvalidProgramException("This type (" + ffd.getType() + ") cannot be used as key.")__					}_				}_				this.keyFields.addAll(tmpList)__			}_		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,positions,type,information,t,type,boolean,allow,empty,if,type,is,tuple,type,type,instanceof,composite,type,throw,new,invalid,program,exception,specifying,keys,via,field,positions,is,only,valid,for,tuple,data,types,type,type,if,type,get,arity,0,throw,new,invalid,program,exception,tuple,size,must,be,greater,than,0,size,type,get,arity,if,allow,empty,key,positions,null,key,positions,length,0,throw,new,illegal,argument,exception,the,grouping,fields,must,not,be,empty,this,key,fields,new,array,list,if,key,positions,null,key,positions,length,0,key,positions,create,incr,int,array,type,get,arity,else,range,check,fields,key,positions,type,get,arity,1,check,argument,key,positions,length,0,grouping,fields,can,not,be,empty,at,this,point,composite,type,t,c,type,composite,type,t,type,this,key,fields,new,array,list,type,get,total,fields,string,field,names,c,type,get,field,names,array,list,flat,field,descriptor,tmp,list,new,array,list,for,int,key,pos,key,positions,tmp,list,clear,c,type,get,flat,fields,field,names,key,pos,0,tmp,list,for,flat,field,descriptor,ffd,tmp,list,if,ffd,get,type,is,key,type,throw,new,invalid,program,exception,this,type,ffd,get,type,cannot,be,used,as,key,this,key,fields,add,all,tmp,list
Keys -> ExpressionKeys -> public ExpressionKeys(int[] keyPositions, TypeInformation<T> type, boolean allowEmpty);1461185548;Create int-based (non-nested) field position keys on a tuple type.;public ExpressionKeys(int[] keyPositions, TypeInformation<T> type, boolean allowEmpty) {__			if (!type.isTupleType() || !(type instanceof CompositeType)) {_				throw new InvalidProgramException("Specifying keys via field positions is only valid " +_						"for tuple data types. Type: " + type)__			}_			if (type.getArity() == 0) {_				throw new InvalidProgramException("Tuple size must be greater than 0. Size: " + type.getArity())__			}_			if (!allowEmpty && (keyPositions == null || keyPositions.length == 0)) {_				throw new IllegalArgumentException("The grouping fields must not be empty.")__			}__			this.keyFields = new ArrayList<>()___			if (keyPositions == null || keyPositions.length == 0) {_				_				keyPositions = createIncrIntArray(type.getArity())__			} else {_				rangeCheckFields(keyPositions, type.getArity() - 1)__			}__			checkArgument(keyPositions.length > 0, "Grouping fields can not be empty at this point")___			_			CompositeType<T> cType = (CompositeType<T>)type__			this.keyFields = new ArrayList<>(type.getTotalFields())___			_			String[] fieldNames = cType.getFieldNames()__			this.originalKeyTypes = new TypeInformation<?>[keyPositions.length]__			ArrayList<FlatFieldDescriptor> tmpList = new ArrayList<>()__			for (int i = 0_ i < keyPositions.length_ i++) {_				int keyPos = keyPositions[i]__				tmpList.clear()__				_				this.originalKeyTypes[i] = cType.getTypeAt(keyPos)__				cType.getFlatFields(fieldNames[keyPos], 0, tmpList)__				_				for(FlatFieldDescriptor ffd : tmpList) {_					if(!ffd.getType().isKeyType()) {_						throw new InvalidProgramException("This type (" + ffd.getType() + ") cannot be used as key.")__					}_				}_				this.keyFields.addAll(tmpList)__			}_		};create,int,based,non,nested,field,position,keys,on,a,tuple,type;public,expression,keys,int,key,positions,type,information,t,type,boolean,allow,empty,if,type,is,tuple,type,type,instanceof,composite,type,throw,new,invalid,program,exception,specifying,keys,via,field,positions,is,only,valid,for,tuple,data,types,type,type,if,type,get,arity,0,throw,new,invalid,program,exception,tuple,size,must,be,greater,than,0,size,type,get,arity,if,allow,empty,key,positions,null,key,positions,length,0,throw,new,illegal,argument,exception,the,grouping,fields,must,not,be,empty,this,key,fields,new,array,list,if,key,positions,null,key,positions,length,0,key,positions,create,incr,int,array,type,get,arity,else,range,check,fields,key,positions,type,get,arity,1,check,argument,key,positions,length,0,grouping,fields,can,not,be,empty,at,this,point,composite,type,t,c,type,composite,type,t,type,this,key,fields,new,array,list,type,get,total,fields,string,field,names,c,type,get,field,names,this,original,key,types,new,type,information,key,positions,length,array,list,flat,field,descriptor,tmp,list,new,array,list,for,int,i,0,i,key,positions,length,i,int,key,pos,key,positions,i,tmp,list,clear,this,original,key,types,i,c,type,get,type,at,key,pos,c,type,get,flat,fields,field,names,key,pos,0,tmp,list,for,flat,field,descriptor,ffd,tmp,list,if,ffd,get,type,is,key,type,throw,new,invalid,program,exception,this,type,ffd,get,type,cannot,be,used,as,key,this,key,fields,add,all,tmp,list
Keys -> ExpressionKeys -> public ExpressionKeys(TypeInformation<T> type);1454428544;ExpressionKeys that is defined by the full data type.;public ExpressionKeys(TypeInformation<T> type) {_			this(SELECT_ALL_CHAR, type)__		};expression,keys,that,is,defined,by,the,full,data,type;public,expression,keys,type,information,t,type,this,type
Keys -> ExpressionKeys -> public ExpressionKeys(TypeInformation<T> type);1455479358;ExpressionKeys that is defined by the full data type.;public ExpressionKeys(TypeInformation<T> type) {_			this(SELECT_ALL_CHAR, type)__		};expression,keys,that,is,defined,by,the,full,data,type;public,expression,keys,type,information,t,type,this,type
Keys -> ExpressionKeys -> public ExpressionKeys(TypeInformation<T> type);1458743533;ExpressionKeys that is defined by the full data type.;public ExpressionKeys(TypeInformation<T> type) {_			this(SELECT_ALL_CHAR, type)__		};expression,keys,that,is,defined,by,the,full,data,type;public,expression,keys,type,information,t,type,this,type
Keys -> ExpressionKeys -> public ExpressionKeys(TypeInformation<T> type);1460741894;ExpressionKeys that is defined by the full data type.;public ExpressionKeys(TypeInformation<T> type) {_			this(SELECT_ALL_CHAR, type)__		};expression,keys,that,is,defined,by,the,full,data,type;public,expression,keys,type,information,t,type,this,type
Keys -> ExpressionKeys -> public ExpressionKeys(TypeInformation<T> type);1461185548;ExpressionKeys that is defined by the full data type.;public ExpressionKeys(TypeInformation<T> type) {_			this(SELECT_ALL_CHAR, type)__		};expression,keys,that,is,defined,by,the,full,data,type;public,expression,keys,type,information,t,type,this,type
Keys -> ExpressionKeys -> public ExpressionKeys(String[] keyExpressions, TypeInformation<T> type);1454428544;Create String-based (nested) field expression keys on a composite type.;public ExpressionKeys(String[] keyExpressions, TypeInformation<T> type) {_			Preconditions.checkNotNull(keyExpressions, "Field expression cannot be null.")___			this.keyFields = new ArrayList<>(keyExpressions.length)___			if (type instanceof CompositeType){_				CompositeType<T> cType = (CompositeType<T>) type___				_				for (String keyExpr : keyExpressions) {_					if (keyExpr == null) {_						throw new InvalidProgramException("Expression key may not be null.")__					}_					_					keyExpr = keyExpr.trim()___					List<FlatFieldDescriptor> flatFields = cType.getFlatFields(keyExpr)___					if (flatFields.size() == 0) {_						throw new InvalidProgramException("Unable to extract key from expression '" + keyExpr + "' on key " + cType)__					}_					_					for (FlatFieldDescriptor field : flatFields) {_						if (!field.getType().isKeyType()) {_							throw new InvalidProgramException("This type (" + field.getType() + ") cannot be used as key.")__						}_					}_					_					keyFields.addAll(flatFields)__				}_			}_			else {_				if (!type.isKeyType()) {_					throw new InvalidProgramException("This type (" + type + ") cannot be used as key.")__				}__				_				for (String keyExpr : keyExpressions) {_					if (keyExpr == null) {_						throw new InvalidProgramException("Expression key may not be null.")__					}_					_					keyExpr = keyExpr.trim()__					_					if (!(SELECT_ALL_CHAR.equals(keyExpr) || SELECT_ALL_CHAR_SCALA.equals(keyExpr))) {_						throw new InvalidProgramException(_							"Field expression must be equal to '" + SELECT_ALL_CHAR + "' or '" + SELECT_ALL_CHAR_SCALA + "' for non-composite types.")__					}_					_					keyFields.add(new FlatFieldDescriptor(0, type))__				}_			}_		};create,string,based,nested,field,expression,keys,on,a,composite,type;public,expression,keys,string,key,expressions,type,information,t,type,preconditions,check,not,null,key,expressions,field,expression,cannot,be,null,this,key,fields,new,array,list,key,expressions,length,if,type,instanceof,composite,type,composite,type,t,c,type,composite,type,t,type,for,string,key,expr,key,expressions,if,key,expr,null,throw,new,invalid,program,exception,expression,key,may,not,be,null,key,expr,key,expr,trim,list,flat,field,descriptor,flat,fields,c,type,get,flat,fields,key,expr,if,flat,fields,size,0,throw,new,invalid,program,exception,unable,to,extract,key,from,expression,key,expr,on,key,c,type,for,flat,field,descriptor,field,flat,fields,if,field,get,type,is,key,type,throw,new,invalid,program,exception,this,type,field,get,type,cannot,be,used,as,key,key,fields,add,all,flat,fields,else,if,type,is,key,type,throw,new,invalid,program,exception,this,type,type,cannot,be,used,as,key,for,string,key,expr,key,expressions,if,key,expr,null,throw,new,invalid,program,exception,expression,key,may,not,be,null,key,expr,key,expr,trim,if,equals,key,expr,equals,key,expr,throw,new,invalid,program,exception,field,expression,must,be,equal,to,or,for,non,composite,types,key,fields,add,new,flat,field,descriptor,0,type
Keys -> ExpressionKeys -> public ExpressionKeys(String[] keyExpressions, TypeInformation<T> type);1455479358;Create String-based (nested) field expression keys on a composite type.;public ExpressionKeys(String[] keyExpressions, TypeInformation<T> type) {_			Preconditions.checkNotNull(keyExpressions, "Field expression cannot be null.")___			this.keyFields = new ArrayList<>(keyExpressions.length)___			if (type instanceof CompositeType){_				CompositeType<T> cType = (CompositeType<T>) type___				_				for (String keyExpr : keyExpressions) {_					if (keyExpr == null) {_						throw new InvalidProgramException("Expression key may not be null.")__					}_					_					keyExpr = keyExpr.trim()___					List<FlatFieldDescriptor> flatFields = cType.getFlatFields(keyExpr)___					if (flatFields.size() == 0) {_						throw new InvalidProgramException("Unable to extract key from expression '" + keyExpr + "' on key " + cType)__					}_					_					for (FlatFieldDescriptor field : flatFields) {_						if (!field.getType().isKeyType()) {_							throw new InvalidProgramException("This type (" + field.getType() + ") cannot be used as key.")__						}_					}_					_					keyFields.addAll(flatFields)__				}_			}_			else {_				if (!type.isKeyType()) {_					throw new InvalidProgramException("This type (" + type + ") cannot be used as key.")__				}__				_				for (String keyExpr : keyExpressions) {_					if (keyExpr == null) {_						throw new InvalidProgramException("Expression key may not be null.")__					}_					_					keyExpr = keyExpr.trim()__					_					if (!(SELECT_ALL_CHAR.equals(keyExpr) || SELECT_ALL_CHAR_SCALA.equals(keyExpr))) {_						throw new InvalidProgramException(_							"Field expression must be equal to '" + SELECT_ALL_CHAR + "' or '" + SELECT_ALL_CHAR_SCALA + "' for non-composite types.")__					}_					_					keyFields.add(new FlatFieldDescriptor(0, type))__				}_			}_		};create,string,based,nested,field,expression,keys,on,a,composite,type;public,expression,keys,string,key,expressions,type,information,t,type,preconditions,check,not,null,key,expressions,field,expression,cannot,be,null,this,key,fields,new,array,list,key,expressions,length,if,type,instanceof,composite,type,composite,type,t,c,type,composite,type,t,type,for,string,key,expr,key,expressions,if,key,expr,null,throw,new,invalid,program,exception,expression,key,may,not,be,null,key,expr,key,expr,trim,list,flat,field,descriptor,flat,fields,c,type,get,flat,fields,key,expr,if,flat,fields,size,0,throw,new,invalid,program,exception,unable,to,extract,key,from,expression,key,expr,on,key,c,type,for,flat,field,descriptor,field,flat,fields,if,field,get,type,is,key,type,throw,new,invalid,program,exception,this,type,field,get,type,cannot,be,used,as,key,key,fields,add,all,flat,fields,else,if,type,is,key,type,throw,new,invalid,program,exception,this,type,type,cannot,be,used,as,key,for,string,key,expr,key,expressions,if,key,expr,null,throw,new,invalid,program,exception,expression,key,may,not,be,null,key,expr,key,expr,trim,if,equals,key,expr,equals,key,expr,throw,new,invalid,program,exception,field,expression,must,be,equal,to,or,for,non,composite,types,key,fields,add,new,flat,field,descriptor,0,type
Keys -> ExpressionKeys -> public ExpressionKeys(String[] keyExpressions, TypeInformation<T> type);1458743533;Create String-based (nested) field expression keys on a composite type.;public ExpressionKeys(String[] keyExpressions, TypeInformation<T> type) {_			Preconditions.checkNotNull(keyExpressions, "Field expression cannot be null.")___			this.keyFields = new ArrayList<>(keyExpressions.length)___			if (type instanceof CompositeType){_				CompositeType<T> cType = (CompositeType<T>) type___				_				for (String keyExpr : keyExpressions) {_					if (keyExpr == null) {_						throw new InvalidProgramException("Expression key may not be null.")__					}_					_					keyExpr = keyExpr.trim()___					List<FlatFieldDescriptor> flatFields = cType.getFlatFields(keyExpr)___					if (flatFields.size() == 0) {_						throw new InvalidProgramException("Unable to extract key from expression '" + keyExpr + "' on key " + cType)__					}_					_					for (FlatFieldDescriptor field : flatFields) {_						if (!field.getType().isKeyType()) {_							throw new InvalidProgramException("This type (" + field.getType() + ") cannot be used as key.")__						}_					}_					_					keyFields.addAll(flatFields)__				}_			}_			else {_				if (!type.isKeyType()) {_					throw new InvalidProgramException("This type (" + type + ") cannot be used as key.")__				}__				_				for (String keyExpr : keyExpressions) {_					if (keyExpr == null) {_						throw new InvalidProgramException("Expression key may not be null.")__					}_					_					keyExpr = keyExpr.trim()__					_					if (!(SELECT_ALL_CHAR.equals(keyExpr) || SELECT_ALL_CHAR_SCALA.equals(keyExpr))) {_						throw new InvalidProgramException(_							"Field expression must be equal to '" + SELECT_ALL_CHAR + "' or '" + SELECT_ALL_CHAR_SCALA + "' for non-composite types.")__					}_					_					keyFields.add(new FlatFieldDescriptor(0, type))__				}_			}_		};create,string,based,nested,field,expression,keys,on,a,composite,type;public,expression,keys,string,key,expressions,type,information,t,type,preconditions,check,not,null,key,expressions,field,expression,cannot,be,null,this,key,fields,new,array,list,key,expressions,length,if,type,instanceof,composite,type,composite,type,t,c,type,composite,type,t,type,for,string,key,expr,key,expressions,if,key,expr,null,throw,new,invalid,program,exception,expression,key,may,not,be,null,key,expr,key,expr,trim,list,flat,field,descriptor,flat,fields,c,type,get,flat,fields,key,expr,if,flat,fields,size,0,throw,new,invalid,program,exception,unable,to,extract,key,from,expression,key,expr,on,key,c,type,for,flat,field,descriptor,field,flat,fields,if,field,get,type,is,key,type,throw,new,invalid,program,exception,this,type,field,get,type,cannot,be,used,as,key,key,fields,add,all,flat,fields,else,if,type,is,key,type,throw,new,invalid,program,exception,this,type,type,cannot,be,used,as,key,for,string,key,expr,key,expressions,if,key,expr,null,throw,new,invalid,program,exception,expression,key,may,not,be,null,key,expr,key,expr,trim,if,equals,key,expr,equals,key,expr,throw,new,invalid,program,exception,field,expression,must,be,equal,to,or,for,non,composite,types,key,fields,add,new,flat,field,descriptor,0,type
Keys -> ExpressionKeys -> public ExpressionKeys(String[] keyExpressions, TypeInformation<T> type);1460741894;Create String-based (nested) field expression keys on a composite type.;public ExpressionKeys(String[] keyExpressions, TypeInformation<T> type) {_			checkNotNull(keyExpressions, "Field expression cannot be null.")___			this.keyFields = new ArrayList<>(keyExpressions.length)___			if (type instanceof CompositeType){_				CompositeType<T> cType = (CompositeType<T>) type___				_				for (String keyExpr : keyExpressions) {_					if (keyExpr == null) {_						throw new InvalidProgramException("Expression key may not be null.")__					}_					_					keyExpr = keyExpr.trim()___					List<FlatFieldDescriptor> flatFields = cType.getFlatFields(keyExpr)___					if (flatFields.size() == 0) {_						throw new InvalidProgramException("Unable to extract key from expression '" + keyExpr + "' on key " + cType)__					}_					_					for (FlatFieldDescriptor field : flatFields) {_						if (!field.getType().isKeyType()) {_							throw new InvalidProgramException("This type (" + field.getType() + ") cannot be used as key.")__						}_					}_					_					keyFields.addAll(flatFields)__				}_			}_			else {_				if (!type.isKeyType()) {_					throw new InvalidProgramException("This type (" + type + ") cannot be used as key.")__				}__				_				for (String keyExpr : keyExpressions) {_					if (keyExpr == null) {_						throw new InvalidProgramException("Expression key may not be null.")__					}_					_					keyExpr = keyExpr.trim()__					_					if (!(SELECT_ALL_CHAR.equals(keyExpr) || SELECT_ALL_CHAR_SCALA.equals(keyExpr))) {_						throw new InvalidProgramException(_							"Field expression must be equal to '" + SELECT_ALL_CHAR + "' or '" + SELECT_ALL_CHAR_SCALA + "' for non-composite types.")__					}_					_					keyFields.add(new FlatFieldDescriptor(0, type))__				}_			}_		};create,string,based,nested,field,expression,keys,on,a,composite,type;public,expression,keys,string,key,expressions,type,information,t,type,check,not,null,key,expressions,field,expression,cannot,be,null,this,key,fields,new,array,list,key,expressions,length,if,type,instanceof,composite,type,composite,type,t,c,type,composite,type,t,type,for,string,key,expr,key,expressions,if,key,expr,null,throw,new,invalid,program,exception,expression,key,may,not,be,null,key,expr,key,expr,trim,list,flat,field,descriptor,flat,fields,c,type,get,flat,fields,key,expr,if,flat,fields,size,0,throw,new,invalid,program,exception,unable,to,extract,key,from,expression,key,expr,on,key,c,type,for,flat,field,descriptor,field,flat,fields,if,field,get,type,is,key,type,throw,new,invalid,program,exception,this,type,field,get,type,cannot,be,used,as,key,key,fields,add,all,flat,fields,else,if,type,is,key,type,throw,new,invalid,program,exception,this,type,type,cannot,be,used,as,key,for,string,key,expr,key,expressions,if,key,expr,null,throw,new,invalid,program,exception,expression,key,may,not,be,null,key,expr,key,expr,trim,if,equals,key,expr,equals,key,expr,throw,new,invalid,program,exception,field,expression,must,be,equal,to,or,for,non,composite,types,key,fields,add,new,flat,field,descriptor,0,type
Keys -> ExpressionKeys -> public ExpressionKeys(String[] keyExpressions, TypeInformation<T> type);1461185548;Create String-based (nested) field expression keys on a composite type.;public ExpressionKeys(String[] keyExpressions, TypeInformation<T> type) {_			checkNotNull(keyExpressions, "Field expression cannot be null.")___			this.keyFields = new ArrayList<>(keyExpressions.length)___			if (type instanceof CompositeType){_				CompositeType<T> cType = (CompositeType<T>) type__				this.originalKeyTypes = new TypeInformation<?>[keyExpressions.length]___				_				for (int i = 0_ i < keyExpressions.length_ i++) {_					String keyExpr = keyExpressions[i]___					if (keyExpr == null) {_						throw new InvalidProgramException("Expression key may not be null.")__					}_					_					keyExpr = keyExpr.trim()___					List<FlatFieldDescriptor> flatFields = cType.getFlatFields(keyExpr)___					if (flatFields.size() == 0) {_						throw new InvalidProgramException("Unable to extract key from expression '" + keyExpr + "' on key " + cType)__					}_					_					for (FlatFieldDescriptor field : flatFields) {_						if (!field.getType().isKeyType()) {_							throw new InvalidProgramException("This type (" + field.getType() + ") cannot be used as key.")__						}_					}_					_					keyFields.addAll(flatFields)___					String strippedKeyExpr = WILD_CARD_REGEX.matcher(keyExpr).replaceAll("")__					if (strippedKeyExpr.isEmpty()) {_						this.originalKeyTypes[i] = type__					} else {_						this.originalKeyTypes[i] = cType.getTypeAt(strippedKeyExpr)__					}_				}_			}_			else {_				if (!type.isKeyType()) {_					throw new InvalidProgramException("This type (" + type + ") cannot be used as key.")__				}__				_				for (String keyExpr : keyExpressions) {_					if (keyExpr == null) {_						throw new InvalidProgramException("Expression key may not be null.")__					}_					_					keyExpr = keyExpr.trim()__					_					if (!(SELECT_ALL_CHAR.equals(keyExpr) || SELECT_ALL_CHAR_SCALA.equals(keyExpr))) {_						throw new InvalidProgramException(_							"Field expression must be equal to '" + SELECT_ALL_CHAR + "' or '" + SELECT_ALL_CHAR_SCALA + "' for non-composite types.")__					}_					_					keyFields.add(new FlatFieldDescriptor(0, type))__				}_				this.originalKeyTypes = new TypeInformation[] {type}__			}_		};create,string,based,nested,field,expression,keys,on,a,composite,type;public,expression,keys,string,key,expressions,type,information,t,type,check,not,null,key,expressions,field,expression,cannot,be,null,this,key,fields,new,array,list,key,expressions,length,if,type,instanceof,composite,type,composite,type,t,c,type,composite,type,t,type,this,original,key,types,new,type,information,key,expressions,length,for,int,i,0,i,key,expressions,length,i,string,key,expr,key,expressions,i,if,key,expr,null,throw,new,invalid,program,exception,expression,key,may,not,be,null,key,expr,key,expr,trim,list,flat,field,descriptor,flat,fields,c,type,get,flat,fields,key,expr,if,flat,fields,size,0,throw,new,invalid,program,exception,unable,to,extract,key,from,expression,key,expr,on,key,c,type,for,flat,field,descriptor,field,flat,fields,if,field,get,type,is,key,type,throw,new,invalid,program,exception,this,type,field,get,type,cannot,be,used,as,key,key,fields,add,all,flat,fields,string,stripped,key,expr,matcher,key,expr,replace,all,if,stripped,key,expr,is,empty,this,original,key,types,i,type,else,this,original,key,types,i,c,type,get,type,at,stripped,key,expr,else,if,type,is,key,type,throw,new,invalid,program,exception,this,type,type,cannot,be,used,as,key,for,string,key,expr,key,expressions,if,key,expr,null,throw,new,invalid,program,exception,expression,key,may,not,be,null,key,expr,key,expr,trim,if,equals,key,expr,equals,key,expr,throw,new,invalid,program,exception,field,expression,must,be,equal,to,or,for,non,composite,types,key,fields,add,new,flat,field,descriptor,0,type,this,original,key,types,new,type,information,type
