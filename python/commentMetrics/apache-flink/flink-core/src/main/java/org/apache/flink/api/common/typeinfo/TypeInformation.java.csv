commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;0;2;/**  * Checks if this type information represents a basic type.  * Basic types are defined in {@link BasicTypeInfo} and are primitives, their boxing types,  * Strings, Date, Void, ...  *  * @return True, if this type information describes a basic type, false otherwise.  */ ;/**  * Checks if this type information represents a basic type.  * Basic types are defined in {@link BasicTypeInfo} and are primitives, their boxing types,  * Strings, Date, Void, ...  *  * @return True, if this type information describes a basic type, false otherwise.  */ @PublicEvolving public abstract boolean isBasicType().
true;public,abstract;0;2;/**  * Checks if this type information represents a Tuple type.  * Tuple types are subclasses of the Java API tuples.  *  * @return True, if this type information describes a tuple type, false otherwise.  */ ;/**  * Checks if this type information represents a Tuple type.  * Tuple types are subclasses of the Java API tuples.  *  * @return True, if this type information describes a tuple type, false otherwise.  */ @PublicEvolving public abstract boolean isTupleType().
true;public,abstract;0;2;/**  * Gets the arity of this type - the number of fields without nesting.  *  * @return Gets the number of fields in this type without nesting.  */ ;/**  * Gets the arity of this type - the number of fields without nesting.  *  * @return Gets the number of fields in this type without nesting.  */ @PublicEvolving public abstract int getArity().
true;public,abstract;0;2;/**  * Gets the number of logical fields in this type. This includes its nested and transitively nested  * fields, in the case of composite types. In the example below, the OuterType type has three  * fields in total.  *  * <p>The total number of fields must be at least 1.  *  * @return The number of fields in this type, including its sub-fields (for composite types)  */ ;/**  * Gets the number of logical fields in this type. This includes its nested and transitively nested  * fields, in the case of composite types. In the example below, the OuterType type has three  * fields in total.  *  * <p>The total number of fields must be at least 1.  *  * @return The number of fields in this type, including its sub-fields (for composite types)  */ @PublicEvolving public abstract int getTotalFields().
true;public,abstract;0;2;/**  * Gets the class of the type represented by this type information.  *  * @return The class of the type represented by this type information.  */ ;/**  * Gets the class of the type represented by this type information.  *  * @return The class of the type represented by this type information.  */ @PublicEvolving public abstract Class<T> getTypeClass().
true;public;0;5;/**  * Optional method for giving Flink's type extraction system information about the mapping  * of a generic type parameter to the type information of a subtype. This information is necessary  * in cases where type information should be deduced from an input type.  *  * <p>For instance, a method for a {@link Tuple2} would look like this:  * <code>  * Map m = new HashMap().  * m.put("T0", this.getTypeAt(0)).  * m.put("T1", this.getTypeAt(1)).  * return m.  * </code>  *  * @return map of inferred subtypes. it does not have to contain all generic parameters as key.  *         values may be null if type could not be inferred  */ ;/**  * Optional method for giving Flink's type extraction system information about the mapping  * of a generic type parameter to the type information of a subtype. This information is necessary  * in cases where type information should be deduced from an input type.  *  * <p>For instance, a method for a {@link Tuple2} would look like this:  * <code>  * Map m = new HashMap().  * m.put("T0", this.getTypeAt(0)).  * m.put("T1", this.getTypeAt(1)).  * return m.  * </code>  *  * @return map of inferred subtypes. it does not have to contain all generic parameters as key.  *         values may be null if type could not be inferred  */ @PublicEvolving public Map<String, TypeInformation<?>> getGenericParameters() {     // return an empty map as the default implementation     return Collections.emptyMap(). }
true;public,abstract;0;2;/**  * Checks whether this type can be used as a key. As a bare minimum, types have  * to be hashable and comparable to be keys.  *  * @return True, if the type can be used as a key, false otherwise.  */ ;/**  * Checks whether this type can be used as a key. As a bare minimum, types have  * to be hashable and comparable to be keys.  *  * @return True, if the type can be used as a key, false otherwise.  */ @PublicEvolving public abstract boolean isKeyType().
true;public;0;4;/**  * Checks whether this type can be used as a key for sorting.  * The order produced by sorting this type must be meaningful.  */ ;/**  * Checks whether this type can be used as a key for sorting.  * The order produced by sorting this type must be meaningful.  */ @PublicEvolving public boolean isSortKeyType() {     return isKeyType(). }
true;public,abstract;1;2;/**  * Creates a serializer for the type. The serializer may use the ExecutionConfig  * for parameterization.  *  * @param config The config used to parameterize the serializer.  * @return A serializer for this type.  */ ;/**  * Creates a serializer for the type. The serializer may use the ExecutionConfig  * for parameterization.  *  * @param config The config used to parameterize the serializer.  * @return A serializer for this type.  */ @PublicEvolving public abstract TypeSerializer<T> createSerializer(ExecutionConfig config).
false;public,abstract;0;2;;@Override public abstract String toString().
false;public,abstract;1;2;;@Override public abstract boolean equals(Object obj).
false;public,abstract;0;2;;@Override public abstract int hashCode().
true;public,abstract;1;1;/**  * Returns true if the given object can be equaled with this object. If not, it returns false.  *  * @param obj Object which wants to take part in the equality relation  * @return true if obj can be equaled with this, otherwise false  */ ;/**  * Returns true if the given object can be equaled with this object. If not, it returns false.  *  * @param obj Object which wants to take part in the equality relation  * @return true if obj can be equaled with this, otherwise false  */ public abstract boolean canEqual(Object obj).
true;public,static;1;12;/**  * Creates a TypeInformation for the type described by the given class.  *  * <p>This method only works for non-generic types. For generic types, use the  * {@link #of(TypeHint)} method.  *  * @param typeClass The class of the type.  * @param <T> The generic type.  *  * @return The TypeInformation object for the type described by the hint.  */ ;// ------------------------------------------------------------------------ /**  * Creates a TypeInformation for the type described by the given class.  *  * <p>This method only works for non-generic types. For generic types, use the  * {@link #of(TypeHint)} method.  *  * @param typeClass The class of the type.  * @param <T> The generic type.  *  * @return The TypeInformation object for the type described by the hint.  */ public static <T> TypeInformation<T> of(Class<T> typeClass) {     try {         return TypeExtractor.createTypeInfo(typeClass).     } catch (InvalidTypesException e) {         throw new FlinkRuntimeException("Cannot extract TypeInformation from Class alone, because generic parameters are missing. " + "Please use TypeInformation.of(TypeHint) instead, or another equivalent method in the API that " + "accepts a TypeHint instead of a Class. " + "For example for a Tuple2<Long, String> pass a 'new TypeHint<Tuple2<Long, String>>(){}'.").     } }
true;public,static;1;3;/**  * Creates a TypeInformation for a generic type via a utility "type hint".  * This method can be used as follows:  * <pre>  * {@code  * TypeInformation<Tuple2<String, Long>> info = TypeInformation.of(new TypeHint<Tuple2<String, Long>>(){}).  * }  * </pre>  *  * @param typeHint The hint for the generic type.  * @param <T> The generic type.  *  * @return The TypeInformation object for the type described by the hint.  */ ;/**  * Creates a TypeInformation for a generic type via a utility "type hint".  * This method can be used as follows:  * <pre>  * {@code  * TypeInformation<Tuple2<String, Long>> info = TypeInformation.of(new TypeHint<Tuple2<String, Long>>(){}).  * }  * </pre>  *  * @param typeHint The hint for the generic type.  * @param <T> The generic type.  *  * @return The TypeInformation object for the type described by the hint.  */ public static <T> TypeInformation<T> of(TypeHint<T> typeHint) {     return typeHint.getTypeInfo(). }
