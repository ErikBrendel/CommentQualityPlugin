commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;21;;@Override protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {     if (classLoader != null) {         String name = desc.getName().         try {             return Class.forName(name, false, classLoader).         } catch (ClassNotFoundException ex) {             // check if class is a primitive class             Class<?> cl = primitiveClasses.get(name).             if (cl != null) {                 // return primitive class                 return cl.             } else {                 // throw ClassNotFoundException                 throw ex.             }         }     }     return super.resolveClass(desc). }
false;protected;1;33;;@Override protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {     if (classLoader != null) {         ClassLoader nonPublicLoader = null.         boolean hasNonPublicInterface = false.         // define proxy in class loader of non-public interface(s), if any         Class<?>[] classObjs = new Class<?>[interfaces.length].         for (int i = 0. i < interfaces.length. i++) {             Class<?> cl = Class.forName(interfaces[i], false, classLoader).             if ((cl.getModifiers() & Modifier.PUBLIC) == 0) {                 if (hasNonPublicInterface) {                     if (nonPublicLoader != cl.getClassLoader()) {                         throw new IllegalAccessError("conflicting non-public interface class loaders").                     }                 } else {                     nonPublicLoader = cl.getClassLoader().                     hasNonPublicInterface = true.                 }             }             classObjs[i] = cl.         }         try {             return Proxy.getProxyClass(hasNonPublicInterface ? nonPublicLoader : classLoader, classObjs).         } catch (IllegalArgumentException e) {             throw new ClassNotFoundException(null, e).         }     }     return super.resolveProxyClass(interfaces). }
false;protected;0;32;;@Override protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException {     ObjectStreamClass streamClassDescriptor = super.readClassDescriptor().     try {         Class.forName(streamClassDescriptor.getName(), false, classLoader).     } catch (ClassNotFoundException e) {         final ObjectStreamClass equivalentSerializer = MigrationUtil.getEquivalentSerializer(streamClassDescriptor.getName()).         if (equivalentSerializer != null) {             return equivalentSerializer.         }     }     final Class localClass = resolveClass(streamClassDescriptor).     final String name = localClass.getName().     if (scalaSerializerClassnames.contains(name) || scalaTypes.contains(name) || isAnonymousClass(localClass) || isOldAvroSerializer(name, streamClassDescriptor.getSerialVersionUID())) {         final ObjectStreamClass localClassDescriptor = ObjectStreamClass.lookup(localClass).         if (localClassDescriptor != null && localClassDescriptor.getSerialVersionUID() != streamClassDescriptor.getSerialVersionUID()) {             LOG.warn("Ignoring serialVersionUID mismatch for class {}. was {}, now {}.", streamClassDescriptor.getName(), streamClassDescriptor.getSerialVersionUID(), localClassDescriptor.getSerialVersionUID()).             streamClassDescriptor = localClassDescriptor.         }     }     return streamClassDescriptor. }
false;private,static;1;16;;private static boolean isAnonymousClass(Class clazz) {     final String name = clazz.getName().     // isAnonymousClass does not work for anonymous Scala classes. additionally check by class name     if (name.contains("$anon$") || name.contains("$anonfun") || name.contains("$macro$")) {         return true.     }     // until we move to JDK 9, this try-catch is necessary     try {         return clazz.isAnonymousClass().     } catch (InternalError e) {         return false.     } }
false;private,static;2;4;;private static boolean isOldAvroSerializer(String name, long serialVersionUID) {     // please see FLINK-11436 for details on why we need to ignore serial version UID here for the AvroSerializer     return (serialVersionUID == 1) && "org.apache.flink.formats.avro.typeutils.AvroSerializer".equals(name). }
false;private,static;0;7;;private static Map<String, ObjectStreamClass> initMap() {     final Map<String, ObjectStreamClass> init = new HashMap<>(4).     for (MigrationUtil m : MigrationUtil.values()) {         init.put(m.oldSerializerName, m.newSerializerStreamClass).     }     return init. }
false;private,static;1;3;;private static ObjectStreamClass getEquivalentSerializer(String classDescriptorName) {     return EQUIVALENCE_MAP.get(classDescriptorName). }
true;public,static;3;8;/**  * Creates a new instance of the given class name and type using the provided {@link ClassLoader}.  *  * @param className of the class to load  * @param targetType type of the instantiated class  * @param classLoader to use for loading the class  * @param <T> type of the instantiated class  * @return Instance of the given class name  * @throws ClassNotFoundException if the class could not be found  */ ;/**  * Creates a new instance of the given class name and type using the provided {@link ClassLoader}.  *  * @param className of the class to load  * @param targetType type of the instantiated class  * @param classLoader to use for loading the class  * @param <T> type of the instantiated class  * @return Instance of the given class name  * @throws ClassNotFoundException if the class could not be found  */ public static <T> T instantiate(final String className, final Class<T> targetType, final ClassLoader classLoader) throws ClassNotFoundException {     final Class<? extends T> clazz = Class.forName(className, false, classLoader).asSubclass(targetType).     return instantiate(clazz). }
true;public,static;2;13;/**  * Creates a new instance of the given class.  *  * @param <T> The generic type of the class.  * @param clazz The class to instantiate.  * @param castTo Optional parameter, specifying the class that the given class must be a subclass off. This  *               argument is added to prevent class cast exceptions occurring later.  * @return An instance of the given class.  *  * @throws RuntimeException Thrown, if the class could not be instantiated. The exception contains a detailed  *                          message about the reason why the instantiation failed.  */ ;/**  * Creates a new instance of the given class.  *  * @param <T> The generic type of the class.  * @param clazz The class to instantiate.  * @param castTo Optional parameter, specifying the class that the given class must be a subclass off. This  *               argument is added to prevent class cast exceptions occurring later.  * @return An instance of the given class.  *  * @throws RuntimeException Thrown, if the class could not be instantiated. The exception contains a detailed  *                          message about the reason why the instantiation failed.  */ public static <T> T instantiate(Class<T> clazz, Class<? super T> castTo) {     if (clazz == null) {         throw new NullPointerException().     }     // check if the class is a subclass, if the check is required     if (castTo != null && !castTo.isAssignableFrom(clazz)) {         throw new RuntimeException("The class '" + clazz.getName() + "' is not a subclass of '" + castTo.getName() + "' as is required.").     }     return instantiate(clazz). }
true;public,static;1;25;/**  * Creates a new instance of the given class.  *  * @param <T> The generic type of the class.  * @param clazz The class to instantiate.  *  * @return An instance of the given class.  *  * @throws RuntimeException Thrown, if the class could not be instantiated. The exception contains a detailed  *                          message about the reason why the instantiation failed.  */ ;/**  * Creates a new instance of the given class.  *  * @param <T> The generic type of the class.  * @param clazz The class to instantiate.  *  * @return An instance of the given class.  *  * @throws RuntimeException Thrown, if the class could not be instantiated. The exception contains a detailed  *                          message about the reason why the instantiation failed.  */ public static <T> T instantiate(Class<T> clazz) {     if (clazz == null) {         throw new NullPointerException().     }     // try to instantiate the class     try {         return clazz.newInstance().     } catch (InstantiationException | IllegalAccessException iex) {         // check for the common problem causes         checkForInstantiation(clazz).         // most likely an exception in the constructor or field initialization         throw new RuntimeException("Could not instantiate type '" + clazz.getName() + "' due to an unspecified exception: " + iex.getMessage(), iex).     } catch (Throwable t) {         String message = t.getMessage().         throw new RuntimeException("Could not instantiate type '" + clazz.getName() + "' Most likely the constructor (or a member variable initialization) threw an exception" + (message == null ? "." : ": " + message), t).     } }
true;public,static;1;10;/**  * Checks, whether the given class has a public nullary constructor.  *  * @param clazz The class to check.  * @return True, if the class has a public nullary constructor, false if not.  */ ;/**  * Checks, whether the given class has a public nullary constructor.  *  * @param clazz The class to check.  * @return True, if the class has a public nullary constructor, false if not.  */ public static boolean hasPublicNullaryConstructor(Class<?> clazz) {     Constructor<?>[] constructors = clazz.getConstructors().     for (Constructor<?> constructor : constructors) {         if (constructor.getParameterTypes().length == 0 && Modifier.isPublic(constructor.getModifiers())) {             return true.         }     }     return false. }
true;public,static;1;3;/**  * Checks, whether the given class is public.  *  * @param clazz The class to check.  * @return True, if the class is public, false if not.  */ ;/**  * Checks, whether the given class is public.  *  * @param clazz The class to check.  * @return True, if the class is public, false if not.  */ public static boolean isPublic(Class<?> clazz) {     return Modifier.isPublic(clazz.getModifiers()). }
true;public,static;1;4;/**  * Checks, whether the class is a proper class, i.e. not abstract or an interface, and not a primitive type.  *  * @param clazz The class to check.  * @return True, if the class is a proper class, false otherwise.  */ ;/**  * Checks, whether the class is a proper class, i.e. not abstract or an interface, and not a primitive type.  *  * @param clazz The class to check.  * @return True, if the class is a proper class, false otherwise.  */ public static boolean isProperClass(Class<?> clazz) {     int mods = clazz.getModifiers().     return !(Modifier.isAbstract(mods) || Modifier.isInterface(mods) || Modifier.isNative(mods)). }
true;public,static;1;4;/**  * Checks, whether the class is an inner class that is not statically accessible. That is especially true for  * anonymous inner classes.  *  * @param clazz The class to check.  * @return True, if the class is a non-statically accessible inner class.  */ ;/**  * Checks, whether the class is an inner class that is not statically accessible. That is especially true for  * anonymous inner classes.  *  * @param clazz The class to check.  * @return True, if the class is a non-statically accessible inner class.  */ public static boolean isNonStaticInnerClass(Class<?> clazz) {     return clazz.getEnclosingClass() != null && (clazz.getDeclaringClass() == null || !Modifier.isStatic(clazz.getModifiers())). }
true;public,static;1;7;/**  * Performs a standard check whether the class can be instantiated by {@code Class#newInstance()}.  *  * @param clazz The class to check.  * @throws RuntimeException Thrown, if the class cannot be instantiated by {@code Class#newInstance()}.  */ ;/**  * Performs a standard check whether the class can be instantiated by {@code Class#newInstance()}.  *  * @param clazz The class to check.  * @throws RuntimeException Thrown, if the class cannot be instantiated by {@code Class#newInstance()}.  */ public static void checkForInstantiation(Class<?> clazz) {     final String errorMessage = checkForInstantiationError(clazz).     if (errorMessage != null) {         throw new RuntimeException("The class '" + clazz.getName() + "' is not instantiable: " + errorMessage).     } }
false;public,static;1;15;;public static String checkForInstantiationError(Class<?> clazz) {     if (!isPublic(clazz)) {         return "The class is not public.".     } else if (clazz.isArray()) {         return "The class is an array. An array cannot be simply instantiated, as with a parameterless constructor.".     } else if (!isProperClass(clazz)) {         return "The class is not a proper class. It is either abstract, an interface, or a primitive type.".     } else if (isNonStaticInnerClass(clazz)) {         return "The class is an inner class, but not statically accessible.".     } else if (!hasPublicNullaryConstructor(clazz)) {         return "The class has no (implicit) public nullary constructor, i.e. a constructor without arguments.".     } else {         return null.     } }
false;public,static;3;8;;public static <T> T readObjectFromConfig(Configuration config, String key, ClassLoader cl) throws IOException, ClassNotFoundException {     byte[] bytes = config.getBytes(key, null).     if (bytes == null) {         return null.     }     return deserializeObject(bytes, cl). }
false;public,static;3;4;;public static void writeObjectToConfig(Object o, Configuration config, String key) throws IOException {     byte[] bytes = serializeObject(o).     config.setBytes(key, bytes). }
false;public,static;2;10;;public static <T> byte[] serializeToByteArray(TypeSerializer<T> serializer, T record) throws IOException {     if (record == null) {         throw new NullPointerException("Record to serialize to byte array must not be null.").     }     ByteArrayOutputStream bos = new ByteArrayOutputStream(64).     DataOutputViewStreamWrapper outputViewWrapper = new DataOutputViewStreamWrapper(bos).     serializer.serialize(record, outputViewWrapper).     return bos.toByteArray(). }
false;public,static;2;8;;public static <T> T deserializeFromByteArray(TypeSerializer<T> serializer, byte[] buf) throws IOException {     if (buf == null) {         throw new NullPointerException("Byte array to deserialize from must not be null.").     }     DataInputViewStreamWrapper inputViewWrapper = new DataInputViewStreamWrapper(new ByteArrayInputStream(buf)).     return serializer.deserialize(inputViewWrapper). }
false;public,static;3;8;;public static <T> T deserializeFromByteArray(TypeSerializer<T> serializer, T reuse, byte[] buf) throws IOException {     if (buf == null) {         throw new NullPointerException("Byte array to deserialize from must not be null.").     }     DataInputViewStreamWrapper inputViewWrapper = new DataInputViewStreamWrapper(new ByteArrayInputStream(buf)).     return serializer.deserialize(reuse, inputViewWrapper). }
false;public,static;2;4;;@SuppressWarnings("unchecked") public static <T> T deserializeObject(byte[] bytes, ClassLoader cl) throws IOException, ClassNotFoundException {     return deserializeObject(bytes, cl, false). }
false;public,static;2;4;;@SuppressWarnings("unchecked") public static <T> T deserializeObject(InputStream in, ClassLoader cl) throws IOException, ClassNotFoundException {     return deserializeObject(in, cl, false). }
false;public,static;3;6;;@SuppressWarnings("unchecked") public static <T> T deserializeObject(byte[] bytes, ClassLoader cl, boolean isFailureTolerant) throws IOException, ClassNotFoundException {     return deserializeObject(new ByteArrayInputStream(bytes), cl, isFailureTolerant). }
false;public,static;3;17;;@SuppressWarnings("unchecked") public static <T> T deserializeObject(InputStream in, ClassLoader cl, boolean isFailureTolerant) throws IOException, ClassNotFoundException {     final ClassLoader old = Thread.currentThread().getContextClassLoader().     // not using resource try to avoid AutoClosable's close() on the given stream     try {         ObjectInputStream oois = isFailureTolerant ? new InstantiationUtil.FailureTolerantObjectInputStream(in, cl) : new InstantiationUtil.ClassLoaderObjectInputStream(in, cl).         Thread.currentThread().setContextClassLoader(cl).         return (T) oois.readObject().     } finally {         Thread.currentThread().setContextClassLoader(old).     } }
false;public,static;1;8;;public static byte[] serializeObject(Object o) throws IOException {     try (ByteArrayOutputStream baos = new ByteArrayOutputStream().         ObjectOutputStream oos = new ObjectOutputStream(baos)) {         oos.writeObject(o).         oos.flush().         return baos.toByteArray().     } }
false;public,static;2;4;;public static void serializeObject(OutputStream out, Object o) throws IOException {     ObjectOutputStream oos = new ObjectOutputStream(out).     oos.writeObject(o). }
false;public,static;1;9;;public static boolean isSerializable(Object o) {     try {         serializeObject(o).     } catch (IOException e) {         return false.     }     return true. }
true;public,static;1;7;/**  * Clones the given serializable object using Java serialization.  *  * @param obj Object to clone  * @param <T> Type of the object to clone  * @return The cloned object  *  * @throws IOException Thrown if the serialization or deserialization process fails.  * @throws ClassNotFoundException Thrown if any of the classes referenced by the object  *                                cannot be resolved during deserialization.  */ ;/**  * Clones the given serializable object using Java serialization.  *  * @param obj Object to clone  * @param <T> Type of the object to clone  * @return The cloned object  *  * @throws IOException Thrown if the serialization or deserialization process fails.  * @throws ClassNotFoundException Thrown if any of the classes referenced by the object  *                                cannot be resolved during deserialization.  */ public static <T extends Serializable> T clone(T obj) throws IOException, ClassNotFoundException {     if (obj == null) {         return null.     } else {         return clone(obj, obj.getClass().getClassLoader()).     } }
true;public,static;2;8;/**  * Clones the given serializable object using Java serialization, using the given classloader to  * resolve the cloned classes.  *  * @param obj Object to clone  * @param classLoader The classloader to resolve the classes during deserialization.  * @param <T> Type of the object to clone  *  * @return Cloned object  *  * @throws IOException Thrown if the serialization or deserialization process fails.  * @throws ClassNotFoundException Thrown if any of the classes referenced by the object  *                                cannot be resolved during deserialization.  */ ;/**  * Clones the given serializable object using Java serialization, using the given classloader to  * resolve the cloned classes.  *  * @param obj Object to clone  * @param classLoader The classloader to resolve the classes during deserialization.  * @param <T> Type of the object to clone  *  * @return Cloned object  *  * @throws IOException Thrown if the serialization or deserialization process fails.  * @throws ClassNotFoundException Thrown if any of the classes referenced by the object  *                                cannot be resolved during deserialization.  */ public static <T extends Serializable> T clone(T obj, ClassLoader classLoader) throws IOException, ClassNotFoundException {     if (obj == null) {         return null.     } else {         final byte[] serializedObject = serializeObject(obj).         return deserializeObject(serializedObject, classLoader).     } }
true;public,static;1;19;/**  * Clones the given writable using the {@link IOReadableWritable serialization}.  *  * @param original Object to clone  * @param <T> Type of the object to clone  * @return Cloned object  * @throws IOException Thrown is the serialization fails.  */ ;/**  * Clones the given writable using the {@link IOReadableWritable serialization}.  *  * @param original Object to clone  * @param <T> Type of the object to clone  * @return Cloned object  * @throws IOException Thrown is the serialization fails.  */ public static <T extends IOReadableWritable> T createCopyWritable(T original) throws IOException {     if (original == null) {         return null.     }     final ByteArrayOutputStream baos = new ByteArrayOutputStream().     try (DataOutputViewStreamWrapper out = new DataOutputViewStreamWrapper(baos)) {         original.write(out).     }     final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()).     try (DataInputViewStreamWrapper in = new DataInputViewStreamWrapper(bais)) {         @SuppressWarnings("unchecked")         T copy = (T) instantiate(original.getClass()).         copy.read(in).         return copy.     } }
true;public,static;2;5;/**  * Loads a class by name from the given input stream and reflectively instantiates it.  *  * <p>This method will use {@link DataInputView#readUTF()} to read the class name, and  * then attempt to load the class from the given ClassLoader.  *  * @param in The stream to read the class name from.  * @param cl The class loader to resolve the class.  *  * @throws IOException Thrown, if the class name could not be read, the class could not be found.  */ ;/**  * Loads a class by name from the given input stream and reflectively instantiates it.  *  * <p>This method will use {@link DataInputView#readUTF()} to read the class name, and  * then attempt to load the class from the given ClassLoader.  *  * @param in The stream to read the class name from.  * @param cl The class loader to resolve the class.  *  * @throws IOException Thrown, if the class name could not be read, the class could not be found.  */ public static <T> Class<T> resolveClassByName(DataInputView in, ClassLoader cl) throws IOException {     return resolveClassByName(in, cl, Object.class). }
true;public,static;3;23;/**  * Loads a class by name from the given input stream and reflectively instantiates it.  *  * <p>This method will use {@link DataInputView#readUTF()} to read the class name, and  * then attempt to load the class from the given ClassLoader.  *  * <p>The resolved class is checked to be equal to or a subtype of the given supertype  * class.  *  * @param in The stream to read the class name from.  * @param cl The class loader to resolve the class.  * @param supertype A class that the resolved class must extend.  *  * @throws IOException Thrown, if the class name could not be read, the class could not be found,  *                     or the class is not a subtype of the given supertype class.  */ ;/**  * Loads a class by name from the given input stream and reflectively instantiates it.  *  * <p>This method will use {@link DataInputView#readUTF()} to read the class name, and  * then attempt to load the class from the given ClassLoader.  *  * <p>The resolved class is checked to be equal to or a subtype of the given supertype  * class.  *  * @param in The stream to read the class name from.  * @param cl The class loader to resolve the class.  * @param supertype A class that the resolved class must extend.  *  * @throws IOException Thrown, if the class name could not be read, the class could not be found,  *                     or the class is not a subtype of the given supertype class.  */ public static <T> Class<T> resolveClassByName(DataInputView in, ClassLoader cl, Class<? super T> supertype) throws IOException {     final String className = in.readUTF().     final Class<?> rawClazz.     try {         rawClazz = Class.forName(className, false, cl).     } catch (ClassNotFoundException e) {         throw new IOException("Could not find class '" + className + "' in classpath.", e).     }     if (!supertype.isAssignableFrom(rawClazz)) {         throw new IOException("The class " + className + " is not a subclass of " + supertype.getName()).     }     @SuppressWarnings("unchecked")     Class<T> clazz = (Class<T>) rawClazz.     return clazz. }
