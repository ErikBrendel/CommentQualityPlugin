commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;1;1;/**  * Create a serializer that is able to serialize the generic type {@code typeClass}.  */ ;/**  * Create a serializer that is able to serialize the generic type {@code typeClass}.  */ protected abstract TypeSerializer<T> createSerializer(Class<T> typeClass).
true;protected,abstract;1;1;/**  * Gets the type class from the corresponding serializer.  */ ;/**  * Gets the type class from the corresponding serializer.  */ protected abstract Class<T> getTypeClass(S serializer).
true;protected,abstract;0;1;/**  * Gets the serializer's class.  */ ;/**  * Gets the serializer's class.  */ protected abstract Class<?> serializerClass().
false;public,final;0;4;;@Override public final int getCurrentVersion() {     return VERSION. }
false;public,final;1;5;;@Override public final void writeSnapshot(DataOutputView out) throws IOException {     checkState(typeClass != null, "type class can not be NULL").     out.writeUTF(typeClass.getName()). }
false;public,final;3;4;;@Override public final void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     typeClass = InstantiationUtil.resolveClassByName(in, userCodeClassLoader). }
false;public,final;0;6;;@Override @SuppressWarnings("unchecked") public final TypeSerializer<T> restoreSerializer() {     checkState(typeClass != null, "type class can not be NULL").     return createSerializer(typeClass). }
false;public,final;1;13;;@Override public final TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializer<T> newSerializer) {     if (!serializerClass().isInstance(newSerializer)) {         return TypeSerializerSchemaCompatibility.incompatible().     }     @SuppressWarnings("unchecked")     S casted = (S) newSerializer.     if (typeClass == getTypeClass(casted)) {         return TypeSerializerSchemaCompatibility.compatibleAsIs().     } else {         return TypeSerializerSchemaCompatibility.incompatible().     } }
