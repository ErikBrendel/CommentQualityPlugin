commented;modifiers;parameterAmount;loc;comment;code
true;private;1;11;/**  * Checks if the provided path string is either null or has zero length and throws  * a {@link IllegalArgumentException} if any of the two conditions apply.  * In addition, leading and tailing whitespaces are removed.  *  * @param path  *        the path string to be checked  * @return The checked and trimmed path.  */ ;/**  * Checks if the provided path string is either null or has zero length and throws  * a {@link IllegalArgumentException} if any of the two conditions apply.  * In addition, leading and tailing whitespaces are removed.  *  * @param path  *        the path string to be checked  * @return The checked and trimmed path.  */ private String checkAndTrimPathArg(String path) {     // disallow construction of a Path from an empty string     if (path == null) {         throw new IllegalArgumentException("Can not create a Path from a null string").     }     path = path.trim().     if (path.length() == 0) {         throw new IllegalArgumentException("Can not create a Path from an empty string").     }     return path. }
true;private;3;7;/**  * Initializes a path object given the scheme, authority and path string.  *  * @param scheme  *        the scheme string.  * @param authority  *        the authority string.  * @param path  *        the path string.  */ ;/**  * Initializes a path object given the scheme, authority and path string.  *  * @param scheme  *        the scheme string.  * @param authority  *        the authority string.  * @param path  *        the path string.  */ private void initialize(String scheme, String authority, String path) {     try {         this.uri = new URI(scheme, authority, normalizePath(path), null, null).normalize().     } catch (URISyntaxException e) {         throw new IllegalArgumentException(e).     } }
true;private;1;20;/**  * Normalizes a path string.  *  * @param path  *        the path string to normalize  * @return the normalized path string  */ ;/**  * Normalizes a path string.  *  * @param path  *        the path string to normalize  * @return the normalized path string  */ private String normalizePath(String path) {     // remove leading and tailing whitespaces     path = path.trim().     // remove consecutive slashes & backslashes     path = path.replace("\\", "/").     path = path.replaceAll("/+", "/").     // remove tailing separator     if (path.endsWith(SEPARATOR) && // UNIX root path     !path.equals(SEPARATOR) && !WINDOWS_ROOT_DIR_REGEX.matcher(path).matches()) {         // Windows root path)         // remove tailing slash         path = path.substring(0, path.length() - SEPARATOR.length()).     }     return path. }
true;public;0;3;/**  * Converts the path object to a {@link URI}.  *  * @return the {@link URI} object converted from the path object  */ ;/**  * Converts the path object to a {@link URI}.  *  * @return the {@link URI} object converted from the path object  */ public URI toUri() {     return uri. }
true;public;0;3;/**  * Returns the FileSystem that owns this Path.  *  * @return the FileSystem that owns this Path  * @throws IOException  *         thrown if the file system could not be retrieved  */ ;/**  * Returns the FileSystem that owns this Path.  *  * @return the FileSystem that owns this Path  * @throws IOException  *         thrown if the file system could not be retrieved  */ public FileSystem getFileSystem() throws IOException {     return FileSystem.get(this.toUri()). }
true;public;0;4;/**  * Checks if the directory of this path is absolute.  *  * @return <code>true</code> if the directory of this path is absolute, <code>false</code> otherwise  */ ;/**  * Checks if the directory of this path is absolute.  *  * @return <code>true</code> if the directory of this path is absolute, <code>false</code> otherwise  */ public boolean isAbsolute() {     final int start = hasWindowsDrive(uri.getPath(), true) ? 3 : 0.     return uri.getPath().startsWith(SEPARATOR, start). }
true;public;0;5;/**  * Returns the final component of this path, i.e., everything that follows the last separator.  *  * @return the final component of the path  */ ;/**  * Returns the final component of this path, i.e., everything that follows the last separator.  *  * @return the final component of the path  */ public String getName() {     final String path = uri.getPath().     final int slash = path.lastIndexOf(SEPARATOR).     return path.substring(slash + 1). }
true;public;0;3;/**  * Return full path.  * @return full path  */ ;/**  * Return full path.  * @return full path  */ public String getPath() {     return uri.getPath(). }
true;public;0;17;/**  * Returns the parent of a path, i.e., everything that precedes the last separator  * or <code>null</code> if at root.  *  * @return the parent of a path or <code>null</code> if at root.  */ ;/**  * Returns the parent of a path, i.e., everything that precedes the last separator  * or <code>null</code> if at root.  *  * @return the parent of a path or <code>null</code> if at root.  */ public Path getParent() {     final String path = uri.getPath().     final int lastSlash = path.lastIndexOf('/').     final int start = hasWindowsDrive(path, true) ? 3 : 0.     if (// empty path     (path.length() == start) || (lastSlash == start && path.length() == start + 1)) {         // at root         return null.     }     String parent.     if (lastSlash == -1) {         parent = CUR_DIR.     } else {         final int end = hasWindowsDrive(path, true) ? 3 : 0.         parent = path.substring(0, lastSlash == end ? end + 1 : lastSlash).     }     return new Path(uri.getScheme(), uri.getAuthority(), parent). }
true;public;1;3;/**  * Adds a suffix to the final name in the path.  *  * @param suffix The suffix to be added  * @return the new path including the suffix  */ ;/**  * Adds a suffix to the final name in the path.  *  * @param suffix The suffix to be added  * @return the new path including the suffix  */ public Path suffix(String suffix) {     return new Path(getParent(), getName() + suffix). }
false;public;0;24;;@Override public String toString() {     // we can't use uri.toString(), which escapes everything, because we want     // illegal characters unescaped in the string, for glob processing, etc.     final StringBuilder buffer = new StringBuilder().     if (uri.getScheme() != null) {         buffer.append(uri.getScheme()).         buffer.append(":").     }     if (uri.getAuthority() != null) {         buffer.append("//").         buffer.append(uri.getAuthority()).     }     if (uri.getPath() != null) {         String path = uri.getPath().         if (// has windows drive         path.indexOf('/') == 0 && hasWindowsDrive(path, true) && // but no scheme         uri.getScheme() == null && uri.getAuthority() == null) {             // or authority             // remove slash before drive             path = path.substring(1).         }         buffer.append(path).     }     return buffer.toString(). }
false;public;1;8;;@Override public boolean equals(Object o) {     if (!(o instanceof Path)) {         return false.     }     Path that = (Path) o.     return this.uri.equals(that.uri). }
false;public;0;4;;@Override public int hashCode() {     return uri.hashCode(). }
false;public;1;4;;public int compareTo(Object o) {     Path that = (Path) o.     return this.uri.compareTo(that.uri). }
true;public;0;10;/**  * Returns the number of elements in this path.  *  * @return the number of elements in this path  */ ;/**  * Returns the number of elements in this path.  *  * @return the number of elements in this path  */ public int depth() {     String path = uri.getPath().     int depth = 0.     int slash = path.length() == 1 && path.charAt(0) == '/' ? -1 : 0.     while (slash != -1) {         depth++.         slash = path.indexOf(SEPARATOR, slash + 1).     }     return depth. }
true;public;1;29;/**  * Returns a qualified path object.  *  * @param fs  *        the FileSystem that should be used to obtain the current working directory  * @return the qualified path object  */ ;/**  * Returns a qualified path object.  *  * @param fs  *        the FileSystem that should be used to obtain the current working directory  * @return the qualified path object  */ public Path makeQualified(FileSystem fs) {     Path path = this.     if (!isAbsolute()) {         path = new Path(fs.getWorkingDirectory(), this).     }     final URI pathUri = path.toUri().     final URI fsUri = fs.getUri().     String scheme = pathUri.getScheme().     String authority = pathUri.getAuthority().     if (scheme != null && (authority != null || fsUri.getAuthority() == null)) {         return path.     }     if (scheme == null) {         scheme = fsUri.getScheme().     }     if (authority == null) {         authority = fsUri.getAuthority().         if (authority == null) {             authority = "".         }     }     return new Path(scheme + ":" + "//" + authority + pathUri.getPath()). }
false;public;1;19;;// ------------------------------------------------------------------------ // Legacy Serialization // ------------------------------------------------------------------------ @Override public void read(DataInputView in) throws IOException {     final boolean isNotNull = in.readBoolean().     if (isNotNull) {         final String scheme = StringUtils.readNullableString(in).         final String userInfo = StringUtils.readNullableString(in).         final String host = StringUtils.readNullableString(in).         final int port = in.readInt().         final String path = StringUtils.readNullableString(in).         final String query = StringUtils.readNullableString(in).         final String fragment = StringUtils.readNullableString(in).         try {             uri = new URI(scheme, userInfo, host, port, path, query, fragment).         } catch (URISyntaxException e) {             throw new IOException("Error reconstructing URI", e).         }     } }
false;public;1;15;;@Override public void write(DataOutputView out) throws IOException {     if (uri == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         StringUtils.writeNullableString(uri.getScheme(), out).         StringUtils.writeNullableString(uri.getUserInfo(), out).         StringUtils.writeNullableString(uri.getHost(), out).         out.writeInt(uri.getPort()).         StringUtils.writeNullableString(uri.getPath(), out).         StringUtils.writeNullableString(uri.getQuery(), out).         StringUtils.writeNullableString(uri.getFragment(), out).     } }
true;public;0;3;/**  * Checks if the provided path string contains a windows drive letter.  *  * @return True, if the path string contains a windows drive letter, false otherwise.  */ ;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ /**  * Checks if the provided path string contains a windows drive letter.  *  * @return True, if the path string contains a windows drive letter, false otherwise.  */ public boolean hasWindowsDrive() {     return hasWindowsDrive(uri.getPath(), true). }
true;private;2;8;/**  * Checks if the provided path string contains a windows drive letter.  *  * @param path  *        the path to check  * @param slashed  *         true to indicate the first character of the string is a slash, false otherwise  *  * @return <code>true</code> if the path string contains a windows drive letter, false otherwise  */ ;/**  * Checks if the provided path string contains a windows drive letter.  *  * @param path  *        the path to check  * @param slashed  *         true to indicate the first character of the string is a slash, false otherwise  *  * @return <code>true</code> if the path string contains a windows drive letter, false otherwise  */ private boolean hasWindowsDrive(String path, boolean slashed) {     final int start = slashed ? 1 : 0.     return path.length() >= start + 2 && (!slashed || path.charAt(0) == '/') && path.charAt(start + 1) == ':' && ((path.charAt(start) >= 'A' && path.charAt(start) <= 'Z') || (path.charAt(start) >= 'a' && path.charAt(start) <= 'z')). }
true;public,static;1;3;/**  * Creates a path for the given local file.  *  * <p>This method is useful to make sure the path creation for local files works  * seamlessly across different operating systems. Especially Windows has slightly  * different rules for slashes between schema and a local file path, making it  * sometimes tricky to produce cross-platform URIs for local files.  *  * @param file The file that the path should represent.  * @return A path representing the local file URI of the given file.  */ ;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ /**  * Creates a path for the given local file.  *  * <p>This method is useful to make sure the path creation for local files works  * seamlessly across different operating systems. Especially Windows has slightly  * different rules for slashes between schema and a local file path, making it  * sometimes tricky to produce cross-platform URIs for local files.  *  * @param file The file that the path should represent.  * @return A path representing the local file URI of the given file.  */ public static Path fromLocalFile(File file) {     return new Path(file.toURI()). }
