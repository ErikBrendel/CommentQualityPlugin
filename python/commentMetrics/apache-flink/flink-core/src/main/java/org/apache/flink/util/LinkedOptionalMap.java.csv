commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;11;/**  * Creates an {@code LinkedOptionalMap} from the provided map.  *  * <p>This method is the equivalent of {@link Optional#of(Object)} but for maps. To support more than one {@code NULL}  * key, an optional map requires a unique string name to be associated with each key (provided by keyNameGetter)  *  * @param sourceMap     a source map to wrap as an optional map.  * @param keyNameGetter function that assigns a unique name to the keys of the source map.  * @param <K>           key type  * @param <V>           value type  * @return an {@code LinkedOptionalMap} with optional named keys, and optional values.  */ ;// -------------------------------------------------------------------------------------------------------- // Factory // -------------------------------------------------------------------------------------------------------- /**  * Creates an {@code LinkedOptionalMap} from the provided map.  *  * <p>This method is the equivalent of {@link Optional#of(Object)} but for maps. To support more than one {@code NULL}  * key, an optional map requires a unique string name to be associated with each key (provided by keyNameGetter)  *  * @param sourceMap     a source map to wrap as an optional map.  * @param keyNameGetter function that assigns a unique name to the keys of the source map.  * @param <K>           key type  * @param <V>           value type  * @return an {@code LinkedOptionalMap} with optional named keys, and optional values.  */ public static <K, V> LinkedOptionalMap<K, V> optionalMapOf(Map<K, V> sourceMap, Function<K, String> keyNameGetter) {     LinkedHashMap<String, KeyValue<K, V>> underlyingMap = new LinkedHashMap<>(sourceMap.size()).     sourceMap.forEach((k, v) -> {         String keyName = keyNameGetter.apply(k).         underlyingMap.put(keyName, new KeyValue<>(k, v)).     }).     return new LinkedOptionalMap<>(underlyingMap). }
true;public,static;2;6;/**  * Tries to merges the keys and the values of @right into @left.  */ ;/**  * Tries to merges the keys and the values of @right into @left.  */ public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right) {     LinkedOptionalMap<K, V> merged = new LinkedOptionalMap<>(left).     merged.putAll(right).     return new MergeResult<>(merged, isLeftPrefixOfRight(left, right)). }
false;public;0;3;;// -------------------------------------------------------------------------------------------------------- // API // -------------------------------------------------------------------------------------------------------- public int size() {     return underlyingMap.size(). }
false;public;3;6;;public void put(String keyName, @Nullable K key, @Nullable V value) {     checkNotNull(keyName).     underlyingMap.compute(keyName, (unused, kv) -> (kv == null) ? new KeyValue<>(key, value) : kv.merge(key, value)). }
false;;1;6;;void putAll(LinkedOptionalMap<K, V> right) {     for (Entry<String, KeyValue<K, V>> entry : right.underlyingMap.entrySet()) {         KeyValue<K, V> kv = entry.getValue().         this.put(entry.getKey(), kv.key, kv.value).     } }
true;public;0;7;/**  * Returns the key names of any keys or values that are absent.  */ ;/**  * Returns the key names of any keys or values that are absent.  */ public Set<String> absentKeysOrValues() {     return underlyingMap.entrySet().stream().filter(LinkedOptionalMap::keyOrValueIsAbsent).map(Entry::getKey).collect(Collectors.toCollection(LinkedHashSet::new)). }
true;public;0;8;/**  * Checks whether there are entries with absent keys or values.  */ ;/**  * Checks whether there are entries with absent keys or values.  */ public boolean hasAbsentKeysOrValues() {     for (Entry<String, KeyValue<K, V>> entry : underlyingMap.entrySet()) {         if (keyOrValueIsAbsent(entry)) {             return true.         }     }     return false. }
false;;3;1;;void accept(@Nonnull String keyName, @Nullable K key, @Nullable V value) throws E.
false;public;1;6;;public <E extends Throwable> void forEach(ConsumerWithException<K, V, E> consumer) throws E {     for (Entry<String, KeyValue<K, V>> entry : underlyingMap.entrySet()) {         KeyValue<K, V> kv = entry.getValue().         consumer.accept(entry.getKey(), kv.key, kv.value).     } }
false;public;0;7;;public Set<KeyValue<K, V>> getPresentEntries() {     return underlyingMap.entrySet().stream().filter(entry -> !LinkedOptionalMap.keyOrValueIsAbsent(entry)).map(Entry::getValue).collect(Collectors.toCollection(LinkedHashSet::new)). }
true;public;0;16;/**  * Assuming all the entries of this map are present (keys and values) this method would return  * a map with these key and values, stripped from their Optional wrappers.  * NOTE: please note that if any of the key or values are absent this method would throw an {@link IllegalStateException}.  */ ;/**  * Assuming all the entries of this map are present (keys and values) this method would return  * a map with these key and values, stripped from their Optional wrappers.  * NOTE: please note that if any of the key or values are absent this method would throw an {@link IllegalStateException}.  */ public LinkedHashMap<K, V> unwrapOptionals() {     final LinkedHashMap<K, V> unwrapped = new LinkedHashMap<>(underlyingMap.size()).     for (Entry<String, KeyValue<K, V>> entry : underlyingMap.entrySet()) {         String namedKey = entry.getKey().         KeyValue<K, V> kv = entry.getValue().         if (kv.key == null) {             throw new IllegalStateException("Missing key '" + namedKey + "'").         }         if (kv.value == null) {             throw new IllegalStateException("Missing value for the key '" + namedKey + "'").         }         unwrapped.put(kv.key, kv.value).     }     return unwrapped. }
true;public;0;3;/**  * Returns the key names added to this map.  */ ;/**  * Returns the key names added to this map.  */ public Set<String> keyNames() {     return underlyingMap.keySet(). }
false;private,static;1;4;;// -------------------------------------------------------------------------------------------------------- // Static Utility Methods // -------------------------------------------------------------------------------------------------------- private static <K, V> boolean keyOrValueIsAbsent(Entry<String, KeyValue<K, V>> entry) {     KeyValue<K, V> kv = entry.getValue().     return kv.key == null || kv.value == null. }
false;static;2;15;;@VisibleForTesting static <K, V> boolean isLeftPrefixOfRight(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right) {     Iterator<String> rightKeys = right.keyNames().iterator().     for (String leftKey : left.keyNames()) {         if (!rightKeys.hasNext()) {             return false.         }         String rightKey = rightKeys.next().         if (!leftKey.equals(rightKey)) {             return false.         }     }     return true. }
false;public;0;3;;public K getKey() {     return key. }
false;public;0;3;;public V getValue() {     return value. }
false;;2;5;;KeyValue<K, V> merge(K key, V value) {     this.key = firstNonNull(key, this.key).     this.value = firstNonNull(value, this.value).     return this. }
false;private,static;2;6;;private static <T> T firstNonNull(T first, T second) {     if (first != null) {         return first.     }     return second. }
false;public;0;3;;public boolean hasMissingKeys() {     return !missingKeys.isEmpty(). }
false;public;0;3;;public Set<String> missingKeys() {     return missingKeys. }
false;public;0;3;;public LinkedHashMap<K, V> getMerged() {     return merged.unwrapOptionals(). }
true;public;0;3;/**  * Returns {@code true} if keyNames present at @left, appearing in prefix order at @right.  */ ;/**  * Returns {@code true} if keyNames present at @left, appearing in prefix order at @right.  */ public boolean isOrderedSubset() {     return isOrderedSubset. }
