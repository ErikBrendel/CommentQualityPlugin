# id;timestamp;commentText;codeText;commentWords;codeWords
LinkedOptionalMap -> public Set<String> keyNames();1550821416;Returns the key names added to this map.;public Set<String> keyNames() {_		return underlyingMap.keySet()__	};returns,the,key,names,added,to,this,map;public,set,string,key,names,return,underlying,map,key,set
LinkedOptionalMap -> public Set<String> keyNames();1550821416;Returns the key names added to this map.;public Set<String> keyNames() {_		return underlyingMap.keySet()__	};returns,the,key,names,added,to,this,map;public,set,string,key,names,return,underlying,map,key,set
LinkedOptionalMap -> public Set<String> keyNames();1550821417;Returns the key names added to this map.;public Set<String> keyNames() {_		return underlyingMap.keySet()__	};returns,the,key,names,added,to,this,map;public,set,string,key,names,return,underlying,map,key,set
LinkedOptionalMap -> public Set<String> keyNames();1550821418;Returns the key names added to this map.;public Set<String> keyNames() {_		return underlyingMap.keySet()__	};returns,the,key,names,added,to,this,map;public,set,string,key,names,return,underlying,map,key,set
LinkedOptionalMap -> MergeResult -> public boolean isOrderedSubset();1550821416;Returns {@code true} if keyNames present at @left, appearing in prefix order at @right.;public boolean isOrderedSubset() {_			return isOrderedSubset__		};returns,code,true,if,key,names,present,at,left,appearing,in,prefix,order,at,right;public,boolean,is,ordered,subset,return,is,ordered,subset
LinkedOptionalMap -> MergeResult -> public boolean isOrderedSubset();1550821416;Returns {@code true} if keyNames present at @left, appearing in prefix order at @right.;public boolean isOrderedSubset() {_			return isOrderedSubset__		};returns,code,true,if,key,names,present,at,left,appearing,in,prefix,order,at,right;public,boolean,is,ordered,subset,return,is,ordered,subset
LinkedOptionalMap -> MergeResult -> public boolean isOrderedSubset();1550821417;Returns {@code true} if keyNames present at @left, appearing in prefix order at @right.;public boolean isOrderedSubset() {_			return isOrderedSubset__		};returns,code,true,if,key,names,present,at,left,appearing,in,prefix,order,at,right;public,boolean,is,ordered,subset,return,is,ordered,subset
LinkedOptionalMap -> MergeResult -> public boolean isOrderedSubset();1550821418;Returns {@code true} if keyNames present at @left, appearing in prefix order at @right.;public boolean isOrderedSubset() {_			return isOrderedSubset__		};returns,code,true,if,key,names,present,at,left,appearing,in,prefix,order,at,right;public,boolean,is,ordered,subset,return,is,ordered,subset
LinkedOptionalMap -> public LinkedHashMap<K, V> unwrapOptionals();1550821416;Assuming all the entries of this map are present (keys and values) this method would return_a map with these key and values, stripped from their Optional wrappers._NOTE: please note that if any of the key or values are absent this method would throw an {@link IllegalStateException}.;public LinkedHashMap<K, V> unwrapOptionals() {_		final LinkedHashMap<K, V> unwrapped = new LinkedHashMap<>(underlyingMap.size())___		for (Entry<String, KeyValue<K, V>> entry : underlyingMap.entrySet()) {_			String namedKey = entry.getKey()__			KeyValue<K, V> kv = entry.getValue()__			if (kv.key == null) {_				throw new IllegalStateException("Missing key '" + namedKey + "'")__			}_			if (kv.value == null) {_				throw new IllegalStateException("Missing value for the key '" + namedKey + "'")__			}_			unwrapped.put(kv.key, kv.value)__		}__		return unwrapped__	};assuming,all,the,entries,of,this,map,are,present,keys,and,values,this,method,would,return,a,map,with,these,key,and,values,stripped,from,their,optional,wrappers,note,please,note,that,if,any,of,the,key,or,values,are,absent,this,method,would,throw,an,link,illegal,state,exception;public,linked,hash,map,k,v,unwrap,optionals,final,linked,hash,map,k,v,unwrapped,new,linked,hash,map,underlying,map,size,for,entry,string,key,value,k,v,entry,underlying,map,entry,set,string,named,key,entry,get,key,key,value,k,v,kv,entry,get,value,if,kv,key,null,throw,new,illegal,state,exception,missing,key,named,key,if,kv,value,null,throw,new,illegal,state,exception,missing,value,for,the,key,named,key,unwrapped,put,kv,key,kv,value,return,unwrapped
LinkedOptionalMap -> public LinkedHashMap<K, V> unwrapOptionals();1550821416;Assuming all the entries of this map are present (keys and values) this method would return_a map with these key and values, stripped from their Optional wrappers._NOTE: please note that if any of the key or values are absent this method would throw an {@link IllegalStateException}.;public LinkedHashMap<K, V> unwrapOptionals() {_		final LinkedHashMap<K, V> unwrapped = new LinkedHashMap<>(underlyingMap.size())___		for (Entry<String, KeyValue<K, V>> entry : underlyingMap.entrySet()) {_			String namedKey = entry.getKey()__			KeyValue<K, V> kv = entry.getValue()__			if (kv.key == null) {_				throw new IllegalStateException("Missing key '" + namedKey + "'")__			}_			if (kv.value == null) {_				throw new IllegalStateException("Missing value for the key '" + namedKey + "'")__			}_			unwrapped.put(kv.key, kv.value)__		}_		return unwrapped__	};assuming,all,the,entries,of,this,map,are,present,keys,and,values,this,method,would,return,a,map,with,these,key,and,values,stripped,from,their,optional,wrappers,note,please,note,that,if,any,of,the,key,or,values,are,absent,this,method,would,throw,an,link,illegal,state,exception;public,linked,hash,map,k,v,unwrap,optionals,final,linked,hash,map,k,v,unwrapped,new,linked,hash,map,underlying,map,size,for,entry,string,key,value,k,v,entry,underlying,map,entry,set,string,named,key,entry,get,key,key,value,k,v,kv,entry,get,value,if,kv,key,null,throw,new,illegal,state,exception,missing,key,named,key,if,kv,value,null,throw,new,illegal,state,exception,missing,value,for,the,key,named,key,unwrapped,put,kv,key,kv,value,return,unwrapped
LinkedOptionalMap -> public LinkedHashMap<K, V> unwrapOptionals();1550821417;Assuming all the entries of this map are present (keys and values) this method would return_a map with these key and values, stripped from their Optional wrappers._NOTE: please note that if any of the key or values are absent this method would throw an {@link IllegalStateException}.;public LinkedHashMap<K, V> unwrapOptionals() {_		final LinkedHashMap<K, V> unwrapped = new LinkedHashMap<>(underlyingMap.size())___		for (Entry<String, KeyValue<K, V>> entry : underlyingMap.entrySet()) {_			String namedKey = entry.getKey()__			KeyValue<K, V> kv = entry.getValue()__			if (kv.key == null) {_				throw new IllegalStateException("Missing key '" + namedKey + "'")__			}_			if (kv.value == null) {_				throw new IllegalStateException("Missing value for the key '" + namedKey + "'")__			}_			unwrapped.put(kv.key, kv.value)__		}_		return unwrapped__	};assuming,all,the,entries,of,this,map,are,present,keys,and,values,this,method,would,return,a,map,with,these,key,and,values,stripped,from,their,optional,wrappers,note,please,note,that,if,any,of,the,key,or,values,are,absent,this,method,would,throw,an,link,illegal,state,exception;public,linked,hash,map,k,v,unwrap,optionals,final,linked,hash,map,k,v,unwrapped,new,linked,hash,map,underlying,map,size,for,entry,string,key,value,k,v,entry,underlying,map,entry,set,string,named,key,entry,get,key,key,value,k,v,kv,entry,get,value,if,kv,key,null,throw,new,illegal,state,exception,missing,key,named,key,if,kv,value,null,throw,new,illegal,state,exception,missing,value,for,the,key,named,key,unwrapped,put,kv,key,kv,value,return,unwrapped
LinkedOptionalMap -> public LinkedHashMap<K, V> unwrapOptionals();1550821418;Assuming all the entries of this map are present (keys and values) this method would return_a map with these key and values, stripped from their Optional wrappers._NOTE: please note that if any of the key or values are absent this method would throw an {@link IllegalStateException}.;public LinkedHashMap<K, V> unwrapOptionals() {_		final LinkedHashMap<K, V> unwrapped = new LinkedHashMap<>(underlyingMap.size())___		for (Entry<String, KeyValue<K, V>> entry : underlyingMap.entrySet()) {_			String namedKey = entry.getKey()__			KeyValue<K, V> kv = entry.getValue()__			if (kv.key == null) {_				throw new IllegalStateException("Missing key '" + namedKey + "'")__			}_			if (kv.value == null) {_				throw new IllegalStateException("Missing value for the key '" + namedKey + "'")__			}_			unwrapped.put(kv.key, kv.value)__		}_		return unwrapped__	};assuming,all,the,entries,of,this,map,are,present,keys,and,values,this,method,would,return,a,map,with,these,key,and,values,stripped,from,their,optional,wrappers,note,please,note,that,if,any,of,the,key,or,values,are,absent,this,method,would,throw,an,link,illegal,state,exception;public,linked,hash,map,k,v,unwrap,optionals,final,linked,hash,map,k,v,unwrapped,new,linked,hash,map,underlying,map,size,for,entry,string,key,value,k,v,entry,underlying,map,entry,set,string,named,key,entry,get,key,key,value,k,v,kv,entry,get,value,if,kv,key,null,throw,new,illegal,state,exception,missing,key,named,key,if,kv,value,null,throw,new,illegal,state,exception,missing,value,for,the,key,named,key,unwrapped,put,kv,key,kv,value,return,unwrapped
LinkedOptionalMap -> public boolean hasAbsentKeysOrValues();1550821416;Checks whether there are entries with absent keys or values.;public boolean hasAbsentKeysOrValues() {_		for (Entry<String, KeyValue<K, V>> entry : underlyingMap.entrySet()) {_			if (keyOrValueIsAbsent(entry)) {_				return true__			}_		}_		return false__	};checks,whether,there,are,entries,with,absent,keys,or,values;public,boolean,has,absent,keys,or,values,for,entry,string,key,value,k,v,entry,underlying,map,entry,set,if,key,or,value,is,absent,entry,return,true,return,false
LinkedOptionalMap -> public boolean hasAbsentKeysOrValues();1550821417;Checks whether there are entries with absent keys or values.;public boolean hasAbsentKeysOrValues() {_		for (Entry<String, KeyValue<K, V>> entry : underlyingMap.entrySet()) {_			if (keyOrValueIsAbsent(entry)) {_				return true__			}_		}_		return false__	};checks,whether,there,are,entries,with,absent,keys,or,values;public,boolean,has,absent,keys,or,values,for,entry,string,key,value,k,v,entry,underlying,map,entry,set,if,key,or,value,is,absent,entry,return,true,return,false
LinkedOptionalMap -> public boolean hasAbsentKeysOrValues();1550821418;Checks whether there are entries with absent keys or values.;public boolean hasAbsentKeysOrValues() {_		for (Entry<String, KeyValue<K, V>> entry : underlyingMap.entrySet()) {_			if (keyOrValueIsAbsent(entry)) {_				return true__			}_		}_		return false__	};checks,whether,there,are,entries,with,absent,keys,or,values;public,boolean,has,absent,keys,or,values,for,entry,string,key,value,k,v,entry,underlying,map,entry,set,if,key,or,value,is,absent,entry,return,true,return,false
LinkedOptionalMap -> public static <K, V> LinkedOptionalMap<K, V> optionalMapOf(HashMap<K, V> sourceMap, Function<K, String> keyNameGetter);1550821416;Creates an {@code LinkedOptionalMap} from the provided map.__<p>This method is the equivalent of {@link Optional#of(Object)} but for maps. To support more than one {@code NULL}_key, an optional map requires a unique string name to be associated with each key (provided by keyNameGetter)__@param sourceMap     a source map to wrap as an optional map._@param keyNameGetter function that assigns a unique name to the keys of the source map._@param <K>           key type_@param <V>           value type_@return an {@code LinkedOptionalMap} with optional named keys, and optional values.;public static <K, V> LinkedOptionalMap<K, V> optionalMapOf(HashMap<K, V> sourceMap, Function<K, String> keyNameGetter) {__		LinkedHashMap<String, KeyValue<K, V>> underlyingMap = new LinkedHashMap<>(sourceMap.size())___		sourceMap.forEach((k, v) -> {_			String keyName = keyNameGetter.apply(k)__			underlyingMap.put(keyName, new KeyValue<>(k, v))__		})___		return new LinkedOptionalMap<>(underlyingMap)__	};creates,an,code,linked,optional,map,from,the,provided,map,p,this,method,is,the,equivalent,of,link,optional,of,object,but,for,maps,to,support,more,than,one,code,null,key,an,optional,map,requires,a,unique,string,name,to,be,associated,with,each,key,provided,by,key,name,getter,param,source,map,a,source,map,to,wrap,as,an,optional,map,param,key,name,getter,function,that,assigns,a,unique,name,to,the,keys,of,the,source,map,param,k,key,type,param,v,value,type,return,an,code,linked,optional,map,with,optional,named,keys,and,optional,values;public,static,k,v,linked,optional,map,k,v,optional,map,of,hash,map,k,v,source,map,function,k,string,key,name,getter,linked,hash,map,string,key,value,k,v,underlying,map,new,linked,hash,map,source,map,size,source,map,for,each,k,v,string,key,name,key,name,getter,apply,k,underlying,map,put,key,name,new,key,value,k,v,return,new,linked,optional,map,underlying,map
LinkedOptionalMap -> public static <K, V> LinkedOptionalMap<K, V> optionalMapOf(HashMap<K, V> sourceMap, Function<K, String> keyNameGetter);1550821417;Creates an {@code LinkedOptionalMap} from the provided map.__<p>This method is the equivalent of {@link Optional#of(Object)} but for maps. To support more than one {@code NULL}_key, an optional map requires a unique string name to be associated with each key (provided by keyNameGetter)__@param sourceMap     a source map to wrap as an optional map._@param keyNameGetter function that assigns a unique name to the keys of the source map._@param <K>           key type_@param <V>           value type_@return an {@code LinkedOptionalMap} with optional named keys, and optional values.;public static <K, V> LinkedOptionalMap<K, V> optionalMapOf(HashMap<K, V> sourceMap, Function<K, String> keyNameGetter) {__		LinkedHashMap<String, KeyValue<K, V>> underlyingMap = new LinkedHashMap<>(sourceMap.size())___		sourceMap.forEach((k, v) -> {_			String keyName = keyNameGetter.apply(k)__			underlyingMap.put(keyName, new KeyValue<>(k, v))__		})___		return new LinkedOptionalMap<>(underlyingMap)__	};creates,an,code,linked,optional,map,from,the,provided,map,p,this,method,is,the,equivalent,of,link,optional,of,object,but,for,maps,to,support,more,than,one,code,null,key,an,optional,map,requires,a,unique,string,name,to,be,associated,with,each,key,provided,by,key,name,getter,param,source,map,a,source,map,to,wrap,as,an,optional,map,param,key,name,getter,function,that,assigns,a,unique,name,to,the,keys,of,the,source,map,param,k,key,type,param,v,value,type,return,an,code,linked,optional,map,with,optional,named,keys,and,optional,values;public,static,k,v,linked,optional,map,k,v,optional,map,of,hash,map,k,v,source,map,function,k,string,key,name,getter,linked,hash,map,string,key,value,k,v,underlying,map,new,linked,hash,map,source,map,size,source,map,for,each,k,v,string,key,name,key,name,getter,apply,k,underlying,map,put,key,name,new,key,value,k,v,return,new,linked,optional,map,underlying,map
LinkedOptionalMap -> public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right);1550821416;Tries to merges the keys and the values of @right into @left.;public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right) {_		LinkedOptionalMap<K, V> merged = new LinkedOptionalMap<>(left)__		merged.putAll(right)___		return new MergeResult<>(merged, isLeftPrefixOfRight(left, right))__	};tries,to,merges,the,keys,and,the,values,of,right,into,left;public,static,k,v,merge,result,k,v,merge,right,into,left,linked,optional,map,k,v,left,linked,optional,map,k,v,right,linked,optional,map,k,v,merged,new,linked,optional,map,left,merged,put,all,right,return,new,merge,result,merged,is,left,prefix,of,right,left,right
LinkedOptionalMap -> public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right);1550821416;Tries to merges the keys and the values of @right into @left.;public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right) {_		LinkedOptionalMap<K, V> merged = new LinkedOptionalMap<>(left)__		merged.putAll(right)___		return new MergeResult<>(merged, isLeftPrefixOfRight(left, right))__	};tries,to,merges,the,keys,and,the,values,of,right,into,left;public,static,k,v,merge,result,k,v,merge,right,into,left,linked,optional,map,k,v,left,linked,optional,map,k,v,right,linked,optional,map,k,v,merged,new,linked,optional,map,left,merged,put,all,right,return,new,merge,result,merged,is,left,prefix,of,right,left,right
LinkedOptionalMap -> public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right);1550821417;Tries to merges the keys and the values of @right into @left.;public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right) {_		LinkedOptionalMap<K, V> merged = new LinkedOptionalMap<>(left)__		merged.putAll(right)___		return new MergeResult<>(merged, isLeftPrefixOfRight(left, right))__	};tries,to,merges,the,keys,and,the,values,of,right,into,left;public,static,k,v,merge,result,k,v,merge,right,into,left,linked,optional,map,k,v,left,linked,optional,map,k,v,right,linked,optional,map,k,v,merged,new,linked,optional,map,left,merged,put,all,right,return,new,merge,result,merged,is,left,prefix,of,right,left,right
LinkedOptionalMap -> public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right);1550821418;Tries to merges the keys and the values of @right into @left.;public static <K, V> MergeResult<K, V> mergeRightIntoLeft(LinkedOptionalMap<K, V> left, LinkedOptionalMap<K, V> right) {_		LinkedOptionalMap<K, V> merged = new LinkedOptionalMap<>(left)__		merged.putAll(right)___		return new MergeResult<>(merged, isLeftPrefixOfRight(left, right))__	};tries,to,merges,the,keys,and,the,values,of,right,into,left;public,static,k,v,merge,result,k,v,merge,right,into,left,linked,optional,map,k,v,left,linked,optional,map,k,v,right,linked,optional,map,k,v,merged,new,linked,optional,map,left,merged,put,all,right,return,new,merge,result,merged,is,left,prefix,of,right,left,right
LinkedOptionalMap -> public Set<String> absentKeysOrValues();1550821416;Returns the key names of any keys or values that are absent.;public Set<String> absentKeysOrValues() {_		return underlyingMap.entrySet()_			.stream()_			.filter(LinkedOptionalMap::keyOrValueIsAbsent)_			.map(Entry::getKey)_			.collect(Collectors.toSet())__	};returns,the,key,names,of,any,keys,or,values,that,are,absent;public,set,string,absent,keys,or,values,return,underlying,map,entry,set,stream,filter,linked,optional,map,key,or,value,is,absent,map,entry,get,key,collect,collectors,to,set
LinkedOptionalMap -> public Set<String> absentKeysOrValues();1550821416;Returns the key names of any keys or values that are absent.;public Set<String> absentKeysOrValues() {_		return underlyingMap.entrySet()_			.stream()_			.filter(LinkedOptionalMap::keyOrValueIsAbsent)_			.map(Entry::getKey)_			.collect(Collectors.toSet())__	};returns,the,key,names,of,any,keys,or,values,that,are,absent;public,set,string,absent,keys,or,values,return,underlying,map,entry,set,stream,filter,linked,optional,map,key,or,value,is,absent,map,entry,get,key,collect,collectors,to,set
LinkedOptionalMap -> public Set<String> absentKeysOrValues();1550821417;Returns the key names of any keys or values that are absent.;public Set<String> absentKeysOrValues() {_		return underlyingMap.entrySet()_			.stream()_			.filter(LinkedOptionalMap::keyOrValueIsAbsent)_			.map(Entry::getKey)_			.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,key,names,of,any,keys,or,values,that,are,absent;public,set,string,absent,keys,or,values,return,underlying,map,entry,set,stream,filter,linked,optional,map,key,or,value,is,absent,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
LinkedOptionalMap -> public Set<String> absentKeysOrValues();1550821418;Returns the key names of any keys or values that are absent.;public Set<String> absentKeysOrValues() {_		return underlyingMap.entrySet()_			.stream()_			.filter(LinkedOptionalMap::keyOrValueIsAbsent)_			.map(Entry::getKey)_			.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,key,names,of,any,keys,or,values,that,are,absent;public,set,string,absent,keys,or,values,return,underlying,map,entry,set,stream,filter,linked,optional,map,key,or,value,is,absent,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
