commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// ------------------------------------------------------------------------ @Override public int getCurrentVersion() {     return CURRENT_VERSION. }
false;public;1;6;;@Override public void writeSnapshot(DataOutputView out) throws IOException {     checkState(componentClass != null && nestedSnapshot != null).     out.writeUTF(componentClass.getName()).     nestedSnapshot.writeNestedSerializerSnapshots(out). }
false;public;3;13;;@Override public void readSnapshot(int readVersion, DataInputView in, ClassLoader classLoader) throws IOException {     switch(readVersion) {         case 1:             readV1(in, classLoader).             break.         case 2:             readV2(in, classLoader).             break.         default:             throw new IllegalArgumentException("Unrecognized version: " + readVersion).     } }
false;private;2;10;;private void readV1(DataInputView in, ClassLoader classLoader) throws IOException {     nestedSnapshot = NestedSerializersSnapshotDelegate.legacyReadNestedSerializerSnapshots(in, classLoader).     try (DataInputViewStream inViewWrapper = new DataInputViewStream(in)) {         componentClass = InstantiationUtil.deserializeObject(inViewWrapper, classLoader).     } catch (ClassNotFoundException e) {         throw new IOException("Could not find requested element class in classpath.", e).     } }
false;private;2;4;;private void readV2(DataInputView in, ClassLoader classLoader) throws IOException {     componentClass = InstantiationUtil.resolveClassByName(in, classLoader).     nestedSnapshot = NestedSerializersSnapshotDelegate.readNestedSerializerSnapshots(in, classLoader). }
false;public;0;5;;@Override public GenericArraySerializer<C> restoreSerializer() {     checkState(componentClass != null && nestedSnapshot != null).     return new GenericArraySerializer<>(componentClass, nestedSnapshot.getRestoredNestedSerializer(0)). }
false;public;1;14;;@Override public TypeSerializerSchemaCompatibility<C[]> resolveSchemaCompatibility(TypeSerializer<C[]> newSerializer) {     checkState(nestedSnapshot != null).     if (!(newSerializer instanceof GenericArraySerializer)) {         return TypeSerializerSchemaCompatibility.incompatible().     }     // delegate to the new snapshot class     return CompositeTypeSerializerUtil.delegateCompatibilityCheckToNewSnapshot(newSerializer, new GenericArraySerializerSnapshot<>(componentClass), nestedSnapshot.getNestedSerializerSnapshots()). }
