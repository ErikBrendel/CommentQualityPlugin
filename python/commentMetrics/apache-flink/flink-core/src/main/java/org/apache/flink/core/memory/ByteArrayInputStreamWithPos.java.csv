commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int read() {     return (position < count) ? 0xFF & (buffer[position++]) : -1. }
false;public;3;26;;@Override public int read(byte[] b, int off, int len) {     Preconditions.checkNotNull(b).     if (off < 0 || len < 0 || len > b.length - off) {         throw new IndexOutOfBoundsException().     }     if (position >= count) {         // signal EOF         return -1.     }     int available = count - position.     if (len > available) {         len = available.     }     if (len <= 0) {         return 0.     }     System.arraycopy(buffer, position, b, off, len).     position += len.     return len. }
false;public;1;11;;@Override public long skip(long toSkip) {     long remain = count - position.     if (toSkip < remain) {         remain = toSkip < 0 ? 0 : toSkip.     }     position += remain.     return remain. }
false;public;0;4;;@Override public boolean markSupported() {     return true. }
false;public;1;4;;@Override public void mark(int readAheadLimit) {     mark = position. }
false;public;0;4;;@Override public void reset() {     position = mark. }
false;public;0;4;;@Override public int available() {     return count - position. }
false;public;0;3;;@Override public void close() throws IOException { }
false;public;0;3;;public int getPosition() {     return position. }
false;public;1;4;;public void setPosition(int pos) {     Preconditions.checkArgument(pos >= 0 && pos <= count, "Position out of bounds.").     this.position = pos. }
false;public;3;6;;public void setBuffer(byte[] buffer, int offset, int length) {     this.count = Math.min(buffer.length, offset + length).     setPosition(offset).     this.buffer = buffer.     this.mark = offset. }
