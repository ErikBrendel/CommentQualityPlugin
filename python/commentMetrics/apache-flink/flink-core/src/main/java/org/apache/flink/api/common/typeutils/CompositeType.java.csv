commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Returns the type class of the composite type  *  * @return Type class of the composite type  */ ;/**  * Returns the type class of the composite type  *  * @return Type class of the composite type  */ @PublicEvolving public Class<T> getTypeClass() {     return typeClass. }
true;public;1;6;/**  * Returns the flat field descriptors for the given field expression.  *  * @param fieldExpression The field expression for which the flat field descriptors are computed.  * @return The list of descriptors for the flat fields which are specified by the field expression.  */ ;/**  * Returns the flat field descriptors for the given field expression.  *  * @param fieldExpression The field expression for which the flat field descriptors are computed.  * @return The list of descriptors for the flat fields which are specified by the field expression.  */ @PublicEvolving public List<FlatFieldDescriptor> getFlatFields(String fieldExpression) {     List<FlatFieldDescriptor> result = new ArrayList<FlatFieldDescriptor>().     this.getFlatFields(fieldExpression, 0, result).     return result. }
true;public,abstract;3;2;/**  * Computes the flat field descriptors for the given field expression with the given offset.  *  * @param fieldExpression The field expression for which the FlatFieldDescriptors are computed.  * @param offset The offset to use when computing the positions of the flat fields.  * @param result The list into which all flat field descriptors are inserted.  */ ;/**  * Computes the flat field descriptors for the given field expression with the given offset.  *  * @param fieldExpression The field expression for which the FlatFieldDescriptors are computed.  * @param offset The offset to use when computing the positions of the flat fields.  * @param result The list into which all flat field descriptors are inserted.  */ @PublicEvolving public abstract void getFlatFields(String fieldExpression, int offset, List<FlatFieldDescriptor> result).
true;public,abstract;1;2;/**  * Returns the type of the (nested) field at the given field expression position.  * Wildcards are not allowed.  *  * @param fieldExpression The field expression for which the field of which the type is returned.  * @return The type of the field at the given field expression.  */ ;/**  * Returns the type of the (nested) field at the given field expression position.  * Wildcards are not allowed.  *  * @param fieldExpression The field expression for which the field of which the type is returned.  * @return The type of the field at the given field expression.  */ @PublicEvolving public abstract <X> TypeInformation<X> getTypeAt(String fieldExpression).
true;public,abstract;1;2;/**  * Returns the type of the (unnested) field at the given field position.  *  * @param pos The position of the (unnested) field in this composite type.  * @return The type of the field at the given position.  */ ;/**  * Returns the type of the (unnested) field at the given field position.  *  * @param pos The position of the (unnested) field in this composite type.  * @return The type of the field at the given position.  */ @PublicEvolving public abstract <X> TypeInformation<X> getTypeAt(int pos).
false;protected,abstract;0;2;;@PublicEvolving protected abstract TypeComparatorBuilder<T> createTypeComparatorBuilder().
true;public;4;59;/**  * Generic implementation of the comparator creation. Composite types are supplying the infrastructure  * to create the actual comparators  * @return The comparator  */ ;/**  * Generic implementation of the comparator creation. Composite types are supplying the infrastructure  * to create the actual comparators  * @return The comparator  */ @PublicEvolving public TypeComparator<T> createComparator(int[] logicalKeyFields, boolean[] orders, int logicalFieldOffset, ExecutionConfig config) {     TypeComparatorBuilder<T> builder = createTypeComparatorBuilder().     builder.initializeTypeComparatorBuilder(logicalKeyFields.length).     for (int logicalKeyFieldIndex = 0. logicalKeyFieldIndex < logicalKeyFields.length. logicalKeyFieldIndex++) {         int logicalKeyField = logicalKeyFields[logicalKeyFieldIndex].         // this is the global/logical field number         int logicalField = logicalFieldOffset.         boolean comparatorAdded = false.         for (int localFieldId = 0. localFieldId < this.getArity() && logicalField <= logicalKeyField && !comparatorAdded. localFieldId++) {             TypeInformation<?> localFieldType = this.getTypeAt(localFieldId).             if (localFieldType instanceof AtomicType && logicalField == logicalKeyField) {                 // we found an atomic key --> create comparator                 builder.addComparatorField(localFieldId, ((AtomicType<?>) localFieldType).createComparator(orders[logicalKeyFieldIndex], config)).                 comparatorAdded = true.             } else // of the composite type's logical fields             if (localFieldType instanceof CompositeType && logicalField <= logicalKeyField && logicalKeyField <= logicalField + (localFieldType.getTotalFields() - 1)) {                 // we found a compositeType that is containing the logicalKeyField we are looking for --> create comparator                 builder.addComparatorField(localFieldId, ((CompositeType<?>) localFieldType).createComparator(new int[] { logicalKeyField }, new boolean[] { orders[logicalKeyFieldIndex] }, logicalField, config)).                 comparatorAdded = true.             }             if (localFieldType instanceof CompositeType) {                 // we need to subtract 1 because we are not accounting for the local field (not accessible for the user)                 logicalField += localFieldType.getTotalFields() - 1.             }             logicalField++.         }         if (!comparatorAdded) {             throw new IllegalArgumentException("Could not add a comparator for the logical" + "key field index " + logicalKeyFieldIndex + ".").         }     }     return builder.createTypeComparator(config). }
false;;1;1;;void initializeTypeComparatorBuilder(int size).
false;;2;1;;void addComparatorField(int fieldId, TypeComparator<?> comparator).
false;;1;1;;TypeComparator<T> createTypeComparator(ExecutionConfig config).
false;public;0;3;;public int getPosition() {     return keyPosition. }
false;public;0;3;;public TypeInformation<?> getType() {     return type. }
false;public;0;4;;@Override public String toString() {     return "FlatFieldDescriptor [position=" + keyPosition + " typeInfo=" + type + "]". }
true;public;1;4;/**  * Returns true when this type has a composite field with the given name.  */ ;/**  * Returns true when this type has a composite field with the given name.  */ @PublicEvolving public boolean hasField(String fieldName) {     return getFieldIndex(fieldName) >= 0. }
false;public;0;10;;@Override @PublicEvolving public boolean isKeyType() {     for (int i = 0. i < this.getArity(). i++) {         if (!this.getTypeAt(i).isKeyType()) {             return false.         }     }     return true. }
false;public;0;10;;@Override @PublicEvolving public boolean isSortKeyType() {     for (int i = 0. i < this.getArity(). i++) {         if (!this.getTypeAt(i).isSortKeyType()) {             return false.         }     }     return true. }
true;public,abstract;0;2;/**  * Returns the names of the composite fields of this type. The order of the returned array must  * be consistent with the internal field index ordering.  */ ;/**  * Returns the names of the composite fields of this type. The order of the returned array must  * be consistent with the internal field index ordering.  */ @PublicEvolving public abstract String[] getFieldNames().
true;public;0;4;/**  * True if this type has an inherent ordering of the fields, such that a user can  * always be sure in which order the fields will be in. This is true for Tuples and  * Case Classes. It is not true for Regular Java Objects, since there, the ordering of  * the fields can be arbitrary.  *  * This is used when translating a DataSet or DataStream to an Expression Table, when  * initially renaming the fields of the underlying type.  */ ;/**  * True if this type has an inherent ordering of the fields, such that a user can  * always be sure in which order the fields will be in. This is true for Tuples and  * Case Classes. It is not true for Regular Java Objects, since there, the ordering of  * the fields can be arbitrary.  *  * This is used when translating a DataSet or DataStream to an Expression Table, when  * initially renaming the fields of the underlying type.  */ @PublicEvolving public boolean hasDeterministicFieldOrder() {     return false. }
true;public,abstract;1;2;/**  * Returns the field index of the composite field of the given name.  *  * @return The field index or -1 if this type does not have a field of the given name.  */ ;/**  * Returns the field index of the composite field of the given name.  *  * @return The field index or -1 if this type does not have a field of the given name.  */ @PublicEvolving public abstract int getFieldIndex(String fieldName).
false;public;1;11;;@Override public boolean equals(Object obj) {     if (obj instanceof CompositeType) {         @SuppressWarnings("unchecked")         CompositeType<T> compositeType = (CompositeType<T>) obj.         return compositeType.canEqual(this) && typeClass == compositeType.typeClass.     } else {         return false.     } }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(typeClass). }
false;public;1;4;;@Override public boolean canEqual(Object obj) {     return obj instanceof CompositeType. }
false;public;0;4;;@Override public String toString() {     return getClass().getSimpleName() + "<" + typeClass.getSimpleName() + ">". }
