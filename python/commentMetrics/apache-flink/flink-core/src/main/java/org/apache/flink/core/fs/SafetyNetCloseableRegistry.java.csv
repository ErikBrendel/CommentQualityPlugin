commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;20;;@Override protected void doRegister(@Nonnull WrappingProxyCloseable<? extends Closeable> wrappingProxyCloseable, @Nonnull Map<Closeable, PhantomDelegatingCloseableRef> closeableMap) {     assert Thread.holdsLock(getSynchronizationLock()).     Closeable innerCloseable = WrappingProxyUtil.stripProxy(wrappingProxyCloseable).     if (null == innerCloseable) {         return.     }     PhantomDelegatingCloseableRef phantomRef = new PhantomDelegatingCloseableRef(wrappingProxyCloseable, this, REAPER_THREAD.referenceQueue).     closeableMap.put(innerCloseable, phantomRef). }
false;protected;2;11;;@Override protected boolean doUnRegister(@Nonnull WrappingProxyCloseable<? extends Closeable> closeable, @Nonnull Map<Closeable, PhantomDelegatingCloseableRef> closeableMap) {     assert Thread.holdsLock(getSynchronizationLock()).     Closeable innerCloseable = WrappingProxyUtil.stripProxy(closeable).     return null != innerCloseable && closeableMap.remove(innerCloseable) != null. }
false;public;0;15;;@Override public void close() throws IOException {     try {         super.close().     } finally {         synchronized (REAPER_THREAD_LOCK) {             --GLOBAL_SAFETY_NET_REGISTRY_COUNT.             if (0 == GLOBAL_SAFETY_NET_REGISTRY_COUNT) {                 REAPER_THREAD.interrupt().                 REAPER_THREAD = null.             }         }     } }
false;static;0;6;;@VisibleForTesting static boolean isReaperThreadRunning() {     synchronized (REAPER_THREAD_LOCK) {         return null != REAPER_THREAD && REAPER_THREAD.isAlive().     } }
false;;0;3;;String getDebugString() {     return debugString. }
false;public;0;5;;@Override public void close() throws IOException {     closeableRegistry.removeCloseableInternal(innerCloseable).     innerCloseable.close(). }
false;public;0;20;;@Override public void run() {     try {         while (running) {             final PhantomDelegatingCloseableRef toClose = (PhantomDelegatingCloseableRef) referenceQueue.remove().             if (toClose != null) {                 try {                     LOG.warn("Closing unclosed resource via safety-net: {}", toClose.getDebugString()).                     toClose.close().                 } catch (Throwable t) {                     LOG.debug("Error while closing resource via safety-net", t).                 }             }         }     } catch (InterruptedException e) {     // done     } }
false;public;0;5;;@Override public void interrupt() {     this.running = false.     super.interrupt(). }
