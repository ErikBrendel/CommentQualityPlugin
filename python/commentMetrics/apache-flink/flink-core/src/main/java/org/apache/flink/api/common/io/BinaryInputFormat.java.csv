commented;modifiers;parameterAmount;loc;comment;code
false;public;1;12;;@Override public void configure(Configuration parameters) {     super.configure(parameters).     if (this.blockSize == NATIVE_BLOCK_SIZE) {         long blockSize = parameters.getLong(BLOCK_SIZE_PARAMETER_KEY, NATIVE_BLOCK_SIZE).         setBlockSize(blockSize).     } }
false;public;1;9;;public void setBlockSize(long blockSize) {     if (blockSize < 1 && blockSize != NATIVE_BLOCK_SIZE) {         throw new IllegalArgumentException("The block size parameter must be set and larger than 0.").     }     if (blockSize > Integer.MAX_VALUE) {         throw new UnsupportedOperationException("Currently only block sizes up to Integer.MAX_VALUE are supported").     }     this.blockSize = blockSize. }
false;public;0;3;;public long getBlockSize() {     return this.blockSize. }
false;public;1;34;;@Override public FileInputSplit[] createInputSplits(int minNumSplits) throws IOException {     final List<FileStatus> files = this.getFiles().     final List<FileInputSplit> inputSplits = new ArrayList<FileInputSplit>(minNumSplits).     for (FileStatus file : files) {         final FileSystem fs = file.getPath().getFileSystem().         final long blockSize = this.blockSize == NATIVE_BLOCK_SIZE ? fs.getDefaultBlockSize() : this.blockSize.         for (long pos = 0, length = file.getLen(). pos < length. pos += blockSize) {             long remainingLength = Math.min(pos + blockSize, length) - pos.             // get the block locations and make sure they are in order with respect to their offset             final BlockLocation[] blocks = fs.getFileBlockLocations(file, pos, remainingLength).             Arrays.sort(blocks).             inputSplits.add(new FileInputSplit(inputSplits.size(), file.getPath(), pos, remainingLength, blocks[0].getHosts())).         }     }     if (inputSplits.size() < minNumSplits) {         LOG.warn(String.format("With the given block size %d, the files %s cannot be split into %d blocks. Filling up with empty splits...", blockSize, Arrays.toString(getFilePaths()), minNumSplits)).         FileStatus last = files.get(files.size() - 1).         final BlockLocation[] blocks = last.getPath().getFileSystem().getFileBlockLocations(last, 0, last.getLen()).         for (int index = files.size(). index < minNumSplits. index++) {             inputSplits.add(new FileInputSplit(index, last.getPath(), last.getLen(), 0, blocks[0].getHosts())).         }     }     return inputSplits.toArray(new FileInputSplit[inputSplits.size()]). }
false;protected;0;22;;protected List<FileStatus> getFiles() throws IOException {     // get all the files that are involved in the splits     List<FileStatus> files = new ArrayList<>().     for (Path filePath : getFilePaths()) {         final FileSystem fs = filePath.getFileSystem().         final FileStatus pathFile = fs.getFileStatus(filePath).         if (pathFile.isDir()) {             // input is directory. list all contained files             final FileStatus[] partials = fs.listStatus(filePath).             for (FileStatus partial : partials) {                 if (!partial.isDir()) {                     files.add(partial).                 }             }         } else {             files.add(pathFile).         }     }     return files. }
false;public;1;35;;@Override public SequentialStatistics getStatistics(BaseStatistics cachedStats) {     final FileBaseStatistics cachedFileStats = cachedStats instanceof FileBaseStatistics ? (FileBaseStatistics) cachedStats : null.     try {         final ArrayList<FileStatus> allFiles = new ArrayList<FileStatus>(1).         final FileBaseStatistics stats = getFileStats(cachedFileStats, getFilePaths(), allFiles).         if (stats == null) {             return null.         }         // check whether the file stats are still sequential stats (in that case they are still valid)         if (stats instanceof SequentialStatistics) {             return (SequentialStatistics) stats.         }         return createStatistics(allFiles, stats).     } catch (IOException ioex) {         if (LOG.isWarnEnabled()) {             LOG.warn(String.format("Could not determine complete statistics for files '%s' due to an I/O error", Arrays.toString(getFilePaths())), ioex).         }     } catch (Throwable t) {         if (LOG.isErrorEnabled()) {             LOG.error(String.format("Unexpected problem while getting the file statistics for files '%s'", Arrays.toString(getFilePaths())), t).         }     }     // no stats available     return null. }
false;protected;0;3;;protected FileInputSplit[] getInputSplits() throws IOException {     return this.createInputSplits(0). }
false;public;0;3;;public BlockInfo createBlockInfo() {     return new BlockInfo(). }
false;private;0;13;;private BlockInfo createAndReadBlockInfo() throws IOException {     BlockInfo blockInfo = new BlockInfo().     if (this.splitLength > blockInfo.getInfoSize()) {         // At first we go and read  the block info containing the recordCount, the accumulatedRecordCount         // and the firstRecordStart offset in the current block. This is written at the end of the block and         // is of fixed size, currently 3 * Long.SIZE.         // TODO: seek not supported by compressed streams. Will throw exception         this.stream.seek(this.splitStart + this.splitLength - blockInfo.getInfoSize()).         blockInfo.read(new DataInputViewStreamWrapper(this.stream)).     }     return blockInfo. }
true;protected;2;27;/**  * Fill in the statistics. The last modification time and the total input size are prefilled.  *  * @param files  *        The files that are associated with this block input format.  * @param stats  *        The pre-filled statistics.  */ ;/**  * Fill in the statistics. The last modification time and the total input size are prefilled.  *  * @param files  *        The files that are associated with this block input format.  * @param stats  *        The pre-filled statistics.  */ protected SequentialStatistics createStatistics(List<FileStatus> files, FileBaseStatistics stats) throws IOException {     if (files.isEmpty()) {         return null.     }     BlockInfo blockInfo = new BlockInfo().     long totalCount = 0.     for (FileStatus file : files) {         // invalid file         if (file.getLen() < blockInfo.getInfoSize()) {             continue.         }         FileSystem fs = file.getPath().getFileSystem().         try (FSDataInputStream fdis = fs.open(file.getPath(), blockInfo.getInfoSize())) {             fdis.seek(file.getLen() - blockInfo.getInfoSize()).             blockInfo.read(new DataInputViewStreamWrapper(fdis)).             totalCount += blockInfo.getAccumulatedRecordCount().         }     }     final float avgWidth = totalCount == 0 ? 0 : ((float) stats.getTotalInputSize() / totalCount).     return new SequentialStatistics(stats.getLastModificationTime(), stats.getTotalInputSize(), avgWidth, totalCount). }
false;public;0;4;;@Override public long getNumberOfRecords() {     return this.numberOfRecords. }
false;public;1;15;;@Override public void open(FileInputSplit split) throws IOException {     super.open(split).     this.blockInfo = this.createAndReadBlockInfo().     // We set the size of the BlockBasedInput to splitLength as each split contains one block.     // After reading the block info, we seek in the file to the correct position.     this.readRecords = 0.     this.stream.seek(this.splitStart + this.blockInfo.getFirstRecordStart()).     this.blockBasedInput = new BlockBasedInput(this.stream, (int) blockInfo.getFirstRecordStart(), this.splitLength).     this.dataInputStream = new DataInputViewStreamWrapper(blockBasedInput). }
false;public;0;4;;@Override public boolean reachedEnd() throws IOException {     return this.readRecords >= this.blockInfo.getRecordCount(). }
false;public;1;9;;@Override public T nextRecord(T record) throws IOException {     if (this.reachedEnd()) {         return null.     }     record = this.deserialize(record, this.dataInputStream).     this.readRecords++.     return record. }
false;protected,abstract;2;1;;protected abstract T deserialize(T reuse, DataInputView dataInput) throws IOException.
false;public;0;7;;@Override public int read() throws IOException {     if (this.blockPos++ >= this.maxPayloadSize) {         this.skipHeader().     }     return this.in.read(). }
false;private;0;3;;private long getCurrBlockPos() {     return this.blockPos. }
false;private;0;8;;private void skipHeader() throws IOException {     byte[] dummy = new byte[BinaryInputFormat.this.blockInfo.getInfoSize()].     this.in.read(dummy, 0, dummy.length).     // the blockPos is set to 0 for the case of remote reads,     // these are the cases where the last record of a block spills on the next block     this.blockPos = 0. }
false;public;1;4;;@Override public int read(byte[] b) throws IOException {     return this.read(b, 0, b.length). }
false;public;3;19;;@Override public int read(byte[] b, int off, int len) throws IOException {     int totalRead = 0.     for (int remainingLength = len, offset = off. remainingLength > 0. ) {         int blockLen = Math.min(remainingLength, this.maxPayloadSize - this.blockPos).         int read = this.in.read(b, offset, blockLen).         if (read < 0) {             return read.         }         totalRead += read.         this.blockPos += read.         offset += read.         if (this.blockPos >= this.maxPayloadSize) {             this.skipHeader().         }         remainingLength -= read.     }     return totalRead. }
false;public;0;12;;// -------------------------------------------------------------------------------------------- // Checkpointing // -------------------------------------------------------------------------------------------- @PublicEvolving @Override public Tuple2<Long, Long> getCurrentState() throws IOException {     if (this.blockBasedInput == null) {         throw new RuntimeException("You must have forgotten to call open() on your input format.").     }     return new Tuple2<>(// the last read index in the block     this.blockBasedInput.getCurrBlockPos(), // the number of records read     this.readRecords). }
false;public;2;19;;@PublicEvolving @Override public void reopen(FileInputSplit split, Tuple2<Long, Long> state) throws IOException {     Preconditions.checkNotNull(split, "reopen() cannot be called on a null split.").     Preconditions.checkNotNull(state, "reopen() cannot be called with a null initial state.").     try {         this.open(split).     } finally {         this.blockInfo = this.createAndReadBlockInfo().         long blockPos = state.f0.         this.readRecords = state.f1.         this.stream.seek(this.splitStart + blockPos).         this.blockBasedInput = new BlockBasedInput(this.stream, (int) blockPos, this.splitLength).         this.dataInputStream = new DataInputViewStreamWrapper(blockBasedInput).     } }
