commented;modifiers;parameterAmount;loc;comment;code
true;public;5;4;/**  * Parses the value of a field from the byte array, taking care of properly reset  * the state of this parser.  * The start position within the byte array and the array's valid length is given.  * The content of the value is delimited by a field delimiter.  *  * @param bytes The byte array that holds the value.  * @param startPos The index where the field starts  * @param limit The limit unto which the byte contents is valid for the parser. The limit is the  *              position one after the last valid byte.  * @param delim The field delimiter character  * @param reuse An optional reusable field to hold the value  *  * @return The index of the next delimiter, if the field was parsed correctly. A value less than 0 otherwise.  */ ;/**  * Parses the value of a field from the byte array, taking care of properly reset  * the state of this parser.  * The start position within the byte array and the array's valid length is given.  * The content of the value is delimited by a field delimiter.  *  * @param bytes The byte array that holds the value.  * @param startPos The index where the field starts  * @param limit The limit unto which the byte contents is valid for the parser. The limit is the  *              position one after the last valid byte.  * @param delim The field delimiter character  * @param reuse An optional reusable field to hold the value  *  * @return The index of the next delimiter, if the field was parsed correctly. A value less than 0 otherwise.  */ public int resetErrorStateAndParse(byte[] bytes, int startPos, int limit, byte[] delim, T reuse) {     resetParserState().     return parseField(bytes, startPos, limit, delim, reuse). }
true;protected,abstract;5;1;/**  * Each parser's logic should be implemented inside this method  */ ;/**  * Each parser's logic should be implemented inside this method  */ protected abstract int parseField(byte[] bytes, int startPos, int limit, byte[] delim, T reuse).
true;protected;0;3;/**  * Reset the state of the parser. Called as the very first method inside  * {@link FieldParser#resetErrorStateAndParse(byte[], int, int, byte[], Object)}, by default it just reset  * its error state.  */ ;/**  * Reset the state of the parser. Called as the very first method inside  * {@link FieldParser#resetErrorStateAndParse(byte[], int, int, byte[], Object)}, by default it just reset  * its error state.  */ protected void resetParserState() {     this.errorState = ParseErrorState.NONE. }
true;public,abstract;0;1;/**  * Gets the parsed field. This method returns the value parsed by the last successful invocation of  * {@link #parseField(byte[], int, int, byte[], Object)}. It objects are mutable and reused, it will return  * the object instance that was passed the parse function.  *  * @return The latest parsed field.  */ ;/**  * Gets the parsed field. This method returns the value parsed by the last successful invocation of  * {@link #parseField(byte[], int, int, byte[], Object)}. It objects are mutable and reused, it will return  * the object instance that was passed the parse function.  *  * @return The latest parsed field.  */ public abstract T getLastResult().
true;public,abstract;0;1;/**  * Returns an instance of the parsed value type.  *  * @return An instance of the parsed value type.  */ ;/**  * Returns an instance of the parsed value type.  *  * @return An instance of the parsed value type.  */ public abstract T createValue().
true;public,static,final;3;11;/**  * Checks if the delimiter starts at the given start position of the byte array.  *  * Attention: This method assumes that enough characters follow the start position for the delimiter check!  *  * @param bytes The byte array that holds the value.  * @param startPos The index of the byte array where the check for the delimiter starts.  * @param delim The delimiter to check for.  *  * @return true if a delimiter starts at the given start position, false otherwise.  */ ;/**  * Checks if the delimiter starts at the given start position of the byte array.  *  * Attention: This method assumes that enough characters follow the start position for the delimiter check!  *  * @param bytes The byte array that holds the value.  * @param startPos The index of the byte array where the check for the delimiter starts.  * @param delim The delimiter to check for.  *  * @return true if a delimiter starts at the given start position, false otherwise.  */ public static final boolean delimiterNext(byte[] bytes, int startPos, byte[] delim) {     for (int pos = 0. pos < delim.length. pos++) {         // check each position         if (delim[pos] != bytes[startPos + pos]) {             return false.         }     }     return true. }
true;public,static,final;3;11;/**  * Checks if the given bytes ends with the delimiter at the given end position.  *  * @param bytes  The byte array that holds the value.  * @param endPos The index of the byte array where the check for the delimiter ends.  * @param delim  The delimiter to check for.  *  * @return true if a delimiter ends at the given end position, false otherwise.  */ ;/**  * Checks if the given bytes ends with the delimiter at the given end position.  *  * @param bytes  The byte array that holds the value.  * @param endPos The index of the byte array where the check for the delimiter ends.  * @param delim  The delimiter to check for.  *  * @return true if a delimiter ends at the given end position, false otherwise.  */ public static final boolean endsWithDelimiter(byte[] bytes, int endPos, byte[] delim) {     if (endPos < delim.length - 1) {         return false.     }     for (int pos = 0. pos < delim.length. ++pos) {         if (delim[pos] != bytes[endPos - delim.length + 1 + pos]) {             return false.         }     }     return true. }
true;protected;1;3;/**  * Sets the error state of the parser. Called by subclasses of the parser to set the type of error  * when failing a parse.  *  * @param error The error state to set.  */ ;/**  * Sets the error state of the parser. Called by subclasses of the parser to set the type of error  * when failing a parse.  *  * @param error The error state to set.  */ protected void setErrorState(ParseErrorState error) {     this.errorState = error. }
true;public;0;3;/**  * Gets the error state of the parser, as a value of the enumeration {@link ParseErrorState}.  * If no error occurred, the error state will be {@link ParseErrorState#NONE}.  *  * @return The current error state of the parser.  */ ;/**  * Gets the error state of the parser, as a value of the enumeration {@link ParseErrorState}.  * If no error occurred, the error state will be {@link ParseErrorState#NONE}.  *  * @return The current error state of the parser.  */ public ParseErrorState getErrorState() {     return this.errorState. }
true;protected,final;4;18;/**  * Returns the end position of a string. Sets the error state if the column is empty.  *  * @return the end position of the string or -1 if an error occurred  */ ;/**  * Returns the end position of a string. Sets the error state if the column is empty.  *  * @return the end position of the string or -1 if an error occurred  */ protected final int nextStringEndPos(byte[] bytes, int startPos, int limit, byte[] delimiter) {     int endPos = startPos.     final int delimLimit = limit - delimiter.length + 1.     while (endPos < limit) {         if (endPos < delimLimit && delimiterNext(bytes, endPos, delimiter)) {             break.         }         endPos++.     }     if (endPos == startPos) {         setErrorState(ParseErrorState.EMPTY_COLUMN).         return -1.     }     return endPos. }
true;protected,static,final;4;13;/**  * Returns the length of a string. Throws an exception if the column is empty.  *  * @return the length of the string  */ ;/**  * Returns the length of a string. Throws an exception if the column is empty.  *  * @return the length of the string  */ protected static final int nextStringLength(byte[] bytes, int startPos, int length, char delimiter) {     if (length <= 0) {         throw new IllegalArgumentException("Invalid input: Empty string").     }     int limitedLength = 0.     final byte delByte = (byte) delimiter.     while (limitedLength < length && bytes[startPos + limitedLength] != delByte) {         limitedLength++.     }     return limitedLength. }
true;public;0;3;/**  * Gets the character set used for this parser.  *  * @return the charset used for this parser.  */ ;/**  * Gets the character set used for this parser.  *  * @return the charset used for this parser.  */ public Charset getCharset() {     return this.charset. }
true;public;1;3;/**  * Sets the character set used for this parser.  *  * @param charset charset used for this parser.  */ ;/**  * Sets the character set used for this parser.  *  * @param charset charset used for this parser.  */ public void setCharset(Charset charset) {     this.charset = charset. }
true;public,static;1;10;/**  * Gets the parser for the type specified by the given class. Returns null, if no parser for that class  * is known.  *  * @param type The class of the type to get the parser for.  * @return The parser for the given type, or null, if no such parser exists.  */ ;// -------------------------------------------------------------------------------------------- // Mapping from types to parsers // -------------------------------------------------------------------------------------------- /**  * Gets the parser for the type specified by the given class. Returns null, if no parser for that class  * is known.  *  * @param type The class of the type to get the parser for.  * @return The parser for the given type, or null, if no such parser exists.  */ public static <T> Class<FieldParser<T>> getParserForType(Class<T> type) {     Class<? extends FieldParser<?>> parser = PARSERS.get(type).     if (parser == null) {         return null.     } else {         @SuppressWarnings("unchecked")         Class<FieldParser<T>> typedParser = (Class<FieldParser<T>>) parser.         return typedParser.     } }
