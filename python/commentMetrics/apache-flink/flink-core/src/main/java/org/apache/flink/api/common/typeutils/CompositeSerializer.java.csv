commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;1;1;/**  * Create new instance from its fields.  */ ;/**  * Create new instance from its fields.  */ public abstract T createInstance(@Nonnull Object... values).
true;protected,abstract;3;1;/**  * Modify field of existing instance. Supported only by mutable types.  */ ;/**  * Modify field of existing instance. Supported only by mutable types.  */ protected abstract void setField(@Nonnull T value, int index, Object fieldValue).
true;protected,abstract;2;1;/**  * Get field of existing instance.  */ ;/**  * Get field of existing instance.  */ protected abstract Object getField(@Nonnull T value, int index).
true;protected,abstract;2;3;/**  * Factory for concrete serializer.  */ ;/**  * Factory for concrete serializer.  */ protected abstract CompositeSerializer<T> createSerializerInstance(PrecomputedParameters precomputed, TypeSerializer<?>... originalSerializers).
false;public;0;5;;@Override public CompositeSerializer<T> duplicate() {     return precomputed.stateful ? createSerializerInstance(precomputed, duplicateFieldSerializers(fieldSerializers)) : this. }
false;private,static;1;8;;private static TypeSerializer[] duplicateFieldSerializers(TypeSerializer<Object>[] fieldSerializers) {     TypeSerializer[] duplicatedSerializers = new TypeSerializer[fieldSerializers.length].     for (int index = 0. index < fieldSerializers.length. index++) {         duplicatedSerializers[index] = fieldSerializers[index].duplicate().         assert duplicatedSerializers[index] != null.     }     return duplicatedSerializers. }
false;public;0;4;;@Override public boolean isImmutableType() {     return precomputed.immutable. }
false;public;0;8;;@Override public T createInstance() {     Object[] fields = new Object[fieldSerializers.length].     for (int index = 0. index < fieldSerializers.length. index++) {         fields[index] = fieldSerializers[index].createInstance().     }     return createInstance(fields). }
false;public;1;12;;@Override public T copy(T from) {     Preconditions.checkNotNull(from).     if (isImmutableType()) {         return from.     }     Object[] fields = new Object[fieldSerializers.length].     for (int index = 0. index < fieldSerializers.length. index++) {         fields[index] = fieldSerializers[index].copy(getField(from, index)).     }     return createInstance(fields). }
false;public;2;13;;@Override public T copy(T from, T reuse) {     Preconditions.checkNotNull(from).     Preconditions.checkNotNull(reuse).     if (isImmutableType()) {         return from.     }     Object[] fields = new Object[fieldSerializers.length].     for (int index = 0. index < fieldSerializers.length. index++) {         fields[index] = fieldSerializers[index].copy(getField(from, index), getField(reuse, index)).     }     return createInstanceWithReuse(fields, reuse). }
false;public;0;4;;@Override public int getLength() {     return precomputed.length. }
false;public;2;8;;@Override public void serialize(T record, DataOutputView target) throws IOException {     Preconditions.checkNotNull(record).     Preconditions.checkNotNull(target).     for (int index = 0. index < fieldSerializers.length. index++) {         fieldSerializers[index].serialize(getField(record, index), target).     } }
false;public;1;9;;@Override public T deserialize(DataInputView source) throws IOException {     Preconditions.checkNotNull(source).     Object[] fields = new Object[fieldSerializers.length].     for (int i = 0. i < fieldSerializers.length. i++) {         fields[i] = fieldSerializers[i].deserialize(source).     }     return createInstance(fields). }
false;public;2;10;;@Override public T deserialize(T reuse, DataInputView source) throws IOException {     Preconditions.checkNotNull(reuse).     Preconditions.checkNotNull(source).     Object[] fields = new Object[fieldSerializers.length].     for (int index = 0. index < fieldSerializers.length. index++) {         fields[index] = fieldSerializers[index].deserialize(getField(reuse, index), source).     }     return precomputed.immutable ? createInstance(fields) : createInstanceWithReuse(fields, reuse). }
false;private;2;6;;private T createInstanceWithReuse(Object[] fields, T reuse) {     for (int index = 0. index < fields.length. index++) {         setField(reuse, index, fields[index]).     }     return reuse. }
false;public;2;8;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     Preconditions.checkNotNull(source).     Preconditions.checkNotNull(target).     for (TypeSerializer typeSerializer : fieldSerializers) {         typeSerializer.copy(source, target).     } }
false;public;0;4;;@Override public int hashCode() {     return 31 * Boolean.hashCode(precomputed.immutableTargetType) + Arrays.hashCode(fieldSerializers). }
false;public;1;7;;@SuppressWarnings("EqualsWhichDoesntCheckParameterClass") @Override public boolean equals(Object obj) {     CompositeSerializer<?> other = (CompositeSerializer<?>) obj.     return precomputed.immutable == other.precomputed.immutable && Arrays.equals(fieldSerializers, other.fieldSerializers). }
false;static;2;22;;static PrecomputedParameters precompute(boolean immutableTargetType, TypeSerializer<Object>[] fieldSerializers) {     Preconditions.checkNotNull(fieldSerializers).     int totalLength = 0.     boolean fieldsImmutable = true.     boolean stateful = false.     for (TypeSerializer<Object> fieldSerializer : fieldSerializers) {         Preconditions.checkNotNull(fieldSerializer).         if (fieldSerializer != fieldSerializer.duplicate()) {             stateful = true.         }         if (!fieldSerializer.isImmutableType()) {             fieldsImmutable = false.         }         if (fieldSerializer.getLength() < 0) {             totalLength = -1.         }         totalLength = totalLength >= 0 ? totalLength + fieldSerializer.getLength() : totalLength.     }     return new PrecomputedParameters(immutableTargetType, fieldsImmutable, totalLength, stateful). }
false;public;0;4;;@Override public int getVersion() {     return VERSION. }
