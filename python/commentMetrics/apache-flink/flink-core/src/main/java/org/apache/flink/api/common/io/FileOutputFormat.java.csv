commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;9;/**  * Initialize defaults for output format. Needs to be a static method because it is configured for local  * cluster execution.  * @param configuration The configuration to load defaults from  */ ;/**  * Initialize defaults for output format. Needs to be a static method because it is configured for local  * cluster execution.  * @param configuration The configuration to load defaults from  */ public static void initDefaultsFromConfiguration(Configuration configuration) {     final boolean overwrite = configuration.getBoolean(CoreOptions.FILESYTEM_DEFAULT_OVERRIDE).     DEFAULT_WRITE_MODE = overwrite ? WriteMode.OVERWRITE : WriteMode.NO_OVERWRITE.     final boolean alwaysCreateDirectory = configuration.getBoolean(CoreOptions.FILESYSTEM_OUTPUT_ALWAYS_CREATE_DIRECTORY).     DEFAULT_OUTPUT_DIRECTORY_MODE = alwaysCreateDirectory ? OutputDirectoryMode.ALWAYS : OutputDirectoryMode.PARONLY. }
false;public;1;7;;public void setOutputFilePath(Path path) {     if (path == null) {         throw new IllegalArgumentException("Output file path may not be null.").     }     this.outputFilePath = path. }
false;public;0;3;;public Path getOutputFilePath() {     return this.outputFilePath. }
false;public;1;7;;public void setWriteMode(WriteMode mode) {     if (mode == null) {         throw new NullPointerException().     }     this.writeMode = mode. }
false;public;0;3;;public WriteMode getWriteMode() {     return this.writeMode. }
false;public;1;7;;public void setOutputDirectoryMode(OutputDirectoryMode mode) {     if (mode == null) {         throw new NullPointerException().     }     this.outputDirectoryMode = mode. }
false;public;0;3;;public OutputDirectoryMode getOutputDirectoryMode() {     return this.outputDirectoryMode. }
false;public;1;28;;// ---------------------------------------------------------------- @Override public void configure(Configuration parameters) {     // get the output file path, if it was not yet set     if (this.outputFilePath == null) {         // get the file parameter         String filePath = parameters.getString(FILE_PARAMETER_KEY, null).         if (filePath == null) {             throw new IllegalArgumentException("The output path has been specified neither via constructor/setters" + ", nor via the Configuration.").         }         try {             this.outputFilePath = new Path(filePath).         } catch (RuntimeException rex) {             throw new RuntimeException("Could not create a valid URI from the given file path name: " + rex.getMessage()).         }     }     // check if have not been set and use the defaults in that case     if (this.writeMode == null) {         this.writeMode = DEFAULT_WRITE_MODE.     }     if (this.outputDirectoryMode == null) {         this.outputDirectoryMode = DEFAULT_OUTPUT_DIRECTORY_MODE.     } }
false;public;2;51;;@Override public void open(int taskNumber, int numTasks) throws IOException {     if (taskNumber < 0 || numTasks < 1) {         throw new IllegalArgumentException("TaskNumber: " + taskNumber + ", numTasks: " + numTasks).     }     if (LOG.isDebugEnabled()) {         LOG.debug("Opening stream for output (" + (taskNumber + 1) + "/" + numTasks + "). WriteMode=" + writeMode + ", OutputDirectoryMode=" + outputDirectoryMode).     }     Path p = this.outputFilePath.     if (p == null) {         throw new IOException("The file path is null.").     }     final FileSystem fs = p.getFileSystem().     // if this is a local file system, we need to initialize the local output directory here     if (!fs.isDistributedFS()) {         if (numTasks == 1 && outputDirectoryMode == OutputDirectoryMode.PARONLY) {             // prepare local output path. checks for write mode and removes existing files in case of OVERWRITE mode             if (!fs.initOutPathLocalFS(p, writeMode, false)) {                 // output preparation failed! Cancel task.                 throw new IOException("Output path '" + p.toString() + "' could not be initialized. Canceling task...").             }         } else {             if (!fs.initOutPathLocalFS(p, writeMode, true)) {                 // output preparation failed! Cancel task.                 throw new IOException("Output directory '" + p.toString() + "' could not be created. Canceling task...").             }         }     }     // Suffix the path with the parallel instance index, if needed     this.actualFilePath = (numTasks > 1 || outputDirectoryMode == OutputDirectoryMode.ALWAYS) ? p.suffix("/" + getDirectoryFileName(taskNumber)) : p.     // create output file     this.stream = fs.create(this.actualFilePath, writeMode).     // at this point, the file creation must have succeeded, or an exception has been thrown     this.fileCreated = true. }
false;protected;1;3;;protected String getDirectoryFileName(int taskNumber) {     return Integer.toString(taskNumber + 1). }
false;public;0;8;;@Override public void close() throws IOException {     final FSDataOutputStream s = this.stream.     if (s != null) {         this.stream = null.         s.close().     } }
true;public;1;29;/**  * Initialization of the distributed file system if it is used.  *  * @param parallelism The task parallelism.  */ ;/**  * Initialization of the distributed file system if it is used.  *  * @param parallelism The task parallelism.  */ @Override public void initializeGlobal(int parallelism) throws IOException {     final Path path = getOutputFilePath().     final FileSystem fs = path.getFileSystem().     // only distributed file systems can be initialized at start-up time.     if (fs.isDistributedFS()) {         final WriteMode writeMode = getWriteMode().         final OutputDirectoryMode outDirMode = getOutputDirectoryMode().         if (parallelism == 1 && outDirMode == OutputDirectoryMode.PARONLY) {             // prepare distributed output path             if (!fs.initOutPathDistFS(path, writeMode, false)) {                 // output preparation failed! Cancel task.                 throw new IOException("Output path could not be initialized.").             }         } else {             // only distributed file systems can be initialized at start-up time.             if (!fs.initOutPathDistFS(path, writeMode, true)) {                 throw new IOException("Output directory could not be created.").             }         }     } }
false;public;0;20;;@Override public void tryCleanupOnError() {     if (this.fileCreated) {         this.fileCreated = false.         try {             close().         } catch (IOException e) {             LOG.error("Could not properly close FileOutputFormat.", e).         }         try {             FileSystem.get(this.actualFilePath.toUri()).delete(actualFilePath, false).         } catch (FileNotFoundException e) {         // ignore, may not be visible yet or may be already removed         } catch (Throwable t) {             LOG.error("Could not remove the incomplete file " + actualFilePath + '.', t).         }     } }
