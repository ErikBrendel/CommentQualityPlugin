commented;modifiers;parameterAmount;loc;comment;code
true;public;2;9;/**  * Sets the order of the elements within a group for the given input.  *  * @param inputNum The number of the input (here either <i>0</i> or <i>1</i>).  * @param order    The order for the elements in a group.  */ ;// -------------------------------------------------------------------------------------------- /**  * Sets the order of the elements within a group for the given input.  *  * @param inputNum The number of the input (here either <i>0</i> or <i>1</i>).  * @param order    The order for the elements in a group.  */ public void setGroupOrder(int inputNum, Ordering order) {     if (inputNum == 0) {         this.groupOrder1 = order.     } else if (inputNum == 1) {         this.groupOrder2 = order.     } else {         throw new IndexOutOfBoundsException().     } }
true;public;1;3;/**  * Sets the order of the elements within a group for the first input.  *  * @param order The order for the elements in a group.  */ ;/**  * Sets the order of the elements within a group for the first input.  *  * @param order The order for the elements in a group.  */ public void setGroupOrderForInputOne(Ordering order) {     setGroupOrder(0, order). }
true;public;1;3;/**  * Sets the order of the elements within a group for the second input.  *  * @param order The order for the elements in a group.  */ ;/**  * Sets the order of the elements within a group for the second input.  *  * @param order The order for the elements in a group.  */ public void setGroupOrderForInputTwo(Ordering order) {     setGroupOrder(1, order). }
true;public;1;9;/**  * Gets the value order for an input, i.e. the order of elements within a group.  * If no such order has been set, this method returns null.  *  * @param inputNum The number of the input (here either <i>0</i> or <i>1</i>).  * @return The group order.  */ ;/**  * Gets the value order for an input, i.e. the order of elements within a group.  * If no such order has been set, this method returns null.  *  * @param inputNum The number of the input (here either <i>0</i> or <i>1</i>).  * @return The group order.  */ public Ordering getGroupOrder(int inputNum) {     if (inputNum == 0) {         return this.groupOrder1.     } else if (inputNum == 1) {         return this.groupOrder2.     } else {         throw new IndexOutOfBoundsException().     } }
true;public;0;3;/**  * Gets the order of elements within a group for the first input.  * If no such order has been set, this method returns null.  *  * @return The group order for the first input.  */ ;/**  * Gets the order of elements within a group for the first input.  * If no such order has been set, this method returns null.  *  * @return The group order for the first input.  */ public Ordering getGroupOrderForInputOne() {     return getGroupOrder(0). }
true;public;0;3;/**  * Gets the order of elements within a group for the second input.  * If no such order has been set, this method returns null.  *  * @return The group order for the second input.  */ ;/**  * Gets the order of elements within a group for the second input.  * If no such order has been set, this method returns null.  *  * @return The group order for the second input.  */ public Ordering getGroupOrderForInputTwo() {     return getGroupOrder(1). }
true;public;0;3;// -------------------------------------------------------------------------------------------- ;// -------------------------------------------------------------------------------------------- public boolean isCombinableFirst() {     return this.combinableFirst. }
false;public;1;3;;public void setCombinableFirst(boolean combinableFirst) {     this.combinableFirst = combinableFirst. }
false;public;0;3;;public boolean isCombinableSecond() {     return this.combinableSecond. }
false;public;1;3;;public void setCombinableSecond(boolean combinableSecond) {     this.combinableSecond = combinableSecond. }
true;protected;4;43;// ------------------------------------------------------------------------ ;// ------------------------------------------------------------------------ @Override protected List<OUT> executeOnCollections(List<IN1> input1, List<IN2> input2, RuntimeContext ctx, ExecutionConfig executionConfig) throws Exception {     // --------------------------------------------------------------------     // Setup     // --------------------------------------------------------------------     TypeInformation<IN1> inputType1 = getOperatorInfo().getFirstInputType().     TypeInformation<IN2> inputType2 = getOperatorInfo().getSecondInputType().     int[] inputKeys1 = getKeyColumns(0).     int[] inputKeys2 = getKeyColumns(1).     boolean[] inputSortDirections1 = new boolean[inputKeys1.length].     boolean[] inputSortDirections2 = new boolean[inputKeys2.length].     Arrays.fill(inputSortDirections1, true).     Arrays.fill(inputSortDirections2, true).     final TypeSerializer<IN1> inputSerializer1 = inputType1.createSerializer(executionConfig).     final TypeSerializer<IN2> inputSerializer2 = inputType2.createSerializer(executionConfig).     final TypeComparator<IN1> inputComparator1 = getTypeComparator(executionConfig, inputType1, inputKeys1, inputSortDirections1).     final TypeComparator<IN2> inputComparator2 = getTypeComparator(executionConfig, inputType2, inputKeys2, inputSortDirections2).     SimpleListIterable<IN1> iterator1 = new SimpleListIterable<IN1>(input1, inputComparator1, inputSerializer1).     SimpleListIterable<IN2> iterator2 = new SimpleListIterable<IN2>(input2, inputComparator2, inputSerializer2).     // --------------------------------------------------------------------     // Run UDF     // --------------------------------------------------------------------     CoGroupFunction<IN1, IN2, OUT> function = userFunction.getUserCodeObject().     FunctionUtils.setFunctionRuntimeContext(function, ctx).     FunctionUtils.openFunction(function, parameters).     List<OUT> result = new ArrayList<OUT>().     Collector<OUT> resultCollector = new CopyingListCollector<OUT>(result, getOperatorInfo().getOutputType().createSerializer(executionConfig)).     function.coGroup(iterator1, iterator2, resultCollector).     FunctionUtils.closeFunction(function).     return result. }
false;private;4;7;;private <T> TypeComparator<T> getTypeComparator(ExecutionConfig executionConfig, TypeInformation<T> inputType, int[] inputKeys, boolean[] inputSortDirections) {     if (!(inputType instanceof CompositeType)) {         throw new InvalidProgramException("Input types of coGroup must be composite types.").     }     return ((CompositeType<T>) inputType).createComparator(inputKeys, inputSortDirections, 0, executionConfig). }
false;public;2;4;;@Override public int compare(IN o1, IN o2) {     return comparator.compare(o1, o2). }
false;public;0;4;;@Override public Iterator<IN> iterator() {     return new SimpleListIterator<IN>(values, serializer). }
false;public;0;4;;@Override public boolean hasNext() {     return pos < values.size(). }
false;public;0;5;;@Override public IN next() {     IN current = values.get(pos++).     return serializer.copy(current). }
false;public;0;3;;@Override public void remove() { // unused }
