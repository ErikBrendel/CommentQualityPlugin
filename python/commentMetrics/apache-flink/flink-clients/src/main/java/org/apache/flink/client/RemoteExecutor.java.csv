commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * Sets the parallelism that will be used when neither the program does not define  * any parallelism at all.  *  * @param defaultParallelism The default parallelism for the executor.  */ ;// ------------------------------------------------------------------------ // Properties // ------------------------------------------------------------------------ /**  * Sets the parallelism that will be used when neither the program does not define  * any parallelism at all.  *  * @param defaultParallelism The default parallelism for the executor.  */ public void setDefaultParallelism(int defaultParallelism) {     if (defaultParallelism < 1) {         throw new IllegalArgumentException("The default parallelism must be at least one").     }     this.defaultParallelism = defaultParallelism. }
true;public;0;3;/**  * Gets the parallelism that will be used when neither the program does not define  * any parallelism at all.  *  * @return The default parallelism for the executor.  */ ;/**  * Gets the parallelism that will be used when neither the program does not define  * any parallelism at all.  *  * @return The default parallelism for the executor.  */ public int getDefaultParallelism() {     return defaultParallelism. }
false;public;0;12;;// ------------------------------------------------------------------------ // Startup & Shutdown // ------------------------------------------------------------------------ @Override public void start() throws Exception {     synchronized (lock) {         if (client == null) {             client = new RestClusterClient<>(clientConfiguration, "RemoteExecutor").             client.setPrintStatusDuringExecution(isPrintingStatusDuringExecution()).         } else {             throw new IllegalStateException("The remote executor was already started.").         }     } }
false;public;0;9;;@Override public void stop() throws Exception {     synchronized (lock) {         if (client != null) {             client.shutdown().             client = null.         }     } }
false;public;0;4;;@Override public boolean isRunning() {     return client != null. }
false;public;1;9;;// ------------------------------------------------------------------------ // Executing programs // ------------------------------------------------------------------------ @Override public JobExecutionResult executePlan(Plan plan) throws Exception {     if (plan == null) {         throw new IllegalArgumentException("The plan may not be null.").     }     JobWithJars p = new JobWithJars(plan, this.jarFiles, this.globalClasspaths).     return executePlanWithJars(p). }
false;public;1;29;;public JobExecutionResult executePlanWithJars(JobWithJars program) throws Exception {     if (program == null) {         throw new IllegalArgumentException("The job may not be null.").     }     synchronized (this.lock) {         // check if we start a session dedicated for this execution         final boolean shutDownAtEnd.         if (client == null) {             shutDownAtEnd = true.             // start the executor for us             start().         } else {             // we use the existing session             shutDownAtEnd = false.         }         try {             return client.run(program, defaultParallelism).getJobExecutionResult().         } finally {             if (shutDownAtEnd) {                 stop().             }         }     } }
false;public;1;6;;@Override public String getOptimizerPlanAsJSON(Plan plan) throws Exception {     Optimizer opt = new Optimizer(new DataStatistics(), new DefaultCostEstimator(), new Configuration()).     OptimizedPlan optPlan = opt.compile(plan).     return new PlanJSONDumpGenerator().getOptimizerPlanAsJSON(optPlan). }
false;public;1;30;;@Override public void endSession(JobID jobID) throws Exception {     if (jobID == null) {         throw new NullPointerException("The supplied jobID must not be null.").     }     synchronized (this.lock) {         // check if we start a session dedicated for this execution         final boolean shutDownAtEnd.         if (client == null) {             shutDownAtEnd = true.             // start the executor for us             start().         } else {             // we use the existing session             shutDownAtEnd = false.         }         try {             client.endSession(jobID).         } finally {             if (shutDownAtEnd) {                 stop().             }         }     } }
