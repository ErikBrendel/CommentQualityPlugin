commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public JobExecutionResult execute(String jobName) throws Exception {     Plan p = createProgramPlan(jobName).     setDetachedPlan(ClusterClient.getOptimizedPlan(client.compiler, p, getParallelism())).     LOG.warn("Job was executed in detached mode, the results will be available on completion.").     this.lastJobExecutionResult = DetachedJobExecutionResult.INSTANCE.     return this.lastJobExecutionResult. }
false;public;1;8;;public void setDetachedPlan(FlinkPlan plan) {     if (detachedPlan == null) {         detachedPlan = plan.     } else {         throw new InvalidProgramException(DetachedJobExecutionResult.DETACHED_MESSAGE + DetachedJobExecutionResult.EXECUTE_TWICE_MESSAGE).     } }
true;;0;3;/**  * Finishes this Context Environment's execution by explicitly running the plan constructed.  */ ;/**  * Finishes this Context Environment's execution by explicitly running the plan constructed.  */ JobSubmissionResult finalizeExecute() throws ProgramInvocationException {     return client.run(detachedPlan, jarFilesToAttach, classpathsToAttach, userCodeClassLoader, savepointSettings). }
false;public;0;4;;@Override public long getNetRuntime() {     throw new InvalidProgramException(DETACHED_MESSAGE + JOB_RESULT_MESSAGE). }
false;public;1;4;;@Override public <T> T getAccumulatorResult(String accumulatorName) {     throw new InvalidProgramException(DETACHED_MESSAGE + JOB_RESULT_MESSAGE + EAGER_FUNCTION_MESSAGE). }
false;public;0;4;;@Override public Map<String, Object> getAllAccumulatorResults() {     throw new InvalidProgramException(DETACHED_MESSAGE + JOB_RESULT_MESSAGE). }
false;public;1;4;;@Override public Integer getIntCounterResult(String accumulatorName) {     throw new InvalidProgramException(DETACHED_MESSAGE + JOB_RESULT_MESSAGE). }
false;public;0;4;;@Override public JobID getJobID() {     throw new InvalidProgramException(DETACHED_MESSAGE + JOB_RESULT_MESSAGE). }
