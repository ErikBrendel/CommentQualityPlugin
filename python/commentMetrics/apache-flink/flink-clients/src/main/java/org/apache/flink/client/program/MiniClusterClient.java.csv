commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public void shutdown() throws Exception {     super.shutdown(). }
false;public;2;34;;@Override public JobSubmissionResult submitJob(JobGraph jobGraph, ClassLoader classLoader) throws ProgramInvocationException {     final CompletableFuture<JobSubmissionResult> jobSubmissionResultFuture = submitJob(jobGraph).     if (isDetached()) {         try {             return jobSubmissionResultFuture.get().         } catch (InterruptedException | ExecutionException e) {             ExceptionUtils.checkInterrupted(e).             throw new ProgramInvocationException("Could not run job in detached mode.", jobGraph.getJobID(), e).         }     } else {         final CompletableFuture<JobResult> jobResultFuture = jobSubmissionResultFuture.thenCompose((JobSubmissionResult ignored) -> requestJobResult(jobGraph.getJobID())).         final JobResult jobResult.         try {             jobResult = jobResultFuture.get().         } catch (InterruptedException | ExecutionException e) {             ExceptionUtils.checkInterrupted(e).             throw new ProgramInvocationException("Could not run job", jobGraph.getJobID(), e).         }         try {             return jobResult.toJobExecutionResult(classLoader).         } catch (JobExecutionException e) {             throw new ProgramInvocationException("Job failed", jobGraph.getJobID(), e).         } catch (IOException | ClassNotFoundException e) {             throw new ProgramInvocationException("Job failed", jobGraph.getJobID(), e).         }     } }
false;public;1;4;;@Override public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {     return miniCluster.submitJob(jobGraph). }
false;public;1;4;;@Override public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {     return miniCluster.requestJobResult(jobId). }
false;public;1;4;;@Override public void cancel(JobID jobId) throws Exception {     miniCluster.cancelJob(jobId).get(). }
false;public;2;4;;@Override public String cancelWithSavepoint(JobID jobId, @Nullable String savepointDirectory) throws Exception {     return miniCluster.triggerSavepoint(jobId, savepointDirectory, true).get(). }
false;public;1;4;;@Override public void stop(JobID jobId) throws Exception {     miniCluster.stopJob(jobId).get(). }
false;public;2;4;;@Override public CompletableFuture<String> triggerSavepoint(JobID jobId, @Nullable String savepointDirectory) {     return miniCluster.triggerSavepoint(jobId, savepointDirectory, false). }
false;public;1;4;;@Override public CompletableFuture<Acknowledge> disposeSavepoint(String savepointPath) {     return miniCluster.disposeSavepoint(savepointPath). }
false;public;0;4;;@Override public CompletableFuture<Collection<JobStatusMessage>> listJobs() {     return miniCluster.listJobs(). }
false;public;1;4;;@Override public Map<String, OptionalFailure<Object>> getAccumulators(JobID jobID) throws Exception {     return getAccumulators(jobID, ClassLoader.getSystemClassLoader()). }
false;public;2;10;;@Override public Map<String, OptionalFailure<Object>> getAccumulators(JobID jobID, ClassLoader loader) throws Exception {     AccessExecutionGraph executionGraph = miniCluster.getExecutionGraph(jobID).get().     Map<String, SerializedValue<OptionalFailure<Object>>> accumulatorsSerialized = executionGraph.getAccumulatorsSerialized().     Map<String, OptionalFailure<Object>> result = new HashMap<>(accumulatorsSerialized.size()).     for (Map.Entry<String, SerializedValue<OptionalFailure<Object>>> acc : accumulatorsSerialized.entrySet()) {         result.put(acc.getKey(), acc.getValue().deserializeValue(loader)).     }     return result. }
false;public;1;4;;@Override public CompletableFuture<JobStatus> getJobStatus(JobID jobId) {     return miniCluster.getJobStatus(jobId). }
false;public;0;4;;@Override public MiniClusterClient.MiniClusterId getClusterId() {     return MiniClusterId.INSTANCE. }
false;public;0;6;;@Override public LeaderConnectionInfo getClusterConnectionInfo() throws LeaderRetrievalException {     return LeaderRetrievalUtils.retrieveLeaderConnectionInfo(highAvailabilityServices.getDispatcherLeaderRetriever(), timeout). }
false;public;0;4;;// ====================================== // Legacy methods // ====================================== @Override public void waitForClusterToBeReady() { // no op }
false;public;0;4;;@Override public String getWebInterfaceURL() {     return miniCluster.getRestAddress().toString(). }
false;public;0;4;;@Override public GetClusterStatusResponse getClusterStatus() {     return null. }
false;public;0;4;;@Override public List<String> getNewMessages() {     return Collections.emptyList(). }
false;public;0;4;;@Override public int getMaxSlots() {     return MAX_SLOTS_UNKNOWN. }
false;public;1;4;;@Override public boolean hasUserJarsInClassPath(List<URL> userJarFiles) {     return false. }
