commented;modifiers;parameterAmount;loc;comment;code
false;private;0;4;;private void startLeaderRetrievers() throws Exception {     this.webMonitorRetrievalService.start(webMonitorLeaderRetriever).     this.dispatcherRetrievalService.start(dispatcherLeaderRetriever). }
false;public;0;26;;@Override public void shutdown() {     ExecutorUtils.gracefulShutdown(restClusterClientConfiguration.getRetryDelay(), TimeUnit.MILLISECONDS, retryExecutorService).     this.restClient.shutdown(Time.seconds(5)).     ExecutorUtils.gracefulShutdown(5, TimeUnit.SECONDS, this.executorService).     try {         webMonitorRetrievalService.stop().     } catch (Exception e) {         log.error("An error occurred during stopping the webMonitorRetrievalService", e).     }     try {         dispatcherRetrievalService.stop().     } catch (Exception e) {         log.error("An error occurred during stopping the dispatcherLeaderRetriever", e).     }     try {         // we only call this for legacy reasons to shutdown components that are started in the ClusterClient constructor         super.shutdown().     } catch (Exception e) {         log.error("An error occurred during the client shutdown.", e).     } }
false;public;2;35;;@Override public JobSubmissionResult submitJob(JobGraph jobGraph, ClassLoader classLoader) throws ProgramInvocationException {     log.info("Submitting job {} (detached: {}).", jobGraph.getJobID(), isDetached()).     final CompletableFuture<JobSubmissionResult> jobSubmissionFuture = submitJob(jobGraph).     if (isDetached()) {         try {             return jobSubmissionFuture.get().         } catch (Exception e) {             throw new ProgramInvocationException("Could not submit job", jobGraph.getJobID(), ExceptionUtils.stripExecutionException(e)).         }     } else {         final CompletableFuture<JobResult> jobResultFuture = jobSubmissionFuture.thenCompose(ignored -> requestJobResult(jobGraph.getJobID())).         final JobResult jobResult.         try {             jobResult = jobResultFuture.get().         } catch (Exception e) {             throw new ProgramInvocationException("Could not retrieve the execution result.", jobGraph.getJobID(), ExceptionUtils.stripExecutionException(e)).         }         try {             this.lastJobExecutionResult = jobResult.toJobExecutionResult(classLoader).             return lastJobExecutionResult.         } catch (JobExecutionException e) {             throw new ProgramInvocationException("Job failed.", jobGraph.getJobID(), e).         } catch (IOException | ClassNotFoundException e) {             throw new ProgramInvocationException("Job failed.", jobGraph.getJobID(), e).         }     } }
true;public;1;9;/**  * Requests the job details.  *  * @param jobId The job id  * @return Job details  */ ;/**  * Requests the job details.  *  * @param jobId The job id  * @return Job details  */ public CompletableFuture<JobDetailsInfo> getJobDetails(JobID jobId) {     final JobDetailsHeaders detailsHeaders = JobDetailsHeaders.getInstance().     final JobMessageParameters params = new JobMessageParameters().     params.jobPathParameter.resolve(jobId).     return sendRequest(detailsHeaders, params). }
false;public;1;4;;@Override public CompletableFuture<JobStatus> getJobStatus(JobID jobId) {     return getJobDetails(jobId).thenApply(JobDetailsInfo::getJobStatus). }
true;public;1;11;/**  * Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple  * times to poll the {@link JobResult} before giving up.  *  * @param jobId specifying the job for which to retrieve the {@link JobResult}  * @return Future which is completed with the {@link JobResult} once the job has completed or  * with a failure if the {@link JobResult} could not be retrieved.  */ ;/**  * Requests the {@link JobResult} for the given {@link JobID}. The method retries multiple  * times to poll the {@link JobResult} before giving up.  *  * @param jobId specifying the job for which to retrieve the {@link JobResult}  * @return Future which is completed with the {@link JobResult} once the job has completed or  * with a failure if the {@link JobResult} could not be retrieved.  */ @Override public CompletableFuture<JobResult> requestJobResult(@Nonnull JobID jobId) {     return pollResourceAsync(() -> {         final JobMessageParameters messageParameters = new JobMessageParameters().         messageParameters.jobPathParameter.resolve(jobId).         return sendRequest(JobExecutionResultHeaders.getInstance(), messageParameters).     }). }
true;public;1;69;/**  * Submits the given {@link JobGraph} to the dispatcher.  *  * @param jobGraph to submit  * @return Future which is completed with the submission response  */ ;/**  * Submits the given {@link JobGraph} to the dispatcher.  *  * @param jobGraph to submit  * @return Future which is completed with the submission response  */ @Override public CompletableFuture<JobSubmissionResult> submitJob(@Nonnull JobGraph jobGraph) {     // we have to enable queued scheduling because slot will be allocated lazily     jobGraph.setAllowQueuedScheduling(true).     CompletableFuture<java.nio.file.Path> jobGraphFileFuture = CompletableFuture.supplyAsync(() -> {         try {             final java.nio.file.Path jobGraphFile = Files.createTempFile("flink-jobgraph", ".bin").             try (ObjectOutputStream objectOut = new ObjectOutputStream(Files.newOutputStream(jobGraphFile))) {                 objectOut.writeObject(jobGraph).             }             return jobGraphFile.         } catch (IOException e) {             throw new CompletionException(new FlinkException("Failed to serialize JobGraph.", e)).         }     }, executorService).     CompletableFuture<Tuple2<JobSubmitRequestBody, Collection<FileUpload>>> requestFuture = jobGraphFileFuture.thenApply(jobGraphFile -> {         List<String> jarFileNames = new ArrayList<>(8).         List<JobSubmitRequestBody.DistributedCacheFile> artifactFileNames = new ArrayList<>(8).         Collection<FileUpload> filesToUpload = new ArrayList<>(8).         filesToUpload.add(new FileUpload(jobGraphFile, RestConstants.CONTENT_TYPE_BINARY)).         for (Path jar : jobGraph.getUserJars()) {             jarFileNames.add(jar.getName()).             filesToUpload.add(new FileUpload(Paths.get(jar.toUri()), RestConstants.CONTENT_TYPE_JAR)).         }         for (Map.Entry<String, DistributedCache.DistributedCacheEntry> artifacts : jobGraph.getUserArtifacts().entrySet()) {             artifactFileNames.add(new JobSubmitRequestBody.DistributedCacheFile(artifacts.getKey(), new Path(artifacts.getValue().filePath).getName())).             filesToUpload.add(new FileUpload(Paths.get(artifacts.getValue().filePath), RestConstants.CONTENT_TYPE_BINARY)).         }         final JobSubmitRequestBody requestBody = new JobSubmitRequestBody(jobGraphFile.getFileName().toString(), jarFileNames, artifactFileNames).         return Tuple2.of(requestBody, Collections.unmodifiableCollection(filesToUpload)).     }).     final CompletableFuture<JobSubmitResponseBody> submissionFuture = requestFuture.thenCompose(requestAndFileUploads -> sendRetriableRequest(JobSubmitHeaders.getInstance(), EmptyMessageParameters.getInstance(), requestAndFileUploads.f0, requestAndFileUploads.f1, isConnectionProblemOrServiceUnavailable())).     submissionFuture.thenCombine(jobGraphFileFuture, (ignored, jobGraphFile) -> jobGraphFile).thenAccept(jobGraphFile -> {         try {             Files.delete(jobGraphFile).         } catch (IOException e) {             log.warn("Could not delete temporary file {}.", jobGraphFile, e).         }     }).     return submissionFuture.thenApply((JobSubmitResponseBody jobSubmitResponseBody) -> new JobSubmissionResult(jobGraph.getJobID())).exceptionally((Throwable throwable) -> {         throw new CompletionException(new JobSubmissionException(jobGraph.getJobID(), "Failed to submit JobGraph.", ExceptionUtils.stripCompletionException(throwable))).     }). }
false;public;1;10;;@Override public void stop(JobID jobID) throws Exception {     JobTerminationMessageParameters params = new JobTerminationMessageParameters().     params.jobPathParameter.resolve(jobID).     params.terminationModeQueryParameter.resolve(Collections.singletonList(TerminationModeQueryParameter.TerminationMode.STOP)).     CompletableFuture<EmptyResponseBody> responseFuture = sendRequest(JobTerminationHeaders.getInstance(), params).     responseFuture.get(timeout.toMillis(), TimeUnit.MILLISECONDS). }
false;public;1;10;;@Override public void cancel(JobID jobID) throws Exception {     JobTerminationMessageParameters params = new JobTerminationMessageParameters().     params.jobPathParameter.resolve(jobID).     params.terminationModeQueryParameter.resolve(Collections.singletonList(TerminationModeQueryParameter.TerminationMode.CANCEL)).     CompletableFuture<EmptyResponseBody> responseFuture = sendRequest(JobTerminationHeaders.getInstance(), params).     responseFuture.get(timeout.toMillis(), TimeUnit.MILLISECONDS). }
false;public;2;4;;@Override public String cancelWithSavepoint(JobID jobId, @Nullable String savepointDirectory) throws Exception {     return triggerSavepoint(jobId, savepointDirectory, true).get(). }
false;public;2;6;;@Override public CompletableFuture<String> triggerSavepoint(final JobID jobId, @Nullable final String savepointDirectory) {     return triggerSavepoint(jobId, savepointDirectory, false). }
false;private;3;24;;private CompletableFuture<String> triggerSavepoint(final JobID jobId, @Nullable final String savepointDirectory, final boolean cancelJob) {     final SavepointTriggerHeaders savepointTriggerHeaders = SavepointTriggerHeaders.getInstance().     final SavepointTriggerMessageParameters savepointTriggerMessageParameters = savepointTriggerHeaders.getUnresolvedMessageParameters().     savepointTriggerMessageParameters.jobID.resolve(jobId).     final CompletableFuture<TriggerResponse> responseFuture = sendRequest(savepointTriggerHeaders, savepointTriggerMessageParameters, new SavepointTriggerRequestBody(savepointDirectory, cancelJob)).     return responseFuture.thenCompose(savepointTriggerResponseBody -> {         final TriggerId savepointTriggerId = savepointTriggerResponseBody.getTriggerId().         return pollSavepointAsync(jobId, savepointTriggerId).     }).thenApply(savepointInfo -> {         if (savepointInfo.getFailureCause() != null) {             throw new CompletionException(savepointInfo.getFailureCause()).         }         return savepointInfo.getLocation().     }). }
false;public;2;32;;@Override public Map<String, OptionalFailure<Object>> getAccumulators(final JobID jobID, ClassLoader loader) throws Exception {     final JobAccumulatorsHeaders accumulatorsHeaders = JobAccumulatorsHeaders.getInstance().     final JobAccumulatorsMessageParameters accMsgParams = accumulatorsHeaders.getUnresolvedMessageParameters().     accMsgParams.jobPathParameter.resolve(jobID).     accMsgParams.includeSerializedAccumulatorsParameter.resolve(Collections.singletonList(true)).     CompletableFuture<JobAccumulatorsInfo> responseFuture = sendRequest(accumulatorsHeaders, accMsgParams).     Map<String, OptionalFailure<Object>> result = Collections.emptyMap().     try {         result = responseFuture.thenApply((JobAccumulatorsInfo accumulatorsInfo) -> {             try {                 return AccumulatorHelper.deserializeAccumulators(accumulatorsInfo.getSerializedUserAccumulators(), loader).             } catch (Exception e) {                 throw new CompletionException(new FlinkException(String.format("Deserialization of accumulators for job %s failed.", jobID), e)).             }         }).get(timeout.toMillis(), TimeUnit.MILLISECONDS).     } catch (ExecutionException ee) {         ExceptionUtils.rethrowException(ExceptionUtils.stripExecutionException(ee)).     }     return result. }
false;private;2;14;;private CompletableFuture<SavepointInfo> pollSavepointAsync(final JobID jobId, final TriggerId triggerID) {     return pollResourceAsync(() -> {         final SavepointStatusHeaders savepointStatusHeaders = SavepointStatusHeaders.getInstance().         final SavepointStatusMessageParameters savepointStatusMessageParameters = savepointStatusHeaders.getUnresolvedMessageParameters().         savepointStatusMessageParameters.jobIdPathParameter.resolve(jobId).         savepointStatusMessageParameters.triggerIdPathParameter.resolve(triggerID).         return sendRequest(savepointStatusHeaders, savepointStatusMessageParameters).     }). }
false;public;0;14;;@Override public CompletableFuture<Collection<JobStatusMessage>> listJobs() {     return sendRequest(JobsOverviewHeaders.getInstance()).thenApply((multipleJobsDetails) -> multipleJobsDetails.getJobs().stream().map(detail -> new JobStatusMessage(detail.getJobId(), detail.getJobName(), detail.getStatus(), detail.getStartTime())).collect(Collectors.toList())). }
false;public;0;4;;@Override public T getClusterId() {     return clusterId. }
false;public;0;6;;@Override public LeaderConnectionInfo getClusterConnectionInfo() throws LeaderRetrievalException {     return LeaderRetrievalUtils.retrieveLeaderConnectionInfo(highAvailabilityServices.getDispatcherLeaderRetriever(), timeout). }
false;public;2;36;;@Override public CompletableFuture<Acknowledge> rescaleJob(JobID jobId, int newParallelism) {     final RescalingTriggerHeaders rescalingTriggerHeaders = RescalingTriggerHeaders.getInstance().     final RescalingTriggerMessageParameters rescalingTriggerMessageParameters = rescalingTriggerHeaders.getUnresolvedMessageParameters().     rescalingTriggerMessageParameters.jobPathParameter.resolve(jobId).     rescalingTriggerMessageParameters.rescalingParallelismQueryParameter.resolve(Collections.singletonList(newParallelism)).     final CompletableFuture<TriggerResponse> rescalingTriggerResponseFuture = sendRequest(rescalingTriggerHeaders, rescalingTriggerMessageParameters).     final CompletableFuture<AsynchronousOperationInfo> rescalingOperationFuture = rescalingTriggerResponseFuture.thenCompose((TriggerResponse triggerResponse) -> {         final TriggerId triggerId = triggerResponse.getTriggerId().         final RescalingStatusHeaders rescalingStatusHeaders = RescalingStatusHeaders.getInstance().         final RescalingStatusMessageParameters rescalingStatusMessageParameters = rescalingStatusHeaders.getUnresolvedMessageParameters().         rescalingStatusMessageParameters.jobPathParameter.resolve(jobId).         rescalingStatusMessageParameters.triggerIdPathParameter.resolve(triggerId).         return pollResourceAsync(() -> sendRequest(rescalingStatusHeaders, rescalingStatusMessageParameters)).     }).     return rescalingOperationFuture.thenApply((AsynchronousOperationInfo asynchronousOperationInfo) -> {         if (asynchronousOperationInfo.getFailureCause() == null) {             return Acknowledge.get().         } else {             throw new CompletionException(asynchronousOperationInfo.getFailureCause()).         }     }). }
false;public;1;30;;@Override public CompletableFuture<Acknowledge> disposeSavepoint(String savepointPath) {     final SavepointDisposalRequest savepointDisposalRequest = new SavepointDisposalRequest(savepointPath).     final CompletableFuture<TriggerResponse> savepointDisposalTriggerFuture = sendRequest(SavepointDisposalTriggerHeaders.getInstance(), savepointDisposalRequest).     final CompletableFuture<AsynchronousOperationInfo> savepointDisposalFuture = savepointDisposalTriggerFuture.thenCompose((TriggerResponse triggerResponse) -> {         final TriggerId triggerId = triggerResponse.getTriggerId().         final SavepointDisposalStatusHeaders savepointDisposalStatusHeaders = SavepointDisposalStatusHeaders.getInstance().         final SavepointDisposalStatusMessageParameters savepointDisposalStatusMessageParameters = savepointDisposalStatusHeaders.getUnresolvedMessageParameters().         savepointDisposalStatusMessageParameters.triggerIdPathParameter.resolve(triggerId).         return pollResourceAsync(() -> sendRequest(savepointDisposalStatusHeaders, savepointDisposalStatusMessageParameters)).     }).     return savepointDisposalFuture.thenApply((AsynchronousOperationInfo asynchronousOperationInfo) -> {         if (asynchronousOperationInfo.getFailureCause() == null) {             return Acknowledge.get().         } else {             throw new CompletionException(asynchronousOperationInfo.getFailureCause()).         }     }). }
false;public;0;10;;@Override public void shutDownCluster() {     try {         sendRequest(ShutdownHeaders.getInstance()).get().     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } catch (ExecutionException e) {         log.error("Error while shutting down cluster", e).     } }
true;private;1;4;/**  * Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until  * its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes  * {@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of  * {@link AsynchronouslyCreatedResource#resource()}.  *  * @param resourceFutureSupplier The operation which polls for the  *                               {@code AsynchronouslyCreatedResource}.  * @param <R>                    The type of the resource.  * @param <A>                    The type of the {@code AsynchronouslyCreatedResource}.  * @return A {@code CompletableFuture} delivering the resource.  */ ;/**  * Creates a {@code CompletableFuture} that polls a {@code AsynchronouslyCreatedResource} until  * its {@link AsynchronouslyCreatedResource#queueStatus() QueueStatus} becomes  * {@link QueueStatus.Id#COMPLETED COMPLETED}. The future completes with the result of  * {@link AsynchronouslyCreatedResource#resource()}.  *  * @param resourceFutureSupplier The operation which polls for the  *                               {@code AsynchronouslyCreatedResource}.  * @param <R>                    The type of the resource.  * @param <A>                    The type of the {@code AsynchronouslyCreatedResource}.  * @return A {@code CompletableFuture} delivering the resource.  */ private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(final Supplier<CompletableFuture<A>> resourceFutureSupplier) {     return pollResourceAsync(resourceFutureSupplier, new CompletableFuture<>(), 0). }
false;private;3;21;;private <R, A extends AsynchronouslyCreatedResource<R>> CompletableFuture<R> pollResourceAsync(final Supplier<CompletableFuture<A>> resourceFutureSupplier, final CompletableFuture<R> resultFuture, final long attempt) {     resourceFutureSupplier.get().whenComplete((asynchronouslyCreatedResource, throwable) -> {         if (throwable != null) {             resultFuture.completeExceptionally(throwable).         } else {             if (asynchronouslyCreatedResource.queueStatus().getId() == QueueStatus.Id.COMPLETED) {                 resultFuture.complete(asynchronouslyCreatedResource.resource()).             } else {                 retryExecutorService.schedule(() -> {                     pollResourceAsync(resourceFutureSupplier, resultFuture, attempt + 1).                 }, waitStrategy.sleepTime(attempt), TimeUnit.MILLISECONDS).             }         }     }).     return resultFuture. }
false;public;1;4;;// ====================================== // Legacy stuff we actually implement // ====================================== @Override public boolean hasUserJarsInClassPath(List<URL> userJarFiles) {     return false. }
false;public;0;4;;@Override public void waitForClusterToBeReady() { // no op }
false;public;0;11;;@Override public String getWebInterfaceURL() {     try {         return getWebMonitorBaseUrl().get().toString().     } catch (InterruptedException | ExecutionException e) {         ExceptionUtils.checkInterrupted(e).         log.warn("Could not retrieve the web interface URL for the cluster.", e).         return "Unknown address.".     } }
false;public;0;4;;@Override public GetClusterStatusResponse getClusterStatus() {     return null. }
false;public;0;4;;@Override public List<String> getNewMessages() {     return Collections.emptyList(). }
false;public;0;4;;@Override public int getMaxSlots() {     return MAX_SLOTS_UNKNOWN. }
false;private;2;4;;// ------------------------------------------------------------------------- // RestClient Helper // ------------------------------------------------------------------------- private <M extends MessageHeaders<EmptyRequestBody, P, U>, U extends MessageParameters, P extends ResponseBody> CompletableFuture<P> sendRequest(M messageHeaders, U messageParameters) {     return sendRequest(messageHeaders, messageParameters, EmptyRequestBody.getInstance()). }
false;private;2;4;;private <M extends MessageHeaders<R, P, EmptyMessageParameters>, R extends RequestBody, P extends ResponseBody> CompletableFuture<P> sendRequest(M messageHeaders, R request) {     return sendRequest(messageHeaders, EmptyMessageParameters.getInstance(), request). }
false;;1;5;;@VisibleForTesting <M extends MessageHeaders<EmptyRequestBody, P, EmptyMessageParameters>, P extends ResponseBody> CompletableFuture<P> sendRequest(M messageHeaders) {     return sendRequest(messageHeaders, EmptyMessageParameters.getInstance(), EmptyRequestBody.getInstance()). }
false;public;3;6;;@VisibleForTesting public <M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P> sendRequest(M messageHeaders, U messageParameters, R request) {     return sendRetriableRequest(messageHeaders, messageParameters, request, isConnectionProblemOrServiceUnavailable()). }
false;private;4;4;;private <M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P> sendRetriableRequest(M messageHeaders, U messageParameters, R request, Predicate<Throwable> retryPredicate) {     return sendRetriableRequest(messageHeaders, messageParameters, request, Collections.emptyList(), retryPredicate). }
false;private;5;10;;private <M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P> sendRetriableRequest(M messageHeaders, U messageParameters, R request, Collection<FileUpload> filesToUpload, Predicate<Throwable> retryPredicate) {     return retry(() -> getWebMonitorBaseUrl().thenCompose(webMonitorBaseUrl -> {         try {             return restClient.sendRequest(webMonitorBaseUrl.getHost(), webMonitorBaseUrl.getPort(), messageHeaders, messageParameters, request, filesToUpload).         } catch (IOException e) {             throw new CompletionException(e).         }     }), retryPredicate). }
false;private;2;10;;private <C> CompletableFuture<C> retry(CheckedSupplier<CompletableFuture<C>> operation, Predicate<Throwable> retryPredicate) {     return FutureUtils.retryWithDelay(CheckedSupplier.unchecked(operation), restClusterClientConfiguration.getRetryMaxAttempts(), Time.milliseconds(restClusterClientConfiguration.getRetryDelay()), retryPredicate, new ScheduledExecutorServiceAdapter(retryExecutorService)). }
false;private,static;0;3;;private static Predicate<Throwable> isConnectionProblemOrServiceUnavailable() {     return isConnectionProblemException().or(isServiceUnavailable()). }
false;private,static;0;7;;private static Predicate<Throwable> isConnectionProblemException() {     return (throwable) -> ExceptionUtils.findThrowable(throwable, java.net.ConnectException.class).isPresent() || ExceptionUtils.findThrowable(throwable, java.net.SocketTimeoutException.class).isPresent() || ExceptionUtils.findThrowable(throwable, ConnectTimeoutException.class).isPresent() || ExceptionUtils.findThrowable(throwable, IOException.class).isPresent(). }
false;private,static;0;3;;private static Predicate<Throwable> isServiceUnavailable() {     return httpExceptionCodePredicate(code -> code == HttpResponseStatus.SERVICE_UNAVAILABLE.code()). }
false;private,static;1;8;;private static Predicate<Throwable> httpExceptionCodePredicate(Predicate<Integer> statusCodePredicate) {     return (throwable) -> ExceptionUtils.findThrowable(throwable, RestClientException.class).map(restClientException -> {         final int code = restClientException.getHttpResponseStatus().code().         return statusCodePredicate.test(code).     }).orElse(false). }
false;;0;15;;@VisibleForTesting CompletableFuture<URL> getWebMonitorBaseUrl() {     return FutureUtils.orTimeout(webMonitorLeaderRetriever.getLeaderFuture(), restClusterClientConfiguration.getAwaitLeaderTimeout(), TimeUnit.MILLISECONDS).thenApplyAsync(leaderAddressSessionId -> {         final String url = leaderAddressSessionId.f0.         try {             return new URL(url).         } catch (MalformedURLException e) {             throw new IllegalArgumentException("Could not parse URL from " + url, e).         }     }, executorService). }
