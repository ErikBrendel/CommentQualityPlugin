commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setSavepointRestoreSettings(SavepointRestoreSettings savepointSettings) {     this.savepointSettings = savepointSettings. }
false;public;0;3;;public SavepointRestoreSettings getSavepointSettings() {     return savepointSettings. }
false;public;0;3;;public String[] getArguments() {     return this.args. }
false;public;0;3;;public String getMainClassName() {     return this.mainClass.getName(). }
false;public;0;3;;public boolean isUsingInteractiveMode() {     return this.program == null. }
false;public;0;3;;public boolean isUsingProgramEntryPoint() {     return this.program != null. }
true;public;0;8;/**  * Returns the plan without the required jars when the files are already provided by the cluster.  *  * @return The plan without attached jar files.  * @throws ProgramInvocationException  */ ;/**  * Returns the plan without the required jars when the files are already provided by the cluster.  *  * @return The plan without attached jar files.  * @throws ProgramInvocationException  */ public JobWithJars getPlanWithoutJars() throws ProgramInvocationException {     if (isUsingProgramEntryPoint()) {         return new JobWithJars(getPlan(), Collections.<URL>emptyList(), classpaths, userCodeClassLoader).     } else {         throw new ProgramInvocationException("Cannot create a " + JobWithJars.class.getSimpleName() + " for a program that is using the interactive mode.", getPlan().getJobId()).     } }
true;public;0;8;/**  * Returns the plan with all required jars.  *  * @return The plan with attached jar files.  * @throws ProgramInvocationException  */ ;/**  * Returns the plan with all required jars.  *  * @return The plan with attached jar files.  * @throws ProgramInvocationException  */ public JobWithJars getPlanWithJars() throws ProgramInvocationException {     if (isUsingProgramEntryPoint()) {         return new JobWithJars(getPlan(), getAllLibraries(), classpaths, userCodeClassLoader).     } else {         throw new ProgramInvocationException("Cannot create a " + JobWithJars.class.getSimpleName() + " for a program that is using the interactive mode.", getPlan().getJobId()).     } }
true;public;0;51;/**  * Returns the analyzed plan without any optimizations.  *  * @return  *         the analyzed plan without any optimizations.  * @throws ProgramInvocationException Thrown if an error occurred in the  *  user-provided pact assembler. This may indicate  *         missing parameters for generation.  */ ;/**  * Returns the analyzed plan without any optimizations.  *  * @return  *         the analyzed plan without any optimizations.  * @throws ProgramInvocationException Thrown if an error occurred in the  *  user-provided pact assembler. This may indicate  *         missing parameters for generation.  */ public String getPreviewPlan() throws ProgramInvocationException {     Thread.currentThread().setContextClassLoader(this.getUserCodeClassLoader()).     List<DataSinkNode> previewPlan.     if (isUsingProgramEntryPoint()) {         previewPlan = Optimizer.createPreOptimizedPlan(getPlan()).     } else if (isUsingInteractiveMode()) {         // temporary hack to support the web client         PreviewPlanEnvironment env = new PreviewPlanEnvironment().         env.setAsContext().         try {             invokeInteractiveModeForExecution().         } catch (ProgramInvocationException e) {             throw e.         } catch (Throwable t) {             // the invocation gets aborted with the preview plan             if (env.previewPlan == null) {                 if (env.preview != null) {                     return env.preview.                 } else {                     throw new ProgramInvocationException("The program caused an error: ", getPlan().getJobId(), t).                 }             }         } finally {             env.unsetAsContext().         }         if (env.previewPlan != null) {             previewPlan = env.previewPlan.         } else {             throw new ProgramInvocationException("The program plan could not be fetched. The program silently swallowed the control flow exceptions.", getPlan().getJobId()).         }     } else {         throw new RuntimeException().     }     PlanJSONDumpGenerator jsonGen = new PlanJSONDumpGenerator().     StringWriter string = new StringWriter(1024).     try (PrintWriter pw = new PrintWriter(string)) {         jsonGen.dumpPactPlanAsJSON(previewPlan, pw).     }     return string.toString(). }
true;public;0;28;/**  * Returns the description provided by the Program class. This  * may contain a description of the plan itself and its arguments.  *  * @return The description of the PactProgram's input parameters.  * @throws ProgramInvocationException  *         This invocation is thrown if the Program can't be properly loaded. Causes  *         may be a missing / wrong class or manifest files.  */ ;/**  * Returns the description provided by the Program class. This  * may contain a description of the plan itself and its arguments.  *  * @return The description of the PactProgram's input parameters.  * @throws ProgramInvocationException  *         This invocation is thrown if the Program can't be properly loaded. Causes  *         may be a missing / wrong class or manifest files.  */ @Nullable public String getDescription() throws ProgramInvocationException {     if (ProgramDescription.class.isAssignableFrom(this.mainClass)) {         ProgramDescription descr.         if (this.program != null) {             descr = (ProgramDescription) this.program.         } else {             try {                 descr = InstantiationUtil.instantiate(this.mainClass.asSubclass(ProgramDescription.class), ProgramDescription.class).             } catch (Throwable t) {                 return null.             }         }         try {             return descr.getDescription().         } catch (Throwable t) {             throw new ProgramInvocationException("Error while getting the program description" + (t.getMessage() == null ? "." : ": " + t.getMessage()), t).         }     } else {         return null.     } }
true;public;0;7;/**  * This method assumes that the context environment is prepared, or the execution  * will be a local execution by default.  */ ;/**  * This method assumes that the context environment is prepared, or the execution  * will be a local execution by default.  */ public void invokeInteractiveModeForExecution() throws ProgramInvocationException {     if (isUsingInteractiveMode()) {         callMainMethod(mainClass, args).     } else {         throw new ProgramInvocationException("Cannot invoke a plan-based program directly.").     } }
true;public;0;3;/**  * Returns the classpaths that are required by the program.  *  * @return List of {@link java.net.URL}s.  */ ;/**  * Returns the classpaths that are required by the program.  *  * @return List of {@link java.net.URL}s.  */ public List<URL> getClasspaths() {     return this.classpaths. }
true;public;0;3;/**  * Gets the {@link java.lang.ClassLoader} that must be used to load user code classes.  *  * @return The user code ClassLoader.  */ ;/**  * Gets the {@link java.lang.ClassLoader} that must be used to load user code classes.  *  * @return The user code ClassLoader.  */ public ClassLoader getUserCodeClassLoader() {     return this.userCodeClassLoader. }
true;public;0;17;/**  * Returns all provided libraries needed to run the program.  */ ;/**  * Returns all provided libraries needed to run the program.  */ public List<URL> getAllLibraries() {     List<URL> libs = new ArrayList<URL>(this.extractedTempLibraries.size() + 1).     if (jarFile != null) {         libs.add(jarFile).     }     for (File tmpLib : this.extractedTempLibraries) {         try {             libs.add(tmpLib.getAbsoluteFile().toURI().toURL()).         } catch (MalformedURLException e) {             throw new RuntimeException("URL is invalid. This should not happen.", e).         }     }     return libs. }
true;public;0;4;/**  * Deletes all temporary files created for contained packaged libraries.  */ ;/**  * Deletes all temporary files created for contained packaged libraries.  */ public void deleteExtractedLibraries() {     deleteExtractedLibraries(this.extractedTempLibraries).     this.extractedTempLibraries.clear(). }
true;private;0;8;/**  * Returns the plan as generated from the Pact Assembler.  *  * @return The program's plan.  * @throws ProgramInvocationException Thrown, if an error occurred in the program while  *         creating the program's {@link Plan}.  */ ;/**  * Returns the plan as generated from the Pact Assembler.  *  * @return The program's plan.  * @throws ProgramInvocationException Thrown, if an error occurred in the program while  *         creating the program's {@link Plan}.  */ private Plan getPlan() throws ProgramInvocationException {     if (this.plan == null) {         Thread.currentThread().setContextClassLoader(this.userCodeClassLoader).         this.plan = createPlanFromProgram(this.program, this.args).     }     return this.plan. }
false;private,static;1;14;;private static boolean hasMainMethod(Class<?> entryClass) {     Method mainMethod.     try {         mainMethod = entryClass.getMethod("main", String[].class).     } catch (NoSuchMethodException e) {         return false.     } catch (Throwable t) {         throw new RuntimeException("Could not look up the main(String[]) method from the class " + entryClass.getName() + ": " + t.getMessage(), t).     }     return Modifier.isStatic(mainMethod.getModifiers()) && Modifier.isPublic(mainMethod.getModifiers()). }
false;private,static;2;48;;private static void callMainMethod(Class<?> entryClass, String[] args) throws ProgramInvocationException {     Method mainMethod.     if (!Modifier.isPublic(entryClass.getModifiers())) {         throw new ProgramInvocationException("The class " + entryClass.getName() + " must be public.").     }     try {         mainMethod = entryClass.getMethod("main", String[].class).     } catch (NoSuchMethodException e) {         throw new ProgramInvocationException("The class " + entryClass.getName() + " has no main(String[]) method.").     } catch (Throwable t) {         throw new ProgramInvocationException("Could not look up the main(String[]) method from the class " + entryClass.getName() + ": " + t.getMessage(), t).     }     if (!Modifier.isStatic(mainMethod.getModifiers())) {         throw new ProgramInvocationException("The class " + entryClass.getName() + " declares a non-static main method.").     }     if (!Modifier.isPublic(mainMethod.getModifiers())) {         throw new ProgramInvocationException("The class " + entryClass.getName() + " declares a non-public main method.").     }     try {         mainMethod.invoke(null, (Object) args).     } catch (IllegalArgumentException e) {         throw new ProgramInvocationException("Could not invoke the main method, arguments are not matching.", e).     } catch (IllegalAccessException e) {         throw new ProgramInvocationException("Access to the main method was denied: " + e.getMessage(), e).     } catch (InvocationTargetException e) {         Throwable exceptionInMethod = e.getTargetException().         if (exceptionInMethod instanceof Error) {             throw (Error) exceptionInMethod.         } else if (exceptionInMethod instanceof ProgramParametrizationException) {             throw (ProgramParametrizationException) exceptionInMethod.         } else if (exceptionInMethod instanceof ProgramInvocationException) {             throw (ProgramInvocationException) exceptionInMethod.         } else {             throw new ProgramInvocationException("The main method caused an error: " + exceptionInMethod.getMessage(), exceptionInMethod).         }     } catch (Throwable t) {         throw new ProgramInvocationException("An error occurred while invoking the program's main method: " + t.getMessage(), t).     } }
false;private,static;1;54;;private static String getEntryPointClassNameFromJar(URL jarFile) throws ProgramInvocationException {     JarFile jar.     Manifest manifest.     String className.     // Open jar file     try {         jar = new JarFile(new File(jarFile.toURI())).     } catch (URISyntaxException use) {         throw new ProgramInvocationException("Invalid file path '" + jarFile.getPath() + "'", use).     } catch (IOException ioex) {         throw new ProgramInvocationException("Error while opening jar file '" + jarFile.getPath() + "'. " + ioex.getMessage(), ioex).     }     // jar file must be closed at the end     try {         // Read from jar manifest         try {             manifest = jar.getManifest().         } catch (IOException ioex) {             throw new ProgramInvocationException("The Manifest in the jar file could not be accessed '" + jarFile.getPath() + "'. " + ioex.getMessage(), ioex).         }         if (manifest == null) {             throw new ProgramInvocationException("No manifest found in jar file '" + jarFile.getPath() + "'. The manifest is need to point to the program's main class.").         }         Attributes attributes = manifest.getMainAttributes().         // check for a "program-class" entry first         className = attributes.getValue(PackagedProgram.MANIFEST_ATTRIBUTE_ASSEMBLER_CLASS).         if (className != null) {             return className.         }         // check for a main class         className = attributes.getValue(PackagedProgram.MANIFEST_ATTRIBUTE_MAIN_CLASS).         if (className != null) {             return className.         } else {             throw new ProgramInvocationException("Neither a '" + MANIFEST_ATTRIBUTE_MAIN_CLASS + "', nor a '" + MANIFEST_ATTRIBUTE_ASSEMBLER_CLASS + "' entry was found in the jar file.").         }     } finally {         try {             jar.close().         } catch (Throwable t) {             throw new ProgramInvocationException("Could not close the JAR file: " + t.getMessage(), t).         }     } }
false;private,static;2;28;;private static Class<?> loadMainClass(String className, ClassLoader cl) throws ProgramInvocationException {     ClassLoader contextCl = null.     try {         contextCl = Thread.currentThread().getContextClassLoader().         Thread.currentThread().setContextClassLoader(cl).         return Class.forName(className, false, cl).     } catch (ClassNotFoundException e) {         throw new ProgramInvocationException("The program's entry point class '" + className + "' was not found in the jar file.", e).     } catch (ExceptionInInitializerError e) {         throw new ProgramInvocationException("The program's entry point class '" + className + "' threw an error during initialization.", e).     } catch (LinkageError e) {         throw new ProgramInvocationException("The program's entry point class '" + className + "' could not be loaded due to a linkage failure.", e).     } catch (Throwable t) {         throw new ProgramInvocationException("The program's entry point class '" + className + "' caused an exception during initialization: " + t.getMessage(), t).     } finally {         if (contextCl != null) {             Thread.currentThread().setContextClassLoader(contextCl).         }     } }
true;private,static;2;7;/**  * Takes the jar described by the given file and invokes its pact assembler class to  * assemble a plan. The assembler class name is either passed through a parameter,  * or it is read from the manifest of the jar. The assembler is handed the given options  * for its assembly.  *  * @param program The program to create the plan for.  * @param options  *        The options for the assembler.  * @return The plan created by the program.  * @throws ProgramInvocationException  *         Thrown, if an error occurred in the user-provided pact assembler.  */ ;/**  * Takes the jar described by the given file and invokes its pact assembler class to  * assemble a plan. The assembler class name is either passed through a parameter,  * or it is read from the manifest of the jar. The assembler is handed the given options  * for its assembly.  *  * @param program The program to create the plan for.  * @param options  *        The options for the assembler.  * @return The plan created by the program.  * @throws ProgramInvocationException  *         Thrown, if an error occurred in the user-provided pact assembler.  */ private static Plan createPlanFromProgram(Program program, String[] options) throws ProgramInvocationException {     try {         return program.getPlan(options).     } catch (Throwable t) {         throw new ProgramInvocationException("Error while calling the program: " + t.getMessage(), t).     } }
true;public,static;1;99;/**  * Takes all JAR files that are contained in this program's JAR file and extracts them  * to the system's temp directory.  *  * @return The file names of the extracted temporary files.  * @throws ProgramInvocationException Thrown, if the extraction process failed.  */ ;/**  * Takes all JAR files that are contained in this program's JAR file and extracts them  * to the system's temp directory.  *  * @return The file names of the extracted temporary files.  * @throws ProgramInvocationException Thrown, if the extraction process failed.  */ public static List<File> extractContainedLibraries(URL jarFile) throws ProgramInvocationException {     Random rnd = new Random().     JarFile jar = null.     try {         jar = new JarFile(new File(jarFile.toURI())).         final List<JarEntry> containedJarFileEntries = new ArrayList<JarEntry>().         Enumeration<JarEntry> entries = jar.entries().         while (entries.hasMoreElements()) {             JarEntry entry = entries.nextElement().             String name = entry.getName().             if (name.length() > 8 && name.startsWith("lib/") && name.endsWith(".jar")) {                 containedJarFileEntries.add(entry).             }         }         if (containedJarFileEntries.isEmpty()) {             return Collections.emptyList().         } else {             // go over all contained jar files             final List<File> extractedTempLibraries = new ArrayList<File>(containedJarFileEntries.size()).             final byte[] buffer = new byte[4096].             boolean incomplete = true.             try {                 for (int i = 0. i < containedJarFileEntries.size(). i++) {                     final JarEntry entry = containedJarFileEntries.get(i).                     String name = entry.getName().                     // '/' as in case of zip, jar                     // java.util.zip.ZipEntry#isDirectory always looks only for '/' not for File.separator                     name = name.replace('/', '_').                     File tempFile.                     try {                         tempFile = File.createTempFile(rnd.nextInt(Integer.MAX_VALUE) + "_", name).                         tempFile.deleteOnExit().                     } catch (IOException e) {                         throw new ProgramInvocationException("An I/O error occurred while creating temporary file to extract nested library '" + entry.getName() + "'.", e).                     }                     extractedTempLibraries.add(tempFile).                     // copy the temp file contents to a temporary File                     OutputStream out = null.                     InputStream in = null.                     try {                         out = new FileOutputStream(tempFile).                         in = new BufferedInputStream(jar.getInputStream(entry)).                         int numRead = 0.                         while ((numRead = in.read(buffer)) != -1) {                             out.write(buffer, 0, numRead).                         }                     } catch (IOException e) {                         throw new ProgramInvocationException("An I/O error occurred while extracting nested library '" + entry.getName() + "' to temporary file '" + tempFile.getAbsolutePath() + "'.").                     } finally {                         if (out != null) {                             out.close().                         }                         if (in != null) {                             in.close().                         }                     }                 }                 incomplete = false.             } finally {                 if (incomplete) {                     deleteExtractedLibraries(extractedTempLibraries).                 }             }             return extractedTempLibraries.         }     } catch (Throwable t) {         throw new ProgramInvocationException("Unknown I/O error while extracting contained jar files.", t).     } finally {         if (jar != null) {             try {                 jar.close().             } catch (Throwable t) {             }         }     } }
false;public,static;1;5;;public static void deleteExtractedLibraries(List<File> tempLibraries) {     for (File f : tempLibraries) {         f.delete().     } }
false;private,static;1;11;;private static void checkJarFile(URL jarfile) throws ProgramInvocationException {     try {         JobWithJars.checkJarFile(jarfile).     } catch (IOException e) {         throw new ProgramInvocationException(e.getMessage()).     } catch (Throwable t) {         throw new ProgramInvocationException("Cannot access jar file" + (t.getMessage() == null ? "." : ": " + t.getMessage()), t).     } }
