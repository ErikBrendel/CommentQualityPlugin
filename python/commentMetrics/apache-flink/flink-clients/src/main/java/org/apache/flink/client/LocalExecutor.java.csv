commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// ------------------------------------------------------------------------ // Configuration // ------------------------------------------------------------------------ public boolean isDefaultOverwriteFiles() {     return defaultOverwriteFiles. }
false;public;1;3;;public void setDefaultOverwriteFiles(boolean defaultOverwriteFiles) {     this.defaultOverwriteFiles = defaultOverwriteFiles. }
false;public;1;3;;public void setTaskManagerNumSlots(int taskManagerNumSlots) {     this.taskManagerNumSlots = taskManagerNumSlots. }
false;public;0;3;;public int getTaskManagerNumSlots() {     return this.taskManagerNumSlots. }
false;public;0;14;;// -------------------------------------------------------------------------------------------- @Override public void start() throws Exception {     synchronized (lock) {         if (jobExecutorService == null) {             // create the embedded runtime             jobExecutorServiceConfiguration = createConfiguration().             // start it up             jobExecutorService = createJobExecutorService(jobExecutorServiceConfiguration).         } else {             throw new IllegalStateException("The local executor was already started.").         }     } }
false;private;1;24;;private JobExecutorService createJobExecutorService(Configuration configuration) throws Exception {     if (!configuration.contains(RestOptions.BIND_PORT)) {         configuration.setString(RestOptions.BIND_PORT, "0").     }     final MiniClusterConfiguration miniClusterConfiguration = new MiniClusterConfiguration.Builder().setConfiguration(configuration).setNumTaskManagers(configuration.getInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, ConfigConstants.DEFAULT_LOCAL_NUMBER_TASK_MANAGER)).setRpcServiceSharing(RpcServiceSharing.SHARED).setNumSlotsPerTaskManager(configuration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, 1)).build().     final MiniCluster miniCluster = new MiniCluster(miniClusterConfiguration).     miniCluster.start().     configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().get().getPort()).     return miniCluster. }
false;public;0;9;;@Override public void stop() throws Exception {     synchronized (lock) {         if (jobExecutorService != null) {             jobExecutorService.close().             jobExecutorService = null.         }     } }
false;public;0;6;;@Override public boolean isRunning() {     synchronized (lock) {         return jobExecutorService != null.     } }
true;public;1;51;/**  * Executes the given program on a local runtime and waits for the job to finish.  *  * <p>If the executor has not been started before, this starts the executor and shuts it down  * after the job finished. If the job runs in session mode, the executor is kept alive until  * no more references to the executor exist.</p>  *  * @param plan The plan of the program to execute.  * @return The net runtime of the program, in milliseconds.  *  * @throws Exception Thrown, if either the startup of the local execution context, or the execution  *                   caused an exception.  */ ;/**  * Executes the given program on a local runtime and waits for the job to finish.  *  * <p>If the executor has not been started before, this starts the executor and shuts it down  * after the job finished. If the job runs in session mode, the executor is kept alive until  * no more references to the executor exist.</p>  *  * @param plan The plan of the program to execute.  * @return The net runtime of the program, in milliseconds.  *  * @throws Exception Thrown, if either the startup of the local execution context, or the execution  *                   caused an exception.  */ @Override public JobExecutionResult executePlan(Plan plan) throws Exception {     if (plan == null) {         throw new IllegalArgumentException("The plan may not be null.").     }     synchronized (this.lock) {         // check if we start a session dedicated for this execution         final boolean shutDownAtEnd.         if (jobExecutorService == null) {             shutDownAtEnd = true.             // configure the number of local slots equal to the parallelism of the local plan             if (this.taskManagerNumSlots == DEFAULT_TASK_MANAGER_NUM_SLOTS) {                 int maxParallelism = plan.getMaximumParallelism().                 if (maxParallelism > 0) {                     this.taskManagerNumSlots = maxParallelism.                 }             }             // start the cluster for us             start().         } else {             // we use the existing session             shutDownAtEnd = false.         }         try {             // TODO: Set job's default parallelism to max number of slots             final int slotsPerTaskManager = jobExecutorServiceConfiguration.getInteger(TaskManagerOptions.NUM_TASK_SLOTS, taskManagerNumSlots).             final int numTaskManagers = jobExecutorServiceConfiguration.getInteger(ConfigConstants.LOCAL_NUMBER_TASK_MANAGER, 1).             plan.setDefaultParallelism(slotsPerTaskManager * numTaskManagers).             Optimizer pc = new Optimizer(new DataStatistics(), jobExecutorServiceConfiguration).             OptimizedPlan op = pc.compile(plan).             JobGraphGenerator jgg = new JobGraphGenerator(jobExecutorServiceConfiguration).             JobGraph jobGraph = jgg.compileJobGraph(op, plan.getJobId()).             return jobExecutorService.executeJobBlocking(jobGraph).         } finally {             if (shutDownAtEnd) {                 stop().             }         }     } }
true;public;1;10;/**  * Creates a JSON representation of the given dataflow's execution plan.  *  * @param plan The dataflow plan.  * @return The dataflow's execution plan, as a JSON string.  * @throws Exception Thrown, if the optimization process that creates the execution plan failed.  */ ;/**  * Creates a JSON representation of the given dataflow's execution plan.  *  * @param plan The dataflow plan.  * @return The dataflow's execution plan, as a JSON string.  * @throws Exception Thrown, if the optimization process that creates the execution plan failed.  */ @Override public String getOptimizerPlanAsJSON(Plan plan) throws Exception {     final int parallelism = plan.getDefaultParallelism() == ExecutionConfig.PARALLELISM_DEFAULT ? 1 : plan.getDefaultParallelism().     Optimizer pc = new Optimizer(new DataStatistics(), this.baseConfiguration).     pc.setDefaultParallelism(parallelism).     OptimizedPlan op = pc.compile(plan).     return new PlanJSONDumpGenerator().getOptimizerPlanAsJSON(op). }
false;public;1;4;;@Override public void endSession(JobID jobID) throws Exception { // no op }
false;private;0;9;;private Configuration createConfiguration() {     Configuration newConfiguration = new Configuration().     newConfiguration.setInteger(TaskManagerOptions.NUM_TASK_SLOTS, getTaskManagerNumSlots()).     newConfiguration.setBoolean(CoreOptions.FILESYTEM_DEFAULT_OVERRIDE, isDefaultOverwriteFiles()).     newConfiguration.addAll(baseConfiguration).     return newConfiguration. }
true;public,static;2;3;/**  * Executes the given program.  *  * @param pa The program.  * @param args The parameters.  * @return The execution result of the program.  *  * @throws Exception Thrown, if either the startup of the local execution context, or the execution  *                   caused an exception.  */ ;// -------------------------------------------------------------------------------------------- // Static variants that internally bring up an instance and shut it down after the execution // -------------------------------------------------------------------------------------------- /**  * Executes the given program.  *  * @param pa The program.  * @param args The parameters.  * @return The execution result of the program.  *  * @throws Exception Thrown, if either the startup of the local execution context, or the execution  *                   caused an exception.  */ public static JobExecutionResult execute(Program pa, String... args) throws Exception {     return execute(pa.getPlan(args)). }
true;public,static;1;3;/**  * Executes the given dataflow plan.  *  * @param plan The dataflow plan.  * @return The execution result.  *  * @throws Exception Thrown, if either the startup of the local execution context, or the execution  *                   caused an exception.  */ ;/**  * Executes the given dataflow plan.  *  * @param plan The dataflow plan.  * @return The execution result.  *  * @throws Exception Thrown, if either the startup of the local execution context, or the execution  *                   caused an exception.  */ public static JobExecutionResult execute(Plan plan) throws Exception {     return new LocalExecutor().executePlan(plan). }
true;public,static;1;9;/**  * Creates a JSON representation of the given dataflow's execution plan.  *  * @param plan The dataflow plan.  * @return The dataflow's execution plan, as a JSON string.  * @throws Exception Thrown, if the optimization process that creates the execution plan failed.  */ ;/**  * Creates a JSON representation of the given dataflow's execution plan.  *  * @param plan The dataflow plan.  * @return The dataflow's execution plan, as a JSON string.  * @throws Exception Thrown, if the optimization process that creates the execution plan failed.  */ public static String optimizerPlanAsJSON(Plan plan) throws Exception {     final int parallelism = plan.getDefaultParallelism() == ExecutionConfig.PARALLELISM_DEFAULT ? 1 : plan.getDefaultParallelism().     Optimizer pc = new Optimizer(new DataStatistics(), new Configuration()).     pc.setDefaultParallelism(parallelism).     OptimizedPlan op = pc.compile(plan).     return new PlanJSONDumpGenerator().getOptimizerPlanAsJSON(op). }
true;public,static;1;4;/**  * Creates a JSON representation of the given dataflow plan.  *  * @param plan The dataflow plan.  * @return The dataflow plan (prior to optimization) as a JSON string.  */ ;/**  * Creates a JSON representation of the given dataflow plan.  *  * @param plan The dataflow plan.  * @return The dataflow plan (prior to optimization) as a JSON string.  */ public static String getPlanAsJSON(Plan plan) {     List<DataSinkNode> sinks = Optimizer.createPreOptimizedPlan(plan).     return new PlanJSONDumpGenerator().getPactPlanAsJSON(sinks). }
