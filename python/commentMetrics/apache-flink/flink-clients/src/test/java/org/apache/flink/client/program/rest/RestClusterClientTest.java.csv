commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Before public void setUp() throws Exception {     restServerEndpointConfiguration = RestServerEndpointConfiguration.fromConfiguration(restConfig).     mockGatewayRetriever = () -> CompletableFuture.completedFuture(mockRestfulGateway).     executor = Executors.newSingleThreadExecutor(new ExecutorThreadFactory(RestClusterClientTest.class.getSimpleName())).     jobGraph = new JobGraph("testjob").     jobId = jobGraph.getJobID(). }
false;public;0;6;;@After public void tearDown() {     if (executor != null) {         executor.shutdown().     } }
false;private;1;10;;private RestClusterClient<StandaloneClusterId> createRestClusterClient(final int port) throws Exception {     final Configuration clientConfig = new Configuration(restConfig).     clientConfig.setInteger(RestOptions.PORT, port).     return new RestClusterClient<>(clientConfig, createRestClient(), StandaloneClusterId.getInstance(), (attempt) -> 0, null). }
false;public;6;15;;@Override public <M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P> sendRequest(final String targetAddress, final int targetPort, final M messageHeaders, final U messageParameters, final R request, final Collection<FileUpload> files) throws IOException {     if (failHttpRequest.test(messageHeaders, messageParameters, request)) {         return FutureUtils.completedExceptionally(new IOException("expected")).     } else {         return super.sendRequest(targetAddress, targetPort, messageHeaders, messageParameters, request, files).     } }
false;private;0;20;;@Nonnull private RestClient createRestClient() throws ConfigurationException {     return new RestClient(RestClientConfiguration.fromConfiguration(restConfig), executor) {          @Override         public <M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P> sendRequest(final String targetAddress, final int targetPort, final M messageHeaders, final U messageParameters, final R request, final Collection<FileUpload> files) throws IOException {             if (failHttpRequest.test(messageHeaders, messageParameters, request)) {                 return FutureUtils.completedExceptionally(new IOException("expected")).             } else {                 return super.sendRequest(targetAddress, targetPort, messageHeaders, messageParameters, request, files).             }         }     }. }
false;public;0;35;;@Test public void testJobSubmitCancelStop() throws Exception {     TestJobSubmitHandler submitHandler = new TestJobSubmitHandler().     TestJobTerminationHandler terminationHandler = new TestJobTerminationHandler().     TestJobExecutionResultHandler testJobExecutionResultHandler = new TestJobExecutionResultHandler(JobExecutionResultResponseBody.created(new JobResult.Builder().applicationStatus(ApplicationStatus.SUCCEEDED).jobId(jobId).netRuntime(Long.MAX_VALUE).build())).     try (TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(submitHandler, terminationHandler, testJobExecutionResultHandler)) {         RestClusterClient<?> restClusterClient = createRestClusterClient(restServerEndpoint.getServerAddress().getPort()).         try {             Assert.assertFalse(submitHandler.jobSubmitted).             restClusterClient.submitJob(jobGraph, ClassLoader.getSystemClassLoader()).             Assert.assertTrue(submitHandler.jobSubmitted).             Assert.assertFalse(terminationHandler.jobCanceled).             restClusterClient.cancel(jobId).             Assert.assertTrue(terminationHandler.jobCanceled).             Assert.assertFalse(terminationHandler.jobStopped).             restClusterClient.stop(jobId).             Assert.assertTrue(terminationHandler.jobStopped).         } finally {             restClusterClient.shutdown().         }     } }
true;public;0;23;/**  * Tests that we can submit a jobGraph in detached mode.  */ ;/**  * Tests that we can submit a jobGraph in detached mode.  */ @Test public void testDetachedJobSubmission() throws Exception {     final TestJobSubmitHandler testJobSubmitHandler = new TestJobSubmitHandler().     try (TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(testJobSubmitHandler)) {         RestClusterClient<?> restClusterClient = createRestClusterClient(restServerEndpoint.getServerAddress().getPort()).         try {             restClusterClient.setDetached(true).             final JobSubmissionResult jobSubmissionResult = restClusterClient.submitJob(jobGraph, ClassLoader.getSystemClassLoader()).             // if the detached mode didn't work, then we would not reach this point because the execution result             // retrieval would have failed.             assertThat(jobSubmissionResult, is(not(instanceOf(JobExecutionResult.class)))).             assertThat(jobSubmissionResult.getJobID(), is(jobId)).         } finally {             restClusterClient.shutdown().         }     } }
false;protected;2;5;;@Override protected CompletableFuture<JobSubmitResponseBody> handleRequest(@Nonnull HandlerRequest<JobSubmitRequestBody, EmptyMessageParameters> request, @Nonnull DispatcherGateway gateway) throws RestHandlerException {     jobSubmitted = true.     return CompletableFuture.completedFuture(new JobSubmitResponseBody("/url")). }
false;protected;2;12;;@Override protected CompletableFuture<EmptyResponseBody> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, JobTerminationMessageParameters> request, @Nonnull DispatcherGateway gateway) throws RestHandlerException {     switch(request.getQueryParameter(TerminationModeQueryParameter.class).get(0)) {         case CANCEL:             jobCanceled = true.             break.         case STOP:             jobStopped = true.             break.     }     return CompletableFuture.completedFuture(EmptyResponseBody.getInstance()). }
false;protected;2;16;;@Override protected CompletableFuture<JobExecutionResultResponseBody> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, JobMessageParameters> request, @Nonnull DispatcherGateway gateway) throws RestHandlerException {     if (jobExecutionResults.hasNext()) {         lastJobExecutionResult = jobExecutionResults.next().     }     checkState(lastJobExecutionResult != null).     if (lastJobExecutionResult instanceof JobExecutionResultResponseBody) {         return CompletableFuture.completedFuture((JobExecutionResultResponseBody) lastJobExecutionResult).     } else if (lastJobExecutionResult instanceof RestHandlerException) {         return FutureUtils.completedExceptionally((RestHandlerException) lastJobExecutionResult).     } else {         throw new AssertionError().     } }
false;public;0;55;;@Test public void testSubmitJobAndWaitForExecutionResult() throws Exception {     final TestJobExecutionResultHandler testJobExecutionResultHandler = new TestJobExecutionResultHandler(new RestHandlerException("should trigger retry", HttpResponseStatus.SERVICE_UNAVAILABLE), JobExecutionResultResponseBody.inProgress(), JobExecutionResultResponseBody.created(new JobResult.Builder().applicationStatus(ApplicationStatus.SUCCEEDED).jobId(jobId).netRuntime(Long.MAX_VALUE).accumulatorResults(Collections.singletonMap("testName", new SerializedValue<>(OptionalFailure.of(1.0)))).build()), JobExecutionResultResponseBody.created(new JobResult.Builder().applicationStatus(ApplicationStatus.FAILED).jobId(jobId).netRuntime(Long.MAX_VALUE).serializedThrowable(new SerializedThrowable(new RuntimeException("expected"))).build())).     // fail first HTTP polling attempt, which should not be a problem because of the retries     final AtomicBoolean firstPollFailed = new AtomicBoolean().     failHttpRequest = (messageHeaders, messageParameters, requestBody) -> messageHeaders instanceof JobExecutionResultHeaders && !firstPollFailed.getAndSet(true).     try (TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(testJobExecutionResultHandler, new TestJobSubmitHandler())) {         RestClusterClient<?> restClusterClient = createRestClusterClient(restServerEndpoint.getServerAddress().getPort()).         try {             JobExecutionResult jobExecutionResult.             jobExecutionResult = (JobExecutionResult) restClusterClient.submitJob(jobGraph, ClassLoader.getSystemClassLoader()).             assertThat(jobExecutionResult.getJobID(), equalTo(jobId)).             assertThat(jobExecutionResult.getNetRuntime(), equalTo(Long.MAX_VALUE)).             assertThat(jobExecutionResult.getAllAccumulatorResults(), equalTo(Collections.singletonMap("testName", 1.0))).             try {                 restClusterClient.submitJob(jobGraph, ClassLoader.getSystemClassLoader()).                 fail("Expected exception not thrown.").             } catch (final ProgramInvocationException e) {                 final Optional<RuntimeException> cause = ExceptionUtils.findThrowable(e, RuntimeException.class).                 assertThat(cause.isPresent(), is(true)).                 assertThat(cause.get().getMessage(), equalTo("expected")).             }         } finally {             restClusterClient.shutdown().         }     } }
false;public;0;48;;@Test public void testDisposeSavepoint() throws Exception {     final String savepointPath = "foobar".     final String exceptionMessage = "Test exception.".     final FlinkException testException = new FlinkException(exceptionMessage).     final TestSavepointDisposalHandlers testSavepointDisposalHandlers = new TestSavepointDisposalHandlers(savepointPath).     final TestSavepointDisposalHandlers.TestSavepointDisposalTriggerHandler testSavepointDisposalTriggerHandler = testSavepointDisposalHandlers.new TestSavepointDisposalTriggerHandler().     final TestSavepointDisposalHandlers.TestSavepointDisposalStatusHandler testSavepointDisposalStatusHandler = testSavepointDisposalHandlers.new TestSavepointDisposalStatusHandler(OptionalFailure.of(AsynchronousOperationInfo.complete()), OptionalFailure.of(AsynchronousOperationInfo.completeExceptional(new SerializedThrowable(testException))), OptionalFailure.ofFailure(testException)).     try (TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(testSavepointDisposalStatusHandler, testSavepointDisposalTriggerHandler)) {         RestClusterClient<?> restClusterClient = createRestClusterClient(restServerEndpoint.getServerAddress().getPort()).         try {             {                 final CompletableFuture<Acknowledge> disposeSavepointFuture = restClusterClient.disposeSavepoint(savepointPath).                 assertThat(disposeSavepointFuture.get(), is(Acknowledge.get())).             }             {                 final CompletableFuture<Acknowledge> disposeSavepointFuture = restClusterClient.disposeSavepoint(savepointPath).                 try {                     disposeSavepointFuture.get().                     fail("Expected an exception").                 } catch (ExecutionException ee) {                     assertThat(ExceptionUtils.findThrowableWithMessage(ee, exceptionMessage).isPresent(), is(true)).                 }             }             {                 try {                     restClusterClient.disposeSavepoint(savepointPath).get().                     fail("Expected an exception.").                 } catch (ExecutionException ee) {                     assertThat(ExceptionUtils.findThrowable(ee, RestClientException.class).isPresent(), is(true)).                 }             }         } finally {             restClusterClient.shutdown().         }     } }
false;protected;2;5;;@Override protected CompletableFuture<TriggerResponse> handleRequest(@Nonnull HandlerRequest<SavepointDisposalRequest, EmptyMessageParameters> request, @Nonnull DispatcherGateway gateway) {     assertThat(request.getRequestBody().getSavepointPath(), is(savepointPath)).     return CompletableFuture.completedFuture(new TriggerResponse(triggerId)). }
false;protected;2;20;;@Override protected CompletableFuture<AsynchronousOperationResult<AsynchronousOperationInfo>> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, SavepointDisposalStatusMessageParameters> request, @Nonnull DispatcherGateway gateway) throws RestHandlerException {     final TriggerId actualTriggerId = request.getPathParameter(TriggerIdPathParameter.class).     if (actualTriggerId.equals(triggerId)) {         final OptionalFailure<AsynchronousOperationInfo> nextResponse = responses.poll().         if (nextResponse != null) {             if (nextResponse.isFailure()) {                 throw new RestHandlerException("Failure", HttpResponseStatus.BAD_REQUEST, nextResponse.getFailureCause()).             } else {                 return CompletableFuture.completedFuture(AsynchronousOperationResult.completed(nextResponse.getUnchecked())).             }         } else {             throw new AssertionError().         }     } else {         throw new AssertionError().     } }
false;public;0;17;;@Test public void testListJobs() throws Exception {     try (TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(new TestListJobsHandler())) {         RestClusterClient<?> restClusterClient = createRestClusterClient(restServerEndpoint.getServerAddress().getPort()).         try {             CompletableFuture<Collection<JobStatusMessage>> jobDetailsFuture = restClusterClient.listJobs().             Collection<JobStatusMessage> jobDetails = jobDetailsFuture.get().             Iterator<JobStatusMessage> jobDetailsIterator = jobDetails.iterator().             JobStatusMessage job1 = jobDetailsIterator.next().             JobStatusMessage job2 = jobDetailsIterator.next().             Assert.assertNotEquals("The job status should not be equal.", job1.getJobState(), job2.getJobState()).         } finally {             restClusterClient.shutdown().         }     } }
false;public;0;23;;@Test public void testGetAccumulators() throws Exception {     TestAccumulatorHandler accumulatorHandler = new TestAccumulatorHandler().     try (TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(accumulatorHandler)) {         RestClusterClient<?> restClusterClient = createRestClusterClient(restServerEndpoint.getServerAddress().getPort()).         try {             JobID id = new JobID().             {                 Map<String, OptionalFailure<Object>> accumulators = restClusterClient.getAccumulators(id).                 assertNotNull(accumulators).                 assertEquals(1, accumulators.size()).                 assertEquals(true, accumulators.containsKey("testKey")).                 assertEquals("testValue", accumulators.get("testKey").get().toString()).             }         } finally {             restClusterClient.shutdown().         }     } }
true;public;0;27;/**  * Tests that command line options override the configuration settings.  */ ;/**  * Tests that command line options override the configuration settings.  */ @Test public void testRESTManualConfigurationOverride() throws Exception {     final String configuredHostname = "localhost".     final int configuredPort = 1234.     final Configuration configuration = new Configuration().     configuration.setString(JobManagerOptions.ADDRESS, configuredHostname).     configuration.setInteger(JobManagerOptions.PORT, configuredPort).     configuration.setString(RestOptions.ADDRESS, configuredHostname).     configuration.setInteger(RestOptions.PORT, configuredPort).     final DefaultCLI defaultCLI = new DefaultCLI(configuration).     final String manualHostname = "123.123.123.123".     final int manualPort = 4321.     final String[] args = { "-m", manualHostname + ':' + manualPort }.     CommandLine commandLine = defaultCLI.parseCommandLineOptions(args, false).     final StandaloneClusterDescriptor clusterDescriptor = defaultCLI.createClusterDescriptor(commandLine).     final RestClusterClient<?> clusterClient = clusterDescriptor.retrieve(defaultCLI.getClusterId(commandLine)).     URL webMonitorBaseUrl = clusterClient.getWebMonitorBaseUrl().get().     assertThat(webMonitorBaseUrl.getHost(), equalTo(manualHostname)).     assertThat(webMonitorBaseUrl.getPort(), equalTo(manualPort)). }
true;public;0;20;/**  * Tests that the send operation is being retried.  */ ;/**  * Tests that the send operation is being retried.  */ @Test public void testRetriableSendOperationIfConnectionErrorOrServiceUnavailable() throws Exception {     final PingRestHandler pingRestHandler = new PingRestHandler(FutureUtils.completedExceptionally(new RestHandlerException("test exception", HttpResponseStatus.SERVICE_UNAVAILABLE)), CompletableFuture.completedFuture(EmptyResponseBody.getInstance())).     try (final TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(pingRestHandler)) {         RestClusterClient<?> restClusterClient = createRestClusterClient(restServerEndpoint.getServerAddress().getPort()).         try {             final AtomicBoolean firstPollFailed = new AtomicBoolean().             failHttpRequest = (messageHeaders, messageParameters, requestBody) -> messageHeaders instanceof PingRestHandlerHeaders && !firstPollFailed.getAndSet(true).             restClusterClient.sendRequest(PingRestHandlerHeaders.INSTANCE).get().         } finally {             restClusterClient.shutdown().         }     } }
false;public;0;14;;@Test public void testJobSubmissionFailureThrowsProgramInvocationException() throws Exception {     try (final TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(new SubmissionFailingHandler())) {         RestClusterClient<?> restClusterClient = createRestClusterClient(restServerEndpoint.getServerAddress().getPort()).         try {             restClusterClient.submitJob(jobGraph, ClassLoader.getSystemClassLoader()).         } catch (final ProgramInvocationException expected) {         // expected         } finally {             restClusterClient.shutdown().         }     } }
false;protected;2;6;;@Override protected CompletableFuture<JobSubmitResponseBody> handleRequest(@Nonnull HandlerRequest<JobSubmitRequestBody, EmptyMessageParameters> request, @Nonnull DispatcherGateway gateway) throws RestHandlerException {     throw new RestHandlerException("expected", HttpResponseStatus.INTERNAL_SERVER_ERROR). }
true;public;0;19;/**  * Tests that the send operation is not being retried when receiving a NOT_FOUND return code.  */ ;/**  * Tests that the send operation is not being retried when receiving a NOT_FOUND return code.  */ @Test public void testSendIsNotRetriableIfHttpNotFound() throws Exception {     final String exceptionMessage = "test exception".     final PingRestHandler pingRestHandler = new PingRestHandler(FutureUtils.completedExceptionally(new RestHandlerException(exceptionMessage, HttpResponseStatus.NOT_FOUND))).     try (final TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(pingRestHandler)) {         RestClusterClient<?> restClusterClient = createRestClusterClient(restServerEndpoint.getServerAddress().getPort()).         try {             restClusterClient.sendRequest(PingRestHandlerHeaders.INSTANCE).get().             fail("The rest request should have failed.").         } catch (Exception e) {             assertThat(ExceptionUtils.findThrowableWithMessage(e, exceptionMessage).isPresent(), is(true)).         } finally {             restClusterClient.shutdown().         }     } }
false;protected;2;10;;@Override protected CompletableFuture<EmptyResponseBody> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, EmptyMessageParameters> request, @Nonnull DispatcherGateway gateway) throws RestHandlerException {     final CompletableFuture<EmptyResponseBody> result = responseQueue.poll().     if (result != null) {         return result.     } else {         return CompletableFuture.completedFuture(EmptyResponseBody.getInstance()).     } }
false;public;0;4;;@Override public Class<EmptyResponseBody> getResponseClass() {     return EmptyResponseBody.class. }
false;public;0;4;;@Override public HttpResponseStatus getResponseStatusCode() {     return HttpResponseStatus.OK. }
false;public;0;4;;@Override public String getDescription() {     return "foobar". }
false;public;0;4;;@Override public Class<EmptyRequestBody> getRequestClass() {     return EmptyRequestBody.class. }
false;public;0;4;;@Override public EmptyMessageParameters getUnresolvedMessageParameters() {     return EmptyMessageParameters.getInstance(). }
false;public;0;4;;@Override public HttpMethodWrapper getHttpMethod() {     return HttpMethodWrapper.GET. }
false;public;0;4;;@Override public String getTargetRestEndpointURL() {     return "/foobar". }
false;protected;2;34;;@Override protected CompletableFuture<JobAccumulatorsInfo> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, JobAccumulatorsMessageParameters> request, @Nonnull DispatcherGateway gateway) throws RestHandlerException {     JobAccumulatorsInfo accumulatorsInfo.     List<Boolean> queryParams = request.getQueryParameter(AccumulatorsIncludeSerializedValueQueryParameter.class).     final boolean includeSerializedValue.     if (!queryParams.isEmpty()) {         includeSerializedValue = queryParams.get(0).     } else {         includeSerializedValue = false.     }     List<JobAccumulatorsInfo.UserTaskAccumulator> userTaskAccumulators = new ArrayList<>(1).     userTaskAccumulators.add(new JobAccumulatorsInfo.UserTaskAccumulator("testName", "testType", "testValue")).     if (includeSerializedValue) {         Map<String, SerializedValue<OptionalFailure<Object>>> serializedUserTaskAccumulators = new HashMap<>(1).         try {             serializedUserTaskAccumulators.put("testKey", new SerializedValue<>(OptionalFailure.of("testValue"))).         } catch (IOException e) {             throw new RuntimeException(e).         }         accumulatorsInfo = new JobAccumulatorsInfo(Collections.emptyList(), userTaskAccumulators, serializedUserTaskAccumulators).     } else {         accumulatorsInfo = new JobAccumulatorsInfo(Collections.emptyList(), userTaskAccumulators, Collections.emptyMap()).     }     return CompletableFuture.completedFuture(accumulatorsInfo). }
false;protected;2;6;;@Override protected CompletableFuture<MultipleJobsDetails> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, EmptyMessageParameters> request, @Nonnull DispatcherGateway gateway) throws RestHandlerException {     JobDetails running = new JobDetails(new JobID(), "job1", 0, 0, 0, JobStatus.RUNNING, 0, new int[9], 0).     JobDetails finished = new JobDetails(new JobID(), "job2", 0, 0, 0, JobStatus.FINISHED, 0, new int[9], 0).     return CompletableFuture.completedFuture(new MultipleJobsDetails(Arrays.asList(running, finished))). }
false;private;1;4;;private TestRestServerEndpoint createRestServerEndpoint(final AbstractRestHandler<?, ?, ?, ?>... abstractRestHandlers) throws Exception {     return TestRestServerEndpoint.createAndStartRestServerEndpoint(restServerEndpointConfiguration, abstractRestHandlers). }
false;;3;1;;boolean test(MessageHeaders<?, ?, ?> messageHeaders, MessageParameters messageParameters, RequestBody requestBody).
false;static;0;3;;static FailHttpRequestPredicate never() {     return ((messageHeaders, messageParameters, requestBody) -> false). }
