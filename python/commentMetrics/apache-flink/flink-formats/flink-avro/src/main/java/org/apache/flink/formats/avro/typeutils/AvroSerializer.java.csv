commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// ------------------------------------------------------------------------ @Nonnull public Class<T> getType() {     return type. }
false;public;0;4;;// ------------------------------------------------------------------------ // Properties // ------------------------------------------------------------------------ @Override public boolean isImmutableType() {     return false. }
false;public;0;4;;@Override public int getLength() {     return -1. }
false;public;0;4;;// ------------------------------------------------------------------------ // Serialization // ------------------------------------------------------------------------ @Override public T createInstance() {     return InstantiationUtil.instantiate(type). }
false;public;2;17;;@Override public void serialize(T value, DataOutputView target) throws IOException {     if (CONCURRENT_ACCESS_CHECK) {         enterExclusiveThread().     }     try {         checkAvroInitialized().         this.encoder.setOut(target).         this.writer.write(value, this.encoder).     } finally {         if (CONCURRENT_ACCESS_CHECK) {             exitExclusiveThread().         }     } }
false;public;1;17;;@Override public T deserialize(DataInputView source) throws IOException {     if (CONCURRENT_ACCESS_CHECK) {         enterExclusiveThread().     }     try {         checkAvroInitialized().         this.decoder.setIn(source).         return this.reader.read(null, this.decoder).     } finally {         if (CONCURRENT_ACCESS_CHECK) {             exitExclusiveThread().         }     } }
false;public;2;17;;@Override public T deserialize(T reuse, DataInputView source) throws IOException {     if (CONCURRENT_ACCESS_CHECK) {         enterExclusiveThread().     }     try {         checkAvroInitialized().         this.decoder.setIn(source).         return this.reader.read(reuse, this.decoder).     } finally {         if (CONCURRENT_ACCESS_CHECK) {             exitExclusiveThread().         }     } }
false;public;1;16;;// ------------------------------------------------------------------------ // Copying // ------------------------------------------------------------------------ @Override public T copy(T from) {     if (CONCURRENT_ACCESS_CHECK) {         enterExclusiveThread().     }     try {         checkAvroInitialized().         return avroData.deepCopy(runtimeSchema, from).     } finally {         if (CONCURRENT_ACCESS_CHECK) {             exitExclusiveThread().         }     } }
false;public;2;4;;@Override public T copy(T from, T reuse) {     return copy(from). }
false;public;2;7;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     // we do not have concurrency checks here, because serialize() and     // deserialize() do the checks and the current concurrency check mechanism     // does provide additional safety in cases of re-entrant calls     serialize(deserialize(source), target). }
false;public;0;8;;// ------------------------------------------------------------------------ // Compatibility and Upgrades // ------------------------------------------------------------------------ @Override public TypeSerializerSnapshot<T> snapshotConfiguration() {     if (configSnapshot == null) {         checkAvroInitialized().         configSnapshot = new AvroSerializerSnapshot<>(runtimeSchema, type).     }     return configSnapshot. }
false;static;1;4;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ static boolean isGenericRecord(Class<?> type) {     return !SpecificRecord.class.isAssignableFrom(type) && GenericRecord.class.isAssignableFrom(type). }
false;public;0;5;;@Override public TypeSerializer<T> duplicate() {     checkAvroInitialized().     return new AvroSerializer<>(type, new SerializableAvroSchema(runtimeSchema), previousSchema). }
false;public;0;4;;@Override public int hashCode() {     return 42 + type.hashCode(). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     } else if (obj != null && obj.getClass() == AvroSerializer.class) {         final AvroSerializer that = (AvroSerializer) obj.         return this.type == that.type.     } else {         return false.     } }
false;public;0;4;;@Override public String toString() {     return getClass().getName() + " (" + getType().getName() + ')'. }
false;private;0;5;;// ------------------------------------------------------------------------ // Initialization // ------------------------------------------------------------------------ private void checkAvroInitialized() {     if (writer == null) {         initializeAvro().     } }
false;private;0;9;;private void initializeAvro() {     AvroFactory<T> factory = AvroFactory.create(type, schema.getAvroSchema(), previousSchema.getAvroSchema()).     this.runtimeSchema = factory.getSchema().     this.writer = factory.getWriter().     this.reader = factory.getReader().     this.encoder = factory.getEncoder().     this.decoder = factory.getDecoder().     this.avroData = factory.getAvroData(). }
false;private;0;16;;// -------------------------------------------------------------------------------------------- // Concurrency checks // -------------------------------------------------------------------------------------------- private void enterExclusiveThread() {     // we use simple get, check, set here, rather than CAS     // we don't need lock-style correctness, this is only a sanity-check and we thus     // favor speed at the cost of some false negatives in this check     Thread previous = currentThread.     Thread thisThread = Thread.currentThread().     if (previous == null) {         currentThread = thisThread.     } else if (previous != thisThread) {         throw new IllegalStateException("Concurrent access to KryoSerializer. Thread 1: " + thisThread.getName() + " , Thread 2: " + previous.getName()).     } }
false;private;0;3;;private void exitExclusiveThread() {     currentThread = null. }
false;;0;4;;Schema getAvroSchema() {     checkAvroInitialized().     return runtimeSchema. }
false;private;1;56;;// -------- backwards compatibility with 1.5, 1.6 ----------- private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {     /* 		Please see FLINK-11436 for details on why manual deserialization is required.  		During the release of Flink 1.7, the value of serialVersionUID was uptick to 2L (was 1L before) 		And although the AvroSerializer (along with it's snapshot class) were migrated to the new serialization 		abstraction (hence free from Java serialization), there were composite serializers that were not migrated 		and were serialized with Java serialization. In case that one of the nested serializers were Avro we would 		bump into deserialization exception due to a wrong serialVersionUID. Unfortunately it is not possible to revert 		the serialVersionUID back to 1L, because users might have snapshots with 2L present already. 		To overcome this we first need to make sure that the AvroSerializer is being Java deserialized with 		FailureTolerantObjectInputStream, and then we determine the serialized layout by looking at the fields.  		From: https://docs.oracle.com/javase/8/docs/platform/serialization/spec/class.html#a5421 		------------------------------------------------------------------------------------------------------------- 		The descriptors for primitive typed fields are written first 		sorted by field name followed by descriptors for the object typed fields sorted by field name. 		The names are sorted using String.compareTo. 		-------------------------------------------------------------------------------------------------------------  		pre 1.6		field order:   	[type] 		pre 1.7 	field order:   	[schemaString, 		type] 		post 1.7 	field order:	[previousSchema,	schema,		type]  		We would use the first field to distinguish between the three different layouts. 		To complicate things even further in pre 1.7, the field @schemaString could be 		null or a string, but, in post 1.7, the field @previousSchema was never set to null, therefore 		we can use the first field to determine the version.  		this logic should stay here as long as we support Flink 1.6 (along with Java serialized 		TypeSerializers) 		*/     final Object firstField = in.readObject().     if (firstField == null) {         // first field can only be NULL in 1.6 (schemaString)         read16Layout(null, in).     } else if (firstField instanceof String) {         // first field is a String only in 1.6 (schemaString)         read16Layout((String) firstField, in).     } else if (firstField instanceof Class<?>) {         // first field is a Class<?> only in 1.5 (type)         @SuppressWarnings("unchecked")         Class<T> type = (Class<T>) firstField.         read15Layout(type).     } else if (firstField instanceof SerializableAvroSchema) {         readCurrentLayout((SerializableAvroSchema) firstField, in).     } else {         throw new IllegalStateException("Failed to Java-Deserialize an AvroSerializer instance. " + "Was expecting a first field to be either a String or SerializableAvroSchema, but got: " + "" + firstField.getClass()).     } }
false;private;1;5;;private void read15Layout(Class<T> type) {     this.previousSchema = new SerializableAvroSchema().     this.schema = new SerializableAvroSchema().     this.type = type. }
false;private;2;11;;@SuppressWarnings("unchecked") private void read16Layout(@Nullable String schemaString, ObjectInputStream in) throws IOException, ClassNotFoundException {     Schema schema = AvroFactory.parseSchemaString(schemaString).     Class<T> type = (Class<T>) in.readObject().     this.previousSchema = new SerializableAvroSchema().     this.schema = new SerializableAvroSchema(schema).     this.type = type. }
false;private;2;8;;@SuppressWarnings("unchecked") private void readCurrentLayout(SerializableAvroSchema previousSchema, ObjectInputStream in) throws IOException, ClassNotFoundException {     this.previousSchema = previousSchema.     this.schema = (SerializableAvroSchema) in.readObject().     this.type = (Class<T>) in.readObject(). }
