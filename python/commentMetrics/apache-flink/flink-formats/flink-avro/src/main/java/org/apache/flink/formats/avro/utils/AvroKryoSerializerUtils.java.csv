commented;modifiers;parameterAmount;loc;comment;code
false;public;2;16;;@Override public void addAvroSerializersIfRequired(ExecutionConfig reg, Class<?> type) {     if (org.apache.avro.specific.SpecificRecordBase.class.isAssignableFrom(type) || org.apache.avro.generic.GenericData.Record.class.isAssignableFrom(type)) {         // Avro POJOs contain java.util.List which have GenericData.Array as their runtime type         // because Kryo is not able to serialize them properly, we use this serializer for them         reg.registerTypeWithKryoSerializer(GenericData.Array.class, Serializers.SpecificInstanceCollectionSerializerForArrayList.class).         // We register this serializer for users who want to use untyped Avro records (GenericData.Record).         // Kryo is able to serialize everything in there, except for the Schema.         // This serializer is very slow, but using the GenericData.Records of Kryo is in general a bad idea.         // we add the serializer as a default serializer because Avro is using a private sub-type at runtime.         reg.addDefaultKryoSerializer(Schema.class, AvroSchemaSerializer.class).     } }
false;public;1;8;;@Override public void addAvroGenericDataArrayRegistration(LinkedHashMap<String, KryoRegistration> kryoRegistrations) {     kryoRegistrations.put(GenericData.Array.class.getName(), new KryoRegistration(GenericData.Array.class, new ExecutionConfig.SerializableSerializer<>(new Serializers.SpecificInstanceCollectionSerializerForArrayList()))). }
false;public;1;4;;@Override public <T> TypeSerializer<T> createAvroSerializer(Class<T> type) {     return new AvroSerializer<>(type). }
false;public;1;7;;@Override @SuppressWarnings({ "rawtypes", "unchecked" }) public <T> TypeInformation<T> createAvroTypeInfo(Class<T> type) {     // the interface of AvroUtils     return new AvroTypeInfo(type). }
false;public;3;5;;@Override public void write(Kryo kryo, Output output, Schema object) {     String schemaAsString = object.toString(false).     output.writeString(schemaAsString). }
false;public;3;7;;@Override public Schema read(Kryo kryo, Input input, Class<Schema> type) {     String schemaAsString = input.readString().     // the parser seems to be stateful, to we need a new one for every type.     Schema.Parser sParser = new Schema.Parser().     return sParser.parse(schemaAsString). }
false;public;3;11;;@Override public void write(Kryo kryo, Output output, LocalDate localDate) {     output.writeInt(localDate.getYear()).     output.writeInt(localDate.getMonthOfYear()).     output.writeInt(localDate.getDayOfMonth()).     final Chronology chronology = localDate.getChronology().     if (chronology != null && chronology != ISOChronology.getInstanceUTC()) {         throw new RuntimeException("Unsupported chronology: " + chronology).     } }
false;public;3;12;;@Override public LocalDate read(Kryo kryo, Input input, Class<LocalDate> aClass) {     final int y = input.readInt().     final int m = input.readInt().     final int d = input.readInt().     return new LocalDate(y, m, d, null). }
false;public;3;10;;@Override public void write(Kryo kryo, Output output, LocalTime object) {     final int time = object.getMillisOfDay().     output.writeInt(time, true).     final Chronology chronology = object.getChronology().     if (chronology != null && chronology != ISOChronology.getInstanceUTC()) {         throw new RuntimeException("Unsupported chronology: " + chronology).     } }
false;public;3;5;;@Override public LocalTime read(Kryo kryo, Input input, Class<LocalTime> type) {     final int time = input.readInt(true).     return new LocalTime(time, ISOChronology.getInstanceUTC().withZone(DateTimeZone.UTC)). }
false;public;2;4;;@Override public LocalTime copy(Kryo kryo, LocalTime original) {     return new LocalTime(original). }
