commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override @SuppressWarnings("deprecation") public TypeSerializer<T> createSerializer(ExecutionConfig config) {     return new AvroSerializer<>(getTypeClass()). }
false;private,static;1;29;;@SuppressWarnings("unchecked") @Internal private static <T extends SpecificRecordBase> List<PojoField> generateFieldsFromAvroSchema(Class<T> typeClass) {     PojoTypeExtractor pte = new PojoTypeExtractor().     ArrayList<Type> typeHierarchy = new ArrayList<>().     typeHierarchy.add(typeClass).     TypeInformation ti = pte.analyzePojo(typeClass, typeHierarchy, null, null, null).     if (!(ti instanceof PojoTypeInfo)) {         throw new IllegalStateException("Expecting type to be a PojoTypeInfo").     }     PojoTypeInfo pti = (PojoTypeInfo) ti.     List<PojoField> newFields = new ArrayList<>(pti.getTotalFields()).     for (int i = 0. i < pti.getArity(). i++) {         PojoField f = pti.getPojoFieldAt(i).         TypeInformation newType = f.getTypeInformation().         // check if type is a CharSequence         if (newType instanceof GenericTypeInfo) {             if ((newType).getTypeClass().equals(CharSequence.class)) {                 // replace the type by a org.apache.avro.util.Utf8                 newType = new GenericTypeInfo(org.apache.avro.util.Utf8.class).             }         }         PojoField newField = new PojoField(f.getField(), newType).         newFields.add(newField).     }     return newFields. }
false;public;5;5;;@Override public <OUT, IN1, IN2> TypeInformation<OUT> analyzePojo(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {     return super.analyzePojo(clazz, typeHierarchy, parameterizedType, in1Type, in2Type). }
