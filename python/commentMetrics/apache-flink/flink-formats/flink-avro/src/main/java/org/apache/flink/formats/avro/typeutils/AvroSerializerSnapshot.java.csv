commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int getCurrentVersion() {     return 2. }
false;public;1;8;;@Override public void writeSnapshot(DataOutputView out) throws IOException {     checkNotNull(runtimeType).     checkNotNull(schema).     out.writeUTF(runtimeType.getName()).     out.writeUTF(schema.toString(false)). }
false;public;3;16;;@SuppressWarnings("unchecked") @Override public void readSnapshot(int readVersion, DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     switch(readVersion) {         case 1:             {                 readV1(in, userCodeClassLoader).                 return.             }         case 2:             {                 readV2(in, userCodeClassLoader).                 return.             }         default:             throw new IllegalArgumentException("unknown snapshot version for AvroSerializerSnapshot " + readVersion).     } }
false;private;2;6;;private void readV1(DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     final String previousSchemaDefinition = in.readUTF().     this.schema = parseAvroSchema(previousSchemaDefinition).     this.runtimeType = findClassOrFallbackToGeneric(userCodeClassLoader, schema.getFullName()).     this.runtimeSchema = tryExtractAvroSchema(userCodeClassLoader, runtimeType). }
false;private;2;8;;private void readV2(DataInputView in, ClassLoader userCodeClassLoader) throws IOException {     final String previousRuntimeTypeName = in.readUTF().     final String previousSchemaDefinition = in.readUTF().     this.runtimeType = findClassOrThrow(userCodeClassLoader, previousRuntimeTypeName).     this.schema = parseAvroSchema(previousSchemaDefinition).     this.runtimeSchema = tryExtractAvroSchema(userCodeClassLoader, runtimeType). }
false;public;1;9;;@Override public TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(TypeSerializer<T> newSerializer) {     if (!(newSerializer instanceof AvroSerializer)) {         return TypeSerializerSchemaCompatibility.incompatible().     }     AvroSerializer<?> newAvroSerializer = (AvroSerializer<?>) newSerializer.     return resolveSchemaCompatibility(schema, newAvroSerializer.getAvroSchema()). }
false;public;0;12;;@Override public TypeSerializer<T> restoreSerializer() {     checkNotNull(runtimeType).     checkNotNull(schema).     if (runtimeSchema != null) {         return new AvroSerializer<>(runtimeType, new SerializableAvroSchema(runtimeSchema), new SerializableAvroSchema(schema)).     } else {         return new AvroSerializer<>(runtimeType, new SerializableAvroSchema(schema), new SerializableAvroSchema(schema)).     } }
true;static;2;14;/**  * Resolves writer/reader schema compatibly.  *  * <p>Checks whenever a new version of a schema (reader) can read values serialized with the old schema (writer).  * If the schemas are compatible according to {@code Avro} schema resolution rules  * (@see <a href="https://avro.apache.org/docs/current/spec.html#Schema+Resolution">Schema Resolution</a>).  */ ;// ------------------------------------------------------------------------------------------------------------ // Helpers // ------------------------------------------------------------------------------------------------------------ /**  * Resolves writer/reader schema compatibly.  *  * <p>Checks whenever a new version of a schema (reader) can read values serialized with the old schema (writer).  * If the schemas are compatible according to {@code Avro} schema resolution rules  * (@see <a href="https://avro.apache.org/docs/current/spec.html#Schema+Resolution">Schema Resolution</a>).  */ @VisibleForTesting static <T> TypeSerializerSchemaCompatibility<T> resolveSchemaCompatibility(Schema writerSchema, Schema readerSchema) {     if (Objects.equals(writerSchema, readerSchema)) {         return TypeSerializerSchemaCompatibility.compatibleAsIs().     }     final SchemaPairCompatibility compatibility = SchemaCompatibility.checkReaderWriterCompatibility(readerSchema, writerSchema).     return avroCompatibilityToFlinkCompatibility(compatibility). }
false;private,static;1;17;;private static <T> TypeSerializerSchemaCompatibility<T> avroCompatibilityToFlinkCompatibility(SchemaPairCompatibility compatibility) {     switch(compatibility.getType()) {         case COMPATIBLE:             {                 // is required.                 return TypeSerializerSchemaCompatibility.compatibleAfterMigration().             }         case INCOMPATIBLE:             {                 return TypeSerializerSchemaCompatibility.incompatible().             }         case RECURSION_IN_PROGRESS:         default:             return TypeSerializerSchemaCompatibility.incompatible().     } }
false;private,static;1;4;;private static Schema parseAvroSchema(String previousSchemaDefinition) {     Schema.Parser parser = new Schema.Parser().     return parser.parse(previousSchemaDefinition). }
false;private,static;2;11;;private static Schema tryExtractAvroSchema(ClassLoader cl, Class<?> runtimeType) {     if (isGenericRecord(runtimeType)) {         return null.     }     if (isSpecificRecord(runtimeType)) {         SpecificData d = new SpecificData(cl).         return d.getSchema(runtimeType).     }     ReflectData d = new ReflectData(cl).     return d.getSchema(runtimeType). }
false;private,static;2;14;;@SuppressWarnings("unchecked") @Nonnull private static <T> Class<T> findClassOrThrow(ClassLoader userCodeClassLoader, String className) {     try {         Class<?> runtimeTarget = Class.forName(className, false, userCodeClassLoader).         return (Class<T>) runtimeTarget.     } catch (ClassNotFoundException e) {         throw new IllegalStateException("" + "Unable to find the class '" + className + "' which is used to deserialize " + "the elements of this serializer. " + "Were the class was moved or renamed?", e).     } }
false;private,static;2;11;;@SuppressWarnings("unchecked") @Nonnull private static <T> Class<T> findClassOrFallbackToGeneric(ClassLoader userCodeClassLoader, String className) {     try {         Class<?> runtimeTarget = Class.forName(className, false, userCodeClassLoader).         return (Class<T>) runtimeTarget.     } catch (ClassNotFoundException e) {         return (Class<T>) GenericRecord.class.     } }
false;private,static;1;3;;private static boolean isSpecificRecord(Class<?> runtimeType) {     return SpecificRecord.class.isAssignableFrom(runtimeType). }
