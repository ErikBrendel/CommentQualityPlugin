commented;modifiers;parameterAmount;loc;comment;code
false;public;1;13;;@Override public byte[] serialize(Row row) {     try {         // convert to record         final GenericRecord record = convertRowToAvroRecord(schema, row).         arrayOutputStream.reset().         datumWriter.write(record, encoder).         encoder.flush().         return arrayOutputStream.toByteArray().     } catch (Exception e) {         throw new RuntimeException("Failed to serialize row.", e).     } }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     final AvroRowSerializationSchema that = (AvroRowSerializationSchema) o.     return Objects.equals(recordClazz, that.recordClazz) && Objects.equals(schemaString, that.schemaString). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(recordClazz, schemaString). }
false;private;2;10;;// -------------------------------------------------------------------------------------------- private GenericRecord convertRowToAvroRecord(Schema schema, Row row) {     final List<Schema.Field> fields = schema.getFields().     final int length = fields.size().     final GenericRecord record = new GenericData.Record(schema).     for (int i = 0. i < length. i++) {         final Schema.Field field = fields.get(i).         record.put(i, convertFlinkType(field.schema(), row.getField(i))).     }     return record. }
false;private;2;81;;private Object convertFlinkType(Schema schema, Object object) {     if (object == null) {         return null.     }     switch(schema.getType()) {         case RECORD:             if (object instanceof Row) {                 return convertRowToAvroRecord(schema, (Row) object).             }             throw new IllegalStateException("Row expected but was: " + object.getClass()).         case ENUM:             return new GenericData.EnumSymbol(schema, object.toString()).         case ARRAY:             final Schema elementSchema = schema.getElementType().             final Object[] array = (Object[]) object.             final GenericData.Array<Object> convertedArray = new GenericData.Array<>(array.length, schema).             for (Object element : array) {                 convertedArray.add(convertFlinkType(elementSchema, element)).             }             return convertedArray.         case MAP:             final Map<?, ?> map = (Map<?, ?>) object.             final Map<Utf8, Object> convertedMap = new HashMap<>().             for (Map.Entry<?, ?> entry : map.entrySet()) {                 convertedMap.put(new Utf8(entry.getKey().toString()), convertFlinkType(schema.getValueType(), entry.getValue())).             }             return convertedMap.         case UNION:             final List<Schema> types = schema.getTypes().             final int size = types.size().             final Schema actualSchema.             if (size == 2 && types.get(0).getType() == Schema.Type.NULL) {                 actualSchema = types.get(1).             } else if (size == 2 && types.get(1).getType() == Schema.Type.NULL) {                 actualSchema = types.get(0).             } else if (size == 1) {                 actualSchema = types.get(0).             } else {                 // generic type                 return object.             }             return convertFlinkType(actualSchema, object).         case FIXED:             // check for logical type             if (object instanceof BigDecimal) {                 return new GenericData.Fixed(schema, convertFromDecimal(schema, (BigDecimal) object)).             }             return new GenericData.Fixed(schema, (byte[]) object).         case STRING:             return new Utf8(object.toString()).         case BYTES:             // check for logical type             if (object instanceof BigDecimal) {                 return ByteBuffer.wrap(convertFromDecimal(schema, (BigDecimal) object)).             }             return ByteBuffer.wrap((byte[]) object).         case INT:             // check for logical types             if (object instanceof Date) {                 return convertFromDate(schema, (Date) object).             } else if (object instanceof Time) {                 return convertFromTime(schema, (Time) object).             }             return object.         case LONG:             // check for logical type             if (object instanceof Timestamp) {                 return convertFromTimestamp(schema, (Timestamp) object).             }             return object.         case FLOAT:         case DOUBLE:         case BOOLEAN:             return object.     }     throw new RuntimeException("Unsupported Avro type:" + schema). }
false;private;2;13;;private byte[] convertFromDecimal(Schema schema, BigDecimal decimal) {     final LogicalType logicalType = schema.getLogicalType().     if (logicalType instanceof LogicalTypes.Decimal) {         final LogicalTypes.Decimal decimalType = (LogicalTypes.Decimal) logicalType.         // rescale to target type         final BigDecimal rescaled = decimal.setScale(decimalType.getScale(), BigDecimal.ROUND_UNNECESSARY).         // unscaled integer value in big-endian byte order         return decimal.unscaledValue().toByteArray().     } else {         throw new RuntimeException("Unsupported decimal type.").     } }
false;private;2;11;;private int convertFromDate(Schema schema, Date date) {     final LogicalType logicalType = schema.getLogicalType().     if (logicalType == LogicalTypes.date()) {         // adopted from Apache Calcite         final long time = date.getTime().         final long converted = time + (long) LOCAL_TZ.getOffset(time).         return (int) (converted / 86400000L).     } else {         throw new RuntimeException("Unsupported date type.").     } }
false;private;2;11;;private int convertFromTime(Schema schema, Time date) {     final LogicalType logicalType = schema.getLogicalType().     if (logicalType == LogicalTypes.timeMillis()) {         // adopted from Apache Calcite         final long time = date.getTime().         final long converted = time + (long) LOCAL_TZ.getOffset(time).         return (int) (converted % 86400000L).     } else {         throw new RuntimeException("Unsupported time type.").     } }
false;private;2;10;;private long convertFromTimestamp(Schema schema, Timestamp date) {     final LogicalType logicalType = schema.getLogicalType().     if (logicalType == LogicalTypes.timestampMillis()) {         // adopted from Apache Calcite         final long time = date.getTime().         return time + (long) LOCAL_TZ.getOffset(time).     } else {         throw new RuntimeException("Unsupported timestamp type.").     } }
false;private;1;4;;private void writeObject(ObjectOutputStream outputStream) throws IOException {     outputStream.writeObject(recordClazz).     // support for null     outputStream.writeObject(schemaString). }
false;private;1;13;;@SuppressWarnings("unchecked") private void readObject(ObjectInputStream inputStream) throws ClassNotFoundException, IOException {     recordClazz = (Class<? extends SpecificRecord>) inputStream.readObject().     schemaString = (String) inputStream.readObject().     if (recordClazz != null) {         schema = SpecificData.get().getSchema(recordClazz).     } else {         schema = new Schema.Parser().parse(schemaString).     }     datumWriter = new SpecificDatumWriter<>(schema).     arrayOutputStream = new ByteArrayOutputStream().     encoder = EncoderFactory.get().binaryEncoder(arrayOutputStream, null). }
