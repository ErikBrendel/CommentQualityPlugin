commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public Row deserialize(byte[] message) throws IOException {     try {         inputStream.setBuffer(message).         record = datumReader.read(record, decoder).         return convertAvroRecordToRow(schema, typeInfo, record).     } catch (Exception e) {         throw new IOException("Failed to deserialize Avro record.", e).     } }
false;public;0;4;;@Override public TypeInformation<Row> getProducedType() {     return typeInfo. }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     final AvroRowDeserializationSchema that = (AvroRowDeserializationSchema) o.     return Objects.equals(recordClazz, that.recordClazz) && Objects.equals(schemaString, that.schemaString). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(recordClazz, schemaString). }
false;private;3;11;;// -------------------------------------------------------------------------------------------- private Row convertAvroRecordToRow(Schema schema, RowTypeInfo typeInfo, IndexedRecord record) {     final List<Schema.Field> fields = schema.getFields().     final TypeInformation<?>[] fieldInfo = typeInfo.getFieldTypes().     final int length = fields.size().     final Row row = new Row(length).     for (int i = 0. i < length. i++) {         final Schema.Field field = fields.get(i).         row.setField(i, convertAvroType(field.schema(), fieldInfo[i], record.get(i))).     }     return row. }
false;private;3;81;;private Object convertAvroType(Schema schema, TypeInformation<?> info, Object object) {     if (object == null) {         return null.     }     switch(schema.getType()) {         case RECORD:             if (object instanceof IndexedRecord) {                 return convertAvroRecordToRow(schema, (RowTypeInfo) info, (IndexedRecord) object).             }             throw new IllegalStateException("IndexedRecord expected but was: " + object.getClass()).         case ENUM:         case STRING:             return object.toString().         case ARRAY:             if (info instanceof BasicArrayTypeInfo) {                 final TypeInformation<?> elementInfo = ((BasicArrayTypeInfo<?, ?>) info).getComponentInfo().                 return convertToObjectArray(schema.getElementType(), elementInfo, object).             } else {                 final TypeInformation<?> elementInfo = ((ObjectArrayTypeInfo<?, ?>) info).getComponentInfo().                 return convertToObjectArray(schema.getElementType(), elementInfo, object).             }         case MAP:             final MapTypeInfo<?, ?> mapTypeInfo = (MapTypeInfo<?, ?>) info.             final Map<String, Object> convertedMap = new HashMap<>().             final Map<?, ?> map = (Map<?, ?>) object.             for (Map.Entry<?, ?> entry : map.entrySet()) {                 convertedMap.put(entry.getKey().toString(), convertAvroType(schema.getValueType(), mapTypeInfo.getValueTypeInfo(), entry.getValue())).             }             return convertedMap.         case UNION:             final List<Schema> types = schema.getTypes().             final int size = types.size().             final Schema actualSchema.             if (size == 2 && types.get(0).getType() == Schema.Type.NULL) {                 return convertAvroType(types.get(1), info, object).             } else if (size == 2 && types.get(1).getType() == Schema.Type.NULL) {                 return convertAvroType(types.get(0), info, object).             } else if (size == 1) {                 return convertAvroType(types.get(0), info, object).             } else {                 // generic type                 return object.             }         case FIXED:             final byte[] fixedBytes = ((GenericFixed) object).bytes().             if (info == Types.BIG_DEC) {                 return convertToDecimal(schema, fixedBytes).             }             return fixedBytes.         case BYTES:             final ByteBuffer byteBuffer = (ByteBuffer) object.             final byte[] bytes = new byte[byteBuffer.remaining()].             byteBuffer.get(bytes).             if (info == Types.BIG_DEC) {                 return convertToDecimal(schema, bytes).             }             return bytes.         case INT:             if (info == Types.SQL_DATE) {                 return convertToDate(object).             } else if (info == Types.SQL_TIME) {                 return convertToTime(object).             }             return object.         case LONG:             if (info == Types.SQL_TIMESTAMP) {                 return convertToTimestamp(object).             }             return object.         case FLOAT:         case DOUBLE:         case BOOLEAN:             return object.     }     throw new RuntimeException("Unsupported Avro type:" + schema). }
false;private;2;4;;private BigDecimal convertToDecimal(Schema schema, byte[] bytes) {     final LogicalTypes.Decimal decimalType = (LogicalTypes.Decimal) schema.getLogicalType().     return new BigDecimal(new BigInteger(bytes), decimalType.getScale()). }
false;private;1;14;;private Date convertToDate(Object object) {     final long millis.     if (object instanceof Integer) {         final Integer value = (Integer) object.         // adopted from Apache Calcite         final long t = (long) value * 86400000L.         millis = t - (long) LOCAL_TZ.getOffset(t).     } else {         // use 'provided' Joda time         final LocalDate value = (LocalDate) object.         millis = value.toDate().getTime().     }     return new Date(millis). }
false;private;1;11;;private Time convertToTime(Object object) {     final long millis.     if (object instanceof Integer) {         millis = (Integer) object.     } else {         // use 'provided' Joda time         final LocalTime value = (LocalTime) object.         millis = (long) value.get(DateTimeFieldType.millisOfDay()).     }     return new Time(millis - LOCAL_TZ.getOffset(millis)). }
false;private;1;11;;private Timestamp convertToTimestamp(Object object) {     final long millis.     if (object instanceof Long) {         millis = (Long) object.     } else {         // use 'provided' Joda time         final DateTime value = (DateTime) object.         millis = value.toDate().getTime().     }     return new Timestamp(millis - LOCAL_TZ.getOffset(millis)). }
false;private;3;10;;private Object[] convertToObjectArray(Schema elementSchema, TypeInformation<?> elementInfo, Object object) {     final List<?> list = (List<?>) object.     final Object[] convertedArray = (Object[]) Array.newInstance(elementInfo.getTypeClass(), list.size()).     for (int i = 0. i < list.size(). i++) {         convertedArray[i] = convertAvroType(elementSchema, elementInfo, list.get(i)).     }     return convertedArray. }
false;private;1;4;;private void writeObject(ObjectOutputStream outputStream) throws IOException {     outputStream.writeObject(recordClazz).     outputStream.writeUTF(schemaString). }
false;private;1;15;;@SuppressWarnings("unchecked") private void readObject(ObjectInputStream inputStream) throws ClassNotFoundException, IOException {     recordClazz = (Class<? extends SpecificRecord>) inputStream.readObject().     schemaString = inputStream.readUTF().     typeInfo = (RowTypeInfo) AvroSchemaConverter.<Row>convertToTypeInfo(schemaString).     schema = new Schema.Parser().parse(schemaString).     if (recordClazz != null) {         record = (SpecificRecord) SpecificData.newInstance(recordClazz, schema).     } else {         record = new GenericData.Record(schema).     }     datumReader = new SpecificDatumReader<>(schema).     this.inputStream = new MutableByteArrayInputStream().     decoder = DecoderFactory.get().binaryDecoder(this.inputStream, null). }
