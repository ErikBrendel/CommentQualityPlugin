commented;modifiers;parameterAmount;loc;comment;code
false;public;0;114;;@Before public void createFiles() throws IOException {     testFile = File.createTempFile("AvroSplittableInputFormatTest", null).     ArrayList<CharSequence> stringArray = new ArrayList<>().     stringArray.add(TEST_ARRAY_STRING_1).     stringArray.add(TEST_ARRAY_STRING_2).     ArrayList<Boolean> booleanArray = new ArrayList<>().     booleanArray.add(TEST_ARRAY_BOOLEAN_1).     booleanArray.add(TEST_ARRAY_BOOLEAN_2).     HashMap<CharSequence, Long> longMap = new HashMap<>().     longMap.put(TEST_MAP_KEY1, TEST_MAP_VALUE1).     longMap.put(TEST_MAP_KEY2, TEST_MAP_VALUE2).     Address addr = new Address().     addr.setNum(TEST_NUM).     addr.setStreet(TEST_STREET).     addr.setCity(TEST_CITY).     addr.setState(TEST_STATE).     addr.setZip(TEST_ZIP).     User user1 = new User().     user1.setName(TEST_NAME).     user1.setFavoriteNumber(256).     user1.setTypeDoubleTest(123.45d).     user1.setTypeBoolTest(true).     user1.setTypeArrayString(stringArray).     user1.setTypeArrayBoolean(booleanArray).     user1.setTypeEnum(TEST_ENUM_COLOR).     user1.setTypeMap(longMap).     user1.setTypeNested(addr).     user1.setTypeBytes(ByteBuffer.allocate(10)).     user1.setTypeDate(LocalDate.parse("2014-03-01")).     user1.setTypeTimeMillis(LocalTime.parse("12:12:12")).     user1.setTypeTimeMicros(123456).     user1.setTypeTimestampMillis(DateTime.parse("2014-03-01T12:12:12.321Z")).     user1.setTypeTimestampMicros(123456L).     // 20.00     user1.setTypeDecimalBytes(ByteBuffer.wrap(BigDecimal.valueOf(2000, 2).unscaledValue().toByteArray())).     // 20.00     user1.setTypeDecimalFixed(new Fixed2(BigDecimal.valueOf(2000, 2).unscaledValue().toByteArray())).     // Construct via builder     User user2 = User.newBuilder().setName(TEST_NAME).setFavoriteColor("blue").setFavoriteNumber(null).setTypeBoolTest(false).setTypeDoubleTest(1.337d).setTypeNullTest(null).setTypeLongTest(1337L).setTypeArrayString(new ArrayList<>()).setTypeArrayBoolean(new ArrayList<>()).setTypeNullableArray(null).setTypeEnum(Colors.RED).setTypeMap(new HashMap<>()).setTypeFixed(new Fixed16()).setTypeUnion(123L).setTypeNested(Address.newBuilder().setNum(TEST_NUM).setStreet(TEST_STREET).setCity(TEST_CITY).setState(TEST_STATE).setZip(TEST_ZIP).build()).setTypeBytes(ByteBuffer.allocate(10)).setTypeDate(LocalDate.parse("2014-03-01")).setTypeTimeMillis(LocalTime.parse("12:12:12")).setTypeTimeMicros(123456).setTypeTimestampMillis(DateTime.parse("2014-03-01T12:12:12.321Z")).setTypeTimestampMicros(123456L).setTypeDecimalBytes(ByteBuffer.wrap(BigDecimal.valueOf(2000, 2).unscaledValue().toByteArray())).setTypeDecimalFixed(new Fixed2(BigDecimal.valueOf(2000, 2).unscaledValue().toByteArray())).build().     DatumWriter<User> userDatumWriter = new SpecificDatumWriter<>(User.class).     DataFileWriter<User> dataFileWriter = new DataFileWriter<>(userDatumWriter).     dataFileWriter.create(user1.getSchema(), testFile).     dataFileWriter.append(user1).     dataFileWriter.append(user2).     Random rnd = new Random(1337).     for (int i = 0. i < NUM_RECORDS - 2. i++) {         User user = new User().         user.setName(TEST_NAME + rnd.nextInt()).         user.setFavoriteNumber(rnd.nextInt()).         user.setTypeDoubleTest(rnd.nextDouble()).         user.setTypeBoolTest(true).         user.setTypeArrayString(stringArray).         user.setTypeArrayBoolean(booleanArray).         user.setTypeEnum(TEST_ENUM_COLOR).         user.setTypeMap(longMap).         Address address = new Address().         address.setNum(TEST_NUM).         address.setStreet(TEST_STREET).         address.setCity(TEST_CITY).         address.setState(TEST_STATE).         address.setZip(TEST_ZIP).         user.setTypeNested(address).         user.setTypeBytes(ByteBuffer.allocate(10)).         user.setTypeDate(LocalDate.parse("2014-03-01")).         user.setTypeTimeMillis(LocalTime.parse("12:12:12")).         user.setTypeTimeMicros(123456).         user.setTypeTimestampMillis(DateTime.parse("2014-03-01T12:12:12.321Z")).         user.setTypeTimestampMicros(123456L).         // 20.00         user.setTypeDecimalBytes(ByteBuffer.wrap(BigDecimal.valueOf(2000, 2).unscaledValue().toByteArray())).         // 20.00         user.setTypeDecimalFixed(new Fixed2(BigDecimal.valueOf(2000, 2).unscaledValue().toByteArray())).         dataFileWriter.append(user).     }     dataFileWriter.close(). }
false;public;0;29;;@Test public void testSplittedIF() throws IOException {     Configuration parameters = new Configuration().     AvroInputFormat<User> format = new AvroInputFormat<>(new Path(testFile.getAbsolutePath()), User.class).     format.configure(parameters).     FileInputSplit[] splits = format.createInputSplits(4).     assertEquals(splits.length, 4).     int elements = 0.     int[] elementsPerSplit = new int[4].     for (int i = 0. i < splits.length. i++) {         format.open(splits[i]).         while (!format.reachedEnd()) {             User u = format.nextRecord(null).             Assert.assertTrue(u.getName().toString().startsWith(TEST_NAME)).             elements++.             elementsPerSplit[i]++.         }         format.close().     }     Assert.assertEquals(1604, elementsPerSplit[0]).     Assert.assertEquals(1203, elementsPerSplit[1]).     Assert.assertEquals(1203, elementsPerSplit[2]).     Assert.assertEquals(990, elementsPerSplit[3]).     Assert.assertEquals(NUM_RECORDS, elements).     format.close(). }
false;public;0;45;;@Test public void testAvroRecoveryWithFailureAtStart() throws Exception {     final int recordsUntilCheckpoint = 132.     Configuration parameters = new Configuration().     AvroInputFormat<User> format = new AvroInputFormat<>(new Path(testFile.getAbsolutePath()), User.class).     format.configure(parameters).     FileInputSplit[] splits = format.createInputSplits(4).     assertEquals(splits.length, 4).     int elements = 0.     int[] elementsPerSplit = new int[4].     for (int i = 0. i < splits.length. i++) {         format.reopen(splits[i], format.getCurrentState()).         while (!format.reachedEnd()) {             User u = format.nextRecord(null).             Assert.assertTrue(u.getName().toString().startsWith(TEST_NAME)).             elements++.             if (format.getRecordsReadFromBlock() == recordsUntilCheckpoint) {                 // do the whole checkpoint-restore procedure and see if we pick up from where we left off.                 Tuple2<Long, Long> state = format.getCurrentState().                 // this is to make sure that nothing stays from the previous format                 // (as it is going to be in the normal case)                 format = new AvroInputFormat<>(new Path(testFile.getAbsolutePath()), User.class).                 format.reopen(splits[i], state).                 assertEquals(format.getRecordsReadFromBlock(), recordsUntilCheckpoint).             }             elementsPerSplit[i]++.         }         format.close().     }     Assert.assertEquals(1604, elementsPerSplit[0]).     Assert.assertEquals(1203, elementsPerSplit[1]).     Assert.assertEquals(1203, elementsPerSplit[2]).     Assert.assertEquals(990, elementsPerSplit[3]).     Assert.assertEquals(NUM_RECORDS, elements).     format.close(). }
false;public;0;45;;@Test public void testAvroRecovery() throws Exception {     final int recordsUntilCheckpoint = 132.     Configuration parameters = new Configuration().     AvroInputFormat<User> format = new AvroInputFormat<>(new Path(testFile.getAbsolutePath()), User.class).     format.configure(parameters).     FileInputSplit[] splits = format.createInputSplits(4).     assertEquals(splits.length, 4).     int elements = 0.     int[] elementsPerSplit = new int[4].     for (int i = 0. i < splits.length. i++) {         format.open(splits[i]).         while (!format.reachedEnd()) {             User u = format.nextRecord(null).             Assert.assertTrue(u.getName().toString().startsWith(TEST_NAME)).             elements++.             if (format.getRecordsReadFromBlock() == recordsUntilCheckpoint) {                 // do the whole checkpoint-restore procedure and see if we pick up from where we left off.                 Tuple2<Long, Long> state = format.getCurrentState().                 // this is to make sure that nothing stays from the previous format                 // (as it is going to be in the normal case)                 format = new AvroInputFormat<>(new Path(testFile.getAbsolutePath()), User.class).                 format.reopen(splits[i], state).                 assertEquals(format.getRecordsReadFromBlock(), recordsUntilCheckpoint).             }             elementsPerSplit[i]++.         }         format.close().     }     Assert.assertEquals(1604, elementsPerSplit[0]).     Assert.assertEquals(1203, elementsPerSplit[1]).     Assert.assertEquals(1203, elementsPerSplit[2]).     Assert.assertEquals(990, elementsPerSplit[3]).     Assert.assertEquals(NUM_RECORDS, elements).     format.close(). }
false;public;0;5;;/* 	This test is gave the reference values for the test of Flink's IF.  	This dependency needs to be added  		<dependency> 			<groupId>org.apache.avro</groupId> 			<artifactId>avro-mapred</artifactId> 			<version>1.7.6</version> 		</dependency>  		<dependency> 			<groupId>org.apache.flink</groupId> 			<artifactId>flink-hadoop-compatibility_2.11</artifactId> 			<version>1.6-SNAPSHOT</version> 		</dependency>  		<dependency> 			<groupId>com.google.guava</groupId> 			<artifactId>guava</artifactId> 			<version>16.0</version> 		</dependency>  	@Test 	public void testHadoop() throws Exception { 		JobConf jf = new JobConf(). 		FileInputFormat.addInputPath(jf, new org.apache.hadoop.fs.Path(testFile.toURI())). 		jf.setBoolean(org.apache.avro.mapred.AvroInputFormat.IGNORE_FILES_WITHOUT_EXTENSION_KEY, false). 		org.apache.avro.mapred.AvroInputFormat<User> format = new org.apache.avro.mapred.AvroInputFormat<User>(). 		InputSplit[] sp = format.getSplits(jf, 4). 		int elementsPerSplit[] = new int[4]. 		int cnt = 0. 		int i = 0. 		for (InputSplit s:sp) { 			RecordReader<AvroWrapper<User>, NullWritable> r = format.getRecordReader(s, jf, new HadoopDummyReporter()). 			AvroWrapper<User> k = r.createKey(). 			NullWritable v = r.createValue().  			while (r.next(k, v)) { 				cnt++. 				elementsPerSplit[i]++. 			} 			i++. 		} 		System.out.println("Status " + Arrays.toString(elementsPerSplit)). 	} */ @After @SuppressWarnings("ResultOfMethodCallIgnored") public void deleteFiles() {     testFile.delete(). }
