commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Test(expected = ValidationException.class) public void testInvalidAllowComments() {     addPropertyAndVerify(CUSTOM_DESCRIPTOR_WITH_SCHEMA, "format.allow-comments", "DDD"). }
false;public;0;4;;@Test(expected = ValidationException.class) public void testMissingSchema() {     removePropertyAndVerify(CUSTOM_DESCRIPTOR_WITH_SCHEMA, "format.schema"). }
false;public;0;8;;@Test(expected = ValidationException.class) public void testDuplicateSchema() {     // we add an additional schema     addPropertyAndVerify(MINIMAL_DESCRIPTOR_WITH_DERIVED_SCHEMA, "format.schema", "ROW<a VARCHAR, b INT, c ROW<a VARCHAR, b INT, c BOOLEAN>>"). }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public List<Descriptor> descriptors() {     return Arrays.asList(CUSTOM_DESCRIPTOR_WITH_SCHEMA, MINIMAL_DESCRIPTOR_WITH_DERIVED_SCHEMA). }
false;public;0;22;;@Override public List<Map<String, String>> properties() {     final Map<String, String> props1 = new HashMap<>().     props1.put("format.type", "csv").     props1.put("format.property-version", "1").     props1.put("format.schema", "ROW<a VARCHAR, b INT, c ROW<a VARCHAR, b INT, c BOOLEAN>>").     props1.put("format.field-delimiter", ".").     props1.put("format.line-delimiter", "\r\n").     props1.put("format.quote-character", "'").     props1.put("format.allow-comments", "true").     props1.put("format.ignore-parse-errors", "true").     props1.put("format.array-element-delimiter", "|").     props1.put("format.escape-character", "\\").     props1.put("format.null-literal", "n/a").     final Map<String, String> props2 = new HashMap<>().     props2.put("format.type", "csv").     props2.put("format.property-version", "1").     props2.put("format.derive-schema", "true").     return Arrays.asList(props1, props2). }
false;public;0;4;;@Override public DescriptorValidator validator() {     return new CsvValidator(). }
