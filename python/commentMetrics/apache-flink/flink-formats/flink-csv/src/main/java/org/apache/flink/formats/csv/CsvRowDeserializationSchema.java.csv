commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Builder setFieldDelimiter(char delimiter) {     this.csvSchema = this.csvSchema.rebuild().setColumnSeparator(delimiter).build().     return this. }
false;public;1;4;;public Builder setAllowComments(boolean allowComments) {     this.csvSchema = this.csvSchema.rebuild().setAllowComments(allowComments).build().     return this. }
false;public;1;5;;public Builder setArrayElementDelimiter(String delimiter) {     Preconditions.checkNotNull(delimiter, "Array element delimiter must not be null.").     this.csvSchema = this.csvSchema.rebuild().setArrayElementSeparator(delimiter).build().     return this. }
false;public;1;4;;public Builder setQuoteCharacter(char c) {     this.csvSchema = this.csvSchema.rebuild().setQuoteChar(c).build().     return this. }
false;public;1;4;;public Builder setEscapeCharacter(char c) {     this.csvSchema = this.csvSchema.rebuild().setEscapeChar(c).build().     return this. }
false;public;1;5;;public Builder setNullLiteral(String nullLiteral) {     Preconditions.checkNotNull(nullLiteral, "Null literal must not be null.").     this.csvSchema = this.csvSchema.rebuild().setNullValue(nullLiteral).build().     return this. }
false;public;1;4;;public Builder setIgnoreParseErrors(boolean ignoreParseErrors) {     this.ignoreParseErrors = ignoreParseErrors.     return this. }
false;public;0;6;;public CsvRowDeserializationSchema build() {     return new CsvRowDeserializationSchema(typeInfo, csvSchema, ignoreParseErrors). }
false;public;1;12;;@Override public Row deserialize(byte[] message) throws IOException {     try {         final JsonNode root = objectReader.readValue(message).         return (Row) runtimeConverter.convert(root).     } catch (Throwable t) {         if (ignoreParseErrors) {             return null.         }         throw new IOException("Failed to deserialize CSV row '" + new String(message) + "'.", t).     } }
false;public;1;4;;@Override public boolean isEndOfStream(Row nextElement) {     return false. }
false;public;0;4;;@Override public TypeInformation<Row> getProducedType() {     return typeInfo. }
false;public;1;20;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || o.getClass() != this.getClass()) {         return false.     }     final CsvRowDeserializationSchema that = (CsvRowDeserializationSchema) o.     final CsvSchema otherSchema = that.csvSchema.     return typeInfo.equals(that.typeInfo) && ignoreParseErrors == that.ignoreParseErrors && csvSchema.getColumnSeparator() == otherSchema.getColumnSeparator() && csvSchema.allowsComments() == otherSchema.allowsComments() && csvSchema.getArrayElementSeparator().equals(otherSchema.getArrayElementSeparator()) && csvSchema.getQuoteChar() == otherSchema.getQuoteChar() && csvSchema.getEscapeChar() == otherSchema.getEscapeChar() && Arrays.equals(csvSchema.getNullValue(), otherSchema.getNullValue()). }
false;public;0;12;;@Override public int hashCode() {     return Objects.hash(typeInfo, ignoreParseErrors, csvSchema.getColumnSeparator(), csvSchema.allowsComments(), csvSchema.getArrayElementSeparator(), csvSchema.getQuoteChar(), csvSchema.getEscapeChar(), csvSchema.getNullValue()). }
false;;1;1;;Object convert(JsonNode node).
false;private,static;3;12;;private static RuntimeConverter createRowRuntimeConverter(RowTypeInfo rowTypeInfo, boolean ignoreParseErrors, boolean isTopLevel) {     final TypeInformation<?>[] fieldTypes = rowTypeInfo.getFieldTypes().     final String[] fieldNames = rowTypeInfo.getFieldNames().     final RuntimeConverter[] fieldConverters = createFieldRuntimeConverters(ignoreParseErrors, fieldTypes).     return assembleRowRuntimeConverter(ignoreParseErrors, isTopLevel, fieldNames, fieldConverters). }
false;private,static;2;7;;private static RuntimeConverter[] createFieldRuntimeConverters(boolean ignoreParseErrors, TypeInformation<?>[] fieldTypes) {     final RuntimeConverter[] fieldConverters = new RuntimeConverter[fieldTypes.length].     for (int i = 0. i < fieldTypes.length. i++) {         fieldConverters[i] = createNullableRuntimeConverter(fieldTypes[i], ignoreParseErrors).     }     return fieldConverters. }
false;private,static;4;24;;private static RuntimeConverter assembleRowRuntimeConverter(boolean ignoreParseErrors, boolean isTopLevel, String[] fieldNames, RuntimeConverter[] fieldConverters) {     final int rowArity = fieldNames.length.     return (node) -> {         final int nodeSize = node.size().         validateArity(rowArity, nodeSize, ignoreParseErrors).         final Row row = new Row(rowArity).         for (int i = 0. i < Math.min(rowArity, nodeSize). i++) {             // Jackson only supports mapping by name in the first level             if (isTopLevel) {                 row.setField(i, fieldConverters[i].convert(node.get(fieldNames[i]))).             } else {                 row.setField(i, fieldConverters[i].convert(node.get(i))).             }         }         return row.     }. }
false;private,static;2;18;;private static RuntimeConverter createNullableRuntimeConverter(TypeInformation<?> info, boolean ignoreParseErrors) {     final RuntimeConverter valueConverter = createRuntimeConverter(info, ignoreParseErrors).     return (node) -> {         if (node.isNull()) {             return null.         }         try {             return valueConverter.convert(node).         } catch (Throwable t) {             if (!ignoreParseErrors) {                 throw t.             }             return null.         }     }. }
false;private,static;2;47;;private static RuntimeConverter createRuntimeConverter(TypeInformation<?> info, boolean ignoreParseErrors) {     if (info.equals(Types.VOID)) {         return (node) -> null.     } else if (info.equals(Types.STRING)) {         return JsonNode::asText.     } else if (info.equals(Types.BOOLEAN)) {         return (node) -> Boolean.valueOf(node.asText().trim()).     } else if (info.equals(Types.BYTE)) {         return (node) -> Byte.valueOf(node.asText().trim()).     } else if (info.equals(Types.SHORT)) {         return (node) -> Short.valueOf(node.asText().trim()).     } else if (info.equals(Types.INT)) {         return (node) -> Integer.valueOf(node.asText().trim()).     } else if (info.equals(Types.LONG)) {         return (node) -> Long.valueOf(node.asText().trim()).     } else if (info.equals(Types.FLOAT)) {         return (node) -> Float.valueOf(node.asText().trim()).     } else if (info.equals(Types.DOUBLE)) {         return (node) -> Double.valueOf(node.asText().trim()).     } else if (info.equals(Types.BIG_DEC)) {         return (node) -> new BigDecimal(node.asText().trim()).     } else if (info.equals(Types.BIG_INT)) {         return (node) -> new BigInteger(node.asText().trim()).     } else if (info.equals(Types.SQL_DATE)) {         return (node) -> Date.valueOf(node.asText()).     } else if (info.equals(Types.SQL_TIME)) {         return (node) -> Time.valueOf(node.asText()).     } else if (info.equals(Types.SQL_TIMESTAMP)) {         return (node) -> Timestamp.valueOf(node.asText()).     } else if (info instanceof RowTypeInfo) {         final RowTypeInfo rowTypeInfo = (RowTypeInfo) info.         return createRowRuntimeConverter(rowTypeInfo, ignoreParseErrors, false).     } else if (info instanceof BasicArrayTypeInfo) {         return createObjectArrayRuntimeConverter(((BasicArrayTypeInfo<?, ?>) info).getComponentInfo(), ignoreParseErrors).     } else if (info instanceof ObjectArrayTypeInfo) {         return createObjectArrayRuntimeConverter(((ObjectArrayTypeInfo<?, ?>) info).getComponentInfo(), ignoreParseErrors).     } else if (info instanceof PrimitiveArrayTypeInfo && ((PrimitiveArrayTypeInfo) info).getComponentType() == Types.BYTE) {         return createByteArrayRuntimeConverter(ignoreParseErrors).     } else {         throw new RuntimeException("Unsupported type information '" + info + "'.").     } }
false;private,static;2;15;;private static RuntimeConverter createObjectArrayRuntimeConverter(TypeInformation<?> elementType, boolean ignoreParseErrors) {     final Class<?> elementClass = elementType.getTypeClass().     final RuntimeConverter elementConverter = createNullableRuntimeConverter(elementType, ignoreParseErrors).     return (node) -> {         final int nodeSize = node.size().         final Object[] array = (Object[]) Array.newInstance(elementClass, nodeSize).         for (int i = 0. i < nodeSize. i++) {             array[i] = elementConverter.convert(node.get(i)).         }         return array.     }. }
false;private,static;1;12;;private static RuntimeConverter createByteArrayRuntimeConverter(boolean ignoreParseErrors) {     return (node) -> {         try {             return node.binaryValue().         } catch (IOException e) {             if (!ignoreParseErrors) {                 throw new RuntimeException("Unable to deserialize byte array.", e).             }             return null.         }     }. }
false;private,static;3;6;;private static void validateArity(int expected, int actual, boolean ignoreParseErrors) {     if (expected != actual && !ignoreParseErrors) {         throw new RuntimeException("Row length mismatch. " + expected + " fields expected but was " + actual + ".").     } }
