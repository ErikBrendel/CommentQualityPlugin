commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Sets the field delimiter character (',' by default).  *  * @param delimiter the field delimiter character  */ ;/**  * Sets the field delimiter character (',' by default).  *  * @param delimiter the field delimiter character  */ public Csv fieldDelimiter(char delimiter) {     internalProperties.putCharacter(FORMAT_FIELD_DELIMITER, delimiter).     return this. }
true;public;1;5;/**  * Sets the line delimiter ("\n" by default. otherwise "\r" or "\r\n" are allowed).  *  * @param delimiter the line delimiter  */ ;/**  * Sets the line delimiter ("\n" by default. otherwise "\r" or "\r\n" are allowed).  *  * @param delimiter the line delimiter  */ public Csv lineDelimiter(String delimiter) {     Preconditions.checkNotNull(delimiter).     internalProperties.putString(FORMAT_LINE_DELIMITER, delimiter).     return this. }
true;public;1;4;/**  * Sets the quote character for enclosing field values ('"' by default).  *  * @param quoteCharacter the quote character  */ ;/**  * Sets the quote character for enclosing field values ('"' by default).  *  * @param quoteCharacter the quote character  */ public Csv quoteCharacter(char quoteCharacter) {     internalProperties.putCharacter(FORMAT_QUOTE_CHARACTER, quoteCharacter).     return this. }
true;public;0;4;/**  * Ignores comment lines that start with '#' (disabled by default). If enabled, make sure to  * also ignore parse errors to allow empty rows.  */ ;/**  * Ignores comment lines that start with '#' (disabled by default). If enabled, make sure to  * also ignore parse errors to allow empty rows.  */ public Csv allowComments() {     internalProperties.putBoolean(FORMAT_ALLOW_COMMENTS, true).     return this. }
true;public;0;4;/**  * Skip fields and rows with parse errors instead of failing. Fields are set to {@code null}  * in case of errors. By default, an exception is thrown.  */ ;/**  * Skip fields and rows with parse errors instead of failing. Fields are set to {@code null}  * in case of errors. By default, an exception is thrown.  */ public Csv ignoreParseErrors() {     internalProperties.putBoolean(FORMAT_IGNORE_PARSE_ERRORS, true).     return this. }
true;public;1;5;/**  * Sets the array element delimiter string for separating array or row element  * values ("." by default).  *  * @param delimiter the array element delimiter  */ ;/**  * Sets the array element delimiter string for separating array or row element  * values ("." by default).  *  * @param delimiter the array element delimiter  */ public Csv arrayElementDelimiter(String delimiter) {     Preconditions.checkNotNull(delimiter).     internalProperties.putString(FORMAT_ARRAY_ELEMENT_DELIMITER, delimiter).     return this. }
true;public;1;4;/**  * Sets the escape character for escaping values (disabled by default).  *  * @param escapeCharacter escaping character (e.g. backslash)  */ ;/**  * Sets the escape character for escaping values (disabled by default).  *  * @param escapeCharacter escaping character (e.g. backslash)  */ public Csv escapeCharacter(char escapeCharacter) {     internalProperties.putCharacter(FORMAT_ESCAPE_CHARACTER, escapeCharacter).     return this. }
true;public;1;5;/**  * Sets the null literal string that is interpreted as a null value (disabled by default).  *  * @param nullLiteral null literal (e.g. "null" or "n/a")  */ ;/**  * Sets the null literal string that is interpreted as a null value (disabled by default).  *  * @param nullLiteral null literal (e.g. "null" or "n/a")  */ public Csv nullLiteral(String nullLiteral) {     Preconditions.checkNotNull(nullLiteral).     internalProperties.putString(FORMAT_NULL_LITERAL, nullLiteral).     return this. }
true;public;1;5;/**  * Sets the format schema with field names and the types. Required if schema is not derived.  *  * @param schemaType type information that describes the schema  */ ;/**  * Sets the format schema with field names and the types. Required if schema is not derived.  *  * @param schemaType type information that describes the schema  */ public Csv schema(TypeInformation<Row> schemaType) {     Preconditions.checkNotNull(schemaType).     internalProperties.putString(FORMAT_SCHEMA, TypeStringUtils.writeTypeInfo(schemaType)).     return this. }
true;public;0;4;/**  * Derives the format schema from the table's schema. Required if no format schema is defined.  *  * <p>This allows for defining schema information only once.  *  * <p>The names, types, and fields' order of the format are determined by the table's  * schema. Time attributes are ignored if their origin is not a field. A "from" definition  * is interpreted as a field renaming in the format.  */ ;/**  * Derives the format schema from the table's schema. Required if no format schema is defined.  *  * <p>This allows for defining schema information only once.  *  * <p>The names, types, and fields' order of the format are determined by the table's  * schema. Time attributes are ignored if their origin is not a field. A "from" definition  * is interpreted as a field renaming in the format.  */ public Csv deriveSchema() {     internalProperties.putBoolean(FORMAT_DERIVE_SCHEMA, true).     return this. }
false;protected;0;6;;@Override protected Map<String, String> toFormatProperties() {     final DescriptorProperties properties = new DescriptorProperties().     properties.putProperties(internalProperties).     return properties.asMap(). }
