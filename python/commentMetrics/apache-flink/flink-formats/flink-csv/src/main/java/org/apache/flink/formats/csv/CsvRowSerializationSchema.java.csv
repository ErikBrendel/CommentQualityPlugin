commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Builder setFieldDelimiter(char c) {     this.csvSchema = this.csvSchema.rebuild().setColumnSeparator(c).build().     return this. }
false;public;1;9;;public Builder setLineDelimiter(String delimiter) {     Preconditions.checkNotNull(delimiter, "Delimiter must not be null.").     if (!delimiter.equals("\n") && !delimiter.equals("\r") && !delimiter.equals("\r\n")) {         throw new IllegalArgumentException("Unsupported new line delimiter. Only \\n, \\r, or \\r\\n are supported.").     }     this.csvSchema = this.csvSchema.rebuild().setLineSeparator(delimiter).build().     return this. }
false;public;1;5;;public Builder setArrayElementDelimiter(String delimiter) {     Preconditions.checkNotNull(delimiter, "Delimiter must not be null.").     this.csvSchema = this.csvSchema.rebuild().setArrayElementSeparator(delimiter).build().     return this. }
false;public;1;4;;public Builder setQuoteCharacter(char c) {     this.csvSchema = this.csvSchema.rebuild().setQuoteChar(c).build().     return this. }
false;public;1;4;;public Builder setEscapeCharacter(char c) {     this.csvSchema = this.csvSchema.rebuild().setEscapeChar(c).build().     return this. }
false;public;1;4;;public Builder setNullLiteral(String s) {     this.csvSchema = this.csvSchema.rebuild().setNullValue(s).build().     return this. }
false;public;0;5;;public CsvRowSerializationSchema build() {     return new CsvRowSerializationSchema(typeInfo, csvSchema). }
false;public;1;12;;@Override public byte[] serialize(Row row) {     if (root == null) {         root = csvMapper.createObjectNode().     }     try {         runtimeConverter.convert(csvMapper, root, row).         return objectWriter.writeValueAsBytes(root).     } catch (Throwable t) {         throw new RuntimeException("Could not serialize row '" + row + "'.", t).     } }
false;public;1;19;;@Override public boolean equals(Object o) {     if (o == null || o.getClass() != this.getClass()) {         return false.     }     if (this == o) {         return true.     }     final CsvRowSerializationSchema that = (CsvRowSerializationSchema) o.     final CsvSchema otherSchema = that.csvSchema.     return typeInfo.equals(that.typeInfo) && csvSchema.getColumnSeparator() == otherSchema.getColumnSeparator() && Arrays.equals(csvSchema.getLineSeparator(), otherSchema.getLineSeparator()) && csvSchema.getArrayElementSeparator().equals(otherSchema.getArrayElementSeparator()) && csvSchema.getQuoteChar() == otherSchema.getQuoteChar() && csvSchema.getEscapeChar() == otherSchema.getEscapeChar() && Arrays.equals(csvSchema.getNullValue(), otherSchema.getNullValue()). }
false;public;0;11;;@Override public int hashCode() {     return Objects.hash(typeInfo, csvSchema.getColumnSeparator(), csvSchema.getLineSeparator(), csvSchema.getArrayElementSeparator(), csvSchema.getQuoteChar(), csvSchema.getEscapeChar(), csvSchema.getNullValue()). }
false;;3;1;;JsonNode convert(CsvMapper csvMapper, ContainerNode<?> container, Object obj).
false;private,static;2;8;;private static RuntimeConverter createRowRuntimeConverter(RowTypeInfo rowTypeInfo, boolean isTopLevel) {     final TypeInformation[] fieldTypes = rowTypeInfo.getFieldTypes().     final String[] fieldNames = rowTypeInfo.getFieldNames().     final RuntimeConverter[] fieldConverters = createFieldRuntimeConverters(fieldTypes).     return assembleRowRuntimeConverter(isTopLevel, fieldNames, fieldConverters). }
false;private,static;1;7;;private static RuntimeConverter[] createFieldRuntimeConverters(TypeInformation<?>[] fieldTypes) {     final RuntimeConverter[] fieldConverters = new RuntimeConverter[fieldTypes.length].     for (int i = 0. i < fieldTypes.length. i++) {         fieldConverters[i] = createNullableRuntimeConverter(fieldTypes[i]).     }     return fieldConverters. }
false;private,static;3;34;;private static RuntimeConverter assembleRowRuntimeConverter(boolean isTopLevel, String[] fieldNames, RuntimeConverter[] fieldConverters) {     final int rowArity = fieldNames.length.     // top level reuses the object node container     if (isTopLevel) {         return (csvMapper, container, obj) -> {             final Row row = (Row) obj.             validateArity(rowArity, row.getArity()).             final ObjectNode objectNode = (ObjectNode) container.             for (int i = 0. i < rowArity. i++) {                 objectNode.set(fieldNames[i], fieldConverters[i].convert(csvMapper, container, row.getField(i))).             }             return objectNode.         }.     } else {         return (csvMapper, container, obj) -> {             final Row row = (Row) obj.             validateArity(rowArity, row.getArity()).             final ArrayNode arrayNode = csvMapper.createArrayNode().             for (int i = 0. i < rowArity. i++) {                 arrayNode.add(fieldConverters[i].convert(csvMapper, arrayNode, row.getField(i))).             }             return arrayNode.         }.     } }
false;private,static;1;9;;private static RuntimeConverter createNullableRuntimeConverter(TypeInformation<?> info) {     final RuntimeConverter valueConverter = createRuntimeConverter(info).     return (csvMapper, container, obj) -> {         if (obj == null) {             return container.nullNode().         }         return valueConverter.convert(csvMapper, container, obj).     }. }
false;private,static;1;43;;private static RuntimeConverter createRuntimeConverter(TypeInformation<?> info) {     if (info.equals(Types.VOID)) {         return (csvMapper, container, obj) -> container.nullNode().     } else if (info.equals(Types.STRING)) {         return (csvMapper, container, obj) -> container.textNode((String) obj).     } else if (info.equals(Types.BOOLEAN)) {         return (csvMapper, container, obj) -> container.booleanNode((Boolean) obj).     } else if (info.equals(Types.BYTE)) {         return (csvMapper, container, obj) -> container.numberNode((Byte) obj).     } else if (info.equals(Types.SHORT)) {         return (csvMapper, container, obj) -> container.numberNode((Short) obj).     } else if (info.equals(Types.INT)) {         return (csvMapper, container, obj) -> container.numberNode((Integer) obj).     } else if (info.equals(Types.LONG)) {         return (csvMapper, container, obj) -> container.numberNode((Long) obj).     } else if (info.equals(Types.FLOAT)) {         return (csvMapper, container, obj) -> container.numberNode((Float) obj).     } else if (info.equals(Types.DOUBLE)) {         return (csvMapper, container, obj) -> container.numberNode((Double) obj).     } else if (info.equals(Types.BIG_DEC)) {         return (csvMapper, container, obj) -> container.numberNode((BigDecimal) obj).     } else if (info.equals(Types.BIG_INT)) {         return (csvMapper, container, obj) -> container.numberNode((BigInteger) obj).     } else if (info.equals(Types.SQL_DATE)) {         return (csvMapper, container, obj) -> container.textNode(obj.toString()).     } else if (info.equals(Types.SQL_TIME)) {         return (csvMapper, container, obj) -> container.textNode(obj.toString()).     } else if (info.equals(Types.SQL_TIMESTAMP)) {         return (csvMapper, container, obj) -> container.textNode(obj.toString()).     } else if (info instanceof RowTypeInfo) {         return createRowRuntimeConverter((RowTypeInfo) info, false).     } else if (info instanceof BasicArrayTypeInfo) {         return createObjectArrayRuntimeConverter(((BasicArrayTypeInfo) info).getComponentInfo()).     } else if (info instanceof ObjectArrayTypeInfo) {         return createObjectArrayRuntimeConverter(((ObjectArrayTypeInfo) info).getComponentInfo()).     } else if (info instanceof PrimitiveArrayTypeInfo && ((PrimitiveArrayTypeInfo) info).getComponentType() == Types.BYTE) {         return createByteArrayRuntimeConverter().     } else {         throw new RuntimeException("Unsupported type information '" + info + "'.").     } }
false;private,static;1;11;;private static RuntimeConverter createObjectArrayRuntimeConverter(TypeInformation<?> elementType) {     final RuntimeConverter elementConverter = createNullableRuntimeConverter(elementType).     return (csvMapper, container, obj) -> {         final Object[] array = (Object[]) obj.         final ArrayNode arrayNode = csvMapper.createArrayNode().         for (Object element : array) {             arrayNode.add(elementConverter.convert(csvMapper, arrayNode, element)).         }         return arrayNode.     }. }
false;private,static;0;3;;private static RuntimeConverter createByteArrayRuntimeConverter() {     return (csvMapper, container, obj) -> container.binaryNode((byte[]) obj). }
false;private,static;2;6;;private static void validateArity(int expected, int actual) {     if (expected != actual) {         throw new RuntimeException("Row length mismatch. " + expected + " fields expected but was " + actual + ".").     } }
