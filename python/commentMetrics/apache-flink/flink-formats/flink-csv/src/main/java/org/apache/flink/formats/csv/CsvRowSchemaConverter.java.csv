commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;9;/**  * Convert {@link RowTypeInfo} to {@link CsvSchema}.  */ ;/**  * Convert {@link RowTypeInfo} to {@link CsvSchema}.  */ public static CsvSchema convert(RowTypeInfo rowType) {     final Builder builder = new CsvSchema.Builder().     final String[] fields = rowType.getFieldNames().     final TypeInformation<?>[] types = rowType.getFieldTypes().     for (int i = 0. i < rowType.getArity(). i++) {         builder.addColumn(new Column(i, fields[i], convertType(fields[i], types[i]))).     }     return builder.build(). }
true;private,static;2;27;/**  * Convert {@link TypeInformation} to {@link CsvSchema.ColumnType} based on Jackson's categories.  */ ;/**  * Convert {@link TypeInformation} to {@link CsvSchema.ColumnType} based on Jackson's categories.  */ private static CsvSchema.ColumnType convertType(String fieldName, TypeInformation<?> info) {     if (STRING_TYPES.contains(info)) {         return CsvSchema.ColumnType.STRING.     } else if (NUMBER_TYPES.contains(info)) {         return CsvSchema.ColumnType.NUMBER.     } else if (BOOLEAN_TYPES.contains(info)) {         return CsvSchema.ColumnType.BOOLEAN.     } else if (info instanceof ObjectArrayTypeInfo) {         validateNestedField(fieldName, ((ObjectArrayTypeInfo) info).getComponentInfo()).         return CsvSchema.ColumnType.ARRAY.     } else if (info instanceof BasicArrayTypeInfo) {         validateNestedField(fieldName, ((BasicArrayTypeInfo) info).getComponentInfo()).         return CsvSchema.ColumnType.ARRAY.     } else if (info instanceof RowTypeInfo) {         final TypeInformation<?>[] types = ((RowTypeInfo) info).getFieldTypes().         for (TypeInformation<?> type : types) {             validateNestedField(fieldName, type).         }         return CsvSchema.ColumnType.ARRAY.     } else if (info instanceof PrimitiveArrayTypeInfo && ((PrimitiveArrayTypeInfo) info).getComponentType() == Types.BYTE) {         return CsvSchema.ColumnType.STRING.     } else {         throw new IllegalArgumentException("Unsupported type information '" + info.toString() + "' for field '" + fieldName + "'.").     } }
false;private,static;2;7;;private static void validateNestedField(String fieldName, TypeInformation<?> info) {     if (!NUMBER_TYPES.contains(info) && !STRING_TYPES.contains(info) && !BOOLEAN_TYPES.contains(info)) {         throw new IllegalArgumentException("Only simple types are supported in the second level nesting of fields '" + fieldName + "' but was: " + info).     } }
