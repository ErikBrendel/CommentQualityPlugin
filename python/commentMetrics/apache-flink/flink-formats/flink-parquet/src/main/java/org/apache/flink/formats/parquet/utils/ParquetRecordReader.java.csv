commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setSkipCorruptedRecord(boolean skipCorruptedRecord) {     this.skipCorruptedRecord = skipCorruptedRecord. }
false;public;2;14;;public void initialize(ParquetFileReader reader, Configuration configuration) {     this.reader = reader.     FileMetaData parquetFileMetadata = reader.getFooter().getFileMetaData().     // real schema of parquet file     this.fileSchema = parquetFileMetadata.getSchema().     Map<String, String> fileMetadata = parquetFileMetadata.getKeyValueMetaData().     ReadSupport.ReadContext readContext = readSupport.init(new InitContext(configuration, toSetMultiMap(fileMetadata), readSchema)).     this.columnIOFactory = new ColumnIOFactory(parquetFileMetadata.getCreatedBy()).     this.recordMaterializer = readSupport.prepareForRead(configuration, fileMetadata, readSchema, readContext).     this.numTotalRecords = reader.getRecordCount(). }
false;private;1;8;;private RecordReader<T> createRecordReader(PageReadStore pages) throws IOException {     if (pages == null) {         throw new IOException("Expecting more rows but reached last block. Read " + numReadRecords + " out of " + numTotalRecords).     }     MessageColumnIO columnIO = columnIOFactory.getColumnIO(readSchema, fileSchema, true).     return columnIO.getRecordReader(pages, recordMaterializer, filter). }
true;public;2;34;/**  * Moves the reading position to the given block and seeks to and reads the given record.  *  * @param block The block to seek to.  * @param recordInBlock The number of the record in the block to return next.  */ ;/**  * Moves the reading position to the given block and seeks to and reads the given record.  *  * @param block The block to seek to.  * @param recordInBlock The number of the record in the block to return next.  */ public void seek(long block, long recordInBlock) throws IOException {     List<BlockMetaData> blockMetaData = reader.getRowGroups().     if (block == -1L && recordInBlock == -1L) {         // the split was fully consumed         currentBlock = blockMetaData.size() - 1.         numReadRecords = numTotalRecords.         numRecordsUpToCurrentBlock = numTotalRecords.         return.     }     // init all counters for the start of the first block     currentBlock = 0.     numRecordsUpToPreviousBlock = 0.     numRecordsUpToCurrentBlock = blockMetaData.get(0).getRowCount().     numReadRecords = 0.     // seek to the given block     while (currentBlock < block) {         currentBlock++.         reader.skipNextRowGroup().         numRecordsUpToPreviousBlock = numRecordsUpToCurrentBlock.         numRecordsUpToCurrentBlock += blockMetaData.get(currentBlock).getRowCount().         numReadRecords = numRecordsUpToPreviousBlock.     }     // seek to and read the given record     PageReadStore pages = reader.readNextRowGroup().     recordReader = createRecordReader(pages).     for (int i = 0. i <= recordInBlock. i++) {         readNextRecord().     } }
true;public;0;22;/**  * Returns the current read position in the split, i.e., the current block and  * the number of records that were returned from that block.  *  * @return The current read position in the split.  */ ;/**  * Returns the current read position in the split, i.e., the current block and  * the number of records that were returned from that block.  *  * @return The current read position in the split.  */ public Tuple2<Long, Long> getCurrentReadPosition() {     // compute number of returned records     long numRecordsReturned = numReadRecords.     if (!readRecordReturned && numReadRecords > 0) {         numRecordsReturned -= 1.     }     if (numRecordsReturned == numTotalRecords) {         // all records of split returned.         return Tuple2.of(-1L, -1L).     }     if (numRecordsReturned == numRecordsUpToCurrentBlock) {         // all records of block returned. Next record is in next block         return Tuple2.of(currentBlock + 1L, 0L).     }     // compute number of returned records of this block     long numRecordsOfBlockReturned = numRecordsReturned - numRecordsUpToPreviousBlock.     return Tuple2.of((long) currentBlock, numRecordsOfBlockReturned). }
true;public;0;12;/**  * Checks if the record reader returned all records.  * This method must be called before a record can be returned.  *  * @return False if there are more records to be read. True if all records have been returned.  */ ;/**  * Checks if the record reader returned all records.  * This method must be called before a record can be returned.  *  * @return False if there are more records to be read. True if all records have been returned.  */ public boolean reachEnd() throws IOException {     // check if we have a read row that was not returned yet     if (readRecord != null && !readRecordReturned) {         return false.     }     // check if there are more rows to be read     if (numReadRecords >= numTotalRecords) {         return true.     }     // try to read next row     return !readNextRecord(). }
true;private;0;57;/**  * Reads the next record.  *  * @return True if a record could be read, false otherwise.  */ ;/**  * Reads the next record.  *  * @return True if a record could be read, false otherwise.  */ private boolean readNextRecord() throws IOException {     boolean recordFound = false.     while (!recordFound) {         // no more records left         if (numReadRecords >= numTotalRecords) {             return false.         }         try {             if (numReadRecords == numRecordsUpToCurrentBlock) {                 // advance to next block                 PageReadStore pages = reader.readNextRowGroup().                 recordReader = createRecordReader(pages).                 numRecordsUpToPreviousBlock = numRecordsUpToCurrentBlock.                 numRecordsUpToCurrentBlock += pages.getRowCount().                 currentBlock++.             }             numReadRecords++.             try {                 readRecord = recordReader.read().                 readRecordReturned = false.             } catch (RecordMaterializationException e) {                 String errorMessage = String.format("skipping a corrupt record in block number [%d] record number [%s] of file %s", currentBlock, numReadRecords - numRecordsUpToPreviousBlock, reader.getFile()).                 if (!skipCorruptedRecord) {                     LOG.error(errorMessage).                     throw e.                 } else {                     LOG.warn(errorMessage).                 }                 continue.             }             if (readRecord == null) {                 readRecordReturned = true.                 numReadRecords = numRecordsUpToCurrentBlock.                 LOG.debug("filtered record reader reached end of block").                 continue.             }             recordFound = true.             LOG.debug("read value: {}", readRecord).         } catch (RecordMaterializationException e) {             LOG.error(String.format("Can not read value at %d in block %d in file %s", numReadRecords - numRecordsUpToPreviousBlock, currentBlock, reader.getFile()), e).             if (!skipCorruptedRecord) {                 throw e.             }             return false.         }     }     return true. }
true;public;0;5;/**  * Returns the next record.  * Note that the reachedEnd() method must be called before.  *  * @return The next record.  */ ;/**  * Returns the next record.  * Note that the reachedEnd() method must be called before.  *  * @return The next record.  */ @CheckReturnValue(when = When.NEVER) public T nextRecord() {     readRecordReturned = true.     return readRecord. }
false;public;0;5;;public void close() throws IOException {     if (reader != null) {         reader.close().     } }
false;private,static;1;8;;private static <K, V> Map<K, Set<V>> toSetMultiMap(Map<K, V> map) {     Map<K, Set<V>> setMultiMap = new HashMap<>().     for (Map.Entry<K, V> entry : map.entrySet()) {         Set<V> set = Collections.singleton(entry.getValue()).         setMultiMap.put(entry.getKey(), Collections.unmodifiableSet(set)).     }     return Collections.unmodifiableMap(setMultiMap). }
