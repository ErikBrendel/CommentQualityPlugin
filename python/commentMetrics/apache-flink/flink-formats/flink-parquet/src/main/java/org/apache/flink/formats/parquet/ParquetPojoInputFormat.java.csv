commented;modifiers;parameterAmount;loc;comment;code
false;public;1;20;;@Override public void open(FileInputSplit split) throws IOException {     super.open(split).     pojoFields = new Field[getFieldNames().length].     LOG.error("Fields number is %d", getFieldNames().length).     final Map<String, Field> fieldMap = new HashMap<>().     findAllFields(pojoTypeClass, fieldMap).     for (int i = 0. i < getFieldNames().length. ++i) {         String fieldName = getFieldNames()[i].         pojoFields[i] = fieldMap.get(fieldName).         if (pojoFields[i] != null) {             pojoFields[i].setAccessible(true).         } else {             throw new RuntimeException(String.format("There is no field called %s in %s", fieldName, pojoTypeClass.getName())).         }     } }
false;private;2;10;;private void findAllFields(Class<?> clazz, Map<String, Field> fieldMap) {     for (Field field : clazz.getDeclaredFields()) {         fieldMap.put(field.getName(), field).     }     if (clazz.getSuperclass() != null) {         findAllFields(clazz.getSuperclass(), fieldMap).     } }
false;protected;1;18;;@Override protected E convert(Row row) {     E result = typeSerializer.createInstance().     for (int i = 0. i < row.getArity(). ++i) {         try {             if (pojoFields[i].getType().isAssignableFrom(List.class)) {                 pojoFields[i].set(result, Collections.singletonList(row.getField(i))).             } else {                 pojoFields[i].set(result, row.getField(i)).             }         } catch (IllegalAccessException e) {             throw new RuntimeException(String.format("Parsed value could not be set in POJO field %s", getFieldNames()[i])).         }     }     return result. }
true;private,static;2;17;/**  * Extracts the {@link TypeInformation}s  from {@link PojoTypeInfo} according to the given field name.  */ ;/**  * Extracts the {@link TypeInformation}s  from {@link PojoTypeInfo} according to the given field name.  */ private static <E> TypeInformation<?>[] extractTypeInfos(PojoTypeInfo<E> pojoTypeInfo, String[] fieldNames) {     Preconditions.checkNotNull(pojoTypeInfo).     Preconditions.checkNotNull(fieldNames).     Preconditions.checkArgument(pojoTypeInfo.getArity() >= fieldNames.length).     TypeInformation<?>[] fieldTypes = new TypeInformation<?>[fieldNames.length].     for (int i = 0. i < fieldNames.length. ++i) {         String fieldName = fieldNames[i].         Preconditions.checkNotNull(fieldName, "The field can't be null").         int fieldPos = pojoTypeInfo.getFieldIndex(fieldName).         Preconditions.checkArgument(fieldPos >= 0, String.format("Field %s is not a member of POJO type %s", fieldName, pojoTypeInfo.getTypeClass().getName())).         fieldTypes[i] = pojoTypeInfo.getTypeAt(fieldPos).     }     return fieldTypes. }
