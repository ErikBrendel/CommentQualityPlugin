commented;modifiers;parameterAmount;loc;comment;code
false;private,static;4;64;;private static Converter createConverter(Type field, int fieldPos, TypeInformation<?> typeInformation, ParentDataHolder parentDataHolder) {     if (field.isPrimitive()) {         return new RowConverter.RowPrimitiveConverter(field, parentDataHolder, fieldPos).     } else if (typeInformation instanceof MapTypeInfo) {         return new RowConverter.MapConverter((GroupType) field, (MapTypeInfo) typeInformation, parentDataHolder, fieldPos).     } else if (typeInformation instanceof BasicArrayTypeInfo) {         Type elementType = field.asGroupType().getFields().get(0).         Class typeClass = ((BasicArrayTypeInfo) typeInformation).getComponentInfo().getTypeClass().         if (typeClass.equals(Character.class)) {             return new RowConverter.ArrayConverter<Character>(elementType, Character.class, BasicTypeInfo.CHAR_TYPE_INFO, parentDataHolder, fieldPos).         } else if (typeClass.equals(Boolean.class)) {             return new RowConverter.ArrayConverter<Boolean>(elementType, Boolean.class, BasicTypeInfo.BOOLEAN_TYPE_INFO, parentDataHolder, fieldPos).         } else if (typeClass.equals(Short.class)) {             return new RowConverter.ArrayConverter<Short>(elementType, Short.class, BasicTypeInfo.SHORT_TYPE_INFO, parentDataHolder, fieldPos).         } else if (typeClass.equals(Integer.class)) {             return new RowConverter.ArrayConverter<Integer>(elementType, Integer.class, BasicTypeInfo.INSTANT_TYPE_INFO, parentDataHolder, fieldPos).         } else if (typeClass.equals(Long.class)) {             return new RowConverter.ArrayConverter<Long>(elementType, Long.class, BasicTypeInfo.LONG_TYPE_INFO, parentDataHolder, fieldPos).         } else if (typeClass.equals(Double.class)) {             return new RowConverter.ArrayConverter<Double>(elementType, Double.class, BasicTypeInfo.DOUBLE_TYPE_INFO, parentDataHolder, fieldPos).         } else if (typeClass.equals(String.class)) {             return new RowConverter.ArrayConverter<String>(elementType, String.class, BasicTypeInfo.STRING_TYPE_INFO, parentDataHolder, fieldPos).         } else if (typeClass.equals(Date.class)) {             return new RowConverter.ArrayConverter<Date>(elementType, Date.class, SqlTimeTypeInfo.DATE, parentDataHolder, fieldPos).         } else if (typeClass.equals(Time.class)) {             return new RowConverter.ArrayConverter<Time>(elementType, Time.class, SqlTimeTypeInfo.TIME, parentDataHolder, fieldPos).         } else if (typeClass.equals(Timestamp.class)) {             return new RowConverter.ArrayConverter<Timestamp>(elementType, Timestamp.class, SqlTimeTypeInfo.TIMESTAMP, parentDataHolder, fieldPos).         } else if (typeClass.equals(BigDecimal.class)) {             return new RowConverter.ArrayConverter<BigDecimal>(elementType, BigDecimal.class, BasicTypeInfo.BIG_DEC_TYPE_INFO, parentDataHolder, fieldPos).         }         throw new IllegalArgumentException(String.format("Can't create converter unsupported primitive array type for %s", typeClass.toString())).     } else if (typeInformation instanceof ObjectArrayTypeInfo) {         GroupType parquetGroupType = field.asGroupType().         Type elementType = parquetGroupType.getType(0).         return new RowConverter.ArrayConverter<Row>(elementType, Row.class, ((ObjectArrayTypeInfo) typeInformation).getComponentInfo(), parentDataHolder, fieldPos).     } else if (typeInformation instanceof RowTypeInfo) {         return new RowConverter((GroupType) field, typeInformation, parentDataHolder, fieldPos).     }     throw new IllegalArgumentException(String.format("Can't create converter for field %s with type %s ", field.getName(), typeInformation.toString())). }
false;public;1;4;;@Override public Converter getConverter(int i) {     return converters[i]. }
false;public;0;4;;@Override public void start() {     this.currentRow = new Row(typeInfo.getArity()). }
false;public;0;3;;public Row getCurrentRow() {     return currentRow. }
false;public;0;6;;@Override public void end() {     if (parentDataHolder != null) {         parentDataHolder.add(posInParentRow, currentRow).     } }
false;public;2;4;;@Override public void add(int fieldIndex, Object object) {     currentRow.setField(fieldIndex, object). }
false;public;1;27;;@Override public void addBinary(Binary value) {     // in case it is a timestamp type stored as INT96     if (primitiveTypeName.equals(PrimitiveType.PrimitiveTypeName.INT96)) {         parentDataHolder.add(pos, new Timestamp(ParquetTimestampUtils.getTimestampMillis(value))).         return.     }     if (originalType != null) {         switch(originalType) {             case DECIMAL:                 parentDataHolder.add(pos, new BigDecimal(value.toStringUsingUTF8().toCharArray())).                 break.             case UTF8:             case ENUM:             case JSON:             case BSON:                 parentDataHolder.add(pos, value.toStringUsingUTF8()).                 break.             default:                 throw new UnsupportedOperationException("Unsupported original type : " + originalType.name() + " for primitive type BINARY").         }     } else {         parentDataHolder.add(pos, value.toStringUsingUTF8()).     } }
false;public;1;4;;@Override public void addBoolean(boolean value) {     parentDataHolder.add(pos, value). }
false;public;1;4;;@Override public void addDouble(double value) {     parentDataHolder.add(pos, value). }
false;public;1;4;;@Override public void addFloat(float value) {     parentDataHolder.add(pos, value). }
false;public;1;31;;@Override public void addInt(int value) {     if (originalType != null) {         switch(originalType) {             case TIME_MICROS:             case TIME_MILLIS:                 parentDataHolder.add(pos, new Time(value)).                 break.             case TIMESTAMP_MICROS:             case TIMESTAMP_MILLIS:                 parentDataHolder.add(pos, new Timestamp(value)).                 break.             case DATE:                 parentDataHolder.add(pos, new Date(value)).                 break.             case UINT_8:             case UINT_16:             case UINT_32:             case INT_8:             case INT_16:             case INT_32:                 parentDataHolder.add(pos, value).                 break.             default:                 throw new UnsupportedOperationException("Unsupported original type : " + originalType.name() + " for primitive type INT32").         }     } else {         parentDataHolder.add(pos, value).     } }
false;public;1;24;;@Override public void addLong(long value) {     if (originalType != null) {         switch(originalType) {             case TIME_MICROS:                 parentDataHolder.add(pos, new Time(value)).                 break.             case TIMESTAMP_MICROS:             case TIMESTAMP_MILLIS:                 parentDataHolder.add(pos, new Timestamp(value)).                 break.             case INT_64:             case DECIMAL:                 // long is more efficient then BigDecimal in terms of memory.                 parentDataHolder.add(pos, value).                 break.             default:                 throw new UnsupportedOperationException("Unsupported original type : " + originalType.name() + " for primitive type INT64").         }     } else {         parentDataHolder.add(pos, value).     } }
false;public;1;4;;@Override public Converter getConverter(int fieldIndex) {     return elementConverter. }
false;public;0;4;;@Override public void start() {     list = new ArrayList<>(). }
false;public;0;4;;@Override public void end() {     parentDataHolder.add(pos, list.toArray((T[]) Array.newInstance(elementClass, list.size()))). }
false;public;2;4;;@Override public void add(int fieldIndex, Object object) {     list.add((T) object). }
false;public;1;4;;@Override public Converter getConverter(int fieldIndex) {     return keyValueConverter. }
false;public;0;4;;@Override public void start() {     map = new HashMap<>(). }
false;public;0;4;;@Override public void end() {     parentDataHolder.add(pos, map). }
false;public;1;8;;@Override public Converter getConverter(int fieldIndex) {     if (fieldIndex == 0) {         return keyConverter.     } else {         return valueConverter.     } }
false;public;0;5;;@Override public void start() {     key = null.     value = null. }
false;public;0;4;;@Override public void end() {     map.put(this.key, this.value). }
