commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public Row deserialize(byte[] message) throws IOException {     try {         final JsonNode root = objectMapper.readTree(message).         return convertRow(root, (RowTypeInfo) typeInfo).     } catch (Throwable t) {         throw new IOException("Failed to deserialize JSON object.", t).     } }
false;public;1;4;;@Override public boolean isEndOfStream(Row nextElement) {     return false. }
false;public;0;4;;@Override public TypeInformation<Row> getProducedType() {     return typeInfo. }
true;public;1;3;/**  * Configures the failure behaviour if a JSON field is missing.  *  * <p>By default, a missing field is ignored and the field is set to null.  *  * @param failOnMissingField Flag indicating whether to fail or not on a missing field.  */ ;/**  * Configures the failure behaviour if a JSON field is missing.  *  * <p>By default, a missing field is ignored and the field is set to null.  *  * @param failOnMissingField Flag indicating whether to fail or not on a missing field.  */ public void setFailOnMissingField(boolean failOnMissingField) {     this.failOnMissingField = failOnMissingField. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     final JsonRowDeserializationSchema that = (JsonRowDeserializationSchema) o.     return failOnMissingField == that.failOnMissingField && Objects.equals(typeInfo, that.typeInfo). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(typeInfo, failOnMissingField). }
false;private;2;54;;// -------------------------------------------------------------------------------------------- private Object convert(JsonNode node, TypeInformation<?> info) {     if (info == Types.VOID || node.isNull()) {         return null.     } else if (info == Types.BOOLEAN) {         return node.asBoolean().     } else if (info == Types.STRING) {         return node.asText().     } else if (info == Types.BIG_DEC) {         return node.decimalValue().     } else if (info == Types.BIG_INT) {         return node.bigIntegerValue().     } else if (info == Types.SQL_DATE) {         return Date.valueOf(node.asText()).     } else if (info == Types.SQL_TIME) {         // according to RFC 3339 every full-time must have a timezone.         // until we have full timezone support, we only support UTC.         // users can parse their time as string as a workaround         final String time = node.asText().         if (time.indexOf('Z') < 0 || time.indexOf('.') >= 0) {             throw new IllegalStateException("Invalid time format. Only a time in UTC timezone without milliseconds is supported yet. " + "Format: HH:mm:ss'Z'").         }         return Time.valueOf(time.substring(0, time.length() - 1)).     } else if (info == Types.SQL_TIMESTAMP) {         // according to RFC 3339 every date-time must have a timezone.         // until we have full timezone support, we only support UTC.         // users can parse their time as string as a workaround         final String timestamp = node.asText().         if (timestamp.indexOf('Z') < 0) {             throw new IllegalStateException("Invalid timestamp format. Only a timestamp in UTC timezone is supported yet. " + "Format: yyyy-MM-dd'T'HH:mm:ss.SSS'Z'").         }         return Timestamp.valueOf(timestamp.substring(0, timestamp.length() - 1).replace('T', ' ')).     } else if (info instanceof RowTypeInfo) {         return convertRow(node, (RowTypeInfo) info).     } else if (info instanceof ObjectArrayTypeInfo) {         return convertObjectArray(node, ((ObjectArrayTypeInfo) info).getComponentInfo()).     } else if (info instanceof BasicArrayTypeInfo) {         return convertObjectArray(node, ((BasicArrayTypeInfo) info).getComponentInfo()).     } else if (info instanceof PrimitiveArrayTypeInfo && ((PrimitiveArrayTypeInfo) info).getComponentType() == Types.BYTE) {         return convertByteArray(node).     } else {         // e.g. POJOs         try {             return objectMapper.treeToValue(node, info.getTypeClass()).         } catch (JsonProcessingException e) {             throw new IllegalStateException("Unsupported type information '" + info + "' for node: " + node).         }     } }
false;private;2;22;;private Row convertRow(JsonNode node, RowTypeInfo info) {     final String[] names = info.getFieldNames().     final TypeInformation<?>[] types = info.getFieldTypes().     final Row row = new Row(names.length).     for (int i = 0. i < names.length. i++) {         final String name = names[i].         final JsonNode subNode = node.get(name).         if (subNode == null) {             if (failOnMissingField) {                 throw new IllegalStateException("Could not find field with name '" + name + "'.").             } else {                 row.setField(i, null).             }         } else {             row.setField(i, convert(subNode, types[i])).         }     }     return row. }
false;private;2;7;;private Object convertObjectArray(JsonNode node, TypeInformation<?> elementType) {     final Object[] array = (Object[]) Array.newInstance(elementType.getTypeClass(), node.size()).     for (int i = 0. i < node.size(). i++) {         array[i] = convert(node.get(i), elementType).     }     return array. }
false;private;1;7;;private Object convertByteArray(JsonNode node) {     try {         return node.binaryValue().     } catch (IOException e) {         throw new RuntimeException("Unable to deserialize byte array.", e).     } }
