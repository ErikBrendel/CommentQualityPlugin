commented;modifiers;parameterAmount;loc;comment;code
true;public;0;60;/**  * We first check the connection to the IRC server. If it fails, this test is ignored.  */ ;/**  * We first check the connection to the IRC server. If it fails, this test is ignored.  */ @Test @RetryOnFailure(times = 1) public void testWikipediaEditsSource() throws Exception {     if (canConnect(1, TimeUnit.SECONDS)) {         final Time testTimeout = Time.seconds(60).         final WikipediaEditsSource wikipediaEditsSource = new WikipediaEditsSource().         ExecutorService executorService = null.         try {             executorService = Executors.newSingleThreadExecutor().             BlockingQueue<Object> collectedEvents = new ArrayBlockingQueue<>(1).             AtomicReference<Exception> asyncError = new AtomicReference<>().             // Execute the source in a different thread and collect events into the queue.             // We do this in a separate thread in order to not block the main test thread             // indefinitely in case that something bad happens (like not receiving any             // events)             executorService.execute(() -> {                 try {                     wikipediaEditsSource.run(new CollectingSourceContext<>(collectedEvents)).                 } catch (Exception e) {                     boolean interrupted = e instanceof InterruptedException.                     if (!interrupted) {                         LOG.warn("Failure in WikipediaEditsSource", e).                     }                     asyncError.compareAndSet(null, e).                 }             }).             long deadline = deadlineNanos(testTimeout).             Object event = null.             Exception error = null.             // Check event or error             while (event == null && error == null && System.nanoTime() < deadline) {                 event = collectedEvents.poll(1, TimeUnit.SECONDS).                 error = asyncError.get().             }             if (error != null) {                 // We don't use assertNull, because we want to include the error message                 fail("Failure in WikipediaEditsSource: " + error.getMessage()).             }             assertNotNull("Did not receive a WikipediaEditEvent within the desired timeout", event).             assertTrue("Received unexpected event " + event, event instanceof WikipediaEditEvent).         } finally {             wikipediaEditsSource.cancel().             if (executorService != null) {                 executorService.shutdownNow().                 executorService.awaitTermination(1, TimeUnit.SECONDS).             }         }     } else {         LOG.info("Skipping test, because not able to connect to IRC server.").     } }
false;private;1;3;;private long deadlineNanos(Time testTimeout) {     return System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(testTimeout.toMilliseconds()). }
false;public;1;4;;@Override public void collect(T element) {     events.offer(element). }
false;public;2;5;;@Override public void collectWithTimestamp(T element, long timestamp) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public void emitWatermark(Watermark mark) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public void markAsTemporarilyIdle() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Object getCheckpointLock() {     throw new UnsupportedOperationException(). }
false;public;0;3;;@Override public void close() { }
false;private,static;2;12;;private static boolean canConnect(int timeout, TimeUnit unit) {     String host = WikipediaEditsSource.DEFAULT_HOST.     int port = WikipediaEditsSource.DEFAULT_PORT.     try (Socket s = new Socket()) {         s.connect(new InetSocketAddress(host, port), (int) unit.toMillis(timeout)).         return s.isConnected().     } catch (Throwable ignored) {     }     return false. }
