commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Test public void testCommonSectionCompleteness() throws IOException, ClassNotFoundException {     Map<String, DocumentedOption> documentedOptions = parseDocumentedCommonOptions().     Map<String, ExistingOption> existingOptions = findExistingOptions(optionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null).     compareDocumentedAndExistingOptions(documentedOptions, existingOptions). }
false;public;0;7;;@Test public void testFullReferenceCompleteness() throws IOException, ClassNotFoundException {     Map<String, DocumentedOption> documentedOptions = parseDocumentedOptions().     Map<String, ExistingOption> existingOptions = findExistingOptions(ignored -> true).     compareDocumentedAndExistingOptions(documentedOptions, existingOptions). }
false;private,static;2;42;;private static void compareDocumentedAndExistingOptions(Map<String, DocumentedOption> documentedOptions, Map<String, ExistingOption> existingOptions) {     final Collection<String> problems = new ArrayList<>(0).     // first check that all existing options are properly documented     existingOptions.forEach((key, supposedState) -> {         DocumentedOption documentedState = documentedOptions.remove(key).         // if nothing matches the docs for this option are up-to-date         if (documentedState == null) {             // option is not documented at all             problems.add("Option " + supposedState.key + " in " + supposedState.containingClass + " is not documented.").         } else if (!supposedState.defaultValue.equals(documentedState.defaultValue)) {             // default is outdated             problems.add("Documented default of " + supposedState.key + " in " + supposedState.containingClass + " is outdated. Expected: " + supposedState.defaultValue + " Actual: " + documentedState.defaultValue).         } else if (!supposedState.description.equals(documentedState.description)) {             // description is outdated             problems.add("Documented description of " + supposedState.key + " in " + supposedState.containingClass + " is outdated.").         }     }).     // documentation contains an option that no longer exists     if (!documentedOptions.isEmpty()) {         for (DocumentedOption documentedOption : documentedOptions.values()) {             problems.add("Documented option " + documentedOption.key + " does not exist.").         }     }     if (!problems.isEmpty()) {         StringBuilder sb = new StringBuilder("Documentation is outdated, please regenerate it according to the" + " instructions in flink-docs/README.md.").         sb.append(System.lineSeparator()).         sb.append("\tProblems:").         for (String problem : problems) {             sb.append(System.lineSeparator()).             sb.append("\t\t").             sb.append(problem).         }         Assert.fail(sb.toString()).     } }
false;private,static;0;20;;private static Map<String, DocumentedOption> parseDocumentedCommonOptions() throws IOException {     Path commonSection = Paths.get(System.getProperty("rootDir"), "docs", "_includes", "generated", COMMON_SECTION_FILE_NAME).     return parseDocumentedOptionsFromFile(commonSection).stream().collect(Collectors.toMap(option -> option.key, option -> option, (option1, option2) -> {         if (option1.equals(option2)) {             // we allow multiple instances of ConfigOptions with the same key if they are identical             return option1.         } else {             // we fail here outright as this is not a documentation-completeness problem             if (!option1.defaultValue.equals(option2.defaultValue)) {                 throw new AssertionError("Documentation contains distinct defaults for " + option1.key + " in " + option1.containingFile + " and " + option2.containingFile + '.').             } else {                 throw new AssertionError("Documentation contains distinct descriptions for " + option1.key + " in " + option1.containingFile + " and " + option2.containingFile + '.').             }         }     })). }
false;private,static;0;28;;private static Map<String, DocumentedOption> parseDocumentedOptions() throws IOException {     Path includeFolder = Paths.get(System.getProperty("rootDir"), "docs", "_includes", "generated").toAbsolutePath().     return Files.list(includeFolder).filter(path -> path.getFileName().toString().contains("configuration")).flatMap(file -> {         try {             return parseDocumentedOptionsFromFile(file).stream().         } catch (IOException ignored) {             return Stream.empty().         }     }).collect(Collectors.toMap(option -> option.key, option -> option, (option1, option2) -> {         if (option1.equals(option2)) {             // we allow multiple instances of ConfigOptions with the same key if they are identical             return option1.         } else {             // we fail here outright as this is not a documentation-completeness problem             if (!option1.defaultValue.equals(option2.defaultValue)) {                 throw new AssertionError("Documentation contains distinct defaults for " + option1.key + " in " + option1.containingFile + " and " + option2.containingFile + '.').             } else {                 throw new AssertionError("Documentation contains distinct descriptions for " + option1.key + " in " + option1.containingFile + " and " + option2.containingFile + '.').             }         }     })). }
false;private,static;1;19;;private static Collection<DocumentedOption> parseDocumentedOptionsFromFile(Path file) throws IOException {     Document document = Jsoup.parse(file.toFile(), StandardCharsets.UTF_8.name()).     document.outputSettings().syntax(Document.OutputSettings.Syntax.xml).     document.outputSettings().prettyPrint(false).     return document.getElementsByTag("table").stream().map(element -> element.getElementsByTag("tbody").get(0)).flatMap(element -> element.getElementsByTag("tr").stream()).map(tableRow -> {         String key = tableRow.child(0).text().         String defaultValue = tableRow.child(1).text().         String description = tableRow.child(2).childNodes().stream().map(Object::toString).collect(Collectors.joining()).         return new DocumentedOption(key, defaultValue, description, file.getName(file.getNameCount() - 1)).     }).collect(Collectors.toList()). }
false;private,static;1;28;;private static Map<String, ExistingOption> findExistingOptions(Predicate<ConfigOptionsDocGenerator.OptionWithMetaInfo> predicate) throws IOException, ClassNotFoundException {     Map<String, ExistingOption> existingOptions = new HashMap<>(32).     for (OptionsClassLocation location : LOCATIONS) {         processConfigOptions(System.getProperty("rootDir"), location.getModule(), location.getPackage(), DEFAULT_PATH_PREFIX, optionsClass -> {             List<ConfigOptionsDocGenerator.OptionWithMetaInfo> configOptions = extractConfigOptions(optionsClass).             for (ConfigOptionsDocGenerator.OptionWithMetaInfo option : configOptions) {                 if (predicate.test(option)) {                     String key = option.option.key().                     String defaultValue = stringifyDefault(option).                     String description = htmlFormatter.format(option.option.description()).                     ExistingOption duplicate = existingOptions.put(key, new ExistingOption(key, defaultValue, description, optionsClass)).                     if (duplicate != null) {                         // we fail here outright as this is not a documentation-completeness problem                         if (!(duplicate.description.equals(description))) {                             throw new AssertionError("Ambiguous option " + key + " due to distinct descriptions.").                         } else if (!duplicate.defaultValue.equals(defaultValue)) {                             throw new AssertionError("Ambiguous option " + key + " due to distinct default values (" + defaultValue + " vs " + duplicate.defaultValue + ").").                         }                     }                 }             }         }).     }     return existingOptions. }
false;public;0;4;;@Override public int hashCode() {     return key.hashCode() + defaultValue.hashCode() + description.hashCode(). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (!(obj instanceof Option)) {         return false.     }     Option other = (Option) obj.     return this.key.equals(other.key) && this.defaultValue.equals(other.defaultValue) && this.description.equals(other.description). }
false;public;0;4;;@Override public String toString() {     return "Option(key=" + key + ", default=" + defaultValue + ", description=" + description + ')'. }
