commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;10;/**  * This method generates html tables from set of classes containing {@link ConfigOption ConfigOptions}.  *  * <p>For each class 1 or more html tables will be generated and placed into a separate file, depending on whether  * the class is annotated with {@link ConfigGroups}. The tables contain the key, default value and description for  * every {@link ConfigOption}.  *  * <p>One additional table is generated containing all {@link ConfigOption ConfigOptions} that are annotated with  * {@link org.apache.flink.annotation.docs.Documentation.CommonOption}.  *  * @param args  *  [0] output directory for the generated files  *  [1] project root directory  */ ;/**  * This method generates html tables from set of classes containing {@link ConfigOption ConfigOptions}.  *  * <p>For each class 1 or more html tables will be generated and placed into a separate file, depending on whether  * the class is annotated with {@link ConfigGroups}. The tables contain the key, default value and description for  * every {@link ConfigOption}.  *  * <p>One additional table is generated containing all {@link ConfigOption ConfigOptions} that are annotated with  * {@link org.apache.flink.annotation.docs.Documentation.CommonOption}.  *  * @param args  *  [0] output directory for the generated files  *  [1] project root directory  */ public static void main(String[] args) throws IOException, ClassNotFoundException {     String outputDirectory = args[0].     String rootDir = args[1].     for (OptionsClassLocation location : LOCATIONS) {         createTable(rootDir, location.getModule(), location.getPackage(), outputDirectory, DEFAULT_PATH_PREFIX).     }     generateCommonSection(rootDir, outputDirectory, LOCATIONS, DEFAULT_PATH_PREFIX). }
false;static;4;19;;@VisibleForTesting static void generateCommonSection(String rootDir, String outputDirectory, OptionsClassLocation[] locations, String pathPrefix) throws IOException, ClassNotFoundException {     List<OptionWithMetaInfo> commonOptions = new ArrayList<>(32).     for (OptionsClassLocation location : locations) {         commonOptions.addAll(findCommonOptions(rootDir, location.getModule(), location.getPackage(), pathPrefix)).     }     commonOptions.sort((o1, o2) -> {         int position1 = o1.field.getAnnotation(Documentation.CommonOption.class).position().         int position2 = o2.field.getAnnotation(Documentation.CommonOption.class).position().         if (position1 == position2) {             return o1.option.key().compareTo(o2.option.key()).         } else {             return Integer.compare(position1, position2).         }     }).     String commonHtmlTable = toHtmlTable(commonOptions).     Files.write(Paths.get(outputDirectory, COMMON_SECTION_FILE_NAME), commonHtmlTable.getBytes(StandardCharsets.UTF_8)). }
false;private,static;4;7;;private static Collection<OptionWithMetaInfo> findCommonOptions(String rootDir, String module, String packageName, String pathPrefix) throws IOException, ClassNotFoundException {     Collection<OptionWithMetaInfo> commonOptions = new ArrayList<>(32).     processConfigOptions(rootDir, module, packageName, pathPrefix, optionsClass -> extractConfigOptions(optionsClass).stream().filter(optionWithMetaInfo -> optionWithMetaInfo.field.getAnnotation(Documentation.CommonOption.class) != null).forEachOrdered(commonOptions::add)).     return commonOptions. }
false;private,static;5;20;;private static void createTable(String rootDir, String module, String packageName, String outputDirectory, String pathPrefix) throws IOException, ClassNotFoundException {     processConfigOptions(rootDir, module, packageName, pathPrefix, optionsClass -> {         List<Tuple2<ConfigGroup, String>> tables = generateTablesForClass(optionsClass).         for (Tuple2<ConfigGroup, String> group : tables) {             String name.             if (group.f0 == null) {                 Matcher matcher = CLASS_NAME_PATTERN.matcher(optionsClass.getSimpleName()).                 if (!matcher.matches()) {                     throw new RuntimeException("Pattern did not match for " + optionsClass.getSimpleName() + '.').                 }                 name = matcher.group(CLASS_PREFIX_GROUP).replaceAll("(.)(\\p{Upper})", "$1_$2").toLowerCase().             } else {                 name = group.f0.name().replaceAll("(.)(\\p{Upper})", "$1_$2").toLowerCase().             }             String outputFile = name + "_configuration.html".             Files.write(Paths.get(outputDirectory, outputFile), group.f1.getBytes(StandardCharsets.UTF_8)).         }     }). }
false;static;5;18;;static void processConfigOptions(String rootDir, String module, String packageName, String pathPrefix, ThrowingConsumer<Class<?>, IOException> classConsumer) throws IOException, ClassNotFoundException {     Path configDir = Paths.get(rootDir, module, pathPrefix, packageName.replaceAll("\\.", "/")).     try (DirectoryStream<Path> stream = Files.newDirectoryStream(configDir)) {         for (Path entry : stream) {             String fileName = entry.getFileName().toString().             Matcher matcher = CLASS_NAME_PATTERN.matcher(fileName).             if (matcher.matches()) {                 final String className = packageName + '.' + matcher.group(CLASS_NAME_GROUP).                 if (!EXCLUSIONS.contains(className)) {                     Class<?> optionsClass = Class.forName(className).                     classConsumer.accept(optionsClass).                 }             }         }     } }
false;static;1;24;;@VisibleForTesting static List<Tuple2<ConfigGroup, String>> generateTablesForClass(Class<?> optionsClass) {     ConfigGroups configGroups = optionsClass.getAnnotation(ConfigGroups.class).     List<OptionWithMetaInfo> allOptions = extractConfigOptions(optionsClass).     List<Tuple2<ConfigGroup, String>> tables.     if (configGroups != null) {         tables = new ArrayList<>(configGroups.groups().length + 1).         Tree tree = new Tree(configGroups.groups(), allOptions).         for (ConfigGroup group : configGroups.groups()) {             List<OptionWithMetaInfo> configOptions = tree.findConfigOptions(group).             sortOptions(configOptions).             tables.add(Tuple2.of(group, toHtmlTable(configOptions))).         }         List<OptionWithMetaInfo> configOptions = tree.getDefaultOptions().         sortOptions(configOptions).         tables.add(Tuple2.of(null, toHtmlTable(configOptions))).     } else {         sortOptions(allOptions).         tables = Collections.singletonList(Tuple2.of(null, toHtmlTable(allOptions))).     }     return tables. }
false;static;1;15;;static List<OptionWithMetaInfo> extractConfigOptions(Class<?> clazz) {     try {         List<OptionWithMetaInfo> configOptions = new ArrayList<>(8).         Field[] fields = clazz.getFields().         for (Field field : fields) {             if (isConfigOption(field) && shouldBeDocumented(field)) {                 configOptions.add(new OptionWithMetaInfo((ConfigOption<?>) field.get(null), field)).             }         }         return configOptions.     } catch (Exception e) {         throw new RuntimeException("Failed to extract config options from class " + clazz + '.', e).     } }
false;private,static;1;3;;private static boolean isConfigOption(Field field) {     return field.getType().equals(ConfigOption.class). }
false;private,static;1;4;;private static boolean shouldBeDocumented(Field field) {     return field.getAnnotation(Deprecated.class) == null && field.getAnnotation(Documentation.ExcludeFromDocumentation.class) == null. }
true;private,static;1;21;/**  * Transforms this configuration group into HTML formatted table.  * Options are sorted alphabetically by key.  *  * @param options list of options to include in this group  * @return string containing HTML formatted table  */ ;/**  * Transforms this configuration group into HTML formatted table.  * Options are sorted alphabetically by key.  *  * @param options list of options to include in this group  * @return string containing HTML formatted table  */ private static String toHtmlTable(final List<OptionWithMetaInfo> options) {     StringBuilder htmlTable = new StringBuilder().     htmlTable.append("<table class=\"table table-bordered\">\n").     htmlTable.append("    <thead>\n").     htmlTable.append("        <tr>\n").     htmlTable.append("            <th class=\"text-left\" style=\"width: 20%\">Key</th>\n").     htmlTable.append("            <th class=\"text-left\" style=\"width: 15%\">Default</th>\n").     htmlTable.append("            <th class=\"text-left\" style=\"width: 65%\">Description</th>\n").     htmlTable.append("        </tr>\n").     htmlTable.append("    </thead>\n").     htmlTable.append("    <tbody>\n").     for (OptionWithMetaInfo option : options) {         htmlTable.append(toHtmlString(option)).     }     htmlTable.append("    </tbody>\n").     htmlTable.append("</table>\n").     return htmlTable.toString(). }
true;private,static;1;11;/**  * Transforms option to table row.  *  * @param optionWithMetaInfo option to transform  * @return row with the option description  */ ;/**  * Transforms option to table row.  *  * @param optionWithMetaInfo option to transform  * @return row with the option description  */ private static String toHtmlString(final OptionWithMetaInfo optionWithMetaInfo) {     ConfigOption<?> option = optionWithMetaInfo.option.     String defaultValue = stringifyDefault(optionWithMetaInfo).     return "" + "        <tr>\n" + "            <td><h5>" + escapeCharacters(option.key()) + "</h5></td>\n" + "            <td style=\"word-wrap: break-word.\">" + escapeCharacters(addWordBreakOpportunities(defaultValue)) + "</td>\n" + "            <td>" + formatter.format(option.description()) + "</td>\n" + "        </tr>\n". }
false;static;1;16;;static String stringifyDefault(OptionWithMetaInfo optionWithMetaInfo) {     ConfigOption<?> option = optionWithMetaInfo.option.     Documentation.OverrideDefault overrideDocumentedDefault = optionWithMetaInfo.field.getAnnotation(Documentation.OverrideDefault.class).     if (overrideDocumentedDefault != null) {         return overrideDocumentedDefault.value().     } else {         Object value = option.defaultValue().         if (value instanceof String) {             if (((String) value).isEmpty()) {                 return "(none)".             }             return "\"" + value + "\"".         }         return value == null ? "(none)" : value.toString().     } }
false;private,static;1;5;;private static String addWordBreakOpportunities(String value) {     return value.replace(".", ".<wbr>"). }
false;private,static;1;3;;private static void sortOptions(List<OptionWithMetaInfo> configOptions) {     configOptions.sort(Comparator.comparing(option -> option.option.key())). }
false;;1;4;;List<OptionWithMetaInfo> findConfigOptions(ConfigGroup configGroup) {     Node groupRoot = findGroupRoot(configGroup.keyPrefix()).     return groupRoot.getConfigOptions(). }
false;;0;3;;List<OptionWithMetaInfo> getDefaultOptions() {     return root.getConfigOptions(). }
false;private;1;17;;private Node findGroupRoot(String key) {     String[] keyComponents = key.split("\\.").     Node lastRootNode = root.     Node currentNode = root.     for (String keyComponent : keyComponents) {         final Node childNode = currentNode.getChild(keyComponent).         if (childNode == null) {             break.         } else {             currentNode = childNode.             if (currentNode.isGroupRoot()) {                 lastRootNode = currentNode.             }         }     }     return lastRootNode. }
false;private;1;8;;private Node addChild(String keyComponent) {     Node child = children.get(keyComponent).     if (child == null) {         child = new Node().         children.put(keyComponent, child).     }     return child. }
false;private;1;3;;private Node getChild(String keyComponent) {     return children.get(keyComponent). }
false;private;1;3;;private void assignOption(OptionWithMetaInfo option) {     configOptions.add(option). }
false;private;0;3;;private boolean isGroupRoot() {     return isGroupRoot. }
false;private;0;3;;private void markAsGroupRoot() {     this.isGroupRoot = true. }
false;private;0;3;;private List<OptionWithMetaInfo> getConfigOptions() {     return configOptions. }
