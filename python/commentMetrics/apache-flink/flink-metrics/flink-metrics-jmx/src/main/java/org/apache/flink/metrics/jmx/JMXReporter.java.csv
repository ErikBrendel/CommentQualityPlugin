commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public String filterCharacters(String input) {     return replaceInvalidChars(input). }
false;public;1;31;;// ------------------------------------------------------------------------ // life cycle // ------------------------------------------------------------------------ @Override public void open(MetricConfig config) {     String portsConfig = config.getString(ARG_PORT, null).     if (portsConfig != null) {         Iterator<Integer> ports = NetUtils.getPortRangeFromString(portsConfig).         JMXServer server = new JMXServer().         while (ports.hasNext()) {             int port = ports.next().             try {                 server.start(port).                 LOG.info("Started JMX server on port " + port + ".").                 // only set our field if the server was actually started                 jmxServer = server.                 break.             } catch (IOException ioe) {                 // assume port conflict                 LOG.debug("Could not start JMX server on port " + port + ".", ioe).                 try {                     server.stop().                 } catch (Exception e) {                     LOG.debug("Could not stop JMX server.", e).                 }             }         }         if (jmxServer == null) {             throw new RuntimeException("Could not start JMX server on any configured port. Ports: " + portsConfig).         }     }     LOG.info("Configured JMXReporter with {port:{}}", portsConfig). }
false;public;0;10;;@Override public void close() {     if (jmxServer != null) {         try {             jmxServer.stop().         } catch (IOException e) {             LOG.error("Failed to stop JMX server.", e).         }     } }
false;public;0;6;;public int getPort() {     if (jmxServer == null) {         throw new NullPointerException("No server was opened. Did you specify a port?").     }     return jmxServer.port. }
false;public;3;46;;// ------------------------------------------------------------------------ // adding / removing metrics // ------------------------------------------------------------------------ @Override public void notifyOfAddedMetric(Metric metric, String metricName, MetricGroup group) {     final String domain = generateJmxDomain(metricName, group).     final Hashtable<String, String> table = generateJmxTable(group.getAllVariables()).     AbstractBean jmxMetric.     ObjectName jmxName.     try {         jmxName = new ObjectName(domain, table).     } catch (MalformedObjectNameException e) {         /**          * There is an implementation error on our side if this occurs. Either the domain was modified and no longer          * conforms to the JMX domain rules or the table wasn't properly generated.          */         LOG.debug("Implementation error. The domain or table does not conform to JMX rules.", e).         return.     }     if (metric instanceof Gauge) {         jmxMetric = new JmxGauge((Gauge<?>) metric).     } else if (metric instanceof Counter) {         jmxMetric = new JmxCounter((Counter) metric).     } else if (metric instanceof Histogram) {         jmxMetric = new JmxHistogram((Histogram) metric).     } else if (metric instanceof Meter) {         jmxMetric = new JmxMeter((Meter) metric).     } else {         LOG.error("Cannot add unknown metric type: {}. This indicates that the metric type " + "is not supported by this reporter.", metric.getClass().getName()).         return.     }     try {         synchronized (this) {             mBeanServer.registerMBean(jmxMetric, jmxName).             registeredMetrics.put(metric, jmxName).         }     } catch (NotCompliantMBeanException e) {         // implementation error on our side         LOG.debug("Metric did not comply with JMX MBean rules.", e).     } catch (InstanceAlreadyExistsException e) {         LOG.warn("A metric with the name " + jmxName + " was already registered.", e).     } catch (Throwable t) {         LOG.warn("Failed to register metric", t).     } }
false;public;3;19;;@Override public void notifyOfRemovedMetric(Metric metric, String metricName, MetricGroup group) {     try {         synchronized (this) {             final ObjectName jmxName = registeredMetrics.remove(metric).             // remove the metric if it is known. if it is not known, ignore the request             if (jmxName != null) {                 mBeanServer.unregisterMBean(jmxName).             }         }     } catch (InstanceNotFoundException e) {     // alright then     } catch (Throwable t) {         // never propagate exceptions - the metrics reporter should not affect the stability         // of the running system         LOG.error("Un-registering metric failed", t).     } }
false;static;1;7;;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ static Hashtable<String, String> generateJmxTable(Map<String, String> variables) {     Hashtable<String, String> ht = new Hashtable<>(variables.size()).     for (Map.Entry<String, String> variable : variables.entrySet()) {         ht.put(replaceInvalidChars(variable.getKey()), replaceInvalidChars(variable.getValue())).     }     return ht. }
false;static;2;3;;static String generateJmxDomain(String metricName, MetricGroup group) {     return JMX_DOMAIN_PREFIX + ((FrontMetricGroup<AbstractMetricGroup<?>>) group).getLogicalScope(CHARACTER_FILTER, '.') + '.' + metricName. }
true;static;1;47;/**  * Lightweight method to replace unsupported characters.  * If the string does not contain any unsupported characters, this method creates no  * new string (and in fact no new objects at all).  *  * <p>Replacements:  *  * <ul>  *     <li>{@code "} is removed</li>  *     <li>{@code space} is replaced by {@code _} (underscore)</li>  *     <li>{@code , = . : ? ' *} are replaced by {@code -} (hyphen)</li>  * </ul>  */ ;/**  * Lightweight method to replace unsupported characters.  * If the string does not contain any unsupported characters, this method creates no  * new string (and in fact no new objects at all).  *  * <p>Replacements:  *  * <ul>  *     <li>{@code "} is removed</li>  *     <li>{@code space} is replaced by {@code _} (underscore)</li>  *     <li>{@code , = . : ? ' *} are replaced by {@code -} (hyphen)</li>  * </ul>  */ static String replaceInvalidChars(String str) {     char[] chars = null.     final int strLen = str.length().     int pos = 0.     for (int i = 0. i < strLen. i++) {         final char c = str.charAt(i).         switch(c) {             case '>':             case '<':             case '"':                 // remove character by not moving cursor                 if (chars == null) {                     chars = str.toCharArray().                 }                 break.             case ' ':                 if (chars == null) {                     chars = str.toCharArray().                 }                 chars[pos++] = '_'.                 break.             case ',':             case '=':             case '.':             case ':':             case '?':             case '\'':             case '*':                 if (chars == null) {                     chars = str.toCharArray().                 }                 chars[pos++] = '-'.                 break.             default:                 if (chars != null) {                     chars[pos] = c.                 }                 pos++.         }     }     return chars == null ? str : new String(chars, 0, pos). }
false;;0;1;;long getCount().
false;public;0;4;;@Override public long getCount() {     return counter.getCount(). }
false;;0;1;;Object getValue().
false;public;0;4;;@Override public Object getValue() {     return gauge.getValue(). }
false;;0;1;;long getCount().
false;;0;1;;double getMean().
false;;0;1;;double getStdDev().
false;;0;1;;long getMax().
false;;0;1;;long getMin().
false;;0;1;;double getMedian().
false;;0;1;;double get75thPercentile().
false;;0;1;;double get95thPercentile().
false;;0;1;;double get98thPercentile().
false;;0;1;;double get99thPercentile().
false;;0;1;;double get999thPercentile().
false;public;0;4;;@Override public long getCount() {     return histogram.getCount(). }
false;public;0;4;;@Override public double getMean() {     return histogram.getStatistics().getMean(). }
false;public;0;4;;@Override public double getStdDev() {     return histogram.getStatistics().getStdDev(). }
false;public;0;4;;@Override public long getMax() {     return histogram.getStatistics().getMax(). }
false;public;0;4;;@Override public long getMin() {     return histogram.getStatistics().getMin(). }
false;public;0;4;;@Override public double getMedian() {     return histogram.getStatistics().getQuantile(0.5). }
false;public;0;4;;@Override public double get75thPercentile() {     return histogram.getStatistics().getQuantile(0.75). }
false;public;0;4;;@Override public double get95thPercentile() {     return histogram.getStatistics().getQuantile(0.95). }
false;public;0;4;;@Override public double get98thPercentile() {     return histogram.getStatistics().getQuantile(0.98). }
false;public;0;4;;@Override public double get99thPercentile() {     return histogram.getStatistics().getQuantile(0.99). }
false;public;0;4;;@Override public double get999thPercentile() {     return histogram.getStatistics().getQuantile(0.999). }
false;;0;1;;double getRate().
false;;0;1;;long getCount().
false;public;0;4;;@Override public double getRate() {     return meter.getRate(). }
false;public;0;4;;@Override public long getCount() {     return meter.getCount(). }
false;public;1;9;;public void start(int port) throws IOException {     if (rmiRegistry != null && connector != null) {         LOG.debug("JMXServer is already running.").         return.     }     startRmiRegistry(port).     startJmxService(port).     this.port = port. }
true;private;1;3;/**  * Starts an RMI Registry that allows clients to lookup the JMX IP/port.  *  * @param port rmi port to use  * @throws IOException  */ ;/**  * Starts an RMI Registry that allows clients to lookup the JMX IP/port.  *  * @param port rmi port to use  * @throws IOException  */ private void startRmiRegistry(int port) throws IOException {     rmiRegistry = LocateRegistry.createRegistry(port). }
true;private;1;13;/**  * Starts a JMX connector that allows (un)registering MBeans with the MBean server and RMI invocations.  *  * @param port jmx port to use  * @throws IOException  */ ;/**  * Starts a JMX connector that allows (un)registering MBeans with the MBean server and RMI invocations.  *  * @param port jmx port to use  * @throws IOException  */ private void startJmxService(int port) throws IOException {     String serviceUrl = "service:jmx:rmi://localhost:" + port + "/jndi/rmi://localhost:" + port + "/jmxrmi".     JMXServiceURL url.     try {         url = new JMXServiceURL(serviceUrl).     } catch (MalformedURLException e) {         throw new IllegalArgumentException("Malformed service url created " + serviceUrl, e).     }     connector = JMXConnectorServerFactory.newJMXConnectorServer(url, null, ManagementFactory.getPlatformMBeanServer()).     connector.start(). }
false;public;0;18;;public void stop() throws IOException {     if (connector != null) {         try {             connector.stop().         } finally {             connector = null.         }     }     if (rmiRegistry != null) {         try {             UnicastRemoteObject.unexportObject(rmiRegistry, true).         } catch (NoSuchObjectException e) {             throw new IOException("Could not un-export our RMI registry", e).         } finally {             rmiRegistry = null.         }     } }
