commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public String filterCharacters(String input) {     return replaceInvalidChars(input). }
false;static;1;6;;@VisibleForTesting static String replaceInvalidChars(final String input) {     // Only [a-zA-Z0-9:_] are valid in metric names, any other characters should be sanitized to an underscore.     return UNALLOWED_CHAR_PATTERN.matcher(input).replaceAll("_"). }
false;public;1;9;;@Override public void open(MetricConfig config) {     boolean filterLabelValueCharacters = config.getBoolean(FILTER_LABEL_VALUE_CHARACTER.key(), FILTER_LABEL_VALUE_CHARACTER.defaultValue()).     if (!filterLabelValueCharacters) {         labelValueCharactersFilter = input -> input.     } }
false;public;0;4;;@Override public void close() {     CollectorRegistry.defaultRegistry.clear(). }
false;public;3;34;;@Override public void notifyOfAddedMetric(final Metric metric, final String metricName, final MetricGroup group) {     List<String> dimensionKeys = new LinkedList<>().     List<String> dimensionValues = new LinkedList<>().     for (final Map.Entry<String, String> dimension : group.getAllVariables().entrySet()) {         final String key = dimension.getKey().         dimensionKeys.add(CHARACTER_FILTER.filterCharacters(key.substring(1, key.length() - 1))).         dimensionValues.add(labelValueCharactersFilter.filterCharacters(dimension.getValue())).     }     final String scopedMetricName = getScopedName(metricName, group).     final String helpString = metricName + " (scope: " + getLogicalScope(group) + ")".     final Collector collector.     Integer count = 0.     synchronized (this) {         if (collectorsWithCountByMetricName.containsKey(scopedMetricName)) {             final AbstractMap.SimpleImmutableEntry<Collector, Integer> collectorWithCount = collectorsWithCountByMetricName.get(scopedMetricName).             collector = collectorWithCount.getKey().             count = collectorWithCount.getValue().         } else {             collector = createCollector(metric, dimensionKeys, dimensionValues, scopedMetricName, helpString).             try {                 collector.register().             } catch (Exception e) {                 log.warn("There was a problem registering metric {}.", metricName, e).             }         }         addMetric(metric, dimensionValues, collector).         collectorsWithCountByMetricName.put(scopedMetricName, new AbstractMap.SimpleImmutableEntry<>(collector, count + 1)).     } }
false;private,static;2;3;;private static String getScopedName(String metricName, MetricGroup group) {     return SCOPE_PREFIX + getLogicalScope(group) + SCOPE_SEPARATOR + CHARACTER_FILTER.filterCharacters(metricName). }
false;private;5;18;;private Collector createCollector(Metric metric, List<String> dimensionKeys, List<String> dimensionValues, String scopedMetricName, String helpString) {     Collector collector.     if (metric instanceof Gauge || metric instanceof Counter || metric instanceof Meter) {         collector = io.prometheus.client.Gauge.build().name(scopedMetricName).help(helpString).labelNames(toArray(dimensionKeys)).create().     } else if (metric instanceof Histogram) {         collector = new HistogramSummaryProxy((Histogram) metric, scopedMetricName, helpString, dimensionKeys, dimensionValues).     } else {         log.warn("Cannot create collector for unknown metric type: {}. This indicates that the metric type is not supported by this reporter.", metric.getClass().getName()).         collector = null.     }     return collector. }
false;private;3;14;;private void addMetric(Metric metric, List<String> dimensionValues, Collector collector) {     if (metric instanceof Gauge) {         ((io.prometheus.client.Gauge) collector).setChild(gaugeFrom((Gauge) metric), toArray(dimensionValues)).     } else if (metric instanceof Counter) {         ((io.prometheus.client.Gauge) collector).setChild(gaugeFrom((Counter) metric), toArray(dimensionValues)).     } else if (metric instanceof Meter) {         ((io.prometheus.client.Gauge) collector).setChild(gaugeFrom((Meter) metric), toArray(dimensionValues)).     } else if (metric instanceof Histogram) {         ((HistogramSummaryProxy) collector).addChild((Histogram) metric, dimensionValues).     } else {         log.warn("Cannot add unknown metric type: {}. This indicates that the metric type is not supported by this reporter.", metric.getClass().getName()).     } }
false;private;3;14;;private void removeMetric(Metric metric, List<String> dimensionValues, Collector collector) {     if (metric instanceof Gauge) {         ((io.prometheus.client.Gauge) collector).remove(toArray(dimensionValues)).     } else if (metric instanceof Counter) {         ((io.prometheus.client.Gauge) collector).remove(toArray(dimensionValues)).     } else if (metric instanceof Meter) {         ((io.prometheus.client.Gauge) collector).remove(toArray(dimensionValues)).     } else if (metric instanceof Histogram) {         ((HistogramSummaryProxy) collector).remove(dimensionValues).     } else {         log.warn("Cannot remove unknown metric type: {}. This indicates that the metric type is not supported by this reporter.", metric.getClass().getName()).     } }
false;public;3;28;;@Override public void notifyOfRemovedMetric(final Metric metric, final String metricName, final MetricGroup group) {     List<String> dimensionValues = new LinkedList<>().     for (final Map.Entry<String, String> dimension : group.getAllVariables().entrySet()) {         dimensionValues.add(labelValueCharactersFilter.filterCharacters(dimension.getValue())).     }     final String scopedMetricName = getScopedName(metricName, group).     synchronized (this) {         final AbstractMap.SimpleImmutableEntry<Collector, Integer> collectorWithCount = collectorsWithCountByMetricName.get(scopedMetricName).         final Integer count = collectorWithCount.getValue().         final Collector collector = collectorWithCount.getKey().         removeMetric(metric, dimensionValues, collector).         if (count == 1) {             try {                 CollectorRegistry.defaultRegistry.unregister(collector).             } catch (Exception e) {                 log.warn("There was a problem unregistering metric {}.", scopedMetricName, e).             }             collectorsWithCountByMetricName.remove(scopedMetricName).         } else {             collectorsWithCountByMetricName.put(scopedMetricName, new AbstractMap.SimpleImmutableEntry<>(collector, count - 1)).         }     } }
false;private,static;1;4;;@SuppressWarnings("unchecked") private static String getLogicalScope(MetricGroup group) {     return ((FrontMetricGroup<AbstractMetricGroup<?>>) group).getLogicalScope(CHARACTER_FILTER, SCOPE_SEPARATOR). }
false;public;0;20;;@Override public double get() {     final Object value = gauge.getValue().     if (value == null) {         log.debug("Gauge {} is null-valued, defaulting to 0.", gauge).         return 0.     }     if (value instanceof Double) {         return (double) value.     }     if (value instanceof Number) {         return ((Number) value).doubleValue().     }     if (value instanceof Boolean) {         return ((Boolean) value) ? 1 : 0.     }     log.debug("Invalid type for Gauge {}: {}, only number types and booleans are supported by this reporter.", gauge, value.getClass().getName()).     return 0. }
false;;1;25;;@VisibleForTesting io.prometheus.client.Gauge.Child gaugeFrom(Gauge gauge) {     return new io.prometheus.client.Gauge.Child() {          @Override         public double get() {             final Object value = gauge.getValue().             if (value == null) {                 log.debug("Gauge {} is null-valued, defaulting to 0.", gauge).                 return 0.             }             if (value instanceof Double) {                 return (double) value.             }             if (value instanceof Number) {                 return ((Number) value).doubleValue().             }             if (value instanceof Boolean) {                 return ((Boolean) value) ? 1 : 0.             }             log.debug("Invalid type for Gauge {}: {}, only number types and booleans are supported by this reporter.", gauge, value.getClass().getName()).             return 0.         }     }. }
false;public;0;4;;@Override public double get() {     return (double) counter.getCount(). }
false;private,static;1;8;;private static io.prometheus.client.Gauge.Child gaugeFrom(Counter counter) {     return new io.prometheus.client.Gauge.Child() {          @Override         public double get() {             return (double) counter.getCount().         }     }. }
false;public;0;4;;@Override public double get() {     return meter.getRate(). }
false;private,static;1;8;;private static io.prometheus.client.Gauge.Child gaugeFrom(Meter meter) {     return new io.prometheus.client.Gauge.Child() {          @Override         public double get() {             return meter.getRate().         }     }. }
false;public;0;11;;@Override public List<MetricFamilySamples> collect() {     // We cannot use SummaryMetricFamily because it is impossible to get a sum of all values (at least for Dropwizard histograms,     // whose snapshot's values array only holds a sample of recent values).     List<MetricFamilySamples.Sample> samples = new LinkedList<>().     for (Map.Entry<List<String>, Histogram> labelValuesToHistogram : histogramsByLabelValues.entrySet()) {         addSamples(labelValuesToHistogram.getKey(), labelValuesToHistogram.getValue(), samples).     }     return Collections.singletonList(new MetricFamilySamples(metricName, Type.SUMMARY, helpString, samples)). }
false;;2;3;;void addChild(final Histogram histogram, final List<String> labelValues) {     histogramsByLabelValues.put(labelValues, histogram). }
false;;1;3;;void remove(final List<String> labelValues) {     histogramsByLabelValues.remove(labelValues). }
false;private;3;9;;private void addSamples(final List<String> labelValues, final Histogram histogram, final List<MetricFamilySamples.Sample> samples) {     samples.add(new MetricFamilySamples.Sample(metricName + "_count", labelNamesWithQuantile.subList(0, labelNamesWithQuantile.size() - 1), labelValues, histogram.getCount())).     for (final Double quantile : QUANTILES) {         samples.add(new MetricFamilySamples.Sample(metricName, labelNamesWithQuantile, addToList(labelValues, quantile.toString()), histogram.getStatistics().getQuantile(quantile))).     } }
false;private,static;2;5;;private static List<String> addToList(List<String> list, String element) {     final List<String> result = new ArrayList<>(list).     result.add(element).     return result. }
false;private,static;1;3;;private static String[] toArray(List<String> list) {     return list.toArray(new String[list.size()]). }
