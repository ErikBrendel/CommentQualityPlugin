commented;modifiers;parameterAmount;loc;comment;code
false;;0;4;;// ------------------------------------------------------------------------ // Getters // ------------------------------------------------------------------------ @VisibleForTesting Map<Counter, String> getCounters() {     return counters. }
false;;0;4;;@VisibleForTesting Map<Meter, String> getMeters() {     return meters. }
false;;0;4;;@VisibleForTesting Map<Gauge<?>, String> getGauges() {     return gauges. }
false;;0;4;;@VisibleForTesting Map<Histogram, String> getHistograms() {     return histograms. }
false;public;1;4;;// ------------------------------------------------------------------------ // life cycle // ------------------------------------------------------------------------ @Override public void open(MetricConfig config) {     this.reporter = getReporter(config). }
false;public;0;4;;@Override public void close() {     this.reporter.stop(). }
false;public;3;36;;// ------------------------------------------------------------------------ // adding / removing metrics // ------------------------------------------------------------------------ @Override public void notifyOfAddedMetric(Metric metric, String metricName, MetricGroup group) {     final String fullName = group.getMetricIdentifier(metricName, this).     synchronized (this) {         if (metric instanceof Counter) {             counters.put((Counter) metric, fullName).             registry.register(fullName, new FlinkCounterWrapper((Counter) metric)).         } else if (metric instanceof Gauge) {             gauges.put((Gauge<?>) metric, fullName).             registry.register(fullName, FlinkGaugeWrapper.fromGauge((Gauge<?>) metric)).         } else if (metric instanceof Histogram) {             Histogram histogram = (Histogram) metric.             histograms.put(histogram, fullName).             if (histogram instanceof DropwizardHistogramWrapper) {                 registry.register(fullName, ((DropwizardHistogramWrapper) histogram).getDropwizardHistogram()).             } else {                 registry.register(fullName, new FlinkHistogramWrapper(histogram)).             }         } else if (metric instanceof Meter) {             Meter meter = (Meter) metric.             meters.put(meter, fullName).             if (meter instanceof DropwizardMeterWrapper) {                 registry.register(fullName, ((DropwizardMeterWrapper) meter).getDropwizardMeter()).             } else {                 registry.register(fullName, new FlinkMeterWrapper(meter)).             }         } else {             log.warn("Cannot add metric of type {}. This indicates that the reporter " + "does not support this metric type.", metric.getClass().getName()).         }     } }
false;public;3;22;;@Override public void notifyOfRemovedMetric(Metric metric, String metricName, MetricGroup group) {     synchronized (this) {         String fullName.         if (metric instanceof Counter) {             fullName = counters.remove(metric).         } else if (metric instanceof Gauge) {             fullName = gauges.remove(metric).         } else if (metric instanceof Histogram) {             fullName = histograms.remove(metric).         } else if (metric instanceof Meter) {             fullName = meters.remove(metric).         } else {             fullName = null.         }         if (fullName != null) {             registry.remove(fullName).         }     } }
false;public;1;31;;@Override public String filterCharacters(String metricName) {     char[] chars = null.     final int strLen = metricName.length().     int pos = 0.     for (int i = 0. i < strLen. i++) {         final char c = metricName.charAt(i).         switch(c) {             case '.':                 if (chars == null) {                     chars = metricName.toCharArray().                 }                 chars[pos++] = '-'.                 break.             case '"':                 if (chars == null) {                     chars = metricName.toCharArray().                 }                 break.             default:                 if (chars != null) {                     chars[pos] = c.                 }                 pos++.         }     }     return chars == null ? metricName : new String(chars, 0, pos). }
false;public;0;13;;// ------------------------------------------------------------------------ // scheduled reporting // ------------------------------------------------------------------------ @Override public void report() {     // we do not need to lock here, because the dropwizard registry is     // internally a concurrent map     @SuppressWarnings("rawtypes")     final SortedMap<String, com.codahale.metrics.Gauge> gauges = registry.getGauges().     final SortedMap<String, com.codahale.metrics.Counter> counters = registry.getCounters().     final SortedMap<String, com.codahale.metrics.Histogram> histograms = registry.getHistograms().     final SortedMap<String, com.codahale.metrics.Meter> meters = registry.getMeters().     final SortedMap<String, com.codahale.metrics.Timer> timers = registry.getTimers().     this.reporter.report(gauges, counters, histograms, meters, timers). }
false;public,abstract;1;1;;public abstract ScheduledReporter getReporter(MetricConfig config).
