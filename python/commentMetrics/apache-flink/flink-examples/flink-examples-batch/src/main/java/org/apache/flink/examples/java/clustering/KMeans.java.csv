commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;44;;public static void main(String[] args) throws Exception {     // Checking input parameters     final ParameterTool params = ParameterTool.fromArgs(args).     // set up execution environment     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     // make parameters available in the web interface     env.getConfig().setGlobalJobParameters(params).     // get input data:     // read the points and centroids from the provided paths or fall back to default data     DataSet<Point> points = getPointDataSet(params, env).     DataSet<Centroid> centroids = getCentroidDataSet(params, env).     // set number of bulk iterations for KMeans algorithm     IterativeDataSet<Centroid> loop = centroids.iterate(params.getInt("iterations", 10)).     DataSet<Centroid> newCentroids = points.map(new SelectNearestCenter()).withBroadcastSet(loop, "centroids").map(new CountAppender()).groupBy(0).reduce(new CentroidAccumulator()).map(new CentroidAverager()).     // feed new centroids back into next iteration     DataSet<Centroid> finalCentroids = loop.closeWith(newCentroids).     DataSet<Tuple2<Integer, Point>> clusteredPoints = points.map(new SelectNearestCenter()).withBroadcastSet(finalCentroids, "centroids").     // emit result     if (params.has("output")) {         clusteredPoints.writeAsCsv(params.get("output"), "\n", " ").         // since file sinks are lazy, we trigger the execution explicitly         env.execute("KMeans Example").     } else {         System.out.println("Printing result to stdout. Use --output to specify output path.").         clusteredPoints.print().     } }
false;private,static;2;13;;// ************************************************************************* // DATA SOURCE READING (POINTS AND CENTROIDS) // ************************************************************************* private static DataSet<Centroid> getCentroidDataSet(ParameterTool params, ExecutionEnvironment env) {     DataSet<Centroid> centroids.     if (params.has("centroids")) {         centroids = env.readCsvFile(params.get("centroids")).fieldDelimiter(" ").pojoType(Centroid.class, "id", "x", "y").     } else {         System.out.println("Executing K-Means example with default centroid data set.").         System.out.println("Use --centroids to specify file input.").         centroids = KMeansData.getDefaultCentroidDataSet(env).     }     return centroids. }
false;private,static;2;14;;private static DataSet<Point> getPointDataSet(ParameterTool params, ExecutionEnvironment env) {     DataSet<Point> points.     if (params.has("points")) {         // read points from CSV file         points = env.readCsvFile(params.get("points")).fieldDelimiter(" ").pojoType(Point.class, "x", "y").     } else {         System.out.println("Executing K-Means example with default point data set.").         System.out.println("Use --points to specify file input.").         points = KMeansData.getDefaultPointDataSet(env).     }     return points. }
false;public;1;5;;public Point add(Point other) {     x += other.x.     y += other.y.     return this. }
false;public;1;5;;public Point div(long val) {     x /= val.     y /= val.     return this. }
false;public;1;3;;public double euclideanDistance(Point other) {     return Math.sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y)). }
false;public;0;3;;public void clear() {     x = y = 0.0. }
false;public;0;4;;@Override public String toString() {     return x + " " + y. }
false;public;0;4;;@Override public String toString() {     return id + " " + super.toString(). }
true;public;1;4;/**  * Reads the centroid values from a broadcast variable into a collection.  */ ;/**  * Reads the centroid values from a broadcast variable into a collection.  */ @Override public void open(Configuration parameters) throws Exception {     this.centroids = getRuntimeContext().getBroadcastVariable("centroids"). }
false;public;1;21;;@Override public Tuple2<Integer, Point> map(Point p) throws Exception {     double minDistance = Double.MAX_VALUE.     int closestCentroidId = -1.     // check all cluster centers     for (Centroid centroid : centroids) {         // compute distance         double distance = p.euclideanDistance(centroid).         // update nearest cluster if necessary         if (distance < minDistance) {             minDistance = distance.             closestCentroidId = centroid.id.         }     }     // emit a new record with the center id and the data point.     return new Tuple2<>(closestCentroidId, p). }
false;public;1;4;;@Override public Tuple3<Integer, Point, Long> map(Tuple2<Integer, Point> t) {     return new Tuple3<>(t.f0, t.f1, 1L). }
false;public;2;4;;@Override public Tuple3<Integer, Point, Long> reduce(Tuple3<Integer, Point, Long> val1, Tuple3<Integer, Point, Long> val2) {     return new Tuple3<>(val1.f0, val1.f1.add(val2.f1), val1.f2 + val2.f2). }
false;public;1;4;;@Override public Centroid map(Tuple3<Integer, Point, Long> value) {     return new Centroid(value.f0, value.f1.div(value.f2)). }
