commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;55;;// ************************************************************************* // PROGRAM // ************************************************************************* public static void main(String[] args) throws Exception {     // Checking input parameters     final ParameterTool params = ParameterTool.fromArgs(args).     // set up input for the stream of integer pairs     // obtain execution environment and set setBufferTimeout to 1 to enable     // continuous flushing of the output buffers (lowest latency)     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setBufferTimeout(1).     // make parameters available in the web interface     env.getConfig().setGlobalJobParameters(params).     // create input stream of integer pairs     DataStream<Tuple2<Integer, Integer>> inputStream.     if (params.has("input")) {         inputStream = env.readTextFile(params.get("input")).map(new FibonacciInputMap()).     } else {         System.out.println("Executing Iterate example with default input data set.").         System.out.println("Use --input to specify file input.").         inputStream = env.addSource(new RandomFibonacciSource()).     }     // create an iterative data stream from the input with 5 second timeout     IterativeStream<Tuple5<Integer, Integer, Integer, Integer, Integer>> it = inputStream.map(new InputMap()).iterate(5000).     // apply the step function to get the next Fibonacci number     // increment the counter and split the output with the output selector     SplitStream<Tuple5<Integer, Integer, Integer, Integer, Integer>> step = it.map(new Step()).split(new MySelector()).     // close the iteration by selecting the tuples that were directed to the     // 'iterate' channel in the output selector     it.closeWith(step.select("iterate")).     // to produce the final output select the tuples directed to the     // 'output' channel then get the input pairs that have the greatest iteration counter     // on a 1 second sliding window     DataStream<Tuple2<Tuple2<Integer, Integer>, Integer>> numbers = step.select("output").map(new OutputMap()).     // emit results     if (params.has("output")) {         numbers.writeAsText(params.get("output")).     } else {         System.out.println("Printing result to stdout. Use --output to specify output path.").         numbers.print().     }     // execute the program     env.execute("Streaming Iteration Example"). }
false;public;1;12;;@Override public void run(SourceContext<Tuple2<Integer, Integer>> ctx) throws Exception {     while (isRunning && counter < BOUND) {         int first = rnd.nextInt(BOUND / 2 - 1) + 1.         int second = rnd.nextInt(BOUND / 2 - 1) + 1.         ctx.collect(new Tuple2<>(first, second)).         counter++.         Thread.sleep(50L).     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;1;6;;@Override public Tuple2<Integer, Integer> map(String value) throws Exception {     String record = value.substring(1, value.length() - 1).     String[] splitted = record.split(",").     return new Tuple2<>(Integer.parseInt(splitted[0]), Integer.parseInt(splitted[1])). }
false;public;1;5;;@Override public Tuple5<Integer, Integer, Integer, Integer, Integer> map(Tuple2<Integer, Integer> value) throws Exception {     return new Tuple5<>(value.f0, value.f1, value.f0, value.f1, 0). }
false;public;1;5;;@Override public Tuple5<Integer, Integer, Integer, Integer, Integer> map(Tuple5<Integer, Integer, Integer, Integer, Integer> value) throws Exception {     return new Tuple5<>(value.f0, value.f1, value.f3, value.f2 + value.f3, ++value.f4). }
false;public;1;10;;@Override public Iterable<String> select(Tuple5<Integer, Integer, Integer, Integer, Integer> value) {     List<String> output = new ArrayList<>().     if (value.f2 < BOUND && value.f3 < BOUND) {         output.add("iterate").     } else {         output.add("output").     }     return output. }
false;public;1;6;;@Override public Tuple2<Tuple2<Integer, Integer>, Integer> map(Tuple5<Integer, Integer, Integer, Integer, Integer> value) throws Exception {     return new Tuple2<>(new Tuple2<>(value.f0, value.f1), value.f4). }
