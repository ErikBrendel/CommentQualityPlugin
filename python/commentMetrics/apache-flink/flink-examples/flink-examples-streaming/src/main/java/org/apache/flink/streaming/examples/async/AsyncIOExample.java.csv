commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public List<Integer> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(start). }
false;public;1;6;;@Override public void restoreState(List<Integer> state) throws Exception {     for (Integer i : state) {         this.start = i.     } }
false;public;1;15;;@Override public void run(SourceContext<Integer> ctx) throws Exception {     while ((start < counter || counter == -1) && isRunning) {         synchronized (ctx.getCheckpointLock()) {             ctx.collect(start).             ++start.             // loop back to 0             if (start == Integer.MAX_VALUE) {                 start = 0.             }         }         Thread.sleep(10L).     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;1;6;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     executorService = Executors.newFixedThreadPool(30). }
false;public;0;5;;@Override public void close() throws Exception {     super.close().     ExecutorUtils.gracefulShutdown(shutdownWaitTS, TimeUnit.MILLISECONDS, executorService). }
false;public;2;19;;@Override public void asyncInvoke(final Integer input, final ResultFuture<String> resultFuture) {     executorService.submit(() -> {         // wait for while to simulate async operation here         long sleep = (long) (ThreadLocalRandom.current().nextFloat() * sleepFactor).         try {             Thread.sleep(sleep).             if (ThreadLocalRandom.current().nextFloat() < failRatio) {                 resultFuture.completeExceptionally(new Exception("wahahahaha...")).             } else {                 resultFuture.complete(Collections.singletonList("key-" + (input % 10))).             }         } catch (InterruptedException e) {             resultFuture.complete(new ArrayList<>(0)).         }     }). }
false;private,static;0;9;;private static void printUsage() {     System.out.println("To customize example, use: AsyncIOExample [--fsStatePath <path to fs state>] " + "[--checkpointMode <exactly_once or at_least_once>] " + "[--maxCount <max number of input from source, -1 for infinite input>] " + "[--sleepFactor <interval to sleep for each stream element>] [--failRatio <possibility to throw exception>] " + "[--waitMode <ordered or unordered>] [--waitOperatorParallelism <parallelism for async wait operator>] " + "[--eventType <EventTime or IngestionTime>] [--shutdownWaitTS <milli sec to wait for thread pool>]" + "[--timeout <Timeout for the asynchronous operations>]"). }
false;public;2;4;;@Override public void flatMap(String value, Collector<Tuple2<String, Integer>> out) throws Exception {     out.collect(new Tuple2<>(value, 1)). }
false;public,static;1;114;;public static void main(String[] args) throws Exception {     // obtain execution environment     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     // parse parameters     final ParameterTool params = ParameterTool.fromArgs(args).     final String statePath.     final String cpMode.     final int maxCount.     final long sleepFactor.     final float failRatio.     final String mode.     final int taskNum.     final String timeType.     final long shutdownWaitTS.     final long timeout.     try {         // check the configuration for the job         statePath = params.get("fsStatePath", null).         cpMode = params.get("checkpointMode", "exactly_once").         maxCount = params.getInt("maxCount", 100000).         sleepFactor = params.getLong("sleepFactor", 100).         failRatio = params.getFloat("failRatio", 0.001f).         mode = params.get("waitMode", "ordered").         taskNum = params.getInt("waitOperatorParallelism", 1).         timeType = params.get("eventType", "EventTime").         shutdownWaitTS = params.getLong("shutdownWaitTS", 20000).         timeout = params.getLong("timeout", 10000L).     } catch (Exception e) {         printUsage().         throw e.     }     StringBuilder configStringBuilder = new StringBuilder().     final String lineSeparator = System.getProperty("line.separator").     configStringBuilder.append("Job configuration").append(lineSeparator).append("FS state path=").append(statePath).append(lineSeparator).append("Checkpoint mode=").append(cpMode).append(lineSeparator).append("Max count of input from source=").append(maxCount).append(lineSeparator).append("Sleep factor=").append(sleepFactor).append(lineSeparator).append("Fail ratio=").append(failRatio).append(lineSeparator).append("Waiting mode=").append(mode).append(lineSeparator).append("Parallelism for async wait operator=").append(taskNum).append(lineSeparator).append("Event type=").append(timeType).append(lineSeparator).append("Shutdown wait timestamp=").append(shutdownWaitTS).     LOG.info(configStringBuilder.toString()).     if (statePath != null) {         // setup state and checkpoint mode         env.setStateBackend(new FsStateBackend(statePath)).     }     if (EXACTLY_ONCE_MODE.equals(cpMode)) {         env.enableCheckpointing(1000L, CheckpointingMode.EXACTLY_ONCE).     } else {         env.enableCheckpointing(1000L, CheckpointingMode.AT_LEAST_ONCE).     }     // enable watermark or not     if (EVENT_TIME.equals(timeType)) {         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     } else if (INGESTION_TIME.equals(timeType)) {         env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     }     // create input stream of an single integer     DataStream<Integer> inputStream = env.addSource(new SimpleSource(maxCount)).     // create async function, which will *wait* for a while to simulate the process of async i/o     AsyncFunction<Integer, String> function = new SampleAsyncFunction(sleepFactor, failRatio, shutdownWaitTS).     // add async operator to streaming job     DataStream<String> result.     if (ORDERED.equals(mode)) {         result = AsyncDataStream.orderedWait(inputStream, function, timeout, TimeUnit.MILLISECONDS, 20).setParallelism(taskNum).     } else {         result = AsyncDataStream.unorderedWait(inputStream, function, timeout, TimeUnit.MILLISECONDS, 20).setParallelism(taskNum).     }     // add a reduce to get the sum of each keys.     result.flatMap(new FlatMapFunction<String, Tuple2<String, Integer>>() {          private static final long serialVersionUID = -938116068682344455L.          @Override         public void flatMap(String value, Collector<Tuple2<String, Integer>> out) throws Exception {             out.collect(new Tuple2<>(value, 1)).         }     }).keyBy(0).sum(1).print().     // execute the program     env.execute("Async IO Example"). }
