commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;84;;public static void runGenerator(Collector<Event>[] collectors) throws IOException {     final GeneratorThread[] threads = new GeneratorThread[collectors.length].     final int range = Integer.MAX_VALUE / collectors.length.     // create the generator threads     for (int i = 0. i < threads.length. i++) {         int min = range * i.         int max = min + range.         GeneratorThread thread = new GeneratorThread(collectors[i], min, max).         threads[i] = thread.         thread.setName("Generator " + i).     }     long delay = 2L.     int nextErroneous = 0.     boolean running = true.     for (GeneratorThread t : threads) {         t.setDelay(delay).         t.start().     }     final ThroughputLogger throughputLogger = new ThroughputLogger(threads).     throughputLogger.start().     System.out.println("Commands:").     System.out.println(" -> q : Quit").     System.out.println(" -> + : increase latency").     System.out.println(" -> - : decrease latency").     System.out.println(" -> e : inject invalid state transition").     while (running) {         final int next = System.in.read().         switch(next) {             case 'q':                 System.out.println("Quitting...").                 running = false.                 break.             case 'e':                 System.out.println("Injecting erroneous transition ...").                 threads[nextErroneous].sendInvalidStateTransition().                 nextErroneous = (nextErroneous + 1) % threads.length.                 break.             case '+':                 delay = Math.max(delay * 2, 1).                 System.out.println("Delay is " + delay).                 for (GeneratorThread t : threads) {                     t.setDelay(delay).                 }                 break.             case '-':                 delay /= 2.                 System.out.println("Delay is " + delay).                 for (GeneratorThread t : threads) {                     t.setDelay(delay).                 }                 break.             default:         }     }     // shutdown     throughputLogger.shutdown().     for (GeneratorThread t : threads) {         t.shutdown().         try {             t.join().         } catch (InterruptedException e) {             // restore interrupted status             Thread.currentThread().interrupt().         }     } }
false;public;0;28;;@Override public void run() {     final EventsGenerator generator = new EventsGenerator().     while (running) {         if (injectInvalidNext) {             injectInvalidNext = false.             Event next = generator.nextInvalid().             if (next != null) {                 out.collect(next).             }         } else {             out.collect(generator.next(minAddress, maxAddress)).         }         count += 1.         // sleep the delay to throttle         if (delay > 0) {             try {                 Thread.sleep(delay).             } catch (InterruptedException e) {                 Thread.currentThread().interrupt().             }         }     } }
false;public;0;3;;public long currentCount() {     return count. }
false;public;0;4;;public void shutdown() {     running = false.     interrupt(). }
false;public;1;3;;public void setDelay(long delay) {     this.delay = delay. }
false;public;0;3;;public void sendInvalidStateTransition() {     injectInvalidNext = true. }
false;public;0;27;;@Override public void run() {     long lastCount = 0L.     long lastTimeStamp = System.currentTimeMillis().     while (running) {         try {             Thread.sleep(1000).         } catch (InterruptedException e) {             break.         }         long ts = System.currentTimeMillis().         long currCount = 0L.         for (GeneratorThread generator : generators) {             currCount += generator.currentCount().         }         double factor = (ts - lastTimeStamp) / 1000.0.         double perSec = (currCount - lastCount) / factor.         lastTimeStamp = ts.         lastCount = currCount.         System.out.println(perSec + " / sec").     } }
false;public;0;4;;public void shutdown() {     running = false.     interrupt(). }
