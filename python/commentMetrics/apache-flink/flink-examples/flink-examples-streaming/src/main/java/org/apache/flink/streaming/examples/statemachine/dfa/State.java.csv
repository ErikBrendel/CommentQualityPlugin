commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Checks if this state is a terminal state.  * A terminal state has no outgoing transitions.  */ ;/**  * Checks if this state is a terminal state.  * A terminal state has no outgoing transitions.  */ public boolean isTerminal() {     return transitions.length == 0. }
true;public;1;10;/**  * Gets the state after transitioning from this state based on the given event.  * If the transition is valid, this returns the new state, and if this transition  * is illegal, it returns [[InvalidTransition]].  *  * @param evt The event that defined the transition.  * @return The new state, or [[InvalidTransition]].  */ ;// ------------------------------------------------------------------------ /**  * Gets the state after transitioning from this state based on the given event.  * If the transition is valid, this returns the new state, and if this transition  * is illegal, it returns [[InvalidTransition]].  *  * @param evt The event that defined the transition.  * @return The new state, or [[InvalidTransition]].  */ public State transition(EventType evt) {     for (Transition t : transitions) {         if (t.eventType() == evt) {             return t.targetState().         }     }     // no transition found     return InvalidTransition. }
true;public;1;21;/**  * Picks a random transition, based on the probabilities of the outgoing transitions  * of this state.  *  * @param rnd The random number generator to use.  * @return A pair of (transition event , new state).  */ ;/**  * Picks a random transition, based on the probabilities of the outgoing transitions  * of this state.  *  * @param rnd The random number generator to use.  * @return A pair of (transition event , new state).  */ public EventTypeAndState randomTransition(Random rnd) {     if (isTerminal()) {         throw new RuntimeException("Cannot transition from state " + name()).     } else {         final float p = rnd.nextFloat().         float mass = 0.0f.         Transition transition = null.         for (Transition t : transitions) {             mass += t.prob().             if (p <= mass) {                 transition = t.                 break.             }         }         assert transition != null.         return new EventTypeAndState(transition.eventType(), transition.targetState()).     } }
true;public;1;8;/**  * Returns an event type that, if applied as a transition on this state, will result  * in an illegal state transition.  *  * @param rnd The random number generator to use.  * @return And event type for an illegal state transition.  */ ;/**  * Returns an event type that, if applied as a transition on this state, will result  * in an illegal state transition.  *  * @param rnd The random number generator to use.  * @return And event type for an illegal state transition.  */ public EventType randomInvalidTransition(Random rnd) {     while (true) {         EventType candidate = EventType.values()[rnd.nextInt(EventType.values().length)].         if (transition(candidate) == InvalidTransition) {             return candidate.         }     } }
