commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;@Override public void invoke(Tuple2<Long, Long> value) { }
false;public,static;1;25;;public static void main(String[] args) throws Exception {     final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     DataStream<Tuple2<Long, Long>> stream = env.addSource(new DataSource()).     stream.keyBy(0).timeWindow(Time.of(2500, MILLISECONDS), Time.of(500, MILLISECONDS)).reduce(new SummingReducer()).addSink(new SinkFunction<Tuple2<Long, Long>>() {          @Override         public void invoke(Tuple2<Long, Long> value) {         }     }).     env.execute(). }
false;public;1;5;;@Override @SuppressWarnings("unchecked") public Key getKey(Type value) {     return (Key) value.getField(0). }
false;public;4;9;;@Override public void apply(Long key, Window window, Iterable<Tuple2<Long, Long>> values, Collector<Tuple2<Long, Long>> out) {     long sum = 0L.     for (Tuple2<Long, Long> value : values) {         sum += value.f1.     }     out.collect(new Tuple2<>(key, sum)). }
false;public;2;4;;@Override public Tuple2<Long, Long> reduce(Tuple2<Long, Long> value1, Tuple2<Long, Long> value2) {     return new Tuple2<>(value1.f0, value1.f1 + value2.f1). }
false;public;1;22;;@Override public void run(SourceContext<Tuple2<Long, Long>> ctx) throws Exception {     final long startTime = System.currentTimeMillis().     final long numElements = 20000000.     final long numKeys = 10000.     long val = 1L.     long count = 0L.     while (running && count < numElements) {         count++.         ctx.collect(new Tuple2<>(val++, 1L)).         if (val > numKeys) {             val = 1L.         }     }     final long endTime = System.currentTimeMillis().     System.out.println("Took " + (endTime - startTime) + " msecs for " + numElements + " values"). }
false;public;0;4;;@Override public void cancel() {     running = false. }
