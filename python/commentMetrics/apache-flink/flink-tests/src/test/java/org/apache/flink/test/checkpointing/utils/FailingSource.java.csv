commented;modifiers;parameterAmount;loc;comment;code
false;;2;1;;void emitEvent(SourceContext<Tuple2<Long, IntType>> ctx, int eventSequenceNo).
false;public;1;5;;@Override public void open(Configuration parameters) {     // non-parallel source     assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()). }
false;public;1;34;;@Override public void run(SourceContext<Tuple2<Long, IntType>> ctx) throws Exception {     final RuntimeContext runtimeContext = getRuntimeContext().     // detect if this task is "the chosen one" and should fail (via subtaskidx), if it did not fail before (via attempt)     final boolean failThisTask = runtimeContext.getAttemptNumber() == 0 && runtimeContext.getIndexOfThisSubtask() == 0.     // to still cause a failure     while (running && emitCallCount < expectedEmitCalls) {         // the function failed before, or we are in the elements before the failure         synchronized (ctx.getCheckpointLock()) {             eventEmittingGenerator.emitEvent(ctx, emitCallCount++).         }         if (emitCallCount < failureAfterNumElements) {             Thread.sleep(1).         } else if (failThisTask && emitCallCount == failureAfterNumElements) {             // wait for a pending checkpoint that fulfills our requirements if needed             while (checkpointStatus.get() != STATEFUL_CHECKPOINT_COMPLETED) {                 Thread.sleep(1).             }             throw new Exception("Artificial Failure").         }     }     if (usingProcessingTime) {         while (running) {             Thread.sleep(10).         }     } }
false;public;0;4;;@Override public void cancel() {     running = false. }
false;public;1;5;;@Override public void notifyCheckpointComplete(long checkpointId) {     // This will unblock the task for failing, if this is the checkpoint we are waiting for     checkpointStatus.compareAndSet(checkpointId, STATEFUL_CHECKPOINT_COMPLETED). }
false;public;2;9;;@Override public List<Integer> snapshotState(long checkpointId, long timestamp) throws Exception {     // We accept a checkpoint as basis if it should have a "decent amount" of state     if (emitCallCount > failureAfterNumElements / 2) {         // This means we are waiting for notification of this checkpoint to completed now.         checkpointStatus.compareAndSet(INITIAL, checkpointId).     }     return Collections.singletonList(this.emitCallCount). }
false;public;1;7;;@Override public void restoreState(List<Integer> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.emitCallCount = state.get(0). }
