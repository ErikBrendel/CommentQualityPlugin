commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Test public void testReduceOnNonKeyedDataset() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     // creates the input data and distributes them evenly among the available downstream tasks     DataSet<Tuple2<Integer, Boolean>> input = createNonKeyedInput(env).     List<Tuple2<Integer, Boolean>> actual = input.reduceGroup(new NonKeyedCombReducer()).collect().     String expected = "10,true\n".     compareResultAsTuples(actual, expected). }
false;public;0;17;;@Test public void testForkingReduceOnNonKeyedDataset() throws Exception {     // set up the execution environment     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     // creates the input data and distributes them evenly among the available downstream tasks     DataSet<Tuple2<Integer, Boolean>> input = createNonKeyedInput(env).     DataSet<Tuple2<Integer, Boolean>> r1 = input.reduceGroup(new NonKeyedCombReducer()).     DataSet<Tuple2<Integer, Boolean>> r2 = input.reduceGroup(new NonKeyedGroupCombReducer()).     List<Tuple2<Integer, Boolean>> actual = r1.union(r2).collect().     String expected = "10,true\n10,true\n".     compareResultAsTuples(actual, expected). }
false;public;0;14;;@Test public void testReduceOnKeyedDataset() throws Exception {     // set up the execution environment     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     // creates the input data and distributes them evenly among the available downstream tasks     DataSet<Tuple3<String, Integer, Boolean>> input = createKeyedInput(env).     List<Tuple3<String, Integer, Boolean>> actual = input.groupBy(0).reduceGroup(new KeyedCombReducer()).collect().     String expected = "k1,6,true\nk2,4,true\n".     compareResultAsTuples(actual, expected). }
false;public;0;18;;@Test public void testReduceOnKeyedDatasetWithSelector() throws Exception {     // set up the execution environment     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     // creates the input data and distributes them evenly among the available downstream tasks     DataSet<Tuple3<String, Integer, Boolean>> input = createKeyedInput(env).     List<Tuple3<String, Integer, Boolean>> actual = input.groupBy(new KeySelectorX()).reduceGroup(new KeyedCombReducer()).collect().     String expected = "k1,6,true\nk2,4,true\n".     compareResultAsTuples(actual, expected). }
false;public;0;21;;@Test public void testForkingReduceOnKeyedDataset() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     // creates the input data and distributes them evenly among the available downstream tasks     DataSet<Tuple3<String, Integer, Boolean>> input = createKeyedInput(env).     UnsortedGrouping<Tuple3<String, Integer, Boolean>> counts = input.groupBy(0).     DataSet<Tuple3<String, Integer, Boolean>> r1 = counts.reduceGroup(new KeyedCombReducer()).     DataSet<Tuple3<String, Integer, Boolean>> r2 = counts.reduceGroup(new KeyedGroupCombReducer()).     List<Tuple3<String, Integer, Boolean>> actual = r1.union(r2).collect().     String expected = "k1,6,true\n" + "k2,4,true\n" + "k1,6,true\n" + "k2,4,true\n".     compareResultAsTuples(actual, expected). }
false;public;0;22;;@Test public void testForkingReduceOnKeyedDatasetWithSelection() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(4).     // creates the input data and distributes them evenly among the available downstream tasks     DataSet<Tuple3<String, Integer, Boolean>> input = createKeyedInput(env).     UnsortedGrouping<Tuple3<String, Integer, Boolean>> counts = input.groupBy(new KeySelectorX()).     DataSet<Tuple3<String, Integer, Boolean>> r1 = counts.reduceGroup(new KeyedCombReducer()).     DataSet<Tuple3<String, Integer, Boolean>> r2 = counts.reduceGroup(new KeyedGroupCombReducer()).     List<Tuple3<String, Integer, Boolean>> actual = r1.union(r2).collect().     String expected = "k1,6,true\n" + "k2,4,true\n" + "k1,6,true\n" + "k2,4,true\n".     compareResultAsTuples(actual, expected). }
false;private;1;14;;private DataSet<Tuple2<Integer, Boolean>> createNonKeyedInput(ExecutionEnvironment env) {     return env.fromCollection(Arrays.asList(new Tuple2<>(1, false), new Tuple2<>(1, false), new Tuple2<>(1, false), new Tuple2<>(1, false), new Tuple2<>(1, false), new Tuple2<>(1, false), new Tuple2<>(1, false), new Tuple2<>(1, false), new Tuple2<>(1, false), new Tuple2<>(1, false))).rebalance(). }
false;public;1;12;;@Override public Tuple2<Integer, Boolean> combine(Iterable<Tuple2<Integer, Boolean>> values) throws Exception {     int sum = 0.     boolean flag = true.     for (Tuple2<Integer, Boolean> tuple : values) {         sum += tuple.f0.         flag &= !tuple.f1.     }     return new Tuple2<>(sum, flag). }
false;public;2;10;;@Override public void reduce(Iterable<Tuple2<Integer, Boolean>> values, Collector<Tuple2<Integer, Boolean>> out) throws Exception {     int sum = 0.     boolean flag = true.     for (Tuple2<Integer, Boolean> tuple : values) {         sum += tuple.f0.         flag &= tuple.f1.     }     out.collect(new Tuple2<>(sum, flag)). }
false;public;2;10;;@Override public void reduce(Iterable<Tuple2<Integer, Boolean>> values, Collector<Tuple2<Integer, Boolean>> out) throws Exception {     int sum = 0.     boolean flag = true.     for (Tuple2<Integer, Boolean> tuple : values) {         sum += tuple.f0.         flag &= tuple.f1.     }     out.collect(new Tuple2<>(sum, flag)). }
false;public;2;10;;@Override public void combine(Iterable<Tuple2<Integer, Boolean>> values, Collector<Tuple2<Integer, Boolean>> out) throws Exception {     int sum = 0.     boolean flag = true.     for (Tuple2<Integer, Boolean> tuple : values) {         sum += tuple.f0.         flag &= !tuple.f1.     }     out.collect(new Tuple2<>(sum, flag)). }
false;private;1;14;;private DataSet<Tuple3<String, Integer, Boolean>> createKeyedInput(ExecutionEnvironment env) {     return env.fromCollection(Arrays.asList(new Tuple3<>("k1", 1, false), new Tuple3<>("k1", 1, false), new Tuple3<>("k1", 1, false), new Tuple3<>("k2", 1, false), new Tuple3<>("k1", 1, false), new Tuple3<>("k1", 1, false), new Tuple3<>("k2", 1, false), new Tuple3<>("k2", 1, false), new Tuple3<>("k1", 1, false), new Tuple3<>("k2", 1, false))).rebalance(). }
false;public;1;4;;@Override public String getKey(Tuple3<String, Integer, Boolean> in) {     return in.f0. }
false;public;1;13;;@Override public Tuple3<String, Integer, Boolean> combine(Iterable<Tuple3<String, Integer, Boolean>> values) throws Exception {     String key = null.     int sum = 0.     boolean flag = true.     for (Tuple3<String, Integer, Boolean> tuple : values) {         key = (key == null) ? tuple.f0 : key.         sum += tuple.f1.         flag &= !tuple.f2.     }     return new Tuple3<>(key, sum, flag). }
false;public;2;13;;@Override public void reduce(Iterable<Tuple3<String, Integer, Boolean>> values, Collector<Tuple3<String, Integer, Boolean>> out) throws Exception {     String key = null.     int sum = 0.     boolean flag = true.     for (Tuple3<String, Integer, Boolean> tuple : values) {         key = (key == null) ? tuple.f0 : key.         sum += tuple.f1.         flag &= tuple.f2.     }     out.collect(new Tuple3<>(key, sum, flag)). }
false;public;2;13;;@Override public void combine(Iterable<Tuple3<String, Integer, Boolean>> values, Collector<Tuple3<String, Integer, Boolean>> out) throws Exception {     String key = null.     int sum = 0.     boolean flag = true.     for (Tuple3<String, Integer, Boolean> tuple : values) {         key = (key == null) ? tuple.f0 : key.         sum += tuple.f1.         flag &= !tuple.f2.     }     out.collect(new Tuple3<>(key, sum, flag)). }
false;public;2;13;;@Override public void reduce(Iterable<Tuple3<String, Integer, Boolean>> values, Collector<Tuple3<String, Integer, Boolean>> out) throws Exception {     String key = null.     int sum = 0.     boolean flag = true.     for (Tuple3<String, Integer, Boolean> tuple : values) {         key = (key == null) ? tuple.f0 : key.         sum += tuple.f1.         flag &= tuple.f2.     }     out.collect(new Tuple3<>(key, sum, flag)). }
