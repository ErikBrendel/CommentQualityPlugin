commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public Long map(Long value) throws Exception {     synchronized (this) {         wait().     }     return 0L. }
false;public;0;29;;@Override public void run() {     try {         ExecutionEnvironment env = ExecutionEnvironment.createRemoteEnvironment("localhost", 1337, config).         env.setParallelism(2).         env.setRestartStrategy(RestartStrategies.noRestart()).         env.getConfig().disableSysoutLogging().         env.generateSequence(0, Long.MAX_VALUE).map(new MapFunction<Long, Long>() {              @Override             public Long map(Long value) throws Exception {                 synchronized (this) {                     wait().                 }                 return 0L.             }         }).output(new DiscardingOutputFormat<Long>()).         env.execute().     } catch (Throwable t) {         errorRef[0] = t.     } }
false;public;0;157;;@Test public void testCancelingOnProcessFailure() throws Exception {     final Time timeout = Time.minutes(2L).     RestClusterClient<String> clusterClient = null.     TestProcess taskManagerProcess = null.     final TestingFatalErrorHandler fatalErrorHandler = new TestingFatalErrorHandler().     Configuration config = new Configuration().     config.setString(JobManagerOptions.ADDRESS, "localhost").     config.setString(AkkaOptions.ASK_TIMEOUT, "100 s").     config.setString(HighAvailabilityOptions.HA_MODE, "zookeeper").     config.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperResource.getConnectString()).     config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, temporaryFolder.newFolder().getAbsolutePath()).     config.setInteger(TaskManagerOptions.NUM_TASK_SLOTS, 2).     config.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, "4m").     config.setInteger(TaskManagerOptions.NETWORK_NUM_BUFFERS, 100).     config.setInteger(RestOptions.PORT, 0).     final RpcService rpcService = AkkaRpcServiceUtils.createRpcService("localhost", 0, config).     final int jobManagerPort = rpcService.getPort().     config.setInteger(JobManagerOptions.PORT, jobManagerPort).     final SessionDispatcherResourceManagerComponentFactory resourceManagerComponentFactory = new SessionDispatcherResourceManagerComponentFactory(StandaloneResourceManagerFactory.INSTANCE).     DispatcherResourceManagerComponent<?> dispatcherResourceManagerComponent = null.     final HighAvailabilityServices haServices = HighAvailabilityServicesUtils.createHighAvailabilityServices(config, TestingUtils.defaultExecutor(), HighAvailabilityServicesUtils.AddressResolution.NO_ADDRESS_RESOLUTION).     try {         // is available on this machine         if (getJavaCommandPath() == null) {             System.out.println("---- Skipping Process Failure test : Could not find java executable ----").             return.         }         dispatcherResourceManagerComponent = resourceManagerComponentFactory.create(config, rpcService, haServices, blobServerResource.getBlobServer(), new HeartbeatServices(100L, 1000L), NoOpMetricRegistry.INSTANCE, new MemoryArchivedExecutionGraphStore(), VoidMetricQueryServiceRetriever.INSTANCE, fatalErrorHandler).         final Map<String, String> keyValues = config.toMap().         final ArrayList<String> commands = new ArrayList<>((keyValues.size() << 1) + 8).         TestProcessBuilder taskManagerProcessBuilder = new TestProcessBuilder(TaskExecutorProcessEntryPoint.class.getName()).         taskManagerProcessBuilder.addConfigAsMainClassArgs(config).         taskManagerProcess = taskManagerProcessBuilder.start().         final Throwable[] errorRef = new Throwable[1].         // start the test program, which infinitely blocks         Runnable programRunner = new Runnable() {              @Override             public void run() {                 try {                     ExecutionEnvironment env = ExecutionEnvironment.createRemoteEnvironment("localhost", 1337, config).                     env.setParallelism(2).                     env.setRestartStrategy(RestartStrategies.noRestart()).                     env.getConfig().disableSysoutLogging().                     env.generateSequence(0, Long.MAX_VALUE).map(new MapFunction<Long, Long>() {                          @Override                         public Long map(Long value) throws Exception {                             synchronized (this) {                                 wait().                             }                             return 0L.                         }                     }).output(new DiscardingOutputFormat<Long>()).                     env.execute().                 } catch (Throwable t) {                     errorRef[0] = t.                 }             }         }.         Thread programThread = new Thread(programRunner).         // kill the TaskManager         programThread.start().         final DispatcherGateway dispatcherGateway = retrieveDispatcherGateway(rpcService, haServices).         waitUntilAllSlotsAreUsed(dispatcherGateway, timeout).         clusterClient = new RestClusterClient<>(config, "standalone").         final Collection<JobID> jobIds = waitForRunningJobs(clusterClient, timeout).         assertThat(jobIds, hasSize(1)).         final JobID jobId = jobIds.iterator().next().         // kill the TaskManager after the job started to run         taskManagerProcess.destroy().         taskManagerProcess = null.         // try to cancel the job         clusterClient.cancel(jobId).         // we should see a failure within reasonable time (10s is the ask timeout).         // since the CI environment is often slow, we conservatively give it up to 2 minutes,         // to fail, which is much lower than the failure time given by the heartbeats ( > 2000s)         programThread.join(120000).         assertFalse("The program did not cancel in time (2 minutes)", programThread.isAlive()).         Throwable error = errorRef[0].         assertNotNull("The program did not fail properly", error).         assertTrue(error instanceof ProgramInvocationException).     // all seems well :-)     } catch (Exception e) {         printProcessLog("TaskManager", taskManagerProcess.getOutput().toString()).         throw e.     } catch (Error e) {         printProcessLog("TaskManager 1", taskManagerProcess.getOutput().toString()).         throw e.     } finally {         if (taskManagerProcess != null) {             taskManagerProcess.destroy().         }         if (clusterClient != null) {             clusterClient.shutdown().         }         if (dispatcherResourceManagerComponent != null) {             dispatcherResourceManagerComponent.deregisterApplicationAndClose(ApplicationStatus.SUCCEEDED, null).         }         fatalErrorHandler.rethrowError().         RpcUtils.terminateRpcService(rpcService, Time.seconds(100L)).         haServices.closeAndCleanupAllData().     } }
true;static;2;8;/**  * Helper method to wait until the {@link Dispatcher} has set its fencing token.  *  * @param rpcService to use to connect to the dispatcher  * @param haServices high availability services to connect to the dispatcher  * @return {@link DispatcherGateway}  * @throws Exception if something goes wrong  */ ;/**  * Helper method to wait until the {@link Dispatcher} has set its fencing token.  *  * @param rpcService to use to connect to the dispatcher  * @param haServices high availability services to connect to the dispatcher  * @return {@link DispatcherGateway}  * @throws Exception if something goes wrong  */ static DispatcherGateway retrieveDispatcherGateway(RpcService rpcService, HighAvailabilityServices haServices) throws Exception {     final LeaderConnectionInfo leaderConnectionInfo = LeaderRetrievalUtils.retrieveLeaderConnectionInfo(haServices.getDispatcherLeaderRetriever(), Time.seconds(10L)).     return rpcService.connect(leaderConnectionInfo.getAddress(), DispatcherId.fromUuid(leaderConnectionInfo.getLeaderSessionID()), DispatcherGateway.class).get(). }
false;private;2;11;;private void waitUntilAllSlotsAreUsed(DispatcherGateway dispatcherGateway, Time timeout) throws ExecutionException, InterruptedException {     FutureUtils.retrySuccessfulWithDelay(() -> dispatcherGateway.requestClusterOverview(timeout), Time.milliseconds(50L), Deadline.fromNow(Duration.ofMillis(timeout.toMilliseconds())), clusterOverview -> clusterOverview.getNumTaskManagersConnected() >= 1 && clusterOverview.getNumSlotsAvailable() == 0 && clusterOverview.getNumSlotsTotal() == 2, TestingUtils.defaultScheduledExecutor()).get(). }
false;private;2;12;;private Collection<JobID> waitForRunningJobs(ClusterClient<?> clusterClient, Time timeout) throws ExecutionException, InterruptedException {     return FutureUtils.retrySuccessfulWithDelay(CheckedSupplier.unchecked(clusterClient::listJobs), Time.milliseconds(50L), Deadline.fromNow(Duration.ofMillis(timeout.toMilliseconds())), jobs -> !jobs.isEmpty(), TestingUtils.defaultScheduledExecutor()).get().stream().map(JobStatusMessage::getJobId).collect(Collectors.toList()). }
false;private;2;13;;private void printProcessLog(String processName, String log) {     if (log == null || log.length() == 0) {         return.     }     System.out.println("-----------------------------------------").     System.out.println(" BEGIN SPAWNED PROCESS LOG FOR " + processName).     System.out.println("-----------------------------------------").     System.out.println(log).     System.out.println("-----------------------------------------").     System.out.println("		END SPAWNED PROCESS LOG").     System.out.println("-----------------------------------------"). }
