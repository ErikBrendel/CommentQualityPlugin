commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Test public void testSessionWindowing() throws Exception {     SessionEventGeneratorDataSource dataSource = new SessionEventGeneratorDataSource().     runTest(dataSource, new ValidatingWindowFunction()). }
false;private;2;31;;private void runTest(SourceFunction<SessionEvent<Integer, TestEventPayload>> dataSource, WindowFunction<SessionEvent<Integer, TestEventPayload>, String, Tuple, TimeWindow> windowFunction) throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     WindowedStream<SessionEvent<Integer, TestEventPayload>, Tuple, TimeWindow> windowedStream = env.addSource(dataSource).keyBy("sessionKey").window(EventTimeSessionWindows.withGap(Time.milliseconds(MAX_SESSION_EVENT_GAP_MS))).     if (ALLOWED_LATENESS_MS != Long.MAX_VALUE) {         windowedStream = windowedStream.allowedLateness(Time.milliseconds(ALLOWED_LATENESS_MS)).     }     if (PURGE_WINDOW_ON_FIRE) {         windowedStream = windowedStream.trigger(PurgingTrigger.of(EventTimeTrigger.create())).     }     windowedStream.apply(windowFunction).print().     JobExecutionResult result = env.execute().     // check that overall event counts match with our expectations. remember that late events within lateness will     // each trigger a window!     Assert.assertEquals((LATE_EVENTS_PER_SESSION + 1) * NUMBER_OF_SESSIONS * EVENTS_PER_SESSION, (long) result.getAccumulatorResult(SESSION_COUNTER_ON_TIME_KEY)).     Assert.assertEquals(NUMBER_OF_SESSIONS * (LATE_EVENTS_PER_SESSION * (LATE_EVENTS_PER_SESSION + 1) / 2), (long) result.getAccumulatorResult(SESSION_COUNTER_LATE_KEY)). }
false;public;4;61;;@Override public void apply(Tuple tuple, TimeWindow timeWindow, Iterable<SessionEvent<Integer, TestEventPayload>> input, Collector<String> output) throws Exception {     if (OUTPUT_RESULTS_AS_STRING) {         output.collect("--- window triggered ---").     }     List<SessionEvent<Integer, TestEventPayload>> sessionEvents = new ArrayList<>().     for (SessionEvent<Integer, TestEventPayload> evt : input) {         if (OUTPUT_RESULTS_AS_STRING) {             output.collect(evt.toString()).         }         sessionEvents.add(evt).     }     // bit-sets to track uniqueness of ids     BitSet onTimeBits = new BitSet(EVENTS_PER_SESSION).     BitSet lateWithingBits = new BitSet(LATE_EVENTS_PER_SESSION).     int onTimeCount = 0.     int lateCount = 0.     for (SessionEvent<Integer, TestEventPayload> evt : sessionEvents) {         if (SessionEventGeneratorImpl.Timing.TIMELY.equals(evt.getEventValue().getTiming())) {             ++onTimeCount.             onTimeBits.set(evt.getEventValue().getEventId()).         } else if (SessionEventGeneratorImpl.Timing.IN_LATENESS.equals(evt.getEventValue().getTiming())) {             ++lateCount.             lateWithingBits.set(evt.getEventValue().getEventId() - EVENTS_PER_SESSION).         } else {             Assert.fail("Illegal event type in window " + timeWindow + ": " + evt).         }     }     getRuntimeContext().getLongCounter(SESSION_COUNTER_ON_TIME_KEY).add(onTimeCount).     getRuntimeContext().getLongCounter(SESSION_COUNTER_LATE_KEY).add(lateCount).     if (sessionEvents.size() >= EVENTS_PER_SESSION) {         // on time events case or non-purging         // check that the expected amount if events is in the window         Assert.assertEquals(onTimeCount, EVENTS_PER_SESSION).         // check that no duplicate events happened         Assert.assertEquals(onTimeBits.cardinality(), onTimeCount).         Assert.assertEquals(lateWithingBits.cardinality(), lateCount).     } else {         Assert.fail("Event count for session window " + timeWindow + " is too low: " + sessionEvents).     } }
false;public;1;17;;@Override public void run(SourceContext<SessionEvent<Integer, TestEventPayload>> ctx) {     ParallelSessionsEventGenerator<Integer, SessionEvent<Integer, TestEventPayload>> generator = createGenerator().     this.isRunning = true.     // main data source driver loop     while (isRunning) {         synchronized (ctx.getCheckpointLock()) {             SessionEvent<Integer, TestEventPayload> evt = generator.nextEvent().             if (evt != null) {                 ctx.collectWithTimestamp(evt, evt.getEventTimestamp()).                 ctx.emitWatermark(new Watermark(generator.getWatermark())).             } else {                 break.             }         }     } }
false;public;6;13;;@Override public SessionEvent<Integer, TestEventPayload> createEvent(Integer key, int sessionId, int eventId, long eventTimestamp, long globalWatermark, SessionEventGeneratorImpl.Timing timing) {     return SessionEvent.of(key, TestEventPayload.of(globalWatermark, sessionId, eventId, timing), eventTimestamp). }
false;private;0;44;;private ParallelSessionsEventGenerator<Integer, SessionEvent<Integer, TestEventPayload>> createGenerator() {     LongRandomGenerator randomGenerator = new LongRandomGenerator(RANDOM_SEED).     Set<Integer> keys = new HashSet<>().     for (int i = 0. i < NUMBER_OF_DIFFERENT_KEYS. ++i) {         keys.add(i).     }     GeneratorConfiguration generatorConfiguration = GeneratorConfiguration.of(ALLOWED_LATENESS_MS, LATE_EVENTS_PER_SESSION, MAX_DROPPED_EVENTS_PER_SESSION, MAX_ADDITIONAL_SESSION_GAP_MS).     GeneratorEventFactory<Integer, SessionEvent<Integer, TestEventPayload>> generatorEventFactory = new GeneratorEventFactory<Integer, SessionEvent<Integer, TestEventPayload>>() {          @Override         public SessionEvent<Integer, TestEventPayload> createEvent(Integer key, int sessionId, int eventId, long eventTimestamp, long globalWatermark, SessionEventGeneratorImpl.Timing timing) {             return SessionEvent.of(key, TestEventPayload.of(globalWatermark, sessionId, eventId, timing), eventTimestamp).         }     }.     EventGeneratorFactory<Integer, SessionEvent<Integer, TestEventPayload>> eventGeneratorFactory = new EventGeneratorFactory<>(generatorConfiguration, generatorEventFactory, MAX_SESSION_EVENT_GAP_MS, EVENTS_PER_SESSION, randomGenerator).     return new ParallelSessionsEventGenerator<>(keys, eventGeneratorFactory, PARALLEL_SESSIONS, NUMBER_OF_SESSIONS, randomGenerator). }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
