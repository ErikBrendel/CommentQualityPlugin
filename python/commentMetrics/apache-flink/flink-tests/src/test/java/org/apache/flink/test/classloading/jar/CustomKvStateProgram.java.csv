commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public Integer getKey(Tuple2<Integer, Integer> value) throws Exception {     return value.f0. }
false;public;1;4;;@Override public Tuple2<Integer, Integer> map(Integer value) throws Exception {     return new Tuple2<>(ThreadLocalRandom.current().nextInt(parallelism), value). }
false;public,static;1;33;;public static void main(String[] args) throws Exception {     final int parallelism = Integer.parseInt(args[0]).     final String checkpointPath = args[1].     final int checkpointingInterval = Integer.parseInt(args[2]).     final String outputPath = args[3].     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(parallelism).     env.getConfig().disableSysoutLogging().     env.enableCheckpointing(checkpointingInterval).     env.setStateBackend(new FsStateBackend(checkpointPath)).     DataStream<Integer> source = env.addSource(new InfiniteIntegerSource()).     source.map(new MapFunction<Integer, Tuple2<Integer, Integer>>() {          private static final long serialVersionUID = 1L.          @Override         public Tuple2<Integer, Integer> map(Integer value) throws Exception {             return new Tuple2<>(ThreadLocalRandom.current().nextInt(parallelism), value).         }     }).keyBy(new KeySelector<Tuple2<Integer, Integer>, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public Integer getKey(Tuple2<Integer, Integer> value) throws Exception {             return value.f0.         }     }).flatMap(new ReducingStateFlatMap()).writeAsText(outputPath).     env.execute(). }
false;public;1;9;;@Override public void run(SourceContext<Integer> ctx) throws Exception {     int counter = 0.     while (running) {         synchronized (ctx.getCheckpointLock()) {             ctx.collect(counter++).         }     } }
false;public;0;4;;@Override public void cancel() {     running = false. }
false;public;1;10;;@Override public void open(Configuration parameters) throws Exception {     ReducingStateDescriptor<Integer> stateDescriptor = new ReducingStateDescriptor<>("reducing-state", new ReduceSum(), Integer.class).     this.kvState = getRuntimeContext().getReducingState(stateDescriptor). }
false;public;2;4;;@Override public void flatMap(Tuple2<Integer, Integer> value, Collector<Integer> out) throws Exception {     kvState.add(value.f1). }
false;public;2;4;;@Override public Integer reduce(Integer value1, Integer value2) throws Exception {     return value1 + value2. }
