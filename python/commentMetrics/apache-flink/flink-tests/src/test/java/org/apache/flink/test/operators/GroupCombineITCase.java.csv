commented;modifiers;parameterAmount;loc;comment;code
false;public;0;17;;@Test public void testAllGroupCombineIdentity() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Tuple3<Integer, Long, String>> reduceDs = ds.combineGroup(new IdentityFunction()).reduceGroup(new IdentityFunction()).     List<Tuple3<Integer, Long, String>> result = reduceDs.collect().     compareResultAsTuples(result, identityResult). }
false;public;0;17;;@Test public void testIdentity() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Tuple3<Integer, Long, String>> reduceDs = ds.combineGroup(new IdentityFunction()).reduceGroup(new IdentityFunction()).     List<Tuple3<Integer, Long, String>> result = reduceDs.collect().     compareResultAsTuples(result, identityResult). }
false;public;0;18;;@Test public void testIdentityWithGroupBy() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Tuple3<Integer, Long, String>> reduceDs = ds.groupBy(1).combineGroup(new IdentityFunction()).reduceGroup(new IdentityFunction()).     List<Tuple3<Integer, Long, String>> result = reduceDs.collect().     compareResultAsTuples(result, identityResult). }
false;public;0;21;;@Test public void testIdentityWithGroupByAndSort() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Tuple3<Integer, Long, String>> reduceDs = ds.groupBy(1).sortGroup(1, Order.DESCENDING).combineGroup(new IdentityFunction()).groupBy(1).sortGroup(1, Order.DESCENDING).reduceGroup(new IdentityFunction()).     List<Tuple3<Integer, Long, String>> result = reduceDs.collect().     compareResultAsTuples(result, identityResult). }
false;public;1;4;;@Override public Tuple3<Integer, Long, String> map(Tuple2<Long, Tuple3<Integer, Long, String>> value) throws Exception {     return value.f1. }
false;public;0;36;;@Test public void testPartialReduceWithIdenticalInputOutputType() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     // data     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Tuple2<Long, Tuple3<Integer, Long, String>>> dsWrapped = ds.map(new Tuple3KvWrapper()).     List<Tuple3<Integer, Long, String>> result = dsWrapped.groupBy(0).combineGroup(new Tuple3toTuple3GroupReduce()).groupBy(0).reduceGroup(new Tuple3toTuple3GroupReduce()).map(new MapFunction<Tuple2<Long, Tuple3<Integer, Long, String>>, Tuple3<Integer, Long, String>>() {          @Override         public Tuple3<Integer, Long, String> map(Tuple2<Long, Tuple3<Integer, Long, String>> value) throws Exception {             return value.f1.         }     }).collect().     String expected = "1,1,combined\n" + "5,4,combined\n" + "15,9,combined\n" + "34,16,combined\n" + "65,25,combined\n" + "111,36,combined\n".     compareResultAsTuples(result, expected). }
false;public;1;4;;@Override public Tuple2<Integer, Long> map(Tuple2<Long, Tuple2<Integer, Long>> value) throws Exception {     return value.f1. }
false;public;0;36;;@Test public void testPartialReduceWithDifferentInputOutputType() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     // data     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Tuple2<Long, Tuple3<Integer, Long, String>>> dsWrapped = ds.map(new Tuple3KvWrapper()).     List<Tuple2<Integer, Long>> result = dsWrapped.groupBy(0).combineGroup(new Tuple3toTuple2GroupReduce()).groupBy(0).reduceGroup(new Tuple2toTuple2GroupReduce()).map(new MapFunction<Tuple2<Long, Tuple2<Integer, Long>>, Tuple2<Integer, Long>>() {          @Override         public Tuple2<Integer, Long> map(Tuple2<Long, Tuple2<Integer, Long>> value) throws Exception {             return value.f1.         }     }).collect().     String expected = "1,3\n" + "5,20\n" + "15,58\n" + "34,52\n" + "65,70\n" + "111,96\n".     compareResultAsTuples(result, expected). }
false;public;2;10;;@Override public void combine(Iterable<Tuple3<Integer, Long, String>> values, Collector<Tuple2<Long, Integer>> out) throws Exception {     int count = 0.     long key = 0.     for (Tuple3<Integer, Long, String> value : values) {         key = value.f1.         count++.     }     out.collect(new Tuple2<>(key, count)). }
false;public;0;39;;@Test public // check if no shuffle is being executed void testCheckPartitionShuffleGroupBy() throws Exception {     org.junit.Assume.assumeTrue(mode != TestExecutionMode.COLLECTION).     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     // data     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     // partition and group data     UnsortedGrouping<Tuple3<Integer, Long, String>> partitionedDS = ds.partitionByHash(0).groupBy(1).     List<Tuple2<Long, Integer>> result = partitionedDS.combineGroup(new GroupCombineFunction<Tuple3<Integer, Long, String>, Tuple2<Long, Integer>>() {          @Override         public void combine(Iterable<Tuple3<Integer, Long, String>> values, Collector<Tuple2<Long, Integer>> out) throws Exception {             int count = 0.             long key = 0.             for (Tuple3<Integer, Long, String> value : values) {                 key = value.f1.                 count++.             }             out.collect(new Tuple2<>(key, count)).         }     }).collect().     String[] localExpected = new String[] { "(6,6)", "(5,5)" + "(4,4)", "(3,3)", "(2,2)", "(1,1)" }.     String[] resultAsStringArray = new String[result.size()].     for (int i = 0. i < resultAsStringArray.length. ++i) {         resultAsStringArray[i] = result.get(i).toString().     }     Arrays.sort(resultAsStringArray).     Assert.assertEquals("The two arrays were identical.", false, Arrays.equals(localExpected, resultAsStringArray)). }
false;public;2;10;;@Override public void combine(Iterable<Tuple3<Integer, Long, String>> values, Collector<Tuple2<Long, Integer>> out) throws Exception {     int count = 0.     long key = 0.     for (Tuple3<Integer, Long, String> value : values) {         key = value.f1.         count++.     }     out.collect(new Tuple2<>(key, count)). }
false;public;0;38;;@Test public // check if parallelism of 1 results in the same data like a shuffle void testCheckPartitionShuffleDOP1() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(1).     // data     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     // partition and group data     UnsortedGrouping<Tuple3<Integer, Long, String>> partitionedDS = ds.partitionByHash(0).groupBy(1).     List<Tuple2<Long, Integer>> result = partitionedDS.combineGroup(new GroupCombineFunction<Tuple3<Integer, Long, String>, Tuple2<Long, Integer>>() {          @Override         public void combine(Iterable<Tuple3<Integer, Long, String>> values, Collector<Tuple2<Long, Integer>> out) throws Exception {             int count = 0.             long key = 0.             for (Tuple3<Integer, Long, String> value : values) {                 key = value.f1.                 count++.             }             out.collect(new Tuple2<>(key, count)).         }     }).collect().     String expected = "6,6\n" + "5,5\n" + "4,4\n" + "3,3\n" + "2,2\n" + "1,1\n".     compareResultAsTuples(result, expected). }
false;public;1;4;;@Override public Tuple1<String> map(String value) throws Exception {     return new Tuple1<>(value). }
false;public;0;27;;@Test public // check if all API methods are callable void testAPI() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple1<String>> ds = CollectionDataSets.getStringDataSet(env).map(new MapFunction<String, Tuple1<String>>() {          @Override         public Tuple1<String> map(String value) throws Exception {             return new Tuple1<>(value).         }     }).     // all methods on DataSet     ds.combineGroup(new GroupCombineFunctionExample()).output(new DiscardingOutputFormat<Tuple1<String>>()).     // all methods on UnsortedGrouping     ds.groupBy(0).combineGroup(new GroupCombineFunctionExample()).output(new DiscardingOutputFormat<Tuple1<String>>()).     // all methods on SortedGrouping     ds.groupBy(0).sortGroup(0, Order.ASCENDING).combineGroup(new GroupCombineFunctionExample()).output(new DiscardingOutputFormat<Tuple1<String>>()).     env.execute(). }
false;public;2;6;;@Override public void combine(Iterable<Tuple1<String>> values, Collector<Tuple1<String>> out) throws Exception {     for (Tuple1<String> value : values) {         out.collect(value).     } }
false;public;2;6;;@Override public void combine(Iterable<scala.Tuple1<String>> values, Collector<scala.Tuple1<String>> out) throws Exception {     for (scala.Tuple1<String> value : values) {         out.collect(value).     } }
false;public;2;6;;@Override public void combine(Iterable<Tuple3<Integer, Long, String>> values, Collector<Tuple3<Integer, Long, String>> out) throws Exception {     for (Tuple3<Integer, Long, String> value : values) {         out.collect(new Tuple3<>(value.f0, value.f1, value.f2)).     } }
false;public;2;6;;@Override public void reduce(Iterable<Tuple3<Integer, Long, String>> values, Collector<Tuple3<Integer, Long, String>> out) throws Exception {     for (Tuple3<Integer, Long, String> value : values) {         out.collect(new Tuple3<>(value.f0, value.f1, value.f2)).     } }
false;public;2;18;;@Override public void combine(Iterable<Tuple2<Long, Tuple3<Integer, Long, String>>> values, Collector<Tuple2<Long, Tuple3<Integer, Long, String>>> out) throws Exception {     int i = 0.     long l = 0.     long key = 0.     // collapse groups     for (Tuple2<Long, Tuple3<Integer, Long, String>> value : values) {         key = value.f0.         Tuple3<Integer, Long, String> extracted = value.f1.         i += extracted.f0.         l += extracted.f1.     }     Tuple3<Integer, Long, String> result = new Tuple3<>(i, l, "combined").     out.collect(new Tuple2<>(key, result)). }
false;public;2;5;;@Override public void reduce(Iterable<Tuple2<Long, Tuple3<Integer, Long, String>>> values, Collector<Tuple2<Long, Tuple3<Integer, Long, String>>> out) throws Exception {     combine(values, out). }
false;public;2;18;;@Override public void combine(Iterable<Tuple2<Long, Tuple3<Integer, Long, String>>> values, Collector<Tuple2<Long, Tuple2<Integer, Long>>> out) throws Exception {     int i = 0.     long l = 0.     long key = 0.     // collapse groups     for (Tuple2<Long, Tuple3<Integer, Long, String>> value : values) {         key = value.f0.         Tuple3<Integer, Long, String> extracted = value.f1.         i += extracted.f0.         l += extracted.f1 + extracted.f2.length().     }     Tuple2<Integer, Long> result = new Tuple2<>(i, l).     out.collect(new Tuple2<>(key, result)). }
false;public;2;5;;@Override public void reduce(Iterable<Tuple2<Long, Tuple2<Integer, Long>>> values, Collector<Tuple2<Long, Tuple2<Integer, Long>>> out) throws Exception {     new Tuple2toTuple2GroupReduce().reduce(values, out). }
false;public;2;19;;@Override public void combine(Iterable<Tuple2<Long, Tuple2<Integer, Long>>> values, Collector<Tuple2<Long, Tuple2<Integer, Long>>> out) throws Exception {     int i = 0.     long l = 0.     long key = 0.     // collapse groups     for (Tuple2<Long, Tuple2<Integer, Long>> value : values) {         key = value.f0.         Tuple2<Integer, Long> extracted = value.f1.         i += extracted.f0.         l += extracted.f1.     }     Tuple2<Integer, Long> result = new Tuple2<>(i, l).     out.collect(new Tuple2<>(key, result)). }
false;public;2;5;;@Override public void reduce(Iterable<Tuple2<Long, Tuple2<Integer, Long>>> values, Collector<Tuple2<Long, Tuple2<Integer, Long>>> out) throws Exception {     combine(values, out). }
false;public;1;4;;@Override public Tuple2<Long, Tuple3<Integer, Long, String>> map(Tuple3<Integer, Long, String> value) throws Exception {     return new Tuple2<>(value.f1, value). }
