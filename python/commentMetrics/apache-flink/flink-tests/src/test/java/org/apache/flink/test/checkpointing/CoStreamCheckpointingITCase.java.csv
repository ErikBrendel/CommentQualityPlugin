commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void invoke(PrefixCount value) { // Do nothing here }
true;public;0;64;/**  * Runs the following program.  * <pre>  *     [ (source)->(filter)->(map) ] -> [ (co-map) ] -> [ (map) ] -> [ (groupBy/reduce)->(sink) ]  * </pre>  */ ;/**  * Runs the following program.  * <pre>  *     [ (source)->(filter)->(map) ] -> [ (co-map) ] -> [ (map) ] -> [ (groupBy/reduce)->(sink) ]  * </pre>  */ @Test public void testCoStreamCheckpointingProgram() throws Exception {     assertTrue("Broken test setup", NUM_STRINGS % 40 == 0).     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(PARALLELISM).     env.enableCheckpointing(50).     env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0L)).     DataStream<String> stream = env.addSource(new StringGeneratingSourceFunction(NUM_STRINGS, NUM_STRINGS / 5)).     stream.filter(new StringRichFilterFunction()).connect(stream).flatMap(new LeftIdentityCoRichFlatMapFunction()).map(new StringPrefixCountRichMapFunction()).startNewChain().map(new StatefulCounterFunction()).keyBy("prefix").reduce(new OnceFailingReducer(NUM_STRINGS)).addSink(new SinkFunction<PrefixCount>() {          @Override         public void invoke(PrefixCount value) {         // Do nothing here         }     }).     TestUtils.tryExecute(env, "Fault Tolerance Test").     // validate the result     long filterSum = 0.     for (long l : StringRichFilterFunction.counts) {         filterSum += l.     }     long coMapSum = 0.     for (long l : LeftIdentityCoRichFlatMapFunction.counts) {         coMapSum += l.     }     long mapSum = 0.     for (long l : StringPrefixCountRichMapFunction.counts) {         mapSum += l.     }     long countSum = 0.     for (long l : StatefulCounterFunction.counts) {         countSum += l.     }     // verify that we counted exactly right     assertEquals(NUM_STRINGS, filterSum).     assertEquals(NUM_STRINGS, coMapSum).     assertEquals(NUM_STRINGS, mapSum).     assertEquals(NUM_STRINGS, countSum). }
false;public;1;41;;@Override public void run(SourceContext<String> ctx) throws Exception {     final Random rnd = new Random().     final StringBuilder stringBuilder = new StringBuilder().     final Object lockingObject = ctx.getCheckpointLock().     final int step = getRuntimeContext().getNumberOfParallelSubtasks().     if (index < 0) {         // not been restored, so initialize         index = getRuntimeContext().getIndexOfThisSubtask().     }     while (isRunning && index < numElements) {         char first = (char) ((index % 40) + 40).         stringBuilder.setLength(0).         stringBuilder.append(first).         String result = randomString(stringBuilder, rnd).         // noinspection SynchronizationOnLocalVariableOrMethodParameter         synchronized (lockingObject) {             index += step.             ctx.collect(result).         }         if (numCompletedCheckpoints < 2) {             // not yet completed enough checkpoints, so slow down             if (index < checkpointLatestAt) {                 // mild slow down                 Thread.sleep(1).             } else {                 // wait until the checkpoints are completed                 while (isRunning && numCompletedCheckpoints < 2) {                     Thread.sleep(5).                 }             }         }     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;2;4;;@Override public List<Integer> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.index). }
false;public;1;7;;@Override public void restoreState(List<Integer> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.index = state.get(0). }
false;public;1;6;;@Override public void notifyCheckpointComplete(long checkpointId) throws Exception {     if (getRuntimeContext().getIndexOfThisSubtask() == 0) {         numCompletedCheckpoints++.     } }
false;private,static;2;10;;private static String randomString(StringBuilder bld, Random rnd) {     final int len = rnd.nextInt(10) + 5.     for (int i = 0. i < len. i++) {         char next = (char) (rnd.nextInt(20000) + 33).         bld.append(next).     }     return bld.toString(). }
false;public;1;5;;@Override public PrefixCount map(PrefixCount value) throws Exception {     count++.     return value. }
false;public;0;4;;@Override public void close() throws IOException {     counts[getRuntimeContext().getIndexOfThisSubtask()] = count. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;1;8;;@Override public void open(Configuration parameters) {     long failurePosMin = (long) (0.4 * numElements / getRuntimeContext().getNumberOfParallelSubtasks()).     long failurePosMax = (long) (0.7 * numElements / getRuntimeContext().getNumberOfParallelSubtasks()).     failurePos = (new Random().nextLong() % (failurePosMax - failurePosMin)) + failurePosMin.     count = 0. }
false;public;2;11;;@Override public PrefixCount reduce(PrefixCount value1, PrefixCount value2) throws Exception {     count++.     if (!hasFailed && count >= failurePos) {         hasFailed = true.         throw new Exception("Test Failure").     }     value1.count += value2.count.     return value1. }
false;public;1;5;;@Override public boolean filter(String value) {     count++.     return value.length() < 100. }
false;public;0;4;;@Override public void close() {     counts[getRuntimeContext().getIndexOfThisSubtask()] = count. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;1;5;;@Override public PrefixCount map(String value) {     count += 1.     return new PrefixCount(value.substring(0, 1), value, 1L). }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;0;4;;@Override public void close() throws IOException {     counts[getRuntimeContext().getIndexOfThisSubtask()] = count. }
false;public;2;6;;@Override public void flatMap1(String value, Collector<String> out) {     count += 1.     out.collect(value). }
false;public;2;4;;@Override public void flatMap2(String value, Collector<String> out) { // we ignore the values from the second input }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;0;4;;@Override public void close() throws IOException {     counts[getRuntimeContext().getIndexOfThisSubtask()] = count. }
false;public;0;4;;@Override public String toString() {     return prefix + " / " + value. }
