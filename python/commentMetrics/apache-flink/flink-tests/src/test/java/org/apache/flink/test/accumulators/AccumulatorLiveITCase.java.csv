commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;7;;private static Configuration getConfiguration() {     Configuration config = new Configuration().     config.setString(AkkaOptions.ASK_TIMEOUT, TestingUtils.DEFAULT_AKKA_ASK_TIMEOUT()).     config.setLong(HeartbeatManagerOptions.HEARTBEAT_INTERVAL, HEARTBEAT_INTERVAL).     return config. }
false;public;0;4;;@Before public void resetLatches() throws InterruptedException {     NotifyingMapper.reset(). }
false;public;0;15;;@Test public void testBatch() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(1).     DataSet<Integer> input = env.fromCollection(inputData).     input.flatMap(new NotifyingMapper()).output(new DummyOutputFormat()).     // Extract job graph and set job id for the task to notify of accumulator changes.     JobGraph jobGraph = getJobGraph(env.createProgramPlan()).     submitJobAndVerifyResults(jobGraph). }
false;public;0;15;;@Test public void testStreaming() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(1).     DataStream<Integer> input = env.fromCollection(inputData).     input.flatMap(new NotifyingMapper()).writeUsingOutputFormat(new DummyOutputFormat()).disableChaining().     JobGraph jobGraph = env.getStreamGraph().getJobGraph().     submitJobAndVerifyResults(jobGraph). }
false;public;0;4;;@Override public void go() throws Exception {     client.submitJob(jobGraph, AccumulatorLiveITCase.class.getClassLoader()). }
false;private,static;1;41;;private static void submitJobAndVerifyResults(JobGraph jobGraph) throws Exception {     Deadline deadline = Deadline.now().plus(Duration.ofSeconds(30)).     final ClusterClient<?> client = MINI_CLUSTER_RESOURCE.getClusterClient().     final CheckedThread submissionThread = new CheckedThread() {          @Override         public void go() throws Exception {             client.submitJob(jobGraph, AccumulatorLiveITCase.class.getClassLoader()).         }     }.     submissionThread.start().     try {         NotifyingMapper.notifyLatch.await().         FutureUtils.retrySuccessfulWithDelay(() -> {             try {                 return CompletableFuture.completedFuture(client.getAccumulators(jobGraph.getJobID())).             } catch (Exception e) {                 return FutureUtils.completedExceptionally(e).             }         }, Time.milliseconds(20), deadline, accumulators -> accumulators.size() == 1 && accumulators.containsKey(ACCUMULATOR_NAME) && (int) accumulators.get(ACCUMULATOR_NAME).getUnchecked() == NUM_ITERATIONS, TestingUtils.defaultScheduledExecutor()).get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS).         NotifyingMapper.shutdownLatch.trigger().     } finally {         NotifyingMapper.shutdownLatch.trigger().         // wait for the job to have terminated         submissionThread.sync().     } }
false;public;1;4;;@Override public void open(Configuration parameters) throws Exception {     getRuntimeContext().addAccumulator(ACCUMULATOR_NAME, counter). }
false;public;2;9;;@Override public void flatMap(Integer value, Collector<Integer> out) throws Exception {     counter.add(1).     out.collect(value).     LOG.debug("Emitting value {}.", value).     if (counter.getLocalValuePrimitive() == 5) {         notifyLatch.trigger().     } }
false;public;0;4;;@Override public void close() throws Exception {     shutdownLatch.await(). }
false;private,static;0;4;;private static void reset() throws InterruptedException {     notifyLatch.reset().     shutdownLatch.reset(). }
false;public;1;3;;@Override public void configure(Configuration parameters) { }
false;public;2;3;;@Override public void open(int taskNumber, int numTasks) throws IOException { }
false;public;1;3;;@Override public void writeRecord(Integer record) throws IOException { }
false;public;0;3;;@Override public void close() throws IOException { }
true;private,static;1;6;/**  * Helpers to generate the JobGraph.  */ ;/**  * Helpers to generate the JobGraph.  */ private static JobGraph getJobGraph(Plan plan) {     Optimizer pc = new Optimizer(new DataStatistics(), new Configuration()).     JobGraphGenerator jgg = new JobGraphGenerator().     OptimizedPlan op = pc.compile(plan).     return jgg.compileJobGraph(op). }
