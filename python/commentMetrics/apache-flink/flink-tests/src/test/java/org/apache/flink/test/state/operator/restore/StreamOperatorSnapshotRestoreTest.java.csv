commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@Parameterized.Parameters(name = "statebackend type ={0}") public static Collection<StateBackendEnum> parameter() {     return Arrays.asList(StateBackendEnum.values()). }
false;public,static;0;5;;@BeforeClass public static void beforeClass() throws IOException {     temporaryFolder = new TemporaryFolder().     temporaryFolder.create(). }
false;public,static;0;4;;@AfterClass public static void afterClass() {     temporaryFolder.delete(). }
true;public;0;4;/**  * Test restoring an operator from a snapshot (local recovery deactivated).  */ ;/**  * Test restoring an operator from a snapshot (local recovery deactivated).  */ @Test public void testOperatorStatesSnapshotRestore() throws Exception {     testOperatorStatesSnapshotRestoreInternal(ONLY_JM_RECOVERY). }
true;public;0;4;/**  * Test restoring an operator from a snapshot (local recovery activated).  */ ;/**  * Test restoring an operator from a snapshot (local recovery activated).  */ @Test public void testOperatorStatesSnapshotRestoreWithLocalState() throws Exception {     testOperatorStatesSnapshotRestoreInternal(TM_AND_JM_RECOVERY). }
true;public;0;4;/**  * Test restoring an operator from a snapshot (local recovery activated, JM snapshot deleted).  *  * <p>This case does not really simulate a practical scenario, but we make sure that restore happens from the local  * state here because we discard the JM state.  */ ;/**  * Test restoring an operator from a snapshot (local recovery activated, JM snapshot deleted).  *  * <p>This case does not really simulate a practical scenario, but we make sure that restore happens from the local  * state here because we discard the JM state.  */ @Test public void testOperatorStatesSnapshotRestoreWithLocalStateDeletedJM() throws Exception {     testOperatorStatesSnapshotRestoreInternal(TM_REMOVE_JM_RECOVERY). }
true;public;0;4;/**  * Test restoring an operator from a snapshot (local recovery activated, local TM snapshot deleted).  *  * <p>This tests discards the local state, to simulate corruption and checks that we still recover from the fallback  * JM state.  */ ;/**  * Test restoring an operator from a snapshot (local recovery activated, local TM snapshot deleted).  *  * <p>This tests discards the local state, to simulate corruption and checks that we still recover from the fallback  * JM state.  */ @Test public void testOperatorStatesSnapshotRestoreWithLocalStateDeletedTM() throws Exception {     testOperatorStatesSnapshotRestoreInternal(JM_REMOVE_TM_RECOVERY). }
false;protected;3;8;;@Override protected <K> InternalTimeServiceManager<K> internalTimeServiceManager(AbstractKeyedStateBackend<K> keyedStatedBackend, KeyContext keyContext, Iterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {     return null. }
false;protected;3;17;;/* subtask index */ @Override protected StreamTaskStateInitializer createStreamTaskStateManager(Environment env, StateBackend stateBackend, ProcessingTimeService processingTimeService) {     return new StreamTaskStateInitializerImpl(env, stateBackend, processingTimeService) {          @Override         protected <K> InternalTimeServiceManager<K> internalTimeServiceManager(AbstractKeyedStateBackend<K> keyedStatedBackend, KeyContext keyContext, Iterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {             return null.         }     }. }
false;private;1;117;;private void testOperatorStatesSnapshotRestoreInternal(final int mode) throws Exception {     // -------------------------------------------------------------------------- snapshot     StateBackend stateBackend.     FsStateBackend fsstateBackend = createStateBackendInternal().     switch(stateBackendEnum) {         case FILE:             stateBackend = fsstateBackend.             break.         case ROCKSDB_FULLY_ASYNC:             stateBackend = new RocksDBStateBackend(fsstateBackend, false).             break.         case ROCKSDB_INCREMENTAL:             stateBackend = new RocksDBStateBackend(fsstateBackend, true).             break.         default:             throw new IllegalStateException(String.format("Do not support statebackend type %s", stateBackendEnum)).     }     TestOneInputStreamOperator op = new TestOneInputStreamOperator(false).     JobID jobID = new JobID().     JobVertexID jobVertexID = new JobVertexID().     int subtaskIdx = 0.     LocalRecoveryDirectoryProvider directoryProvider = new LocalRecoveryDirectoryProviderImpl(temporaryFolder.newFolder(), jobID, jobVertexID, subtaskIdx).     LocalRecoveryConfig localRecoveryConfig = new LocalRecoveryConfig(mode != ONLY_JM_RECOVERY, directoryProvider).     MockEnvironment mockEnvironment = new MockEnvironmentBuilder().setJobID(jobID).setJobVertexID(jobVertexID).setTaskName("test").setMemorySize(1024L * 1024L).setInputSplitProvider(new MockInputSplitProvider()).setBufferSize(1024 * 1024).setTaskStateManager(new TestTaskStateManager(localRecoveryConfig)).setMaxParallelism(MAX_PARALLELISM).setSubtaskIndex(subtaskIdx).setUserCodeClassLoader(getClass().getClassLoader()).build().     KeyedOneInputStreamOperatorTestHarness<Integer, Integer, Integer> testHarness = new KeyedOneInputStreamOperatorTestHarness<>(op, (KeySelector<Integer, Integer>) value -> value, TypeInformation.of(Integer.class), mockEnvironment).     testHarness.setStateBackend(stateBackend).     testHarness.open().     for (int i = 0. i < 10. ++i) {         testHarness.processElement(new StreamRecord<>(i)).     }     OperatorSnapshotFinalizer snapshotWithLocalState = testHarness.snapshotWithLocalState(1L, 1L).     testHarness.close().     // -------------------------------------------------------------------------- restore     op = new TestOneInputStreamOperator(true).     testHarness = new KeyedOneInputStreamOperatorTestHarness<Integer, Integer, Integer>(op, (KeySelector<Integer, Integer>) value -> value, TypeInformation.of(Integer.class), MAX_PARALLELISM, 1, /* num subtasks */     0) {          /* subtask index */         @Override         protected StreamTaskStateInitializer createStreamTaskStateManager(Environment env, StateBackend stateBackend, ProcessingTimeService processingTimeService) {             return new StreamTaskStateInitializerImpl(env, stateBackend, processingTimeService) {                  @Override                 protected <K> InternalTimeServiceManager<K> internalTimeServiceManager(AbstractKeyedStateBackend<K> keyedStatedBackend, KeyContext keyContext, Iterable<KeyGroupStatePartitionStreamProvider> rawKeyedStates) throws Exception {                     return null.                 }             }.         }     }.     testHarness.setStateBackend(stateBackend).     OperatorSubtaskState jobManagerOwnedState = snapshotWithLocalState.getJobManagerOwnedState().     OperatorSubtaskState taskLocalState = snapshotWithLocalState.getTaskLocalState().     // We check if local state was created when we enabled local recovery     Assert.assertTrue(mode > ONLY_JM_RECOVERY == (taskLocalState != null && taskLocalState.hasState())).     if (mode == TM_REMOVE_JM_RECOVERY) {         jobManagerOwnedState.getManagedKeyedState().discardState().     } else if (mode == JM_REMOVE_TM_RECOVERY) {         taskLocalState.getManagedKeyedState().discardState().     }     testHarness.initializeState(jobManagerOwnedState, taskLocalState).     testHarness.open().     for (int i = 0. i < 10. ++i) {         testHarness.processElement(new StreamRecord<>(i)).     }     testHarness.close(). }
false;private;0;4;;private FsStateBackend createStateBackendInternal() throws IOException {     File checkpointDir = temporaryFolder.newFolder().     return new FsStateBackend(checkpointDir.toURI()). }
false;public;1;14;;@Override public void processElement(StreamRecord<Integer> element) throws Exception {     if (verifyRestore) {         // check restored managed keyed state         long exp = element.getValue() + 1.         long act = keyedState.value().         Assert.assertEquals(exp, act).     } else {         // write managed keyed state that goes into snapshot         keyedState.update(element.getValue() + 1).         // write managed operator state that goes into snapshot         opState.add(element.getValue()).     } }
false;public;1;4;;@Override public void processWatermark(Watermark mark) { }
false;public;1;24;;@Override public void snapshotState(StateSnapshotContext context) throws Exception {     KeyedStateCheckpointOutputStream out = context.getRawKeyedOperatorStateOutput().     DataOutputView dov = new DataOutputViewStreamWrapper(out).     // write raw keyed state that goes into snapshot     int count = 0.     for (int kg : out.getKeyGroupList()) {         out.startNewKeyGroup(kg).         dov.writeInt(kg + 2).         ++count.     }     Assert.assertEquals(MAX_PARALLELISM, count).     // write raw operator state that goes into snapshot     OperatorStateCheckpointOutputStream outOp = context.getRawOperatorStateOutput().     dov = new DataOutputViewStreamWrapper(outOp).     for (int i = 0. i < 13. ++i) {         outOp.startNewPartition().         dov.writeInt(42 + i).     } }
false;public;1;44;;@Override public void initializeState(StateInitializationContext context) throws Exception {     Assert.assertEquals(verifyRestore, context.isRestored()).     keyedState = context.getKeyedStateStore().getState(new ValueStateDescriptor<>("managed-keyed", Integer.class, 0)).     opState = context.getOperatorStateStore().getListState(new ListStateDescriptor<>("managed-op-state", IntSerializer.INSTANCE)).     if (context.isRestored()) {         // check restored raw keyed state         int count = 0.         for (KeyGroupStatePartitionStreamProvider streamProvider : context.getRawKeyedStateInputs()) {             try (InputStream in = streamProvider.getStream()) {                 DataInputView div = new DataInputViewStreamWrapper(in).                 Assert.assertEquals(streamProvider.getKeyGroupId() + 2, div.readInt()).                 ++count.             }         }         Assert.assertEquals(MAX_PARALLELISM, count).         // check restored managed operator state         BitSet check = new BitSet(10).         for (int v : opState.get()) {             check.set(v).         }         Assert.assertEquals(10, check.cardinality()).         // check restored raw operator state         check = new BitSet(13).         for (StatePartitionStreamProvider streamProvider : context.getRawOperatorStateInputs()) {             try (InputStream in = streamProvider.getStream()) {                 DataInputView div = new DataInputViewStreamWrapper(in).                 check.set(div.readInt() - 42).             }         }         Assert.assertEquals(13, check.cardinality()).     } }
