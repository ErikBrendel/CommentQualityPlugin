commented;modifiers;parameterAmount;loc;comment;code
false;public;0;74;;@Test public void testWorksetConnectedComponents() {     Plan plan = getConnectedComponentsCoGroupPlan().     plan.setExecutionConfig(new ExecutionConfig()).     OptimizedPlan optPlan = compileNoStats(plan).     OptimizerPlanNodeResolver or = getOptimizerPlanNodeResolver(optPlan).     if (PRINT_PLAN) {         PlanJSONDumpGenerator dumper = new PlanJSONDumpGenerator().         String json = dumper.getOptimizerPlanAsJSON(optPlan).         System.out.println(json).     }     SourcePlanNode vertexSource = or.getNode(VERTEX_SOURCE).     SourcePlanNode edgesSource = or.getNode(EDGES_SOURCE).     SinkPlanNode sink = or.getNode(SINK).     WorksetIterationPlanNode iter = or.getNode(ITERATION_NAME).     DualInputPlanNode neighborsJoin = or.getNode(JOIN_NEIGHBORS_MATCH).     DualInputPlanNode cogroup = or.getNode(MIN_ID_AND_UPDATE).     // --------------------------------------------------------------------     // Plan validation:     //      // We expect the plan to go with a sort-merge join, because the CoGroup     // sorts and the join in the successive iteration can re-exploit the sorting.     // --------------------------------------------------------------------     // test all drivers     Assert.assertEquals(DriverStrategy.NONE, sink.getDriverStrategy()).     Assert.assertEquals(DriverStrategy.NONE, vertexSource.getDriverStrategy()).     Assert.assertEquals(DriverStrategy.NONE, edgesSource.getDriverStrategy()).     Assert.assertEquals(DriverStrategy.INNER_MERGE, neighborsJoin.getDriverStrategy()).     Assert.assertEquals(set0, neighborsJoin.getKeysForInput1()).     Assert.assertEquals(set0, neighborsJoin.getKeysForInput2()).     Assert.assertEquals(DriverStrategy.CO_GROUP, cogroup.getDriverStrategy()).     Assert.assertEquals(set0, cogroup.getKeysForInput1()).     Assert.assertEquals(set0, cogroup.getKeysForInput2()).     // test all the shipping strategies     Assert.assertEquals(ShipStrategyType.FORWARD, sink.getInput().getShipStrategy()).     Assert.assertEquals(ShipStrategyType.PARTITION_HASH, iter.getInitialSolutionSetInput().getShipStrategy()).     Assert.assertEquals(set0, iter.getInitialSolutionSetInput().getShipStrategyKeys()).     Assert.assertEquals(ShipStrategyType.PARTITION_HASH, iter.getInitialWorksetInput().getShipStrategy()).     Assert.assertEquals(set0, iter.getInitialWorksetInput().getShipStrategyKeys()).     // workset     Assert.assertEquals(ShipStrategyType.FORWARD, neighborsJoin.getInput1().getShipStrategy()).     // edges     Assert.assertEquals(ShipStrategyType.PARTITION_HASH, neighborsJoin.getInput2().getShipStrategy()).     Assert.assertEquals(set0, neighborsJoin.getInput2().getShipStrategyKeys()).     Assert.assertTrue(neighborsJoin.getInput2().getTempMode().isCached()).     // min id     Assert.assertEquals(ShipStrategyType.PARTITION_HASH, cogroup.getInput1().getShipStrategy()).     // solution set     Assert.assertEquals(ShipStrategyType.FORWARD, cogroup.getInput2().getShipStrategy()).     // test all the local strategies     Assert.assertEquals(LocalStrategy.NONE, sink.getInput().getLocalStrategy()).     Assert.assertEquals(LocalStrategy.NONE, iter.getInitialSolutionSetInput().getLocalStrategy()).     // the sort for the neighbor join in the first iteration is pushed out of the loop     Assert.assertEquals(LocalStrategy.SORT, iter.getInitialWorksetInput().getLocalStrategy()).     // workset     Assert.assertEquals(LocalStrategy.NONE, neighborsJoin.getInput1().getLocalStrategy()).     // edges     Assert.assertEquals(LocalStrategy.SORT, neighborsJoin.getInput2().getLocalStrategy()).     Assert.assertEquals(LocalStrategy.SORT, cogroup.getInput1().getLocalStrategy()).     // solution set     Assert.assertEquals(LocalStrategy.NONE, cogroup.getInput2().getLocalStrategy()).     // check the caches     Assert.assertTrue(TempMode.CACHED == neighborsJoin.getInput2().getTempMode()).     JobGraphGenerator jgg = new JobGraphGenerator().     jgg.compileJobGraph(optPlan). }
false;public,static;0;14;;public static Plan getConnectedComponentsCoGroupPlan() {     // prepare the test environment     PreviewPlanEnvironment env = new PreviewPlanEnvironment().     env.setAsContext().     try {         connectedComponentsWithCoGroup(new String[] { DEFAULT_PARALLELISM_STRING, IN_FILE, IN_FILE, OUT_FILE, "100" }).     } catch (ProgramAbortException pae) {     // all good.     } catch (Exception e) {         e.printStackTrace().         Assert.fail("connectedComponentsWithCoGroup failed with an exception").     }     return env.getPlan(). }
false;public,static;1;25;;public static void connectedComponentsWithCoGroup(String[] args) throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(Integer.parseInt(args[0])).     DataSet<Tuple1<Long>> initialVertices = env.readCsvFile(args[1]).types(Long.class).name(VERTEX_SOURCE).     DataSet<Tuple2<Long, Long>> edges = env.readCsvFile(args[2]).types(Long.class, Long.class).name(EDGES_SOURCE).     DataSet<Tuple2<Long, Long>> verticesWithId = initialVertices.flatMap(new DummyMapFunction()).     DeltaIteration<Tuple2<Long, Long>, Tuple2<Long, Long>> iteration = verticesWithId.iterateDelta(verticesWithId, Integer.parseInt(args[4]), 0).name(ITERATION_NAME).     DataSet<Tuple2<Long, Long>> joinWithNeighbors = iteration.getWorkset().join(edges).where(0).equalTo(0).with(new DummyJoinFunction()).name(JOIN_NEIGHBORS_MATCH).     DataSet<Tuple2<Long, Long>> minAndUpdate = joinWithNeighbors.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(new DummyCoGroupFunction()).name(MIN_ID_AND_UPDATE).     iteration.closeWith(minAndUpdate, minAndUpdate).writeAsCsv(args[3]).name(SINK).     env.execute(). }
false;public;2;4;;@Override public void flatMap(Tuple1<Long> value, Collector<Tuple2<Long, Long>> out) throws Exception { // won't be executed }
false;public;3;4;;@Override public void join(Tuple2<Long, Long> first, Tuple2<Long, Long> second, Collector<Tuple2<Long, Long>> out) throws Exception { // won't be executed }
false;public;3;4;;@Override public void coGroup(Iterable<Tuple2<Long, Long>> first, Iterable<Tuple2<Long, Long>> second, Collector<Tuple2<Long, Long>> out) throws Exception { // won't be executed }
