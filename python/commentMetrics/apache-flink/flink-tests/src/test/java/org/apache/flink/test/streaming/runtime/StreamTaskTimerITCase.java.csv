commented;modifiers;parameterAmount;loc;comment;code
true;public;0;33;/**  * Note: this test fails if we don't check for exceptions in the source contexts and do not  * synchronize in the source contexts.  */ ;/**  * Note: this test fails if we don't check for exceptions in the source contexts and do not  * synchronize in the source contexts.  */ @Test public void testOperatorChainedToSource() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(timeCharacteristic).     env.setParallelism(1).     DataStream<String> source = env.addSource(new InfiniteTestSource()).     source.transform("Custom Operator", BasicTypeInfo.STRING_TYPE_INFO, new TimerOperator(ChainingStrategy.ALWAYS)).     boolean testSuccess = false.     try {         env.execute("Timer test").     } catch (JobExecutionException e) {         if (e.getCause() instanceof TimerException) {             TimerException te = (TimerException) e.getCause().             if (te.getCause() instanceof RuntimeException) {                 RuntimeException re = (RuntimeException) te.getCause().                 if (re.getMessage().equals("TEST SUCCESS")) {                     testSuccess = true.                 } else {                     throw e.                 }             } else {                 throw e.             }         } else {             throw e.         }     }     Assert.assertTrue(testSuccess). }
true;public;0;32;/**  * Note: this test fails if we don't check for exceptions in the source contexts and do not  * synchronize in the source contexts.  */ ;/**  * Note: this test fails if we don't check for exceptions in the source contexts and do not  * synchronize in the source contexts.  */ @Test public void testOneInputOperatorWithoutChaining() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(timeCharacteristic).     env.setParallelism(1).     DataStream<String> source = env.addSource(new InfiniteTestSource()).     source.transform("Custom Operator", BasicTypeInfo.STRING_TYPE_INFO, new TimerOperator(ChainingStrategy.NEVER)).     boolean testSuccess = false.     try {         env.execute("Timer test").     } catch (JobExecutionException e) {         if (e.getCause() instanceof TimerException) {             TimerException te = (TimerException) e.getCause().             if (te.getCause() instanceof RuntimeException) {                 RuntimeException re = (RuntimeException) te.getCause().                 if (re.getMessage().equals("TEST SUCCESS")) {                     testSuccess = true.                 } else {                     throw e.                 }             } else {                 throw e.             }         } else {             throw e.         }     }     Assert.assertTrue(testSuccess). }
false;public;0;35;;@Test public void testTwoInputOperatorWithoutChaining() throws Exception {     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(timeCharacteristic).     env.setParallelism(1).     DataStream<String> source = env.addSource(new InfiniteTestSource()).     source.connect(source).transform("Custom Operator", BasicTypeInfo.STRING_TYPE_INFO, new TwoInputTimerOperator(ChainingStrategy.NEVER)).     boolean testSuccess = false.     try {         env.execute("Timer test").     } catch (JobExecutionException e) {         if (e.getCause() instanceof TimerException) {             TimerException te = (TimerException) e.getCause().             if (te.getCause() instanceof RuntimeException) {                 RuntimeException re = (RuntimeException) te.getCause().                 if (re.getMessage().equals("TEST SUCCESS")) {                     testSuccess = true.                 } else {                     throw e.                 }             } else {                 throw e.             }         } else {             throw e.         }     }     Assert.assertTrue(testSuccess). }
false;public;1;14;;@Override public void processElement(StreamRecord<String> element) throws Exception {     if (!semaphore.tryAcquire()) {         Assert.fail("Concurrent invocation of operator functions.").     }     if (first) {         getProcessingTimeService().registerTimer(System.currentTimeMillis() + 100, this).         first = false.     }     numElements++.     semaphore.release(). }
false;public;1;14;;@Override public void onProcessingTime(long time) throws Exception {     if (!semaphore.tryAcquire()) {         Assert.fail("Concurrent invocation of operator functions.").     }     try {         numTimers++.         throwIfDone().         getProcessingTimeService().registerTimer(System.currentTimeMillis() + 1, this).     } finally {         semaphore.release().     } }
false;private;0;5;;private void throwIfDone() {     if (numTimers > 1000 && numElements > 10_000) {         throw new RuntimeException("TEST SUCCESS").     } }
false;public;1;7;;@Override public void processWatermark(Watermark mark) throws Exception {     if (!semaphore.tryAcquire()) {         Assert.fail("Concurrent invocation of operator functions.").     }     semaphore.release(). }
false;public;1;14;;@Override public void processElement1(StreamRecord<String> element) throws Exception {     if (!semaphore.tryAcquire()) {         Assert.fail("Concurrent invocation of operator functions.").     }     if (first) {         getProcessingTimeService().registerTimer(System.currentTimeMillis() + 100, this).         first = false.     }     numElements++.     semaphore.release(). }
false;public;1;14;;@Override public void processElement2(StreamRecord<String> element) throws Exception {     if (!semaphore.tryAcquire()) {         Assert.fail("Concurrent invocation of operator functions.").     }     if (first) {         getProcessingTimeService().registerTimer(System.currentTimeMillis() + 100, this).         first = false.     }     numElements++.     semaphore.release(). }
false;public;1;14;;@Override public void onProcessingTime(long time) throws Exception {     if (!semaphore.tryAcquire()) {         Assert.fail("Concurrent invocation of operator functions.").     }     try {         numTimers++.         throwIfDone().         getProcessingTimeService().registerTimer(System.currentTimeMillis() + 1, this).     } finally {         semaphore.release().     } }
false;private;0;5;;private void throwIfDone() {     if (numTimers > 1000 && numElements > 10_000) {         throw new RuntimeException("TEST SUCCESS").     } }
false;public;1;4;;@Override public void processWatermark1(Watermark mark) throws Exception { // ignore }
false;public;1;4;;@Override public void processWatermark2(Watermark mark) throws Exception { // ignore }
false;public;1;6;;@Override public void run(SourceContext<String> ctx) throws Exception {     while (running) {         ctx.collect("hello").     } }
false;public;0;4;;@Override public void cancel() {     running = false. }
false;public,static;0;7;;// ------------------------------------------------------------------------ // parametrization // ------------------------------------------------------------------------ @Parameterized.Parameters(name = "Time Characteristic = {0}") public static Collection<Object[]> executionModes() {     return Arrays.asList(new Object[] { TimeCharacteristic.ProcessingTime }, new Object[] { TimeCharacteristic.IngestionTime }, new Object[] { TimeCharacteristic.EventTime }). }
