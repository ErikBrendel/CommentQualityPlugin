commented;modifiers;parameterAmount;loc;comment;code
true;public;1;29;/**  * Runs the following program.  * <pre>  *     [ (source)->(filter)] -> [ (map) -> (map) ] -> [ (groupBy/reduce)->(sink) ]  * </pre>  */ ;/**  * Runs the following program.  * <pre>  *     [ (source)->(filter)] -> [ (map) -> (map) ] -> [ (groupBy/reduce)->(sink) ]  * </pre>  */ @Override public void testProgram(StreamExecutionEnvironment env) {     assertTrue("Broken test setup", NUM_STRINGS % 40 == 0).     final long failurePosMin = (long) (0.4 * NUM_STRINGS / PARALLELISM).     final long failurePosMax = (long) (0.7 * NUM_STRINGS / PARALLELISM).     final long failurePos = (new Random().nextLong() % (failurePosMax - failurePosMin)) + failurePosMin.     env.enableCheckpointing(200).     DataStream<String> stream = env.addSource(new StringGeneratingSourceFunction(NUM_STRINGS)).     stream.filter(new StringRichFilterFunction()).map(new StringPrefixCountRichMapFunction()).startNewChain().map(new StatefulCounterFunction()).keyBy("prefix").flatMap(new OnceFailingAggregator(failurePos)).addSink(new ValidatingSink()). }
false;public;0;35;;@Override public void postSubmit() {     // OnceFailingAggregator.wasCheckpointedBeforeFailure).     if (!OnceFailingAggregator.wasCheckpointedBeforeFailure) {         LOG.warn("Test inconclusive: failure occurred before first checkpoint").     }     long filterSum = 0.     for (long l : StringRichFilterFunction.counts) {         filterSum += l.     }     long mapSum = 0.     for (long l : StringPrefixCountRichMapFunction.counts) {         mapSum += l.     }     long countSum = 0.     for (long l : StatefulCounterFunction.counts) {         countSum += l.     }     // verify that we counted exactly right     assertEquals(NUM_STRINGS, filterSum).     assertEquals(NUM_STRINGS, mapSum).     assertEquals(NUM_STRINGS, countSum).     for (Map<Character, Long> map : ValidatingSink.maps) {         for (Long count : map.values()) {             assertEquals(NUM_STRINGS / 40, count.longValue()).         }     } }
false;public;1;27;;@Override public void run(SourceContext<String> ctx) throws Exception {     final Object lockingObject = ctx.getCheckpointLock().     final Random rnd = new Random().     final StringBuilder stringBuilder = new StringBuilder().     final int step = getRuntimeContext().getNumberOfParallelSubtasks().     if (index == 0) {         index = getRuntimeContext().getIndexOfThisSubtask().     }     while (isRunning && index < numElements) {         char first = (char) ((index % 40) + 40).         stringBuilder.setLength(0).         stringBuilder.append(first).         String result = randomString(stringBuilder, rnd).         synchronized (lockingObject) {             index += step.             ctx.collect(result).         }     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;private,static;2;10;;private static String randomString(StringBuilder bld, Random rnd) {     final int len = rnd.nextInt(10) + 5.     for (int i = 0. i < len. i++) {         char next = (char) (rnd.nextInt(20000) + 33).         bld.append(next).     }     return bld.toString(). }
false;public;2;4;;@Override public List<Integer> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.index). }
false;public;1;7;;@Override public void restoreState(List<Integer> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.index = state.get(0). }
false;public;1;5;;@Override public boolean filter(String value) throws Exception {     count++.     // should be always true     return value.length() < 100. }
false;public;0;4;;@Override public void close() {     counts[getRuntimeContext().getIndexOfThisSubtask()] = count. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;1;5;;@Override public PrefixCount map(String value) {     count++.     return new PrefixCount(value.substring(0, 1), value, 1L). }
false;public;0;4;;@Override public void close() {     counts[getRuntimeContext().getIndexOfThisSubtask()] = count. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;1;5;;@Override public PrefixCount map(PrefixCount value) throws Exception {     count++.     return value. }
false;public;0;4;;@Override public void close() throws IOException {     counts[getRuntimeContext().getIndexOfThisSubtask()] = count. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;1;4;;@Override public void open(Configuration parameters) {     count = 0. }
false;public;2;19;;@Override public void flatMap(PrefixCount value, Collector<PrefixCount> out) throws Exception {     count++.     if (!hasFailed && count >= failurePos && getRuntimeContext().getIndexOfThisSubtask() == 1) {         wasCheckpointedBeforeFailure = wasCheckpointed.         hasFailed = true.         throw new Exception("Test Failure").     }     PrefixCount curr = aggregationMap.get(value.prefix).     if (curr == null) {         aggregationMap.put(value.prefix, value).         out.collect(value).     } else {         curr.count += value.count.         out.collect(curr).     } }
false;public;2;4;;@Override public List<HashMap<String, PrefixCount>> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.aggregationMap). }
false;public;1;7;;@Override public void restoreState(List<HashMap<String, PrefixCount>> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.aggregationMap.putAll(state.get(0)). }
false;public;1;4;;@Override public void notifyCheckpointComplete(long checkpointId) {     this.wasCheckpointed = true. }
false;public;1;10;;@Override public void invoke(PrefixCount value) {     Character first = value.prefix.charAt(0).     Long previous = counts.get(first).     if (previous == null) {         counts.put(first, value.count).     } else {         counts.put(first, Math.max(previous, value.count)).     } }
false;public;0;4;;@Override public void close() throws Exception {     maps[getRuntimeContext().getIndexOfThisSubtask()] = counts. }
false;public;2;4;;@Override public List<HashMap<Character, Long>> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.counts). }
false;public;1;7;;@Override public void restoreState(List<HashMap<Character, Long>> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.counts.putAll(state.get(0)). }
