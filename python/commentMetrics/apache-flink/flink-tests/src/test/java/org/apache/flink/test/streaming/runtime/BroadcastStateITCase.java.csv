commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public long extractTimestamp(Long element, long previousElementTimestamp) {     return element. }
false;public;2;4;;@Override public long extractTimestamp(String element, long previousElementTimestamp) {     return Long.parseLong(element.split(":")[1]). }
false;public;0;51;;@Test public void testKeyedWithBroadcastTranslation() throws Exception {     final MapStateDescriptor<Long, String> utterDescriptor = new MapStateDescriptor<>("broadcast-state", BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO).     final Map<Long, String> expected = new HashMap<>().     expected.put(0L, "test:0").     expected.put(1L, "test:1").     expected.put(2L, "test:2").     expected.put(3L, "test:3").     expected.put(4L, "test:4").     expected.put(5L, "test:5").     final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     final DataStream<Long> srcOne = env.generateSequence(0L, 5L).assignTimestampsAndWatermarks(new CustomWmEmitter<Long>() {          private static final long serialVersionUID = -8500904795760316195L.          @Override         public long extractTimestamp(Long element, long previousElementTimestamp) {             return element.         }     }).keyBy((KeySelector<Long, Long>) value -> value).     final DataStream<String> srcTwo = env.fromCollection(expected.values()).assignTimestampsAndWatermarks(new CustomWmEmitter<String>() {          private static final long serialVersionUID = -2148318224248467213L.          @Override         public long extractTimestamp(String element, long previousElementTimestamp) {             return Long.parseLong(element.split(":")[1]).         }     }).     final BroadcastStream<String> broadcast = srcTwo.broadcast(utterDescriptor).     // the timestamp should be high enough to trigger the timer after all the elements arrive.     final DataStream<String> output = srcOne.connect(broadcast).process(new TestKeyedBroadcastProcessFunction(100000L, expected)).     output.addSink(new TestSink(expected.size())).setParallelism(1).     env.execute(). }
false;public;2;4;;@Override public long extractTimestamp(Long element, long previousElementTimestamp) {     return element. }
false;public;2;4;;@Override public long extractTimestamp(String element, long previousElementTimestamp) {     return Long.parseLong(element.split(":")[1]). }
false;public;0;51;;@Test public void testBroadcastTranslation() throws Exception {     final MapStateDescriptor<Long, String> utterDescriptor = new MapStateDescriptor<>("broadcast-state", BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO).     final Map<Long, String> expected = new HashMap<>().     expected.put(0L, "test:0").     expected.put(1L, "test:1").     expected.put(2L, "test:2").     expected.put(3L, "test:3").     expected.put(4L, "test:4").     expected.put(5L, "test:5").     final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     final DataStream<Long> srcOne = env.generateSequence(0L, 5L).assignTimestampsAndWatermarks(new CustomWmEmitter<Long>() {          private static final long serialVersionUID = -8500904795760316195L.          @Override         public long extractTimestamp(Long element, long previousElementTimestamp) {             return element.         }     }).     final DataStream<String> srcTwo = env.fromCollection(expected.values()).assignTimestampsAndWatermarks(new CustomWmEmitter<String>() {          private static final long serialVersionUID = -2148318224248467213L.          @Override         public long extractTimestamp(String element, long previousElementTimestamp) {             return Long.parseLong(element.split(":")[1]).         }     }).     final BroadcastStream<String> broadcast = srcTwo.broadcast(utterDescriptor).     // the timestamp should be high enough to trigger the timer after all the elements arrive.     final DataStream<String> output = srcOne.connect(broadcast).process(new TestBroadcastProcessFunction()).     output.addSink(new TestSink(0)).setParallelism(1).     env.execute(). }
false;public;2;4;;@Override public void invoke(String value, Context context) throws Exception {     outputCounter++. }
false;public;0;7;;@Override public void close() throws Exception {     super.close().     // make sure that all the timers fired     assertEquals(expectedOutputCounter, outputCounter). }
false;public;2;5;;@Nullable @Override public Watermark checkAndGetNextWatermark(T lastElement, long extractedTimestamp) {     return new Watermark(extractedTimestamp). }
false;public;1;8;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     descriptor = new MapStateDescriptor<>("broadcast-state", BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO). }
false;public;3;7;;@Override public void processElement(Long value, ReadOnlyContext ctx, Collector<String> out) throws Exception {     long currentTime = nextTimerTimestamp.     nextTimerTimestamp++.     ctx.timerService().registerEventTimeTimer(currentTime).     timerToExpectedKey.put(currentTime, value). }
false;public;3;5;;@Override public void processBroadcastElement(String value, Context ctx, Collector<String> out) throws Exception {     long key = Long.parseLong(value.split(":")[1]).     ctx.getBroadcastState(descriptor).put(key, value). }
false;public;3;13;;@Override public void onTimer(long timestamp, OnTimerContext ctx, Collector<String> out) throws Exception {     assertEquals(timerToExpectedKey.get(timestamp), ctx.getCurrentKey()).     Map<Long, String> map = new HashMap<>().     for (Map.Entry<Long, String> entry : ctx.getBroadcastState(descriptor).immutableEntries()) {         map.put(entry.getKey(), entry.getValue()).     }     assertEquals(expectedState, map).     out.collect(Long.toString(timestamp)). }
false;public;1;8;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     descriptor = new MapStateDescriptor<>("broadcast-state", BasicTypeInfo.LONG_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO). }
false;public;3;3;;@Override public void processElement(Long value, ReadOnlyContext ctx, Collector<String> out) throws Exception { }
false;public;3;5;;@Override public void processBroadcastElement(String value, Context ctx, Collector<String> out) throws Exception {     long key = Long.parseLong(value.split(":")[1]).     ctx.getBroadcastState(descriptor).put(key, value). }
