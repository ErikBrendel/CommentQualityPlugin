commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;5;;private static Configuration getConfiguration() {     Configuration config = new Configuration().     config.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, "48m").     return config. }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;4;15;;@Override public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple2<Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     for (Tuple2<Long, IntType> value : values) {         assertEquals(value.f0.intValue(), value.f1.value).         out.collect(new Tuple2<>(value.f0, new IntType(1))).     } }
false;public;0;57;;// ------------------------------------------------------------------------ @Test public void testTumblingProcessingTimeWindow() {     final int numElements = 3000.     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(timeCharacteristic).         env.getConfig().setAutoWatermarkInterval(10).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         SinkValidatorUpdaterAndChecker updaterAndChecker = new SinkValidatorUpdaterAndChecker(numElements, 1).         env.addSource(new FailingSource(new Generator(), numElements, timeCharacteristic)).rebalance().keyBy(0).timeWindow(Time.of(100, MILLISECONDS)).apply(new RichWindowFunction<Tuple2<Long, IntType>, Tuple2<Long, IntType>, Tuple, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple2<Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 for (Tuple2<Long, IntType> value : values) {                     assertEquals(value.f0.intValue(), value.f1.value).                     out.collect(new Tuple2<>(value.f0, new IntType(1))).                 }             }         }).addSink(new ValidatingSink<>(updaterAndChecker, updaterAndChecker, timeCharacteristic)).setParallelism(1).         tryExecute(env, "Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;4;15;;@Override public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple2<Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     for (Tuple2<Long, IntType> value : values) {         assertEquals(value.f0.intValue(), value.f1.value).         out.collect(new Tuple2<>(value.f0, new IntType(1))).     } }
false;public;0;55;;@Test public void testSlidingProcessingTimeWindow() {     final int numElements = 3000.     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(timeCharacteristic).         env.getConfig().setAutoWatermarkInterval(10).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         SinkValidatorUpdaterAndChecker updaterAndChecker = new SinkValidatorUpdaterAndChecker(numElements, 3).         env.addSource(new FailingSource(new Generator(), numElements, timeCharacteristic)).rebalance().keyBy(0).timeWindow(Time.of(150, MILLISECONDS), Time.of(50, MILLISECONDS)).apply(new RichWindowFunction<Tuple2<Long, IntType>, Tuple2<Long, IntType>, Tuple, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple2<Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 for (Tuple2<Long, IntType> value : values) {                     assertEquals(value.f0.intValue(), value.f1.value).                     out.collect(new Tuple2<>(value.f0, new IntType(1))).                 }             }         }).addSink(new ValidatingSink<>(updaterAndChecker, updaterAndChecker, timeCharacteristic)).setParallelism(1).         tryExecute(env, "Sliding Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;6;;@Override public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {     return new Tuple2<>(a.f0, new IntType(1)). }
false;public;1;5;;@Override public Tuple2<Long, IntType> map(Tuple2<Long, IntType> value) {     value.f1.value = 1.     return value. }
false;public;0;45;;@Test public void testAggregatingTumblingProcessingTimeWindow() {     final int numElements = 3000.     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(timeCharacteristic).         env.getConfig().setAutoWatermarkInterval(10).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         SinkValidatorUpdaterAndChecker updaterAndChecker = new SinkValidatorUpdaterAndChecker(numElements, 1).         env.addSource(new FailingSource(new Generator(), numElements, timeCharacteristic)).map(new MapFunction<Tuple2<Long, IntType>, Tuple2<Long, IntType>>() {              @Override             public Tuple2<Long, IntType> map(Tuple2<Long, IntType> value) {                 value.f1.value = 1.                 return value.             }         }).rebalance().keyBy(0).timeWindow(Time.of(100, MILLISECONDS)).reduce(new ReduceFunction<Tuple2<Long, IntType>>() {              @Override             public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {                 return new Tuple2<>(a.f0, new IntType(1)).             }         }).addSink(new ValidatingSink<>(updaterAndChecker, updaterAndChecker, timeCharacteristic)).setParallelism(1).         tryExecute(env, "Aggregating Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;6;;@Override public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {     return new Tuple2<>(a.f0, new IntType(1)). }
false;public;1;5;;@Override public Tuple2<Long, IntType> map(Tuple2<Long, IntType> value) {     value.f1.value = 1.     return value. }
false;public;0;44;;@Test public void testAggregatingSlidingProcessingTimeWindow() {     final int numElements = 3000.     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(timeCharacteristic).         env.getConfig().setAutoWatermarkInterval(10).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         SinkValidatorUpdaterAndChecker updaterAndChecker = new SinkValidatorUpdaterAndChecker(numElements, 3).         env.addSource(new FailingSource(new Generator(), numElements, timeCharacteristic)).map(new MapFunction<Tuple2<Long, IntType>, Tuple2<Long, IntType>>() {              @Override             public Tuple2<Long, IntType> map(Tuple2<Long, IntType> value) {                 value.f1.value = 1.                 return value.             }         }).rebalance().keyBy(0).timeWindow(Time.of(150, MILLISECONDS), Time.of(50, MILLISECONDS)).reduce(new ReduceFunction<Tuple2<Long, IntType>>() {              @Override             public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {                 return new Tuple2<>(a.f0, new IntType(1)).             }         }).addSink(new ValidatingSink<>(updaterAndChecker, updaterAndChecker, timeCharacteristic)).setParallelism(1).         tryExecute(env, "Aggregating Sliding Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;4;;@Override public void emitEvent(SourceFunction.SourceContext<Tuple2<Long, IntType>> ctx, int eventSequenceNo) {     ctx.collect(new Tuple2<>((long) eventSequenceNo, new IntType(eventSequenceNo))). }
false;public;2;4;;@Override public void updateCount(Tuple2<Long, IntType> value, Map<Long, Integer> windowCounts) {     windowCounts.merge(value.f0, value.f1.value, (a, b) -> a + b). }
false;public;1;21;;@Override public boolean checkResult(Map<Long, Integer> windowCounts) {     int aggCount = 0.     for (Integer i : windowCounts.values()) {         aggCount += i.     }     if (aggCount < elementCountExpected * countPerElementExpected || elementCountExpected != windowCounts.size()) {         return false.     }     for (int i : windowCounts.values()) {         if (countPerElementExpected != i) {             return false.         }     }     return true. }
false;public,static;0;7;;// ------------------------------------------------------------------------ // Parametrization for testing different time characteristics // ------------------------------------------------------------------------ @Parameterized.Parameters(name = "TimeCharacteristic = {0}") @SuppressWarnings("unchecked,rawtypes") public static Collection<TimeCharacteristic[]> timeCharacteristic() {     return Arrays.asList(new TimeCharacteristic[] { TimeCharacteristic.ProcessingTime }, new TimeCharacteristic[] { TimeCharacteristic.IngestionTime }). }
