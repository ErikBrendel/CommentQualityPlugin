commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;6;;@Override protected void preSubmit() throws Exception {     verticesPath = createTempFile("vertices.txt", ConnectedComponentsData.getEnumeratingVertices(NUM_VERTICES)).     edgesPath = createTempFile("edges.txt", ConnectedComponentsData.getRandomOddEvenEdges(NUM_EDGES, NUM_VERTICES, SEED)).     resultPath = getTempFilePath("results"). }
false;protected;0;6;;@Override protected void postSubmit() throws Exception {     for (BufferedReader reader : getResultReader(resultPath)) {         ConnectedComponentsData.checkOddEvenResult(reader).     } }
false;public;1;4;;@Override public Tuple2<Long, Long> map(Tuple1<Long> value) throws Exception {     return new Tuple2<>(value.f0, value.f0). }
false;public;2;4;;@Override public Tuple2<Long, Long> join(Tuple2<Long, Long> first, Tuple2<Long, Long> second) throws Exception {     return new Tuple2<>(second.f1, first.f1). }
false;protected;0;37;;// -------------------------------------------------------------------------------------------- // The test program // -------------------------------------------------------------------------------------------- @Override protected void testProgram() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple1<Long>> initialVertices = env.readCsvFile(verticesPath).fieldDelimiter(" ").types(Long.class).name("Vertices").     DataSet<Tuple2<Long, Long>> edges = env.readCsvFile(edgesPath).fieldDelimiter(" ").types(Long.class, Long.class).name("Edges").     DataSet<Tuple2<Long, Long>> verticesWithId = initialVertices.map(new MapFunction<Tuple1<Long>, Tuple2<Long, Long>>() {          @Override         public Tuple2<Long, Long> map(Tuple1<Long> value) throws Exception {             return new Tuple2<>(value.f0, value.f0).         }     }).name("Assign Vertex Ids").     DeltaIteration<Tuple2<Long, Long>, Tuple2<Long, Long>> iteration = verticesWithId.iterateDelta(verticesWithId, MAX_ITERATIONS, 0).     JoinOperator<Tuple2<Long, Long>, Tuple2<Long, Long>, Tuple2<Long, Long>> joinWithNeighbors = iteration.getWorkset().join(edges).where(0).equalTo(0).with(new JoinFunction<Tuple2<Long, Long>, Tuple2<Long, Long>, Tuple2<Long, Long>>() {          @Override         public Tuple2<Long, Long> join(Tuple2<Long, Long> first, Tuple2<Long, Long> second) throws Exception {             return new Tuple2<>(second.f1, first.f1).         }     }).name("Join Candidate Id With Neighbor").     CoGroupOperator<Tuple2<Long, Long>, Tuple2<Long, Long>, Tuple2<Long, Long>> minAndUpdate = joinWithNeighbors.coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(new MinIdAndUpdate()).name("min Id and Update").     iteration.closeWith(minAndUpdate, minAndUpdate).writeAsCsv(resultPath, "\n", " ").name("Result").     env.execute("Workset Connected Components"). }
false;public;3;22;;@Override public void coGroup(Iterable<Tuple2<Long, Long>> first, Iterable<Tuple2<Long, Long>> second, Collector<Tuple2<Long, Long>> out) throws Exception {     Iterator<Tuple2<Long, Long>> current = second.iterator().     if (!current.hasNext()) {         throw new Exception("Error: Id not encountered before.").     }     Tuple2<Long, Long> old = current.next().     long oldId = old.f1.     long minimumComponentID = Long.MAX_VALUE.     for (Tuple2<Long, Long> candidate : first) {         long candidateComponentID = candidate.f1.         if (candidateComponentID < minimumComponentID) {             minimumComponentID = candidateComponentID.         }     }     if (minimumComponentID < oldId) {         out.collect(new Tuple2<>(old.f0, minimumComponentID)).     } }
