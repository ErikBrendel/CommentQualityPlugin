commented;modifiers;parameterAmount;loc;comment;code
false;public;0;33;;@Test public void testConnectedComponentsWithParametrizableConvergence() throws Exception {     // name of the aggregator that checks for convergence     final String updatedElements = "updated.elements.aggr".     // the iteration stops if less than this number of elements change value     final long convergenceThreshold = 3.     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple2<Long, Long>> initialSolutionSet = env.fromCollection(verticesInput).     DataSet<Tuple2<Long, Long>> edges = env.fromCollection(edgesInput).     IterativeDataSet<Tuple2<Long, Long>> iteration = initialSolutionSet.iterate(10).     // register the convergence criterion     iteration.registerAggregationConvergenceCriterion(updatedElements, new LongSumAggregator(), new UpdatedElementsConvergenceCriterion(convergenceThreshold)).     DataSet<Tuple2<Long, Long>> verticesWithNewComponents = iteration.join(edges).where(0).equalTo(0).with(new NeighborWithComponentIDJoin()).groupBy(0).min(1).     DataSet<Tuple2<Long, Long>> updatedComponentId = verticesWithNewComponents.join(iteration).where(0).equalTo(0).flatMap(new MinimumIdFilter(updatedElements)).     List<Tuple2<Long, Long>> result = iteration.closeWith(updatedComponentId).collect().     Collections.sort(result, new TestBaseUtils.TupleComparator<Tuple2<Long, Long>>()).     assertEquals(expectedResult, result). }
false;public;0;34;;@Test public void testDeltaConnectedComponentsWithParametrizableConvergence() throws Exception {     // name of the aggregator that checks for convergence     final String updatedElements = "updated.elements.aggr".     // the iteration stops if less than this number of elements change value     final long convergenceThreshold = 3.     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple2<Long, Long>> initialSolutionSet = env.fromCollection(verticesInput).     DataSet<Tuple2<Long, Long>> edges = env.fromCollection(edgesInput).     DeltaIteration<Tuple2<Long, Long>, Tuple2<Long, Long>> iteration = initialSolutionSet.iterateDelta(initialSolutionSet, 10, 0).     // register the convergence criterion     iteration.registerAggregationConvergenceCriterion(updatedElements, new LongSumAggregator(), new UpdatedElementsConvergenceCriterion(convergenceThreshold)).     DataSet<Tuple2<Long, Long>> verticesWithNewComponents = iteration.getWorkset().join(edges).where(0).equalTo(0).with(new NeighborWithComponentIDJoin()).groupBy(0).min(1).     DataSet<Tuple2<Long, Long>> updatedComponentId = verticesWithNewComponents.join(iteration.getSolutionSet()).where(0).equalTo(0).flatMap(new MinimumIdFilter(updatedElements)).     List<Tuple2<Long, Long>> result = iteration.closeWith(updatedComponentId, updatedComponentId).collect().     Collections.sort(result, new TestBaseUtils.TupleComparator<Tuple2<Long, Long>>()).     assertEquals(expectedResult, result). }
false;public;0;56;;@Test public void testParameterizableAggregator() throws Exception {     final int maxIterations = 5.     final String aggregatorName = "elements.in.component.aggregator".     final long componentId = 1L.     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple2<Long, Long>> initialSolutionSet = env.fromCollection(verticesInput).     DataSet<Tuple2<Long, Long>> edges = env.fromCollection(edgesInput).     IterativeDataSet<Tuple2<Long, Long>> iteration = initialSolutionSet.iterate(maxIterations).     // register the aggregator     iteration.registerAggregator(aggregatorName, new LongSumAggregatorWithParameter(componentId)).     DataSet<Tuple2<Long, Long>> verticesWithNewComponents = iteration.join(edges).where(0).equalTo(0).with(new NeighborWithComponentIDJoin()).groupBy(0).min(1).     DataSet<Tuple2<Long, Long>> updatedComponentId = verticesWithNewComponents.join(iteration).where(0).equalTo(0).flatMap(new MinimumIdFilterCounting(aggregatorName)).     List<Tuple2<Long, Long>> result = iteration.closeWith(updatedComponentId).collect().     Collections.sort(result, new TestBaseUtils.TupleComparator<Tuple2<Long, Long>>()).     List<Tuple2<Long, Long>> expectedResult = Arrays.asList(new Tuple2<>(1L, 1L), new Tuple2<>(2L, 1L), new Tuple2<>(3L, 1L), new Tuple2<>(4L, 1L), new Tuple2<>(5L, 1L), new Tuple2<>(6L, 1L), new Tuple2<>(7L, 7L), new Tuple2<>(8L, 7L), new Tuple2<>(9L, 7L)).     // check program result     assertEquals(expectedResult, result).     // check aggregators     long[] aggrValues = MinimumIdFilterCounting.aggr_value.     // note that position 0 has the end result from superstep 1, retrieved at the start of iteration 2     // position one as superstep 2, retrieved at the start of iteration 3.     // the result from iteration 5 is not available, because no iteration 6 happens     assertEquals(3, aggrValues[0]).     assertEquals(4, aggrValues[1]).     assertEquals(5, aggrValues[2]).     assertEquals(6, aggrValues[3]). }
false;public;2;5;;@Override public Tuple2<Long, Long> join(Tuple2<Long, Long> vertexWithCompId, Tuple2<Long, Long> edge) {     vertexWithCompId.f0 = edge.f1.     return vertexWithCompId. }
false;public;1;4;;@Override public void open(Configuration conf) {     aggr = getIterationRuntimeContext().getIterationAggregator(aggName). }
false;public;2;13;;@Override public void flatMap(Tuple2<Tuple2<Long, Long>, Tuple2<Long, Long>> vertexWithNewAndOldId, Collector<Tuple2<Long, Long>> out) {     if (vertexWithNewAndOldId.f0.f1 < vertexWithNewAndOldId.f1.f1) {         out.collect(vertexWithNewAndOldId.f0).         aggr.aggregate(1L).     } else {         out.collect(vertexWithNewAndOldId.f1).     } }
false;public;1;11;;@Override public void open(Configuration conf) {     final int superstep = getIterationRuntimeContext().getSuperstepNumber().     aggr = getIterationRuntimeContext().getIterationAggregator(aggName).     if (superstep > 1 && getIterationRuntimeContext().getIndexOfThisSubtask() == 0) {         LongValue val = getIterationRuntimeContext().getPreviousIterationAggregate(aggName).         aggr_value[superstep - 2] = val.getValue().     } }
false;public;2;17;;@Override public void flatMap(Tuple2<Tuple2<Long, Long>, Tuple2<Long, Long>> vertexWithNewAndOldId, Collector<Tuple2<Long, Long>> out) {     if (vertexWithNewAndOldId.f0.f1 < vertexWithNewAndOldId.f1.f1) {         out.collect(vertexWithNewAndOldId.f0).         if (vertexWithNewAndOldId.f0.f1 == aggr.getComponentId()) {             aggr.aggregate(1L).         }     } else {         out.collect(vertexWithNewAndOldId.f1).         if (vertexWithNewAndOldId.f1.f1 == aggr.getComponentId()) {             aggr.aggregate(1L).         }     } }
false;public;2;4;;@Override public boolean isConverged(int iteration, LongValue value) {     return value.getValue() < this.threshold. }
false;public;0;3;;public long getComponentId() {     return this.componentId. }
