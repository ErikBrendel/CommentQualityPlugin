commented;modifiers;parameterAmount;loc;comment;code
true;public;0;66;/**  * Runs the following program.  * <pre>  *     [ (source)->(filter) ] -> [ (co-map) ] -> [ (map) ] -> [ (groupBy/reduce)->(sink) ]  * </pre>  */ ;/**  * Runs the following program.  * <pre>  *     [ (source)->(filter) ] -> [ (co-map) ] -> [ (map) ] -> [ (groupBy/reduce)->(sink) ]  * </pre>  */ @Test public void testProgram() {     try {         final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         assertEquals("test setup broken", PARALLELISM, env.getParallelism()).         env.enableCheckpointing(500).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0L)).         final int numElements = 10000.         final int numTaskTotal = PARALLELISM * 5.         DataStream<Long> stream = env.addSource(new GeneratingSourceFunction(numElements, numTaskTotal)).         stream.filter(new LongRichFilterFunction()).connect(stream).flatMap(new LeftIdentityCoRichFlatMapFunction()).map(new IdentityMapFunction()).startNewChain().keyBy(0).reduce(new OnceFailingReducer(numElements)).addSink(new DiscardingSink<Tuple1<Long>>()).         env.execute().         final long failureCheckpointID = OnceFailingReducer.failureCheckpointID.         assertNotEquals(0L, failureCheckpointID).         List<List<Long>[]> allLists = Arrays.asList(GeneratingSourceFunction.COMPLETED_CHECKPOINTS, LongRichFilterFunction.COMPLETED_CHECKPOINTS, LeftIdentityCoRichFlatMapFunction.COMPLETED_CHECKPOINTS, IdentityMapFunction.COMPLETED_CHECKPOINTS, OnceFailingReducer.COMPLETED_CHECKPOINTS).         for (List<Long>[] parallelNotifications : allLists) {             for (List<Long> notifications : parallelNotifications) {                 assertTrue("No checkpoint notification was received.", notifications.size() > 0).                 assertFalse("Failure checkpoint was marked as completed.", notifications.contains(failureCheckpointID)).                 assertFalse("No checkpoint received after failure.", notifications.get(notifications.size() - 1) == failureCheckpointID).                 assertTrue("Checkpoint notification was received multiple times", notifications.size() == new HashSet<Long>(notifications).size()).             }         }     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;static;1;8;;static List<Long>[] createCheckpointLists(int parallelism) {     @SuppressWarnings({ "unchecked", "rawtypes" })     List<Long>[] lists = new List[parallelism].     for (int i = 0. i < parallelism. i++) {         lists[i] = new ArrayList<>().     }     return lists. }
false;public;1;9;;@Override public void open(Configuration parameters) throws IOException {     step = getRuntimeContext().getNumberOfParallelSubtasks().     // if index has been restored, it is not 0 any more     if (index == 0) {         index = getRuntimeContext().getIndexOfThisSubtask().     } }
false;public;1;19;;@Override public void run(SourceContext<Long> ctx) throws Exception {     final Object lockingObject = ctx.getCheckpointLock().     while (isRunning && index < numElements) {         long result = index % 10.         synchronized (lockingObject) {             index += step.             ctx.collect(result).         }     }     // wait until all tasks had a chance to see a notification     while (isRunning && numPostFailureNotifications.get() < notificationsToWaitFor) {         Thread.sleep(50).     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;2;4;;@Override public List<Integer> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.index). }
false;public;1;7;;@Override public void restoreState(List<Integer> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.index = state.get(0). }
false;public;1;13;;@Override public void notifyCheckpointComplete(long checkpointId) {     // record the ID of the completed checkpoint     int partition = getRuntimeContext().getIndexOfThisSubtask().     COMPLETED_CHECKPOINTS[partition].add(checkpointId).     // tell the source function     if (OnceFailingReducer.hasFailed && !notificationAlready) {         notificationAlready = true.         GeneratingSourceFunction.numPostFailureNotifications.incrementAndGet().     } }
false;public;1;4;;@Override public Tuple1<Long> map(Long value) throws Exception {     return Tuple1.of(value). }
false;public;1;13;;@Override public void notifyCheckpointComplete(long checkpointId) {     // record the ID of the completed checkpoint     int partition = getRuntimeContext().getIndexOfThisSubtask().     COMPLETED_CHECKPOINTS[partition].add(checkpointId).     // tell the source function     if (OnceFailingReducer.hasFailed && !notificationAlready) {         notificationAlready = true.         GeneratingSourceFunction.numPostFailureNotifications.incrementAndGet().     } }
false;public;1;4;;@Override public boolean filter(Long value) {     return value < 100. }
false;public;1;13;;@Override public void notifyCheckpointComplete(long checkpointId) {     // record the ID of the completed checkpoint     int partition = getRuntimeContext().getIndexOfThisSubtask().     COMPLETED_CHECKPOINTS[partition].add(checkpointId).     // tell the source function     if (OnceFailingReducer.hasFailed && !notificationAlready) {         notificationAlready = true.         GeneratingSourceFunction.numPostFailureNotifications.incrementAndGet().     } }
false;public;2;4;;@Override public void flatMap1(Long value, Collector<Long> out) {     out.collect(value). }
false;public;2;4;;@Override public void flatMap2(Long value, Collector<Long> out) { // we ignore the values from the second input }
false;public;1;13;;@Override public void notifyCheckpointComplete(long checkpointId) {     // record the ID of the completed checkpoint     int partition = getRuntimeContext().getIndexOfThisSubtask().     COMPLETED_CHECKPOINTS[partition].add(checkpointId).     // tell the source function     if (OnceFailingReducer.hasFailed && !notificationAlready) {         notificationAlready = true.         GeneratingSourceFunction.numPostFailureNotifications.incrementAndGet().     } }
false;public;2;10;;@Override public Tuple1<Long> reduce(Tuple1<Long> value1, Tuple1<Long> value2) {     count++.     if (count >= failurePos && getRuntimeContext().getIndexOfThisSubtask() == 0) {         LOG.info(">>>>>>>>>>>>>>>>> Reached failing position <<<<<<<<<<<<<<<<<<<<<").     }     value1.f0 += value2.f0.     return value1. }
false;public;2;10;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     if (!hasFailed && count >= failurePos && getRuntimeContext().getIndexOfThisSubtask() == 0) {         LOG.info(">>>>>>>>>>>>>>>>> Throwing Exception <<<<<<<<<<<<<<<<<<<<<").         hasFailed = true.         failureCheckpointID = checkpointId.         throw new Exception("Test Failure").     }     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;1;13;;@Override public void notifyCheckpointComplete(long checkpointId) {     // record the ID of the completed checkpoint     int partition = getRuntimeContext().getIndexOfThisSubtask().     COMPLETED_CHECKPOINTS[partition].add(checkpointId).     // tell the source function     if (OnceFailingReducer.hasFailed && !notificationAlready) {         notificationAlready = true.         GeneratingSourceFunction.numPostFailureNotifications.incrementAndGet().     } }
