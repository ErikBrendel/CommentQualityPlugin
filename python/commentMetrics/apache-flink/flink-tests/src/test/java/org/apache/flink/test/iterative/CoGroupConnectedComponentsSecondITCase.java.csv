commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;35;;@Override protected void testProgram() throws Exception {     // set up execution environment     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     // read vertex and edge data     DataSet<Long> vertices = env.fromElements(ConnectedComponentsData.getEnumeratingVertices(NUM_VERTICES).split("\n")).map(new VertexParser()).     DataSet<Tuple2<Long, Long>> edges = env.fromElements(ConnectedComponentsData.getRandomOddEvenEdges(NUM_EDGES, NUM_VERTICES, SEED).split("\n")).flatMap(new EdgeParser()).     // assign the initial components (equal to the vertex id)     DataSet<Tuple2<Long, Long>> verticesWithInitialId = vertices.map(new DuplicateValue<Long>()).     // open a delta iteration     DeltaIteration<Tuple2<Long, Long>, Tuple2<Long, Long>> iteration = verticesWithInitialId.iterateDelta(verticesWithInitialId, 100, 0).     // apply the step logic: join with the edges, select the minimum neighbor, update if the component of the candidate is smaller     DataSet<Tuple2<Long, Long>> changes = iteration.getWorkset().join(edges).where(0).equalTo(0).with(new NeighborWithComponentIDJoin()).coGroup(iteration.getSolutionSet()).where(0).equalTo(0).with(new MinIdAndUpdate()).     // close the delta iteration (delta and new workset are identical)     DataSet<Tuple2<Long, Long>> result = iteration.closeWith(changes, changes).     // emit result     List<Tuple2<Long, Long>> resutTuples = new ArrayList<>().     result.output(new LocalCollectionOutputFormat<>(resutTuples)).     env.execute(). }
false;public;1;4;;@Override public Long map(String value) throws Exception {     return Long.parseLong(value). }
false;public;2;9;;@Override public void flatMap(String value, Collector<Tuple2<Long, Long>> out) throws Exception {     String[] parts = value.split(" ").     long v1 = Long.parseLong(parts[0]).     long v2 = Long.parseLong(parts[1]).     out.collect(new Tuple2<Long, Long>(v1, v2)).     out.collect(new Tuple2<Long, Long>(v2, v1)). }
false;public;3;23;;@Override public void coGroup(Iterable<Tuple2<Long, Long>> candidates, Iterable<Tuple2<Long, Long>> current, Collector<Tuple2<Long, Long>> out) {     Iterator<Tuple2<Long, Long>> iterator = current.iterator().     if (!iterator.hasNext()) {         throw new RuntimeException("Error: Id not encountered before.").     }     Tuple2<Long, Long> old = iterator.next().     long minimumComponentID = Long.MAX_VALUE.     for (Tuple2<Long, Long> candidate : candidates) {         long candidateComponentID = candidate.f1.         if (candidateComponentID < minimumComponentID) {             minimumComponentID = candidateComponentID.         }     }     if (minimumComponentID < old.f1) {         old.f1 = minimumComponentID.         out.collect(old).     } }
