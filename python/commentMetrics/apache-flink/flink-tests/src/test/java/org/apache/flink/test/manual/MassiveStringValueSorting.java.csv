commented;modifiers;parameterAmount;loc;comment;code
false;public;0;98;;public void testStringValueSorting() {     File input = null.     File sorted = null.     try {         // the source file         input = generateFileWithStrings(300000, "http://some-uri.com/that/is/a/common/prefix/to/all").         // the sorted file         sorted = File.createTempFile("sorted_strings", "txt").         String[] command = { "/bin/bash", "-c", "export LC_ALL=\"C\" && cat \"" + input.getAbsolutePath() + "\" | sort > \"" + sorted.getAbsolutePath() + "\"" }.         Process p = null.         try {             p = Runtime.getRuntime().exec(command).             int retCode = p.waitFor().             if (retCode != 0) {                 throw new Exception("Command failed with return code " + retCode).             }             p = null.         } finally {             if (p != null) {                 p.destroy().             }         }         // sort the data         UnilateralSortMerger<StringValue> sorter = null.         BufferedReader reader = null.         BufferedReader verifyReader = null.         MemoryManager mm = null.         IOManager ioMan = null.         try {             mm = new MemoryManager(1024 * 1024, 1).             ioMan = new IOManagerAsync().             TypeSerializer<StringValue> serializer = new CopyableValueSerializer<StringValue>(StringValue.class).             TypeComparator<StringValue> comparator = new CopyableValueComparator<StringValue>(true, StringValue.class).             reader = new BufferedReader(new FileReader(input)).             MutableObjectIterator<StringValue> inputIterator = new StringValueReaderMutableObjectIterator(reader).             sorter = new UnilateralSortMerger<StringValue>(mm, ioMan, inputIterator, new DummyInvokable(), new RuntimeSerializerFactory<StringValue>(serializer, StringValue.class), comparator, 1.0, 4, 0.8f, true, /* use large record handler */             true).             MutableObjectIterator<StringValue> sortedData = sorter.getIterator().             reader.close().             // verify             verifyReader = new BufferedReader(new FileReader(sorted)).             String nextVerify.             StringValue nextFromFlinkSort = new StringValue().             while ((nextVerify = verifyReader.readLine()) != null) {                 nextFromFlinkSort = sortedData.next(nextFromFlinkSort).                 Assert.assertNotNull(nextFromFlinkSort).                 Assert.assertEquals(nextVerify, nextFromFlinkSort.getValue()).             }         } finally {             if (reader != null) {                 reader.close().             }             if (verifyReader != null) {                 verifyReader.close().             }             if (sorter != null) {                 sorter.close().             }             if (mm != null) {                 mm.shutdown().             }             if (ioMan != null) {                 ioMan.shutdown().             }         }     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail(e.getMessage()).     } finally {         if (input != null) {             // noinspection ResultOfMethodCallIgnored             input.delete().         }         if (sorted != null) {             // noinspection ResultOfMethodCallIgnored             sorted.delete().         }     } }
false;public;0;130;;@SuppressWarnings("unchecked") public void testStringValueTuplesSorting() {     final int numStrings = 300000.     File input = null.     File sorted = null.     try {         // the source file         input = generateFileWithStringTuples(numStrings, "http://some-uri.com/that/is/a/common/prefix/to/all").         // the sorted file         sorted = File.createTempFile("sorted_strings", "txt").         String[] command = { "/bin/bash", "-c", "export LC_ALL=\"C\" && cat \"" + input.getAbsolutePath() + "\" | sort > \"" + sorted.getAbsolutePath() + "\"" }.         Process p = null.         try {             p = Runtime.getRuntime().exec(command).             int retCode = p.waitFor().             if (retCode != 0) {                 throw new Exception("Command failed with return code " + retCode).             }             p = null.         } finally {             if (p != null) {                 p.destroy().             }         }         // sort the data         UnilateralSortMerger<Tuple2<StringValue, StringValue[]>> sorter = null.         BufferedReader reader = null.         BufferedReader verifyReader = null.         MemoryManager mm = null.         IOManager ioMan = null.         try {             mm = new MemoryManager(1024 * 1024, 1).             ioMan = new IOManagerAsync().             TupleTypeInfo<Tuple2<StringValue, StringValue[]>> typeInfo = (TupleTypeInfo<Tuple2<StringValue, StringValue[]>>) new TypeHint<Tuple2<StringValue, StringValue[]>>() {             }.getTypeInfo().             TypeSerializer<Tuple2<StringValue, StringValue[]>> serializer = typeInfo.createSerializer(new ExecutionConfig()).             TypeComparator<Tuple2<StringValue, StringValue[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig()).             reader = new BufferedReader(new FileReader(input)).             MutableObjectIterator<Tuple2<StringValue, StringValue[]>> inputIterator = new StringValueTupleReaderMutableObjectIterator(reader).             sorter = new UnilateralSortMerger<Tuple2<StringValue, StringValue[]>>(mm, ioMan, inputIterator, new DummyInvokable(), new RuntimeSerializerFactory<Tuple2<StringValue, StringValue[]>>(serializer, (Class<Tuple2<StringValue, StringValue[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f, true, /* use large record handler */             false).             // use this part to verify that all if good when sorting in memory             // List<MemorySegment> memory = mm.allocatePages(new DummyInvokable(), mm.computeNumberOfPages(1024*1024*1024)).             // NormalizedKeySorter<Tuple2<String, String[]>> nks = new NormalizedKeySorter<Tuple2<String,String[]>>(serializer, comparator, memory).             //              // {             // Tuple2<String, String[]> wi = new Tuple2<String, String[]>("", new String[0]).             // while ((wi = inputIterator.next(wi)) != null) {             // Assert.assertTrue(nks.write(wi)).             // }             //              // new QuickSort().sort(nks).             // }             //              // MutableObjectIterator<Tuple2<String, String[]>> sortedData = nks.getIterator().             MutableObjectIterator<Tuple2<StringValue, StringValue[]>> sortedData = sorter.getIterator().             reader.close().             // verify             verifyReader = new BufferedReader(new FileReader(sorted)).             MutableObjectIterator<Tuple2<StringValue, StringValue[]>> verifyIterator = new StringValueTupleReaderMutableObjectIterator(verifyReader).             Tuple2<StringValue, StringValue[]> nextVerify = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]).             Tuple2<StringValue, StringValue[]> nextFromFlinkSort = new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0]).             int num = 0.             while ((nextVerify = verifyIterator.next(nextVerify)) != null) {                 num++.                 nextFromFlinkSort = sortedData.next(nextFromFlinkSort).                 Assert.assertNotNull(nextFromFlinkSort).                 Assert.assertEquals(nextVerify.f0, nextFromFlinkSort.f0).                 Assert.assertArrayEquals(nextVerify.f1, nextFromFlinkSort.f1).             }             Assert.assertNull(sortedData.next(nextFromFlinkSort)).             Assert.assertEquals(numStrings, num).         } finally {             if (reader != null) {                 reader.close().             }             if (verifyReader != null) {                 verifyReader.close().             }             if (sorter != null) {                 sorter.close().             }             if (mm != null) {                 mm.shutdown().             }             if (ioMan != null) {                 ioMan.shutdown().             }         }     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail(e.getMessage()).     } finally {         if (input != null) {             // noinspection ResultOfMethodCallIgnored             input.delete().         }         if (sorted != null) {             // noinspection ResultOfMethodCallIgnored             sorted.delete().         }     } }
false;public;1;11;;@Override public StringValue next(StringValue reuse) throws IOException {     String line = reader.readLine().     if (line == null) {         return null.     }     reuse.setValue(line).     return reuse. }
false;public;0;4;;@Override public StringValue next() throws IOException {     return next(new StringValue()). }
false;public;1;17;;@Override public Tuple2<StringValue, StringValue[]> next(Tuple2<StringValue, StringValue[]> reuse) throws IOException {     String line = reader.readLine().     if (line == null) {         return null.     }     String[] parts = line.split(" ").     reuse.f0.setValue(parts[0]).     reuse.f1 = new StringValue[parts.length].     for (int i = 0. i < parts.length. i++) {         reuse.f1[i] = new StringValue(parts[i]).     }     return reuse. }
false;public;0;4;;@Override public Tuple2<StringValue, StringValue[]> next() throws IOException {     return next(new Tuple2<StringValue, StringValue[]>(new StringValue(), new StringValue[0])). }
false;private;2;34;;// -------------------------------------------------------------------------------------------- private File generateFileWithStrings(int numStrings, String prefix) throws IOException {     final Random rnd = new Random(SEED).     final StringBuilder bld = new StringBuilder().     final int resetValue = prefix.length().     bld.append(prefix).     File f = File.createTempFile("strings", "txt").     BufferedWriter wrt = null.     try {         wrt = new BufferedWriter(new FileWriter(f)).         for (int i = 0. i < numStrings. i++) {             bld.setLength(resetValue).             int len = rnd.nextInt(20) + 300.             for (int k = 0. k < len. k++) {                 char c = (char) (rnd.nextInt(80) + 40).                 bld.append(c).             }             String str = bld.toString().             wrt.write(str).             wrt.newLine().         }     } finally {         if (wrt != null) {             wrt.close().         }     }     return f. }
false;private;2;41;;private File generateFileWithStringTuples(int numStrings, String prefix) throws IOException {     final Random rnd = new Random(SEED).     final StringBuilder bld = new StringBuilder().     File f = File.createTempFile("strings", "txt").     BufferedWriter wrt = null.     try {         wrt = new BufferedWriter(new FileWriter(f)).         for (int i = 0. i < numStrings. i++) {             bld.setLength(0).             int numComps = rnd.nextInt(5) + 1.             for (int z = 0. z < numComps. z++) {                 if (z > 0) {                     bld.append(' ').                 }                 bld.append(prefix).                 int len = rnd.nextInt(20) + 10.                 for (int k = 0. k < len. k++) {                     char c = (char) (rnd.nextInt(80) + 40).                     bld.append(c).                 }             }             String str = bld.toString().             wrt.write(str).             wrt.newLine().         }     } finally {         if (wrt != null) {             wrt.close().         }     }     return f. }
false;public,static;1;4;;// -------------------------------------------------------------------------------------------- public static void main(String[] args) {     new MassiveStringValueSorting().testStringValueSorting().     new MassiveStringValueSorting().testStringValueTuplesSorting(). }
