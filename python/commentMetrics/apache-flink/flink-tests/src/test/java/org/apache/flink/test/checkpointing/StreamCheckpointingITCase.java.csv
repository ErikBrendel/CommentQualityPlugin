commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void invoke(PrefixCount value) throws Exception { // Do nothing here }
true;public;1;25;/**  * Runs the following program.  * <pre>  *     [ (source)->(filter) ]-s->[ (map) ] -> [ (map) ] -> [ (groupBy/count)->(sink) ]  * </pre>  */ ;/**  * Runs the following program.  * <pre>  *     [ (source)->(filter) ]-s->[ (map) ] -> [ (map) ] -> [ (groupBy/count)->(sink) ]  * </pre>  */ @Override public void testProgram(StreamExecutionEnvironment env) {     DataStream<String> stream = env.addSource(new StringGeneratingSourceFunction(NUM_STRINGS)).     stream.filter(new StringRichFilterFunction()).shuffle().map(new StringPrefixCountRichMapFunction()).startNewChain().map(new StatefulCounterFunction()).keyBy("prefix").map(new OnceFailingPrefixCounter(NUM_STRINGS)).addSink(new SinkFunction<PrefixCount>() {          @Override         public void invoke(PrefixCount value) throws Exception {         // Do nothing here         }     }). }
false;public;0;31;;@Override public void postSubmit() {     long filterSum = 0.     for (long l : StringRichFilterFunction.counts) {         filterSum += l.     }     long mapSum = 0.     for (long l : StringPrefixCountRichMapFunction.counts) {         mapSum += l.     }     long countSum = 0.     for (long l : StatefulCounterFunction.counts) {         countSum += l.     }     long reduceInputCount = 0.     for (long l : OnceFailingPrefixCounter.counts) {         reduceInputCount += l.     }     assertEquals(NUM_STRINGS, filterSum).     assertEquals(NUM_STRINGS, mapSum).     assertEquals(NUM_STRINGS, countSum).     assertEquals(NUM_STRINGS, reduceInputCount).     // verify that we counted exactly right     for (Long count : OnceFailingPrefixCounter.prefixCounts.values()) {         assertEquals(new Long(NUM_STRINGS / 40), count).     } }
false;public;0;4;;@Override public void close() throws IOException {     counts[getRuntimeContext().getIndexOfThisSubtask()] = index. }
false;public;1;7;;@Override public void open(Configuration parameters) throws IOException {     step = getRuntimeContext().getNumberOfParallelSubtasks().     if (index == 0) {         index = getRuntimeContext().getIndexOfThisSubtask().     } }
false;public;1;18;;@Override public void run(SourceContext<String> ctx) throws Exception {     final Object lockingObject = ctx.getCheckpointLock().     while (isRunning && index < numElements) {         char first = (char) ((index % 40) + 40).         stringBuilder.setLength(0).         stringBuilder.append(first).         String result = randomString(stringBuilder, rnd).         synchronized (lockingObject) {             index += step.             ctx.collect(result).         }     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;private,static;2;10;;private static String randomString(StringBuilder bld, Random rnd) {     final int len = rnd.nextInt(10) + 5.     for (int i = 0. i < len. i++) {         char next = (char) (rnd.nextInt(20000) + 33).         bld.append(next).     }     return bld.toString(). }
false;public;2;4;;@Override public List<Integer> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.index). }
false;public;1;7;;@Override public void restoreState(List<Integer> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.index = state.get(0). }
false;public;1;5;;@Override public PrefixCount map(PrefixCount value) throws Exception {     count++.     return value. }
false;public;0;4;;@Override public void close() throws IOException {     counts[getRuntimeContext().getIndexOfThisSubtask()] = count. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;1;10;;@Override public void open(Configuration parameters) throws IOException {     long failurePosMin = (long) (0.4 * numElements / getRuntimeContext().getNumberOfParallelSubtasks()).     long failurePosMax = (long) (0.7 * numElements / getRuntimeContext().getNumberOfParallelSubtasks()).     failurePos = (new Random().nextLong() % (failurePosMax - failurePosMin)) + failurePosMin.     count = 0.     pCount = getRuntimeContext().getState(new ValueStateDescriptor<>("pCount", Long.class, 0L)). }
false;public;0;4;;@Override public void close() throws IOException {     counts[getRuntimeContext().getIndexOfThisSubtask()] = inputCount. }
false;public;1;15;;@Override public PrefixCount map(PrefixCount value) throws Exception {     count++.     if (!hasFailed && count >= failurePos) {         hasFailed = true.         throw new Exception("Test Failure").     }     inputCount++.     long currentPrefixCount = pCount.value() + value.count.     pCount.update(currentPrefixCount).     prefixCounts.put(value.prefix, currentPrefixCount).     value.count = currentPrefixCount.     return value. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.inputCount). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.inputCount = state.get(0). }
false;public;1;5;;@Override public boolean filter(String value) {     count++.     return value.length() < 100. }
false;public;0;4;;@Override public void close() {     counts[getRuntimeContext().getIndexOfThisSubtask()] = count. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;1;5;;@Override public PrefixCount map(String value) throws IOException {     count++.     return new PrefixCount(value.substring(0, 1), value, 1L). }
false;public;0;4;;@Override public void close() throws IOException {     counts[getRuntimeContext().getIndexOfThisSubtask()] = count. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
