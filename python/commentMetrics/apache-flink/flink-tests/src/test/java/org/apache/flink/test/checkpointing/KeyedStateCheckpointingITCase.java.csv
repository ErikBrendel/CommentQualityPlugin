commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;5;;private static Configuration getConfiguration() {     Configuration config = new Configuration().     config.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, "12m").     return config. }
false;public;0;5;;@Test public void testWithMemoryBackendSync() throws Exception {     MemoryStateBackend syncMemBackend = new MemoryStateBackend(MAX_MEM_STATE_SIZE, false).     testProgramWithBackend(syncMemBackend). }
false;public;0;5;;@Test public void testWithMemoryBackendAsync() throws Exception {     MemoryStateBackend asyncMemBackend = new MemoryStateBackend(MAX_MEM_STATE_SIZE, true).     testProgramWithBackend(asyncMemBackend). }
false;public;0;5;;@Test public void testWithFsBackendSync() throws Exception {     FsStateBackend syncFsBackend = new FsStateBackend(tmpFolder.newFolder().toURI().toString(), false).     testProgramWithBackend(syncFsBackend). }
false;public;0;5;;@Test public void testWithFsBackendAsync() throws Exception {     FsStateBackend asyncFsBackend = new FsStateBackend(tmpFolder.newFolder().toURI().toString(), true).     testProgramWithBackend(asyncFsBackend). }
false;public;0;7;;@Test public void testWithRocksDbBackendFull() throws Exception {     RocksDBStateBackend fullRocksDbBackend = new RocksDBStateBackend(new MemoryStateBackend(MAX_MEM_STATE_SIZE), false).     fullRocksDbBackend.setDbStoragePath(tmpFolder.newFolder().getAbsolutePath()).     testProgramWithBackend(fullRocksDbBackend). }
false;public;0;7;;@Test public void testWithRocksDbBackendIncremental() throws Exception {     RocksDBStateBackend incRocksDbBackend = new RocksDBStateBackend(new MemoryStateBackend(MAX_MEM_STATE_SIZE), true).     incRocksDbBackend.setDbStoragePath(tmpFolder.newFolder().getAbsolutePath()).     testProgramWithBackend(incRocksDbBackend). }
false;protected;1;41;;// ------------------------------------------------------------------------ protected void testProgramWithBackend(AbstractStateBackend stateBackend) throws Exception {     assertEquals("Broken test setup", 0, (NUM_STRINGS / 2) % NUM_KEYS).     final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(PARALLELISM).     env.enableCheckpointing(500).     env.getConfig().disableSysoutLogging().     env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 0L)).     env.setStateBackend(stateBackend).     // compute when (randomly) the failure should happen     final int failurePosMin = (int) (0.6 * NUM_STRINGS / PARALLELISM).     final int failurePosMax = (int) (0.8 * NUM_STRINGS / PARALLELISM).     final int failurePos = (new Random().nextInt(failurePosMax - failurePosMin) + failurePosMin).     final DataStream<Integer> stream1 = env.addSource(new IntGeneratingSourceFunction(NUM_STRINGS / 2, NUM_STRINGS / 4)).     final DataStream<Integer> stream2 = env.addSource(new IntGeneratingSourceFunction(NUM_STRINGS / 2, NUM_STRINGS / 4)).     stream1.union(stream2).keyBy(new IdentityKeySelector<Integer>()).map(new OnceFailingPartitionedSum(failurePos)).keyBy(0).addSink(new CounterSink()).     env.execute().     // verify that we counted exactly right     assertEquals(NUM_KEYS, CounterSink.ALL_COUNTS.size()).     assertEquals(NUM_KEYS, OnceFailingPartitionedSum.ALL_SUMS.size()).     for (Entry<Integer, Long> sum : OnceFailingPartitionedSum.ALL_SUMS.entrySet()) {         assertEquals((long) sum.getKey() * NUM_STRINGS / NUM_KEYS, sum.getValue().longValue()).     }     for (long count : CounterSink.ALL_COUNTS.values()) {         assertEquals(NUM_STRINGS / NUM_KEYS, count).     } }
false;public;1;34;;@Override public void run(SourceContext<Integer> ctx) throws Exception {     final Object lockingObject = ctx.getCheckpointLock().     final int step = getRuntimeContext().getNumberOfParallelSubtasks().     int nextElement = lastEmitted >= 0 ? lastEmitted + step : getRuntimeContext().getIndexOfThisSubtask().     while (isRunning && nextElement < numElements) {         // throttle / block if we are still waiting for the checkpoint         if (!checkpointHappened) {             if (nextElement < checkpointLatestAt) {                 // only throttle                 Thread.sleep(1).             } else {                 // hard block                 synchronized (this) {                     while (!checkpointHappened) {                         this.wait().                     }                 }             }         }         // noinspection SynchronizationOnLocalVariableOrMethodParameter         synchronized (lockingObject) {             ctx.collect(nextElement % NUM_KEYS).             lastEmitted = nextElement.         }         nextElement += step.     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;2;4;;@Override public List<Integer> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(lastEmitted). }
false;public;1;6;;@Override public void restoreState(List<Integer> state) throws Exception {     assertEquals("Test failed due to unexpected recovered state size", 1, state.size()).     lastEmitted = state.get(0).     checkpointHappened = true. }
false;public;1;7;;@Override public void notifyCheckpointComplete(long checkpointId) throws Exception {     synchronized (this) {         checkpointHappened = true.         this.notifyAll().     } }
false;public;1;4;;@Override public void open(Configuration parameters) throws IOException {     sum = getRuntimeContext().getState(new ValueStateDescriptor<>("my_state", Long.class)). }
false;public;1;14;;@Override public Tuple2<Integer, Long> map(Integer value) throws Exception {     if (shouldFail && count++ >= failurePos) {         shouldFail = false.         throw new Exception("Test Failure").     }     Long oldSum = sum.value().     long currentSum = (oldSum == null ? 0L : oldSum) + value.     sum.update(currentSum).     ALL_SUMS.put(value, currentSum).     return new Tuple2<>(value, currentSum). }
false;public;2;4;;@Override public List<Integer> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(count). }
false;public;1;6;;@Override public void restoreState(List<Integer> state) throws Exception {     assertEquals("Test failed due to unexpected recovered state size", 1, state.size()).     count = state.get(0).     shouldFail = false. }
false;public;0;6;;@Override public void close() throws Exception {     if (shouldFail) {         fail("Test ineffective: Function cleanly finished without ever failing.").     } }
false;public;1;5;;@Override public void open(Configuration parameters) throws IOException {     aCounts = getRuntimeContext().getState(new ValueStateDescriptor<>("a", NonSerializableLong.class)).     bCounts = getRuntimeContext().getState(new ValueStateDescriptor<>("b", Long.class)). }
false;public;1;16;;@Override public void invoke(Tuple2<Integer, Long> value) throws Exception {     final NonSerializableLong acRaw = aCounts.value().     final Long bcRaw = bCounts.value().     final long ac = acRaw == null ? 0L : acRaw.value.     final long bc = bcRaw == null ? 0L : bcRaw.     assertEquals(ac, bc).     long currentCount = ac + 1.     aCounts.update(NonSerializableLong.of(currentCount)).     bCounts.update(currentCount).     ALL_COUNTS.put(value.f0, currentCount). }
false;public;1;4;;@Override public T getKey(T value) throws Exception {     return value. }
false;public,static;1;3;;public static NonSerializableLong of(long value) {     return new NonSerializableLong(value). }
false;public;1;5;;@Override public boolean equals(Object obj) {     return this == obj || obj != null && obj.getClass() == getClass() && ((NonSerializableLong) obj).value == this.value. }
false;public;0;4;;@Override public int hashCode() {     return (int) (value ^ (value >>> 32)). }
