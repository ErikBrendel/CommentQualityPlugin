commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setup() throws Exception {     zkServer = new TestingServer(true). }
false;public,static;0;7;;@AfterClass public static void tearDown() throws Exception {     if (zkServer != null) {         zkServer.close().         zkServer = null.     } }
true;public;0;64;/**  * Tests that a job can be executed after a new leader has been elected. For all except for the  * last leader, the job is blocking. The JobManager will be terminated while executing the  * blocking job. Once only one JobManager is left, it is checked that a non-blocking can be  * successfully executed.  */ ;/**  * Tests that a job can be executed after a new leader has been elected. For all except for the  * last leader, the job is blocking. The JobManager will be terminated while executing the  * blocking job. Once only one JobManager is left, it is checked that a non-blocking can be  * successfully executed.  */ @Test public void testJobExecutionOnClusterWithLeaderChange() throws Exception {     final int numDispatchers = 3.     final int numTMs = 2.     final int numSlotsPerTM = 2.     final Configuration configuration = ZooKeeperTestUtils.createZooKeeperHAConfig(zkServer.getConnectString(), tempFolder.newFolder().getAbsolutePath()).     // speed up refused registration retries     configuration.setLong(ClusterOptions.REFUSED_REGISTRATION_DELAY, 50L).     final TestingMiniClusterConfiguration miniClusterConfiguration = new TestingMiniClusterConfiguration.Builder().setConfiguration(configuration).setNumberDispatcherResourceManagerComponents(numDispatchers).setNumTaskManagers(numTMs).setNumSlotsPerTaskManager(numSlotsPerTM).build().     LeaderRetrievalService dispatcherLeaderRetriever = null.     try (TestingMiniCluster miniCluster = new TestingMiniCluster(miniClusterConfiguration)) {         Deadline timeout = Deadline.fromNow(TEST_TIMEOUT).         miniCluster.start().         final int parallelism = numTMs * numSlotsPerTM.         JobGraph jobGraph = createJobGraph(parallelism).         miniCluster.submitJob(jobGraph).get().         Collection<DispatcherResourceManagerComponent<?>> dispatcherResourceManagerComponents = miniCluster.getDispatcherResourceManagerComponents().         final NewLeaderRetriever newLeaderRetriever = new NewLeaderRetriever().         final HighAvailabilityServices highAvailabilityServices = miniCluster.getHighAvailabilityServices().         dispatcherLeaderRetriever = highAvailabilityServices.getDispatcherLeaderRetriever().         dispatcherLeaderRetriever.start(newLeaderRetriever).         for (int i = 0. i < numDispatchers - 1. i++) {             final DispatcherResourceManagerComponent<?> leadingDispatcherResourceManagerComponent = getLeadingDispatcherResourceManagerComponent(dispatcherResourceManagerComponents, newLeaderRetriever).             final Dispatcher dispatcher = leadingDispatcherResourceManagerComponent.getDispatcher().             CommonTestUtils.waitUntilCondition(() -> dispatcher.requestJobStatus(jobGraph.getJobID(), RPC_TIMEOUT).get() == JobStatus.RUNNING, timeout, 50L).             leadingDispatcherResourceManagerComponent.closeAsync().         }         final DispatcherResourceManagerComponent<?> leadingDispatcherResourceManagerComponent = getLeadingDispatcherResourceManagerComponent(dispatcherResourceManagerComponents, newLeaderRetriever).         CompletableFuture<JobResult> jobResultFuture = leadingDispatcherResourceManagerComponent.getDispatcher().requestJobResult(jobGraph.getJobID(), RPC_TIMEOUT).         BlockingOperator.unblock().         assertThat(jobResultFuture.get().isSuccess(), is(true)).     } finally {         if (dispatcherLeaderRetriever != null) {             dispatcherLeaderRetriever.stop().         }     } }
false;protected;2;12;;@Nonnull protected DispatcherResourceManagerComponent<?> getLeadingDispatcherResourceManagerComponent(Collection<DispatcherResourceManagerComponent<?>> dispatcherResourceManagerComponents, NewLeaderRetriever newLeaderRetriever) throws Exception {     final Tuple2<String, UUID> leaderInformation = newLeaderRetriever.waitUntilNewLeader().get().     final String leaderAddress = leaderInformation.f0.     return findLeadingDispatcherResourceManagerComponent(dispatcherResourceManagerComponents, leaderAddress).orElseThrow(() -> new Exception(String.format("Could not find the leading Dispatcher with address %s", leaderAddress))). }
false;private,static;2;10;;@Nonnull private static Optional<DispatcherResourceManagerComponent<?>> findLeadingDispatcherResourceManagerComponent(Collection<DispatcherResourceManagerComponent<?>> dispatcherResourceManagerComponents, String address) {     for (DispatcherResourceManagerComponent<?> dispatcherResourceManagerComponent : dispatcherResourceManagerComponents) {         if (dispatcherResourceManagerComponent.getDispatcher().getAddress().equals(address)) {             return Optional.of(dispatcherResourceManagerComponent).         }     }     return Optional.empty(). }
false;;0;17;;CompletableFuture<Tuple2<String, UUID>> waitUntilNewLeader() {     synchronized (lock) {         if (newLeaderFuture.isDone()) {             CompletableFuture<Tuple2<String, UUID>> newLeader = newLeaderFuture.             newLeaderFuture = new CompletableFuture<>().             return newLeader.         } else {             return newLeaderFuture.thenApply(stringUUIDTuple2 -> {                 synchronized (lock) {                     newLeaderFuture = new CompletableFuture<>().                 }                 return stringUUIDTuple2.             }).         }     } }
false;protected;1;17;;@Override protected void notifyNewLeaderAddress(CompletableFuture<Tuple2<String, UUID>> newLeaderAddressFuture) {     newLeaderAddressFuture.whenComplete((newLeaderAddress, throwable) -> {         synchronized (lock) {             if (throwable != null) {                 newLeaderFuture.completeExceptionally(throwable).             } else if (!newLeaderAddress.equals(lastAddress)) {                 lastAddress = newLeaderAddress.                 if (newLeaderFuture.isDone()) {                     newLeaderFuture = CompletableFuture.completedFuture(newLeaderAddress).                 } else {                     newLeaderFuture.complete(newLeaderAddress).                 }             }         }     }). }
false;private;1;8;;private JobGraph createJobGraph(int parallelism) {     BlockingOperator.isBlocking = true.     final JobVertex vertex = new JobVertex("blocking operator").     vertex.setParallelism(parallelism).     vertex.setInvokableClass(BlockingOperator.class).     return new JobGraph("Blocking test job", vertex). }
false;public;0;8;;@Override public void invoke() throws Exception {     synchronized (lock) {         while (isBlocking) {             lock.wait().         }     } }
false;public,static;0;6;;public static void unblock() {     synchronized (lock) {         isBlocking = false.         lock.notifyAll().     } }
