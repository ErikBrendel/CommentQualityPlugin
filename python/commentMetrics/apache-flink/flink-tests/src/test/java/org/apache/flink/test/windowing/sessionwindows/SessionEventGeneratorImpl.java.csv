commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * @see EventGenerator  */ ;/**  * @see EventGenerator  */ @Override public boolean canGenerateEventAtWatermark(long globalWatermark) {     return timingAwareEventGenerator.canGenerateEventAtWatermark(globalWatermark). }
true;public;1;15;/**  * @see EventGenerator  */ ;/**  * @see EventGenerator  */ @Override public E generateEvent(long globalWatermark) {     if (hasMoreEvents()) {         ++producedEventsCount.         E event = timingAwareEventGenerator.generateEvent(globalWatermark).         while (!timingAwareEventGenerator.hasMoreEvents()) {             timingAwareEventGenerator = timingAwareEventGenerator.getNextGenerator(globalWatermark).         }         return event.     } else {         throw new IllegalStateException("All events exhausted").     } }
true;public;0;4;/**  * @see EventGenerator  */ ;/**  * @see EventGenerator  */ @Override public long getLocalWatermark() {     return timingAwareEventGenerator.getLocalWatermark(). }
true;public;0;4;/**  * @see EventGenerator  */ ;/**  * @see EventGenerator  */ @Override public boolean hasMoreEvents() {     return producedEventsCount < getAllEventsCount(). }
true;private;2;10;/**  * Pre-computes and stores the timestamps for timely events in this session in a list (ordered).  *  * @param minTimestamp              the minimum event time in the session  * @param onTimeEventCountInSession the number of timestamps to generate  */ ;/**  * Pre-computes and stores the timestamps for timely events in this session in a list (ordered).  *  * @param minTimestamp              the minimum event time in the session  * @param onTimeEventCountInSession the number of timestamps to generate  */ private void generateOrderedTimelyTimestamps(long minTimestamp, int onTimeEventCountInSession) {     long generatedTimestamp = minTimestamp.     for (int i = 1. i < onTimeEventCountInSession. ++i) {         orderedTimelyTimestamps.add(generatedTimestamp).         generatedTimestamp += randomGenerator.randomLongBetween(0, getGap() - 1).     }     orderedTimelyTimestamps.add(generatedTimestamp). }
false;private;3;9;;private E createEventFromTimestamp(long eventTimestamp, long globalWatermark, Timing timing) {     return getEventFactory().createEvent(getKey(), getSessionId(), producedEventsCount, eventTimestamp, globalWatermark, timing). }
true;private;0;6;/**  * @return a timestamp in the session that is timely  */ ;/**  * @return a timestamp in the session that is timely  */ private long generateTimelyInSessionTimestamp() {     int chosenTimestampIndex = randomGenerator.choseRandomIndex(orderedTimelyTimestamps).     // this should not matter too much for a IT case     return orderedTimelyTimestamps.remove(chosenTimestampIndex). }
true;private;0;3;/**  * @return a timestamp in the session  */ ;/**  * @return a timestamp in the session  */ private long generateArbitraryInSessionTimestamp() {     return randomGenerator.randomLongBetween(minTimestamp, maxTimestamp + 1). }
true;private;1;3;/**  * @param globalWatermark the current global watermark  * @return true if the session window for this session has already triggered at global watermark  */ ;/**  * @param globalWatermark the current global watermark  * @return true if the session window for this session has already triggered at global watermark  */ private boolean isTriggered(long globalWatermark) {     return globalWatermark >= maxTimestamp + getGap() - 1. }
true;private;1;3;/**  * @param globalWatermark the current global watermark  * @return true if all future generated events are after lateness w.r.t global watermark  */ ;/**  * @param globalWatermark the current global watermark  * @return true if all future generated events are after lateness w.r.t global watermark  */ private boolean isAfterLateness(long globalWatermark) {     return globalWatermark >= getAfterLatenessTimestamp(). }
true;private;0;3;/**  * @return timestamp of the watermark at events for this session are after the lateness  */ ;/**  * @return timestamp of the watermark at events for this session are after the lateness  */ private long getAfterLatenessTimestamp() {     return getTriggerTimestamp() + getLateness(). }
true;private;0;3;/**  * @return timestamp of the watermark at which the window for this session will trigger  */ ;/**  * @return timestamp of the watermark at which the window for this session will trigger  */ private long getTriggerTimestamp() {     return maxTimestamp + getGap() - 1. }
false;public;0;4;;@Override public K getKey() {     return configuration.getSessionConfiguration().getKey(). }
false;private;0;3;;private long getGap() {     return configuration.getSessionConfiguration().getGap(). }
false;private;0;3;;private long getLateness() {     return configuration.getGeneratorConfiguration().getAllowedLateness(). }
false;private;0;3;;private GeneratorEventFactory<K, E> getEventFactory() {     return configuration.getSessionConfiguration().getEventFactory(). }
false;private;0;3;;private int getSessionId() {     return configuration.getSessionConfiguration().getSessionId(). }
false;private;0;3;;private int getTimelyEventsCount() {     return configuration.getSessionConfiguration().getNumberOfTimelyEvents(). }
false;private;0;3;;private int getLateEventsCount() {     return getTimelyEventsCount() + configuration.getGeneratorConfiguration().getLateEventsWithinLateness(). }
false;private;0;3;;private int getAllEventsCount() {     return getLateEventsCount() + configuration.getGeneratorConfiguration().getLateEventsAfterLateness(). }
false;private;0;3;;private boolean hasMoreTimelyEvents() {     return !orderedTimelyTimestamps.isEmpty(). }
false;private;0;3;;private boolean hasMoreInLatenessEvents() {     return producedEventsCount < getLateEventsCount(). }
true;public;1;17;/**  * @see EventGenerator  */ ;/**  * @see EventGenerator  */ @Override public EventGenerator<K, E> getNextGenerator(long globalWatermark) {     GeneratorConfiguration generatorConfiguration = configuration.getGeneratorConfiguration().     SessionConfiguration<K, E> sessionConfiguration = configuration.getSessionConfiguration().     // compute the start timestamp for the next session     long maxAdditionalGap = generatorConfiguration.getMaxAdditionalSessionGap().     long nextStartTime = Math.max(getAfterLatenessTimestamp() + randomGenerator.randomLongBetween(0, maxAdditionalGap), globalWatermark).     sessionConfiguration = sessionConfiguration.getFollowupSessionConfiguration(nextStartTime).     SessionGeneratorConfiguration<K, E> sessionGeneratorConfiguration = new SessionGeneratorConfiguration<>(sessionConfiguration, generatorConfiguration).     return new SessionEventGeneratorImpl<>(sessionGeneratorConfiguration, randomGenerator). }
false;public;0;4;;@Override public K getKey() {     return configuration.getSessionConfiguration().getKey(). }
false;public;1;4;;@Override public E generateEvent(long globalWatermark) {     return createEventFromTimestamp(generateTimelyInSessionTimestamp(), globalWatermark, Timing.TIMELY). }
false;public;0;4;;@Override public long getLocalWatermark() {     return orderedTimelyTimestamps.get(0). }
false;public;1;4;;@Override public boolean canGenerateEventAtWatermark(long globalWatermark) {     return true. }
false;public;0;4;;@Override public boolean hasMoreEvents() {     return hasMoreTimelyEvents(). }
false;public;1;4;;@Override public EventGenerator<K, E> getNextGenerator(long globalWatermark) {     return new InLatenessGenerator(). }
false;public;1;4;;@Override public E generateEvent(long globalWatermark) {     return createEventFromTimestamp(generateArbitraryInSessionTimestamp(), globalWatermark, Timing.IN_LATENESS). }
false;public;0;4;;@Override public long getLocalWatermark() {     return getAfterLatenessTimestamp() - 1. }
false;public;1;4;;@Override public boolean canGenerateEventAtWatermark(long globalWatermark) {     return isTriggered(globalWatermark). }
false;public;0;4;;@Override public boolean hasMoreEvents() {     return hasMoreInLatenessEvents(). }
false;public;1;4;;@Override public EventGenerator<K, E> getNextGenerator(long globalWatermark) {     return new AfterLatenessGenerator(). }
false;public;1;4;;@Override public E generateEvent(long globalWatermark) {     return createEventFromTimestamp(generateArbitraryInSessionTimestamp(), globalWatermark, Timing.AFTER_LATENESS). }
false;public;0;4;;@Override public long getLocalWatermark() {     return getAfterLatenessTimestamp(). }
false;public;1;4;;@Override public boolean canGenerateEventAtWatermark(long globalWatermark) {     return isAfterLateness(globalWatermark). }
false;public;0;4;;@Override public boolean hasMoreEvents() {     return true. }
false;public;1;4;;@Override public EventGenerator<K, E> getNextGenerator(long globalWatermark) {     throw new IllegalStateException("This generator has no successor"). }
