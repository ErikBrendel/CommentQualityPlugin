commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;32;;public static void main(String[] args) throws Exception {     final int numElements = 40_000_000.     final int keyRange = 4_000_000.     // warm up JIT     testReducePerformance(new TupleIntIntIterator(1000), TupleTypeInfo.<Tuple2<Integer, Integer>>getBasicTupleTypeInfo(Integer.class, Integer.class), CombineHint.SORT, 10000, false).     testReducePerformance(new TupleIntIntIterator(1000), TupleTypeInfo.<Tuple2<Integer, Integer>>getBasicTupleTypeInfo(Integer.class, Integer.class), CombineHint.HASH, 10000, false).     // TupleIntIntIterator     testReducePerformance(new TupleIntIntIterator(keyRange), TupleTypeInfo.<Tuple2<Integer, Integer>>getBasicTupleTypeInfo(Integer.class, Integer.class), CombineHint.SORT, numElements, true).     testReducePerformance(new TupleIntIntIterator(keyRange), TupleTypeInfo.<Tuple2<Integer, Integer>>getBasicTupleTypeInfo(Integer.class, Integer.class), CombineHint.HASH, numElements, true).     // TupleStringIntIterator     testReducePerformance(new TupleStringIntIterator(keyRange), TupleTypeInfo.<Tuple2<String, Integer>>getBasicTupleTypeInfo(String.class, Integer.class), CombineHint.SORT, numElements, true).     testReducePerformance(new TupleStringIntIterator(keyRange), TupleTypeInfo.<Tuple2<String, Integer>>getBasicTupleTypeInfo(String.class, Integer.class), CombineHint.HASH, numElements, true). }
false;private,static;5;21;;private static <T, B extends CopyableIterator<T>> void testReducePerformance(B iterator, TypeInformation<T> typeInfo, CombineHint hint, int numRecords, boolean print) throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.getConfig().enableObjectReuse().     @SuppressWarnings("unchecked")     DataSet<T> output = env.fromParallelCollection(new SplittableRandomIterator<T, B>(numRecords, iterator), typeInfo).groupBy("0").reduce(new SumReducer()).setCombineHint(hint).     long start = System.currentTimeMillis().     System.out.println(output.count()).     long end = System.currentTimeMillis().     if (print) {         System.out.println("=== Time for " + iterator.getClass().getSimpleName() + " with hint " + hint.toString() + ": " + (end - start) + "ms ===").     } }
false;public;0;4;;@Override public boolean hasNext() {     return numElements > 0. }
false;public;0;5;;@Override public T next() {     numElements--.     return baseIterator.next(). }
false;public;1;11;;@SuppressWarnings("unchecked") @Override public SplittableRandomIterator<T, B>[] split(int numPartitions) {     int splitSize = numElements / numPartitions.     int rem = numElements % numPartitions.     SplittableRandomIterator<T, B>[] res = new SplittableRandomIterator[numPartitions].     for (int i = 0. i < numPartitions. i++) {         res[i] = new SplittableRandomIterator<T, B>(i < rem ? splitSize : splitSize + 1, (B) baseIterator.copy()).     }     return res. }
false;public;0;4;;@Override public int getMaximumNumberOfSplits() {     return numElements. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;;0;1;;CopyableIterator<T> copy().
false;public;0;4;;@Override public boolean hasNext() {     return true. }
false;public;0;6;;@Override public Tuple2<Integer, Integer> next() {     reuse.f0 = rnd.nextInt(keyRange).     reuse.f1 = 1.     return reuse. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public CopyableIterator<Tuple2<Integer, Integer>> copy() {     return new TupleIntIntIterator(keyRange, rndSeed + rnd.nextInt(10000)). }
false;public;0;4;;@Override public boolean hasNext() {     return true. }
false;public;0;6;;@Override public Tuple2<String, Integer> next() {     reuse.f0 = String.valueOf(rnd.nextInt(keyRange)).     reuse.f1 = 1.     return reuse. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public CopyableIterator<Tuple2<String, Integer>> copy() {     return new TupleStringIntIterator(keyRange, rndSeed + rnd.nextInt(10000)). }
false;public;2;8;;@Override public Tuple2<K, Integer> reduce(Tuple2<K, Integer> a, Tuple2<K, Integer> b) throws Exception {     if (!a.f0.equals(b.f0)) {         throw new RuntimeException("SumReducer was called with two record that have differing keys.").     }     a.f1 = a.f1 + b.f1.     return a. }
