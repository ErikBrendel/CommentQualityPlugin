commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;5;;public static Configuration getConfiguration() {     Configuration config = new Configuration().     config.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, "12m").     return config. }
false;public;0;12;;@Test public void testFaultyAccumulator() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.getConfig().disableSysoutLogging().     // Test Exception forwarding with faulty Accumulator implementation     env.generateSequence(0, 10000).map(new FaultyAccumulatorUsingMapper()).output(new DiscardingOutputFormat<>()).     assertAccumulatorsShouldFail(env.execute()). }
false;public;0;22;;@Test public void testInvalidTypeAccumulator() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.getConfig().disableSysoutLogging().     // Test Exception forwarding with faulty Accumulator implementation     env.generateSequence(0, 10000).map(new IncompatibleAccumulatorTypesMapper()).map(new IncompatibleAccumulatorTypesMapper2()).output(new DiscardingOutputFormat<>()).     try {         env.execute().         fail("Should have failed.").     } catch (JobExecutionException e) {         assertTrue("Root cause should be:", e.getCause() instanceof Exception).         assertTrue("Root cause should be:", e.getCause().getCause() instanceof UnsupportedOperationException).     } }
false;public;0;12;;@Test public void testFaultyMergeAccumulator() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.getConfig().disableSysoutLogging().     // Test Exception forwarding with faulty Accumulator implementation     env.generateSequence(0, 10000).map(new FaultyMergeAccumulatorUsingMapper()).output(new DiscardingOutputFormat<>()).     assertAccumulatorsShouldFail(env.execute()). }
false;public;1;4;;@Override public void open(Configuration parameters) throws Exception {     getRuntimeContext().addAccumulator(FAULTY_CLONE_ACCUMULATOR, new FaultyCloneAccumulator()). }
false;public;1;4;;@Override public Long map(Long value) throws Exception {     return -1L. }
false;public;0;4;;@Override public LongCounter clone() {     throw new CustomException(). }
false;public;1;4;;@Override public void open(Configuration parameters) throws Exception {     getRuntimeContext().addAccumulator(INCOMPATIBLE_ACCUMULATORS_NAME, new LongCounter()). }
false;public;1;4;;@Override public Long map(Long value) throws Exception {     return -1L. }
false;public;1;4;;@Override public void open(Configuration parameters) throws Exception {     getRuntimeContext().addAccumulator(INCOMPATIBLE_ACCUMULATORS_NAME, new DoubleCounter()). }
false;public;1;4;;@Override public Long map(Long value) throws Exception {     return -1L. }
false;public;1;4;;@Override public void open(Configuration parameters) throws Exception {     getRuntimeContext().addAccumulator(FAULTY_MERGE_ACCUMULATOR, new FaultyMergeAccumulator()). }
false;public;1;4;;@Override public Long map(Long value) throws Exception {     return -1L. }
false;public;1;4;;@Override public void merge(Accumulator<Long, Long> other) {     throw new CustomException(). }
false;public;0;4;;@Override public LongCounter clone() {     return new FaultyMergeAccumulator(). }
false;private,static;1;9;;private static void assertAccumulatorsShouldFail(JobExecutionResult result) {     try {         result.getAllAccumulatorResults().         fail("Should have failed").     } catch (Exception ex) {         assertTrue(ExceptionUtils.findThrowable(ex, CustomException.class).isPresent()).     } }
