commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@Parameterized.Parameters(name = "statebackend type ={0}") public static Collection<StateBackendEnum> parameter() {     return Arrays.asList(StateBackendEnum.values()). }
false;protected;0;3;;protected StateBackendEnum getStateBackend() {     return this.stateBackendEnum. }
false;protected,final;0;8;;protected final MiniClusterWithClientResource getMiniClusterResource() {     return new MiniClusterWithClientResource(new MiniClusterResourceConfiguration.Builder().setConfiguration(getConfigurationSafe()).setNumberTaskManagers(2).setNumberSlotsPerTaskManager(PARALLELISM / 2).build()). }
false;private;0;7;;private Configuration getConfigurationSafe() {     try {         return getConfiguration().     } catch (Exception e) {         throw new AssertionError("Could not initialize test.", e).     } }
false;private;0;53;;private Configuration getConfiguration() throws Exception {     // print a message when starting a test method to avoid Travis' <tt>"Maven produced no     // output for xxx seconds."</tt> messages     System.out.println("Starting " + getClass().getCanonicalName() + "#" + name.getMethodName() + ".").     // Testing HA Scenario / ZKCompletedCheckpointStore with incremental checkpoints     StateBackendEnum stateBackendEnum = getStateBackend().     if (ROCKSDB_INCREMENTAL_ZK.equals(stateBackendEnum)) {         zkServer = new TestingServer().         zkServer.start().     }     Configuration config = createClusterConfig().     switch(stateBackendEnum) {         case MEM:             this.stateBackend = new MemoryStateBackend(MAX_MEM_STATE_SIZE, false).             break.         case FILE:             {                 String backups = tempFolder.newFolder().getAbsolutePath().                 this.stateBackend = new FsStateBackend("file://" + backups, false).                 break.             }         case MEM_ASYNC:             this.stateBackend = new MemoryStateBackend(MAX_MEM_STATE_SIZE, true).             break.         case FILE_ASYNC:             {                 String backups = tempFolder.newFolder().getAbsolutePath().                 this.stateBackend = new FsStateBackend("file://" + backups, true).                 break.             }         case ROCKSDB_FULLY_ASYNC:             {                 setupRocksDB(-1, false).                 break.             }         case ROCKSDB_INCREMENTAL:             // Test RocksDB based timer service as well             config.setString(RocksDBOptions.TIMER_SERVICE_FACTORY, RocksDBStateBackend.PriorityQueueStateType.ROCKSDB.toString()).             setupRocksDB(16, true).             break.         case ROCKSDB_INCREMENTAL_ZK:             {                 setupRocksDB(16, true).                 break.             }         default:             throw new IllegalStateException("No backend selected.").     }     return config. }
false;private;2;13;;private void setupRocksDB(int fileSizeThreshold, boolean incrementalCheckpoints) throws IOException {     String rocksDb = tempFolder.newFolder().getAbsolutePath().     String backups = tempFolder.newFolder().getAbsolutePath().     // we use the fs backend with small threshold here to test the behaviour with file     // references, not self contained byte handles     RocksDBStateBackend rdb = new RocksDBStateBackend(new FsStateBackend(new Path("file://" + backups).toUri(), fileSizeThreshold), incrementalCheckpoints).     rdb.setDbStoragePath(rocksDb).     this.stateBackend = rdb. }
false;protected;0;18;;protected Configuration createClusterConfig() throws IOException {     TemporaryFolder temporaryFolder = new TemporaryFolder().     temporaryFolder.create().     final File haDir = temporaryFolder.newFolder().     Configuration config = new Configuration().     config.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, "48m").     // the default network buffers size (10% of heap max =~ 150MB) seems to much for this test case     // 80 MB     config.setString(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX, String.valueOf(80L << 20)).     config.setString(AkkaOptions.FRAMESIZE, String.valueOf(MAX_MEM_STATE_SIZE) + "b").     if (zkServer != null) {         config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER").         config.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zkServer.getConnectString()).         config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, haDir.toURI().toString()).     }     return config. }
false;public;0;5;;@Before public void setupTestCluster() throws Exception {     miniClusterResource = getMiniClusterResource().     miniClusterResource.before(). }
false;public;0;17;;@After public void stopTestCluster() throws IOException {     if (miniClusterResource != null) {         miniClusterResource.after().         miniClusterResource = null.     }     if (zkServer != null) {         zkServer.stop().         zkServer = null.     }     // Prints a message when finishing a test method to avoid Travis' <tt>"Maven produced no output     // for xxx seconds."</tt> messages.     System.out.println("Finished " + getClass().getCanonicalName() + "#" + name.getMethodName() + "."). }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;4;22;;@Override public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple4<Long, Long, Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     int sum = 0.     long key = -1.     for (Tuple2<Long, IntType> value : values) {         sum += value.f1.value.         key = value.f0.     }     final Tuple4<Long, Long, Long, IntType> result = new Tuple4<>(key, window.getStart(), window.getEnd(), new IntType(sum)).     out.collect(result). }
false;public;0;65;;// ------------------------------------------------------------------------ @Test public void testTumblingTimeWindow() {     final int numElementsPerKey = numElementsPerKey().     final int windowSize = windowSize().     final int numKeys = numKeys().     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         env.setStateBackend(this.stateBackend).         env.getConfig().setUseSnapshotCompression(true).         env.addSource(new FailingSource(new KeyedEventTimeGenerator(numKeys, windowSize), numElementsPerKey)).rebalance().keyBy(0).timeWindow(Time.of(windowSize, MILLISECONDS)).apply(new RichWindowFunction<Tuple2<Long, IntType>, Tuple4<Long, Long, Long, IntType>, Tuple, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple4<Long, Long, Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 int sum = 0.                 long key = -1.                 for (Tuple2<Long, IntType> value : values) {                     sum += value.f1.value.                     key = value.f0.                 }                 final Tuple4<Long, Long, Long, IntType> result = new Tuple4<>(key, window.getStart(), window.getEnd(), new IntType(sum)).                 out.collect(result).             }         }).addSink(new ValidatingSink<>(new SinkValidatorUpdateFun(numElementsPerKey), new SinkValidatorCheckFun(numKeys, numElementsPerKey, windowSize))).setParallelism(1).         env.execute("Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;4;;@Test public void testTumblingTimeWindowWithKVStateMinMaxParallelism() {     doTestTumblingTimeWindowWithKVState(PARALLELISM). }
false;public;0;4;;@Test public void testTumblingTimeWindowWithKVStateMaxMaxParallelism() {     doTestTumblingTimeWindowWithKVState(1 << 15). }
false;public;1;7;;@Override public void open(Configuration parameters) {     assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true.     count = getRuntimeContext().getState(new ValueStateDescriptor<>("count", Integer.class, 0)). }
false;public;4;19;;@Override public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple4<Long, Long, Long, IntType>> out) throws Exception {     // different count results for each key     if (count.value() == 0) {         count.update(tuple.<Long>getField(0).intValue()).     }     // validate that the function has been opened properly     assertTrue(open).     count.update(count.value() + 1).     out.collect(new Tuple4<>(tuple.<Long>getField(0), window.getStart(), window.getEnd(), new IntType(count.value()))). }
false;public;1;66;;public void doTestTumblingTimeWindowWithKVState(int maxParallelism) {     final int numElementsPerKey = numElementsPerKey().     final int windowSize = windowSize().     final int numKeys = numKeys().     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setMaxParallelism(maxParallelism).         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         env.setStateBackend(this.stateBackend).         env.getConfig().setUseSnapshotCompression(true).         env.addSource(new FailingSource(new KeyedEventTimeGenerator(numKeys, windowSize), numElementsPerKey)).rebalance().keyBy(0).timeWindow(Time.of(windowSize, MILLISECONDS)).apply(new RichWindowFunction<Tuple2<Long, IntType>, Tuple4<Long, Long, Long, IntType>, Tuple, TimeWindow>() {              private boolean open = false.              private ValueState<Integer> count.              @Override             public void open(Configuration parameters) {                 assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.                 count = getRuntimeContext().getState(new ValueStateDescriptor<>("count", Integer.class, 0)).             }              @Override             public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple4<Long, Long, Long, IntType>> out) throws Exception {                 // different count results for each key                 if (count.value() == 0) {                     count.update(tuple.<Long>getField(0).intValue()).                 }                 // validate that the function has been opened properly                 assertTrue(open).                 count.update(count.value() + 1).                 out.collect(new Tuple4<>(tuple.<Long>getField(0), window.getStart(), window.getEnd(), new IntType(count.value()))).             }         }).addSink(new ValidatingSink<>(new CountingSinkValidatorUpdateFun(), new SinkValidatorCheckFun(numKeys, numElementsPerKey, windowSize))).setParallelism(1).         env.execute("Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;4;21;;@Override public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple4<Long, Long, Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     int sum = 0.     long key = -1.     for (Tuple2<Long, IntType> value : values) {         sum += value.f1.value.         key = value.f0.     }     final Tuple4<Long, Long, Long, IntType> output = new Tuple4<>(key, window.getStart(), window.getEnd(), new IntType(sum)).     out.collect(output). }
false;public;0;66;;@Test public void testSlidingTimeWindow() {     final int numElementsPerKey = numElementsPerKey().     final int windowSize = windowSize().     final int windowSlide = windowSlide().     final int numKeys = numKeys().     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setMaxParallelism(2 * PARALLELISM).         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         env.setStateBackend(this.stateBackend).         env.getConfig().setUseSnapshotCompression(true).         env.addSource(new FailingSource(new KeyedEventTimeGenerator(numKeys, windowSlide), numElementsPerKey)).rebalance().keyBy(0).timeWindow(Time.of(windowSize, MILLISECONDS), Time.of(windowSlide, MILLISECONDS)).apply(new RichWindowFunction<Tuple2<Long, IntType>, Tuple4<Long, Long, Long, IntType>, Tuple, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple4<Long, Long, Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 int sum = 0.                 long key = -1.                 for (Tuple2<Long, IntType> value : values) {                     sum += value.f1.value.                     key = value.f0.                 }                 final Tuple4<Long, Long, Long, IntType> output = new Tuple4<>(key, window.getStart(), window.getEnd(), new IntType(sum)).                 out.collect(output).             }         }).addSink(new ValidatingSink<>(new SinkValidatorUpdateFun(numElementsPerKey), new SinkValidatorCheckFun(numKeys, numElementsPerKey, windowSlide))).setParallelism(1).         env.execute("Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;6;;@Override public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {     return new Tuple2<>(a.f0, new IntType(a.f1.value + b.f1.value)). }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;4;18;;@Override public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> input, Collector<Tuple4<Long, Long, Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     for (Tuple2<Long, IntType> in : input) {         final Tuple4<Long, Long, Long, IntType> output = new Tuple4<>(in.f0, window.getStart(), window.getEnd(), in.f1).         out.collect(output).     } }
false;public;0;71;;@Test public void testPreAggregatedTumblingTimeWindow() {     final int numElementsPerKey = numElementsPerKey().     final int windowSize = windowSize().     final int numKeys = numKeys().     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         env.setStateBackend(this.stateBackend).         env.getConfig().setUseSnapshotCompression(true).         env.addSource(new FailingSource(new KeyedEventTimeGenerator(numKeys, windowSize), numElementsPerKey)).rebalance().keyBy(0).timeWindow(Time.of(windowSize, MILLISECONDS)).reduce(new ReduceFunction<Tuple2<Long, IntType>>() {              @Override             public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {                 return new Tuple2<>(a.f0, new IntType(a.f1.value + b.f1.value)).             }         }, new RichWindowFunction<Tuple2<Long, IntType>, Tuple4<Long, Long, Long, IntType>, Tuple, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> input, Collector<Tuple4<Long, Long, Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 for (Tuple2<Long, IntType> in : input) {                     final Tuple4<Long, Long, Long, IntType> output = new Tuple4<>(in.f0, window.getStart(), window.getEnd(), in.f1).                     out.collect(output).                 }             }         }).addSink(new ValidatingSink<>(new SinkValidatorUpdateFun(numElementsPerKey), new SinkValidatorCheckFun(numKeys, numElementsPerKey, windowSize))).setParallelism(1).         env.execute("Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;8;;@Override public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {     // validate that the function has been opened properly     return new Tuple2<>(a.f0, new IntType(a.f1.value + b.f1.value)). }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;4;17;;@Override public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> input, Collector<Tuple4<Long, Long, Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     for (Tuple2<Long, IntType> in : input) {         out.collect(new Tuple4<>(in.f0, window.getStart(), window.getEnd(), in.f1)).     } }
false;public;0;73;;@Test public void testPreAggregatedSlidingTimeWindow() {     final int numElementsPerKey = numElementsPerKey().     final int windowSize = windowSize().     final int windowSlide = windowSlide().     final int numKeys = numKeys().     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         env.setStateBackend(this.stateBackend).         env.getConfig().setUseSnapshotCompression(true).         env.addSource(new FailingSource(new KeyedEventTimeGenerator(numKeys, windowSlide), numElementsPerKey)).rebalance().keyBy(0).timeWindow(Time.of(windowSize, MILLISECONDS), Time.of(windowSlide, MILLISECONDS)).reduce(new ReduceFunction<Tuple2<Long, IntType>>() {              @Override             public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {                 // validate that the function has been opened properly                 return new Tuple2<>(a.f0, new IntType(a.f1.value + b.f1.value)).             }         }, new RichWindowFunction<Tuple2<Long, IntType>, Tuple4<Long, Long, Long, IntType>, Tuple, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(PARALLELISM, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(Tuple tuple, TimeWindow window, Iterable<Tuple2<Long, IntType>> input, Collector<Tuple4<Long, Long, Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 for (Tuple2<Long, IntType> in : input) {                     out.collect(new Tuple4<>(in.f0, window.getStart(), window.getEnd(), in.f1)).                 }             }         }).addSink(new ValidatingSink<>(new SinkValidatorUpdateFun(numElementsPerKey), new SinkValidatorCheckFun(numKeys, numElementsPerKey, windowSlide))).setParallelism(1).         env.execute("Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;9;;@Override public void updateCount(Tuple4<Long, Long, Long, IntType> value, Map<Long, Integer> windowCounts) {     windowCounts.merge(value.f0, 1, (a, b) -> a + b).     // verify the contents of that window, the contents should be:     // (key + num windows so far)     assertEquals("Window counts don't match for key " + value.f0 + ".", value.f0.intValue() + windowCounts.get(value.f0), value.f3.value). }
false;public;2;20;;@Override public void updateCount(Tuple4<Long, Long, Long, IntType> value, Map<Long, Integer> windowCounts) {     // verify the contents of that window, Tuple4.f1 and .f2 are the window start/end     // the sum should be "sum (start .. end-1)"     int expectedSum = 0.     // we shorten the range if it goes beyond elementsPerKey, because those are "incomplete" sliding windows     long countUntil = Math.min(value.f2, elementsPerKey).     for (long i = value.f1. i < countUntil. i++) {         // first sliding windows         if (i > 0) {             expectedSum += i.         }     }     assertEquals("Window start: " + value.f1 + " end: " + value.f2, expectedSum, value.f3.value).     windowCounts.merge(value.f0, 1, (val, increment) -> val + increment). }
false;public;1;12;;@Override public boolean checkResult(Map<Long, Integer> windowCounts) {     if (windowCounts.size() == numKeys) {         for (Integer windowCount : windowCounts.values()) {             if (windowCount < numWindowsExpected) {                 return false.             }         }         return true.     }     return false. }
false;public;2;10;;@Override public void emitEvent(SourceFunction.SourceContext<Tuple2<Long, IntType>> ctx, int eventSequenceNo) {     final IntType intTypeNext = new IntType(eventSequenceNo).     for (long i = 0. i < keyUniverseSize. i++) {         final Tuple2<Long, IntType> generatedEvent = new Tuple2<>(i, intTypeNext).         ctx.collectWithTimestamp(generatedEvent, eventSequenceNo).     }     ctx.emitWatermark(new Watermark(eventSequenceNo - watermarkTrailing)). }
false;private;0;10;;private int numElementsPerKey() {     switch(this.stateBackendEnum) {         case ROCKSDB_FULLY_ASYNC:         case ROCKSDB_INCREMENTAL:         case ROCKSDB_INCREMENTAL_ZK:             return 3000.         default:             return 300.     } }
false;private;0;10;;private int windowSize() {     switch(this.stateBackendEnum) {         case ROCKSDB_FULLY_ASYNC:         case ROCKSDB_INCREMENTAL:         case ROCKSDB_INCREMENTAL_ZK:             return 1000.         default:             return 100.     } }
false;private;0;3;;private int windowSlide() {     return 100. }
false;private;0;10;;private int numKeys() {     switch(this.stateBackendEnum) {         case ROCKSDB_FULLY_ASYNC:         case ROCKSDB_INCREMENTAL:         case ROCKSDB_INCREMENTAL_ZK:             return 100.         default:             return 20.     } }
