commented;modifiers;parameterAmount;loc;comment;code
false;public;0;32;;@Override public void invoke() throws Exception {     RecordWriter<SpeedTestRecord> writer = new RecordWriter<>(getEnvironment().getWriter(0)).     try {         // Determine the amount of data to send per subtask         int dataVolumeGb = getTaskConfiguration().getInteger(NetworkStackThroughputITCase.DATA_VOLUME_GB_CONFIG_KEY, 1).         long dataMbPerSubtask = (dataVolumeGb * 10) / getCurrentNumberOfSubtasks().         long numRecordsToEmit = (dataMbPerSubtask * 1024 * 1024) / SpeedTestRecord.RECORD_SIZE.         LOG.info(String.format("%d/%d: Producing %d records (each record: %d bytes, total: %.2f GB)", getIndexInSubtaskGroup() + 1, getCurrentNumberOfSubtasks(), numRecordsToEmit, SpeedTestRecord.RECORD_SIZE, dataMbPerSubtask / 1024.0)).         boolean isSlow = getTaskConfiguration().getBoolean(IS_SLOW_SENDER_CONFIG_KEY, false).         int numRecords = 0.         SpeedTestRecord record = new SpeedTestRecord().         for (long i = 0. i < numRecordsToEmit. i++) {             if (isSlow && (numRecords++ % IS_SLOW_EVERY_NUM_RECORDS) == 0) {                 Thread.sleep(IS_SLOW_SLEEP_MS).             }             writer.emit(record).         }     } finally {         writer.clearBuffers().         writer.flushAll().     } }
false;public;0;21;;@Override public void invoke() throws Exception {     RecordReader<SpeedTestRecord> reader = new RecordReader<>(getEnvironment().getInputGate(0), SpeedTestRecord.class, getEnvironment().getTaskManagerInfo().getTmpDirectories()).     RecordWriter<SpeedTestRecord> writer = new RecordWriter<>(getEnvironment().getWriter(0)).     try {         SpeedTestRecord record.         while ((record = reader.next()) != null) {             writer.emit(record).         }     } finally {         reader.clearBuffers().         writer.clearBuffers().         writer.flushAll().     } }
false;public;0;21;;@Override public void invoke() throws Exception {     RecordReader<SpeedTestRecord> reader = new RecordReader<>(getEnvironment().getInputGate(0), SpeedTestRecord.class, getEnvironment().getTaskManagerInfo().getTmpDirectories()).     try {         boolean isSlow = getTaskConfiguration().getBoolean(IS_SLOW_RECEIVER_CONFIG_KEY, false).         int numRecords = 0.         while (reader.next() != null) {             if (isSlow && (numRecords++ % IS_SLOW_EVERY_NUM_RECORDS) == 0) {                 Thread.sleep(IS_SLOW_SLEEP_MS).             }         }     } finally {         reader.clearBuffers().     } }
false;public;1;4;;@Override public void write(DataOutputView out) throws IOException {     out.write(this.buf). }
false;public;1;4;;@Override public void read(DataInputView in) throws IOException {     in.readFully(this.buf). }
false;public;0;48;;// ------------------------------------------------------------------------ @Test public void testThroughput() throws Exception {     Object[][] configParams = new Object[][] { new Object[] { 1, false, false, false, 4, 2 }, new Object[] { 1, true, false, false, 4, 2 }, new Object[] { 1, true, true, false, 4, 2 }, new Object[] { 1, true, false, true, 4, 2 }, new Object[] { 2, true, false, false, 4, 2 }, new Object[] { 4, true, false, false, 4, 2 }, new Object[] { 4, true, false, false, 8, 4 } }.     for (Object[] p : configParams) {         final int dataVolumeGb = (Integer) p[0].         final boolean useForwarder = (Boolean) p[1].         final boolean isSlowSender = (Boolean) p[2].         final boolean isSlowReceiver = (Boolean) p[3].         final int parallelism = (Integer) p[4].         final int numSlotsPerTaskManager = (Integer) p[5].         if (parallelism % numSlotsPerTaskManager != 0) {             throw new RuntimeException("The test case defines a parallelism that is not a multiple of the slots per task manager.").         }         final int numTaskManagers = parallelism / numSlotsPerTaskManager.         final MiniClusterWithClientResource cluster = new MiniClusterWithClientResource(new MiniClusterResourceConfiguration.Builder().setNumberTaskManagers(numTaskManagers).setNumberSlotsPerTaskManager(numSlotsPerTaskManager).build()).         cluster.before().         try {             System.out.println(String.format("Running test with parameters: dataVolumeGB=%s, useForwarder=%s, isSlowSender=%s, isSlowReceiver=%s, parallelism=%s, numSlotsPerTM=%s", dataVolumeGb, useForwarder, isSlowSender, isSlowReceiver, parallelism, numSlotsPerTaskManager)).             testProgram(cluster, dataVolumeGb, useForwarder, isSlowSender, isSlowReceiver, parallelism).         } finally {             cluster.after().         }     } }
false;private;6;28;;private void testProgram(final MiniClusterWithClientResource cluster, final int dataVolumeGb, final boolean useForwarder, final boolean isSlowSender, final boolean isSlowReceiver, final int parallelism) throws Exception {     ClusterClient<?> client = cluster.getClusterClient().     client.setDetached(false).     client.setPrintStatusDuringExecution(false).     JobExecutionResult jer = (JobExecutionResult) client.submitJob(createJobGraph(dataVolumeGb, useForwarder, isSlowSender, isSlowReceiver, parallelism), getClass().getClassLoader()).     long dataVolumeMbit = dataVolumeGb * 8192.     long runtimeSecs = jer.getNetRuntime(TimeUnit.SECONDS).     int mbitPerSecond = (int) (((double) dataVolumeMbit) / runtimeSecs).     LOG.info(String.format("Test finished with throughput of %d MBit/s (runtime [secs]: %d, " + "data volume [gb/mbits]: %d/%d)", mbitPerSecond, runtimeSecs, dataVolumeGb, dataVolumeMbit)). }
false;private;5;45;;private JobGraph createJobGraph(int dataVolumeGb, boolean useForwarder, boolean isSlowSender, boolean isSlowReceiver, int numSubtasks) {     JobGraph jobGraph = new JobGraph("Speed Test").     SlotSharingGroup sharingGroup = new SlotSharingGroup().     JobVertex producer = new JobVertex("Speed Test Producer").     jobGraph.addVertex(producer).     producer.setSlotSharingGroup(sharingGroup).     producer.setInvokableClass(SpeedTestProducer.class).     producer.setParallelism(numSubtasks).     producer.getConfiguration().setInteger(DATA_VOLUME_GB_CONFIG_KEY, dataVolumeGb).     producer.getConfiguration().setBoolean(IS_SLOW_SENDER_CONFIG_KEY, isSlowSender).     JobVertex forwarder = null.     if (useForwarder) {         forwarder = new JobVertex("Speed Test Forwarder").         jobGraph.addVertex(forwarder).         forwarder.setSlotSharingGroup(sharingGroup).         forwarder.setInvokableClass(SpeedTestForwarder.class).         forwarder.setParallelism(numSubtasks).     }     JobVertex consumer = new JobVertex("Speed Test Consumer").     jobGraph.addVertex(consumer).     consumer.setSlotSharingGroup(sharingGroup).     consumer.setInvokableClass(SpeedTestConsumer.class).     consumer.setParallelism(numSubtasks).     consumer.getConfiguration().setBoolean(IS_SLOW_RECEIVER_CONFIG_KEY, isSlowReceiver).     if (useForwarder) {         forwarder.connectNewDataSetAsInput(producer, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED).         consumer.connectNewDataSetAsInput(forwarder, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED).     } else {         consumer.connectNewDataSetAsInput(producer, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED).     }     return jobGraph. }
false;public,static;1;5;;public static void main(String[] args) throws Exception {     new NetworkStackThroughputITCase().testThroughput().     System.out.println("Done."). }
