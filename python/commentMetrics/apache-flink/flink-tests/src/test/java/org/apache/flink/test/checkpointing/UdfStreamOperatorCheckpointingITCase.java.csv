commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public Tuple2<Integer, Long> reduce(Tuple2<Integer, Long> value1, Tuple2<Integer, Long> value2) throws Exception {     return Tuple2.of(value1.f0, value1.f1 + value2.f1). }
false;public;2;5;;@Override public Tuple2<Integer, Long> fold(Tuple2<Integer, Long> accumulator, Tuple2<Integer, Long> value) throws Exception {     return Tuple2.of(value.f0, accumulator.f1 + value.f1). }
true;public;1;39;/**  * Assembles a stream of a grouping field and some long data. Applies reduce functions  * on this stream.  */ ;/**  * Assembles a stream of a grouping field and some long data. Applies reduce functions  * on this stream.  */ @Override public void testProgram(StreamExecutionEnvironment env) {     // base stream     KeyedStream<Tuple2<Integer, Long>, Tuple> stream = env.addSource(new StatefulMultipleSequence()).keyBy(0).     stream.min(1).map(new OnceFailingIdentityMapFunction(NUM_INPUT)).keyBy(0).addSink(new MinEvictingQueueSink()).     stream.reduce(new ReduceFunction<Tuple2<Integer, Long>>() {          @Override         public Tuple2<Integer, Long> reduce(Tuple2<Integer, Long> value1, Tuple2<Integer, Long> value2) throws Exception {             return Tuple2.of(value1.f0, value1.f1 + value2.f1).         }     }).keyBy(0).addSink(new SumEvictingQueueSink()).     stream.fold(Tuple2.of(0, 0L), new FoldFunction<Tuple2<Integer, Long>, Tuple2<Integer, Long>>() {          @Override         public Tuple2<Integer, Long> fold(Tuple2<Integer, Long> accumulator, Tuple2<Integer, Long> value) throws Exception {             return Tuple2.of(value.f0, accumulator.f1 + value.f1).         }     }).keyBy(0).addSink(new FoldEvictingQueueSink()). }
false;public;0;35;;@Override public void postSubmit() {     // Checking the result of the built-in aggregate     for (int i = 0. i < PARALLELISM. i++) {         for (Long value : MinEvictingQueueSink.queues[i]) {             Assert.assertTrue("Value different from 1 found, was " + value + ".", value == 1).         }     }     // Checking the result of the UDF reducer     for (int i = 0. i < PARALLELISM. i++) {         long prevCount = NUM_INPUT - NUM_OUTPUT.         long sum = prevCount * (prevCount + 1) / 2.         while (!SumEvictingQueueSink.queues[i].isEmpty()) {             sum += ++prevCount.             Long value = SumEvictingQueueSink.queues[i].remove().             Assert.assertTrue("Unexpected reduce value " + value + " instead of " + sum + ".", value == sum).         }     }     // Checking the result of the UDF folder     for (int i = 0. i < PARALLELISM. i++) {         long prevCount = NUM_INPUT - NUM_OUTPUT.         long sum = prevCount * (prevCount + 1) / 2.         while (!FoldEvictingQueueSink.queues[i].isEmpty()) {             sum += ++prevCount.             Long value = FoldEvictingQueueSink.queues[i].remove().             Assert.assertTrue("Unexpected fold value " + value + " instead of " + sum + ".", value == sum).         }     } }
false;public;1;13;;@Override public void run(SourceContext<Tuple2<Integer, Long>> ctx) throws Exception {     Object lock = ctx.getCheckpointLock().     while (count < NUM_INPUT) {         synchronized (lock) {             for (int i = 0. i < PARALLELISM. i++) {                 ctx.collect(Tuple2.of(i, count + 1)).             }             count++.         }     } }
false;public;0;2;;@Override public void cancel() { }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.count). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.count = state.get(0). }
false;public;1;7;;@Override public void open(Configuration parameters) throws Exception {     long failurePosMin = (long) (0.4 * numElements / getRuntimeContext().getNumberOfParallelSubtasks()).     long failurePosMax = (long) (0.7 * numElements / getRuntimeContext().getNumberOfParallelSubtasks()).     failurePos = (new Random().nextLong() % (failurePosMax - failurePosMin)) + failurePosMin. }
false;public;1;9;;@Override public Tuple2<Integer, Long> map(Tuple2<Integer, Long> value) throws Exception {     if (!hasFailed && count >= failurePos) {         hasFailed = true.         throw new Exception("Test Failure").     }     count++.     return value. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(count). }
false;public;1;6;;@Override public void restoreState(List<Long> state) throws Exception {     if (!state.isEmpty()) {         count = state.get(0).     } }
false;public;1;7;;@Override public void invoke(Tuple2<Integer, Long> value) throws Exception {     if (queues[value.f0] == null) {         queues[value.f0] = EvictingQueue.create(NUM_OUTPUT).     }     queues[value.f0].add(value.f1). }
false;public;1;7;;@Override public void invoke(Tuple2<Integer, Long> value) throws Exception {     if (queues[value.f0] == null) {         queues[value.f0] = EvictingQueue.create(NUM_OUTPUT).     }     queues[value.f0].add(value.f1). }
false;public;1;7;;@Override public void invoke(Tuple2<Integer, Long> value) throws Exception {     if (queues[value.f0] == null) {         queues[value.f0] = EvictingQueue.create(NUM_OUTPUT).     }     queues[value.f0].add(value.f1). }
