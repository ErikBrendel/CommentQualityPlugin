commented;modifiers;parameterAmount;loc;comment;code
true;public;0;7;/**  * Tests that if local recovery is disabled we won't spread  * out tasks when recovering.  */ ;/**  * Tests that if local recovery is disabled we won't spread  * out tasks when recovering.  */ @Test public void testDisablingLocalRecovery() throws Exception {     final Configuration configuration = new Configuration().     configuration.setBoolean(CheckpointingOptions.LOCAL_RECOVERY, false).     executeSchedulingTest(configuration). }
true;public;0;4;/**  * Tests that if local recovery is enabled we won't spread  * out tasks when recovering for global failover.  */ ;/**  * Tests that if local recovery is enabled we won't spread  * out tasks when recovering for global failover.  */ @Test public void testLocalRecoveryFull() throws Exception {     testLocalRecoveryInternal("full"). }
true;public;0;4;/**  * Tests that if local recovery is enabled we won't spread  * out tasks when recovering for regional failover.  */ ;/**  * Tests that if local recovery is enabled we won't spread  * out tasks when recovering for regional failover.  */ @Test public void testLocalRecoveryRegion() throws Exception {     testLocalRecoveryInternal("region"). }
false;private;1;7;;private void testLocalRecoveryInternal(String failoverStrategyValue) throws Exception {     final Configuration configuration = new Configuration().     configuration.setBoolean(CheckpointingOptions.LOCAL_RECOVERY, true).     configuration.setString(EXECUTION_FAILOVER_STRATEGY.key(), failoverStrategyValue).     executeSchedulingTest(configuration). }
false;private;1;31;;private void executeSchedulingTest(Configuration configuration) throws Exception {     configuration.setString(RestOptions.BIND_PORT, "0").     final long slotIdleTimeout = 50L.     configuration.setLong(JobManagerOptions.SLOT_IDLE_TIMEOUT, slotIdleTimeout).     final int parallelism = 4.     final MiniClusterConfiguration miniClusterConfiguration = new MiniClusterConfiguration.Builder().setConfiguration(configuration).setNumTaskManagers(parallelism).setNumSlotsPerTaskManager(1).build().     try (MiniCluster miniCluster = new MiniCluster(miniClusterConfiguration)) {         miniCluster.start().         MiniClusterClient miniClusterClient = new MiniClusterClient(configuration, miniCluster).         JobGraph jobGraph = createJobGraph(slotIdleTimeout << 1, parallelism).         CompletableFuture<JobSubmissionResult> submissionFuture = miniClusterClient.submitJob(jobGraph).         // wait for the submission to succeed         JobSubmissionResult jobSubmissionResult = submissionFuture.get().         CompletableFuture<JobResult> resultFuture = miniClusterClient.requestJobResult(jobSubmissionResult.getJobID()).         JobResult jobResult = resultFuture.get().         assertThat(jobResult.getSerializedThrowable().isPresent(), is(false)).     } }
false;private;2;25;;@Nonnull private JobGraph createJobGraph(long delay, int parallelism) throws IOException {     SlotSharingGroup slotSharingGroup = new SlotSharingGroup().     final JobVertex source = new JobVertex("source").     source.setInvokableClass(OneTimeFailingInvokable.class).     source.setParallelism(parallelism).     source.setSlotSharingGroup(slotSharingGroup).     final JobVertex sink = new JobVertex("sink").     sink.setInvokableClass(NoOpInvokable.class).     sink.setParallelism(parallelism).     sink.setSlotSharingGroup(slotSharingGroup).     sink.connectNewDataSetAsInput(source, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED).     JobGraph jobGraph = new JobGraph(source, sink).     jobGraph.setScheduleMode(ScheduleMode.EAGER).     ExecutionConfig executionConfig = new ExecutionConfig().     executionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, delay)).     jobGraph.setExecutionConfig(executionConfig).     return jobGraph. }
false;public;0;6;;@Override public void invoke() throws Exception {     if (hasFailed.compareAndSet(false, true)) {         throw new FlinkException("One time failure.").     } }
