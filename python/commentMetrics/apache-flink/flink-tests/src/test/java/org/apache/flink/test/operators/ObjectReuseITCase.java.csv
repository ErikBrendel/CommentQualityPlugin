commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public Tuple2<String, Integer> reduce(Tuple2<String, Integer> value1, Tuple2<String, Integer> value2) {     value2.f1 += value1.f1.     return value2. }
false;public;0;26;;@Test public void testKeyedReduce() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     if (objectReuse) {         env.getConfig().enableObjectReuse().     } else {         env.getConfig().disableObjectReuse().     }     DataSet<Tuple2<String, Integer>> input = env.fromCollection(REDUCE_DATA).     DataSet<Tuple2<String, Integer>> result = input.groupBy(0).reduce(new ReduceFunction<Tuple2<String, Integer>>() {          @Override         public Tuple2<String, Integer> reduce(Tuple2<String, Integer> value1, Tuple2<String, Integer> value2) {             value2.f1 += value1.f1.             return value2.         }     }).     Tuple2<String, Integer> res = result.collect().get(0).     assertEquals(new Tuple2<>("a", 60), res). }
false;public;2;13;;@Override public Tuple2<String, Integer> reduce(Tuple2<String, Integer> value1, Tuple2<String, Integer> value2) {     if (value1.f1 % 3 == 0) {         value1.f1 += value2.f1.         return value1.     } else {         value2.f1 += value1.f1.         return value2.     } }
false;public;0;34;;@Test public void testGlobalReduce() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     if (objectReuse) {         env.getConfig().enableObjectReuse().     } else {         env.getConfig().disableObjectReuse().     }     DataSet<Tuple2<String, Integer>> input = env.fromCollection(REDUCE_DATA).     DataSet<Tuple2<String, Integer>> result = input.reduce(new ReduceFunction<Tuple2<String, Integer>>() {          @Override         public Tuple2<String, Integer> reduce(Tuple2<String, Integer> value1, Tuple2<String, Integer> value2) {             if (value1.f1 % 3 == 0) {                 value1.f1 += value2.f1.                 return value1.             } else {                 value2.f1 += value1.f1.                 return value2.             }         }     }).     Tuple2<String, Integer> res = result.collect().get(0).     assertEquals(new Tuple2<>("a", 60), res). }
false;public;2;11;;@Override public void reduce(Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) {     List<Tuple2<String, Integer>> list = new ArrayList<>().     for (Tuple2<String, Integer> val : values) {         list.add(val).     }     for (Tuple2<String, Integer> val : list) {         out.collect(val).     } }
false;public;0;39;;@Test public void testKeyedGroupReduce() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     if (objectReuse) {         env.getConfig().enableObjectReuse().     } else {         env.getConfig().disableObjectReuse().     }     DataSet<Tuple2<String, Integer>> input = env.fromCollection(GROUP_REDUCE_DATA).     DataSet<Tuple2<String, Integer>> result = input.groupBy(0).reduceGroup(new GroupReduceFunction<Tuple2<String, Integer>, Tuple2<String, Integer>>() {          @Override         public void reduce(Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) {             List<Tuple2<String, Integer>> list = new ArrayList<>().             for (Tuple2<String, Integer> val : values) {                 list.add(val).             }             for (Tuple2<String, Integer> val : list) {                 out.collect(val).             }         }     }).     List<Tuple2<String, Integer>> is = result.collect().     Collections.sort(is, new TupleComparator<Tuple2<String, Integer>>()).     List<Tuple2<String, Integer>> expected = env.getConfig().isObjectReuseEnabled() ? Arrays.asList(new Tuple2<>("a", 4), new Tuple2<>("a", 4), new Tuple2<>("a", 5), new Tuple2<>("a", 5), new Tuple2<>("a", 5)) : Arrays.asList(new Tuple2<>("a", 1), new Tuple2<>("a", 2), new Tuple2<>("a", 3), new Tuple2<>("a", 4), new Tuple2<>("a", 5)).     assertEquals(expected, is). }
false;public;2;11;;@Override public void reduce(Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) {     List<Tuple2<String, Integer>> list = new ArrayList<>().     for (Tuple2<String, Integer> val : values) {         list.add(val).     }     for (Tuple2<String, Integer> val : list) {         out.collect(val).     } }
false;public;0;39;;@Test public void testGlobalGroupReduce() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     if (objectReuse) {         env.getConfig().enableObjectReuse().     } else {         env.getConfig().disableObjectReuse().     }     DataSet<Tuple2<String, Integer>> input = env.fromCollection(GROUP_REDUCE_DATA).     DataSet<Tuple2<String, Integer>> result = input.reduceGroup(new GroupReduceFunction<Tuple2<String, Integer>, Tuple2<String, Integer>>() {          @Override         public void reduce(Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) {             List<Tuple2<String, Integer>> list = new ArrayList<>().             for (Tuple2<String, Integer> val : values) {                 list.add(val).             }             for (Tuple2<String, Integer> val : list) {                 out.collect(val).             }         }     }).     List<Tuple2<String, Integer>> is = result.collect().     Collections.sort(is, new TupleComparator<Tuple2<String, Integer>>()).     List<Tuple2<String, Integer>> expected = env.getConfig().isObjectReuseEnabled() ? Arrays.asList(new Tuple2<>("a", 4), new Tuple2<>("a", 4), new Tuple2<>("a", 5), new Tuple2<>("a", 5), new Tuple2<>("a", 5)) : Arrays.asList(new Tuple2<>("a", 1), new Tuple2<>("a", 2), new Tuple2<>("a", 3), new Tuple2<>("a", 4), new Tuple2<>("a", 5)).     assertEquals(expected, is). }
false;public,static;0;6;;@Parameterized.Parameters(name = "Execution mode = CLUSTER, Reuse = {0}") public static Collection<Object[]> executionModes() {     return Arrays.asList(new Object[] { false }, new Object[] { true }). }
