commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public void run(SourceContext<Integer> ctx) throws Exception {     ctx.collectWithTimestamp(1, 0).     ctx.emitWatermark(new Watermark(0)).     ctx.collectWithTimestamp(2, 1).     ctx.collectWithTimestamp(5, 2).     ctx.emitWatermark(new Watermark(2)).     ctx.collectWithTimestamp(3, 3).     ctx.collectWithTimestamp(4, 4). }
false;public;0;4;;@Override public void cancel() { }
false;public;3;6;;@Override public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {     out.collect(value).     ctx.output(sideOutputTag1, "sideout-" + String.valueOf(value)). }
false;public;1;4;;@Override public void processElement(StreamRecord<String> element) throws Exception {     output.collect(new StreamRecord<>("E:" + element.getValue())). }
false;public;1;5;;@Override public void processWatermark(Watermark mark) throws Exception {     super.processWatermark(mark).     output.collect(new StreamRecord<>("WM:" + mark.getTimestamp())). }
false;public;1;4;;@Override public String map(Integer value) throws Exception {     return value.toString(). }
true;public;0;107;/**  * Verify that watermarks are forwarded to all side outputs.  */ ;/**  * Verify that watermarks are forwarded to all side outputs.  */ @Test public void testWatermarkForwarding() throws Exception {     final OutputTag<String> sideOutputTag1 = new OutputTag<String>("side") {     }.     final OutputTag<String> sideOutputTag2 = new OutputTag<String>("other-side") {     }.     TestListResultSink<String> sideOutputResultSink1 = new TestListResultSink<>().     TestListResultSink<String> sideOutputResultSink2 = new TestListResultSink<>().     TestListResultSink<String> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     env.setParallelism(3).     DataStream<Integer> dataStream = env.addSource(new SourceFunction<Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void run(SourceContext<Integer> ctx) throws Exception {             ctx.collectWithTimestamp(1, 0).             ctx.emitWatermark(new Watermark(0)).             ctx.collectWithTimestamp(2, 1).             ctx.collectWithTimestamp(5, 2).             ctx.emitWatermark(new Watermark(2)).             ctx.collectWithTimestamp(3, 3).             ctx.collectWithTimestamp(4, 4).         }          @Override         public void cancel() {         }     }).     SingleOutputStreamOperator<Integer> passThroughtStream = dataStream.process(new ProcessFunction<Integer, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {             out.collect(value).             ctx.output(sideOutputTag1, "sideout-" + String.valueOf(value)).         }     }).     class WatermarkReifier extends AbstractStreamOperator<String> implements OneInputStreamOperator<String, String> {          private static final long serialVersionUID = 1L.          @Override         public void processElement(StreamRecord<String> element) throws Exception {             output.collect(new StreamRecord<>("E:" + element.getValue())).         }          @Override         public void processWatermark(Watermark mark) throws Exception {             super.processWatermark(mark).             output.collect(new StreamRecord<>("WM:" + mark.getTimestamp())).         }     }     passThroughtStream.getSideOutput(sideOutputTag1).transform("ReifyWatermarks", BasicTypeInfo.STRING_TYPE_INFO, new WatermarkReifier()).addSink(sideOutputResultSink1).     passThroughtStream.getSideOutput(sideOutputTag2).transform("ReifyWatermarks", BasicTypeInfo.STRING_TYPE_INFO, new WatermarkReifier()).addSink(sideOutputResultSink2).     passThroughtStream.map(new MapFunction<Integer, String>() {          private static final long serialVersionUID = 1L.          @Override         public String map(Integer value) throws Exception {             return value.toString().         }     }).transform("ReifyWatermarks", BasicTypeInfo.STRING_TYPE_INFO, new WatermarkReifier()).addSink(resultSink).     env.execute().     assertEquals(Arrays.asList("E:sideout-1", "E:sideout-2", "E:sideout-3", "E:sideout-4", "E:sideout-5", "WM:0", "WM:0", "WM:0", "WM:2", "WM:2", "WM:2", "WM:" + Long.MAX_VALUE, "WM:" + Long.MAX_VALUE, "WM:" + Long.MAX_VALUE), sideOutputResultSink1.getSortedResult()).     assertEquals(Arrays.asList("E:sideout-1", "E:sideout-2", "E:sideout-3", "E:sideout-4", "E:sideout-5", "WM:0", "WM:0", "WM:0", "WM:2", "WM:2", "WM:2", "WM:" + Long.MAX_VALUE, "WM:" + Long.MAX_VALUE, "WM:" + Long.MAX_VALUE), sideOutputResultSink1.getSortedResult()).     assertEquals(Arrays.asList("E:1", "E:2", "E:3", "E:4", "E:5", "WM:0", "WM:0", "WM:0", "WM:2", "WM:2", "WM:2", "WM:" + Long.MAX_VALUE, "WM:" + Long.MAX_VALUE, "WM:" + Long.MAX_VALUE), resultSink.getSortedResult()). }
false;public;3;6;;@Override public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {     out.collect(value).     ctx.output(sideOutputTag, "sideout-" + String.valueOf(value)). }
false;public;0;34;;@Test public void testSideOutputWithMultipleConsumers() throws Exception {     final OutputTag<String> sideOutputTag = new OutputTag<String>("side") {     }.     TestListResultSink<String> sideOutputResultSink1 = new TestListResultSink<>().     TestListResultSink<String> sideOutputResultSink2 = new TestListResultSink<>().     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(3).     DataStream<Integer> dataStream = env.fromCollection(elements).     SingleOutputStreamOperator<Integer> passThroughtStream = dataStream.process(new ProcessFunction<Integer, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {             out.collect(value).             ctx.output(sideOutputTag, "sideout-" + String.valueOf(value)).         }     }).     passThroughtStream.getSideOutput(sideOutputTag).addSink(sideOutputResultSink1).     passThroughtStream.getSideOutput(sideOutputTag).addSink(sideOutputResultSink2).     passThroughtStream.addSink(resultSink).     env.execute().     assertEquals(Arrays.asList("sideout-1", "sideout-2", "sideout-3", "sideout-4", "sideout-5"), sideOutputResultSink1.getSortedResult()).     assertEquals(Arrays.asList("sideout-1", "sideout-2", "sideout-3", "sideout-4", "sideout-5"), sideOutputResultSink2.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 3, 4, 5), resultSink.getSortedResult()). }
false;public;3;6;;@Override public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {     out.collect(value).     ctx.output(sideOutputTag, "sideout-" + String.valueOf(value)). }
false;public;0;35;;@Test public void testSideOutputWithMultipleConsumersWithObjectReuse() throws Exception {     final OutputTag<String> sideOutputTag = new OutputTag<String>("side") {     }.     TestListResultSink<String> sideOutputResultSink1 = new TestListResultSink<>().     TestListResultSink<String> sideOutputResultSink2 = new TestListResultSink<>().     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.getConfig().enableObjectReuse().     env.setParallelism(3).     DataStream<Integer> dataStream = env.fromCollection(elements).     SingleOutputStreamOperator<Integer> passThroughtStream = dataStream.process(new ProcessFunction<Integer, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {             out.collect(value).             ctx.output(sideOutputTag, "sideout-" + String.valueOf(value)).         }     }).     passThroughtStream.getSideOutput(sideOutputTag).addSink(sideOutputResultSink1).     passThroughtStream.getSideOutput(sideOutputTag).addSink(sideOutputResultSink2).     passThroughtStream.addSink(resultSink).     env.execute().     assertEquals(Arrays.asList("sideout-1", "sideout-2", "sideout-3", "sideout-4", "sideout-5"), sideOutputResultSink1.getSortedResult()).     assertEquals(Arrays.asList("sideout-1", "sideout-2", "sideout-3", "sideout-4", "sideout-5"), sideOutputResultSink2.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 3, 4, 5), resultSink.getSortedResult()). }
false;public;3;7;;@Override public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {     out.collect(value).     ctx.output(sideOutputTag1, "sideout-" + String.valueOf(value)).     ctx.output(sideOutputTag2, 13). }
false;public;0;37;;@Test public void testDifferentSideOutputTypes() throws Exception {     final OutputTag<String> sideOutputTag1 = new OutputTag<String>("string") {     }.     final OutputTag<Integer> sideOutputTag2 = new OutputTag<Integer>("int") {     }.     TestListResultSink<String> sideOutputResultSink1 = new TestListResultSink<>().     TestListResultSink<Integer> sideOutputResultSink2 = new TestListResultSink<>().     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.getConfig().enableObjectReuse().     env.setParallelism(3).     DataStream<Integer> dataStream = env.fromCollection(elements).     SingleOutputStreamOperator<Integer> passThroughtStream = dataStream.process(new ProcessFunction<Integer, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {             out.collect(value).             ctx.output(sideOutputTag1, "sideout-" + String.valueOf(value)).             ctx.output(sideOutputTag2, 13).         }     }).     passThroughtStream.getSideOutput(sideOutputTag1).addSink(sideOutputResultSink1).     passThroughtStream.getSideOutput(sideOutputTag2).addSink(sideOutputResultSink2).     passThroughtStream.addSink(resultSink).     env.execute().     assertEquals(Arrays.asList("sideout-1", "sideout-2", "sideout-3", "sideout-4", "sideout-5"), sideOutputResultSink1.getSortedResult()).     assertEquals(Arrays.asList(13, 13, 13, 13, 13), sideOutputResultSink2.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 3, 4, 5), resultSink.getSortedResult()). }
false;public;3;7;;@Override public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {     out.collect(value).     ctx.output(sideOutputTag1, "sideout-" + String.valueOf(value)).     ctx.output(sideOutputTag2, 13). }
false;public;0;31;;@Test public void testSideOutputNameClash() throws Exception {     final OutputTag<String> sideOutputTag1 = new OutputTag<String>("side") {     }.     final OutputTag<Integer> sideOutputTag2 = new OutputTag<Integer>("side") {     }.     TestListResultSink<String> sideOutputResultSink1 = new TestListResultSink<>().     TestListResultSink<Integer> sideOutputResultSink2 = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(3).     DataStream<Integer> dataStream = see.fromCollection(elements).     SingleOutputStreamOperator<Integer> passThroughtStream = dataStream.process(new ProcessFunction<Integer, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {             out.collect(value).             ctx.output(sideOutputTag1, "sideout-" + String.valueOf(value)).             ctx.output(sideOutputTag2, 13).         }     }).     passThroughtStream.getSideOutput(sideOutputTag1).addSink(sideOutputResultSink1).     expectedException.expect(UnsupportedOperationException.class).     passThroughtStream.getSideOutput(sideOutputTag2).addSink(sideOutputResultSink2). }
false;public;3;6;;@Override public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {     out.collect(value).     ctx.output(sideOutputTag, "sideout-" + String.valueOf(value)). }
true;public;0;31;/**  * Test ProcessFunction side output.  */ ;/**  * Test ProcessFunction side output.  */ @Test public void testProcessFunctionSideOutput() throws Exception {     final OutputTag<String> sideOutputTag = new OutputTag<String>("side") {     }.     TestListResultSink<String> sideOutputResultSink = new TestListResultSink<>().     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(3).     DataStream<Integer> dataStream = see.fromCollection(elements).     SingleOutputStreamOperator<Integer> passThroughtStream = dataStream.process(new ProcessFunction<Integer, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {             out.collect(value).             ctx.output(sideOutputTag, "sideout-" + String.valueOf(value)).         }     }).     passThroughtStream.getSideOutput(sideOutputTag).addSink(sideOutputResultSink).     passThroughtStream.addSink(resultSink).     see.execute().     assertEquals(Arrays.asList("sideout-1", "sideout-2", "sideout-3", "sideout-4", "sideout-5"), sideOutputResultSink.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 3, 4, 5), resultSink.getSortedResult()). }
false;public;3;7;;@Override public void processElement1(Integer value, Context ctx, Collector<Integer> out) throws Exception {     if (value < 3) {         out.collect(value).         ctx.output(sideOutputTag, "sideout1-" + String.valueOf(value)).     } }
false;public;3;7;;@Override public void processElement2(Integer value, Context ctx, Collector<Integer> out) throws Exception {     if (value >= 3) {         out.collect(value).         ctx.output(sideOutputTag, "sideout2-" + String.valueOf(value)).     } }
true;public;0;40;/**  * Test CoProcessFunction side output.  */ ;/**  * Test CoProcessFunction side output.  */ @Test public void testCoProcessFunctionSideOutput() throws Exception {     final OutputTag<String> sideOutputTag = new OutputTag<String>("side") {     }.     TestListResultSink<String> sideOutputResultSink = new TestListResultSink<>().     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(3).     DataStream<Integer> ds1 = see.fromCollection(elements).     DataStream<Integer> ds2 = see.fromCollection(elements).     SingleOutputStreamOperator<Integer> passThroughtStream = ds1.connect(ds2).process(new CoProcessFunction<Integer, Integer, Integer>() {          @Override         public void processElement1(Integer value, Context ctx, Collector<Integer> out) throws Exception {             if (value < 3) {                 out.collect(value).                 ctx.output(sideOutputTag, "sideout1-" + String.valueOf(value)).             }         }          @Override         public void processElement2(Integer value, Context ctx, Collector<Integer> out) throws Exception {             if (value >= 3) {                 out.collect(value).                 ctx.output(sideOutputTag, "sideout2-" + String.valueOf(value)).             }         }     }).     passThroughtStream.getSideOutput(sideOutputTag).addSink(sideOutputResultSink).     passThroughtStream.addSink(resultSink).     see.execute().     assertEquals(Arrays.asList("sideout1-1", "sideout1-2", "sideout2-3", "sideout2-4", "sideout2-5"), sideOutputResultSink.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 3, 4, 5), resultSink.getSortedResult()). }
false;public;3;7;;@Override public void processElement1(Integer value, Context ctx, Collector<Integer> out) throws Exception {     if (value < 4) {         out.collect(value).         ctx.output(sideOutputTag1, "sideout1-" + String.valueOf(value)).     } }
false;public;3;7;;@Override public void processElement2(Integer value, Context ctx, Collector<Integer> out) throws Exception {     if (value >= 4) {         out.collect(value).         ctx.output(sideOutputTag2, "sideout2-" + String.valueOf(value)).     } }
true;public;0;44;/**  * Test CoProcessFunction side output with multiple consumers.  */ ;/**  * Test CoProcessFunction side output with multiple consumers.  */ @Test public void testCoProcessFunctionSideOutputWithMultipleConsumers() throws Exception {     final OutputTag<String> sideOutputTag1 = new OutputTag<String>("side1") {     }.     final OutputTag<String> sideOutputTag2 = new OutputTag<String>("side2") {     }.     TestListResultSink<String> sideOutputResultSink1 = new TestListResultSink<>().     TestListResultSink<String> sideOutputResultSink2 = new TestListResultSink<>().     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(3).     DataStream<Integer> ds1 = see.fromCollection(elements).     DataStream<Integer> ds2 = see.fromCollection(elements).     SingleOutputStreamOperator<Integer> passThroughtStream = ds1.connect(ds2).process(new CoProcessFunction<Integer, Integer, Integer>() {          @Override         public void processElement1(Integer value, Context ctx, Collector<Integer> out) throws Exception {             if (value < 4) {                 out.collect(value).                 ctx.output(sideOutputTag1, "sideout1-" + String.valueOf(value)).             }         }          @Override         public void processElement2(Integer value, Context ctx, Collector<Integer> out) throws Exception {             if (value >= 4) {                 out.collect(value).                 ctx.output(sideOutputTag2, "sideout2-" + String.valueOf(value)).             }         }     }).     passThroughtStream.getSideOutput(sideOutputTag1).addSink(sideOutputResultSink1).     passThroughtStream.getSideOutput(sideOutputTag2).addSink(sideOutputResultSink2).     passThroughtStream.addSink(resultSink).     see.execute().     assertEquals(Arrays.asList("sideout1-1", "sideout1-2", "sideout1-3"), sideOutputResultSink1.getSortedResult()).     assertEquals(Arrays.asList("sideout2-4", "sideout2-5"), sideOutputResultSink2.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 3, 4, 5), resultSink.getSortedResult()). }
false;public;3;6;;@Override public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {     out.collect(value).     ctx.output(sideOutputTag, "sideout-" + String.valueOf(value)). }
false;public;1;4;;@Override public Integer getKey(Integer value) throws Exception {     return value. }
true;public;0;39;/**  * Test keyed ProcessFunction side output.  */ ;/**  * Test keyed ProcessFunction side output.  */ @Test public void testKeyedProcessFunctionSideOutput() throws Exception {     final OutputTag<String> sideOutputTag = new OutputTag<String>("side") {     }.     TestListResultSink<String> sideOutputResultSink = new TestListResultSink<>().     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(3).     DataStream<Integer> dataStream = see.fromCollection(elements).     SingleOutputStreamOperator<Integer> passThroughtStream = dataStream.keyBy(new KeySelector<Integer, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public Integer getKey(Integer value) throws Exception {             return value.         }     }).process(new ProcessFunction<Integer, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {             out.collect(value).             ctx.output(sideOutputTag, "sideout-" + String.valueOf(value)).         }     }).     passThroughtStream.getSideOutput(sideOutputTag).addSink(sideOutputResultSink).     passThroughtStream.addSink(resultSink).     see.execute().     assertEquals(Arrays.asList("sideout-1", "sideout-2", "sideout-3", "sideout-4", "sideout-5"), sideOutputResultSink.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 3, 4, 5), resultSink.getSortedResult()). }
false;public;3;7;;@Override public void processElement1(Integer value, Context ctx, Collector<Integer> out) throws Exception {     if (value < 3) {         out.collect(value).         ctx.output(sideOutputTag, "sideout1-" + String.valueOf(value)).     } }
false;public;3;7;;@Override public void processElement2(Integer value, Context ctx, Collector<Integer> out) throws Exception {     if (value >= 3) {         out.collect(value).         ctx.output(sideOutputTag, "sideout2-" + String.valueOf(value)).     } }
true;public;0;41;/**  * Test keyed CoProcessFunction side output.  */ ;/**  * Test keyed CoProcessFunction side output.  */ @Test public void testKeyedCoProcessFunctionSideOutput() throws Exception {     final OutputTag<String> sideOutputTag = new OutputTag<String>("side") {     }.     TestListResultSink<String> sideOutputResultSink = new TestListResultSink<>().     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(3).     DataStream<Integer> ds1 = see.fromCollection(elements).     DataStream<Integer> ds2 = see.fromCollection(elements).     SingleOutputStreamOperator<Integer> passThroughtStream = ds1.keyBy(i -> i).connect(ds2.keyBy(i -> i)).process(new CoProcessFunction<Integer, Integer, Integer>() {          @Override         public void processElement1(Integer value, Context ctx, Collector<Integer> out) throws Exception {             if (value < 3) {                 out.collect(value).                 ctx.output(sideOutputTag, "sideout1-" + String.valueOf(value)).             }         }          @Override         public void processElement2(Integer value, Context ctx, Collector<Integer> out) throws Exception {             if (value >= 3) {                 out.collect(value).                 ctx.output(sideOutputTag, "sideout2-" + String.valueOf(value)).             }         }     }).     passThroughtStream.getSideOutput(sideOutputTag).addSink(sideOutputResultSink).     passThroughtStream.addSink(resultSink).     see.execute().     assertEquals(Arrays.asList("sideout1-1", "sideout1-2", "sideout2-3", "sideout2-4", "sideout2-5"), sideOutputResultSink.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 3, 4, 5), resultSink.getSortedResult()). }
false;public;3;7;;@Override public void processElement1(Integer value, Context ctx, Collector<Integer> out) throws Exception {     if (value < 4) {         out.collect(value).         ctx.output(sideOutputTag1, "sideout1-" + String.valueOf(value)).     } }
false;public;3;7;;@Override public void processElement2(Integer value, Context ctx, Collector<Integer> out) throws Exception {     if (value >= 4) {         out.collect(value).         ctx.output(sideOutputTag2, "sideout2-" + String.valueOf(value)).     } }
true;public;0;45;/**  * Test keyed CoProcessFunction side output with multiple consumers.  */ ;/**  * Test keyed CoProcessFunction side output with multiple consumers.  */ @Test public void testKeyedCoProcessFunctionSideOutputWithMultipleConsumers() throws Exception {     final OutputTag<String> sideOutputTag1 = new OutputTag<String>("side1") {     }.     final OutputTag<String> sideOutputTag2 = new OutputTag<String>("side2") {     }.     TestListResultSink<String> sideOutputResultSink1 = new TestListResultSink<>().     TestListResultSink<String> sideOutputResultSink2 = new TestListResultSink<>().     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(3).     DataStream<Integer> ds1 = see.fromCollection(elements).     DataStream<Integer> ds2 = see.fromCollection(elements).     SingleOutputStreamOperator<Integer> passThroughtStream = ds1.keyBy(i -> i).connect(ds2.keyBy(i -> i)).process(new CoProcessFunction<Integer, Integer, Integer>() {          @Override         public void processElement1(Integer value, Context ctx, Collector<Integer> out) throws Exception {             if (value < 4) {                 out.collect(value).                 ctx.output(sideOutputTag1, "sideout1-" + String.valueOf(value)).             }         }          @Override         public void processElement2(Integer value, Context ctx, Collector<Integer> out) throws Exception {             if (value >= 4) {                 out.collect(value).                 ctx.output(sideOutputTag2, "sideout2-" + String.valueOf(value)).             }         }     }).     passThroughtStream.getSideOutput(sideOutputTag1).addSink(sideOutputResultSink1).     passThroughtStream.getSideOutput(sideOutputTag2).addSink(sideOutputResultSink2).     passThroughtStream.addSink(resultSink).     see.execute().     assertEquals(Arrays.asList("sideout1-1", "sideout1-2", "sideout1-3"), sideOutputResultSink1.getSortedResult()).     assertEquals(Arrays.asList("sideout2-4", "sideout2-5"), sideOutputResultSink2.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 3, 4, 5), resultSink.getSortedResult()). }
false;public;3;6;;@Override public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {     out.collect(value).     ctx.output(sideOutputTag2, "sideout-" + String.valueOf(value)). }
true;public;0;28;/**  * Test ProcessFunction side outputs with wrong {@code OutputTag}.  */ ;/**  * Test ProcessFunction side outputs with wrong {@code OutputTag}.  */ @Test public void testProcessFunctionSideOutputWithWrongTag() throws Exception {     final OutputTag<String> sideOutputTag1 = new OutputTag<String>("side") {     }.     final OutputTag<String> sideOutputTag2 = new OutputTag<String>("other-side") {     }.     TestListResultSink<String> sideOutputResultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(3).     DataStream<Integer> dataStream = see.fromCollection(elements).     dataStream.process(new ProcessFunction<Integer, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public void processElement(Integer value, Context ctx, Collector<Integer> out) throws Exception {             out.collect(value).             ctx.output(sideOutputTag2, "sideout-" + String.valueOf(value)).         }     }).getSideOutput(sideOutputTag1).addSink(sideOutputResultSink).     see.execute().     assertEquals(Arrays.asList(), sideOutputResultSink.getSortedResult()). }
false;public;2;5;;@Nullable @Override public Watermark checkAndGetNextWatermark(Integer lastElement, long extractedTimestamp) {     return new Watermark(extractedTimestamp). }
false;public;2;4;;@Override public long extractTimestamp(Integer element, long previousElementTimestamp) {     return Long.valueOf(element). }
false;public;1;4;;@Override public Integer getKey(Integer value) throws Exception {     return value. }
false;public;3;6;;@Override public void apply(TimeWindow window, Iterable<Integer> values, Collector<Integer> out) throws Exception {     for (Integer val : values) {         out.collect(val).     } }
false;public;2;4;;@Override public void flatMap(Integer value, Collector<String> out) throws Exception {     out.collect("late-" + String.valueOf(value)). }
true;public;0;43;/**  * Test window late arriving events stream.  */ ;/**  * Test window late arriving events stream.  */ @Test public void testAllWindowLateArrivingEvents() throws Exception {     TestListResultSink<String> sideOutputResultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(1).     see.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     DataStream<Integer> dataStream = see.fromCollection(elements).     OutputTag<Integer> lateDataTag = new OutputTag<Integer>("late") {     }.     SingleOutputStreamOperator<Integer> windowOperator = dataStream.assignTimestampsAndWatermarks(new TestWatermarkAssigner()).timeWindowAll(Time.milliseconds(1), Time.milliseconds(1)).sideOutputLateData(lateDataTag).apply(new AllWindowFunction<Integer, Integer, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(TimeWindow window, Iterable<Integer> values, Collector<Integer> out) throws Exception {             for (Integer val : values) {                 out.collect(val).             }         }     }).     windowOperator.getSideOutput(lateDataTag).flatMap(new FlatMapFunction<Integer, String>() {          private static final long serialVersionUID = 1L.          @Override         public void flatMap(Integer value, Collector<String> out) throws Exception {             out.collect("late-" + String.valueOf(value)).         }     }).addSink(sideOutputResultSink).     see.execute().     assertEquals(sideOutputResultSink.getSortedResult(), Arrays.asList("late-3", "late-4")). }
false;public;4;6;;@Override public void apply(Integer key, TimeWindow window, Iterable<Integer> input, Collector<String> out) throws Exception {     for (Integer val : input) {         out.collect(String.valueOf(key) + "-" + String.valueOf(val)).     } }
false;public;0;41;;@Test public void testKeyedWindowLateArrivingEvents() throws Exception {     TestListResultSink<String> resultSink = new TestListResultSink<>().     TestListResultSink<Integer> lateResultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(3).     see.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     DataStream<Integer> dataStream = see.fromCollection(elements).     OutputTag<Integer> lateDataTag = new OutputTag<Integer>("late") {     }.     SingleOutputStreamOperator<String> windowOperator = dataStream.assignTimestampsAndWatermarks(new TestWatermarkAssigner()).keyBy(new TestKeySelector()).timeWindow(Time.milliseconds(1), Time.milliseconds(1)).allowedLateness(Time.milliseconds(2)).sideOutputLateData(lateDataTag).apply(new WindowFunction<Integer, String, Integer, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void apply(Integer key, TimeWindow window, Iterable<Integer> input, Collector<String> out) throws Exception {             for (Integer val : input) {                 out.collect(String.valueOf(key) + "-" + String.valueOf(val)).             }         }     }).     windowOperator.addSink(resultSink).     windowOperator.getSideOutput(lateDataTag).addSink(lateResultSink).     see.execute().     assertEquals(Arrays.asList("1-1", "2-2", "4-4", "5-5"), resultSink.getSortedResult()).     assertEquals(Collections.singletonList(3), lateResultSink.getSortedResult()). }
false;public;4;5;;@Override public void process(Integer integer, Context context, Iterable<Integer> elements, Collector<Integer> out) throws Exception {     out.collect(integer).     context.output(sideOutputTag, "sideout-" + String.valueOf(integer)). }
false;public;0;34;;@Test public void testProcessdWindowFunctionSideOutput() throws Exception {     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     TestListResultSink<String> sideOutputResultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(3).     see.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     DataStream<Integer> dataStream = see.fromCollection(elements).     OutputTag<String> sideOutputTag = new OutputTag<String>("side") {     }.     SingleOutputStreamOperator<Integer> windowOperator = dataStream.assignTimestampsAndWatermarks(new TestWatermarkAssigner()).keyBy(new TestKeySelector()).timeWindow(Time.milliseconds(1), Time.milliseconds(1)).process(new ProcessWindowFunction<Integer, Integer, Integer, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void process(Integer integer, Context context, Iterable<Integer> elements, Collector<Integer> out) throws Exception {             out.collect(integer).             context.output(sideOutputTag, "sideout-" + String.valueOf(integer)).         }     }).     windowOperator.getSideOutput(sideOutputTag).addSink(sideOutputResultSink).     windowOperator.addSink(resultSink).     see.execute().     assertEquals(Arrays.asList("sideout-1", "sideout-2", "sideout-5"), sideOutputResultSink.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 5), resultSink.getSortedResult()). }
false;public;3;7;;@Override public void process(Context context, Iterable<Integer> elements, Collector<Integer> out) throws Exception {     for (Integer e : elements) {         out.collect(e).         context.output(sideOutputTag, "sideout-" + String.valueOf(e)).     } }
false;public;0;35;;@Test public void testProcessAllWindowFunctionSideOutput() throws Exception {     TestListResultSink<Integer> resultSink = new TestListResultSink<>().     TestListResultSink<String> sideOutputResultSink = new TestListResultSink<>().     StreamExecutionEnvironment see = StreamExecutionEnvironment.getExecutionEnvironment().     see.setParallelism(1).     see.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     DataStream<Integer> dataStream = see.fromCollection(elements).     OutputTag<String> sideOutputTag = new OutputTag<String>("side") {     }.     SingleOutputStreamOperator<Integer> windowOperator = dataStream.assignTimestampsAndWatermarks(new TestWatermarkAssigner()).timeWindowAll(Time.milliseconds(1), Time.milliseconds(1)).process(new ProcessAllWindowFunction<Integer, Integer, TimeWindow>() {          private static final long serialVersionUID = 1L.          @Override         public void process(Context context, Iterable<Integer> elements, Collector<Integer> out) throws Exception {             for (Integer e : elements) {                 out.collect(e).                 context.output(sideOutputTag, "sideout-" + String.valueOf(e)).             }         }     }).     windowOperator.getSideOutput(sideOutputTag).addSink(sideOutputResultSink).     windowOperator.addSink(resultSink).     see.execute().     assertEquals(Arrays.asList("sideout-1", "sideout-2", "sideout-5"), sideOutputResultSink.getSortedResult()).     assertEquals(Arrays.asList(1, 2, 5), resultSink.getSortedResult()). }
