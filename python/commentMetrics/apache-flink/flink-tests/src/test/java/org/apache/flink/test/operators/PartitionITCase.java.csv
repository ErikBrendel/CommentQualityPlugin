commented;modifiers;parameterAmount;loc;comment;code
false;public;0;23;;@Test public void testHashPartitionByKeyField() throws Exception {     /* 		 * Test hash partition by key field 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Long> uniqLongs = ds.partitionByHash(1).mapPartition(new UniqueTupleLongMapper()).     List<Long> result = uniqLongs.collect().     String expected = "1\n" + "2\n" + "3\n" + "4\n" + "5\n" + "6\n".     compareResultAsText(result, expected). }
false;public;0;23;;@Test public void testRangePartitionByKeyField() throws Exception {     /* 		 * Test range partition by key field 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Long> uniqLongs = ds.partitionByRange(1).mapPartition(new UniqueTupleLongMapper()).     List<Long> result = uniqLongs.collect().     String expected = "1\n" + "2\n" + "3\n" + "4\n" + "5\n" + "6\n".     compareResultAsText(result, expected). }
false;public;0;28;;@Test public void testHashPartitionByKeyField2() throws Exception {     /* 		 * Test hash partition by key field 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     AggregateOperator<Tuple3<Integer, Long, String>> sum = ds.map(new PrefixMapper()).partitionByHash(1, 2).groupBy(1, 2).sum(0).     List<Tuple3<Integer, Long, String>> result = sum.collect().     String expected = "(1,1,Hi)\n" + "(5,2,Hello)\n" + "(4,3,Hello)\n" + "(5,3,I am )\n" + "(6,3,Luke )\n" + "(34,4,Comme)\n" + "(65,5,Comme)\n" + "(111,6,Comme)".     compareResultAsText(result, expected). }
false;public;0;28;;@Test public void testRangePartitionByKeyField2() throws Exception {     /* 		 * Test range partition by key field 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     AggregateOperator<Tuple3<Integer, Long, String>> sum = ds.map(new PrefixMapper()).partitionByRange(1, 2).groupBy(1, 2).sum(0).     List<Tuple3<Integer, Long, String>> result = sum.collect().     String expected = "(1,1,Hi)\n" + "(5,2,Hello)\n" + "(4,3,Hello)\n" + "(5,3,I am )\n" + "(6,3,Luke )\n" + "(34,4,Comme)\n" + "(65,5,Comme)\n" + "(111,6,Comme)".     compareResultAsText(result, expected). }
false;public;0;24;;@Test public void testHashPartitionOfAtomicType() throws Exception {     /* 		 * Test hash partition of atomic type 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Long> uniqLongs = env.generateSequence(1, 6).union(env.generateSequence(1, 6)).rebalance().partitionByHash("*").mapPartition(new UniqueLongMapper()).     List<Long> result = uniqLongs.collect().     String expected = "1\n" + "2\n" + "3\n" + "4\n" + "5\n" + "6\n".     compareResultAsText(result, expected). }
false;public;0;24;;@Test public void testRangePartitionOfAtomicType() throws Exception {     /* 		 * Test range partition of atomic type 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Long> uniqLongs = env.generateSequence(1, 6).union(env.generateSequence(1, 6)).rebalance().partitionByRange("*").mapPartition(new UniqueLongMapper()).     List<Long> result = uniqLongs.collect().     String expected = "1\n" + "2\n" + "3\n" + "4\n" + "5\n" + "6\n".     compareResultAsText(result, expected). }
false;public;0;23;;@Test public void testHashPartitionByKeySelector() throws Exception {     /* 		 * Test hash partition by key selector 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Long> uniqLongs = ds.partitionByHash(new KeySelector1()).mapPartition(new UniqueTupleLongMapper()).     List<Long> result = uniqLongs.collect().     String expected = "1\n" + "2\n" + "3\n" + "4\n" + "5\n" + "6\n".     compareResultAsText(result, expected). }
false;public;1;7;;@Override public Tuple3<Integer, Long, String> map(Tuple3<Integer, Long, String> value) throws Exception {     if (value.f2.length() > 5) {         value.f2 = value.f2.substring(0, 5).     }     return value. }
false;public;0;23;;@Test public void testRangePartitionByKeySelector() throws Exception {     /* 		 * Test range partition by key selector 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Long> uniqLongs = ds.partitionByRange(new KeySelector1()).mapPartition(new UniqueTupleLongMapper()).     List<Long> result = uniqLongs.collect().     String expected = "1\n" + "2\n" + "3\n" + "4\n" + "5\n" + "6\n".     compareResultAsText(result, expected). }
false;public;1;4;;@Override public Long getKey(Tuple3<Integer, Long, String> value) throws Exception {     return value.f1. }
false;public;0;33;;@Test public void testForcedRebalancing() throws Exception {     /* 		 * Test forced rebalancing 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     // generate some number in parallel     DataSet<Long> ds = env.generateSequence(1, 3000).     DataSet<Tuple2<Integer, Integer>> uniqLongs = ds.filter(new Filter1()).rebalance().map(new PartitionIndexMapper()).groupBy(0).reduce(new Reducer1()).map(new Mapper1()).     List<Tuple2<Integer, Integer>> result = uniqLongs.collect().     StringBuilder expected = new StringBuilder().     int numPerPartition = 2220 / env.getParallelism() / 10.     for (int i = 0. i < env.getParallelism(). i++) {         expected.append('(').append(i).append(',').append(numPerPartition).append(")\n").     }     compareResultAsText(result, expected.toString()). }
false;public;1;4;;@Override public boolean filter(Long value) throws Exception {     return value > 780. }
false;public;2;4;;@Override public Tuple2<Integer, Integer> reduce(Tuple2<Integer, Integer> v1, Tuple2<Integer, Integer> v2) {     return new Tuple2<>(v1.f0, v1.f1 + v2.f1). }
false;public;1;5;;@Override public Tuple2<Integer, Integer> map(Tuple2<Integer, Integer> value) throws Exception {     value.f1 = (value.f1 / 10).     return value. }
false;public;0;24;;@Test public void testHashPartitionByKeyFieldAndDifferentParallelism() throws Exception {     /* 		 * Test hash partition by key field and different parallelism 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(3).     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Long> uniqLongs = ds.partitionByHash(1).setParallelism(4).mapPartition(new UniqueTupleLongMapper()).     List<Long> result = uniqLongs.collect().     String expected = "1\n" + "2\n" + "3\n" + "4\n" + "5\n" + "6\n".     compareResultAsText(result, expected). }
false;public;0;24;;@Test public void testRangePartitionByKeyFieldAndDifferentParallelism() throws Exception {     /* 		 * Test range partition by key field and different parallelism 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(3).     DataSet<Tuple3<Integer, Long, String>> ds = CollectionDataSets.get3TupleDataSet(env).     DataSet<Long> uniqLongs = ds.partitionByRange(1).setParallelism(4).mapPartition(new UniqueTupleLongMapper()).     List<Long> result = uniqLongs.collect().     String expected = "1\n" + "2\n" + "3\n" + "4\n" + "5\n" + "6\n".     compareResultAsText(result, expected). }
false;public;0;21;;@Test public void testHashPartitionWithKeyExpression() throws Exception {     /* 		 * Test hash partition with key expression 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(3).     DataSet<POJO> ds = CollectionDataSets.getDuplicatePojoDataSet(env).     DataSet<Long> uniqLongs = ds.partitionByHash("nestedPojo.longNumber").setParallelism(4).mapPartition(new UniqueNestedPojoLongMapper()).     List<Long> result = uniqLongs.collect().     String expected = "10000\n" + "20000\n" + "30000\n".     compareResultAsText(result, expected). }
false;public;0;21;;@Test public void testRangePartitionWithKeyExpression() throws Exception {     /* 		 * Test range partition with key expression 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(3).     DataSet<POJO> ds = CollectionDataSets.getDuplicatePojoDataSet(env).     DataSet<Long> uniqLongs = ds.partitionByRange("nestedPojo.longNumber").setParallelism(4).mapPartition(new UniqueNestedPojoLongMapper()).     List<Long> result = uniqLongs.collect().     String expected = "10000\n" + "20000\n" + "30000\n".     compareResultAsText(result, expected). }
false;public;2;10;;@Override public void mapPartition(Iterable<Tuple3<Integer, Long, String>> records, Collector<Long> out) throws Exception {     HashSet<Long> uniq = new HashSet<>().     for (Tuple3<Integer, Long, String> t : records) {         uniq.add(t.f1).     }     for (Long l : uniq) {         out.collect(l).     } }
false;public;2;10;;@Override public void mapPartition(Iterable<Long> longs, Collector<Long> out) throws Exception {     HashSet<Long> uniq = new HashSet<>().     for (Long l : longs) {         uniq.add(l).     }     for (Long l : uniq) {         out.collect(l).     } }
false;public;2;10;;@Override public void mapPartition(Iterable<POJO> records, Collector<Long> out) throws Exception {     HashSet<Long> uniq = new HashSet<>().     for (POJO t : records) {         uniq.add(t.nestedPojo.longNumber).     }     for (Long l : uniq) {         out.collect(l).     } }
false;public;1;4;;@Override public Tuple2<Integer, Integer> map(Long value) throws Exception {     return new Tuple2<>(this.getRuntimeContext().getIndexOfThisSubtask(), 1). }
false;public;0;25;;@Test public void testRangePartitionerOnSequenceData() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSource<Long> dataSource = env.generateSequence(0, 10000).     KeySelector<Long, Long> keyExtractor = new ObjectSelfKeySelector().     MapPartitionFunction<Long, Tuple2<Long, Long>> minMaxSelector = new MinMaxSelector<>(new LongComparator(true)).     Comparator<Tuple2<Long, Long>> tuple2Comparator = new Tuple2Comparator(new LongComparator(true)).     List<Tuple2<Long, Long>> collected = dataSource.partitionByRange(keyExtractor).mapPartition(minMaxSelector).collect().     Collections.sort(collected, tuple2Comparator).     long previousMax = -1.     for (Tuple2<Long, Long> tuple2 : collected) {         if (previousMax == -1) {             previousMax = tuple2.f1.         } else {             long currentMin = tuple2.f0.             assertTrue(tuple2.f0 < tuple2.f1).             assertEquals(previousMax + 1, currentMin).             previousMax = tuple2.f1.         }     } }
false;public;1;4;;@Override public Tuple2<Long, String> map(Long v) throws Exception {     return new Tuple2<>(v, Long.toString(v)). }
false;public;0;27;;@Test(expected = InvalidProgramException.class) public void testRangePartitionInIteration() throws Exception {     // does not apply for collection execution     if (super.mode == TestExecutionMode.COLLECTION) {         throw new InvalidProgramException("Does not apply for collection execution").     }     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSource<Long> source = env.generateSequence(0, 10000).     DataSet<Tuple2<Long, String>> tuples = source.map(new MapFunction<Long, Tuple2<Long, String>>() {          @Override         public Tuple2<Long, String> map(Long v) throws Exception {             return new Tuple2<>(v, Long.toString(v)).         }     }).     DeltaIteration<Tuple2<Long, String>, Tuple2<Long, String>> it = tuples.iterateDelta(tuples, 10, 0).     DataSet<Tuple2<Long, String>> body = it.getWorkset().partitionByRange(// Verify that range partition is not allowed in iteration     1).join(it.getSolutionSet()).where(0).equalTo(0).projectFirst(0).projectSecond(1).     DataSet<Tuple2<Long, String>> result = it.closeWith(body, body).     // should fail     result.collect(). }
false;public;1;4;;@Override public Tuple2<Long, Long> map(Long value) throws Exception {     return new Tuple2<>(value / 5000, value % 5000). }
false;public;0;41;;@Test public void testRangePartitionerOnSequenceDataWithOrders() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple2<Long, Long>> dataSet = env.generateSequence(0, 10000).map(new MapFunction<Long, Tuple2<Long, Long>>() {          @Override         public Tuple2<Long, Long> map(Long value) throws Exception {             return new Tuple2<>(value / 5000, value % 5000).         }     }).     final Tuple2Comparator<Long> tuple2Comparator = new Tuple2Comparator<>(new LongComparator(true), new LongComparator(false)).     MinMaxSelector<Tuple2<Long, Long>> minMaxSelector = new MinMaxSelector<>(tuple2Comparator).     final List<Tuple2<Tuple2<Long, Long>, Tuple2<Long, Long>>> collected = dataSet.partitionByRange(0, 1).withOrders(Order.ASCENDING, Order.DESCENDING).mapPartition(minMaxSelector).collect().     Collections.sort(collected, new Tuple2Comparator<>(tuple2Comparator)).     Tuple2<Long, Long> previousMax = null.     for (Tuple2<Tuple2<Long, Long>, Tuple2<Long, Long>> tuple2 : collected) {         assertTrue("Min element in each partition should be smaller than max.", tuple2Comparator.compare(tuple2.f0, tuple2.f1) <= 0).         if (previousMax == null) {             previousMax = tuple2.f1.         } else {             assertTrue("Partitions overlap. Previous max should be smaller than current min.", tuple2Comparator.compare(previousMax, tuple2.f0) < 0).             if (previousMax.f0.equals(tuple2.f0.f0)) {                 // check that ordering on the second key is correct                 assertEquals("Ordering on the second field should be continous.", previousMax.f1 - 1, tuple2.f0.f1.longValue()).             }             previousMax = tuple2.f1.         }     } }
false;public;1;4;;@Override public Tuple2<Tuple2<Long, Long>, Long> map(Long value) throws Exception {     return new Tuple2<>(new Tuple2<>(value / 5000, value % 5000), value). }
false;public;2;7;;@Override public void mapPartition(Iterable<Tuple2<Tuple2<Long, Long>, Long>> values, Collector<Tuple2<Long, Long>> out) throws Exception {     for (Tuple2<Tuple2<Long, Long>, Long> value : values) {         out.collect(value.f0).     } }
false;public;0;48;;@Test public void testRangePartitionerOnSequenceNestedDataWithOrders() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     final DataSet<Tuple2<Tuple2<Long, Long>, Long>> dataSet = env.generateSequence(0, 10000).map(new MapFunction<Long, Tuple2<Tuple2<Long, Long>, Long>>() {          @Override         public Tuple2<Tuple2<Long, Long>, Long> map(Long value) throws Exception {             return new Tuple2<>(new Tuple2<>(value / 5000, value % 5000), value).         }     }).     final Tuple2Comparator<Long> tuple2Comparator = new Tuple2Comparator<>(new LongComparator(true), new LongComparator(true)).     MinMaxSelector<Tuple2<Long, Long>> minMaxSelector = new MinMaxSelector<>(tuple2Comparator).     final List<Tuple2<Tuple2<Long, Long>, Tuple2<Long, Long>>> collected = dataSet.partitionByRange(0).withOrders(Order.ASCENDING).mapPartition(new MapPartitionFunction<Tuple2<Tuple2<Long, Long>, Long>, Tuple2<Long, Long>>() {          @Override         public void mapPartition(Iterable<Tuple2<Tuple2<Long, Long>, Long>> values, Collector<Tuple2<Long, Long>> out) throws Exception {             for (Tuple2<Tuple2<Long, Long>, Long> value : values) {                 out.collect(value.f0).             }         }     }).mapPartition(minMaxSelector).collect().     Collections.sort(collected, new Tuple2Comparator<>(tuple2Comparator)).     Tuple2<Long, Long> previousMax = null.     for (Tuple2<Tuple2<Long, Long>, Tuple2<Long, Long>> tuple2 : collected) {         assertTrue("Min element in each partition should be smaller than max.", tuple2Comparator.compare(tuple2.f0, tuple2.f1) <= 0).         if (previousMax == null) {             previousMax = tuple2.f1.         } else {             assertTrue("Partitions overlap. Previous max should be smaller than current min.", tuple2Comparator.compare(previousMax, tuple2.f0) < 0).             if (previousMax.f0.equals(tuple2.f0.f0)) {                 assertEquals("Ordering on the second field should be continous.", previousMax.f1 + 1, tuple2.f0.f1.longValue()).             }             previousMax = tuple2.f1.         }     } }
false;public;1;4;;@Override public Tuple2<ComparablePojo, Long> map(Long value) throws Exception {     return new Tuple2<>(new ComparablePojo(value / 5000, value % 5000), value). }
false;public;1;4;;@Override public ComparablePojo getKey(Tuple2<ComparablePojo, Long> value) throws Exception {     return value.f0. }
false;public;2;4;;@Override public int compare(Tuple2<ComparablePojo, ComparablePojo> o1, Tuple2<ComparablePojo, ComparablePojo> o2) {     return o1.f0.compareTo(o2.f1). }
false;public;0;49;;@Test public void testRangePartitionerWithKeySelectorOnSequenceNestedDataWithOrders() throws Exception {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     final DataSet<Tuple2<ComparablePojo, Long>> dataSet = env.generateSequence(0, 10000).map(new MapFunction<Long, Tuple2<ComparablePojo, Long>>() {          @Override         public Tuple2<ComparablePojo, Long> map(Long value) throws Exception {             return new Tuple2<>(new ComparablePojo(value / 5000, value % 5000), value).         }     }).     final List<Tuple2<ComparablePojo, ComparablePojo>> collected = dataSet.partitionByRange(new KeySelector<Tuple2<ComparablePojo, Long>, ComparablePojo>() {          @Override         public ComparablePojo getKey(Tuple2<ComparablePojo, Long> value) throws Exception {             return value.f0.         }     }).withOrders(Order.ASCENDING).mapPartition(new MinMaxSelector<>(new ComparablePojoComparator())).mapPartition(new ExtractComparablePojo()).collect().     final Comparator<Tuple2<ComparablePojo, ComparablePojo>> pojoComparator = new Comparator<Tuple2<ComparablePojo, ComparablePojo>>() {          @Override         public int compare(Tuple2<ComparablePojo, ComparablePojo> o1, Tuple2<ComparablePojo, ComparablePojo> o2) {             return o1.f0.compareTo(o2.f1).         }     }.     Collections.sort(collected, pojoComparator).     ComparablePojo previousMax = null.     for (Tuple2<ComparablePojo, ComparablePojo> element : collected) {         assertTrue("Min element in each partition should be smaller than max.", element.f0.compareTo(element.f1) <= 0).         if (previousMax == null) {             previousMax = element.f1.         } else {             assertTrue("Partitions overlap. Previous max should be smaller than current min.", previousMax.compareTo(element.f0) < 0).             if (previousMax.first.equals(element.f0.first)) {                 assertEquals("Ordering on the second field should be continous.", previousMax.second - 1, element.f0.second.longValue()).             }             previousMax = element.f1.         }     } }
false;public;2;7;;@Override public void mapPartition(Iterable<Tuple2<Tuple2<ComparablePojo, Long>, Tuple2<ComparablePojo, Long>>> values, Collector<Tuple2<ComparablePojo, ComparablePojo>> out) throws Exception {     for (Tuple2<Tuple2<ComparablePojo, Long>, Tuple2<ComparablePojo, Long>> value : values) {         out.collect(new Tuple2<>(value.f0.f0, value.f1.f0)).     } }
false;public;2;4;;@Override public int compare(Tuple2<ComparablePojo, Long> o1, Tuple2<ComparablePojo, Long> o2) {     return o1.f0.compareTo(o2.f0). }
false;public;0;3;;public Long getFirst() {     return first. }
false;public;1;3;;public void setFirst(Long first) {     this.first = first. }
false;public;0;3;;public Long getSecond() {     return second. }
false;public;1;3;;public void setSecond(Long second) {     this.second = second. }
false;public;1;9;;@Override public int compareTo(ComparablePojo o) {     final int firstResult = Long.compare(this.first, o.first).     if (firstResult == 0) {         return (-1) * Long.compare(this.second, o.second).     }     return firstResult. }
false;public;1;4;;@Override public Long getKey(Long value) throws Exception {     return value. }
false;public;2;20;;@Override public void mapPartition(Iterable<T> values, Collector<Tuple2<T, T>> out) throws Exception {     Iterator<T> itr = values.iterator().     T min = itr.next().     T max = min.     T value.     while (itr.hasNext()) {         value = itr.next().         if (comparator.compare(value, min) < 0) {             min = value.         }         if (comparator.compare(value, max) > 0) {             max = value.         }     }     Tuple2<T, T> result = new Tuple2<>(min, max).     out.collect(result). }
false;public;2;18;;@Override public int compare(Tuple2<T, T> first, Tuple2<T, T> second) {     long result = firstComparator.compare(first.f0, second.f0).     if (result > 0) {         return 1.     } else if (result < 0) {         return -1.     }     result = secondComparator.compare(first.f1, second.f1).     if (result > 0) {         return 1.     } else if (result < 0) {         return -1.     }     return 0. }
false;public;2;8;;@Override public int compare(Long o1, Long o2) {     if (ascending) {         return Long.compare(o1, o2).     } else {         return (-1) * Long.compare(o1, o2).     } }
