commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Test public void testExternalizedIncrementalRocksDBCheckpointsStandalone() throws Exception {     final File checkpointDir = temporaryFolder.newFolder().     testExternalizedCheckpoints(checkpointDir, null, createRocksDBStateBackend(checkpointDir, true), false). }
false;public;0;9;;@Test public void testExternalizedFullRocksDBCheckpointsStandalone() throws Exception {     final File checkpointDir = temporaryFolder.newFolder().     testExternalizedCheckpoints(checkpointDir, null, createRocksDBStateBackend(checkpointDir, false), false). }
false;public;0;9;;@Test public void testExternalizedIncrementalRocksDBCheckpointsWithLocalRecoveryStandalone() throws Exception {     final File checkpointDir = temporaryFolder.newFolder().     testExternalizedCheckpoints(checkpointDir, null, createRocksDBStateBackend(checkpointDir, true), true). }
false;public;0;9;;@Test public void testExternalizedFullRocksDBCheckpointsWithLocalRecoveryStandalone() throws Exception {     final File checkpointDir = temporaryFolder.newFolder().     testExternalizedCheckpoints(checkpointDir, null, createRocksDBStateBackend(checkpointDir, false), true). }
false;public;0;9;;@Test public void testExternalizedFSCheckpointsStandalone() throws Exception {     final File checkpointDir = temporaryFolder.newFolder().     testExternalizedCheckpoints(checkpointDir, null, createFsStateBackend(checkpointDir), false). }
false;public;0;9;;@Test public void testExternalizedFSCheckpointsWithLocalRecoveryStandalone() throws Exception {     final File checkpointDir = temporaryFolder.newFolder().     testExternalizedCheckpoints(checkpointDir, null, createFsStateBackend(checkpointDir), true). }
false;public;0;15;;@Test public void testExternalizedIncrementalRocksDBCheckpointsZookeeper() throws Exception {     TestingServer zkServer = new TestingServer().     zkServer.start().     try {         final File checkpointDir = temporaryFolder.newFolder().         testExternalizedCheckpoints(checkpointDir, zkServer.getConnectString(), createRocksDBStateBackend(checkpointDir, true), false).     } finally {         zkServer.stop().     } }
false;public;0;15;;@Test public void testExternalizedFullRocksDBCheckpointsZookeeper() throws Exception {     TestingServer zkServer = new TestingServer().     zkServer.start().     try {         final File checkpointDir = temporaryFolder.newFolder().         testExternalizedCheckpoints(checkpointDir, zkServer.getConnectString(), createRocksDBStateBackend(checkpointDir, false), false).     } finally {         zkServer.stop().     } }
false;public;0;15;;@Test public void testExternalizedIncrementalRocksDBCheckpointsWithLocalRecoveryZookeeper() throws Exception {     TestingServer zkServer = new TestingServer().     zkServer.start().     try {         final File checkpointDir = temporaryFolder.newFolder().         testExternalizedCheckpoints(checkpointDir, zkServer.getConnectString(), createRocksDBStateBackend(checkpointDir, true), true).     } finally {         zkServer.stop().     } }
false;public;0;15;;@Test public void testExternalizedFullRocksDBCheckpointsWithLocalRecoveryZookeeper() throws Exception {     TestingServer zkServer = new TestingServer().     zkServer.start().     try {         final File checkpointDir = temporaryFolder.newFolder().         testExternalizedCheckpoints(checkpointDir, zkServer.getConnectString(), createRocksDBStateBackend(checkpointDir, false), true).     } finally {         zkServer.stop().     } }
false;public;0;15;;@Test public void testExternalizedFSCheckpointsZookeeper() throws Exception {     TestingServer zkServer = new TestingServer().     zkServer.start().     try {         final File checkpointDir = temporaryFolder.newFolder().         testExternalizedCheckpoints(checkpointDir, zkServer.getConnectString(), createFsStateBackend(checkpointDir), false).     } finally {         zkServer.stop().     } }
false;public;0;15;;@Test public void testExternalizedFSCheckpointsWithLocalRecoveryZookeeper() throws Exception {     TestingServer zkServer = new TestingServer().     zkServer.start().     try {         final File checkpointDir = temporaryFolder.newFolder().         testExternalizedCheckpoints(checkpointDir, zkServer.getConnectString(), createFsStateBackend(checkpointDir), true).     } finally {         zkServer.stop().     } }
false;private;1;3;;private FsStateBackend createFsStateBackend(File checkpointDir) throws IOException {     return new FsStateBackend(checkpointDir.toURI().toString(), true). }
false;private;2;6;;private RocksDBStateBackend createRocksDBStateBackend(File checkpointDir, boolean incrementalCheckpointing) throws IOException {     return new RocksDBStateBackend(checkpointDir.toURI().toString(), incrementalCheckpointing). }
false;private;4;48;;private void testExternalizedCheckpoints(File checkpointDir, String zooKeeperQuorum, StateBackend backend, boolean localRecovery) throws Exception {     final Configuration config = new Configuration().     final File savepointDir = temporaryFolder.newFolder().     config.setString(CheckpointingOptions.CHECKPOINTS_DIRECTORY, checkpointDir.toURI().toString()).     config.setString(CheckpointingOptions.SAVEPOINT_DIRECTORY, savepointDir.toURI().toString()).     config.setBoolean(CheckpointingOptions.LOCAL_RECOVERY, localRecovery).     // ZooKeeper recovery mode?     if (zooKeeperQuorum != null) {         final File haDir = temporaryFolder.newFolder().         config.setString(HighAvailabilityOptions.HA_MODE, "ZOOKEEPER").         config.setString(HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperQuorum).         config.setString(HighAvailabilityOptions.HA_STORAGE_PATH, haDir.toURI().toString()).     }     MiniClusterWithClientResource cluster = new MiniClusterWithClientResource(new MiniClusterResourceConfiguration.Builder().setConfiguration(config).setNumberTaskManagers(NUM_TASK_MANAGERS).setNumberSlotsPerTaskManager(SLOTS_PER_TASK_MANAGER).build()).     cluster.before().     ClusterClient<?> client = cluster.getClusterClient().     client.setDetached(true).     try {         // main test sequence:  start job -> eCP -> restore job -> eCP -> restore job         String firstExternalCheckpoint = runJobAndGetExternalizedCheckpoint(backend, checkpointDir, null, client).         assertNotNull(firstExternalCheckpoint).         String secondExternalCheckpoint = runJobAndGetExternalizedCheckpoint(backend, checkpointDir, firstExternalCheckpoint, client).         assertNotNull(secondExternalCheckpoint).         String thirdExternalCheckpoint = runJobAndGetExternalizedCheckpoint(backend, checkpointDir, secondExternalCheckpoint, client).         assertNotNull(thirdExternalCheckpoint).     } finally {         cluster.after().     } }
false;private,static;4;15;;private static String runJobAndGetExternalizedCheckpoint(StateBackend backend, File checkpointDir, @Nullable String externalCheckpoint, ClusterClient<?> client) throws Exception {     JobGraph initialJobGraph = getJobGraph(backend, externalCheckpoint).     NotifyingInfiniteTupleSource.countDownLatch = new CountDownLatch(PARALLELISM).     client.submitJob(initialJobGraph, ResumeCheckpointManuallyITCase.class.getClassLoader()).     // wait until all sources have been started     NotifyingInfiniteTupleSource.countDownLatch.await().     waitUntilExternalizedCheckpointCreated(checkpointDir, initialJobGraph.getJobID()).     client.cancel(initialJobGraph.getJobID()).     waitUntilCanceled(initialJobGraph.getJobID(), client).     return getExternalizedCheckpointCheckpointPath(checkpointDir, initialJobGraph.getJobID()). }
false;private,static;2;8;;private static String getExternalizedCheckpointCheckpointPath(File checkpointDir, JobID jobId) throws IOException {     Optional<Path> checkpoint = findExternalizedCheckpoint(checkpointDir, jobId).     if (!checkpoint.isPresent()) {         throw new AssertionError("No complete checkpoint could be found.").     } else {         return checkpoint.get().toString().     } }
false;private,static;2;9;;private static void waitUntilExternalizedCheckpointCreated(File checkpointDir, JobID jobId) throws InterruptedException, IOException {     while (true) {         Thread.sleep(50).         Optional<Path> externalizedCheckpoint = findExternalizedCheckpoint(checkpointDir, jobId).         if (externalizedCheckpoint.isPresent()) {             break.         }     } }
false;private,static;2;14;;private static Optional<Path> findExternalizedCheckpoint(File checkpointDir, JobID jobId) throws IOException {     try (Stream<Path> checkpoints = Files.list(checkpointDir.toPath().resolve(jobId.toString()))) {         return checkpoints.filter(path -> path.getFileName().toString().startsWith("chk-")).filter(path -> {             try (Stream<Path> checkpointFiles = Files.list(path)) {                 return checkpointFiles.anyMatch(child -> child.getFileName().toString().contains("meta")).             } catch (IOException ignored) {                 return false.             }         }).findAny().     } }
false;private,static;2;5;;private static void waitUntilCanceled(JobID jobId, ClusterClient<?> client) throws ExecutionException, InterruptedException {     while (client.getJobStatus(jobId).get() != JobStatus.CANCELED) {         Thread.sleep(50).     } }
false;private,static;2;27;;private static JobGraph getJobGraph(StateBackend backend, @Nullable String externalCheckpoint) {     final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.enableCheckpointing(500).     env.setStateBackend(backend).     env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime).     env.setParallelism(PARALLELISM).     env.getCheckpointConfig().enableExternalizedCheckpoints(CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION).     env.addSource(new NotifyingInfiniteTupleSource(10_000)).keyBy(0).timeWindow(Time.seconds(3)).reduce((value1, value2) -> Tuple2.of(value1.f0, value1.f1 + value2.f1)).filter(value -> value.f0.startsWith("Tuple 0")).     StreamGraph streamGraph = env.getStreamGraph().     streamGraph.setJobName("Test").     JobGraph jobGraph = streamGraph.getJobGraph().     // recover from previous iteration?     if (externalCheckpoint != null) {         jobGraph.setSavepointRestoreSettings(SavepointRestoreSettings.forPath(externalCheckpoint)).     }     return jobGraph. }
false;public;1;8;;@Override public void run(SourceContext<Tuple2<String, Integer>> out) throws Exception {     if (countDownLatch != null) {         countDownLatch.countDown().     }     super.run(out). }
