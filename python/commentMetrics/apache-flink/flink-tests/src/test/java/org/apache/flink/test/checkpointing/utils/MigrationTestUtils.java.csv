commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     unionListState.clear().     unionListState.add(CHECKPOINTED_STRING).     unionListState.add(CHECKPOINTED_STRING_1).     unionListState.add(CHECKPOINTED_STRING_2).     unionListState.add(CHECKPOINTED_STRING_3). }
false;public;1;5;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     unionListState = context.getOperatorStateStore().getListState(STATE_DESCRIPTOR). }
false;public;1;17;;@Override public void run(SourceContext<Tuple2<Long, Long>> ctx) throws Exception {     ctx.emitWatermark(new Watermark(0)).     synchronized (ctx.getCheckpointLock()) {         for (long i = 0. i < numElements. i++) {             ctx.collect(new Tuple2<>(i, i)).         }     }     // timers     while (isRunning) {         Thread.sleep(20).     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;1;4;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception { }
false;public;1;20;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     ListState<String> unionListState = context.getOperatorStateStore().getListState(CheckpointingNonParallelSourceWithListState.STATE_DESCRIPTOR).     if (context.isRestored()) {         assertThat(unionListState.get(), containsInAnyOrder(CheckpointingNonParallelSourceWithListState.CHECKPOINTED_STRING, CheckpointingNonParallelSourceWithListState.CHECKPOINTED_STRING_1, CheckpointingNonParallelSourceWithListState.CHECKPOINTED_STRING_2, CheckpointingNonParallelSourceWithListState.CHECKPOINTED_STRING_3)).         getRuntimeContext().addAccumulator(SUCCESSFUL_RESTORE_CHECK_ACCUMULATOR, new IntCounter()).         getRuntimeContext().getAccumulator(SUCCESSFUL_RESTORE_CHECK_ACCUMULATOR).add(1).     } else {         throw new RuntimeException("This source should always be restored because it's only used when restoring from a savepoint.").     } }
false;public;1;16;;@Override public void run(SourceContext<Tuple2<Long, Long>> ctx) throws Exception {     // immediately trigger any set timers     ctx.emitWatermark(new Watermark(1000)).     synchronized (ctx.getCheckpointLock()) {         for (long i = 0. i < numElements. i++) {             ctx.collect(new Tuple2<>(i, i)).         }     }     while (isRunning) {         Thread.sleep(20).     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;1;10;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     unionListState.clear().     for (String s : CHECKPOINTED_STRINGS) {         if (s.hashCode() % getRuntimeContext().getNumberOfParallelSubtasks() == getRuntimeContext().getIndexOfThisSubtask()) {             unionListState.add(s).         }     } }
false;public;1;5;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     unionListState = context.getOperatorStateStore().getUnionListState(STATE_DESCRIPTOR). }
false;public;1;19;;@Override public void run(SourceContext<Tuple2<Long, Long>> ctx) throws Exception {     ctx.emitWatermark(new Watermark(0)).     synchronized (ctx.getCheckpointLock()) {         for (long i = 0. i < numElements. i++) {             if (i % getRuntimeContext().getNumberOfParallelSubtasks() == getRuntimeContext().getIndexOfThisSubtask()) {                 ctx.collect(new Tuple2<>(i, i)).             }         }     }     // timers     while (isRunning) {         Thread.sleep(20).     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;1;4;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception { }
false;public;1;16;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     ListState<String> unionListState = context.getOperatorStateStore().getUnionListState(CheckpointingNonParallelSourceWithListState.STATE_DESCRIPTOR).     if (context.isRestored()) {         assertThat(unionListState.get(), containsInAnyOrder(CheckpointingParallelSourceWithUnionListState.CHECKPOINTED_STRINGS)).         getRuntimeContext().addAccumulator(SUCCESSFUL_RESTORE_CHECK_ACCUMULATOR, new IntCounter()).         getRuntimeContext().getAccumulator(SUCCESSFUL_RESTORE_CHECK_ACCUMULATOR).add(1).     } else {         throw new RuntimeException("This source should always be restored because it's only used when restoring from a savepoint.").     } }
false;public;1;18;;@Override public void run(SourceContext<Tuple2<Long, Long>> ctx) throws Exception {     // immediately trigger any set timers     ctx.emitWatermark(new Watermark(1000)).     synchronized (ctx.getCheckpointLock()) {         for (long i = 0. i < numElements. i++) {             if (i % getRuntimeContext().getNumberOfParallelSubtasks() == getRuntimeContext().getIndexOfThisSubtask()) {                 ctx.collect(new Tuple2<>(i, i)).             }         }     }     while (isRunning) {         Thread.sleep(20).     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;1;6;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     getRuntimeContext().addAccumulator(NUM_ELEMENTS_ACCUMULATOR, new IntCounter()). }
false;public;2;5;;@Override public void invoke(T value, Context context) throws Exception {     count++.     getRuntimeContext().getAccumulator(NUM_ELEMENTS_ACCUMULATOR).add(1). }
