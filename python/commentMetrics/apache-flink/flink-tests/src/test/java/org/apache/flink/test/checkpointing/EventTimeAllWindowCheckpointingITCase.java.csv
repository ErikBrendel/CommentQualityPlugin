commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;7;;private static Configuration getConfiguration() {     Configuration config = new Configuration().     config.setString(TaskManagerOptions.MANAGED_MEMORY_SIZE, "48m").     config.setString(AkkaOptions.LOOKUP_TIMEOUT, "60 s").     config.setString(AkkaOptions.ASK_TIMEOUT, "60 s").     return config. }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;3;18;;@Override public void apply(TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple4<Long, Long, Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     int sum = 0.     long key = -1.     for (Tuple2<Long, IntType> value : values) {         sum += value.f1.value.         key = value.f0.     }     out.collect(new Tuple4<>(key, window.getStart(), window.getEnd(), new IntType(sum))). }
false;public;0;59;;// ------------------------------------------------------------------------ @Test public void testTumblingTimeWindow() {     final int numElementsPerKey = 3000.     final int windowSize = 100.     final int numKeys = 1.     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         env.addSource(new FailingSource(new EventTimeWindowCheckpointingITCase.KeyedEventTimeGenerator(numKeys, windowSize), numElementsPerKey)).rebalance().timeWindowAll(Time.of(windowSize, MILLISECONDS)).apply(new RichAllWindowFunction<Tuple2<Long, IntType>, Tuple4<Long, Long, Long, IntType>, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple4<Long, Long, Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 int sum = 0.                 long key = -1.                 for (Tuple2<Long, IntType> value : values) {                     sum += value.f1.value.                     key = value.f0.                 }                 out.collect(new Tuple4<>(key, window.getStart(), window.getEnd(), new IntType(sum))).             }         }).addSink(new ValidatingSink<>(new EventTimeWindowCheckpointingITCase.SinkValidatorUpdateFun(numElementsPerKey), new EventTimeWindowCheckpointingITCase.SinkValidatorCheckFun(numKeys, numElementsPerKey, windowSize))).setParallelism(1).         env.execute("Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;3;18;;@Override public void apply(TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple4<Long, Long, Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     int sum = 0.     long key = -1.     for (Tuple2<Long, IntType> value : values) {         sum += value.f1.value.         key = value.f0.     }     out.collect(new Tuple4<>(key, window.getStart(), window.getEnd(), new IntType(sum))). }
false;public;0;60;;@Test public void testSlidingTimeWindow() {     final int numElementsPerKey = 3000.     final int windowSize = 1000.     final int windowSlide = 100.     final int numKeys = 1.     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         env.addSource(new FailingSource(new EventTimeWindowCheckpointingITCase.KeyedEventTimeGenerator(numKeys, windowSlide), numElementsPerKey)).rebalance().timeWindowAll(Time.of(windowSize, MILLISECONDS), Time.of(windowSlide, MILLISECONDS)).apply(new RichAllWindowFunction<Tuple2<Long, IntType>, Tuple4<Long, Long, Long, IntType>, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(TimeWindow window, Iterable<Tuple2<Long, IntType>> values, Collector<Tuple4<Long, Long, Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 int sum = 0.                 long key = -1.                 for (Tuple2<Long, IntType> value : values) {                     sum += value.f1.value.                     key = value.f0.                 }                 out.collect(new Tuple4<>(key, window.getStart(), window.getEnd(), new IntType(sum))).             }         }).addSink(new ValidatingSink<>(new EventTimeWindowCheckpointingITCase.SinkValidatorUpdateFun(numElementsPerKey), new EventTimeWindowCheckpointingITCase.SinkValidatorCheckFun(numKeys, numElementsPerKey, windowSlide))).setParallelism(1).         env.execute("Sliding Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;7;;@Override public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {     return new Tuple2<>(a.f0, new IntType(a.f1.value + b.f1.value)). }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;3;16;;@Override public void apply(TimeWindow window, Iterable<Tuple2<Long, IntType>> input, Collector<Tuple4<Long, Long, Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     for (Tuple2<Long, IntType> in : input) {         out.collect(new Tuple4<>(in.f0, window.getStart(), window.getEnd(), in.f1)).     } }
false;public;0;68;;@Test public void testPreAggregatedTumblingTimeWindow() {     final int numElementsPerKey = 3000.     final int windowSize = 100.     final int numKeys = 1.     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         env.addSource(new FailingSource(new EventTimeWindowCheckpointingITCase.KeyedEventTimeGenerator(numKeys, windowSize), numElementsPerKey)).rebalance().timeWindowAll(Time.of(windowSize, MILLISECONDS)).reduce(new ReduceFunction<Tuple2<Long, IntType>>() {              @Override             public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {                 return new Tuple2<>(a.f0, new IntType(a.f1.value + b.f1.value)).             }         }, new RichAllWindowFunction<Tuple2<Long, IntType>, Tuple4<Long, Long, Long, IntType>, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(TimeWindow window, Iterable<Tuple2<Long, IntType>> input, Collector<Tuple4<Long, Long, Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 for (Tuple2<Long, IntType> in : input) {                     out.collect(new Tuple4<>(in.f0, window.getStart(), window.getEnd(), in.f1)).                 }             }         }).addSink(new ValidatingSink<>(new EventTimeWindowCheckpointingITCase.SinkValidatorUpdateFun(numElementsPerKey), new EventTimeWindowCheckpointingITCase.SinkValidatorCheckFun(numKeys, numElementsPerKey, windowSize))).setParallelism(1).         env.execute("Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;7;;@Override public Tuple4<Long, Long, Long, IntType> fold(Tuple4<Long, Long, Long, IntType> accumulator, Tuple2<Long, IntType> value) throws Exception {     accumulator.f0 = value.f0.     accumulator.f3 = new IntType(accumulator.f3.value + value.f1.value).     return accumulator. }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;3;16;;@Override public void apply(TimeWindow window, Iterable<Tuple4<Long, Long, Long, IntType>> input, Collector<Tuple4<Long, Long, Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     for (Tuple4<Long, Long, Long, IntType> in : input) {         out.collect(new Tuple4<>(in.f0, window.getStart(), window.getEnd(), in.f3)).     } }
false;public;0;67;;@Test public void testPreAggregatedFoldingTumblingTimeWindow() {     final int numElementsPerKey = 3000.     final int windowSize = 100.     final int numKeys = 1.     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         env.addSource(new FailingSource(new EventTimeWindowCheckpointingITCase.KeyedEventTimeGenerator(numKeys, windowSize), numElementsPerKey)).rebalance().timeWindowAll(Time.of(windowSize, MILLISECONDS)).fold(new Tuple4<>(0L, 0L, 0L, new IntType(0)), new FoldFunction<Tuple2<Long, IntType>, Tuple4<Long, Long, Long, IntType>>() {              @Override             public Tuple4<Long, Long, Long, IntType> fold(Tuple4<Long, Long, Long, IntType> accumulator, Tuple2<Long, IntType> value) throws Exception {                 accumulator.f0 = value.f0.                 accumulator.f3 = new IntType(accumulator.f3.value + value.f1.value).                 return accumulator.             }         }, new RichAllWindowFunction<Tuple4<Long, Long, Long, IntType>, Tuple4<Long, Long, Long, IntType>, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(TimeWindow window, Iterable<Tuple4<Long, Long, Long, IntType>> input, Collector<Tuple4<Long, Long, Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 for (Tuple4<Long, Long, Long, IntType> in : input) {                     out.collect(new Tuple4<>(in.f0, window.getStart(), window.getEnd(), in.f3)).                 }             }         }).addSink(new ValidatingSink<>(new EventTimeWindowCheckpointingITCase.SinkValidatorUpdateFun(numElementsPerKey), new EventTimeWindowCheckpointingITCase.SinkValidatorCheckFun(numKeys, numElementsPerKey, windowSize))).setParallelism(1).         env.execute("Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;7;;@Override public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {     return new Tuple2<>(a.f0, new IntType(a.f1.value + b.f1.value)). }
false;public;1;5;;@Override public void open(Configuration parameters) {     assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()).     open = true. }
false;public;3;16;;@Override public void apply(TimeWindow window, Iterable<Tuple2<Long, IntType>> input, Collector<Tuple4<Long, Long, Long, IntType>> out) {     // validate that the function has been opened properly     assertTrue(open).     for (Tuple2<Long, IntType> in : input) {         out.collect(new Tuple4<>(in.f0, window.getStart(), window.getEnd(), in.f1)).     } }
false;public;0;70;;@Test public void testPreAggregatedSlidingTimeWindow() {     final int numElementsPerKey = 3000.     final int windowSize = 1000.     final int windowSlide = 100.     final int numKeys = 1.     try {         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().         env.setParallelism(PARALLELISM).         env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).         env.enableCheckpointing(100).         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 0)).         env.getConfig().disableSysoutLogging().         env.addSource(new FailingSource(new EventTimeWindowCheckpointingITCase.KeyedEventTimeGenerator(numKeys, windowSlide), numElementsPerKey)).rebalance().timeWindowAll(Time.of(windowSize, MILLISECONDS), Time.of(windowSlide, MILLISECONDS)).reduce(new ReduceFunction<Tuple2<Long, IntType>>() {              @Override             public Tuple2<Long, IntType> reduce(Tuple2<Long, IntType> a, Tuple2<Long, IntType> b) {                 return new Tuple2<>(a.f0, new IntType(a.f1.value + b.f1.value)).             }         }, new RichAllWindowFunction<Tuple2<Long, IntType>, Tuple4<Long, Long, Long, IntType>, TimeWindow>() {              private boolean open = false.              @Override             public void open(Configuration parameters) {                 assertEquals(1, getRuntimeContext().getNumberOfParallelSubtasks()).                 open = true.             }              @Override             public void apply(TimeWindow window, Iterable<Tuple2<Long, IntType>> input, Collector<Tuple4<Long, Long, Long, IntType>> out) {                 // validate that the function has been opened properly                 assertTrue(open).                 for (Tuple2<Long, IntType> in : input) {                     out.collect(new Tuple4<>(in.f0, window.getStart(), window.getEnd(), in.f1)).                 }             }         }).addSink(new ValidatingSink<>(new EventTimeWindowCheckpointingITCase.SinkValidatorUpdateFun(numElementsPerKey), new EventTimeWindowCheckpointingITCase.SinkValidatorCheckFun(numKeys, numElementsPerKey, windowSlide))).setParallelism(1).         env.execute("Tumbling Window Test").     } catch (Exception e) {         e.printStackTrace().         fail(e.getMessage()).     } }
