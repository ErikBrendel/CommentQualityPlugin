commented;modifiers;parameterAmount;loc;comment;code
false;public;0;95;;public void testStringSorting() {     File input = null.     File sorted = null.     try {         // the source file         input = generateFileWithStrings(300000, "http://some-uri.com/that/is/a/common/prefix/to/all").         // the sorted file         sorted = File.createTempFile("sorted_strings", "txt").         String[] command = { "/bin/bash", "-c", "export LC_ALL=\"C\" && cat \"" + input.getAbsolutePath() + "\" | sort > \"" + sorted.getAbsolutePath() + "\"" }.         Process p = null.         try {             p = Runtime.getRuntime().exec(command).             int retCode = p.waitFor().             if (retCode != 0) {                 throw new Exception("Command failed with return code " + retCode).             }             p = null.         } finally {             if (p != null) {                 p.destroy().             }         }         // sort the data         UnilateralSortMerger<String> sorter = null.         BufferedReader reader = null.         BufferedReader verifyReader = null.         MemoryManager mm = null.         IOManager ioMan = null.         try {             mm = new MemoryManager(1024 * 1024, 1).             ioMan = new IOManagerAsync().             TypeSerializer<String> serializer = StringSerializer.INSTANCE.             TypeComparator<String> comparator = new StringComparator(true).             reader = new BufferedReader(new FileReader(input)).             MutableObjectIterator<String> inputIterator = new StringReaderMutableObjectIterator(reader).             sorter = new UnilateralSortMerger<String>(mm, ioMan, inputIterator, new DummyInvokable(), new RuntimeSerializerFactory<String>(serializer, String.class), comparator, 1.0, 4, 0.8f, true, /* use large record handler */             false).             MutableObjectIterator<String> sortedData = sorter.getIterator().             reader.close().             // verify             verifyReader = new BufferedReader(new FileReader(sorted)).             String next.             while ((next = verifyReader.readLine()) != null) {                 String nextFromStratoSort = sortedData.next("").                 Assert.assertNotNull(nextFromStratoSort).                 Assert.assertEquals(next, nextFromStratoSort).             }         } finally {             if (reader != null) {                 reader.close().             }             if (verifyReader != null) {                 verifyReader.close().             }             if (sorter != null) {                 sorter.close().             }             if (mm != null) {                 mm.shutdown().             }             if (ioMan != null) {                 ioMan.shutdown().             }         }     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail(e.getMessage()).     } finally {         if (input != null) {             input.delete().         }         if (sorted != null) {             sorted.delete().         }     } }
false;public;0;128;;@SuppressWarnings("unchecked") public void testStringTuplesSorting() {     final int numStrings = 300000.     File input = null.     File sorted = null.     try {         // the source file         input = generateFileWithStringTuples(numStrings, "http://some-uri.com/that/is/a/common/prefix/to/all").         // the sorted file         sorted = File.createTempFile("sorted_strings", "txt").         String[] command = { "/bin/bash", "-c", "export LC_ALL=\"C\" && cat \"" + input.getAbsolutePath() + "\" | sort > \"" + sorted.getAbsolutePath() + "\"" }.         Process p = null.         try {             p = Runtime.getRuntime().exec(command).             int retCode = p.waitFor().             if (retCode != 0) {                 throw new Exception("Command failed with return code " + retCode).             }             p = null.         } finally {             if (p != null) {                 p.destroy().             }         }         // sort the data         UnilateralSortMerger<Tuple2<String, String[]>> sorter = null.         BufferedReader reader = null.         BufferedReader verifyReader = null.         MemoryManager mm = null.         IOManager ioMan = null.         try {             mm = new MemoryManager(1024 * 1024, 1).             ioMan = new IOManagerAsync().             TupleTypeInfo<Tuple2<String, String[]>> typeInfo = (TupleTypeInfo<Tuple2<String, String[]>>) new TypeHint<Tuple2<String, String[]>>() {             }.getTypeInfo().             TypeSerializer<Tuple2<String, String[]>> serializer = typeInfo.createSerializer(new ExecutionConfig()).             TypeComparator<Tuple2<String, String[]>> comparator = typeInfo.createComparator(new int[] { 0 }, new boolean[] { true }, 0, new ExecutionConfig()).             reader = new BufferedReader(new FileReader(input)).             MutableObjectIterator<Tuple2<String, String[]>> inputIterator = new StringTupleReaderMutableObjectIterator(reader).             sorter = new UnilateralSortMerger<Tuple2<String, String[]>>(mm, ioMan, inputIterator, new DummyInvokable(), new RuntimeSerializerFactory<Tuple2<String, String[]>>(serializer, (Class<Tuple2<String, String[]>>) (Class<?>) Tuple2.class), comparator, 1.0, 4, 0.8f, true, /* use large record handler */             false).             // use this part to verify that all if good when sorting in memory             // List<MemorySegment> memory = mm.allocatePages(new DummyInvokable(), mm.computeNumberOfPages(1024*1024*1024)).             // NormalizedKeySorter<Tuple2<String, String[]>> nks = new NormalizedKeySorter<Tuple2<String,String[]>>(serializer, comparator, memory).             //              // {             // Tuple2<String, String[]> wi = new Tuple2<String, String[]>("", new String[0]).             // while ((wi = inputIterator.next(wi)) != null) {             // Assert.assertTrue(nks.write(wi)).             // }             //              // new QuickSort().sort(nks).             // }             //              // MutableObjectIterator<Tuple2<String, String[]>> sortedData = nks.getIterator().             MutableObjectIterator<Tuple2<String, String[]>> sortedData = sorter.getIterator().             reader.close().             // verify             verifyReader = new BufferedReader(new FileReader(sorted)).             MutableObjectIterator<Tuple2<String, String[]>> verifyIterator = new StringTupleReaderMutableObjectIterator(verifyReader).             Tuple2<String, String[]> next = new Tuple2<String, String[]>("", new String[0]).             Tuple2<String, String[]> nextFromStratoSort = new Tuple2<String, String[]>("", new String[0]).             int num = 0.             while ((next = verifyIterator.next(next)) != null) {                 num++.                 nextFromStratoSort = sortedData.next(nextFromStratoSort).                 Assert.assertNotNull(nextFromStratoSort).                 Assert.assertEquals(next.f0, nextFromStratoSort.f0).                 Assert.assertArrayEquals(next.f1, nextFromStratoSort.f1).             }             Assert.assertNull(sortedData.next(nextFromStratoSort)).             Assert.assertEquals(numStrings, num).         } finally {             if (reader != null) {                 reader.close().             }             if (verifyReader != null) {                 verifyReader.close().             }             if (sorter != null) {                 sorter.close().             }             if (mm != null) {                 mm.shutdown().             }             if (ioMan != null) {                 ioMan.shutdown().             }         }     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         Assert.fail(e.getMessage()).     } finally {         if (input != null) {             input.delete().         }         if (sorted != null) {             sorted.delete().         }     } }
false;public;1;4;;@Override public String next(String reuse) throws IOException {     return reader.readLine(). }
false;public;0;4;;@Override public String next() throws IOException {     return reader.readLine(). }
false;public;1;12;;@Override public Tuple2<String, String[]> next(Tuple2<String, String[]> reuse) throws IOException {     String line = reader.readLine().     if (line == null) {         return null.     }     String[] parts = line.split(" ").     reuse.f0 = parts[0].     reuse.f1 = parts.     return reuse. }
false;public;0;4;;@Override public Tuple2<String, String[]> next() throws IOException {     return next(new Tuple2<String, String[]>()). }
false;private;2;32;;// -------------------------------------------------------------------------------------------- private File generateFileWithStrings(int numStrings, String prefix) throws IOException {     final Random rnd = new Random(SEED).     final StringBuilder bld = new StringBuilder().     final int resetValue = prefix.length().     bld.append(prefix).     File f = File.createTempFile("strings", "txt").     BufferedWriter wrt = null.     try {         wrt = new BufferedWriter(new FileWriter(f)).         for (int i = 0. i < numStrings. i++) {             bld.setLength(resetValue).             int len = rnd.nextInt(20) + 300.             for (int k = 0. k < len. k++) {                 char c = (char) (rnd.nextInt(80) + 40).                 bld.append(c).             }             String str = bld.toString().             wrt.write(str).             wrt.newLine().         }     } finally {         wrt.close().     }     return f. }
false;private;2;39;;private File generateFileWithStringTuples(int numStrings, String prefix) throws IOException {     final Random rnd = new Random(SEED).     final StringBuilder bld = new StringBuilder().     File f = File.createTempFile("strings", "txt").     BufferedWriter wrt = null.     try {         wrt = new BufferedWriter(new FileWriter(f)).         for (int i = 0. i < numStrings. i++) {             bld.setLength(0).             int numComps = rnd.nextInt(5) + 1.             for (int z = 0. z < numComps. z++) {                 if (z > 0) {                     bld.append(' ').                 }                 bld.append(prefix).                 int len = rnd.nextInt(20) + 10.                 for (int k = 0. k < len. k++) {                     char c = (char) (rnd.nextInt(80) + 40).                     bld.append(c).                 }             }             String str = bld.toString().             wrt.write(str).             wrt.newLine().         }     } finally {         wrt.close().     }     return f. }
false;public,static;1;4;;// -------------------------------------------------------------------------------------------- public static void main(String[] args) {     new MassiveStringSorting().testStringSorting().     new MassiveStringSorting().testStringTuplesSorting(). }
