commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public Integer getKey(Tuple2<Integer, Integer> value) throws Exception {     return value.f0. }
false;public;1;4;;@Override public Tuple2<Integer, Integer> map(Integer value) throws Exception {     return new Tuple2<>(ThreadLocalRandom.current().nextInt(parallelism), value). }
false;public,static;1;34;;public static void main(String[] args) throws Exception {     final String checkpointPath = args[0].     final String outputPath = args[1].     final int parallelism = 1.     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(parallelism).     env.getConfig().disableSysoutLogging().     env.enableCheckpointing(100).     env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 1000)).     env.setStateBackend(new FsStateBackend(checkpointPath)).     DataStream<Integer> source = env.addSource(new InfiniteIntegerSource()).     source.map(new MapFunction<Integer, Tuple2<Integer, Integer>>() {          private static final long serialVersionUID = 1L.          @Override         public Tuple2<Integer, Integer> map(Integer value) throws Exception {             return new Tuple2<>(ThreadLocalRandom.current().nextInt(parallelism), value).         }     }).keyBy(new KeySelector<Tuple2<Integer, Integer>, Integer>() {          private static final long serialVersionUID = 1L.          @Override         public Integer getKey(Tuple2<Integer, Integer> value) throws Exception {             return value.f0.         }     }).flatMap(new ReducingStateFlatMap()).writeAsText(outputPath, FileSystem.WriteMode.OVERWRITE).     env.execute(). }
false;public;1;9;;@Override public void run(SourceContext<Integer> ctx) throws Exception {     int counter = 0.     while (running) {         synchronized (ctx.getCheckpointLock()) {             ctx.collect(counter++).         }     } }
false;public;0;4;;@Override public void cancel() {     running = false. }
false;public;2;4;;@Override public List<Integer> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(0). }
false;public;1;4;;@Override public void restoreState(List<Integer> state) throws Exception { }
false;public;1;10;;@Override public void open(Configuration parameters) throws Exception {     ReducingStateDescriptor<Integer> stateDescriptor = new ReducingStateDescriptor<>("reducing-state", new ReduceSum(), CustomIntSerializer.INSTANCE).     this.kvState = getRuntimeContext().getReducingState(stateDescriptor). }
false;public;2;12;;@Override public void flatMap(Tuple2<Integer, Integer> value, Collector<Integer> out) throws Exception {     kvState.add(value.f1).     if (atLeastOneSnapshotComplete) {         if (restored) {             throw new SuccessException().         } else {             throw new RuntimeException("Intended failure, to trigger restore").         }     } }
false;public;2;4;;@Override public List<ReducingStateFlatMap> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this). }
false;public;1;5;;@Override public void restoreState(List<ReducingStateFlatMap> state) throws Exception {     restored = true.     atLeastOneSnapshotComplete = true. }
false;public;1;4;;@Override public void notifyCheckpointComplete(long checkpointId) throws Exception {     atLeastOneSnapshotComplete = true. }
false;public;2;4;;@Override public Integer reduce(Integer value1, Integer value2) throws Exception {     return value1 + value2. }
false;public;0;4;;@Override public boolean isImmutableType() {     return true. }
false;public;0;4;;@Override public Integer createInstance() {     return 0. }
false;public;1;4;;@Override public Integer copy(Integer from) {     return from. }
false;public;2;4;;@Override public Integer copy(Integer from, Integer reuse) {     return from. }
false;public;0;4;;@Override public int getLength() {     return 4. }
false;public;2;4;;@Override public void serialize(Integer record, DataOutputView target) throws IOException {     target.writeInt(record.intValue()). }
false;public;1;4;;@Override public Integer deserialize(DataInputView source) throws IOException {     return Integer.valueOf(source.readInt()). }
false;public;2;4;;@Override public Integer deserialize(Integer reuse, DataInputView source) throws IOException {     return Integer.valueOf(source.readInt()). }
false;public;2;4;;@Override public void copy(DataInputView source, DataOutputView target) throws IOException {     target.writeInt(source.readInt()). }
false;public;0;4;;// ----------------------------------------------------------------------------------- @Override public TypeSerializerSnapshot<Integer> snapshotConfiguration() {     return new CustomIntSerializerSnapshot(). }
