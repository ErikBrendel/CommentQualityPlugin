commented;modifiers;parameterAmount;loc;comment;code
false;public;0;40;;@Test public void testMultiSolutionSetJoinPlan() {     try {         ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().         @SuppressWarnings("unchecked")         DataSet<Tuple2<Long, Double>> inputData = env.fromElements(new Tuple2<Long, Double>(1L, 1.0)).         DataSet<Tuple2<Long, Double>> result = constructPlan(inputData, 10).         // add two sinks, to test the case of branching after an iteration         result.output(new DiscardingOutputFormat<Tuple2<Long, Double>>()).         result.output(new DiscardingOutputFormat<Tuple2<Long, Double>>()).         Plan p = env.createProgramPlan().         OptimizedPlan optPlan = compileNoStats(p).         OptimizerPlanNodeResolver or = getOptimizerPlanNodeResolver(optPlan).         DualInputPlanNode join1 = or.getNode(JOIN_1).         DualInputPlanNode join2 = or.getNode(JOIN_2).         assertEquals(DriverStrategy.HYBRIDHASH_BUILD_FIRST, join1.getDriverStrategy()).         assertEquals(DriverStrategy.HYBRIDHASH_BUILD_SECOND, join2.getDriverStrategy()).         assertEquals(ShipStrategyType.PARTITION_HASH, join1.getInput2().getShipStrategy()).         assertEquals(ShipStrategyType.PARTITION_HASH, join2.getInput1().getShipStrategy()).         assertEquals(SolutionSetPlanNode.class, join1.getInput1().getSource().getClass()).         assertEquals(SolutionSetPlanNode.class, join2.getInput2().getSource().getClass()).         new JobGraphGenerator().compileJobGraph(optPlan).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail("Test erroneous: " + e.getMessage()).     } }
false;public,static;2;15;;public static DataSet<Tuple2<Long, Double>> constructPlan(DataSet<Tuple2<Long, Double>> initialData, int numIterations) {     DeltaIteration<Tuple2<Long, Double>, Tuple2<Long, Double>> iteration = initialData.iterateDelta(initialData, numIterations, 0).     DataSet<Tuple2<Long, Double>> delta = iteration.getSolutionSet().join(iteration.getWorkset().flatMap(new Duplicator())).where(0).equalTo(0).with(new SummingJoin()).name(JOIN_1).groupBy(0).aggregate(Aggregations.MIN, 1).map(new Expander()).join(iteration.getSolutionSet()).where(0).equalTo(0).with(new SummingJoinProject()).name(JOIN_2).     DataSet<Tuple2<Long, Double>> changes = delta.groupBy(0).aggregate(Aggregations.SUM, 1).     DataSet<Tuple2<Long, Double>> result = iteration.closeWith(delta, changes).     return result. }
false;public;2;4;;@Override public Tuple2<Long, Double> join(Tuple2<Long, Double> first, Tuple2<Long, Double> second) {     return new Tuple2<Long, Double>(first.f0, first.f1 + second.f1). }
false;public;2;4;;@Override public Tuple2<Long, Double> join(Tuple3<Long, Double, Double> first, Tuple2<Long, Double> second) {     return new Tuple2<Long, Double>(first.f0, first.f1 + first.f2 + second.f1). }
false;public;2;5;;@Override public void flatMap(Tuple2<Long, Double> value, Collector<Tuple2<Long, Double>> out) {     out.collect(value).     out.collect(value). }
false;public;1;4;;@Override public Tuple3<Long, Double, Double> map(Tuple2<Long, Double> value) {     return new Tuple3<Long, Double, Double>(value.f0, value.f1, value.f1 * 2). }
