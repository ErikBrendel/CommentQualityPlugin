commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected void preSubmit() throws Exception {     dataPath = createTempFile("datapoints.txt", INPUT).     resultPath = getTempFilePath("result"). }
false;protected;0;26;;@Override protected void postSubmit() throws Exception {     compareResultsByLinesInMemory(EXPECTED, resultPath).     // Test accumulator results     System.out.println("Accumulator results:").     JobExecutionResult res = this.result.     System.out.println(AccumulatorHelper.getResultsFormatted(res.getAllAccumulatorResults())).     Assert.assertEquals(Integer.valueOf(3), res.getAccumulatorResult("num-lines")).     Assert.assertEquals(Integer.valueOf(3), res.getIntCounterResult("num-lines")).     Assert.assertEquals(Double.valueOf(getParallelism()), res.getAccumulatorResult("open-close-counter")).     // Test histogram (words per line distribution)     Map<Integer, Integer> dist = new HashMap<>().     dist.put(1, 1).     dist.put(2, 1).     dist.put(3, 1).     Assert.assertEquals(dist, res.getAccumulatorResult("words-per-line")).     // Test distinct words (custom accumulator)     Set<StringValue> distinctWords = new HashSet<>().     distinctWords.add(new StringValue("one")).     distinctWords.add(new StringValue("two")).     distinctWords.add(new StringValue("three")).     Assert.assertEquals(distinctWords, res.getAccumulatorResult("distinct-words")). }
false;protected;0;13;;@Override protected void testProgram() throws Exception {     ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<String> input = env.readTextFile(dataPath).     input.flatMap(new TokenizeLine()).groupBy(0).reduceGroup(new CountWords()).writeAsCsv(resultPath, "\n", " ").     this.result = env.execute(). }
false;public;1;39;;@Override public void open(Configuration parameters) {     // Add counters using convenience functions     this.cntNumLines = getRuntimeContext().getIntCounter("num-lines").     this.wordsPerLineDistribution = getRuntimeContext().getHistogram("words-per-line").     // Add built-in accumulator without convenience function     getRuntimeContext().addAccumulator("open-close-counter", this.openCloseCounter).     // Add custom counter     this.distinctWords = new SetAccumulator<>().     this.getRuntimeContext().addAccumulator("distinct-words", distinctWords).     // Create counter and test increment     IntCounter simpleCounter = getRuntimeContext().getIntCounter("simple-counter").     simpleCounter.add(1).     Assert.assertEquals(simpleCounter.getLocalValue().intValue(), 1).     // Test if we get the same counter     IntCounter simpleCounter2 = getRuntimeContext().getIntCounter("simple-counter").     Assert.assertEquals(simpleCounter.getLocalValue(), simpleCounter2.getLocalValue()).     // Should fail if we request it with different type     try {         @SuppressWarnings("unused")         DoubleCounter simpleCounter3 = getRuntimeContext().getDoubleCounter("simple-counter").         // DoubleSumAggregator longAggregator3 = (DoubleSumAggregator)         // getRuntimeContext().getAggregator("custom",         // DoubleSumAggregator.class).         Assert.fail("Should not be able to obtain previously created counter with different type").     } catch (UnsupportedOperationException ex) {     // expected!     }     // Test counter used in open() and closed()     this.openCloseCounter.add(0.5). }
false;public;2;12;;@Override public void flatMap(String value, Collector<Tuple2<String, Integer>> out) {     this.cntNumLines.add(1).     int wordsPerLine = 0.     for (String token : value.toLowerCase().split("\\W+")) {         distinctWords.add(new StringValue(token)).         out.collect(new Tuple2<>(token, 1)).         ++wordsPerLine.     }     wordsPerLineDistribution.add(wordsPerLine). }
false;public;0;6;;@Override public void close() throws Exception {     // Test counter used in open and close only     this.openCloseCounter.add(0.5).     Assert.assertEquals(1, this.openCloseCounter.getLocalValue().intValue()). }
false;public;1;5;;@Override public void open(Configuration parameters) {     this.reduceCalls = getRuntimeContext().getIntCounter("reduce-calls").     this.combineCalls = getRuntimeContext().getIntCounter("combine-calls"). }
false;public;2;5;;@Override public void reduce(Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) {     reduceCalls.add(1).     reduceInternal(values, out). }
false;public;2;5;;@Override public void combine(Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) {     combineCalls.add(1).     reduceInternal(values, out). }
false;private;2;10;;private void reduceInternal(Iterable<Tuple2<String, Integer>> values, Collector<Tuple2<String, Integer>> out) {     int sum = 0.     String key = null.     for (Tuple2<String, Integer> e : values) {         key = e.f0.         sum += e.f1.     }     out.collect(new Tuple2<>(key, sum)). }
false;public;1;4;;@Override public void add(T value) {     this.set.add(value). }
false;public;0;4;;@Override public HashSet<T> getLocalValue() {     return this.set. }
false;public;0;4;;@Override public void resetLocal() {     this.set.clear(). }
false;public;1;5;;@Override public void merge(Accumulator<T, HashSet<T>> other) {     // build union     this.set.addAll(other.getLocalValue()). }
false;public;0;6;;@Override public Accumulator<T, HashSet<T>> clone() {     SetAccumulator<T> result = new SetAccumulator<>().     result.set.addAll(set).     return result. }
