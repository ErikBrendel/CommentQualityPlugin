# id;timestamp;commentText;codeText;commentWords;codeWords
ParallelSessionsEventGenerator -> private void initParallelSessionGenerators(int parallelSessions);1469088690;@param parallelSessions;private void initParallelSessionGenerators(int parallelSessions) {_		for (int i = 0_ i < parallelSessions && streamFactory.getProducedGeneratorsCount() < sessionCountLimit_ ++i) {_			subGeneratorLists.add(streamFactory.newSessionStreamForKey(_					randomGenerator.choseRandomElement(sessionKeys), 0L))__		}_	};param,parallel,sessions;private,void,init,parallel,session,generators,int,parallel,sessions,for,int,i,0,i,parallel,sessions,stream,factory,get,produced,generators,count,session,count,limit,i,sub,generator,lists,add,stream,factory,new,session,stream,for,key,random,generator,chose,random,element,session,keys,0l
ParallelSessionsEventGenerator -> private void initParallelSessionGenerators(int parallelSessions);1469088690;@param parallelSessions the number of parallel sessions to initialize;private void initParallelSessionGenerators(int parallelSessions) {_		for (int i = 0_ i < parallelSessions && generatorFactory.getProducedGeneratorsCount() < sessionCountLimit_ ++i) {_			subGeneratorLists.add(generatorFactory.newSessionGeneratorForKey(_					randomGenerator.choseRandomElement(sessionKeys), 0L))__		}_	};param,parallel,sessions,the,number,of,parallel,sessions,to,initialize;private,void,init,parallel,session,generators,int,parallel,sessions,for,int,i,0,i,parallel,sessions,generator,factory,get,produced,generators,count,session,count,limit,i,sub,generator,lists,add,generator,factory,new,session,generator,for,key,random,generator,chose,random,element,session,keys,0l
ParallelSessionsEventGenerator -> private void initParallelSessionGenerators(int parallelSessions);1499899067;@param parallelSessions the number of parallel sessions to initialize;private void initParallelSessionGenerators(int parallelSessions) {_		for (int i = 0_ i < parallelSessions && generatorFactory.getProducedGeneratorsCount() < sessionCountLimit_ ++i) {_			subGeneratorLists.add(generatorFactory.newSessionGeneratorForKey(_					randomGenerator.chooseRandomElement(sessionKeys), 0L))__		}_	};param,parallel,sessions,the,number,of,parallel,sessions,to,initialize;private,void,init,parallel,session,generators,int,parallel,sessions,for,int,i,0,i,parallel,sessions,generator,factory,get,produced,generators,count,session,count,limit,i,sub,generator,lists,add,generator,factory,new,session,generator,for,key,random,generator,choose,random,element,session,keys,0l
ParallelSessionsEventGenerator -> private void initParallelSessionGenerators(int parallelSessions);1515177485;@param parallelSessions the number of parallel sessions to initialize;private void initParallelSessionGenerators(int parallelSessions) {_		for (int i = 0_ i < parallelSessions && generatorFactory.getProducedGeneratorsCount() < sessionCountLimit_ ++i) {_			subGeneratorLists.add(generatorFactory.newSessionGeneratorForKey(_					randomGenerator.chooseRandomElement(sessionKeys), 0L))__		}_	};param,parallel,sessions,the,number,of,parallel,sessions,to,initialize;private,void,init,parallel,session,generators,int,parallel,sessions,for,int,i,0,i,parallel,sessions,generator,factory,get,produced,generators,count,session,count,limit,i,sub,generator,lists,add,generator,factory,new,session,generator,for,key,random,generator,choose,random,element,session,keys,0l
ParallelSessionsEventGenerator -> public long getWatermark();1469088690;@return a global watermark that is the minimum of all individual watermarks of the sub-generators;public long getWatermark() {_		long watermark = Long.MAX_VALUE___		for (EventGenerator<K, E> sessionEventStream : subGeneratorLists) {_			watermark = Math.min(watermark, sessionEventStream.getLocalWatermark())__		}_		return watermark__	};return,a,global,watermark,that,is,the,minimum,of,all,individual,watermarks,of,the,sub,generators;public,long,get,watermark,long,watermark,long,for,event,generator,k,e,session,event,stream,sub,generator,lists,watermark,math,min,watermark,session,event,stream,get,local,watermark,return,watermark
ParallelSessionsEventGenerator -> public long getWatermark();1469088690;@return a global watermark that is the minimum of all individual watermarks of the sub-generators;public long getWatermark() {_		long watermark = Long.MAX_VALUE___		for (EventGenerator<K, E> eventGenerator : subGeneratorLists) {_			watermark = Math.min(watermark, eventGenerator.getLocalWatermark())__		}_		return watermark__	};return,a,global,watermark,that,is,the,minimum,of,all,individual,watermarks,of,the,sub,generators;public,long,get,watermark,long,watermark,long,for,event,generator,k,e,event,generator,sub,generator,lists,watermark,math,min,watermark,event,generator,get,local,watermark,return,watermark
ParallelSessionsEventGenerator -> public long getWatermark();1499899067;@return a global watermark that is the minimum of all individual watermarks of the sub-generators;public long getWatermark() {_		long watermark = Long.MAX_VALUE___		for (EventGenerator<K, E> eventGenerator : subGeneratorLists) {_			watermark = Math.min(watermark, eventGenerator.getLocalWatermark())__		}_		return watermark__	};return,a,global,watermark,that,is,the,minimum,of,all,individual,watermarks,of,the,sub,generators;public,long,get,watermark,long,watermark,long,for,event,generator,k,e,event,generator,sub,generator,lists,watermark,math,min,watermark,event,generator,get,local,watermark,return,watermark
ParallelSessionsEventGenerator -> public long getWatermark();1515177485;@return a global watermark that is the minimum of all individual watermarks of the sub-generators;public long getWatermark() {_		long watermark = Long.MAX_VALUE___		for (EventGenerator<K, E> eventGenerator : subGeneratorLists) {_			watermark = Math.min(watermark, eventGenerator.getLocalWatermark())__		}_		return watermark__	};return,a,global,watermark,that,is,the,minimum,of,all,individual,watermarks,of,the,sub,generators;public,long,get,watermark,long,watermark,long,for,event,generator,k,e,event,generator,sub,generator,lists,watermark,math,min,watermark,event,generator,get,local,watermark,return,watermark
ParallelSessionsEventGenerator -> public E nextEvent();1469088690;@return;public E nextEvent() {__		_		if (subGeneratorLists.isEmpty()) {_			return null__		}__		final long globalWatermark = getWatermark()___		_		_		final int choice = randomGenerator.choseRandomIndex(subGeneratorLists)___		for (int i = choice_ i < choice + subGeneratorLists.size()_ ++i) {__			final int index = i % subGeneratorLists.size()__			EventGenerator<K, E> subGenerator = subGeneratorLists.get(index)___			_			if (subGenerator.canProduceEventAtWatermark(globalWatermark)) {__				E event = subGenerator.generateEvent(globalWatermark)___				_				if (!subGenerator.hasMoreEvents()) {__					_					if (streamFactory.getProducedGeneratorsCount() < sessionCountLimit) {_						subGeneratorLists.set(index,_								streamFactory.newSessionStreamForKey(_										randomGenerator.choseRandomElement(sessionKeys), getWatermark()))__					} else {_						_						subGeneratorLists.remove(index)__					}_				}_				return event__			}_		}__		_		throw new IllegalStateException("Unable to find an open sub-generator that can produce events")___	};return;public,e,next,event,if,sub,generator,lists,is,empty,return,null,final,long,global,watermark,get,watermark,final,int,choice,random,generator,chose,random,index,sub,generator,lists,for,int,i,choice,i,choice,sub,generator,lists,size,i,final,int,index,i,sub,generator,lists,size,event,generator,k,e,sub,generator,sub,generator,lists,get,index,if,sub,generator,can,produce,event,at,watermark,global,watermark,e,event,sub,generator,generate,event,global,watermark,if,sub,generator,has,more,events,if,stream,factory,get,produced,generators,count,session,count,limit,sub,generator,lists,set,index,stream,factory,new,session,stream,for,key,random,generator,chose,random,element,session,keys,get,watermark,else,sub,generator,lists,remove,index,return,event,throw,new,illegal,state,exception,unable,to,find,an,open,sub,generator,that,can,produce,events
ParallelSessionsEventGenerator -> public E nextEvent();1469088690;@return the next generated event;public E nextEvent() {__		_		if (subGeneratorLists.isEmpty()) {_			return null__		}__		final long globalWatermark = getWatermark()___		_		_		final int choice = randomGenerator.choseRandomIndex(subGeneratorLists)___		for (int i = choice_ i < choice + subGeneratorLists.size()_ ++i) {__			final int index = i % subGeneratorLists.size()__			EventGenerator<K, E> subGenerator = subGeneratorLists.get(index)___			_			if (subGenerator.canGenerateEventAtWatermark(globalWatermark)) {__				E event = subGenerator.generateEvent(globalWatermark)___				_				if (!subGenerator.hasMoreEvents()) {__					_					if (generatorFactory.getProducedGeneratorsCount() < sessionCountLimit) {_						subGeneratorLists.set(index,_								generatorFactory.newSessionGeneratorForKey(_										randomGenerator.choseRandomElement(sessionKeys), getWatermark()))__					} else {_						_						subGeneratorLists.remove(index)__					}_				}_				return event__			}_		}__		_		throw new IllegalStateException("Unable to find an open sub-generator that can produce events")___	};return,the,next,generated,event;public,e,next,event,if,sub,generator,lists,is,empty,return,null,final,long,global,watermark,get,watermark,final,int,choice,random,generator,chose,random,index,sub,generator,lists,for,int,i,choice,i,choice,sub,generator,lists,size,i,final,int,index,i,sub,generator,lists,size,event,generator,k,e,sub,generator,sub,generator,lists,get,index,if,sub,generator,can,generate,event,at,watermark,global,watermark,e,event,sub,generator,generate,event,global,watermark,if,sub,generator,has,more,events,if,generator,factory,get,produced,generators,count,session,count,limit,sub,generator,lists,set,index,generator,factory,new,session,generator,for,key,random,generator,chose,random,element,session,keys,get,watermark,else,sub,generator,lists,remove,index,return,event,throw,new,illegal,state,exception,unable,to,find,an,open,sub,generator,that,can,produce,events
ParallelSessionsEventGenerator -> public E nextEvent();1499899067;@return the next generated event;public E nextEvent() {__		_		if (subGeneratorLists.isEmpty()) {_			return null__		}__		final long globalWatermark = getWatermark()___		_		_		final int choice = randomGenerator.choseRandomIndex(subGeneratorLists)___		for (int i = choice_ i < choice + subGeneratorLists.size()_ ++i) {__			final int index = i % subGeneratorLists.size()__			EventGenerator<K, E> subGenerator = subGeneratorLists.get(index)___			_			if (subGenerator.canGenerateEventAtWatermark(globalWatermark)) {__				E event = subGenerator.generateEvent(globalWatermark)___				_				if (!subGenerator.hasMoreEvents()) {__					_					if (generatorFactory.getProducedGeneratorsCount() < sessionCountLimit) {_						subGeneratorLists.set(index,_								generatorFactory.newSessionGeneratorForKey(_										randomGenerator.chooseRandomElement(sessionKeys), getWatermark()))__					} else {_						_						subGeneratorLists.remove(index)__					}_				}_				return event__			}_		}__		_		throw new IllegalStateException("Unable to find an open sub-generator that can produce events")___	};return,the,next,generated,event;public,e,next,event,if,sub,generator,lists,is,empty,return,null,final,long,global,watermark,get,watermark,final,int,choice,random,generator,chose,random,index,sub,generator,lists,for,int,i,choice,i,choice,sub,generator,lists,size,i,final,int,index,i,sub,generator,lists,size,event,generator,k,e,sub,generator,sub,generator,lists,get,index,if,sub,generator,can,generate,event,at,watermark,global,watermark,e,event,sub,generator,generate,event,global,watermark,if,sub,generator,has,more,events,if,generator,factory,get,produced,generators,count,session,count,limit,sub,generator,lists,set,index,generator,factory,new,session,generator,for,key,random,generator,choose,random,element,session,keys,get,watermark,else,sub,generator,lists,remove,index,return,event,throw,new,illegal,state,exception,unable,to,find,an,open,sub,generator,that,can,produce,events
ParallelSessionsEventGenerator -> public E nextEvent();1515177485;@return the next generated event;public E nextEvent() {__		_		if (subGeneratorLists.isEmpty()) {_			return null__		}__		final long globalWatermark = getWatermark()___		_		_		final int choice = randomGenerator.choseRandomIndex(subGeneratorLists)___		for (int i = choice_ i < choice + subGeneratorLists.size()_ ++i) {__			final int index = i % subGeneratorLists.size()__			EventGenerator<K, E> subGenerator = subGeneratorLists.get(index)___			_			if (subGenerator.canGenerateEventAtWatermark(globalWatermark)) {__				E event = subGenerator.generateEvent(globalWatermark)___				_				if (!subGenerator.hasMoreEvents()) {__					_					if (generatorFactory.getProducedGeneratorsCount() < sessionCountLimit) {_						subGeneratorLists.set(index,_								generatorFactory.newSessionGeneratorForKey(_										randomGenerator.chooseRandomElement(sessionKeys), getWatermark()))__					} else {_						_						subGeneratorLists.remove(index)__					}_				}_				return event__			}_		}__		_		throw new IllegalStateException("Unable to find an open sub-generator that can produce events")___	};return,the,next,generated,event;public,e,next,event,if,sub,generator,lists,is,empty,return,null,final,long,global,watermark,get,watermark,final,int,choice,random,generator,chose,random,index,sub,generator,lists,for,int,i,choice,i,choice,sub,generator,lists,size,i,final,int,index,i,sub,generator,lists,size,event,generator,k,e,sub,generator,sub,generator,lists,get,index,if,sub,generator,can,generate,event,at,watermark,global,watermark,e,event,sub,generator,generate,event,global,watermark,if,sub,generator,has,more,events,if,generator,factory,get,produced,generators,count,session,count,limit,sub,generator,lists,set,index,generator,factory,new,session,generator,for,key,random,generator,choose,random,element,session,keys,get,watermark,else,sub,generator,lists,remove,index,return,event,throw,new,illegal,state,exception,unable,to,find,an,open,sub,generator,that,can,produce,events
