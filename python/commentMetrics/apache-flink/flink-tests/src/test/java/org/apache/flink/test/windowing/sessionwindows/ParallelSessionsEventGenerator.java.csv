commented;modifiers;parameterAmount;loc;comment;code
true;public;0;44;/**  * @return the next generated event  */ ;/**  * @return the next generated event  */ public E nextEvent() {     // the session limit is reached and all generators are exhausted     if (subGeneratorLists.isEmpty()) {         return null.     }     final long globalWatermark = getWatermark().     // iterates at most once over all sub-generators, starting at a randomly chosen index to find one that can     // currently produce events     final int choice = randomGenerator.choseRandomIndex(subGeneratorLists).     for (int i = choice. i < choice + subGeneratorLists.size(). ++i) {         final int index = i % subGeneratorLists.size().         EventGenerator<K, E> subGenerator = subGeneratorLists.get(index).         // check if the sub-generator can produce an event under the current global watermark         if (subGenerator.canGenerateEventAtWatermark(globalWatermark)) {             E event = subGenerator.generateEvent(globalWatermark).             // check if the sub-generator produced it's last event             if (!subGenerator.hasMoreEvents()) {                 // replaces exhausted generator if the session limit is not met                 if (generatorFactory.getProducedGeneratorsCount() < sessionCountLimit) {                     subGeneratorLists.set(index, generatorFactory.newSessionGeneratorForKey(randomGenerator.chooseRandomElement(sessionKeys), getWatermark())).                 } else {                     // otherwise removes the sub-generator and shrinks the list of open sessions permanently                     subGeneratorLists.remove(index).                 }             }             return event.         }     }     // if everything works correctly, this should never happen     throw new IllegalStateException("Unable to find an open sub-generator that can produce events"). }
true;public;0;8;/**  * @return a global watermark that is the minimum of all individual watermarks of the sub-generators  */ ;/**  * @return a global watermark that is the minimum of all individual watermarks of the sub-generators  */ public long getWatermark() {     long watermark = Long.MAX_VALUE.     for (EventGenerator<K, E> eventGenerator : subGeneratorLists) {         watermark = Math.min(watermark, eventGenerator.getLocalWatermark()).     }     return watermark. }
true;private;1;6;/**  * @param parallelSessions the number of parallel sessions to initialize  */ ;/**  * @param parallelSessions the number of parallel sessions to initialize  */ private void initParallelSessionGenerators(int parallelSessions) {     for (int i = 0. i < parallelSessions && generatorFactory.getProducedGeneratorsCount() < sessionCountLimit. ++i) {         subGeneratorLists.add(generatorFactory.newSessionGeneratorForKey(randomGenerator.chooseRandomElement(sessionKeys), 0L)).     } }
