# id;timestamp;commentText;codeText;commentWords;codeWords
CustomDistributionITCase -> @Test 	public void testPartitionWithDistribution1() throws Exception;1499899067;Test the record partitioned rightly with one field according to the customized data distribution.;@Test_	public void testPartitionWithDistribution1() throws Exception {_		final TestDataDist1 dist = new TestDataDist1()___		final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(dist.getParallelism())___		DataSet<Tuple3<Integer, Long, String>> input = CollectionDataSets.get3TupleDataSet(env)___		DataSet<Boolean> result = DataSetUtils_			.partitionByRange(input, dist, 0)_			.mapPartition(new RichMapPartitionFunction<Tuple3<Integer, Long, String>, Boolean>() {__				@Override_				public void mapPartition(Iterable<Tuple3<Integer, Long, String>> values, Collector<Boolean> out) throws Exception {_					int pIdx = getRuntimeContext().getIndexOfThisSubtask()___					for (Tuple3<Integer, Long, String> s : values) {_						boolean correctlyPartitioned = true__						if (pIdx == 0) {_							Integer[] upper = dist.boundaries[0]__							if (s.f0.compareTo(upper[0]) > 0) {_								correctlyPartitioned = false__							}_						}_						else if (pIdx > 0 && pIdx < dist.getParallelism() - 1) {_							Integer[] lower = dist.boundaries[pIdx - 1]__							Integer[] upper = dist.boundaries[pIdx]__							if (s.f0.compareTo(upper[0]) > 0 || (s.f0.compareTo(lower[0]) <= 0)) {_								correctlyPartitioned = false__							}_						}_						else {_							Integer[] lower = dist.boundaries[pIdx - 1]__							if ((s.f0.compareTo(lower[0]) <= 0)) {_								correctlyPartitioned = false__							}_						}__						if (!correctlyPartitioned) {_							fail("Record was not correctly partitioned: " + s.toString())__						}_					}_				}_			}_			)___		result.output(new DiscardingOutputFormat<Boolean>())__		env.execute()__	};test,the,record,partitioned,rightly,with,one,field,according,to,the,customized,data,distribution;test,public,void,test,partition,with,distribution1,throws,exception,final,test,data,dist1,dist,new,test,data,dist1,final,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,dist,get,parallelism,data,set,tuple3,integer,long,string,input,collection,data,sets,get3tuple,data,set,env,data,set,boolean,result,data,set,utils,partition,by,range,input,dist,0,map,partition,new,rich,map,partition,function,tuple3,integer,long,string,boolean,override,public,void,map,partition,iterable,tuple3,integer,long,string,values,collector,boolean,out,throws,exception,int,p,idx,get,runtime,context,get,index,of,this,subtask,for,tuple3,integer,long,string,s,values,boolean,correctly,partitioned,true,if,p,idx,0,integer,upper,dist,boundaries,0,if,s,f0,compare,to,upper,0,0,correctly,partitioned,false,else,if,p,idx,0,p,idx,dist,get,parallelism,1,integer,lower,dist,boundaries,p,idx,1,integer,upper,dist,boundaries,p,idx,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,lower,0,0,correctly,partitioned,false,else,integer,lower,dist,boundaries,p,idx,1,if,s,f0,compare,to,lower,0,0,correctly,partitioned,false,if,correctly,partitioned,fail,record,was,not,correctly,partitioned,s,to,string,result,output,new,discarding,output,format,boolean,env,execute
CustomDistributionITCase -> @Test 	public void testPartitionWithDistribution1() throws Exception;1519674120;Test the record partitioned rightly with one field according to the customized data distribution.;@Test_	public void testPartitionWithDistribution1() throws Exception {_		final TestDataDist1 dist = new TestDataDist1()___		final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(dist.getParallelism())___		DataSet<Tuple3<Integer, Long, String>> input = CollectionDataSets.get3TupleDataSet(env)___		DataSet<Boolean> result = DataSetUtils_			.partitionByRange(input, dist, 0)_			.mapPartition(new RichMapPartitionFunction<Tuple3<Integer, Long, String>, Boolean>() {__				@Override_				public void mapPartition(Iterable<Tuple3<Integer, Long, String>> values, Collector<Boolean> out) throws Exception {_					int pIdx = getRuntimeContext().getIndexOfThisSubtask()___					for (Tuple3<Integer, Long, String> s : values) {_						boolean correctlyPartitioned = true__						if (pIdx == 0) {_							Integer[] upper = dist.boundaries[0]__							if (s.f0.compareTo(upper[0]) > 0) {_								correctlyPartitioned = false__							}_						}_						else if (pIdx > 0 && pIdx < dist.getParallelism() - 1) {_							Integer[] lower = dist.boundaries[pIdx - 1]__							Integer[] upper = dist.boundaries[pIdx]__							if (s.f0.compareTo(upper[0]) > 0 || (s.f0.compareTo(lower[0]) <= 0)) {_								correctlyPartitioned = false__							}_						}_						else {_							Integer[] lower = dist.boundaries[pIdx - 1]__							if ((s.f0.compareTo(lower[0]) <= 0)) {_								correctlyPartitioned = false__							}_						}__						if (!correctlyPartitioned) {_							fail("Record was not correctly partitioned: " + s.toString())__						}_					}_				}_			}_			)___		result.output(new DiscardingOutputFormat<Boolean>())__		env.execute()__	};test,the,record,partitioned,rightly,with,one,field,according,to,the,customized,data,distribution;test,public,void,test,partition,with,distribution1,throws,exception,final,test,data,dist1,dist,new,test,data,dist1,final,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,dist,get,parallelism,data,set,tuple3,integer,long,string,input,collection,data,sets,get3tuple,data,set,env,data,set,boolean,result,data,set,utils,partition,by,range,input,dist,0,map,partition,new,rich,map,partition,function,tuple3,integer,long,string,boolean,override,public,void,map,partition,iterable,tuple3,integer,long,string,values,collector,boolean,out,throws,exception,int,p,idx,get,runtime,context,get,index,of,this,subtask,for,tuple3,integer,long,string,s,values,boolean,correctly,partitioned,true,if,p,idx,0,integer,upper,dist,boundaries,0,if,s,f0,compare,to,upper,0,0,correctly,partitioned,false,else,if,p,idx,0,p,idx,dist,get,parallelism,1,integer,lower,dist,boundaries,p,idx,1,integer,upper,dist,boundaries,p,idx,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,lower,0,0,correctly,partitioned,false,else,integer,lower,dist,boundaries,p,idx,1,if,s,f0,compare,to,lower,0,0,correctly,partitioned,false,if,correctly,partitioned,fail,record,was,not,correctly,partitioned,s,to,string,result,output,new,discarding,output,format,boolean,env,execute
CustomDistributionITCase -> @Test 	public void testPartitionWithDistribution1() throws Exception;1529682304;Test the record partitioned rightly with one field according to the customized data distribution.;@Test_	public void testPartitionWithDistribution1() throws Exception {_		final TestDataDist1 dist = new TestDataDist1()___		final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(dist.getParallelism())___		DataSet<Tuple3<Integer, Long, String>> input = CollectionDataSets.get3TupleDataSet(env)___		DataSet<Boolean> result = DataSetUtils_			.partitionByRange(input, dist, 0)_			.mapPartition(new RichMapPartitionFunction<Tuple3<Integer, Long, String>, Boolean>() {__				@Override_				public void mapPartition(Iterable<Tuple3<Integer, Long, String>> values, Collector<Boolean> out) throws Exception {_					int pIdx = getRuntimeContext().getIndexOfThisSubtask()___					for (Tuple3<Integer, Long, String> s : values) {_						boolean correctlyPartitioned = true__						if (pIdx == 0) {_							Integer[] upper = dist.boundaries[0]__							if (s.f0.compareTo(upper[0]) > 0) {_								correctlyPartitioned = false__							}_						}_						else if (pIdx > 0 && pIdx < dist.getParallelism() - 1) {_							Integer[] lower = dist.boundaries[pIdx - 1]__							Integer[] upper = dist.boundaries[pIdx]__							if (s.f0.compareTo(upper[0]) > 0 || (s.f0.compareTo(lower[0]) <= 0)) {_								correctlyPartitioned = false__							}_						}_						else {_							Integer[] lower = dist.boundaries[pIdx - 1]__							if ((s.f0.compareTo(lower[0]) <= 0)) {_								correctlyPartitioned = false__							}_						}__						if (!correctlyPartitioned) {_							fail("Record was not correctly partitioned: " + s.toString())__						}_					}_				}_			}_			)___		result.output(new DiscardingOutputFormat<Boolean>())__		env.execute()__	};test,the,record,partitioned,rightly,with,one,field,according,to,the,customized,data,distribution;test,public,void,test,partition,with,distribution1,throws,exception,final,test,data,dist1,dist,new,test,data,dist1,final,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,dist,get,parallelism,data,set,tuple3,integer,long,string,input,collection,data,sets,get3tuple,data,set,env,data,set,boolean,result,data,set,utils,partition,by,range,input,dist,0,map,partition,new,rich,map,partition,function,tuple3,integer,long,string,boolean,override,public,void,map,partition,iterable,tuple3,integer,long,string,values,collector,boolean,out,throws,exception,int,p,idx,get,runtime,context,get,index,of,this,subtask,for,tuple3,integer,long,string,s,values,boolean,correctly,partitioned,true,if,p,idx,0,integer,upper,dist,boundaries,0,if,s,f0,compare,to,upper,0,0,correctly,partitioned,false,else,if,p,idx,0,p,idx,dist,get,parallelism,1,integer,lower,dist,boundaries,p,idx,1,integer,upper,dist,boundaries,p,idx,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,lower,0,0,correctly,partitioned,false,else,integer,lower,dist,boundaries,p,idx,1,if,s,f0,compare,to,lower,0,0,correctly,partitioned,false,if,correctly,partitioned,fail,record,was,not,correctly,partitioned,s,to,string,result,output,new,discarding,output,format,boolean,env,execute
CustomDistributionITCase -> @Test 	public void testPartitionWithDistribution1() throws Exception;1540389860;Test the record partitioned rightly with one field according to the customized data distribution.;@Test_	public void testPartitionWithDistribution1() throws Exception {_		final TestDataDist1 dist = new TestDataDist1()___		final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(dist.getParallelism())___		DataSet<Tuple3<Integer, Long, String>> input = CollectionDataSets.get3TupleDataSet(env)___		DataSet<Boolean> result = DataSetUtils_			.partitionByRange(input, dist, 0)_			.mapPartition(new RichMapPartitionFunction<Tuple3<Integer, Long, String>, Boolean>() {__				@Override_				public void mapPartition(Iterable<Tuple3<Integer, Long, String>> values, Collector<Boolean> out) throws Exception {_					int pIdx = getRuntimeContext().getIndexOfThisSubtask()___					for (Tuple3<Integer, Long, String> s : values) {_						boolean correctlyPartitioned = true__						if (pIdx == 0) {_							Integer[] upper = dist.boundaries[0]__							if (s.f0.compareTo(upper[0]) > 0) {_								correctlyPartitioned = false__							}_						}_						else if (pIdx > 0 && pIdx < dist.getParallelism() - 1) {_							Integer[] lower = dist.boundaries[pIdx - 1]__							Integer[] upper = dist.boundaries[pIdx]__							if (s.f0.compareTo(upper[0]) > 0 || (s.f0.compareTo(lower[0]) <= 0)) {_								correctlyPartitioned = false__							}_						}_						else {_							Integer[] lower = dist.boundaries[pIdx - 1]__							if ((s.f0.compareTo(lower[0]) <= 0)) {_								correctlyPartitioned = false__							}_						}__						if (!correctlyPartitioned) {_							fail("Record was not correctly partitioned: " + s.toString())__						}_					}_				}_			}_			)___		result.output(new DiscardingOutputFormat<Boolean>())__		env.execute()__	};test,the,record,partitioned,rightly,with,one,field,according,to,the,customized,data,distribution;test,public,void,test,partition,with,distribution1,throws,exception,final,test,data,dist1,dist,new,test,data,dist1,final,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,dist,get,parallelism,data,set,tuple3,integer,long,string,input,collection,data,sets,get3tuple,data,set,env,data,set,boolean,result,data,set,utils,partition,by,range,input,dist,0,map,partition,new,rich,map,partition,function,tuple3,integer,long,string,boolean,override,public,void,map,partition,iterable,tuple3,integer,long,string,values,collector,boolean,out,throws,exception,int,p,idx,get,runtime,context,get,index,of,this,subtask,for,tuple3,integer,long,string,s,values,boolean,correctly,partitioned,true,if,p,idx,0,integer,upper,dist,boundaries,0,if,s,f0,compare,to,upper,0,0,correctly,partitioned,false,else,if,p,idx,0,p,idx,dist,get,parallelism,1,integer,lower,dist,boundaries,p,idx,1,integer,upper,dist,boundaries,p,idx,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,lower,0,0,correctly,partitioned,false,else,integer,lower,dist,boundaries,p,idx,1,if,s,f0,compare,to,lower,0,0,correctly,partitioned,false,if,correctly,partitioned,fail,record,was,not,correctly,partitioned,s,to,string,result,output,new,discarding,output,format,boolean,env,execute
CustomDistributionITCase -> @Test 	public void testRangeWithDistribution2() throws Exception;1499899067;Test the record partitioned rightly with two fields according to the customized data distribution.;@Test_	public void testRangeWithDistribution2() throws Exception {_		final TestDataDist2 dist = new TestDataDist2()___		final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(dist.getParallelism())___		DataSet<Tuple3<Integer, Integer, String>> input = env.fromElements(_						new Tuple3<>(1, 5, "Hi"),_						new Tuple3<>(1, 6, "Hi"),_						new Tuple3<>(1, 7, "Hi"),_						new Tuple3<>(1, 11, "Hello"),_						new Tuple3<>(2, 3, "World"),_						new Tuple3<>(2, 4, "World"),_						new Tuple3<>(2, 5, "World"),_						new Tuple3<>(2, 13, "Hello World"),_						new Tuple3<>(3, 8, "Say"),_						new Tuple3<>(4, 0, "Why"),_						new Tuple3<>(4, 2, "Java"),_						new Tuple3<>(4, 11, "Say Hello"),_						new Tuple3<>(5, 1, "Hi Java!"),_						new Tuple3<>(5, 2, "Hi Java?"),_						new Tuple3<>(5, 3, "Hi Java again")_			)___		DataSet<Boolean> result = DataSetUtils_			.partitionByRange(input, dist, 0, 1)_			.mapPartition(new RichMapPartitionFunction<Tuple3<Integer, Integer, String>, Boolean>() {__				@Override_				public void mapPartition(Iterable<Tuple3<Integer, Integer, String>> values, Collector<Boolean> out) throws Exception {_					int pIdx = getRuntimeContext().getIndexOfThisSubtask()__					boolean correctlyPartitioned = true___					for (Tuple3<Integer, Integer, String> s : values) {__						if (pIdx == 0) {_							Integer[] upper = dist.boundaries[0]__							if (s.f0.compareTo(upper[0]) > 0 ||_								(s.f0.compareTo(upper[0]) == 0 && s.f1.compareTo(upper[1]) > 0)) {_								correctlyPartitioned = false__							}_						}_						else if (pIdx > 0 && pIdx < dist.getParallelism() - 1) {_							Integer[] lower = dist.boundaries[pIdx - 1]__							Integer[] upper = dist.boundaries[pIdx]___							if (s.f0.compareTo(upper[0]) > 0 ||_								(s.f0.compareTo(upper[0]) == 0 && s.f1.compareTo(upper[1]) > 0) ||_								(s.f0.compareTo(lower[0]) < 0) ||_								(s.f0.compareTo(lower[0]) == 0 && s.f1.compareTo(lower[1]) <= 0)) {_								correctlyPartitioned = false__							}_						}_						else {_							Integer[] lower = dist.boundaries[pIdx - 1]__							if ((s.f0.compareTo(lower[0]) < 0) ||_								(s.f0.compareTo(lower[0]) == 0 && s.f1.compareTo(lower[1]) <= 0)) {_								correctlyPartitioned = false__							}_						}__						if (!correctlyPartitioned) {_							fail("Record was not correctly partitioned: " + s.toString())__						}_					}_				}_			}_			)___		result.output(new DiscardingOutputFormat<Boolean>())__		env.execute()__	};test,the,record,partitioned,rightly,with,two,fields,according,to,the,customized,data,distribution;test,public,void,test,range,with,distribution2,throws,exception,final,test,data,dist2,dist,new,test,data,dist2,final,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,dist,get,parallelism,data,set,tuple3,integer,integer,string,input,env,from,elements,new,tuple3,1,5,hi,new,tuple3,1,6,hi,new,tuple3,1,7,hi,new,tuple3,1,11,hello,new,tuple3,2,3,world,new,tuple3,2,4,world,new,tuple3,2,5,world,new,tuple3,2,13,hello,world,new,tuple3,3,8,say,new,tuple3,4,0,why,new,tuple3,4,2,java,new,tuple3,4,11,say,hello,new,tuple3,5,1,hi,java,new,tuple3,5,2,hi,java,new,tuple3,5,3,hi,java,again,data,set,boolean,result,data,set,utils,partition,by,range,input,dist,0,1,map,partition,new,rich,map,partition,function,tuple3,integer,integer,string,boolean,override,public,void,map,partition,iterable,tuple3,integer,integer,string,values,collector,boolean,out,throws,exception,int,p,idx,get,runtime,context,get,index,of,this,subtask,boolean,correctly,partitioned,true,for,tuple3,integer,integer,string,s,values,if,p,idx,0,integer,upper,dist,boundaries,0,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,upper,0,0,s,f1,compare,to,upper,1,0,correctly,partitioned,false,else,if,p,idx,0,p,idx,dist,get,parallelism,1,integer,lower,dist,boundaries,p,idx,1,integer,upper,dist,boundaries,p,idx,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,upper,0,0,s,f1,compare,to,upper,1,0,s,f0,compare,to,lower,0,0,s,f0,compare,to,lower,0,0,s,f1,compare,to,lower,1,0,correctly,partitioned,false,else,integer,lower,dist,boundaries,p,idx,1,if,s,f0,compare,to,lower,0,0,s,f0,compare,to,lower,0,0,s,f1,compare,to,lower,1,0,correctly,partitioned,false,if,correctly,partitioned,fail,record,was,not,correctly,partitioned,s,to,string,result,output,new,discarding,output,format,boolean,env,execute
CustomDistributionITCase -> @Test 	public void testRangeWithDistribution2() throws Exception;1519674120;Test the record partitioned rightly with two fields according to the customized data distribution.;@Test_	public void testRangeWithDistribution2() throws Exception {_		final TestDataDist2 dist = new TestDataDist2()___		final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(dist.getParallelism())___		DataSet<Tuple3<Integer, Integer, String>> input = env.fromElements(_						new Tuple3<>(1, 5, "Hi"),_						new Tuple3<>(1, 6, "Hi"),_						new Tuple3<>(1, 7, "Hi"),_						new Tuple3<>(1, 11, "Hello"),_						new Tuple3<>(2, 3, "World"),_						new Tuple3<>(2, 4, "World"),_						new Tuple3<>(2, 5, "World"),_						new Tuple3<>(2, 13, "Hello World"),_						new Tuple3<>(3, 8, "Say"),_						new Tuple3<>(4, 0, "Why"),_						new Tuple3<>(4, 2, "Java"),_						new Tuple3<>(4, 11, "Say Hello"),_						new Tuple3<>(5, 1, "Hi Java!"),_						new Tuple3<>(5, 2, "Hi Java?"),_						new Tuple3<>(5, 3, "Hi Java again")_			)___		DataSet<Boolean> result = DataSetUtils_			.partitionByRange(input, dist, 0, 1)_			.mapPartition(new RichMapPartitionFunction<Tuple3<Integer, Integer, String>, Boolean>() {__				@Override_				public void mapPartition(Iterable<Tuple3<Integer, Integer, String>> values, Collector<Boolean> out) throws Exception {_					int pIdx = getRuntimeContext().getIndexOfThisSubtask()__					boolean correctlyPartitioned = true___					for (Tuple3<Integer, Integer, String> s : values) {__						if (pIdx == 0) {_							Integer[] upper = dist.boundaries[0]__							if (s.f0.compareTo(upper[0]) > 0 ||_								(s.f0.compareTo(upper[0]) == 0 && s.f1.compareTo(upper[1]) > 0)) {_								correctlyPartitioned = false__							}_						}_						else if (pIdx > 0 && pIdx < dist.getParallelism() - 1) {_							Integer[] lower = dist.boundaries[pIdx - 1]__							Integer[] upper = dist.boundaries[pIdx]___							if (s.f0.compareTo(upper[0]) > 0 ||_								(s.f0.compareTo(upper[0]) == 0 && s.f1.compareTo(upper[1]) > 0) ||_								(s.f0.compareTo(lower[0]) < 0) ||_								(s.f0.compareTo(lower[0]) == 0 && s.f1.compareTo(lower[1]) <= 0)) {_								correctlyPartitioned = false__							}_						}_						else {_							Integer[] lower = dist.boundaries[pIdx - 1]__							if ((s.f0.compareTo(lower[0]) < 0) ||_								(s.f0.compareTo(lower[0]) == 0 && s.f1.compareTo(lower[1]) <= 0)) {_								correctlyPartitioned = false__							}_						}__						if (!correctlyPartitioned) {_							fail("Record was not correctly partitioned: " + s.toString())__						}_					}_				}_			}_			)___		result.output(new DiscardingOutputFormat<Boolean>())__		env.execute()__	};test,the,record,partitioned,rightly,with,two,fields,according,to,the,customized,data,distribution;test,public,void,test,range,with,distribution2,throws,exception,final,test,data,dist2,dist,new,test,data,dist2,final,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,dist,get,parallelism,data,set,tuple3,integer,integer,string,input,env,from,elements,new,tuple3,1,5,hi,new,tuple3,1,6,hi,new,tuple3,1,7,hi,new,tuple3,1,11,hello,new,tuple3,2,3,world,new,tuple3,2,4,world,new,tuple3,2,5,world,new,tuple3,2,13,hello,world,new,tuple3,3,8,say,new,tuple3,4,0,why,new,tuple3,4,2,java,new,tuple3,4,11,say,hello,new,tuple3,5,1,hi,java,new,tuple3,5,2,hi,java,new,tuple3,5,3,hi,java,again,data,set,boolean,result,data,set,utils,partition,by,range,input,dist,0,1,map,partition,new,rich,map,partition,function,tuple3,integer,integer,string,boolean,override,public,void,map,partition,iterable,tuple3,integer,integer,string,values,collector,boolean,out,throws,exception,int,p,idx,get,runtime,context,get,index,of,this,subtask,boolean,correctly,partitioned,true,for,tuple3,integer,integer,string,s,values,if,p,idx,0,integer,upper,dist,boundaries,0,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,upper,0,0,s,f1,compare,to,upper,1,0,correctly,partitioned,false,else,if,p,idx,0,p,idx,dist,get,parallelism,1,integer,lower,dist,boundaries,p,idx,1,integer,upper,dist,boundaries,p,idx,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,upper,0,0,s,f1,compare,to,upper,1,0,s,f0,compare,to,lower,0,0,s,f0,compare,to,lower,0,0,s,f1,compare,to,lower,1,0,correctly,partitioned,false,else,integer,lower,dist,boundaries,p,idx,1,if,s,f0,compare,to,lower,0,0,s,f0,compare,to,lower,0,0,s,f1,compare,to,lower,1,0,correctly,partitioned,false,if,correctly,partitioned,fail,record,was,not,correctly,partitioned,s,to,string,result,output,new,discarding,output,format,boolean,env,execute
CustomDistributionITCase -> @Test 	public void testRangeWithDistribution2() throws Exception;1529682304;Test the record partitioned rightly with two fields according to the customized data distribution.;@Test_	public void testRangeWithDistribution2() throws Exception {_		final TestDataDist2 dist = new TestDataDist2()___		final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(dist.getParallelism())___		DataSet<Tuple3<Integer, Integer, String>> input = env.fromElements(_						new Tuple3<>(1, 5, "Hi"),_						new Tuple3<>(1, 6, "Hi"),_						new Tuple3<>(1, 7, "Hi"),_						new Tuple3<>(1, 11, "Hello"),_						new Tuple3<>(2, 3, "World"),_						new Tuple3<>(2, 4, "World"),_						new Tuple3<>(2, 5, "World"),_						new Tuple3<>(2, 13, "Hello World"),_						new Tuple3<>(3, 8, "Say"),_						new Tuple3<>(4, 0, "Why"),_						new Tuple3<>(4, 2, "Java"),_						new Tuple3<>(4, 11, "Say Hello"),_						new Tuple3<>(5, 1, "Hi Java!"),_						new Tuple3<>(5, 2, "Hi Java?"),_						new Tuple3<>(5, 3, "Hi Java again")_			)___		DataSet<Boolean> result = DataSetUtils_			.partitionByRange(input, dist, 0, 1)_			.mapPartition(new RichMapPartitionFunction<Tuple3<Integer, Integer, String>, Boolean>() {__				@Override_				public void mapPartition(Iterable<Tuple3<Integer, Integer, String>> values, Collector<Boolean> out) throws Exception {_					int pIdx = getRuntimeContext().getIndexOfThisSubtask()__					boolean correctlyPartitioned = true___					for (Tuple3<Integer, Integer, String> s : values) {__						if (pIdx == 0) {_							Integer[] upper = dist.boundaries[0]__							if (s.f0.compareTo(upper[0]) > 0 ||_								(s.f0.compareTo(upper[0]) == 0 && s.f1.compareTo(upper[1]) > 0)) {_								correctlyPartitioned = false__							}_						}_						else if (pIdx > 0 && pIdx < dist.getParallelism() - 1) {_							Integer[] lower = dist.boundaries[pIdx - 1]__							Integer[] upper = dist.boundaries[pIdx]___							if (s.f0.compareTo(upper[0]) > 0 ||_								(s.f0.compareTo(upper[0]) == 0 && s.f1.compareTo(upper[1]) > 0) ||_								(s.f0.compareTo(lower[0]) < 0) ||_								(s.f0.compareTo(lower[0]) == 0 && s.f1.compareTo(lower[1]) <= 0)) {_								correctlyPartitioned = false__							}_						}_						else {_							Integer[] lower = dist.boundaries[pIdx - 1]__							if ((s.f0.compareTo(lower[0]) < 0) ||_								(s.f0.compareTo(lower[0]) == 0 && s.f1.compareTo(lower[1]) <= 0)) {_								correctlyPartitioned = false__							}_						}__						if (!correctlyPartitioned) {_							fail("Record was not correctly partitioned: " + s.toString())__						}_					}_				}_			}_			)___		result.output(new DiscardingOutputFormat<Boolean>())__		env.execute()__	};test,the,record,partitioned,rightly,with,two,fields,according,to,the,customized,data,distribution;test,public,void,test,range,with,distribution2,throws,exception,final,test,data,dist2,dist,new,test,data,dist2,final,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,dist,get,parallelism,data,set,tuple3,integer,integer,string,input,env,from,elements,new,tuple3,1,5,hi,new,tuple3,1,6,hi,new,tuple3,1,7,hi,new,tuple3,1,11,hello,new,tuple3,2,3,world,new,tuple3,2,4,world,new,tuple3,2,5,world,new,tuple3,2,13,hello,world,new,tuple3,3,8,say,new,tuple3,4,0,why,new,tuple3,4,2,java,new,tuple3,4,11,say,hello,new,tuple3,5,1,hi,java,new,tuple3,5,2,hi,java,new,tuple3,5,3,hi,java,again,data,set,boolean,result,data,set,utils,partition,by,range,input,dist,0,1,map,partition,new,rich,map,partition,function,tuple3,integer,integer,string,boolean,override,public,void,map,partition,iterable,tuple3,integer,integer,string,values,collector,boolean,out,throws,exception,int,p,idx,get,runtime,context,get,index,of,this,subtask,boolean,correctly,partitioned,true,for,tuple3,integer,integer,string,s,values,if,p,idx,0,integer,upper,dist,boundaries,0,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,upper,0,0,s,f1,compare,to,upper,1,0,correctly,partitioned,false,else,if,p,idx,0,p,idx,dist,get,parallelism,1,integer,lower,dist,boundaries,p,idx,1,integer,upper,dist,boundaries,p,idx,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,upper,0,0,s,f1,compare,to,upper,1,0,s,f0,compare,to,lower,0,0,s,f0,compare,to,lower,0,0,s,f1,compare,to,lower,1,0,correctly,partitioned,false,else,integer,lower,dist,boundaries,p,idx,1,if,s,f0,compare,to,lower,0,0,s,f0,compare,to,lower,0,0,s,f1,compare,to,lower,1,0,correctly,partitioned,false,if,correctly,partitioned,fail,record,was,not,correctly,partitioned,s,to,string,result,output,new,discarding,output,format,boolean,env,execute
CustomDistributionITCase -> @Test 	public void testRangeWithDistribution2() throws Exception;1540389860;Test the record partitioned rightly with two fields according to the customized data distribution.;@Test_	public void testRangeWithDistribution2() throws Exception {_		final TestDataDist2 dist = new TestDataDist2()___		final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(dist.getParallelism())___		DataSet<Tuple3<Integer, Integer, String>> input = env.fromElements(_						new Tuple3<>(1, 5, "Hi"),_						new Tuple3<>(1, 6, "Hi"),_						new Tuple3<>(1, 7, "Hi"),_						new Tuple3<>(1, 11, "Hello"),_						new Tuple3<>(2, 3, "World"),_						new Tuple3<>(2, 4, "World"),_						new Tuple3<>(2, 5, "World"),_						new Tuple3<>(2, 13, "Hello World"),_						new Tuple3<>(3, 8, "Say"),_						new Tuple3<>(4, 0, "Why"),_						new Tuple3<>(4, 2, "Java"),_						new Tuple3<>(4, 11, "Say Hello"),_						new Tuple3<>(5, 1, "Hi Java!"),_						new Tuple3<>(5, 2, "Hi Java?"),_						new Tuple3<>(5, 3, "Hi Java again")_			)___		DataSet<Boolean> result = DataSetUtils_			.partitionByRange(input, dist, 0, 1)_			.mapPartition(new RichMapPartitionFunction<Tuple3<Integer, Integer, String>, Boolean>() {__				@Override_				public void mapPartition(Iterable<Tuple3<Integer, Integer, String>> values, Collector<Boolean> out) throws Exception {_					int pIdx = getRuntimeContext().getIndexOfThisSubtask()__					boolean correctlyPartitioned = true___					for (Tuple3<Integer, Integer, String> s : values) {__						if (pIdx == 0) {_							Integer[] upper = dist.boundaries[0]__							if (s.f0.compareTo(upper[0]) > 0 ||_								(s.f0.compareTo(upper[0]) == 0 && s.f1.compareTo(upper[1]) > 0)) {_								correctlyPartitioned = false__							}_						}_						else if (pIdx > 0 && pIdx < dist.getParallelism() - 1) {_							Integer[] lower = dist.boundaries[pIdx - 1]__							Integer[] upper = dist.boundaries[pIdx]___							if (s.f0.compareTo(upper[0]) > 0 ||_								(s.f0.compareTo(upper[0]) == 0 && s.f1.compareTo(upper[1]) > 0) ||_								(s.f0.compareTo(lower[0]) < 0) ||_								(s.f0.compareTo(lower[0]) == 0 && s.f1.compareTo(lower[1]) <= 0)) {_								correctlyPartitioned = false__							}_						}_						else {_							Integer[] lower = dist.boundaries[pIdx - 1]__							if ((s.f0.compareTo(lower[0]) < 0) ||_								(s.f0.compareTo(lower[0]) == 0 && s.f1.compareTo(lower[1]) <= 0)) {_								correctlyPartitioned = false__							}_						}__						if (!correctlyPartitioned) {_							fail("Record was not correctly partitioned: " + s.toString())__						}_					}_				}_			}_			)___		result.output(new DiscardingOutputFormat<Boolean>())__		env.execute()__	};test,the,record,partitioned,rightly,with,two,fields,according,to,the,customized,data,distribution;test,public,void,test,range,with,distribution2,throws,exception,final,test,data,dist2,dist,new,test,data,dist2,final,execution,environment,env,execution,environment,get,execution,environment,env,set,parallelism,dist,get,parallelism,data,set,tuple3,integer,integer,string,input,env,from,elements,new,tuple3,1,5,hi,new,tuple3,1,6,hi,new,tuple3,1,7,hi,new,tuple3,1,11,hello,new,tuple3,2,3,world,new,tuple3,2,4,world,new,tuple3,2,5,world,new,tuple3,2,13,hello,world,new,tuple3,3,8,say,new,tuple3,4,0,why,new,tuple3,4,2,java,new,tuple3,4,11,say,hello,new,tuple3,5,1,hi,java,new,tuple3,5,2,hi,java,new,tuple3,5,3,hi,java,again,data,set,boolean,result,data,set,utils,partition,by,range,input,dist,0,1,map,partition,new,rich,map,partition,function,tuple3,integer,integer,string,boolean,override,public,void,map,partition,iterable,tuple3,integer,integer,string,values,collector,boolean,out,throws,exception,int,p,idx,get,runtime,context,get,index,of,this,subtask,boolean,correctly,partitioned,true,for,tuple3,integer,integer,string,s,values,if,p,idx,0,integer,upper,dist,boundaries,0,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,upper,0,0,s,f1,compare,to,upper,1,0,correctly,partitioned,false,else,if,p,idx,0,p,idx,dist,get,parallelism,1,integer,lower,dist,boundaries,p,idx,1,integer,upper,dist,boundaries,p,idx,if,s,f0,compare,to,upper,0,0,s,f0,compare,to,upper,0,0,s,f1,compare,to,upper,1,0,s,f0,compare,to,lower,0,0,s,f0,compare,to,lower,0,0,s,f1,compare,to,lower,1,0,correctly,partitioned,false,else,integer,lower,dist,boundaries,p,idx,1,if,s,f0,compare,to,lower,0,0,s,f0,compare,to,lower,0,0,s,f1,compare,to,lower,1,0,correctly,partitioned,false,if,correctly,partitioned,fail,record,was,not,correctly,partitioned,s,to,string,result,output,new,discarding,output,format,boolean,env,execute
