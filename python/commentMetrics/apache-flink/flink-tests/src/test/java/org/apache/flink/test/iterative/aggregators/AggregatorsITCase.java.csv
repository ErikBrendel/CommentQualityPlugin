commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void open(Configuration parameters) throws Exception {     File file = getRuntimeContext().getDistributedCache().getFile(testName).     BufferedReader reader = new BufferedReader(new FileReader(file)).     String output = reader.readLine().     reader.close().     assertEquals(output, testString). }
false;public;1;4;;@Override public boolean filter(Long value) throws Exception {     return false. }
false;public;0;37;;@Test public void testDistributedCacheWithIterations() throws Exception {     final String testString = "Et tu, Brute?".     final String testName = "testing_caesar".     final File folder = tempFolder.newFolder().     final File resultFile = new File(folder, UUID.randomUUID().toString()).     String testPath = resultFile.toString().     String resultPath = resultFile.toURI().toString().     File tempFile = new File(testPath).     try (FileWriter writer = new FileWriter(tempFile)) {         writer.write(testString).     }     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.registerCachedFile(resultPath, testName).     IterativeDataSet<Long> solution = env.fromElements(1L).iterate(2).     solution.closeWith(env.generateSequence(1, 2).filter(new RichFilterFunction<Long>() {          @Override         public void open(Configuration parameters) throws Exception {             File file = getRuntimeContext().getDistributedCache().getFile(testName).             BufferedReader reader = new BufferedReader(new FileReader(file)).             String output = reader.readLine().             reader.close().             assertEquals(output, testString).         }          @Override         public boolean filter(Long value) throws Exception {             return false.         }     }).withBroadcastSet(solution, "SOLUTION")).output(new DiscardingOutputFormat<Long>()).     env.execute(). }
false;public;0;28;;@Test public void testAggregatorWithoutParameterForIterate() throws Exception {     /* 		 * Test aggregator without parameter for iterate 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(parallelism).     DataSet<Integer> initialSolutionSet = CollectionDataSets.getIntegerDataSet(env).     IterativeDataSet<Integer> iteration = initialSolutionSet.iterate(MAX_ITERATIONS).     // register aggregator     LongSumAggregator aggr = new LongSumAggregator().     iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR, aggr).     // register convergence criterion     iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR, aggr, new NegativeElementsConvergenceCriterion()).     DataSet<Integer> updatedDs = iteration.map(new SubtractOneMap()).     List<Integer> result = iteration.closeWith(updatedDs).collect().     Collections.sort(result).     List<Integer> expected = Arrays.asList(-3, -2, -2, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 1, 1).     assertEquals(expected, result). }
false;public;0;28;;@Test public void testAggregatorWithParameterForIterate() throws Exception {     /* 		 * Test aggregator with parameter for iterate 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(parallelism).     DataSet<Integer> initialSolutionSet = CollectionDataSets.getIntegerDataSet(env).     IterativeDataSet<Integer> iteration = initialSolutionSet.iterate(MAX_ITERATIONS).     // register aggregator     LongSumAggregatorWithParameter aggr = new LongSumAggregatorWithParameter(0).     iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR, aggr).     // register convergence criterion     iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR, aggr, new NegativeElementsConvergenceCriterion()).     DataSet<Integer> updatedDs = iteration.map(new SubtractOneMapWithParam()).     List<Integer> result = iteration.closeWith(updatedDs).collect().     Collections.sort(result).     List<Integer> expected = Arrays.asList(-3, -2, -2, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 1, 1).     assertEquals(expected, result). }
false;public;0;28;;@Test public void testConvergenceCriterionWithParameterForIterate() throws Exception {     /* 		 * Test convergence criterion with parameter for iterate 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(parallelism).     DataSet<Integer> initialSolutionSet = CollectionDataSets.getIntegerDataSet(env).     IterativeDataSet<Integer> iteration = initialSolutionSet.iterate(MAX_ITERATIONS).     // register aggregator     LongSumAggregator aggr = new LongSumAggregator().     iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR, aggr).     // register convergence criterion     iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR, aggr, new NegativeElementsConvergenceCriterionWithParam(3)).     DataSet<Integer> updatedDs = iteration.map(new SubtractOneMap()).     List<Integer> result = iteration.closeWith(updatedDs).collect().     Collections.sort(result).     List<Integer> expected = Arrays.asList(-3, -2, -2, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 1, 1).     assertEquals(expected, result). }
false;public;0;31;;@Test public void testAggregatorWithoutParameterForIterateDelta() throws Exception {     /* 		 * Test aggregator without parameter for iterateDelta 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(parallelism).     DataSet<Tuple2<Integer, Integer>> initialSolutionSet = CollectionDataSets.getIntegerDataSet(env).map(new TupleMakerMap()).     DeltaIteration<Tuple2<Integer, Integer>, Tuple2<Integer, Integer>> iteration = initialSolutionSet.iterateDelta(initialSolutionSet, MAX_ITERATIONS, 0).     // register aggregator     LongSumAggregator aggr = new LongSumAggregator().     iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR, aggr).     DataSet<Tuple2<Integer, Integer>> updatedDs = iteration.getWorkset().map(new AggregateMapDelta()).     DataSet<Tuple2<Integer, Integer>> newElements = updatedDs.join(iteration.getSolutionSet()).where(0).equalTo(0).flatMap(new UpdateFilter()).     DataSet<Tuple2<Integer, Integer>> iterationRes = iteration.closeWith(newElements, newElements).     List<Integer> result = iterationRes.map(new ProjectSecondMapper()).collect().     Collections.sort(result).     List<Integer> expected = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5).     assertEquals(expected, result). }
false;public;0;31;;@Test public void testAggregatorWithParameterForIterateDelta() throws Exception {     /* 		 * Test aggregator with parameter for iterateDelta 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(parallelism).     DataSet<Tuple2<Integer, Integer>> initialSolutionSet = CollectionDataSets.getIntegerDataSet(env).map(new TupleMakerMap()).     DeltaIteration<Tuple2<Integer, Integer>, Tuple2<Integer, Integer>> iteration = initialSolutionSet.iterateDelta(initialSolutionSet, MAX_ITERATIONS, 0).     // register aggregator     LongSumAggregator aggr = new LongSumAggregatorWithParameter(4).     iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR, aggr).     DataSet<Tuple2<Integer, Integer>> updatedDs = iteration.getWorkset().map(new AggregateMapDelta()).     DataSet<Tuple2<Integer, Integer>> newElements = updatedDs.join(iteration.getSolutionSet()).where(0).equalTo(0).flatMap(new UpdateFilter()).     DataSet<Tuple2<Integer, Integer>> iterationRes = iteration.closeWith(newElements, newElements).     List<Integer> result = iterationRes.map(new ProjectSecondMapper()).collect().     Collections.sort(result).     List<Integer> expected = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5).     assertEquals(result, expected). }
false;public;0;35;;@Test public void testConvergenceCriterionWithParameterForIterateDelta() throws Exception {     /* 		 * Test convergence criterion with parameter for iterate delta 		 */     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(parallelism).     DataSet<Tuple2<Integer, Integer>> initialSolutionSet = CollectionDataSets.getIntegerDataSet(env).map(new TupleMakerMap()).     DeltaIteration<Tuple2<Integer, Integer>, Tuple2<Integer, Integer>> iteration = initialSolutionSet.iterateDelta(initialSolutionSet, MAX_ITERATIONS, 0).     // register aggregator     LongSumAggregator aggr = new LongSumAggregator().     iteration.registerAggregator(NEGATIVE_ELEMENTS_AGGR, aggr).     // register convergence criterion     iteration.registerAggregationConvergenceCriterion(NEGATIVE_ELEMENTS_AGGR, aggr, new NegativeElementsConvergenceCriterionWithParam(3)).     DataSet<Tuple2<Integer, Integer>> updatedDs = iteration.getWorkset().map(new AggregateAndSubtractOneDelta()).     DataSet<Tuple2<Integer, Integer>> newElements = updatedDs.join(iteration.getSolutionSet()).where(0).equalTo(0).projectFirst(0, 1).     DataSet<Tuple2<Integer, Integer>> iterationRes = iteration.closeWith(newElements, newElements).     List<Integer> result = iterationRes.map(new ProjectSecondMapper()).collect().     Collections.sort(result).     List<Integer> expected = Arrays.asList(-3, -2, -2, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 1, 1).     assertEquals(expected, result). }
false;public;2;4;;@Override public boolean isConverged(int iteration, LongValue value) {     return value.getValue() > 3. }
false;public;0;3;;public int getValue() {     return this.value. }
false;public;2;4;;@Override public boolean isConverged(int iteration, LongValue value) {     return value.getValue() > this.value. }
false;public;1;5;;@Override public void open(Configuration conf) {     aggr = getIterationRuntimeContext().getIterationAggregator(NEGATIVE_ELEMENTS_AGGR). }
false;public;1;9;;@Override public Integer map(Integer value) {     Integer newValue = value - 1.     // count negative numbers     if (newValue < 0) {         aggr.aggregate(1L).     }     return newValue. }
false;public;1;4;;@Override public void open(Configuration conf) {     aggr = getIterationRuntimeContext().getIterationAggregator(NEGATIVE_ELEMENTS_AGGR). }
false;public;1;9;;@Override public Integer map(Integer value) {     Integer newValue = value - 1.     // count numbers less than the aggregator parameter     if (newValue < aggr.getValue()) {         aggr.aggregate(1L).     }     return newValue. }
false;public;0;3;;public int getValue() {     return this.value. }
false;public;1;4;;@Override public void open(Configuration parameters) {     rnd = new Random(0xC0FFEBADBEEFDEADL + getRuntimeContext().getIndexOfThisSubtask()). }
false;public;1;5;;@Override public Tuple2<Integer, Integer> map(Integer value) {     Integer nodeId = rnd.nextInt(100000).     return new Tuple2<>(nodeId, value). }
false;public;1;12;;@Override public void open(Configuration conf) {     aggr = getIterationRuntimeContext().getIterationAggregator(NEGATIVE_ELEMENTS_AGGR).     superstep = getIterationRuntimeContext().getSuperstepNumber().     if (superstep > 1) {         previousAggr = getIterationRuntimeContext().getPreviousIterationAggregate(NEGATIVE_ELEMENTS_AGGR).         // check previous aggregator value         Assert.assertEquals(superstep - 1, previousAggr.getValue()).     } }
false;public;1;8;;@Override public Tuple2<Integer, Integer> map(Tuple2<Integer, Integer> value) {     // count the elements that are equal to the superstep number     if (value.f1 == superstep) {         aggr.aggregate(1L).     }     return value. }
false;public;1;4;;@Override public void open(Configuration conf) {     superstep = getIterationRuntimeContext().getSuperstepNumber(). }
false;public;2;8;;@Override public void flatMap(Tuple2<Tuple2<Integer, Integer>, Tuple2<Integer, Integer>> value, Collector<Tuple2<Integer, Integer>> out) {     if (value.f0.f1 > superstep) {         out.collect(value.f0).     } }
false;public;1;4;;@Override public Integer map(Tuple2<Integer, Integer> value) {     return value.f1. }
false;public;1;12;;@Override public void open(Configuration conf) {     aggr = getIterationRuntimeContext().getIterationAggregator(NEGATIVE_ELEMENTS_AGGR).     superstep = getIterationRuntimeContext().getSuperstepNumber().     if (superstep > 1) {         previousAggr = getIterationRuntimeContext().getPreviousIterationAggregate(NEGATIVE_ELEMENTS_AGGR).         // check previous aggregator value         Assert.assertEquals(superstep - 1, previousAggr.getValue()).     } }
false;public;1;9;;@Override public Tuple2<Integer, Integer> map(Tuple2<Integer, Integer> value) {     // count the ones     if (value.f1 == 1) {         aggr.aggregate(1L).     }     value.f1--.     return value. }
