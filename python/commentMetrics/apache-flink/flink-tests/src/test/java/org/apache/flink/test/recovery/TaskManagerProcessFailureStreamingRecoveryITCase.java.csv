commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public Long map(Long value) throws Exception {     return value. }
false;public;2;45;;@Override public void testTaskManagerFailure(Configuration configuration, final File coordinateDir) throws Exception {     final File tempCheckpointDir = tempFolder.newFolder().     StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", // not needed since we use ZooKeeper     1337, configuration).     env.setParallelism(PARALLELISM).     env.getConfig().disableSysoutLogging().     env.setRestartStrategy(RestartStrategies.fixedDelayRestart(1, 1000)).     env.enableCheckpointing(200).     env.setStateBackend(new FsStateBackend(tempCheckpointDir.getAbsoluteFile().toURI())).     DataStream<Long> result = env.addSource(new SleepyDurableGenerateSequence(coordinateDir, DATA_COUNT)).map(new MapFunction<Long, Long>() {          @Override         public Long map(Long value) throws Exception {             return value.         }     }).startNewChain().map(new Mapper(coordinateDir)).     // write result to temporary file     result.addSink(new CheckpointedSink(DATA_COUNT)).     try {         // blocking call until execution is done         env.execute().     // TODO: Figure out why this fails when ran with other tests     // Check whether checkpoints have been cleaned up properly     // assertDirectoryEmpty(tempCheckpointDir).     } finally {         // clean up         if (tempCheckpointDir.exists()) {             FileUtils.deleteDirectory(tempCheckpointDir).         }     } }
false;public;1;31;;@Override public void run(SourceContext<Long> sourceCtx) throws Exception {     final Object checkpointLock = sourceCtx.getCheckpointLock().     RuntimeContext runtimeCtx = getRuntimeContext().     final long stepSize = runtimeCtx.getNumberOfParallelSubtasks().     final long congruence = runtimeCtx.getIndexOfThisSubtask().     final long toCollect = (end % stepSize > congruence) ? (end / stepSize + 1) : (end / stepSize).     final File proceedFile = new File(coordinateDir, PROCEED_MARKER_FILE).     boolean checkForProceedFile = true.     while (isRunning && collected < toCollect) {         // if not, we always recheck and sleep         if (checkForProceedFile) {             if (proceedFile.exists()) {                 checkForProceedFile = false.             } else {                 // otherwise wait so that we make slow progress                 Thread.sleep(SLEEP_TIME).             }         }         synchronized (checkpointLock) {             sourceCtx.collect(collected * stepSize + congruence).             collected++.         }     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.collected). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.collected = state.get(0). }
false;public;1;9;;@Override public Long map(Long value) throws Exception {     if (!markerCreated) {         int taskIndex = getRuntimeContext().getIndexOfThisSubtask().         touchFile(new File(coordinateDir, READY_MARKER_FILE_PREFIX + taskIndex)).         markerCreated = true.     }     return value. }
false;public;1;6;;@Override public void open(Configuration parameters) throws IOException {     stepSize = getRuntimeContext().getNumberOfParallelSubtasks().     congruence = getRuntimeContext().getIndexOfThisSubtask().     toCollect = (end % stepSize > congruence) ? (end / stepSize + 1) : (end / stepSize). }
false;public;1;13;;@Override public void invoke(Long value) throws Exception {     long expected = collected * stepSize + congruence.     Assert.assertTrue("Value did not match expected value. " + expected + " != " + value, value.equals(expected)).     collected++.     if (collected > toCollect) {         Assert.fail("Collected <= toCollect: " + collected + " > " + toCollect).     } }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) throws Exception {     return Collections.singletonList(this.collected). }
false;public;1;7;;@Override public void restoreState(List<Long> state) throws Exception {     if (state.isEmpty() || state.size() > 1) {         throw new RuntimeException("Test failed due to unexpected recovered state size " + state.size()).     }     this.collected = state.get(0). }
