commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public String map1(String value) {     return value. }
false;public;1;4;;@Override public String map2(Integer value) {     return String.valueOf(value + 1). }
true;public;0;36;/**  * We connect two different data streams in a chain to a CoMap.  */ ;/**  * We connect two different data streams in a chain to a CoMap.  */ @Test public void differentDataStreamSameChain() throws Exception {     TestListResultSink<String> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(1).     DataStream<Integer> src = env.fromElements(1, 3, 5).     DataStream<String> stringMap = src.map(value -> "x " + value).     stringMap.connect(src).map(new CoMapFunction<String, Integer, String>() {          @Override         public String map1(String value) {             return value.         }          @Override         public String map2(Integer value) {             return String.valueOf(value + 1).         }     }).addSink(resultSink).     env.execute().     List<String> expected = Arrays.asList("x 1", "x 3", "x 5", "2", "4", "6").     List<String> result = resultSink.getResult().     Collections.sort(expected).     Collections.sort(result).     assertEquals(expected, result). }
false;public;2;4;;@Override public void flatMap(Integer value, Collector<String> out) throws Exception {     out.collect("x " + value). }
false;public;1;4;;@Override public String map1(String value) {     return value. }
false;public;1;4;;@Override public String map2(Long value) {     return value.toString(). }
true;public;0;46;/**  * We connect two different data streams in different chains to a CoMap.  * (This is not actually self-connect.)  */ ;/**  * We connect two different data streams in different chains to a CoMap.  * (This is not actually self-connect.)  */ @Test public void differentDataStreamDifferentChain() throws Exception {     TestListResultSink<String> resultSink = new TestListResultSink<>().     StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(3).     DataStream<Integer> src = env.fromElements(1, 3, 5).disableChaining().     DataStream<String> stringMap = src.flatMap(new FlatMapFunction<Integer, String>() {          @Override         public void flatMap(Integer value, Collector<String> out) throws Exception {             out.collect("x " + value).         }     }).keyBy(String::length).     DataStream<Long> longMap = src.map(value -> (long) (value + 1)).keyBy(Long::intValue).     stringMap.connect(longMap).map(new CoMapFunction<String, Long, String>() {          @Override         public String map1(String value) {             return value.         }          @Override         public String map2(Long value) {             return value.toString().         }     }).addSink(resultSink).     env.execute().     List<String> expected = Arrays.asList("x 1", "x 3", "x 5", "2", "4", "6").     List<String> result = resultSink.getResult().     Collections.sort(expected).     Collections.sort(result).     assertEquals(expected, result). }
