# id;timestamp;commentText;codeText;commentWords;codeWords
SelfConnectionITCase -> @Test 	public void differentDataStreamDifferentChain();1467726666;We connect two different data streams in different chains to a CoMap._(This is not actually self-connect.);@Test_	public void differentDataStreamDifferentChain() {__		TestListResultSink<String> resultSink = new TestListResultSink<String>()___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(3)___		DataStream<Integer> src = env.fromElements(1, 3, 5).disableChaining()___		DataStream<String> stringMap = src.flatMap(new FlatMapFunction<Integer, String>() {__			private static final long serialVersionUID = 1L___			@Override_			public void flatMap(Integer value, Collector<String> out) throws Exception {_				out.collect("x " + value)__			}_		}).keyBy(new KeySelector<String, Integer>() {__			private static final long serialVersionUID = 1L___			@Override_			public Integer getKey(String value) throws Exception {_				return value.length()__			}_		})___		DataStream<Long> longMap = src.map(new MapFunction<Integer, Long>() {__			private static final long serialVersionUID = 1L___			@Override_			public Long map(Integer value) throws Exception {_				return (long) (value + 1)__			}_		}).keyBy(new KeySelector<Long, Integer>() {__			private static final long serialVersionUID = 1L___			@Override_			public Integer getKey(Long value) throws Exception {_				return value.intValue()__			}_		})____		stringMap.connect(longMap).map(new CoMapFunction<String, Long, String>() {__			private static final long serialVersionUID = 1L___			@Override_			public String map1(String value) {_				return value__			}__			@Override_			public String map2(Long value) {_				return value.toString()__			}_		}).addSink(resultSink)___		try {_			env.execute()__		} catch (Exception e) {_			e.printStackTrace()__		}__		List<String> expected = Arrays.asList("x 1", "x 3", "x 5", "2", "4", "6")__		List<String> result = resultSink.getResult()___		Collections.sort(expected)__		Collections.sort(result)___		assertEquals(expected, result)__	};we,connect,two,different,data,streams,in,different,chains,to,a,co,map,this,is,not,actually,self,connect;test,public,void,different,data,stream,different,chain,test,list,result,sink,string,result,sink,new,test,list,result,sink,string,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,3,data,stream,integer,src,env,from,elements,1,3,5,disable,chaining,data,stream,string,string,map,src,flat,map,new,flat,map,function,integer,string,private,static,final,long,serial,version,uid,1l,override,public,void,flat,map,integer,value,collector,string,out,throws,exception,out,collect,x,value,key,by,new,key,selector,string,integer,private,static,final,long,serial,version,uid,1l,override,public,integer,get,key,string,value,throws,exception,return,value,length,data,stream,long,long,map,src,map,new,map,function,integer,long,private,static,final,long,serial,version,uid,1l,override,public,long,map,integer,value,throws,exception,return,long,value,1,key,by,new,key,selector,long,integer,private,static,final,long,serial,version,uid,1l,override,public,integer,get,key,long,value,throws,exception,return,value,int,value,string,map,connect,long,map,map,new,co,map,function,string,long,string,private,static,final,long,serial,version,uid,1l,override,public,string,map1,string,value,return,value,override,public,string,map2,long,value,return,value,to,string,add,sink,result,sink,try,env,execute,catch,exception,e,e,print,stack,trace,list,string,expected,arrays,as,list,x,1,x,3,x,5,2,4,6,list,string,result,result,sink,get,result,collections,sort,expected,collections,sort,result,assert,equals,expected,result
SelfConnectionITCase -> @Test 	public void differentDataStreamDifferentChain();1499899067;We connect two different data streams in different chains to a CoMap._(This is not actually self-connect.);@Test_	public void differentDataStreamDifferentChain() {__		TestListResultSink<String> resultSink = new TestListResultSink<String>()___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(3)___		DataStream<Integer> src = env.fromElements(1, 3, 5).disableChaining()___		DataStream<String> stringMap = src.flatMap(new FlatMapFunction<Integer, String>() {__			private static final long serialVersionUID = 1L___			@Override_			public void flatMap(Integer value, Collector<String> out) throws Exception {_				out.collect("x " + value)__			}_		}).keyBy(new KeySelector<String, Integer>() {__			private static final long serialVersionUID = 1L___			@Override_			public Integer getKey(String value) throws Exception {_				return value.length()__			}_		})___		DataStream<Long> longMap = src.map(new MapFunction<Integer, Long>() {__			private static final long serialVersionUID = 1L___			@Override_			public Long map(Integer value) throws Exception {_				return (long) (value + 1)__			}_		}).keyBy(new KeySelector<Long, Integer>() {__			private static final long serialVersionUID = 1L___			@Override_			public Integer getKey(Long value) throws Exception {_				return value.intValue()__			}_		})___		stringMap.connect(longMap).map(new CoMapFunction<String, Long, String>() {__			private static final long serialVersionUID = 1L___			@Override_			public String map1(String value) {_				return value__			}__			@Override_			public String map2(Long value) {_				return value.toString()__			}_		}).addSink(resultSink)___		try {_			env.execute()__		} catch (Exception e) {_			e.printStackTrace()__		}__		List<String> expected = Arrays.asList("x 1", "x 3", "x 5", "2", "4", "6")__		List<String> result = resultSink.getResult()___		Collections.sort(expected)__		Collections.sort(result)___		assertEquals(expected, result)__	};we,connect,two,different,data,streams,in,different,chains,to,a,co,map,this,is,not,actually,self,connect;test,public,void,different,data,stream,different,chain,test,list,result,sink,string,result,sink,new,test,list,result,sink,string,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,3,data,stream,integer,src,env,from,elements,1,3,5,disable,chaining,data,stream,string,string,map,src,flat,map,new,flat,map,function,integer,string,private,static,final,long,serial,version,uid,1l,override,public,void,flat,map,integer,value,collector,string,out,throws,exception,out,collect,x,value,key,by,new,key,selector,string,integer,private,static,final,long,serial,version,uid,1l,override,public,integer,get,key,string,value,throws,exception,return,value,length,data,stream,long,long,map,src,map,new,map,function,integer,long,private,static,final,long,serial,version,uid,1l,override,public,long,map,integer,value,throws,exception,return,long,value,1,key,by,new,key,selector,long,integer,private,static,final,long,serial,version,uid,1l,override,public,integer,get,key,long,value,throws,exception,return,value,int,value,string,map,connect,long,map,map,new,co,map,function,string,long,string,private,static,final,long,serial,version,uid,1l,override,public,string,map1,string,value,return,value,override,public,string,map2,long,value,return,value,to,string,add,sink,result,sink,try,env,execute,catch,exception,e,e,print,stack,trace,list,string,expected,arrays,as,list,x,1,x,3,x,5,2,4,6,list,string,result,result,sink,get,result,collections,sort,expected,collections,sort,result,assert,equals,expected,result
SelfConnectionITCase -> @Test 	public void differentDataStreamDifferentChain();1515481551;We connect two different data streams in different chains to a CoMap._(This is not actually self-connect.);@Test_	public void differentDataStreamDifferentChain() {__		TestListResultSink<String> resultSink = new TestListResultSink<String>()___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(3)___		DataStream<Integer> src = env.fromElements(1, 3, 5).disableChaining()___		DataStream<String> stringMap = src.flatMap(new FlatMapFunction<Integer, String>() {__			private static final long serialVersionUID = 1L___			@Override_			public void flatMap(Integer value, Collector<String> out) throws Exception {_				out.collect("x " + value)__			}_		}).keyBy(new KeySelector<String, Integer>() {__			private static final long serialVersionUID = 1L___			@Override_			public Integer getKey(String value) throws Exception {_				return value.length()__			}_		})___		DataStream<Long> longMap = src.map(new MapFunction<Integer, Long>() {__			private static final long serialVersionUID = 1L___			@Override_			public Long map(Integer value) throws Exception {_				return (long) (value + 1)__			}_		}).keyBy(new KeySelector<Long, Integer>() {__			private static final long serialVersionUID = 1L___			@Override_			public Integer getKey(Long value) throws Exception {_				return value.intValue()__			}_		})___		stringMap.connect(longMap).map(new CoMapFunction<String, Long, String>() {__			private static final long serialVersionUID = 1L___			@Override_			public String map1(String value) {_				return value__			}__			@Override_			public String map2(Long value) {_				return value.toString()__			}_		}).addSink(resultSink)___		try {_			env.execute()__		} catch (Exception e) {_			e.printStackTrace()__		}__		List<String> expected = Arrays.asList("x 1", "x 3", "x 5", "2", "4", "6")__		List<String> result = resultSink.getResult()___		Collections.sort(expected)__		Collections.sort(result)___		assertEquals(expected, result)__	};we,connect,two,different,data,streams,in,different,chains,to,a,co,map,this,is,not,actually,self,connect;test,public,void,different,data,stream,different,chain,test,list,result,sink,string,result,sink,new,test,list,result,sink,string,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,3,data,stream,integer,src,env,from,elements,1,3,5,disable,chaining,data,stream,string,string,map,src,flat,map,new,flat,map,function,integer,string,private,static,final,long,serial,version,uid,1l,override,public,void,flat,map,integer,value,collector,string,out,throws,exception,out,collect,x,value,key,by,new,key,selector,string,integer,private,static,final,long,serial,version,uid,1l,override,public,integer,get,key,string,value,throws,exception,return,value,length,data,stream,long,long,map,src,map,new,map,function,integer,long,private,static,final,long,serial,version,uid,1l,override,public,long,map,integer,value,throws,exception,return,long,value,1,key,by,new,key,selector,long,integer,private,static,final,long,serial,version,uid,1l,override,public,integer,get,key,long,value,throws,exception,return,value,int,value,string,map,connect,long,map,map,new,co,map,function,string,long,string,private,static,final,long,serial,version,uid,1l,override,public,string,map1,string,value,return,value,override,public,string,map2,long,value,return,value,to,string,add,sink,result,sink,try,env,execute,catch,exception,e,e,print,stack,trace,list,string,expected,arrays,as,list,x,1,x,3,x,5,2,4,6,list,string,result,result,sink,get,result,collections,sort,expected,collections,sort,result,assert,equals,expected,result
SelfConnectionITCase -> @Test 	public void differentDataStreamSameChain() throws Exception;1467726666;We connect two different data streams in a chain to a CoMap.;@Test_	public void differentDataStreamSameChain() throws Exception {__		TestListResultSink<String> resultSink = new TestListResultSink<String>()___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)___		DataStream<Integer> src = env.fromElements(1, 3, 5)___		DataStream<String> stringMap = src.map(new MapFunction<Integer, String>() {_			private static final long serialVersionUID = 1L___			@Override_			public String map(Integer value) throws Exception {_				return "x " + value__			}_		})___		stringMap.connect(src).map(new CoMapFunction<String, Integer, String>() {__			private static final long serialVersionUID = 1L___			@Override_			public String map1(String value) {_				return value__			}__			@Override_			public String map2(Integer value) {_				return String.valueOf(value + 1)__			}_		}).addSink(resultSink)___		env.execute()___		List<String> expected = Arrays.asList("x 1", "x 3", "x 5", "2", "4", "6")___		List<String> result = resultSink.getResult()___		Collections.sort(expected)__		Collections.sort(result)___		assertEquals(expected, result)__	};we,connect,two,different,data,streams,in,a,chain,to,a,co,map;test,public,void,different,data,stream,same,chain,throws,exception,test,list,result,sink,string,result,sink,new,test,list,result,sink,string,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,data,stream,integer,src,env,from,elements,1,3,5,data,stream,string,string,map,src,map,new,map,function,integer,string,private,static,final,long,serial,version,uid,1l,override,public,string,map,integer,value,throws,exception,return,x,value,string,map,connect,src,map,new,co,map,function,string,integer,string,private,static,final,long,serial,version,uid,1l,override,public,string,map1,string,value,return,value,override,public,string,map2,integer,value,return,string,value,of,value,1,add,sink,result,sink,env,execute,list,string,expected,arrays,as,list,x,1,x,3,x,5,2,4,6,list,string,result,result,sink,get,result,collections,sort,expected,collections,sort,result,assert,equals,expected,result
SelfConnectionITCase -> @Test 	public void differentDataStreamSameChain() throws Exception;1499899067;We connect two different data streams in a chain to a CoMap.;@Test_	public void differentDataStreamSameChain() throws Exception {__		TestListResultSink<String> resultSink = new TestListResultSink<String>()___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)___		DataStream<Integer> src = env.fromElements(1, 3, 5)___		DataStream<String> stringMap = src.map(new MapFunction<Integer, String>() {_			private static final long serialVersionUID = 1L___			@Override_			public String map(Integer value) throws Exception {_				return "x " + value__			}_		})___		stringMap.connect(src).map(new CoMapFunction<String, Integer, String>() {__			private static final long serialVersionUID = 1L___			@Override_			public String map1(String value) {_				return value__			}__			@Override_			public String map2(Integer value) {_				return String.valueOf(value + 1)__			}_		}).addSink(resultSink)___		env.execute()___		List<String> expected = Arrays.asList("x 1", "x 3", "x 5", "2", "4", "6")___		List<String> result = resultSink.getResult()___		Collections.sort(expected)__		Collections.sort(result)___		assertEquals(expected, result)__	};we,connect,two,different,data,streams,in,a,chain,to,a,co,map;test,public,void,different,data,stream,same,chain,throws,exception,test,list,result,sink,string,result,sink,new,test,list,result,sink,string,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,data,stream,integer,src,env,from,elements,1,3,5,data,stream,string,string,map,src,map,new,map,function,integer,string,private,static,final,long,serial,version,uid,1l,override,public,string,map,integer,value,throws,exception,return,x,value,string,map,connect,src,map,new,co,map,function,string,integer,string,private,static,final,long,serial,version,uid,1l,override,public,string,map1,string,value,return,value,override,public,string,map2,integer,value,return,string,value,of,value,1,add,sink,result,sink,env,execute,list,string,expected,arrays,as,list,x,1,x,3,x,5,2,4,6,list,string,result,result,sink,get,result,collections,sort,expected,collections,sort,result,assert,equals,expected,result
SelfConnectionITCase -> @Test 	public void differentDataStreamSameChain() throws Exception;1515481551;We connect two different data streams in a chain to a CoMap.;@Test_	public void differentDataStreamSameChain() throws Exception {__		TestListResultSink<String> resultSink = new TestListResultSink<String>()___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)___		DataStream<Integer> src = env.fromElements(1, 3, 5)___		DataStream<String> stringMap = src.map(new MapFunction<Integer, String>() {_			private static final long serialVersionUID = 1L___			@Override_			public String map(Integer value) throws Exception {_				return "x " + value__			}_		})___		stringMap.connect(src).map(new CoMapFunction<String, Integer, String>() {__			private static final long serialVersionUID = 1L___			@Override_			public String map1(String value) {_				return value__			}__			@Override_			public String map2(Integer value) {_				return String.valueOf(value + 1)__			}_		}).addSink(resultSink)___		env.execute()___		List<String> expected = Arrays.asList("x 1", "x 3", "x 5", "2", "4", "6")___		List<String> result = resultSink.getResult()___		Collections.sort(expected)__		Collections.sort(result)___		assertEquals(expected, result)__	};we,connect,two,different,data,streams,in,a,chain,to,a,co,map;test,public,void,different,data,stream,same,chain,throws,exception,test,list,result,sink,string,result,sink,new,test,list,result,sink,string,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,data,stream,integer,src,env,from,elements,1,3,5,data,stream,string,string,map,src,map,new,map,function,integer,string,private,static,final,long,serial,version,uid,1l,override,public,string,map,integer,value,throws,exception,return,x,value,string,map,connect,src,map,new,co,map,function,string,integer,string,private,static,final,long,serial,version,uid,1l,override,public,string,map1,string,value,return,value,override,public,string,map2,integer,value,return,string,value,of,value,1,add,sink,result,sink,env,execute,list,string,expected,arrays,as,list,x,1,x,3,x,5,2,4,6,list,string,result,result,sink,get,result,collections,sort,expected,collections,sort,result,assert,equals,expected,result
SelfConnectionITCase -> @Test 	public void differentDataStreamSameChain() throws Exception;1519836512;We connect two different data streams in a chain to a CoMap.;@Test_	public void differentDataStreamSameChain() throws Exception {__		TestListResultSink<String> resultSink = new TestListResultSink<>()___		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()__		env.setParallelism(1)___		DataStream<Integer> src = env.fromElements(1, 3, 5)___		DataStream<String> stringMap = src.map(value -> "x " + value)___		stringMap.connect(src).map(new CoMapFunction<String, Integer, String>() {__			@Override_			public String map1(String value) {_				return value__			}__			@Override_			public String map2(Integer value) {_				return String.valueOf(value + 1)__			}_		}).addSink(resultSink)___		env.execute()___		List<String> expected = Arrays.asList("x 1", "x 3", "x 5", "2", "4", "6")___		List<String> result = resultSink.getResult()___		Collections.sort(expected)__		Collections.sort(result)___		assertEquals(expected, result)__	};we,connect,two,different,data,streams,in,a,chain,to,a,co,map;test,public,void,different,data,stream,same,chain,throws,exception,test,list,result,sink,string,result,sink,new,test,list,result,sink,stream,execution,environment,env,stream,execution,environment,get,execution,environment,env,set,parallelism,1,data,stream,integer,src,env,from,elements,1,3,5,data,stream,string,string,map,src,map,value,x,value,string,map,connect,src,map,new,co,map,function,string,integer,string,override,public,string,map1,string,value,return,value,override,public,string,map2,integer,value,return,string,value,of,value,1,add,sink,result,sink,env,execute,list,string,expected,arrays,as,list,x,1,x,3,x,5,2,4,6,list,string,result,result,sink,get,result,collections,sort,expected,collections,sort,result,assert,equals,expected,result
