commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;7;;@Parameterized.Parameters(name = "StateBackend: {0}") public static Collection<String> parameters() {     return Arrays.asList(StateBackendLoader.MEMORY_STATE_BACKEND_NAME, StateBackendLoader.FS_STATE_BACKEND_NAME, StateBackendLoader.ROCKSDB_STATE_BACKEND_NAME). }
true;public;0;4;/**  * We should be able to handle a changed field order of a POJO as keyed state.  */ ;/**  * We should be able to handle a changed field order of a POJO as keyed state.  */ @Test public void testChangedFieldOrderWithKeyedState() throws Exception {     testPojoSerializerUpgrade(SOURCE_A, SOURCE_B, true, true). }
true;public;0;4;/**  * We should be able to handle a changed field order of a POJO as operator state.  */ ;/**  * We should be able to handle a changed field order of a POJO as operator state.  */ @Test public void testChangedFieldOrderWithOperatorState() throws Exception {     testPojoSerializerUpgrade(SOURCE_A, SOURCE_B, true, false). }
true;public;0;13;/**  * Changing field types of a POJO as keyed state should require a state migration.  */ ;/**  * Changing field types of a POJO as keyed state should require a state migration.  */ @Test public void testChangedFieldTypesWithKeyedState() throws Exception {     try {         testPojoSerializerUpgrade(SOURCE_A, SOURCE_C, true, true).         fail("Expected a state migration exception.").     } catch (Exception e) {         if (CommonTestUtils.containsCause(e, StateMigrationException.class)) {         // StateMigrationException expected         } else {             throw e.         }     } }
true;public;0;13;/**  * Changing field types of a POJO as operator state should require a state migration.  */ ;/**  * Changing field types of a POJO as operator state should require a state migration.  */ @Test public void testChangedFieldTypesWithOperatorState() throws Exception {     try {         testPojoSerializerUpgrade(SOURCE_A, SOURCE_C, true, false).         fail("Expected a state migration exception.").     } catch (Exception e) {         if (CommonTestUtils.containsCause(e, StateMigrationException.class)) {         // StateMigrationException expected         } else {             throw e.         }     } }
true;public;0;4;/**  * Adding fields to a POJO as keyed state should succeed.  */ ;/**  * Adding fields to a POJO as keyed state should succeed.  */ @Test public void testAdditionalFieldWithKeyedState() throws Exception {     testPojoSerializerUpgrade(SOURCE_A, SOURCE_D, true, true). }
true;public;0;4;/**  * Adding fields to a POJO as operator state should succeed.  */ ;/**  * Adding fields to a POJO as operator state should succeed.  */ @Test public void testAdditionalFieldWithOperatorState() throws Exception {     testPojoSerializerUpgrade(SOURCE_A, SOURCE_D, true, false). }
true;public;0;4;/**  * Removing fields from a POJO as keyed state should succeed.  */ ;/**  * Removing fields from a POJO as keyed state should succeed.  */ @Test public void testMissingFieldWithKeyedState() throws Exception {     testPojoSerializerUpgrade(SOURCE_A, SOURCE_E, false, true). }
true;public;0;4;/**  * Removing fields from a POJO as operator state should succeed.  */ ;/**  * Removing fields from a POJO as operator state should succeed.  */ @Test public void testMissingFieldWithOperatorState() throws Exception {     testPojoSerializerUpgrade(SOURCE_A, SOURCE_E, false, false). }
false;private;4;47;;private void testPojoSerializerUpgrade(String classSourceA, String classSourceB, boolean hasBField, boolean isKeyedState) throws Exception {     final Configuration taskConfiguration = new Configuration().     final ExecutionConfig executionConfig = new ExecutionConfig().     final KeySelector<Long, Long> keySelector = new IdentityKeySelector<>().     final Collection<Long> inputs = Arrays.asList(1L, 2L, 45L, 67L, 1337L).     // run the program with classSourceA     File rootPath = temporaryFolder.newFolder().     File sourceFile = writeSourceFile(rootPath, POJO_NAME + ".java", classSourceA).     compileClass(sourceFile).     final ClassLoader classLoader = URLClassLoader.newInstance(new URL[] { rootPath.toURI().toURL() }, Thread.currentThread().getContextClassLoader()).     OperatorSubtaskState stateHandles = runOperator(taskConfiguration, executionConfig, new StreamMap<>(new StatefulMapper(isKeyedState, false, hasBField)), keySelector, isKeyedState, stateBackend, classLoader, null, inputs).     // run the program with classSourceB     rootPath = temporaryFolder.newFolder().     sourceFile = writeSourceFile(rootPath, POJO_NAME + ".java", classSourceB).     compileClass(sourceFile).     final ClassLoader classLoaderB = URLClassLoader.newInstance(new URL[] { rootPath.toURI().toURL() }, Thread.currentThread().getContextClassLoader()).     runOperator(taskConfiguration, executionConfig, new StreamMap<>(new StatefulMapper(isKeyedState, true, hasBField)), keySelector, isKeyedState, stateBackend, classLoaderB, stateHandles, inputs). }
false;private;9;56;;private OperatorSubtaskState runOperator(Configuration taskConfiguration, ExecutionConfig executionConfig, OneInputStreamOperator<Long, Long> operator, KeySelector<Long, Long> keySelector, boolean isKeyedState, StateBackend stateBackend, ClassLoader classLoader, OperatorSubtaskState operatorSubtaskState, Iterable<Long> input) throws Exception {     try (final MockEnvironment environment = new MockEnvironmentBuilder().setTaskName("test task").setMemorySize(32 * 1024).setInputSplitProvider(new MockInputSplitProvider()).setBufferSize(256).setTaskConfiguration(taskConfiguration).setExecutionConfig(executionConfig).setMaxParallelism(16).setUserCodeClassLoader(classLoader).build()) {         OneInputStreamOperatorTestHarness<Long, Long> harness = null.         try {             if (isKeyedState) {                 harness = new KeyedOneInputStreamOperatorTestHarness<>(operator, keySelector, BasicTypeInfo.LONG_TYPE_INFO, environment).             } else {                 harness = new OneInputStreamOperatorTestHarness<>(operator, LongSerializer.INSTANCE, environment).             }             harness.setStateBackend(stateBackend).             harness.setup().             harness.initializeState(operatorSubtaskState).             harness.open().             long timestamp = 0L.             for (Long value : input) {                 harness.processElement(value, timestamp++).             }             long checkpointId = 1L.             long checkpointTimestamp = timestamp + 1L.             return harness.snapshot(checkpointId, checkpointTimestamp).         } finally {             IOUtils.closeQuietly(harness).         }     } }
false;private,static;3;11;;private static File writeSourceFile(File root, String name, String source) throws IOException {     File sourceFile = new File(root, name).     sourceFile.getParentFile().mkdirs().     try (FileWriter writer = new FileWriter(sourceFile)) {         writer.write(source).     }     return sourceFile. }
false;private,static;1;4;;private static int compileClass(File sourceFile) {     JavaCompiler compiler = ToolProvider.getSystemJavaCompiler().     return compiler.run(null, null, null, "-proc:none", sourceFile.getPath()). }
false;public;1;53;;@Override public Long map(Long value) throws Exception {     Object pojo = pojoClass.newInstance().     fieldA.set(pojo, value).     if (hasBField) {         fieldB.set(pojo, value + "").     }     if (verify) {         if (keyed) {             assertEquals(pojo, keyedValueState.value()).             Iterator<Object> listIterator = keyedListState.get().iterator().             boolean elementFound = false.             while (listIterator.hasNext()) {                 elementFound |= pojo.equals(listIterator.next()).             }             assertTrue(elementFound).             assertEquals(pojo, keyedReducingState.get()).         } else {             boolean elementFound = false.             Iterator<Object> listIterator = partitionableListState.get().iterator().             while (listIterator.hasNext()) {                 elementFound |= pojo.equals(listIterator.next()).             }             assertTrue(elementFound).             elementFound = false.             listIterator = unionListState.get().iterator().             while (listIterator.hasNext()) {                 elementFound |= pojo.equals(listIterator.next()).             }             assertTrue(elementFound).         }     } else {         if (keyed) {             keyedValueState.update(pojo).             keyedListState.add(pojo).             keyedReducingState.add(pojo).         } else {             partitionableListState.add(pojo).             unionListState.add(pojo).         }     }     return value. }
false;public;1;4;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception { }
false;public;1;29;;@SuppressWarnings("unchecked") @Override public void initializeState(FunctionInitializationContext context) throws Exception {     pojoClass = getRuntimeContext().getUserCodeClassLoader().loadClass(POJO_NAME).     fieldA = pojoClass.getDeclaredField("a").     fieldA.setAccessible(true).     if (hasBField) {         fieldB = pojoClass.getDeclaredField("b").         fieldB.setAccessible(true).     }     if (keyed) {         keyedValueState = context.getKeyedStateStore().getState(new ValueStateDescriptor<>("keyedValueState", (Class<Object>) pojoClass)).         keyedListState = context.getKeyedStateStore().getListState(new ListStateDescriptor<>("keyedListState", (Class<Object>) pojoClass)).         ReduceFunction<Object> reduceFunction = new FirstValueReducer<>().         keyedReducingState = context.getKeyedStateStore().getReducingState(new ReducingStateDescriptor<>("keyedReducingState", reduceFunction, (Class<Object>) pojoClass)).     } else {         partitionableListState = context.getOperatorStateStore().getListState(new ListStateDescriptor<>("partitionableListState", (Class<Object>) pojoClass)).         unionListState = context.getOperatorStateStore().getUnionListState(new ListStateDescriptor<>("unionListState", (Class<Object>) pojoClass)).     } }
false;public;2;4;;@Override public T reduce(T value1, T value2) throws Exception {     return value1. }
false;public;1;4;;@Override public T getKey(T value) throws Exception {     return value. }
