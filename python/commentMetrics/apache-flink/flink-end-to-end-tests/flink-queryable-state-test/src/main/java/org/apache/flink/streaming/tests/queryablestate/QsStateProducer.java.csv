commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public String getKey(Email value) throws Exception {     return QsConstants.KEY. }
false;public,static;1;41;;public static void main(final String[] args) throws Exception {     final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     ParameterTool tool = ParameterTool.fromArgs(args).     String tmpPath = tool.getRequired("tmp-dir").     String stateBackendType = tool.getRequired("state-backend").     StateBackend stateBackend.     switch(stateBackendType) {         case "rocksdb":             stateBackend = new RocksDBStateBackend(tmpPath).             break.         case "fs":             stateBackend = new FsStateBackend(tmpPath).             break.         case "memory":             stateBackend = new MemoryStateBackend().             break.         default:             throw new RuntimeException("Unsupported state backend " + stateBackendType).     }     env.setStateBackend(stateBackend).     env.enableCheckpointing(1000L).     env.getCheckpointConfig().setMaxConcurrentCheckpoints(1).     env.getCheckpointConfig().setMinPauseBetweenCheckpoints(0).     env.addSource(new EmailSource()).keyBy(new KeySelector<Email, String>() {          private static final long serialVersionUID = -1480525724620425363L.          @Override         public String getKey(Email value) throws Exception {             return QsConstants.KEY.         }     }).flatMap(new TestFlatMap()).     env.execute(). }
false;public;1;6;;@Override public void open(Configuration parameters) throws Exception {     super.open(parameters).     this.random = new Random().     this.isRunning = true. }
false;public;1;22;;@Override public void run(SourceContext<Email> ctx) throws Exception {     // Sleep for 10 seconds on start to allow time to copy jobid     Thread.sleep(10000L).     int types = LabelSurrogate.Type.values().length.     while (isRunning) {         int r = random.nextInt(100).         final EmailId emailId = new EmailId(Integer.toString(random.nextInt())).         final Instant timestamp = Instant.now().minus(Duration.ofDays(1L)).         final String foo = String.format("foo #%d", r).         final LabelSurrogate label = new LabelSurrogate(LabelSurrogate.Type.values()[r % types], "bar").         synchronized (ctx.getCheckpointLock()) {             ctx.collect(new Email(emailId, timestamp, foo, label)).         }         Thread.sleep(30L).     } }
false;public;0;4;;@Override public void cancel() {     isRunning = false. }
false;public;1;16;;@Override public void open(Configuration parameters) {     MapStateDescriptor<EmailId, EmailInformation> stateDescriptor = new MapStateDescriptor<>(QsConstants.STATE_NAME, TypeInformation.of(new TypeHint<EmailId>() {     }), TypeInformation.of(new TypeHint<EmailInformation>() {     })).     stateDescriptor.setQueryable(QsConstants.QUERY_NAME).     state = getRuntimeContext().getMapState(stateDescriptor).     count = -1. }
false;public;2;5;;@Override public void flatMap(Email value, Collector<Object> out) throws Exception {     state.put(value.getEmailId(), new EmailInformation(value)).     count = Iterables.size(state.keys()). }
false;public;1;4;;@Override public void snapshotState(FunctionSnapshotContext context) {     // we look for it in the test     System.out.println("Count on snapshot: " + count). }
false;public;1;4;;@Override public void initializeState(FunctionInitializationContext context) { }
