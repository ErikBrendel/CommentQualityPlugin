commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void run(SourceContext<Event> ctx) throws Exception {     if (keyRanges.size() > 0) {         runActive(ctx).     } else {         runIdle(ctx).     } }
false;private;1;40;;private void runActive(SourceContext<Event> ctx) throws Exception {     Random random = new Random().     // this holds the current event time, from which generated events can up to +/- (maxOutOfOrder).     long elementsBeforeSleep = sleepAfterElements.     while (running) {         KeyRangeStates randomKeyRangeStates = keyRanges.get(random.nextInt(keyRanges.size())).         int randomKey = randomKeyRangeStates.getRandomKey(random).         long eventTime = Math.max(0, generateEventTimeWithOutOfOrderness(random, monotonousEventTime)).         // uptick the event time clock         monotonousEventTime += eventTimeClockProgressPerEvent.         synchronized (ctx.getCheckpointLock()) {             long value = randomKeyRangeStates.incrementAndGet(randomKey).             Event event = new Event(randomKey, eventTime, value, StringUtils.getRandomString(random, payloadLength, payloadLength, 'A', 'z')).             ctx.collect(event).         }         if (sleepTime > 0) {             if (elementsBeforeSleep == 1) {                 elementsBeforeSleep = sleepAfterElements.                 Thread.sleep(sleepTime).             } else if (elementsBeforeSleep > 1) {                 --elementsBeforeSleep.             }         }     } }
false;private;1;20;;private void runIdle(SourceContext<Event> ctx) {     ctx.markAsTemporarilyIdle().     // just wait until this source is canceled     final Object waitLock = new Object().     while (running) {         try {             // noinspection SynchronizationOnLocalVariableOrMethodParameter             synchronized (waitLock) {                 waitLock.wait().             }         } catch (InterruptedException e) {             if (!running) {                 // restore the interrupted state, and fall through the loop                 Thread.currentThread().interrupt().             }         }     } }
false;private;2;7;;private long generateEventTimeWithOutOfOrderness(Random random, long correctTime) {     if (maxOutOfOrder > 0) {         return correctTime - maxOutOfOrder + ((random.nextLong() & Long.MAX_VALUE) % (2 * maxOutOfOrder)).     } else {         return correctTime.     } }
false;public;0;4;;@Override public void cancel() {     running = false. }
false;public;1;7;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     snapshotKeyRanges.update(keyRanges).     lastEventTimes.clear().     lastEventTimes.add(monotonousEventTime). }
false;public;1;47;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     final RuntimeContext runtimeContext = getRuntimeContext().     final int subtaskIdx = runtimeContext.getIndexOfThisSubtask().     final int parallelism = runtimeContext.getNumberOfParallelSubtasks().     final int maxParallelism = runtimeContext.getMaxNumberOfParallelSubtasks().     ListStateDescriptor<Long> unionWatermarksStateDescriptor = new ListStateDescriptor<>("watermarks", Long.class).     lastEventTimes = context.getOperatorStateStore().getUnionListState(unionWatermarksStateDescriptor).     ListStateDescriptor<KeyRangeStates> stateDescriptor = new ListStateDescriptor<>("keyRanges", KeyRangeStates.class).     snapshotKeyRanges = context.getOperatorStateStore().getListState(stateDescriptor).     keyRanges = new ArrayList<>().     if (context.isRestored()) {         // restore key ranges from the snapshot         for (KeyRangeStates keyRange : snapshotKeyRanges.get()) {             keyRanges.add(keyRange).         }         // let event time start from the max of all event time progress across subtasks in the last execution         for (Long lastEventTime : lastEventTimes.get()) {             monotonousEventTime = Math.max(monotonousEventTime, lastEventTime).         }     } else {         // determine the key ranges that belong to the subtask         int rangeStartIdx = (subtaskIdx * maxParallelism) / parallelism.         int rangeEndIdx = ((subtaskIdx + 1) * maxParallelism) / parallelism.         for (int i = rangeStartIdx. i < rangeEndIdx. ++i) {             int start = ((i * totalKeySpaceSize + maxParallelism - 1) / maxParallelism).             int end = 1 + ((i + 1) * totalKeySpaceSize - 1) / maxParallelism.             if (end - start > 0) {                 keyRanges.add(new KeyRangeStates(start, end)).             }         }         // fresh run. start from event time o         monotonousEventTime = 0L.     } }
true;;1;3;/**  * Increments and returns the current sequence number for the given key.  */ ;/**  * Increments and returns the current sequence number for the given key.  */ long incrementAndGet(int key) {     return ++statesPerKey[key - startKey]. }
true;;1;3;/**  * Returns a random key that belongs to this key range.  */ ;/**  * Returns a random key that belongs to this key range.  */ int getRandomKey(Random random) {     return random.nextInt(endKey - startKey) + startKey. }
false;public;0;8;;@Override public String toString() {     return "KeyRangeStates{" + "start=" + startKey + ", end=" + endKey + ", statesPerKey=" + Arrays.toString(statesPerKey) + '}'. }
