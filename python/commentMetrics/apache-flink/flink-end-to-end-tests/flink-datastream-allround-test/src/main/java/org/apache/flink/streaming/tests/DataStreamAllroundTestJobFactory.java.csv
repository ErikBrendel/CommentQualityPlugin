commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;91;;public static void setupEnvironment(StreamExecutionEnvironment env, ParameterTool pt) throws Exception {     // set checkpointing semantics     String semantics = pt.get(TEST_SEMANTICS.key(), TEST_SEMANTICS.defaultValue()).     long checkpointInterval = pt.getLong(ENVIRONMENT_CHECKPOINT_INTERVAL.key(), ENVIRONMENT_CHECKPOINT_INTERVAL.defaultValue()).     CheckpointingMode checkpointingMode = semantics.equalsIgnoreCase("exactly-once") ? CheckpointingMode.EXACTLY_ONCE : CheckpointingMode.AT_LEAST_ONCE.     env.enableCheckpointing(checkpointInterval, checkpointingMode).     // use event time     env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime).     // parallelism     env.setParallelism(pt.getInt(ENVIRONMENT_PARALLELISM.key(), ENVIRONMENT_PARALLELISM.defaultValue())).     env.setMaxParallelism(pt.getInt(ENVIRONMENT_MAX_PARALLELISM.key(), ENVIRONMENT_MAX_PARALLELISM.defaultValue())).     // restart strategy     String restartStrategyConfig = pt.get(ENVIRONMENT_RESTART_STRATEGY.key()).     if (restartStrategyConfig != null) {         RestartStrategies.RestartStrategyConfiguration restartStrategy.         switch(restartStrategyConfig) {             case "fixed_delay":                 restartStrategy = RestartStrategies.fixedDelayRestart(pt.getInt(ENVIRONMENT_RESTART_STRATEGY_FIXED_ATTEMPTS.key(), ENVIRONMENT_RESTART_STRATEGY_FIXED_ATTEMPTS.defaultValue()), pt.getLong(ENVIRONMENT_RESTART_STRATEGY_FIXED_DELAY.key(), ENVIRONMENT_RESTART_STRATEGY_FIXED_DELAY.defaultValue())).                 break.             case "no_restart":                 restartStrategy = RestartStrategies.noRestart().                 break.             default:                 throw new IllegalArgumentException("Unkown restart strategy: " + restartStrategyConfig).         }         env.setRestartStrategy(restartStrategy).     }     // state backend     final String stateBackend = pt.get(STATE_BACKEND.key(), STATE_BACKEND.defaultValue()).     final String checkpointDir = pt.getRequired(STATE_BACKEND_CHECKPOINT_DIR.key()).     if ("file".equalsIgnoreCase(stateBackend)) {         boolean asyncCheckpoints = pt.getBoolean(STATE_BACKEND_FILE_ASYNC.key(), STATE_BACKEND_FILE_ASYNC.defaultValue()).         env.setStateBackend((StateBackend) new FsStateBackend(checkpointDir, asyncCheckpoints)).     } else if ("rocks".equalsIgnoreCase(stateBackend)) {         boolean incrementalCheckpoints = pt.getBoolean(STATE_BACKEND_ROCKS_INCREMENTAL.key(), STATE_BACKEND_ROCKS_INCREMENTAL.defaultValue()).         env.setStateBackend((StateBackend) new RocksDBStateBackend(checkpointDir, incrementalCheckpoints)).     } else {         throw new IllegalArgumentException("Unknown backend requested: " + stateBackend).     }     boolean enableExternalizedCheckpoints = pt.getBoolean(ENVIRONMENT_EXTERNALIZE_CHECKPOINT.key(), ENVIRONMENT_EXTERNALIZE_CHECKPOINT.defaultValue()).     if (enableExternalizedCheckpoints) {         String cleanupModeConfig = pt.get(ENVIRONMENT_EXTERNALIZE_CHECKPOINT_CLEANUP.key(), ENVIRONMENT_EXTERNALIZE_CHECKPOINT_CLEANUP.defaultValue()).         CheckpointConfig.ExternalizedCheckpointCleanup cleanupMode.         switch(cleanupModeConfig) {             case "retain":                 cleanupMode = CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION.                 break.             case "delete":                 cleanupMode = CheckpointConfig.ExternalizedCheckpointCleanup.DELETE_ON_CANCELLATION.                 break.             default:                 throw new IllegalArgumentException("Unknown clean up mode for externalized checkpoints: " + cleanupModeConfig).         }         env.getCheckpointConfig().enableExternalizedCheckpoints(cleanupMode).     }     // make parameters available in the web interface     env.getConfig().setGlobalJobParameters(pt). }
false;static;1;21;;static SourceFunction<Event> createEventSource(ParameterTool pt) {     return new SequenceGeneratorSource(pt.getInt(SEQUENCE_GENERATOR_SRC_KEYSPACE.key(), SEQUENCE_GENERATOR_SRC_KEYSPACE.defaultValue()), pt.getInt(SEQUENCE_GENERATOR_SRC_PAYLOAD_SIZE.key(), SEQUENCE_GENERATOR_SRC_PAYLOAD_SIZE.defaultValue()), pt.getLong(SEQUENCE_GENERATOR_SRC_EVENT_TIME_MAX_OUT_OF_ORDERNESS.key(), SEQUENCE_GENERATOR_SRC_EVENT_TIME_MAX_OUT_OF_ORDERNESS.defaultValue()), pt.getLong(SEQUENCE_GENERATOR_SRC_EVENT_TIME_CLOCK_PROGRESS.key(), SEQUENCE_GENERATOR_SRC_EVENT_TIME_CLOCK_PROGRESS.defaultValue()), pt.getLong(SEQUENCE_GENERATOR_SRC_SLEEP_TIME.key(), SEQUENCE_GENERATOR_SRC_SLEEP_TIME.defaultValue()), pt.getLong(SEQUENCE_GENERATOR_SRC_SLEEP_AFTER_ELEMENTS.key(), SEQUENCE_GENERATOR_SRC_SLEEP_AFTER_ELEMENTS.defaultValue())). }
false;public;1;4;;@Override public long extractTimestamp(Event element) {     return element.getEventTime(). }
false;static;1;15;;static BoundedOutOfOrdernessTimestampExtractor<Event> createTimestampExtractor(ParameterTool pt) {     return new BoundedOutOfOrdernessTimestampExtractor<Event>(Time.milliseconds(pt.getLong(SEQUENCE_GENERATOR_SRC_EVENT_TIME_MAX_OUT_OF_ORDERNESS.key(), SEQUENCE_GENERATOR_SRC_EVENT_TIME_MAX_OUT_OF_ORDERNESS.defaultValue()))) {          private static final long serialVersionUID = -3154419724891779938L.          @Override         public long extractTimestamp(Event element) {             return element.getEventTime().         }     }. }
false;static;2;16;;static WindowedStream<Event, Integer, TimeWindow> applyTumblingWindows(KeyedStream<Event, Integer> keyedStream, ParameterTool pt) {     long eventTimeProgressPerEvent = pt.getLong(SEQUENCE_GENERATOR_SRC_EVENT_TIME_CLOCK_PROGRESS.key(), SEQUENCE_GENERATOR_SRC_EVENT_TIME_CLOCK_PROGRESS.defaultValue()).     return keyedStream.timeWindow(Time.milliseconds(pt.getLong(TUMBLING_WINDOW_OPERATOR_NUM_EVENTS.key(), TUMBLING_WINDOW_OPERATOR_NUM_EVENTS.defaultValue()) * eventTimeProgressPerEvent)). }
false;static;1;16;;static FlatMapFunction<Event, String> createSemanticsCheckMapper(ParameterTool pt) {     String semantics = pt.get(TEST_SEMANTICS.key(), TEST_SEMANTICS.defaultValue()).     SemanticsCheckMapper.ValidatorFunction validatorFunction.     if (semantics.equalsIgnoreCase("exactly-once")) {         validatorFunction = SemanticsCheckMapper.ValidatorFunction.exactlyOnce().     } else if (semantics.equalsIgnoreCase("at-least-once")) {         validatorFunction = SemanticsCheckMapper.ValidatorFunction.atLeastOnce().     } else {         throw new IllegalArgumentException("Unknown semantics requested: " + semantics).     }     return new SemanticsCheckMapper(validatorFunction). }
false;static;1;3;;static boolean isSimulateFailures(ParameterTool pt) {     return pt.getBoolean(TEST_SIMULATE_FAILURE.key(), TEST_SIMULATE_FAILURE.defaultValue()). }
false;static;1;13;;static MapFunction<Event, Event> createFailureMapper(ParameterTool pt) {     return new FailureMapper<>(pt.getLong(TEST_SIMULATE_FAILURE_NUM_RECORDS.key(), TEST_SIMULATE_FAILURE_NUM_RECORDS.defaultValue()), pt.getLong(TEST_SIMULATE_FAILURE_NUM_CHECKPOINTS.key(), TEST_SIMULATE_FAILURE_NUM_CHECKPOINTS.defaultValue()), pt.getInt(TEST_SIMULATE_FAILURE_MAX_FAILURES.key(), TEST_SIMULATE_FAILURE_MAX_FAILURES.defaultValue())). }
false;static;4;37;;static <IN, OUT, STATE> ArtificialKeyedStateMapper<IN, OUT> createArtificialKeyedStateMapper(MapFunction<IN, OUT> mapFunction, JoinFunction<IN, STATE, STATE> inputAndOldStateToNewState, List<TypeSerializer<STATE>> stateSerializers, List<Class<STATE>> stateClasses) {     List<ArtificialStateBuilder<IN>> artificialStateBuilders = new ArrayList<>(stateSerializers.size()).     for (TypeSerializer<STATE> typeSerializer : stateSerializers) {         artificialStateBuilders.add(createValueStateBuilder(inputAndOldStateToNewState, new ValueStateDescriptor<>("valueState-" + typeSerializer.getClass().getSimpleName(), typeSerializer))).         artificialStateBuilders.add(createListStateBuilder(inputAndOldStateToNewState, new ListStateDescriptor<>("listState-" + typeSerializer.getClass().getSimpleName(), typeSerializer))).     }     for (Class<STATE> stateClass : stateClasses) {         artificialStateBuilders.add(createValueStateBuilder(inputAndOldStateToNewState, new ValueStateDescriptor<>("valueState-" + stateClass.getSimpleName(), stateClass))).         artificialStateBuilders.add(createListStateBuilder(inputAndOldStateToNewState, new ListStateDescriptor<>("listState-" + stateClass.getSimpleName(), stateClass))).     }     return new ArtificialKeyedStateMapper<>(mapFunction, artificialStateBuilders). }
false;static;1;5;;static <IN, OUT> ArtificalOperatorStateMapper<IN, OUT> createArtificialOperatorStateMapper(MapFunction<IN, OUT> mapFunction) {     return new ArtificalOperatorStateMapper<>(mapFunction). }
false;private,static;2;9;;private static <IN, STATE> ArtificialStateBuilder<IN> createValueStateBuilder(JoinFunction<IN, STATE, STATE> inputAndOldStateToNewState, ValueStateDescriptor<STATE> valueStateDescriptor) {     return new ArtificialValueStateBuilder<>(valueStateDescriptor.getName(), inputAndOldStateToNewState, valueStateDescriptor). }
false;private,static;2;18;;private static <IN, STATE> ArtificialStateBuilder<IN> createListStateBuilder(JoinFunction<IN, STATE, STATE> inputAndOldStateToNewState, ListStateDescriptor<STATE> listStateDescriptor) {     JoinFunction<IN, Iterable<STATE>, List<STATE>> listStateGenerator = (first, second) -> {         List<STATE> newState = new ArrayList<>().         for (STATE s : second) {             newState.add(inputAndOldStateToNewState.join(first, s)).         }         return newState.     }.     return new ArtificialListStateBuilder<>(listStateDescriptor.getName(), listStateGenerator, listStateGenerator, listStateDescriptor). }
false;static;1;12;;static SlidingEventTimeWindows createSlidingWindow(ParameterTool pt) {     long slideSize = pt.getLong(TEST_SLIDE_SIZE.key(), TEST_SLIDE_SIZE.defaultValue()).     long slideFactor = pt.getInt(TEST_SLIDE_FACTOR.key(), TEST_SLIDE_FACTOR.defaultValue()).     return SlidingEventTimeWindows.of(Time.milliseconds(slideSize * slideFactor), Time.milliseconds(slideSize)). }
false;static;1;6;;static FlatMapFunction<Tuple2<Integer, List<Event>>, String> createSlidingWindowCheckMapper(ParameterTool pt) {     return new SlidingWindowCheckMapper(pt.getInt(TEST_SLIDE_FACTOR.key(), TEST_SLIDE_FACTOR.defaultValue())). }
false;static;1;19;;static DataStream<Event> verifyCustomStatefulTypeSerializer(DataStream<Event> eventStream) {     return eventStream.map(new EventIdentityFunctionWithCustomEventTypeInformation()).name(RESULT_TYPE_QUERYABLE_MAPPER_WITH_CUSTOM_SER.getName()).uid(RESULT_TYPE_QUERYABLE_MAPPER_WITH_CUSTOM_SER.getUid()).keyBy(new EventKeySelectorWithCustomKeyTypeInformation()).map(e -> e).returns(new SingleThreadAccessCheckingTypeInfo<>(Event.class)).name(MAPPER_RETURNS_OUT_WITH_CUSTOM_SER.getName()).uid(MAPPER_RETURNS_OUT_WITH_CUSTOM_SER.getUid()).keyBy(new EventKeySelectorWithCustomKeyTypeInformation()).map(e -> e).name(EVENT_IDENTITY_MAPPER.getName()).uid(EVENT_IDENTITY_MAPPER.getUid()). }
false;public;1;4;;@Override public Event map(Event value) {     return value. }
false;public;0;4;;@Override public TypeInformation<Event> getProducedType() {     return typeInformation. }
false;public;1;4;;@Override public Integer getKey(Event value) {     return value.getKey(). }
false;public;0;4;;@Override public TypeInformation<Integer> getProducedType() {     return typeInformation. }
