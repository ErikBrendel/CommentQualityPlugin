commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;48;;public static void main(String[] args) throws Exception {     final ParameterTool pt = ParameterTool.fromArgs(args).     final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.setParallelism(pt.getInt("parallelism", 1)).     env.setMaxParallelism(pt.getInt("maxParallelism", pt.getInt("parallelism", 1))).     env.enableCheckpointing(pt.getInt("checkpointInterval", 1000)).     env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, pt.getInt("restartDelay", 0))).     if (pt.getBoolean("externalizedCheckpoints", false)) {         env.getCheckpointConfig().enableExternalizedCheckpoints(CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION).     }     String stateBackend = pt.get("stateBackend", "file").     String checkpointDir = pt.getRequired("checkpointDir").     boolean killJvmOnFail = pt.getBoolean("killJvmOnFail", false).     if ("file".equals(stateBackend)) {         boolean asyncCheckpoints = pt.getBoolean("asyncCheckpoints", true).         env.setStateBackend(new FsStateBackend(checkpointDir, asyncCheckpoints)).     } else if ("rocks".equals(stateBackend)) {         boolean incrementalCheckpoints = pt.getBoolean("incrementalCheckpoints", false).         env.setStateBackend(new RocksDBStateBackend(checkpointDir, incrementalCheckpoints)).     } else {         throw new IllegalArgumentException("Unknown backend: " + stateBackend).     }     // make parameters available in the web interface     env.getConfig().setGlobalJobParameters(pt).     // delay to throttle down the production of the source     long delay = pt.getLong("delay", 0L).     // the maximum number of attempts, before the job finishes with success     int maxAttempts = pt.getInt("maxAttempts", 3).     // size of one artificial value     int valueSize = pt.getInt("valueSize", 10).     env.addSource(new RandomLongSource(maxAttempts, delay)).keyBy((KeySelector<Long, Long>) aLong -> aLong).flatMap(new StateCreatingFlatMap(valueSize, killJvmOnFail)).addSink(new PrintSinkFunction<>()).     env.execute("Sticky Allocation And Local Recovery Test"). }
false;public;1;26;;@Override public void run(SourceContext<Long> sourceContext) throws Exception {     int numberOfParallelSubtasks = getRuntimeContext().getNumberOfParallelSubtasks().     int subtaskIdx = getRuntimeContext().getIndexOfThisSubtask().     // the source emits one final event and shuts down once we have reached max attempts.     if (getRuntimeContext().getAttemptNumber() > maxAttempts) {         synchronized (sourceContext.getCheckpointLock()) {             sourceContext.collect(Long.MAX_VALUE - subtaskIdx).         }         return.     }     while (running) {         synchronized (sourceContext.getCheckpointLock()) {             sourceContext.collect(currentKey).             currentKey += numberOfParallelSubtasks.         }         if (delay > 0) {             Thread.sleep(delay).         }     } }
false;public;0;4;;@Override public void cancel() {     running = false. }
false;public;1;5;;@Override public void snapshotState(FunctionSnapshotContext context) throws Exception {     sourceCurrentKeyState.clear().     sourceCurrentKeyState.add(currentKey). }
false;public;1;16;;@Override public void initializeState(FunctionInitializationContext context) throws Exception {     ListStateDescriptor<Long> currentKeyDescriptor = new ListStateDescriptor<>("currentKey", Long.class).     sourceCurrentKeyState = context.getOperatorStateStore().getListState(currentKeyDescriptor).     currentKey = getRuntimeContext().getIndexOfThisSubtask().     Iterable<Long> iterable = sourceCurrentKeyState.get().     if (iterable != null) {         Iterator<Long> iterator = iterable.iterator().         if (iterator.hasNext()) {             currentKey = iterator.next().             Preconditions.checkState(!iterator.hasNext()).         }     } }
false;public;2;26;;@Override public void flatMap(Long key, Collector<String> collector) throws IOException {     if (allocationFailureMessage != null) {         // Report the failure downstream, so that we can get the message from the output.         collector.collect(allocationFailureMessage).         allocationFailureMessage = null.     }     if (failTask) {         // we fail the task, either by killing the JVM hard, or by throwing a user code exception.         if (killTaskOnFailure) {             Runtime.getRuntime().halt(-1).         } else {             throw new RuntimeException("Artificial user code exception.").         }     }     // sanity check     if (null != valueState.value()) {         throw new IllegalStateException("This should never happen, keys are generated monotonously.").     }     // store artificial data to blow up the state     valueState.update(RandomStringUtils.random(valueSize, true, true)). }
false;public;1;3;;@Override public void snapshotState(FunctionSnapshotContext functionSnapshotContext) { }
false;public;1;70;;@Override public void initializeState(FunctionInitializationContext functionInitializationContext) throws Exception {     ValueStateDescriptor<String> stateDescriptor = new ValueStateDescriptor<>("state", String.class).     valueState = functionInitializationContext.getKeyedStateStore().getState(stateDescriptor).     ListStateDescriptor<MapperSchedulingAndFailureInfo> mapperInfoStateDescriptor = new ListStateDescriptor<>("mapperState", MapperSchedulingAndFailureInfo.class).     schedulingAndFailureState = functionInitializationContext.getOperatorStateStore().getUnionListState(mapperInfoStateDescriptor).     StreamingRuntimeContext runtimeContext = (StreamingRuntimeContext) getRuntimeContext().     String allocationID = runtimeContext.getAllocationIDAsString().     final int thisJvmPid = getJvmPid().     final Set<Integer> killedJvmPids = new HashSet<>().     // here we check if the sticky scheduling worked as expected     if (functionInitializationContext.isRestored()) {         Iterable<MapperSchedulingAndFailureInfo> iterable = schedulingAndFailureState.get().         String taskNameWithSubtasks = runtimeContext.getTaskNameWithSubtasks().         MapperSchedulingAndFailureInfo infoForThisTask = null.         List<MapperSchedulingAndFailureInfo> completeInfo = new ArrayList<>().         if (iterable != null) {             for (MapperSchedulingAndFailureInfo testInfo : iterable) {                 completeInfo.add(testInfo).                 if (taskNameWithSubtasks.equals(testInfo.taskNameWithSubtask)) {                     infoForThisTask = testInfo.                 }                 if (testInfo.killedJvm) {                     killedJvmPids.add(testInfo.jvmPid).                 }             }         }         Preconditions.checkNotNull(infoForThisTask, "Expected to find info here.").         if (!isScheduledToCorrectAllocation(infoForThisTask, allocationID, killedJvmPids)) {             allocationFailureMessage = String.format("Sticky allocation test failed: Subtask %s in attempt %d was rescheduled from allocation %s " + "on JVM with PID %d to unexpected allocation %s on JVM with PID %d.\n" + "Complete information from before the crash: %s.", runtimeContext.getTaskNameWithSubtasks(), runtimeContext.getAttemptNumber(), infoForThisTask.allocationId, infoForThisTask.jvmPid, allocationID, thisJvmPid, completeInfo).         }     }     // We determine which of the subtasks will produce the artificial failure     boolean failingTask = shouldTaskFailForThisAttempt().     // We take note of all the meta info that we require to check sticky scheduling in the next re-attempt     this.currentSchedulingAndFailureInfo = new MapperSchedulingAndFailureInfo(failingTask, failingTask && killTaskOnFailure, thisJvmPid, runtimeContext.getTaskNameWithSubtasks(), allocationID).     schedulingAndFailureState.clear().     schedulingAndFailureState.add(currentSchedulingAndFailureInfo). }
false;public;1;5;;@Override public void notifyCheckpointComplete(long checkpointId) {     // we can only fail the task after at least one checkpoint is completed to record progress.     failTask = currentSchedulingAndFailureInfo.failingTask. }
false;private;0;7;;private boolean shouldTaskFailForThisAttempt() {     RuntimeContext runtimeContext = getRuntimeContext().     int numSubtasks = runtimeContext.getNumberOfParallelSubtasks().     int subtaskIdx = runtimeContext.getIndexOfThisSubtask().     int attempt = runtimeContext.getAttemptNumber().     return (attempt % numSubtasks) == subtaskIdx. }
false;private;3;8;;private boolean isScheduledToCorrectAllocation(MapperSchedulingAndFailureInfo infoForThisTask, String allocationID, Set<Integer> killedJvmPids) {     return (infoForThisTask.allocationId.equals(allocationID) || killedJvmPids.contains(infoForThisTask.jvmPid)). }
true;private,static;0;13;/**  * This code is copied from Stack Overflow.  *  * <p><a href="https://stackoverflow.com/questions/35842">https://stackoverflow.com/questions/35842</a>, answer  * <a href="https://stackoverflow.com/a/12066696/9193881">https://stackoverflow.com/a/12066696/9193881</a>  *  * <p>Author: <a href="https://stackoverflow.com/users/446591/brad-mace">Brad Mace</a>)  */ ;/**  * This code is copied from Stack Overflow.  *  * <p><a href="https://stackoverflow.com/questions/35842">https://stackoverflow.com/questions/35842</a>, answer  * <a href="https://stackoverflow.com/a/12066696/9193881">https://stackoverflow.com/a/12066696/9193881</a>  *  * <p>Author: <a href="https://stackoverflow.com/users/446591/brad-mace">Brad Mace</a>)  */ private static int getJvmPid() throws Exception {     java.lang.management.RuntimeMXBean runtime = java.lang.management.ManagementFactory.getRuntimeMXBean().     java.lang.reflect.Field jvm = runtime.getClass().getDeclaredField("jvm").     jvm.setAccessible(true).     sun.management.VMManagement mgmt = (sun.management.VMManagement) jvm.get(runtime).     java.lang.reflect.Method pidMethod = mgmt.getClass().getDeclaredMethod("getProcessId").     pidMethod.setAccessible(true).     return (int) (Integer) pidMethod.invoke(mgmt). }
false;public;0;10;;@Override public String toString() {     return "MapperTestInfo{" + "failingTask=" + failingTask + ", killedJvm=" + killedJvm + ", jvmPid=" + jvmPid + ", taskNameWithSubtask='" + taskNameWithSubtask + '\'' + ", allocationId='" + allocationId + '\'' + '}'. }
