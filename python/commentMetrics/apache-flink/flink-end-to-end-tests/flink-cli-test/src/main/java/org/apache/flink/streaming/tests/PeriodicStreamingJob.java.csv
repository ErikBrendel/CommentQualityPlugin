commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;27;;public static void main(String[] args) throws Exception {     ParameterTool params = ParameterTool.fromArgs(args).     String outputPath = params.getRequired("outputPath").     int recordsPerSecond = params.getInt("recordsPerSecond", 10).     int duration = params.getInt("durationInSecond", 60).     int offset = params.getInt("offsetInSecond", 0).     StreamExecutionEnvironment sEnv = StreamExecutionEnvironment.getExecutionEnvironment().     sEnv.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime).     sEnv.enableCheckpointing(4000).     sEnv.getConfig().setAutoWatermarkInterval(1000).     // execute a simple pass through program.     PeriodicSourceGenerator generator = new PeriodicSourceGenerator(recordsPerSecond, duration, offset).     DataStream<Tuple> rows = sEnv.addSource(generator).     DataStream<Tuple> result = rows.keyBy(1).timeWindow(Time.seconds(5)).sum(0).     result.writeAsText(outputPath + "/result.txt", FileSystem.WriteMode.OVERWRITE).setParallelism(1).     sEnv.execute(). }
false;public;1;12;;@Override public void run(SourceContext<Tuple> ctx) throws Exception {     long offsetMs = offsetSeconds * 1000L.     while (ms < durationMs) {         synchronized (ctx.getCheckpointLock()) {             ctx.collect(new Tuple2<>(ms + offsetMs, "key")).         }         ms += sleepMs.         Thread.sleep(sleepMs).     } }
false;public;0;4;;@Override public void cancel() { // nothing to do }
false;public;0;4;;@Override public TypeInformation<Tuple> getProducedType() {     return Types.TUPLE(Types.LONG, Types.STRING). }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) {     return Collections.singletonList(ms). }
false;public;1;6;;@Override public void restoreState(List<Long> state) {     for (Long l : state) {         ms += l.     } }
