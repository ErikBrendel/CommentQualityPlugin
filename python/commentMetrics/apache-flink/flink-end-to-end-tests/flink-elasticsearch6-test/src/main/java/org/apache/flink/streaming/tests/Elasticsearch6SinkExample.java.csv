commented;modifiers;parameterAmount;loc;comment;code
false;public;2;7;;@Override public void flatMap(Long value, Collector<Tuple2<String, String>> out) {     final String key = String.valueOf(value).     final String message = "message #" + value.     out.collect(Tuple2.of(key, message + "update #1")).     out.collect(Tuple2.of(key, message + "update #2")). }
false;public,static;1;45;;public static void main(String[] args) throws Exception {     final ParameterTool parameterTool = ParameterTool.fromArgs(args).     if (parameterTool.getNumberOfParameters() < 3) {         System.out.println("Missing parameters!\n" + "Usage: --numRecords <numRecords> --index <index> --type <type>").         return.     }     final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().     env.getConfig().disableSysoutLogging().     env.enableCheckpointing(5000).     DataStream<Tuple2<String, String>> source = env.generateSequence(0, parameterTool.getInt("numRecords") - 1).flatMap(new FlatMapFunction<Long, Tuple2<String, String>>() {          @Override         public void flatMap(Long value, Collector<Tuple2<String, String>> out) {             final String key = String.valueOf(value).             final String message = "message #" + value.             out.collect(Tuple2.of(key, message + "update #1")).             out.collect(Tuple2.of(key, message + "update #2")).         }     }).     List<HttpHost> httpHosts = new ArrayList<>().     httpHosts.add(new HttpHost("127.0.0.1", 9200, "http")).     ElasticsearchSink.Builder<Tuple2<String, String>> esSinkBuilder = new ElasticsearchSink.Builder<>(httpHosts, (Tuple2<String, String> element, RuntimeContext ctx, RequestIndexer indexer) -> {         indexer.add(createIndexRequest(element.f1, parameterTool)).         indexer.add(createUpdateRequest(element, parameterTool)).     }).     esSinkBuilder.setFailureHandler(new CustomFailureHandler(parameterTool.getRequired("index"), parameterTool.getRequired("type"))).     // this instructs the sink to emit after every element, otherwise they would be buffered     esSinkBuilder.setBulkFlushMaxActions(1).     source.addSink(esSinkBuilder.build()).     env.execute("Elasticsearch 6.x end to end sink test example"). }
false;public;4;16;;@Override public void onFailure(ActionRequest action, Throwable failure, int restStatusCode, RequestIndexer indexer) throws Throwable {     if (action instanceof IndexRequest) {         Map<String, Object> json = new HashMap<>().         json.put("data", ((IndexRequest) action).source()).         indexer.add(Requests.indexRequest().index(index).type(type).id(((IndexRequest) action).id()).source(json)).     } else {         throw new IllegalStateException("unexpected").     } }
false;private,static;2;21;;private static IndexRequest createIndexRequest(String element, ParameterTool parameterTool) {     Map<String, Object> json = new HashMap<>().     json.put("data", element).     String index.     String type.     if (element.startsWith("message #15")) {         index = ":intentional invalid index:".         type = ":intentional invalid type:".     } else {         index = parameterTool.getRequired("index").         type = parameterTool.getRequired("type").     }     return Requests.indexRequest().index(index).type(type).id(element).source(json). }
false;private,static;2;11;;private static UpdateRequest createUpdateRequest(Tuple2<String, String> element, ParameterTool parameterTool) {     Map<String, Object> json = new HashMap<>().     json.put("data", element.f1).     return new UpdateRequest(parameterTool.getRequired("index"), parameterTool.getRequired("type"), element.f0).doc(json).upsert(json). }
