commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;26;;public static void main(String[] args) throws Exception {     ParameterTool params = ParameterTool.fromArgs(args).     String outputPath = params.getRequired("outputPath").     StreamExecutionEnvironment sEnv = StreamExecutionEnvironment.getExecutionEnvironment().     sEnv.setRestartStrategy(RestartStrategies.fixedDelayRestart(3, Time.of(10, TimeUnit.SECONDS))).     sEnv.enableCheckpointing(4000).     final int idlenessMs = 10.     // define bucketing sink to emit the result     BucketingSink<Tuple4<Integer, Long, Integer, String>> sink = new BucketingSink<Tuple4<Integer, Long, Integer, String>>(outputPath).setBucketer(new KeyBucketer()).     // generate data, shuffle, perform stateful operation, sink     sEnv.addSource(new Generator(10, idlenessMs, 60)).keyBy(0).map(new SubtractingMapper(-1L * idlenessMs)).addSink(sink).     sEnv.execute(). }
false;public;3;4;;@Override public Path getBucketPath(Clock clock, Path basePath, Tuple4<Integer, Long, Integer, String> element) {     return basePath.suffix(String.valueOf(element.f0)). }
false;public;1;5;;@Override public void open(Configuration parameters) {     counter = getRuntimeContext().getState(new ValueStateDescriptor<>("counter", Types.INT)).     last = getRuntimeContext().getState(new ValueStateDescriptor<>("last", Types.LONG)). }
false;public;1;18;;@Override public Tuple4<Integer, Long, Integer, String> map(Tuple3<Integer, Long, String> value) throws IOException {     // update counter     Integer counterValue = counter.value().     if (counterValue == null) {         counterValue = 0.     }     counter.update(counterValue + 1).     // save last value     Long lastValue = last.value().     if (lastValue == null) {         lastValue = initialValue.     }     last.update(value.f1).     return Tuple4.of(value.f0, value.f1 - lastValue, counterValue, value.f2). }
false;public;1;12;;@Override public void run(SourceContext<Tuple3<Integer, Long, String>> ctx) throws Exception {     while (ms < durationMs) {         synchronized (ctx.getCheckpointLock()) {             for (int i = 0. i < numKeys. i++) {                 ctx.collect(Tuple3.of(i, ms, "Some payload...")).             }             ms += idlenessMs.         }         Thread.sleep(idlenessMs).     } }
false;public;0;2;;@Override public void cancel() { }
false;public;2;4;;@Override public List<Long> snapshotState(long checkpointId, long timestamp) {     return Collections.singletonList(ms). }
false;public;1;6;;@Override public void restoreState(List<Long> state) {     for (Long l : state) {         ms += l.     } }
