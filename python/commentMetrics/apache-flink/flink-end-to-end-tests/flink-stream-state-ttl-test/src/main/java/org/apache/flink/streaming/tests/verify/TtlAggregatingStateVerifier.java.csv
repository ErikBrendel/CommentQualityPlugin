commented;modifiers;parameterAmount;loc;comment;code
false;;1;5;;@Override @Nonnull State createState(@Nonnull FunctionInitializationContext context) {     return context.getKeyedStateStore().getAggregatingState(stateDesc). }
false;public;0;5;;@Override @Nonnull public TypeSerializer<Integer> getUpdateSerializer() {     return IntSerializer.INSTANCE. }
false;public;0;5;;@Override @Nonnull public Integer generateRandomUpdate() {     return RANDOM.nextInt(100). }
false;;1;4;;@Override String getInternal(@Nonnull AggregatingState<Integer, String> state) throws Exception {     return state.get(). }
false;;2;4;;@Override void updateInternal(@Nonnull AggregatingState<Integer, String> state, Integer update) throws Exception {     state.add(update). }
false;;2;16;;@Override String expected(@Nonnull List<ValueWithTs<Integer>> updates, long currentTimestamp) {     if (updates.isEmpty()) {         return null.     }     long acc = AGG_FUNC.createAccumulator().     long lastTs = updates.get(0).getTimestamp().     for (ValueWithTs<Integer> update : updates) {         if (expired(lastTs, update.getTimestamp())) {             acc = AGG_FUNC.createAccumulator().         }         acc = AGG_FUNC.add(update.getValue(), acc).         lastTs = update.getTimestamp().     }     return expired(lastTs, currentTimestamp) ? null : AGG_FUNC.getResult(acc). }
false;public;0;4;;@Override public Long createAccumulator() {     return 3L. }
false;public;2;4;;@Override public Long add(Integer value, Long accumulator) {     return accumulator + value. }
false;public;1;4;;@Override public String getResult(Long accumulator) {     return Long.toString(accumulator). }
false;public;2;4;;@Override public Long merge(Long a, Long b) {     return a + b. }
