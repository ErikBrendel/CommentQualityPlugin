commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void startExecutor() {     scheduledExecutorService = Executors.newScheduledThreadPool(4). }
false;public,static;0;6;;@AfterClass public static void shutdownExecutor() {     if (scheduledExecutorService != null) {         scheduledExecutorService.shutdown().     } }
false;public;0;14;;@Test public void testReporter() throws Exception {     dist.startFlinkCluster().     final RestClient restClient = new RestClient(RestClientConfiguration.fromConfiguration(new Configuration()), scheduledExecutorService).     checkJobManagerMetricAvailability(restClient).     final Collection<ResourceID> taskManagerIds = getTaskManagerIds(restClient).     for (final ResourceID taskManagerId : taskManagerIds) {         checkTaskManagerMetricAvailability(restClient, taskManagerId).     } }
false;private,static;1;9;;private static void checkJobManagerMetricAvailability(final RestClient restClient) throws Exception {     final JobManagerMetricsHeaders headers = JobManagerMetricsHeaders.getInstance().     final JobManagerMetricsMessageParameters parameters = headers.getUnresolvedMessageParameters().     parameters.metricsFilterParameter.resolve(Collections.singletonList("numRegisteredTaskManagers")).     fetchMetric(() -> restClient.sendRequest(HOST, PORT, headers, parameters, EmptyRequestBody.getInstance()), getMetricNamePredicate("numRegisteredTaskManagers")). }
false;private,static;1;16;;private static Collection<ResourceID> getTaskManagerIds(final RestClient restClient) throws Exception {     final TaskManagersHeaders headers = TaskManagersHeaders.getInstance().     final TaskManagersInfo response = fetchMetric(() -> restClient.sendRequest(HOST, PORT, headers, EmptyMessageParameters.getInstance(), EmptyRequestBody.getInstance()), taskManagersInfo -> !taskManagersInfo.getTaskManagerInfos().isEmpty()).     return response.getTaskManagerInfos().stream().map(TaskManagerInfo::getResourceId).collect(Collectors.toList()). }
false;private,static;2;10;;private static void checkTaskManagerMetricAvailability(final RestClient restClient, final ResourceID taskManagerId) throws Exception {     final TaskManagerMetricsHeaders headers = TaskManagerMetricsHeaders.getInstance().     final TaskManagerMetricsMessageParameters parameters = headers.getUnresolvedMessageParameters().     parameters.taskManagerIdParameter.resolve(taskManagerId).     parameters.metricsFilterParameter.resolve(Collections.singletonList("Status.Network.TotalMemorySegments")).     fetchMetric(() -> restClient.sendRequest(HOST, PORT, headers, parameters, EmptyRequestBody.getInstance()), getMetricNamePredicate("Status.Network.TotalMemorySegments")). }
false;private,static;2;15;;private static <X> X fetchMetric(final SupplierWithException<CompletableFuture<X>, IOException> clientOperation, final Predicate<X> predicate) throws InterruptedException, ExecutionException, TimeoutException {     final CompletableFuture<X> responseFuture = FutureUtils.retrySuccessfulWithDelay(() -> {         try {             return clientOperation.get().         } catch (IOException e) {             throw new RuntimeException(e).         }     }, Time.seconds(1), Deadline.fromNow(Duration.ofSeconds(5)), predicate, new ScheduledExecutorServiceAdapter(scheduledExecutorService)).     return responseFuture.get(30, TimeUnit.SECONDS). }
false;private,static;1;3;;private static Predicate<MetricCollectionResponseBody> getMetricNamePredicate(final String metricName) {     return response -> response.getMetrics().stream().anyMatch(metric -> metric.getId().equals(metricName)). }
