commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;8;;@Override protected void before() throws IOException {     defaultConfig = new UnmodifiableConfiguration(GlobalConfiguration.loadConfiguration(conf.toAbsolutePath().toString())).     final Path originalConfig = conf.resolve(FLINK_CONF_YAML).     final Path backupConfig = conf.resolve(FLINK_CONF_YAML_BACKUP).     Files.copy(originalConfig, backupConfig).     filesToDelete.add(new AutoClosablePath(backupConfig)). }
false;protected;0;25;;@Override protected void after() {     try {         stopFlinkCluster().     } catch (IOException e) {         LOG.error("Failure while shutting down Flink cluster.", e).     }     final Path originalConfig = conf.resolve(FLINK_CONF_YAML).     final Path backupConfig = conf.resolve(FLINK_CONF_YAML_BACKUP).     try {         Files.move(backupConfig, originalConfig, StandardCopyOption.REPLACE_EXISTING).     } catch (IOException e) {         LOG.error("Failed to restore flink-conf.yaml", e).     }     for (AutoCloseable fileToDelete : filesToDelete) {         try {             fileToDelete.close().         } catch (Exception e) {             LOG.error("Failure while cleaning up file.", e).         }     } }
false;public;0;37;;public void startFlinkCluster() throws IOException {     AutoClosableProcess.runBlocking("Start Flink cluster", bin.resolve("start-cluster.sh").toAbsolutePath().toString()).     final OkHttpClient client = new OkHttpClient().     final Request request = new Request.Builder().get().url("http://localhost:8081/taskmanagers").build().     Exception reportedException = null.     for (int retryAttempt = 0. retryAttempt < 30. retryAttempt++) {         try (Response response = client.newCall(request).execute()) {             if (response.isSuccessful()) {                 final String json = response.body().string().                 final JsonNode taskManagerList = OBJECT_MAPPER.readTree(json).get("taskmanagers").                 if (taskManagerList != null && taskManagerList.size() > 0) {                     LOG.info("Dispatcher REST endpoint is up.").                     return.                 }             }         } catch (IOException ioe) {             reportedException = ExceptionUtils.firstOrSuppressed(ioe, reportedException).         }         LOG.info("Waiting for dispatcher REST endpoint to come up...").         try {             Thread.sleep(1000).         } catch (InterruptedException e) {             Thread.currentThread().interrupt().             reportedException = ExceptionUtils.firstOrSuppressed(e, reportedException).         }     }     throw new AssertionError("Dispatcher REST endpoint did not start in time.", reportedException). }
false;public;0;3;;public void stopFlinkCluster() throws IOException {     AutoClosableProcess.runBlocking("Stop Flink Cluster", bin.resolve("stop-cluster.sh").toAbsolutePath().toString()). }
false;public;1;16;;public void copyOptJarsToLib(String jarNamePrefix) throws FileNotFoundException, IOException {     final Optional<Path> reporterJarOptional.     try (Stream<Path> logFiles = Files.walk(opt)) {         reporterJarOptional = logFiles.filter(path -> path.getFileName().toString().startsWith(jarNamePrefix)).findFirst().     }     if (reporterJarOptional.isPresent()) {         final Path optReporterJar = reporterJarOptional.get().         final Path libReporterJar = lib.resolve(optReporterJar.getFileName()).         Files.copy(optReporterJar, libReporterJar).         filesToDelete.add(new AutoClosablePath(libReporterJar)).     } else {         throw new FileNotFoundException("No jar could be found matching the pattern " + jarNamePrefix + ".").     } }
false;public;1;11;;public void appendConfiguration(Configuration config) throws IOException {     final Configuration mergedConfig = new Configuration().     mergedConfig.addAll(defaultConfig).     mergedConfig.addAll(config).     final List<String> configurationLines = mergedConfig.toMap().entrySet().stream().map(entry -> entry.getKey() + ": " + entry.getValue()).collect(Collectors.toList()).     Files.write(conf.resolve("flink-conf.yaml"), configurationLines). }
false;public;2;24;;public Stream<String> searchAllLogs(Pattern pattern, Function<Matcher, String> matchProcessor) throws IOException {     final List<String> matches = new ArrayList<>(2).     try (Stream<Path> logFilesStream = Files.list(log)) {         final Iterator<Path> logFiles = logFilesStream.iterator().         while (logFiles.hasNext()) {             final Path logFile = logFiles.next().             if (!logFile.getFileName().toString().endsWith(".log")) {                 // ignore logs for previous runs that have a number suffix                 continue.             }             try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(logFile.toFile()), StandardCharsets.UTF_8))) {                 String line.                 while ((line = br.readLine()) != null) {                     Matcher matcher = pattern.matcher(line).                     if (matcher.matches()) {                         matches.add(matchProcessor.apply(matcher)).                     }                 }             }         }     }     return matches.stream(). }
