commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;5;;public static void main(String[] args) {     final ParameterTool params = ParameterTool.fromArgs(args).     final Action action = Action.valueOf(params.getRequired("action")).     handlers.get(action).accept(params). }
false;private,static;1;5;;private static void listByFullPathPrefix(ParameterTool params) {     final String bucket = params.getRequired("bucket").     final String s3prefix = params.getRequired("s3prefix").     listByFullPathPrefix(bucket, s3prefix).forEach(System.out::println). }
false;private,static;2;4;;private static List<String> listByFullPathPrefix(final String bucket, final String s3prefix) {     return AmazonS3ClientBuilder.defaultClient().listObjects(bucket, s3prefix).getObjectSummaries().stream().map(S3ObjectSummary::getKey).collect(Collectors.toList()). }
false;private,static;1;13;;private static void downloadFile(ParameterTool params) {     final String bucket = params.getRequired("bucket").     final String s3file = params.getRequired("s3file").     final String localFile = params.getRequired("localFile").     TransferManager tx = TransferManagerBuilder.defaultTransferManager().     try {         tx.download(bucket, s3file, new File(localFile)).waitForCompletion().     } catch (InterruptedException e) {         System.out.println("Transfer interrupted").     } finally {         tx.shutdownNow().     } }
false;private,static;1;17;;private static void downloadByFullPathAndFileNamePrefix(ParameterTool params) {     final String bucket = params.getRequired("bucket").     final String s3prefix = params.getRequired("s3prefix").     final String localFolder = params.getRequired("localFolder").     final String s3filePrefix = params.get("s3filePrefix", "").     TransferManager tx = TransferManagerBuilder.defaultTransferManager().     Predicate<String> keyPredicate = getKeyFilterByFileNamePrefix(s3filePrefix).     KeyFilter keyFilter = s3filePrefix.isEmpty() ? KeyFilter.INCLUDE_ALL : objectSummary -> keyPredicate.test(objectSummary.getKey()).     try {         tx.downloadDirectory(bucket, s3prefix, new File(localFolder), keyFilter).waitForCompletion().     } catch (InterruptedException e) {         System.out.println("Transfer interrupted").     } finally {         tx.shutdownNow().     } }
false;private,static;1;11;;private static Predicate<String> getKeyFilterByFileNamePrefix(String s3filePrefix) {     if (s3filePrefix.isEmpty()) {         return key -> true.     } else {         return key -> {             String[] parts = key.split("/").             String fileName = parts[parts.length - 1].             return fileName.startsWith(s3filePrefix).         }.     } }
false;private,static;1;5;;private static void deleteFile(ParameterTool params) {     final String bucket = params.getRequired("bucket").     final String s3file = params.getRequired("s3file").     AmazonS3ClientBuilder.defaultClient().deleteObject(bucket, s3file). }
false;private,static;1;9;;private static void deleteByFullPathPrefix(ParameterTool params) {     final String bucket = params.getRequired("bucket").     final String s3prefix = params.getRequired("s3prefix").     String[] keys = listByFullPathPrefix(bucket, s3prefix).toArray(new String[] {}).     if (keys.length > 0) {         DeleteObjectsRequest request = new DeleteObjectsRequest(bucket).withKeys(keys).         AmazonS3ClientBuilder.defaultClient().deleteObjects(request).     } }
false;private,static;1;7;;private static void numberOfLinesInFile(ParameterTool params) {     final String bucket = params.getRequired("bucket").     final String s3file = params.getRequired("s3file").     AmazonS3 s3client = AmazonS3ClientBuilder.defaultClient().     System.out.print(S3QueryUtil.queryFile(s3client, bucket, s3file, countQuery)).     s3client.shutdown(). }
false;private,static;1;18;;private static void numberOfLinesInFilesWithFullAndNamePrefix(ParameterTool params) {     final String bucket = params.getRequired("bucket").     final String s3prefix = params.getRequired("s3prefix").     final String s3filePrefix = params.get("s3filePrefix", "").     int parallelism = params.getInt("parallelism", 10).     List<String> files = listByFullPathPrefix(bucket, s3prefix).     ExecutorService executor = Executors.newFixedThreadPool(parallelism).     AmazonS3 s3client = AmazonS3ClientBuilder.defaultClient().     List<CompletableFuture<Integer>> requests = submitLineCountingRequestsForFilesAsync(executor, s3client, bucket, files, s3filePrefix).     int count = waitAndComputeTotalLineCountResult(requests).     executor.shutdownNow().     s3client.shutdown().     System.out.print(count). }
false;private,static;5;14;;private static List<CompletableFuture<Integer>> submitLineCountingRequestsForFilesAsync(ExecutorService executor, AmazonS3 s3client, String bucket, List<String> files, String s3filePrefix) {     List<CompletableFuture<Integer>> requests = new ArrayList<>().     Predicate<String> keyPredicate = getKeyFilterByFileNamePrefix(s3filePrefix).     files.forEach(file -> {         if (keyPredicate.test(file)) {             CompletableFuture<Integer> result = new CompletableFuture<>().             executor.execute(() -> result.complete(Integer.parseInt(S3QueryUtil.queryFile(s3client, bucket, file, countQuery)))).             requests.add(result).         }     }).     return requests. }
false;private,static;1;12;;private static int waitAndComputeTotalLineCountResult(List<CompletableFuture<Integer>> requests) {     int count = 0.     for (CompletableFuture<Integer> result : requests) {         try {             count += result.get().         } catch (Throwable e) {             System.out.println("Failed count lines").             e.printStackTrace().         }     }     return count. }
