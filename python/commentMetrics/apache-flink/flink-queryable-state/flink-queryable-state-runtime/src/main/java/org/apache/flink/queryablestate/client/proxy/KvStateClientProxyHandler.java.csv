commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;12;;private static Client<KvStateInternalRequest, KvStateResponse> createInternalClient(int threads) {     final MessageSerializer<KvStateInternalRequest, KvStateResponse> messageSerializer = new MessageSerializer<>(new KvStateInternalRequest.KvStateInternalRequestDeserializer(), new KvStateResponse.KvStateResponseDeserializer()).     return new Client<>("Queryable State Proxy Client", threads, messageSerializer, new DisabledKvStateRequestStats()). }
false;public;2;8;;@Override public CompletableFuture<KvStateResponse> handleRequest(final long requestId, final KvStateRequest request) {     CompletableFuture<KvStateResponse> response = new CompletableFuture<>().     executeActionAsync(response, request, false).     return response. }
false;private;3;34;;private void executeActionAsync(final CompletableFuture<KvStateResponse> result, final KvStateRequest request, final boolean update) {     if (!result.isDone()) {         final CompletableFuture<KvStateResponse> operationFuture = getState(request, update).         operationFuture.whenCompleteAsync((t, throwable) -> {             if (throwable != null) {                 if (throwable.getCause() instanceof UnknownKvStateIdException || throwable.getCause() instanceof UnknownKvStateKeyGroupLocationException || throwable.getCause() instanceof ConnectException) {                     // These failures are likely to be caused by out-of-sync                     // KvStateLocation. Therefore we retry this query and                     // force look up the location.                     LOG.debug("Retrying after failing to retrieve state due to: {}.", throwable.getCause().getMessage()).                     executeActionAsync(result, request, true).                 } else {                     result.completeExceptionally(throwable).                 }             } else {                 result.complete(t).             }         }, queryExecutor).         result.whenComplete((t, throwable) -> operationFuture.cancel(false)).     } }
false;private;2;21;;private CompletableFuture<KvStateResponse> getState(final KvStateRequest request, final boolean forceUpdate) {     return getKvStateLookupInfo(request.getJobId(), request.getStateName(), forceUpdate).thenComposeAsync((Function<KvStateLocation, CompletableFuture<KvStateResponse>>) location -> {         final int keyGroupIndex = KeyGroupRangeAssignment.computeKeyGroupForKeyHash(request.getKeyHashCode(), location.getNumKeyGroups()).         final InetSocketAddress serverAddress = location.getKvStateServerAddress(keyGroupIndex).         if (serverAddress == null) {             return FutureUtils.completedExceptionally(new UnknownKvStateKeyGroupLocationException(getServerName())).         } else {             final KvStateID kvStateId = location.getKvStateID(keyGroupIndex).             final KvStateInternalRequest internalRequest = new KvStateInternalRequest(kvStateId, request.getSerializedKeyAndNamespace()).             return kvStateClient.sendRequest(serverAddress, internalRequest).         }     }, queryExecutor). }
true;private;3;43;/**  * Lookup the {@link KvStateLocation} for the given job and queryable state name.  *  * <p>The job manager will be queried for the location only if forced or no  * cached location can be found. There are no guarantees about  *  * @param jobId              JobID the state instance belongs to.  * @param queryableStateName Name under which the state instance has been published.  * @param forceUpdate        Flag to indicate whether to force a update via the lookup service.  * @return Future holding the KvStateLocation  */ ;/**  * Lookup the {@link KvStateLocation} for the given job and queryable state name.  *  * <p>The job manager will be queried for the location only if forced or no  * cached location can be found. There are no guarantees about  *  * @param jobId              JobID the state instance belongs to.  * @param queryableStateName Name under which the state instance has been published.  * @param forceUpdate        Flag to indicate whether to force a update via the lookup service.  * @return Future holding the KvStateLocation  */ private CompletableFuture<KvStateLocation> getKvStateLookupInfo(final JobID jobId, final String queryableStateName, final boolean forceUpdate) {     final Tuple2<JobID, String> cacheKey = new Tuple2<>(jobId, queryableStateName).     final CompletableFuture<KvStateLocation> cachedFuture = lookupCache.get(cacheKey).     if (!forceUpdate && cachedFuture != null && !cachedFuture.isCompletedExceptionally()) {         LOG.debug("Retrieving location for state={} of job={} from the cache.", queryableStateName, jobId).         return cachedFuture.     }     final KvStateLocationOracle kvStateLocationOracle = proxy.getKvStateLocationOracle(jobId).     if (kvStateLocationOracle != null) {         LOG.debug("Retrieving location for state={} of job={} from the key-value state location oracle.", queryableStateName, jobId).         final CompletableFuture<KvStateLocation> location = new CompletableFuture<>().         lookupCache.put(cacheKey, location).         kvStateLocationOracle.requestKvStateLocation(jobId, queryableStateName).whenComplete((KvStateLocation kvStateLocation, Throwable throwable) -> {             if (throwable != null) {                 if (ExceptionUtils.stripCompletionException(throwable) instanceof FlinkJobNotFoundException) {                     // if the jobId was wrong, remove the entry from the cache.                     lookupCache.remove(cacheKey).                 }                 location.completeExceptionally(throwable).             } else {                 location.complete(kvStateLocation).             }         }).         return location.     } else {         return FutureUtils.completedExceptionally(new UnknownLocationException("Could not retrieve location of state=" + queryableStateName + " of job=" + jobId + ". Potential reasons are: i) the state is not ready, or ii) the job does not exist.")).     } }
false;public;0;4;;@Override public CompletableFuture<Void> shutdown() {     return kvStateClient.shutdown(). }
