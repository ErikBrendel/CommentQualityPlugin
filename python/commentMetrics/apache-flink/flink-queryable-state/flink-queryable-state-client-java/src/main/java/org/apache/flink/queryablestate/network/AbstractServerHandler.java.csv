commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected String getServerName() {     return server.getServerName(). }
false;public;1;4;;@Override public void channelActive(ChannelHandlerContext ctx) throws Exception {     stats.reportActiveConnection(). }
false;public;1;4;;@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {     stats.reportInactiveConnection(). }
false;public;2;63;;@Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {     REQ request = null.     long requestId = -1L.     try {         final ByteBuf buf = (ByteBuf) msg.         final MessageType msgType = MessageSerializer.deserializeHeader(buf).         requestId = MessageSerializer.getRequestId(buf).         if (msgType == MessageType.REQUEST) {             // ------------------------------------------------------------             // MessageBody             // ------------------------------------------------------------             request = serializer.deserializeRequest(buf).             stats.reportRequest().             // Execute actual query async, because it is possibly             // blocking (e.g. file I/O).             //              // A submission failure is not treated as fatal.             queryExecutor.submit(new AsyncRequestTask<>(this, ctx, requestId, request, stats)).         } else {             // ------------------------------------------------------------             // Unexpected             // ------------------------------------------------------------             final String errMsg = "Unexpected message type " + msgType + ". Expected " + MessageType.REQUEST + ".".             final ByteBuf failure = MessageSerializer.serializeServerFailure(ctx.alloc(), new IllegalArgumentException(errMsg)).             LOG.debug(errMsg).             ctx.writeAndFlush(failure).         }     } catch (Throwable t) {         final String stringifiedCause = ExceptionUtils.stringifyException(t).         String errMsg.         ByteBuf err.         if (request != null) {             errMsg = "Failed request with ID " + requestId + ". Caused by: " + stringifiedCause.             err = MessageSerializer.serializeRequestFailure(ctx.alloc(), requestId, new RuntimeException(errMsg)).             stats.reportFailedRequest().         } else {             errMsg = "Failed incoming message. Caused by: " + stringifiedCause.             err = MessageSerializer.serializeServerFailure(ctx.alloc(), new RuntimeException(errMsg)).         }         LOG.debug(errMsg).         ctx.writeAndFlush(err).     } finally {         // IMPORTANT: We have to always recycle the incoming buffer.         // Otherwise we will leak memory out of Netty's buffer pool.         //          // If any operation ever holds on to the buffer, it is the         // responsibility of that operation to retain the buffer and         // release it later.         ReferenceCountUtil.release(msg).     } }
false;public;2;8;;@Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {     final String msg = "Exception in server pipeline. Caused by: " + ExceptionUtils.stringifyException(cause).     final ByteBuf err = MessageSerializer.serializeServerFailure(ctx.alloc(), new RuntimeException(msg)).     LOG.debug(msg).     ctx.writeAndFlush(err).addListener(ChannelFutureListener.CLOSE). }
true;public,abstract;2;1;/**  * Handles an incoming request and returns a {@link CompletableFuture} containing the corresponding response.  *  * <p><b>NOTE:</b> This method is called by multiple threads.  *  * @param requestId the id of the received request to be handled.  * @param request the request to be handled.  * @return A future with the response to be forwarded to the client.  */ ;/**  * Handles an incoming request and returns a {@link CompletableFuture} containing the corresponding response.  *  * <p><b>NOTE:</b> This method is called by multiple threads.  *  * @param requestId the id of the received request to be handled.  * @param request the request to be handled.  * @return A future with the response to be forwarded to the client.  */ public abstract CompletableFuture<RESP> handleRequest(final long requestId, final REQ request).
true;public,abstract;0;1;/**  * Shuts down any handler-specific resources, e.g. thread pools etc and returns  * a {@link CompletableFuture}.  *  * <p>If an exception is thrown during the shutdown process, then that exception  * will be included in the returned future.  *  * @return A {@link CompletableFuture} that will be completed when the shutdown  * process actually finishes.  */ ;/**  * Shuts down any handler-specific resources, e.g. thread pools etc and returns  * a {@link CompletableFuture}.  *  * <p>If an exception is thrown during the shutdown process, then that exception  * will be included in the returned future.  *  * @return A {@link CompletableFuture} that will be completed when the shutdown  * process actually finishes.  */ public abstract CompletableFuture<Void> shutdown().
false;public;0;52;;@Override public void run() {     if (!ctx.channel().isActive()) {         return.     }     handler.handleRequest(requestId, request).whenComplete((resp, throwable) -> {         try {             if (throwable != null) {                 throw throwable instanceof CompletionException ? throwable.getCause() : throwable.             }             if (resp == null) {                 throw new BadRequestException(handler.getServerName(), "NULL returned for request with ID " + requestId + ".").             }             final ByteBuf serialResp = MessageSerializer.serializeResponse(ctx.alloc(), requestId, resp).             int highWatermark = ctx.channel().config().getWriteBufferHighWaterMark().             ChannelFuture write.             if (serialResp.readableBytes() <= highWatermark) {                 write = ctx.writeAndFlush(serialResp).             } else {                 write = ctx.writeAndFlush(new ChunkedByteBuf(serialResp, highWatermark)).             }             write.addListener(new RequestWriteListener()).         } catch (BadRequestException e) {             try {                 stats.reportFailedRequest().                 final ByteBuf err = MessageSerializer.serializeRequestFailure(ctx.alloc(), requestId, e).                 ctx.writeAndFlush(err).             } catch (IOException io) {                 LOG.error("Failed to respond with the error after failed request", io).             }         } catch (Throwable t) {             try {                 stats.reportFailedRequest().                 final String errMsg = "Failed request " + requestId + "." + System.lineSeparator() + " Caused by: " + ExceptionUtils.stringifyException(t).                 final ByteBuf err = MessageSerializer.serializeRequestFailure(ctx.alloc(), requestId, new RuntimeException(errMsg)).                 ctx.writeAndFlush(err).             } catch (IOException io) {                 LOG.error("Failed to respond with the error after failed request", io).             }         }     }). }
false;public;0;7;;@Override public String toString() {     return "AsyncRequestTask{" + "requestId=" + requestId + ", request=" + request + '}'. }
false;public;1;13;;@Override public void operationComplete(ChannelFuture future) throws Exception {     long durationNanos = System.nanoTime() - creationNanos.     long durationMillis = TimeUnit.MILLISECONDS.convert(durationNanos, TimeUnit.NANOSECONDS).     if (future.isSuccess()) {         LOG.debug("Request {} was successfully answered after {} ms.", request, durationMillis).         stats.reportSuccessfulRequest(durationMillis).     } else {         LOG.debug("Request {} failed after {} ms due to: {}", request, durationMillis, future.cause()).         stats.reportFailedRequest().     } }
