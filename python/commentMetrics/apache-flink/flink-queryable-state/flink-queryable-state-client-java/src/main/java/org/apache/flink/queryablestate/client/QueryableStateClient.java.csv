commented;modifiers;parameterAmount;loc;comment;code
false;;2;1;;<T, S extends State> S createState(StateDescriptor<S, T> stateDesc, byte[] serializedState) throws Exception.
true;public;0;3;/**  * Shuts down the client and returns a {@link CompletableFuture} that  * will be completed when the shutdown process is completed.  *  * <p>If an exception is thrown for any reason, then the returned future  * will be completed exceptionally with that exception.  *  * @return A {@link CompletableFuture} for further handling of the  * shutdown result.  */ ;/**  * Shuts down the client and returns a {@link CompletableFuture} that  * will be completed when the shutdown process is completed.  *  * <p>If an exception is thrown for any reason, then the returned future  * will be completed exceptionally with that exception.  *  * @return A {@link CompletableFuture} for further handling of the  * shutdown result.  */ public CompletableFuture<?> shutdownAndHandle() {     return client.shutdown(). }
true;public;0;8;/**  * Shuts down the client and waits until shutdown is completed.  *  * <p>If an exception is thrown, a warning is logged containing  * the exception message.  */ ;/**  * Shuts down the client and waits until shutdown is completed.  *  * <p>If an exception is thrown, a warning is logged containing  * the exception message.  */ public void shutdownAndWait() {     try {         client.shutdown().get().         LOG.info("The Queryable State Client was shutdown successfully.").     } catch (Exception e) {         LOG.warn("The Queryable State Client shutdown failed: ", e).     } }
true;public;0;3;/**  * Gets the {@link ExecutionConfig}.  */ ;/**  * Gets the {@link ExecutionConfig}.  */ public ExecutionConfig getExecutionConfig() {     return executionConfig. }
true;public;1;5;/**  * Replaces the existing {@link ExecutionConfig} (possibly {@code null}), with the provided one.  * @param config The new {@code configuration}.  * @return The old configuration, or {@code null} if none was specified.  */ ;/**  * Replaces the existing {@link ExecutionConfig} (possibly {@code null}), with the provided one.  * @param config The new {@code configuration}.  * @return The old configuration, or {@code null} if none was specified.  */ public ExecutionConfig setExecutionConfig(ExecutionConfig config) {     ExecutionConfig prev = executionConfig.     this.executionConfig = config.     return prev. }
true;public;5;13;/**  * Returns a future holding the request result.  * @param jobId                     JobID of the job the queryable state belongs to.  * @param queryableStateName        Name under which the state is queryable.  * @param key			            The key we are interested in.  * @param keyTypeHint				A {@link TypeHint} used to extract the type of the key.  * @param stateDescriptor			The {@link StateDescriptor} of the state we want to query.  * @return Future holding the immutable {@link State} object containing the result.  */ ;/**  * Returns a future holding the request result.  * @param jobId                     JobID of the job the queryable state belongs to.  * @param queryableStateName        Name under which the state is queryable.  * @param key			            The key we are interested in.  * @param keyTypeHint				A {@link TypeHint} used to extract the type of the key.  * @param stateDescriptor			The {@link StateDescriptor} of the state we want to query.  * @return Future holding the immutable {@link State} object containing the result.  */ @PublicEvolving public <K, S extends State, V> CompletableFuture<S> getKvState(final JobID jobId, final String queryableStateName, final K key, final TypeHint<K> keyTypeHint, final StateDescriptor<S, V> stateDescriptor) {     Preconditions.checkNotNull(keyTypeHint).     TypeInformation<K> keyTypeInfo = keyTypeHint.getTypeInfo().     return getKvState(jobId, queryableStateName, key, keyTypeInfo, stateDescriptor). }
true;public;5;11;/**  * Returns a future holding the request result.  * @param jobId                     JobID of the job the queryable state belongs to.  * @param queryableStateName        Name under which the state is queryable.  * @param key			            The key we are interested in.  * @param keyTypeInfo				The {@link TypeInformation} of the key.  * @param stateDescriptor			The {@link StateDescriptor} of the state we want to query.  * @return Future holding the immutable {@link State} object containing the result.  */ ;/**  * Returns a future holding the request result.  * @param jobId                     JobID of the job the queryable state belongs to.  * @param queryableStateName        Name under which the state is queryable.  * @param key			            The key we are interested in.  * @param keyTypeInfo				The {@link TypeInformation} of the key.  * @param stateDescriptor			The {@link StateDescriptor} of the state we want to query.  * @return Future holding the immutable {@link State} object containing the result.  */ @PublicEvolving public <K, S extends State, V> CompletableFuture<S> getKvState(final JobID jobId, final String queryableStateName, final K key, final TypeInformation<K> keyTypeInfo, final StateDescriptor<S, V> stateDescriptor) {     return getKvState(jobId, queryableStateName, key, VoidNamespace.INSTANCE, keyTypeInfo, VoidNamespaceTypeInfo.INSTANCE, stateDescriptor). }
true;private;7;34;/**  * Returns a future holding the request result.  * @param jobId                     JobID of the job the queryable state belongs to.  * @param queryableStateName        Name under which the state is queryable.  * @param key			            The key that the state we request is associated with.  * @param namespace					The namespace of the state.  * @param keyTypeInfo				The {@link TypeInformation} of the keys.  * @param namespaceTypeInfo			The {@link TypeInformation} of the namespace.  * @param stateDescriptor			The {@link StateDescriptor} of the state we want to query.  * @return Future holding the immutable {@link State} object containing the result.  */ ;/**  * Returns a future holding the request result.  * @param jobId                     JobID of the job the queryable state belongs to.  * @param queryableStateName        Name under which the state is queryable.  * @param key			            The key that the state we request is associated with.  * @param namespace					The namespace of the state.  * @param keyTypeInfo				The {@link TypeInformation} of the keys.  * @param namespaceTypeInfo			The {@link TypeInformation} of the namespace.  * @param stateDescriptor			The {@link StateDescriptor} of the state we want to query.  * @return Future holding the immutable {@link State} object containing the result.  */ private <K, N, S extends State, V> CompletableFuture<S> getKvState(final JobID jobId, final String queryableStateName, final K key, final N namespace, final TypeInformation<K> keyTypeInfo, final TypeInformation<N> namespaceTypeInfo, final StateDescriptor<S, V> stateDescriptor) {     Preconditions.checkNotNull(jobId).     Preconditions.checkNotNull(queryableStateName).     Preconditions.checkNotNull(key).     Preconditions.checkNotNull(namespace).     Preconditions.checkNotNull(keyTypeInfo).     Preconditions.checkNotNull(namespaceTypeInfo).     Preconditions.checkNotNull(stateDescriptor).     TypeSerializer<K> keySerializer = keyTypeInfo.createSerializer(executionConfig).     TypeSerializer<N> namespaceSerializer = namespaceTypeInfo.createSerializer(executionConfig).     stateDescriptor.initializeSerializerUnlessSet(executionConfig).     final byte[] serializedKeyAndNamespace.     try {         serializedKeyAndNamespace = KvStateSerializer.serializeKeyAndNamespace(key, keySerializer, namespace, namespaceSerializer).     } catch (IOException e) {         return FutureUtils.getFailedFuture(e).     }     return getKvState(jobId, queryableStateName, key.hashCode(), serializedKeyAndNamespace).thenApply(stateResponse -> createState(stateResponse, stateDescriptor)). }
false;private;2;15;;private <T, S extends State> S createState(KvStateResponse stateResponse, StateDescriptor<S, T> stateDescriptor) {     StateFactory stateFactory = STATE_FACTORIES.get(stateDescriptor.getClass()).     if (stateFactory == null) {         String message = String.format("State %s is not supported by %s", stateDescriptor.getClass(), this.getClass()).         throw new FlinkRuntimeException(message).     }     try {         return stateFactory.createState(stateDescriptor, stateResponse.getContent()).     } catch (Exception e) {         throw new FlinkRuntimeException(e).     } }
true;private;4;14;/**  * Returns a future holding the serialized request result.  *  * @param jobId                     JobID of the job the queryable state  *                                  belongs to  * @param queryableStateName        Name under which the state is queryable  * @param keyHashCode               Integer hash code of the key (result of  *                                  a call to {@link Object#hashCode()}  * @param serializedKeyAndNamespace Serialized key and namespace to query  *                                  KvState instance with  * @return Future holding the serialized result  */ ;/**  * Returns a future holding the serialized request result.  *  * @param jobId                     JobID of the job the queryable state  *                                  belongs to  * @param queryableStateName        Name under which the state is queryable  * @param keyHashCode               Integer hash code of the key (result of  *                                  a call to {@link Object#hashCode()}  * @param serializedKeyAndNamespace Serialized key and namespace to query  *                                  KvState instance with  * @return Future holding the serialized result  */ private CompletableFuture<KvStateResponse> getKvState(final JobID jobId, final String queryableStateName, final int keyHashCode, final byte[] serializedKeyAndNamespace) {     LOG.debug("Sending State Request to {}.", remoteAddress).     try {         KvStateRequest request = new KvStateRequest(jobId, queryableStateName, keyHashCode, serializedKeyAndNamespace).         return client.sendRequest(remoteAddress, request).     } catch (Exception e) {         LOG.error("Unable to send KVStateRequest: ", e).         return FutureUtils.getFailedFuture(e).     } }
