commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;6;;@Override protected void initChannel(SocketChannel channel) throws Exception {     channel.pipeline().addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4)).addLast(new ChunkedWriteHandler()). }
false;public;0;3;;public String getClientName() {     return clientName. }
false;public;2;29;;public CompletableFuture<RESP> sendRequest(final InetSocketAddress serverAddress, final REQ request) {     if (clientShutdownFuture.get() != null) {         return FutureUtils.getFailedFuture(new IllegalStateException(clientName + " is already shut down.")).     }     EstablishedConnection connection = establishedConnections.get(serverAddress).     if (connection != null) {         return connection.sendRequest(request).     } else {         PendingConnection pendingConnection = pendingConnections.get(serverAddress).         if (pendingConnection != null) {             // There was a race, use the existing pending connection.             return pendingConnection.sendRequest(request).         } else {             // We try to connect to the server.             PendingConnection pending = new PendingConnection(serverAddress, messageSerializer).             PendingConnection previous = pendingConnections.putIfAbsent(serverAddress, pending).             if (previous == null) {                 // OK, we are responsible to connect.                 bootstrap.connect(serverAddress.getAddress(), serverAddress.getPort()).addListener(pending).                 return pending.sendRequest(request).             } else {                 // There was a race, use the existing pending connection.                 return previous.sendRequest(request).             }         }     } }
true;public;0;49;/**  * Shuts down the client and closes all connections.  *  * <p>After a call to this method, all returned futures will be failed.  *  * @return A {@link CompletableFuture} that will be completed when the shutdown process is done.  */ ;/**  * Shuts down the client and closes all connections.  *  * <p>After a call to this method, all returned futures will be failed.  *  * @return A {@link CompletableFuture} that will be completed when the shutdown process is done.  */ public CompletableFuture<Void> shutdown() {     final CompletableFuture<Void> newShutdownFuture = new CompletableFuture<>().     if (clientShutdownFuture.compareAndSet(null, newShutdownFuture)) {         final List<CompletableFuture<Void>> connectionFutures = new ArrayList<>().         for (Map.Entry<InetSocketAddress, EstablishedConnection> conn : establishedConnections.entrySet()) {             if (establishedConnections.remove(conn.getKey(), conn.getValue())) {                 connectionFutures.add(conn.getValue().close()).             }         }         for (Map.Entry<InetSocketAddress, PendingConnection> conn : pendingConnections.entrySet()) {             if (pendingConnections.remove(conn.getKey()) != null) {                 connectionFutures.add(conn.getValue().close()).             }         }         CompletableFuture.allOf(connectionFutures.toArray(new CompletableFuture<?>[connectionFutures.size()])).whenComplete((result, throwable) -> {             if (throwable != null) {                 LOG.warn("Problem while shutting down the connections at the {}: {}", clientName, throwable).             }             if (bootstrap != null) {                 EventLoopGroup group = bootstrap.group().                 if (group != null && !group.isShutdown()) {                     group.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS).addListener(finished -> {                         if (finished.isSuccess()) {                             newShutdownFuture.complete(null).                         } else {                             newShutdownFuture.completeExceptionally(finished.cause()).                         }                     }).                 } else {                     newShutdownFuture.complete(null).                 }             } else {                 newShutdownFuture.complete(null).             }         }).         return newShutdownFuture.     }     return clientShutdownFuture.get(). }
false;public;1;8;;@Override public void operationComplete(ChannelFuture future) throws Exception {     if (future.isSuccess()) {         handInChannel(future.channel()).     } else {         close(future.cause()).     } }
true;;1;18;/**  * Returns a future holding the serialized request result.  *  * <p>If the channel has been established, forward the call to the  * established channel, otherwise queue it for when the channel is  * handed in.  *  * @param request the request to be sent.  * @return Future holding the serialized result  */ ;/**  * Returns a future holding the serialized request result.  *  * <p>If the channel has been established, forward the call to the  * established channel, otherwise queue it for when the channel is  * handed in.  *  * @param request the request to be sent.  * @return Future holding the serialized result  */ CompletableFuture<RESP> sendRequest(REQ request) {     synchronized (connectLock) {         if (failureCause != null) {             return FutureUtils.getFailedFuture(failureCause).         } else if (connectionShutdownFuture.get() != null) {             return FutureUtils.getFailedFuture(new ClosedChannelException()).         } else {             if (established != null) {                 return established.sendRequest(request).             } else {                 // Queue this and handle when connected                 final PendingRequest pending = new PendingRequest(request).                 queuedRequests.add(pending).                 return pending.             }         }     } }
true;private;1;38;/**  * Hands in a channel after a successful connection.  *  * @param channel Channel to hand in  */ ;/**  * Hands in a channel after a successful connection.  *  * @param channel Channel to hand in  */ private void handInChannel(Channel channel) {     synchronized (connectLock) {         if (connectionShutdownFuture.get() != null || failureCause != null) {             // Close the channel and we are done. Any queued requests             // are removed on the close/failure call and after that no             // new ones can be enqueued.             channel.close().         } else {             established = new EstablishedConnection(serverAddress, serializer, channel).             while (!queuedRequests.isEmpty()) {                 final PendingRequest pending = queuedRequests.poll().                 established.sendRequest(pending.request).whenComplete((response, throwable) -> {                     if (throwable != null) {                         pending.completeExceptionally(throwable).                     } else {                         pending.complete(response).                     }                 }).             }             // Publish the channel for the general public             establishedConnections.put(serverAddress, established).             pendingConnections.remove(serverAddress).             // which can happen if we don't check this here.             if (clientShutdownFuture.get() != null) {                 if (establishedConnections.remove(serverAddress, established)) {                     established.close().                 }             }         }     } }
true;private;0;3;/**  * Close the connecting channel with a ClosedChannelException.  */ ;/**  * Close the connecting channel with a ClosedChannelException.  */ private CompletableFuture<Void> close() {     return close(new ClosedChannelException()). }
true;private;1;27;/**  * Close the connecting channel with an Exception (can be {@code null})  * or forward to the established channel.  */ ;/**  * Close the connecting channel with an Exception (can be {@code null})  * or forward to the established channel.  */ private CompletableFuture<Void> close(Throwable cause) {     CompletableFuture<Void> future = new CompletableFuture<>().     if (connectionShutdownFuture.compareAndSet(null, future)) {         synchronized (connectLock) {             if (failureCause == null) {                 failureCause = cause.             }             if (established != null) {                 established.close().whenComplete((result, throwable) -> {                     if (throwable != null) {                         future.completeExceptionally(throwable).                     } else {                         future.complete(null).                     }                 }).             } else {                 PendingRequest pending.                 while ((pending = queuedRequests.poll()) != null) {                     pending.completeExceptionally(cause).                 }                 future.complete(null).             }         }     }     return connectionShutdownFuture.get(). }
false;public;0;11;;@Override public String toString() {     synchronized (connectLock) {         return "PendingConnection{" + "serverAddress=" + serverAddress + ", queuedRequests=" + queuedRequests.size() + ", established=" + (established != null) + ", closed=" + (connectionShutdownFuture.get() != null) + '}'.     } }
true;;0;3;/**  * Close the channel with a ClosedChannelException.  */ ;/**  * Close the channel with a ClosedChannelException.  */ CompletableFuture<Void> close() {     return close(new ClosedChannelException()). }
true;private;1;28;/**  * Close the channel with a cause.  *  * @param cause The cause to close the channel with.  * @return Channel close future  */ ;/**  * Close the channel with a cause.  *  * @param cause The cause to close the channel with.  * @return Channel close future  */ private CompletableFuture<Void> close(final Throwable cause) {     final CompletableFuture<Void> shutdownFuture = new CompletableFuture<>().     if (connectionShutdownFuture.compareAndSet(null, shutdownFuture)) {         channel.close().addListener(finished -> {             stats.reportInactiveConnection().             for (long requestId : pendingRequests.keySet()) {                 TimestampedCompletableFuture pending = pendingRequests.remove(requestId).                 if (pending != null && pending.completeExceptionally(cause)) {                     stats.reportFailedRequest().                 }             }             // is prioritized over the provided one.             if (finished.isSuccess()) {                 shutdownFuture.completeExceptionally(cause).             } else {                 LOG.warn("Something went wrong when trying to close connection due to : ", cause).                 shutdownFuture.completeExceptionally(finished.cause()).             }         }).     }     // in case we had a race condition, return the winner of the race.     return connectionShutdownFuture.get(). }
true;;1;45;/**  * Returns a future holding the serialized request result.  * @param request the request to be sent.  * @return Future holding the serialized result  */ ;/**  * Returns a future holding the serialized request result.  * @param request the request to be sent.  * @return Future holding the serialized result  */ CompletableFuture<RESP> sendRequest(REQ request) {     TimestampedCompletableFuture requestPromiseTs = new TimestampedCompletableFuture(System.nanoTime()).     try {         final long requestId = requestCount.getAndIncrement().         pendingRequests.put(requestId, requestPromiseTs).         stats.reportRequest().         ByteBuf buf = MessageSerializer.serializeRequest(channel.alloc(), requestId, request).         channel.writeAndFlush(buf).addListener((ChannelFutureListener) future -> {             if (!future.isSuccess()) {                 TimestampedCompletableFuture pending = pendingRequests.remove(requestId).                 if (pending != null && pending.completeExceptionally(future.cause())) {                     stats.reportFailedRequest().                 }             }         }).         // Check for possible race. We don't want any lingering         // promises after a failure, which can happen if we don't check         // this here. Note that close is treated as a failure as well.         CompletableFuture<Void> clShutdownFuture = clientShutdownFuture.get().         if (clShutdownFuture != null) {             TimestampedCompletableFuture pending = pendingRequests.remove(requestId).             if (pending != null) {                 clShutdownFuture.whenComplete((ignored, throwable) -> {                     if (throwable != null && pending.completeExceptionally(throwable)) {                         stats.reportFailedRequest().                     } else {                         // the shutdown future is always completed exceptionally so we should not arrive here.                         // but in any case, we complete the pending connection request exceptionally.                         pending.completeExceptionally(new ClosedChannelException()).                     }                 }).             }         }     } catch (Throwable t) {         requestPromiseTs.completeExceptionally(t).     }     return requestPromiseTs. }
false;public;2;9;;@Override public void onRequestResult(long requestId, RESP response) {     TimestampedCompletableFuture pending = pendingRequests.remove(requestId).     if (pending != null && !pending.isDone()) {         long durationMillis = (System.nanoTime() - pending.getTimestamp()) / 1_000_000L.         stats.reportSuccessfulRequest(durationMillis).         pending.complete(response).     } }
false;public;2;8;;@Override public void onRequestFailure(long requestId, Throwable cause) {     TimestampedCompletableFuture pending = pendingRequests.remove(requestId).     if (pending != null && !pending.isDone()) {         stats.reportFailedRequest().         pending.completeExceptionally(cause).     } }
false;public;1;4;;@Override public void onFailure(Throwable cause) {     close(cause).handle((cancelled, ignored) -> establishedConnections.remove(serverAddress, this)). }
false;public;0;9;;@Override public String toString() {     return "EstablishedConnection{" + "serverAddress=" + serverAddress + ", channel=" + channel + ", pendingRequests=" + pendingRequests.size() + ", requestCount=" + requestCount + '}'. }
false;public;0;3;;public long getTimestamp() {     return timestampInNanos. }
false;public;0;4;;@VisibleForTesting public boolean isEventGroupShutdown() {     return bootstrap == null || bootstrap.group().isTerminated(). }
