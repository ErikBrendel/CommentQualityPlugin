commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;7;;@BeforeClass public static void setupClass() {     yarnConfiguration = new YarnConfiguration().     yarnClient = YarnClient.createYarnClient().     yarnClient.init(yarnConfiguration).     yarnClient.start(). }
false;public;0;5;;@Before public void beforeTest() throws IOException {     temporaryFolder.create().     flinkJar = temporaryFolder.newFile("flink.jar"). }
false;public,static;0;4;;@AfterClass public static void tearDownClass() {     yarnClient.stop(). }
false;public;0;34;;@Test public void testFailIfTaskSlotsHigherThanMaxVcores() throws ClusterDeploymentException {     final Configuration flinkConfiguration = new Configuration().     flinkConfiguration.setInteger(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN, 0).     YarnClusterDescriptor clusterDescriptor = new YarnClusterDescriptor(flinkConfiguration, yarnConfiguration, temporaryFolder.getRoot().getAbsolutePath(), yarnClient, true).     clusterDescriptor.setLocalJarPath(new Path(flinkJar.getPath())).     ClusterSpecification clusterSpecification = new ClusterSpecification.ClusterSpecificationBuilder().setMasterMemoryMB(1).setTaskManagerMemoryMB(1).setNumberTaskManagers(1).setSlotsPerTaskManager(Integer.MAX_VALUE).createClusterSpecification().     try {         clusterDescriptor.deploySessionCluster(clusterSpecification).         fail("The deploy call should have failed.").     } catch (ClusterDeploymentException e) {         // we expect the cause to be an IllegalConfigurationException         if (!(e.getCause() instanceof IllegalConfigurationException)) {             throw e.         }     } finally {         clusterDescriptor.close().     } }
false;public;0;37;;@Test public void testConfigOverwrite() throws ClusterDeploymentException {     Configuration configuration = new Configuration().     // overwrite vcores in config     configuration.setInteger(YarnConfigOptions.VCORES, Integer.MAX_VALUE).     configuration.setInteger(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN, 0).     YarnClusterDescriptor clusterDescriptor = new YarnClusterDescriptor(configuration, yarnConfiguration, temporaryFolder.getRoot().getAbsolutePath(), yarnClient, true).     clusterDescriptor.setLocalJarPath(new Path(flinkJar.getPath())).     // configure slots     ClusterSpecification clusterSpecification = new ClusterSpecification.ClusterSpecificationBuilder().setMasterMemoryMB(1).setTaskManagerMemoryMB(1).setNumberTaskManagers(1).setSlotsPerTaskManager(1).createClusterSpecification().     try {         clusterDescriptor.deploySessionCluster(clusterSpecification).         fail("The deploy call should have failed.").     } catch (ClusterDeploymentException e) {         // we expect the cause to be an IllegalConfigurationException         if (!(e.getCause() instanceof IllegalConfigurationException)) {             throw e.         }     } finally {         clusterDescriptor.close().     } }
false;public;0;248;;@Test public void testSetupApplicationMasterContainer() {     Configuration cfg = new Configuration().     YarnClusterDescriptor clusterDescriptor = new YarnClusterDescriptor(cfg, yarnConfiguration, temporaryFolder.getRoot().getAbsolutePath(), yarnClient, true).     final String java = "$JAVA_HOME/bin/java".     final String jvmmem = "-Xms424m -Xmx424m".     // if set     final String jvmOpts = "-Djvm".     // if set     final String jmJvmOpts = "-DjmJvm".     final String krb5 = "-Djava.security.krb5.conf=krb5.conf".     final String logfile = "-Dlog.file=\"" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + // if set     "/jobmanager.log\"".     final String logback = // if set     "-Dlogback.configurationFile=file:" + FlinkYarnSessionCli.CONFIG_FILE_LOGBACK_NAME.     final String log4j = // if set     "-Dlog4j.configuration=file:" + FlinkYarnSessionCli.CONFIG_FILE_LOG4J_NAME.     final String mainClass = clusterDescriptor.getYarnSessionClusterEntrypoint().     final String args = "".     final String redirects = "1> " + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/jobmanager.out " + "2> " + ApplicationConstants.LOG_DIR_EXPANSION_VAR + "/jobmanager.err".     final int jobManagerMemory = 1024.     try {         // no logging, with/out krb5         assertEquals(java + " " + jvmmem + // jvmOpts         " " + // logging         " " + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, false, false, false, jobManagerMemory).getCommands().get(0)).         assertEquals(java + " " + jvmmem + " " + " " + // jvmOpts         krb5 + // logging         " " + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, false, false, true, jobManagerMemory).getCommands().get(0)).         // logback only, with/out krb5         assertEquals(java + " " + jvmmem + // jvmOpts         " " + " " + logfile + " " + logback + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, true, false, false, jobManagerMemory).getCommands().get(0)).         assertEquals(java + " " + jvmmem + " " + " " + // jvmOpts         krb5 + " " + logfile + " " + logback + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, true, false, true, jobManagerMemory).getCommands().get(0)).         // log4j, with/out krb5         assertEquals(java + " " + jvmmem + // jvmOpts         " " + " " + logfile + " " + log4j + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, false, true, false, jobManagerMemory).getCommands().get(0)).         assertEquals(java + " " + jvmmem + " " + " " + // jvmOpts         krb5 + " " + logfile + " " + log4j + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, false, true, true, jobManagerMemory).getCommands().get(0)).         // logback + log4j, with/out krb5         assertEquals(java + " " + jvmmem + // jvmOpts         " " + " " + logfile + " " + logback + " " + log4j + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, true, true, false, jobManagerMemory).getCommands().get(0)).         assertEquals(java + " " + jvmmem + " " + " " + // jvmOpts         krb5 + " " + logfile + " " + logback + " " + log4j + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, true, true, true, jobManagerMemory).getCommands().get(0)).         // logback + log4j, with/out krb5, different JVM opts         // IMPORTANT: Be aware that we are using side effects here to modify the created YarnClusterDescriptor,         // because we have a reference to the ClusterDescriptor's configuration which we modify continuously         cfg.setString(CoreOptions.FLINK_JVM_OPTIONS, jvmOpts).         assertEquals(java + " " + jvmmem + " " + jvmOpts + " " + logfile + " " + logback + " " + log4j + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, true, true, false, jobManagerMemory).getCommands().get(0)).         assertEquals(java + " " + jvmmem + " " + jvmOpts + " " + // jvmOpts         krb5 + " " + logfile + " " + logback + " " + log4j + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, true, true, true, jobManagerMemory).getCommands().get(0)).         // logback + log4j, with/out krb5, different JVM opts         // IMPORTANT: Be aware that we are using side effects here to modify the created YarnClusterDescriptor         cfg.setString(CoreOptions.FLINK_JM_JVM_OPTIONS, jmJvmOpts).         assertEquals(java + " " + jvmmem + " " + jvmOpts + " " + jmJvmOpts + " " + logfile + " " + logback + " " + log4j + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, true, true, false, jobManagerMemory).getCommands().get(0)).         assertEquals(java + " " + jvmmem + " " + jvmOpts + " " + jmJvmOpts + " " + // jvmOpts         krb5 + " " + logfile + " " + logback + " " + log4j + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, true, true, true, jobManagerMemory).getCommands().get(0)).         // now try some configurations with different yarn.container-start-command-template         // IMPORTANT: Be aware that we are using side effects here to modify the created YarnClusterDescriptor         cfg.setString(ConfigConstants.YARN_CONTAINER_START_COMMAND_TEMPLATE, "%java% 1 %jvmmem% 2 %jvmopts% 3 %logging% 4 %class% 5 %args% 6 %redirects%").         assertEquals(java + " 1 " + jvmmem + " 2 " + jvmOpts + " " + jmJvmOpts + " " + // jvmOpts         krb5 + " 3 " + logfile + " " + logback + " " + log4j + " 4 " + mainClass + " 5 " + args + " 6 " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, true, true, true, jobManagerMemory).getCommands().get(0)).         cfg.setString(ConfigConstants.YARN_CONTAINER_START_COMMAND_TEMPLATE, "%java% %logging% %jvmopts% %jvmmem% %class% %args% %redirects%").         // IMPORTANT: Be aware that we are using side effects here to modify the created YarnClusterDescriptor         assertEquals(java + " " + logfile + " " + logback + " " + log4j + " " + jvmOpts + " " + jmJvmOpts + " " + // jvmOpts         krb5 + " " + jvmmem + " " + mainClass + " " + args + " " + redirects, clusterDescriptor.setupApplicationMasterContainer(mainClass, true, true, true, jobManagerMemory).getCommands().get(0)).     } finally {         clusterDescriptor.close().     } }
true;public;0;35;/**  * Tests to ship a lib folder through the {@code YarnClusterDescriptor.addShipFiles}.  */ ;/**  * Tests to ship a lib folder through the {@code YarnClusterDescriptor.addShipFiles}.  */ @Test public void testExplicitLibShipping() throws Exception {     try (YarnClusterDescriptor descriptor = new YarnClusterDescriptor(new Configuration(), yarnConfiguration, temporaryFolder.getRoot().getAbsolutePath(), yarnClient, true)) {         descriptor.setLocalJarPath(new Path("/path/to/flink.jar")).         File libFile = temporaryFolder.newFile("libFile.jar").         File libFolder = temporaryFolder.newFolder().getAbsoluteFile().         Assert.assertFalse(descriptor.shipFiles.contains(libFile)).         Assert.assertFalse(descriptor.shipFiles.contains(libFolder)).         List<File> shipFiles = new ArrayList<>().         shipFiles.add(libFile).         shipFiles.add(libFolder).         descriptor.addShipFiles(shipFiles).         Assert.assertTrue(descriptor.shipFiles.contains(libFile)).         Assert.assertTrue(descriptor.shipFiles.contains(libFolder)).         // only execute part of the deployment to test for shipped files         Set<File> effectiveShipFiles = new HashSet<>().         descriptor.addLibFolderToShipFiles(effectiveShipFiles).         Assert.assertEquals(0, effectiveShipFiles.size()).         Assert.assertEquals(2, descriptor.shipFiles.size()).         Assert.assertTrue(descriptor.shipFiles.contains(libFile)).         Assert.assertTrue(descriptor.shipFiles.contains(libFolder)).     } }
true;public;0;32;/**  * Tests to ship a lib folder through the {@code ConfigConstants.ENV_FLINK_LIB_DIR}.  */ ;/**  * Tests to ship a lib folder through the {@code ConfigConstants.ENV_FLINK_LIB_DIR}.  */ @Test public void testEnvironmentLibShipping() throws Exception {     try (YarnClusterDescriptor descriptor = new YarnClusterDescriptor(new Configuration(), yarnConfiguration, temporaryFolder.getRoot().getAbsolutePath(), yarnClient, true)) {         File libFolder = temporaryFolder.newFolder().getAbsoluteFile().         File libFile = new File(libFolder, "libFile.jar").         libFile.createNewFile().         Set<File> effectiveShipFiles = new HashSet<>().         final Map<String, String> oldEnv = System.getenv().         try {             Map<String, String> env = new HashMap<>(1).             env.put(ConfigConstants.ENV_FLINK_LIB_DIR, libFolder.getAbsolutePath()).             CommonTestUtils.setEnv(env).             // only execute part of the deployment to test for shipped files             descriptor.addLibFolderToShipFiles(effectiveShipFiles).         } finally {             CommonTestUtils.setEnv(oldEnv).         }         // only add the ship the folder, not the contents         Assert.assertFalse(effectiveShipFiles.contains(libFile)).         Assert.assertTrue(effectiveShipFiles.contains(libFolder)).         Assert.assertFalse(descriptor.shipFiles.contains(libFile)).         Assert.assertFalse(descriptor.shipFiles.contains(libFolder)).     } }
true;public;0;28;/**  * Tests that the YarnClient is only shut down if it is not shared.  */ ;/**  * Tests that the YarnClient is only shut down if it is not shared.  */ @Test public void testYarnClientShutDown() {     YarnClusterDescriptor yarnClusterDescriptor = new YarnClusterDescriptor(new Configuration(), yarnConfiguration, temporaryFolder.getRoot().getAbsolutePath(), yarnClient, true).     yarnClusterDescriptor.close().     assertTrue(yarnClient.isInState(Service.STATE.STARTED)).     final YarnClient closableYarnClient = YarnClient.createYarnClient().     closableYarnClient.init(yarnConfiguration).     closableYarnClient.start().     yarnClusterDescriptor = new YarnClusterDescriptor(new Configuration(), yarnConfiguration, temporaryFolder.getRoot().getAbsolutePath(), closableYarnClient, false).     yarnClusterDescriptor.close().     assertTrue(closableYarnClient.isInState(Service.STATE.STOPPED)). }
