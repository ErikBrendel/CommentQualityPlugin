commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;// ------------------------------------------------------------------------ // high availability services // ------------------------------------------------------------------------ @Override public BlobStore createBlobStore() throws IOException {     enter().     try {         return blobStoreService.     } finally {         exit().     } }
true;public;0;3;/**  * Checks whether these services have been shut down.  *  * @return True, if this instance has been shut down, false if it still operational.  */ ;// ------------------------------------------------------------------------ // Shutdown // ------------------------------------------------------------------------ /**  * Checks whether these services have been shut down.  *  * @return True, if this instance has been shut down, false if it still operational.  */ public boolean isClosed() {     return closed. }
false;public;0;33;;@Override public void close() throws Exception {     lock.lock().     try {         // close only once         if (closed) {             return.         }         closed = true.         Throwable exception = null.         try {             blobStoreService.close().         } catch (Throwable t) {             exception = t.         }         // we do not propagate exceptions here, but only log them         try {             hadoopFileSystem.close().         } catch (Throwable t) {             exception = ExceptionUtils.firstOrSuppressed(t, exception).         }         if (exception != null) {             ExceptionUtils.rethrowException(exception, "Could not properly close the YarnHighAvailabilityServices.").         }     } finally {         lock.unlock().     } }
false;public;0;40;;@Override public void closeAndCleanupAllData() throws Exception {     lock.lock().     try {         checkState(!closed, "YarnHighAvailabilityServices are already closed").         // we remember exceptions only, then continue cleanup, and re-throw at the end         Throwable exception = null.         try {             blobStoreService.closeAndCleanupAllData().         } catch (Throwable t) {             exception = t.         }         // first, we delete all data in Flink's data directory         try {             flinkFileSystem.delete(haDataDirectory, true).         } catch (Throwable t) {             exception = ExceptionUtils.firstOrSuppressed(t, exception).         }         // now we actually close the services         try {             close().         } catch (Throwable t) {             exception = firstOrSuppressed(t, exception).         }         // if some exception occurred, rethrow         if (exception != null) {             ExceptionUtils.rethrowException(exception, exception.getMessage()).         }     } finally {         lock.unlock().     } }
true;;0;5;/**  * To be called at the beginning of every method that creates an HA service. Acquires the lock  * and check whether this HighAvailabilityServices instance is shut down.  */ ;// ------------------------------------------------------------------------ // Utilities // ------------------------------------------------------------------------ /**  * To be called at the beginning of every method that creates an HA service. Acquires the lock  * and check whether this HighAvailabilityServices instance is shut down.  */ void enter() {     if (!enterUnlessClosed()) {         throw new IllegalStateException("closed").     } }
true;;0;9;/**  * Acquires the lock and checks whether the services are already closed. If they are  * already closed, the method releases the lock and returns {@code false}.  *  * @return True, if the lock was acquired and the services are not closed, false if the services are closed.  */ ;/**  * Acquires the lock and checks whether the services are already closed. If they are  * already closed, the method releases the lock and returns {@code false}.  *  * @return True, if the lock was acquired and the services are not closed, false if the services are closed.  */ boolean enterUnlessClosed() {     lock.lock().     if (!closed) {         return true.     } else {         lock.unlock().         return false.     } }
true;;0;3;/**  * To be called at the end of every method that creates an HA service. Releases the lock.  */ ;/**  * To be called at the end of every method that creates an HA service. Releases the lock.  */ void exit() {     lock.unlock(). }
true;public,static;2;19;/**  * Creates the high-availability services for a single-job Flink YARN application, to be  * used in the Application Master that runs both ResourceManager and JobManager.  *  * @param flinkConfig  The Flink configuration.  * @param hadoopConfig The Hadoop configuration for the YARN cluster.  *  * @return The created high-availability services.  *  * @throws IOException Thrown, if the high-availability services could not be initialized.  */ ;// ------------------------------------------------------------------------ // Factory from Configuration // ------------------------------------------------------------------------ /**  * Creates the high-availability services for a single-job Flink YARN application, to be  * used in the Application Master that runs both ResourceManager and JobManager.  *  * @param flinkConfig  The Flink configuration.  * @param hadoopConfig The Hadoop configuration for the YARN cluster.  *  * @return The created high-availability services.  *  * @throws IOException Thrown, if the high-availability services could not be initialized.  */ public static YarnHighAvailabilityServices forSingleJobAppMaster(Configuration flinkConfig, org.apache.hadoop.conf.Configuration hadoopConfig) throws IOException {     checkNotNull(flinkConfig, "flinkConfig").     checkNotNull(hadoopConfig, "hadoopConfig").     final HighAvailabilityMode mode = HighAvailabilityMode.fromConfig(flinkConfig).     switch(mode) {         case NONE:             return new YarnIntraNonHaMasterServices(flinkConfig, hadoopConfig).         case ZOOKEEPER:             throw new UnsupportedOperationException("to be implemented").         default:             throw new IllegalConfigurationException("Unrecognized high availability mode: " + mode).     } }
true;public,static;2;22;/**  * Creates the high-availability services for the TaskManagers participating in  * a Flink YARN application.  *  * @param flinkConfig  The Flink configuration.  * @param hadoopConfig The Hadoop configuration for the YARN cluster.  *  * @return The created high-availability services.  *  * @throws IOException Thrown, if the high-availability services could not be initialized.  */ ;/**  * Creates the high-availability services for the TaskManagers participating in  * a Flink YARN application.  *  * @param flinkConfig  The Flink configuration.  * @param hadoopConfig The Hadoop configuration for the YARN cluster.  *  * @return The created high-availability services.  *  * @throws IOException Thrown, if the high-availability services could not be initialized.  */ public static YarnHighAvailabilityServices forYarnTaskManager(Configuration flinkConfig, org.apache.hadoop.conf.Configuration hadoopConfig) throws IOException {     checkNotNull(flinkConfig, "flinkConfig").     checkNotNull(hadoopConfig, "hadoopConfig").     final HighAvailabilityMode mode = HighAvailabilityMode.fromConfig(flinkConfig).     switch(mode) {         case NONE:             return new YarnPreConfiguredMasterNonHaServices(flinkConfig, hadoopConfig, HighAvailabilityServicesUtils.AddressResolution.TRY_ADDRESS_RESOLUTION).         case ZOOKEEPER:             throw new UnsupportedOperationException("to be implemented").         default:             throw new IllegalConfigurationException("Unrecognized high availability mode: " + mode).     } }
