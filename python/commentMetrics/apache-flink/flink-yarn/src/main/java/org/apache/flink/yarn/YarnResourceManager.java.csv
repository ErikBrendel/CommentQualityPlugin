commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;34;;protected AMRMClientAsync<AMRMClient.ContainerRequest> createAndStartResourceManagerClient(YarnConfiguration yarnConfiguration, int yarnHeartbeatIntervalMillis, @Nullable String webInterfaceUrl) throws Exception {     AMRMClientAsync<AMRMClient.ContainerRequest> resourceManagerClient = AMRMClientAsync.createAMRMClientAsync(yarnHeartbeatIntervalMillis, this).     resourceManagerClient.init(yarnConfiguration).     resourceManagerClient.start().     // TODO: change akka address to tcp host and port, the getAddress() interface should return a standard tcp address     Tuple2<String, Integer> hostPort = parseHostPort(getAddress()).     final int restPort.     if (webInterfaceUrl != null) {         final int lastColon = webInterfaceUrl.lastIndexOf(':').         if (lastColon == -1) {             restPort = -1.         } else {             restPort = Integer.valueOf(webInterfaceUrl.substring(lastColon + 1)).         }     } else {         restPort = -1.     }     final RegisterApplicationMasterResponse registerApplicationMasterResponse = resourceManagerClient.registerApplicationMaster(hostPort.f0, restPort, webInterfaceUrl).     getContainersFromPreviousAttempts(registerApplicationMasterResponse).     return resourceManagerClient. }
false;private;1;10;;private void getContainersFromPreviousAttempts(final RegisterApplicationMasterResponse registerApplicationMasterResponse) {     final List<Container> containersFromPreviousAttempts = new RegisterApplicationMasterResponseReflector(log).getContainersFromPreviousAttempts(registerApplicationMasterResponse).     log.info("Recovered {} containers from previous attempts ({}).", containersFromPreviousAttempts.size(), containersFromPreviousAttempts).     for (final Container container : containersFromPreviousAttempts) {         workerNodeMap.put(new ResourceID(container.getId().toString()), new YarnWorkerNode(container)).     } }
false;protected;1;8;;protected NMClient createAndStartNodeManagerClient(YarnConfiguration yarnConfiguration) {     // create the client to communicate with the node managers     NMClient nodeManagerClient = NMClient.createNMClient().     nodeManagerClient.init(yarnConfiguration).     nodeManagerClient.start().     nodeManagerClient.cleanupRunningContainersOnStop(true).     return nodeManagerClient. }
false;protected;0;13;;@Override protected void initialize() throws ResourceManagerException {     try {         resourceManagerClient = createAndStartResourceManagerClient(yarnConfig, yarnHeartbeatIntervalMillis, webInterfaceUrl).     } catch (Exception e) {         throw new ResourceManagerException("Could not start resource manager client.", e).     }     nodeManagerClient = createAndStartNodeManagerClient(yarnConfig). }
false;public;0;29;;@Override public CompletableFuture<Void> onStop() {     // shut down all components     Throwable firstException = null.     if (resourceManagerClient != null) {         try {             resourceManagerClient.stop().         } catch (Throwable t) {             firstException = t.         }     }     if (nodeManagerClient != null) {         try {             nodeManagerClient.stop().         } catch (Throwable t) {             firstException = ExceptionUtils.firstOrSuppressed(t, firstException).         }     }     final CompletableFuture<Void> terminationFuture = super.onStop().     if (firstException != null) {         return FutureUtils.completedExceptionally(new FlinkException("Error while shutting down YARN resource manager", firstException)).     } else {         return terminationFuture.     } }
false;protected;2;17;;@Override protected void internalDeregisterApplication(ApplicationStatus finalStatus, @Nullable String diagnostics) {     // first, de-register from YARN     FinalApplicationStatus yarnStatus = getYarnStatus(finalStatus).     log.info("Unregister application from the YARN Resource Manager with final status {}.", yarnStatus).     try {         resourceManagerClient.unregisterApplicationMaster(yarnStatus, diagnostics, "").     } catch (Throwable t) {         log.error("Could not unregister the application master.", t).     }     Utils.deleteApplicationFiles(env). }
false;public;1;9;;@Override public Collection<ResourceProfile> startNewWorker(ResourceProfile resourceProfile) {     Preconditions.checkArgument(ResourceProfile.UNKNOWN.equals(resourceProfile), "The YarnResourceManager does not support custom ResourceProfiles yet. It assumes that all containers have the same resources.").     requestYarnContainer().     return slotsPerWorker. }
false;;0;4;;@VisibleForTesting Resource getContainerResource() {     return resource. }
false;public;1;13;;@Override public boolean stopWorker(final YarnWorkerNode workerNode) {     final Container container = workerNode.getContainer().     log.info("Stopping container {}.", container.getId()).     try {         nodeManagerClient.stopContainer(container.getId(), container.getNodeId()).     } catch (final Exception e) {         log.warn("Error while calling YARN Node Manager to stop container", e).     }     resourceManagerClient.releaseAssignedContainer(container.getId()).     workerNodeMap.remove(workerNode.getResourceID()).     return true. }
false;protected;1;4;;@Override protected YarnWorkerNode workerStarted(ResourceID resourceID) {     return workerNodeMap.get(resourceID). }
false;public;0;5;;// ------------------------------------------------------------------------ // AMRMClientAsync CallbackHandler methods // ------------------------------------------------------------------------ @Override public float getProgress() {     // Temporarily need not record the total size of asked and allocated containers     return 1. }
false;public;1;19;;@Override public void onContainersCompleted(final List<ContainerStatus> statuses) {     runAsync(() -> {         log.debug("YARN ResourceManager reported the following containers completed: {}.", statuses).         for (final ContainerStatus containerStatus : statuses) {             final ResourceID resourceId = new ResourceID(containerStatus.getContainerId().toString()).             final YarnWorkerNode yarnWorkerNode = workerNodeMap.remove(resourceId).             if (yarnWorkerNode != null) {                 // Container completed unexpectedly ~> start a new one                 requestYarnContainerIfRequired().             }             // Eagerly close the connection with task manager.             closeTaskManagerConnection(resourceId, new Exception(containerStatus.getDiagnostics())).         }     }). }
false;public;1;51;;@Override public void onContainersAllocated(List<Container> containers) {     runAsync(() -> {         final Collection<AMRMClient.ContainerRequest> pendingRequests = getPendingRequests().         final Iterator<AMRMClient.ContainerRequest> pendingRequestsIterator = pendingRequests.iterator().         for (Container container : containers) {             log.info("Received new container: {} - Remaining pending container requests: {}", container.getId(), numPendingContainerRequests).             if (numPendingContainerRequests > 0) {                 removeContainerRequest(pendingRequestsIterator.next()).                 final String containerIdStr = container.getId().toString().                 final ResourceID resourceId = new ResourceID(containerIdStr).                 workerNodeMap.put(resourceId, new YarnWorkerNode(container)).                 try {                     // Context information used to start a TaskExecutor Java process                     ContainerLaunchContext taskExecutorLaunchContext = createTaskExecutorLaunchContext(container.getResource(), containerIdStr, container.getNodeId().getHost()).                     nodeManagerClient.startContainer(container, taskExecutorLaunchContext).                 } catch (Throwable t) {                     log.error("Could not start TaskManager in container {}.", container.getId(), t).                     // release the failed container                     workerNodeMap.remove(resourceId).                     resourceManagerClient.releaseAssignedContainer(container.getId()).                     // and ask for a new one                     requestYarnContainerIfRequired().                 }             } else {                 // return the excessive containers                 log.info("Returning excess container {}.", container.getId()).                 resourceManagerClient.releaseAssignedContainer(container.getId()).             }         }         // regular heartbeat interval         if (numPendingContainerRequests <= 0) {             resourceManagerClient.setHeartbeatInterval(yarnHeartbeatIntervalMillis).         }     }). }
false;private;1;7;;private void removeContainerRequest(AMRMClient.ContainerRequest pendingContainerRequest) {     numPendingContainerRequests--.     log.info("Removing container request {}. Pending container requests {}.", pendingContainerRequest, numPendingContainerRequests).     resourceManagerClient.removeContainerRequest(pendingContainerRequest). }
false;private;0;21;;private Collection<AMRMClient.ContainerRequest> getPendingRequests() {     final List<? extends Collection<AMRMClient.ContainerRequest>> matchingRequests = resourceManagerClient.getMatchingRequests(RM_REQUEST_PRIORITY, ResourceRequest.ANY, getContainerResource()).     final Collection<AMRMClient.ContainerRequest> matchingContainerRequests.     if (matchingRequests.isEmpty()) {         matchingContainerRequests = Collections.emptyList().     } else {         final Collection<AMRMClient.ContainerRequest> collection = matchingRequests.get(0).         matchingContainerRequests = new ArrayList<>(collection).     }     Preconditions.checkState(matchingContainerRequests.size() == numPendingContainerRequests, "The RMClient's and YarnResourceManagers internal state about the number of pending container requests has diverged. Number client's pending container requests %s != Number RM's pending container requests %s.", matchingContainerRequests.size(), numPendingContainerRequests).     return matchingContainerRequests. }
false;public;0;4;;@Override public void onShutdownRequest() {     closeAsync(). }
false;public;1;4;;@Override public void onNodesUpdated(List<NodeReport> list) { // We are not interested in node updates }
false;public;1;4;;@Override public void onError(Throwable error) {     onFatalError(error). }
true;private;1;17;/**  * Converts a Flink application status enum to a YARN application status enum.  * @param status The Flink application status.  * @return The corresponding YARN application status.  */ ;// ------------------------------------------------------------------------ // Utility methods // ------------------------------------------------------------------------ /**  * Converts a Flink application status enum to a YARN application status enum.  * @param status The Flink application status.  * @return The corresponding YARN application status.  */ private FinalApplicationStatus getYarnStatus(ApplicationStatus status) {     if (status == null) {         return FinalApplicationStatus.UNDEFINED.     } else {         switch(status) {             case SUCCEEDED:                 return FinalApplicationStatus.SUCCEEDED.             case FAILED:                 return FinalApplicationStatus.FAILED.             case CANCELED:                 return FinalApplicationStatus.KILLED.             default:                 return FinalApplicationStatus.UNDEFINED.         }     } }
true;private,static;1;6;// the akka address is like akka.tcp://flink@100.81.153.180:49712/user/$a ;// parse the host and port from akka address, // the akka address is like akka.tcp://flink@100.81.153.180:49712/user/$a private static Tuple2<String, Integer> parseHostPort(String address) {     String[] hostPort = address.split("@")[1].split(":").     String host = hostPort[0].     String port = hostPort[1].split("/")[0].     return new Tuple2<>(host, Integer.valueOf(port)). }
true;private;0;8;/**  * Request new container if pending containers cannot satisfies pending slot requests.  */ ;/**  * Request new container if pending containers cannot satisfies pending slot requests.  */ private void requestYarnContainerIfRequired() {     int requiredTaskManagerSlots = getNumberRequiredTaskManagerSlots().     int pendingTaskManagerSlots = numPendingContainerRequests * numberOfTaskSlots.     if (requiredTaskManagerSlots > pendingTaskManagerSlots) {         requestYarnContainer().     } }
false;private;0;12;;private void requestYarnContainer() {     resourceManagerClient.addContainerRequest(getContainerRequest()).     // make sure we transmit the request fast and receive fast news of granted allocations     resourceManagerClient.setHeartbeatInterval(FAST_YARN_HEARTBEAT_INTERVAL_MS).     numPendingContainerRequests++.     log.info("Requesting new TaskExecutor container with resources {}. Number pending requests {}.", resource, numPendingContainerRequests). }
false;;0;9;;@Nonnull @VisibleForTesting AMRMClient.ContainerRequest getContainerRequest() {     return new AMRMClient.ContainerRequest(getContainerResource(), null, null, RM_REQUEST_PRIORITY). }
false;private;3;36;;private ContainerLaunchContext createTaskExecutorLaunchContext(Resource resource, String containerId, String host) throws Exception {     // init the ContainerLaunchContext     final String currDir = env.get(ApplicationConstants.Environment.PWD.key()).     final ContaineredTaskManagerParameters taskManagerParameters = ContaineredTaskManagerParameters.create(flinkConfig, resource.getMemory(), numberOfTaskSlots).     log.debug("TaskExecutor {} will be started with container size {} MB, JVM heap size {} MB, " + "JVM direct memory limit {} MB", containerId, taskManagerParameters.taskManagerTotalMemoryMB(), taskManagerParameters.taskManagerHeapSizeMB(), taskManagerParameters.taskManagerDirectMemoryLimitMB()).     Configuration taskManagerConfig = BootstrapTools.cloneConfiguration(flinkConfig).     log.debug("TaskManager configuration: {}", taskManagerConfig).     ContainerLaunchContext taskExecutorLaunchContext = Utils.createTaskExecutorContext(flinkConfig, yarnConfig, env, taskManagerParameters, taskManagerConfig, currDir, YarnTaskExecutorRunner.class, log).     // set a special environment variable to uniquely identify this container     taskExecutorLaunchContext.getEnvironment().put(ENV_FLINK_CONTAINER_ID, containerId).     taskExecutorLaunchContext.getEnvironment().put(ENV_FLINK_NODE_ID, host).     return taskExecutorLaunchContext. }
