commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Test public void testDistinctByKeyFields1() {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple5<Integer, Long, String, Long, Integer>> tupleDs = env.fromCollection(emptyTupleData, tupleTypeInfo).     // should work     try {         tupleDs.distinct(0).     } catch (Exception e) {         Assert.fail().     } }
false;public;0;9;;@Test(expected = InvalidProgramException.class) public void testDistinctByKeyFields2() {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Long> longDs = env.fromCollection(emptyLongData, BasicTypeInfo.LONG_TYPE_INFO).     // should not work: distinct on basic type     longDs.distinct(0). }
false;public;0;12;;@Test(expected = InvalidProgramException.class) public void testDistinctByKeyFields3() {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     this.customTypeData.add(new CustomType()).     DataSet<CustomType> customDs = env.fromCollection(customTypeData).     // should not work: distinct on custom type     customDs.distinct(0). }
false;public;0;9;;@Test public void testDistinctByKeyFields4() {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple5<Integer, Long, String, Long, Integer>> tupleDs = env.fromCollection(emptyTupleData, tupleTypeInfo).     // should work     tupleDs.distinct(). }
false;public;0;12;;@Test public void testDistinctByKeyFields5() {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     this.customTypeData.add(new CustomType()).     DataSet<CustomType> customDs = env.fromCollection(customTypeData).     // should work     customDs.distinct(). }
false;public;0;9;;@Test(expected = IndexOutOfBoundsException.class) public void testDistinctByKeyFields6() {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Tuple5<Integer, Long, String, Long, Integer>> tupleDs = env.fromCollection(emptyTupleData, tupleTypeInfo).     // should not work, negative field position     tupleDs.distinct(-1). }
false;public;0;12;;@Test public void testDistinctByKeyFields7() {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     DataSet<Long> longDs = env.fromCollection(emptyLongData, BasicTypeInfo.LONG_TYPE_INFO).     // should work     try {         longDs.distinct("*").     } catch (Exception e) {         Assert.fail().     } }
false;public;1;4;;@Override public Long getKey(CustomType value) {     return value.myLong. }
false;public;0;23;;@Test @SuppressWarnings("serial") public void testDistinctByKeySelector1() {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     this.customTypeData.add(new CustomType()).     try {         DataSet<CustomType> customDs = env.fromCollection(customTypeData).         // should work         customDs.distinct(new KeySelector<DistinctOperatorTest.CustomType, Long>() {              @Override             public Long getKey(CustomType value) {                 return value.myLong.             }         }).     } catch (Exception e) {         Assert.fail().     } }
false;public;0;11;;@Test public void testDistinctByKeyIndices1() {     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     try {         DataSet<Long> longDs = env.fromCollection(emptyLongData, BasicTypeInfo.LONG_TYPE_INFO).         // should work         longDs.distinct().     } catch (Exception e) {         Assert.fail().     } }
false;public;0;15;;@Test(expected = InvalidProgramException.class) public void testDistinctOnNotKeyDataType() throws Exception {     /*      	* should not work. NotComparable data type cannot be used as key      	*/     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     NotComparable a = new NotComparable().     List<NotComparable> l = new ArrayList<NotComparable>().     l.add(a).     DataSet<NotComparable> ds = env.fromCollection(l).     DataSet<NotComparable> reduceDs = ds.distinct(). }
false;public;0;14;;@Test(expected = InvalidProgramException.class) public void testDistinctOnNotKeyDataTypeOnSelectAllChar() throws Exception {     /*      	* should not work. NotComparable data type cannot be used as key      	*/     final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().     NotComparable a = new NotComparable().     List<NotComparable> l = new ArrayList<NotComparable>().     l.add(a).     DataSet<NotComparable> ds = env.fromCollection(l).     DataSet<NotComparable> reduceDs = ds.distinct("*"). }
false;public;0;4;;@Override public String toString() {     return myInt + "," + myLong + "," + myString. }
