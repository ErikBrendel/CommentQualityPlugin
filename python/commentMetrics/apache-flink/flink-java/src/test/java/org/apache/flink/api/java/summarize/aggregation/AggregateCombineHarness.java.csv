commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;2;1;/**  * Compare results from different runs of aggregate/combine to make sure they are the same.  *  * <p>Subclasses should cause an Assertion failure or throw an Exception if the results aren't  * equal or at least close enough.  */ ;/**  * Compare results from different runs of aggregate/combine to make sure they are the same.  *  * <p>Subclasses should cause an Assertion failure or throw an Exception if the results aren't  * equal or at least close enough.  */ protected abstract void compareResults(R result1, R result2).
true;public,final;1;46;/**  * Variously aggregate and combine against a list of values, comparing results each time.  */ ;/**  * Variously aggregate and combine against a list of values, comparing results each time.  */ @SafeVarargs public final R summarize(T... values) {     if (values.length == 0) {         // when there is nothing to aggregate just combine two empty aggregators and get the result.         A agg1 = initAggregator().         agg1.combine(initAggregator()).         return agg1.result().     } else {         R previousResult = null.         R result = null.         // Shuffling the values might cause test instability but only in the         // case that there are underlying bugs that need to be fixed         List<T> list = Arrays.asList(values).         Collections.shuffle(list).         for (int i = 0. i < values.length. i++) {             // Two aggregators are used so that combine() can be tested also.             // It shouldn't matter which aggregator is used because they are combined at the end so             // we're looping through all points of the data and making sure it doesn't make a difference.             A aggregator1 = initAggregator().             A aggregator2 = initAggregator().             for (int j = 0. j < i. j++) {                 aggregator1.aggregate(list.get(j)).             }             for (int j = i. j < values.length. j++) {                 aggregator2.aggregate(list.get(j)).             }             aggregator1.combine(aggregator2).             previousResult = result.             result = aggregator1.result().             if (previousResult != null) {                 // validate that variously aggregating then combining doesn't give different results                 compareResults(result, previousResult).             }         }         return result.     } }
false;private;0;12;;@SuppressWarnings("unchecked") private A initAggregator() {     try {         // http://stackoverflow.com/questions/75175/create-instance-of-generic-type-in-java         return (A) ((Class) ((ParameterizedType) this.getClass().getGenericSuperclass()).getActualTypeArguments()[2]).newInstance().     } catch (Exception e) {         throw new RuntimeException("Could not initialize aggregator", e).     } }
