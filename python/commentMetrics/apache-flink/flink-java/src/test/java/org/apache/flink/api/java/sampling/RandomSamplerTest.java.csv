commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;7;;@BeforeClass public static void init() {     // initiate source data set.     for (int i = 0. i < SOURCE_SIZE. i++) {         source.add((double) i).     } }
false;private;0;9;;private void initSourcePartition() {     for (int i = 0. i < DEFAULT_PARTITION_NUMBER. i++) {         sourcePartitions[i] = new ArrayList<Double>((int) Math.ceil((double) SOURCE_SIZE / DEFAULT_PARTITION_NUMBER)).     }     for (int i = 0. i < SOURCE_SIZE. i++) {         int index = i % DEFAULT_PARTITION_NUMBER.         sourcePartitions[index].add((double) i).     } }
false;public;0;4;;@Test(expected = java.lang.IllegalArgumentException.class) public void testBernoulliSamplerWithUnexpectedFraction1() {     verifySamplerFraction(-1, false). }
false;public;0;4;;@Test(expected = java.lang.IllegalArgumentException.class) public void testBernoulliSamplerWithUnexpectedFraction2() {     verifySamplerFraction(2, false). }
false;public;0;11;;@Test @RetryOnFailure(times = 3) public void testBernoulliSamplerFraction() {     verifySamplerFraction(0.01, false).     verifySamplerFraction(0.05, false).     verifySamplerFraction(0.1, false).     verifySamplerFraction(0.3, false).     verifySamplerFraction(0.5, false).     verifySamplerFraction(0.854, false).     verifySamplerFraction(0.99, false). }
false;public;0;7;;@Test @RetryOnFailure(times = 3) public void testBernoulliSamplerDuplicateElements() {     verifyRandomSamplerDuplicateElements(new BernoulliSampler<Double>(0.01)).     verifyRandomSamplerDuplicateElements(new BernoulliSampler<Double>(0.1)).     verifyRandomSamplerDuplicateElements(new BernoulliSampler<Double>(0.5)). }
false;public;0;4;;@Test(expected = java.lang.IllegalArgumentException.class) public void testPoissonSamplerWithUnexpectedFraction1() {     verifySamplerFraction(-1, true). }
false;public;0;11;;@Test @RetryOnFailure(times = 3) public void testPoissonSamplerFraction() {     verifySamplerFraction(0.01, true).     verifySamplerFraction(0.05, true).     verifySamplerFraction(0.1, true).     verifySamplerFraction(0.5, true).     verifySamplerFraction(0.854, true).     verifySamplerFraction(0.99, true).     verifySamplerFraction(1.5, true). }
false;public;0;4;;@Test(expected = java.lang.IllegalArgumentException.class) public void testReservoirSamplerUnexpectedSize1() {     verifySamplerFixedSampleSize(-1, true). }
false;public;0;4;;@Test(expected = java.lang.IllegalArgumentException.class) public void testReservoirSamplerUnexpectedSize2() {     verifySamplerFixedSampleSize(-1, false). }
false;public;0;8;;@Test @RetryOnFailure(times = 3) public void testBernoulliSamplerDistribution() {     verifyBernoulliSampler(0.01d).     verifyBernoulliSampler(0.05d).     verifyBernoulliSampler(0.1d).     verifyBernoulliSampler(0.5d). }
false;public;0;8;;@Test @RetryOnFailure(times = 3) public void testPoissonSamplerDistribution() {     verifyPoissonSampler(0.01d).     verifyPoissonSampler(0.05d).     verifyPoissonSampler(0.1d).     verifyPoissonSampler(0.5d). }
false;public;0;16;;@Test @RetryOnFailure(times = 3) public void testReservoirSamplerSampledSize() {     verifySamplerFixedSampleSize(1, true).     verifySamplerFixedSampleSize(10, true).     verifySamplerFixedSampleSize(100, true).     verifySamplerFixedSampleSize(1234, true).     verifySamplerFixedSampleSize(9999, true).     verifySamplerFixedSampleSize(20000, true).     verifySamplerFixedSampleSize(1, false).     verifySamplerFixedSampleSize(10, false).     verifySamplerFixedSampleSize(100, false).     verifySamplerFixedSampleSize(1234, false).     verifySamplerFixedSampleSize(9999, false). }
false;public;0;7;;@Test @RetryOnFailure(times = 3) public void testReservoirSamplerSampledSize2() {     RandomSampler<Double> sampler = new ReservoirSamplerWithoutReplacement<Double>(20000).     Iterator<Double> sampled = sampler.sample(source.iterator()).     assertTrue("ReservoirSamplerWithoutReplacement sampled output size should not beyond the source size.", getSize(sampled) == SOURCE_SIZE). }
false;public;0;7;;@Test @RetryOnFailure(times = 3) public void testReservoirSamplerDuplicateElements() {     verifyRandomSamplerDuplicateElements(new ReservoirSamplerWithoutReplacement<Double>(100)).     verifyRandomSamplerDuplicateElements(new ReservoirSamplerWithoutReplacement<Double>(1000)).     verifyRandomSamplerDuplicateElements(new ReservoirSamplerWithoutReplacement<Double>(5000)). }
false;public;0;8;;@Test @RetryOnFailure(times = 3) public void testReservoirSamplerWithoutReplacement() {     verifyReservoirSamplerWithoutReplacement(100, false).     verifyReservoirSamplerWithoutReplacement(500, false).     verifyReservoirSamplerWithoutReplacement(1000, false).     verifyReservoirSamplerWithoutReplacement(5000, false). }
false;public;0;8;;@Test @RetryOnFailure(times = 3) public void testReservoirSamplerWithReplacement() {     verifyReservoirSamplerWithReplacement(100, false).     verifyReservoirSamplerWithReplacement(500, false).     verifyReservoirSamplerWithReplacement(1000, false).     verifyReservoirSamplerWithReplacement(5000, false). }
false;public;0;10;;@Test @RetryOnFailure(times = 3) public void testReservoirSamplerWithMultiSourcePartitions1() {     initSourcePartition().     verifyReservoirSamplerWithoutReplacement(100, true).     verifyReservoirSamplerWithoutReplacement(500, true).     verifyReservoirSamplerWithoutReplacement(1000, true).     verifyReservoirSamplerWithoutReplacement(5000, true). }
false;public;0;10;;@Test @RetryOnFailure(times = 3) public void testReservoirSamplerWithMultiSourcePartitions2() {     initSourcePartition().     verifyReservoirSamplerWithReplacement(100, true).     verifyReservoirSamplerWithReplacement(500, true).     verifyReservoirSamplerWithReplacement(1000, true).     verifyReservoirSamplerWithReplacement(5000, true). }
true;private;2;10;/* 	 * Sample with fixed size, verify whether the sampled result size equals to input size. 	 */ ;/* 	 * Sample with fixed size, verify whether the sampled result size equals to input size. 	 */ private void verifySamplerFixedSampleSize(int numSample, boolean withReplacement) {     RandomSampler<Double> sampler.     if (withReplacement) {         sampler = new ReservoirSamplerWithReplacement<Double>(numSample).     } else {         sampler = new ReservoirSamplerWithoutReplacement<Double>(numSample).     }     Iterator<Double> sampled = sampler.sample(source.iterator()).     assertEquals(numSample, getSize(sampled)). }
true;private;2;17;/* 	 * Sample with fraction, and verify whether the sampled result close to input fraction. 	 */ ;/* 	 * Sample with fraction, and verify whether the sampled result close to input fraction. 	 */ private void verifySamplerFraction(double fraction, boolean withReplacement) {     RandomSampler<Double> sampler.     if (withReplacement) {         sampler = new PoissonSampler<Double>(fraction).     } else {         sampler = new BernoulliSampler<Double>(fraction).     }     // take 20 times sample, and take the average result size for next step comparison.     int totalSampledSize = 0.     double sampleCount = 20.     for (int i = 0. i < sampleCount. i++) {         totalSampledSize += getSize(sampler.sample(source.iterator())).     }     double resultFraction = totalSampledSize / ((double) SOURCE_SIZE * sampleCount).     assertTrue(String.format("expected fraction: %f, result fraction: %f", fraction, resultFraction), Math.abs((resultFraction - fraction) / fraction) < 0.2). }
true;private;1;8;/* 	 * Test sampler without replacement, and verify that there should not exist any duplicate element in sampled result. 	 */ ;/* 	 * Test sampler without replacement, and verify that there should not exist any duplicate element in sampled result. 	 */ private void verifyRandomSamplerDuplicateElements(final RandomSampler<Double> sampler) {     Iterator<Double> values = sampler.sample(source.iterator()).     Set<Double> set = new HashSet<>().     while (values.hasNext()) {         double next = values.next().         assertTrue("Sampler returned duplicate element (" + next + "). Set=" + set, set.add(next)).     } }
false;private;1;8;;private int getSize(Iterator<?> iterator) {     int size = 0.     while (iterator.hasNext()) {         iterator.next().         size++.     }     return size. }
false;private;1;5;;private void verifyBernoulliSampler(double fraction) {     BernoulliSampler<Double> sampler = new BernoulliSampler<Double>(fraction).     verifyRandomSamplerWithFraction(fraction, sampler, true).     verifyRandomSamplerWithFraction(fraction, sampler, false). }
false;private;1;5;;private void verifyPoissonSampler(double fraction) {     PoissonSampler<Double> sampler = new PoissonSampler<Double>(fraction).     verifyRandomSamplerWithFraction(fraction, sampler, true).     verifyRandomSamplerWithFraction(fraction, sampler, false). }
false;private;2;5;;private void verifyReservoirSamplerWithReplacement(int numSamplers, boolean sampleOnPartitions) {     ReservoirSamplerWithReplacement<Double> sampler = new ReservoirSamplerWithReplacement<Double>(numSamplers).     verifyRandomSamplerWithSampleSize(numSamplers, sampler, true, sampleOnPartitions).     verifyRandomSamplerWithSampleSize(numSamplers, sampler, false, sampleOnPartitions). }
false;private;2;5;;private void verifyReservoirSamplerWithoutReplacement(int numSamplers, boolean sampleOnPartitions) {     ReservoirSamplerWithoutReplacement<Double> sampler = new ReservoirSamplerWithoutReplacement<Double>(numSamplers).     verifyRandomSamplerWithSampleSize(numSamplers, sampler, true, sampleOnPartitions).     verifyRandomSamplerWithSampleSize(numSamplers, sampler, false, sampleOnPartitions). }
true;private;3;10;/* 	 * Verify whether random sampler sample with fraction from source data randomly. There are two default sample, one is 	 * sampled from source data with certain interval, the other is sampled only from the first half region of source data, 	 * If random sampler select elements randomly from source, it would distributed well-proportioned on source data as well, 	 * so the K-S Test result would accept the first one, while reject the second one. 	 */ ;/* 	 * Verify whether random sampler sample with fraction from source data randomly. There are two default sample, one is 	 * sampled from source data with certain interval, the other is sampled only from the first half region of source data, 	 * If random sampler select elements randomly from source, it would distributed well-proportioned on source data as well, 	 * so the K-S Test result would accept the first one, while reject the second one. 	 */ private void verifyRandomSamplerWithFraction(double fraction, RandomSampler<Double> sampler, boolean withDefaultSampler) {     double[] baseSample.     if (withDefaultSampler) {         baseSample = getDefaultSampler(fraction).     } else {         baseSample = getWrongSampler(fraction).     }     verifyKSTest(sampler, baseSample, withDefaultSampler). }
true;private;4;10;/* 	 * Verify whether random sampler sample with fixed size from source data randomly. There are two default sample, one is 	 * sampled from source data with certain interval, the other is sampled only from the first half region of source data, 	 * If random sampler select elements randomly from source, it would distributed well-proportioned on source data as well, 	 * so the K-S Test result would accept the first one, while reject the second one. 	 */ ;/* 	 * Verify whether random sampler sample with fixed size from source data randomly. There are two default sample, one is 	 * sampled from source data with certain interval, the other is sampled only from the first half region of source data, 	 * If random sampler select elements randomly from source, it would distributed well-proportioned on source data as well, 	 * so the K-S Test result would accept the first one, while reject the second one. 	 */ private void verifyRandomSamplerWithSampleSize(int sampleSize, RandomSampler<Double> sampler, boolean withDefaultSampler, boolean sampleWithPartitions) {     double[] baseSample.     if (withDefaultSampler) {         baseSample = getDefaultSampler(sampleSize).     } else {         baseSample = getWrongSampler(sampleSize).     }     verifyKSTest(sampler, baseSample, withDefaultSampler, sampleWithPartitions). }
false;private;3;3;;private void verifyKSTest(RandomSampler<Double> sampler, double[] defaultSampler, boolean expectSuccess) {     verifyKSTest(sampler, defaultSampler, expectSuccess, false). }
false;private;4;10;;private void verifyKSTest(RandomSampler<Double> sampler, double[] defaultSampler, boolean expectSuccess, boolean sampleOnPartitions) {     double[] sampled = getSampledOutput(sampler, sampleOnPartitions).     double pValue = ksTest.kolmogorovSmirnovStatistic(sampled, defaultSampler).     double dValue = getDValue(sampled.length, defaultSampler.length).     if (expectSuccess) {         assertTrue(String.format("KS test result with p value(%f), d value(%f)", pValue, dValue), pValue <= dValue).     } else {         assertTrue(String.format("KS test result with p value(%f), d value(%f)", pValue, dValue), pValue > dValue).     } }
false;private;2;21;;private double[] getSampledOutput(RandomSampler<Double> sampler, boolean sampleOnPartitions) {     Iterator<Double> sampled.     if (sampleOnPartitions) {         DistributedRandomSampler<Double> reservoirRandomSampler = (DistributedRandomSampler<Double>) sampler.         List<IntermediateSampleData<Double>> intermediateResult = new LinkedList<>().         for (int i = 0. i < DEFAULT_PARTITION_NUMBER. i++) {             Iterator<IntermediateSampleData<Double>> partialIntermediateResult = reservoirRandomSampler.sampleInPartition(sourcePartitions[i].iterator()).             while (partialIntermediateResult.hasNext()) {                 intermediateResult.add(partialIntermediateResult.next()).             }         }         sampled = reservoirRandomSampler.sampleInCoordinator(intermediateResult.iterator()).     } else {         sampled = sampler.sample(source.iterator()).     }     List<Double> list = new ArrayList<>().     while (sampled.hasNext()) {         list.add(sampled.next()).     }     return transferFromListToArrayWithOrder(list). }
true;private;1;8;/* 	 * Some sample result may not order by the input sequence, we should make it in order to do K-S test. 	 */ ;/* 	 * Some sample result may not order by the input sequence, we should make it in order to do K-S test. 	 */ private double[] transferFromListToArrayWithOrder(List<Double> list) {     Collections.sort(list).     double[] result = new double[list.size()].     for (int i = 0. i < list.size(). i++) {         result[i] = list.get(i).     }     return result. }
false;private;1;11;;private double[] getDefaultSampler(double fraction) {     Preconditions.checkArgument(fraction > 0, "Sample fraction should be positive.").     int size = (int) (SOURCE_SIZE * fraction).     double step = 1 / fraction.     double[] defaultSampler = new double[size].     for (int i = 0. i < size. i++) {         defaultSampler[i] = Math.round(step * i).     }     return defaultSampler. }
false;private;1;10;;private double[] getDefaultSampler(int fixSize) {     Preconditions.checkArgument(fixSize > 0, "Sample fraction should be positive.").     double step = SOURCE_SIZE / (double) fixSize.     double[] defaultSampler = new double[fixSize].     for (int i = 0. i < fixSize. i++) {         defaultSampler[i] = Math.round(step * i).     }     return defaultSampler. }
true;private;1;11;/* 	 * Build a failed sample distribution which only contains elements in the first half of source data. 	 */ ;/* 	 * Build a failed sample distribution which only contains elements in the first half of source data. 	 */ private double[] getWrongSampler(double fraction) {     Preconditions.checkArgument(fraction > 0, "Sample size should be positive.").     int size = (int) (SOURCE_SIZE * fraction).     int halfSourceSize = SOURCE_SIZE / 2.     double[] wrongSampler = new double[size].     for (int i = 0. i < size. i++) {         wrongSampler[i] = (double) i % halfSourceSize.     }     return wrongSampler. }
true;private;1;10;/* 	 * Build a failed sample distribution which only contains elements in the first half of source data. 	 */ ;/* 	 * Build a failed sample distribution which only contains elements in the first half of source data. 	 */ private double[] getWrongSampler(int fixSize) {     Preconditions.checkArgument(fixSize > 0, "Sample size be positive.").     int halfSourceSize = SOURCE_SIZE / 2.     double[] wrongSampler = new double[fixSize].     for (int i = 0. i < fixSize. i++) {         wrongSampler[i] = (double) i % halfSourceSize.     }     return wrongSampler. }
true;private;2;7;/* 	 * Calculate the D value of K-S test for p-value 0.001, m and n are the sample size 	 */ ;/* 	 * Calculate the D value of K-S test for p-value 0.001, m and n are the sample size 	 */ private double getDValue(int m, int n) {     Preconditions.checkArgument(m > 0, "input sample size should be positive.").     Preconditions.checkArgument(n > 0, "input sample size should be positive.").     double first = (double) m.     double second = (double) n.     return 1.95 * Math.sqrt((first + second) / (first * second)). }
