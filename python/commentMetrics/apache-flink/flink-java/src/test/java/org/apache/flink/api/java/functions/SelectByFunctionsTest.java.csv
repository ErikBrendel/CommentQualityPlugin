commented;modifiers;parameterAmount;loc;comment;code
true;public;0;11;/**  * This test validates whether the order of tuples has any impact on the outcome and if the bigger tuple is returned.  */ ;/**  * This test validates whether the order of tuples has any impact on the outcome and if the bigger tuple is returned.  */ @Test public void testMaxByComparison() {     SelectByMaxFunction<Tuple5<Integer, Long, String, Long, Integer>> maxByTuple = new SelectByMaxFunction<Tuple5<Integer, Long, String, Long, Integer>>(tupleTypeInfo, new int[] { 0 }).     try {         Assert.assertSame("SelectByMax must return bigger tuple", bigger, maxByTuple.reduce(smaller, bigger)).         Assert.assertSame("SelectByMax must return bigger tuple", bigger, maxByTuple.reduce(bigger, smaller)).     } catch (Exception e) {         Assert.fail("No exception should be thrown while comparing both tuples").     } }
true;public;0;11;/**  * This test cases checks when two tuples only differ in one value, but this value is not  * in the fields list. In that case it should be seen as equal and then the first given tuple (value1) should be returned by reduce().  */ ;// ----------------------- MAXIMUM FUNCTION TEST BELOW -------------------------- /**  * This test cases checks when two tuples only differ in one value, but this value is not  * in the fields list. In that case it should be seen as equal and then the first given tuple (value1) should be returned by reduce().  */ @Test public void testMaxByComparisonSpecialCase1() {     SelectByMaxFunction<Tuple5<Integer, Long, String, Long, Integer>> maxByTuple = new SelectByMaxFunction<Tuple5<Integer, Long, String, Long, Integer>>(tupleTypeInfo, new int[] { 0, 3 }).     try {         Assert.assertSame("SelectByMax must return the first given tuple", specialCaseBigger, maxByTuple.reduce(specialCaseBigger, bigger)).         Assert.assertSame("SelectByMax must return the first given tuple", bigger, maxByTuple.reduce(bigger, specialCaseBigger)).     } catch (Exception e) {         Assert.fail("No exception should be thrown while comparing both tuples").     } }
true;public;0;11;/**  * This test cases checks when two tuples only differ in one value.  */ ;/**  * This test cases checks when two tuples only differ in one value.  */ @Test public void testMaxByComparisonSpecialCase2() {     SelectByMaxFunction<Tuple5<Integer, Long, String, Long, Integer>> maxByTuple = new SelectByMaxFunction<Tuple5<Integer, Long, String, Long, Integer>>(tupleTypeInfo, new int[] { 0, 2, 1, 4, 3 }).     try {         Assert.assertSame("SelectByMax must return bigger tuple", bigger, maxByTuple.reduce(specialCaseBigger, bigger)).         Assert.assertSame("SelectByMax must return bigger tuple", bigger, maxByTuple.reduce(bigger, specialCaseBigger)).     } catch (Exception e) {         Assert.fail("No exception should be thrown while comparing both tuples").     } }
true;public;0;11;/**  * This test validates that equality is independent of the amount of used indices.  */ ;/**  * This test validates that equality is independent of the amount of used indices.  */ @Test public void testMaxByComparisonMultiple() {     SelectByMaxFunction<Tuple5<Integer, Long, String, Long, Integer>> maxByTuple = new SelectByMaxFunction<Tuple5<Integer, Long, String, Long, Integer>>(tupleTypeInfo, new int[] { 0, 1, 2, 3, 4 }).     try {         Assert.assertSame("SelectByMax must return bigger tuple", bigger, maxByTuple.reduce(smaller, bigger)).         Assert.assertSame("SelectByMax must return bigger tuple", bigger, maxByTuple.reduce(bigger, smaller)).     } catch (Exception e) {         Assert.fail("No exception should be thrown while comparing both tuples").     } }
true;public;0;11;/**  * Checks whether reduce does behave as expected if both values are the same object.  */ ;/**  * Checks whether reduce does behave as expected if both values are the same object.  */ @Test public void testMaxByComparisonMustReturnATuple() {     SelectByMaxFunction<Tuple5<Integer, Long, String, Long, Integer>> maxByTuple = new SelectByMaxFunction<Tuple5<Integer, Long, String, Long, Integer>>(tupleTypeInfo, new int[] { 0 }).     try {         Assert.assertSame("SelectByMax must return bigger tuple", bigger, maxByTuple.reduce(bigger, bigger)).         Assert.assertSame("SelectByMax must return smaller tuple", smaller, maxByTuple.reduce(smaller, smaller)).     } catch (Exception e) {         Assert.fail("No exception should be thrown while comparing both tuples").     } }
true;public;0;11;/**  * This test validates whether the order of tuples has any impact on the outcome and if the smaller tuple is returned.  */ ;// ----------------------- MINIMUM FUNCTION TEST BELOW -------------------------- /**  * This test validates whether the order of tuples has any impact on the outcome and if the smaller tuple is returned.  */ @Test public void testMinByComparison() {     SelectByMinFunction<Tuple5<Integer, Long, String, Long, Integer>> minByTuple = new SelectByMinFunction<Tuple5<Integer, Long, String, Long, Integer>>(tupleTypeInfo, new int[] { 0 }).     try {         Assert.assertSame("SelectByMin must return smaller tuple", smaller, minByTuple.reduce(smaller, bigger)).         Assert.assertSame("SelectByMin must return smaller tuple", smaller, minByTuple.reduce(bigger, smaller)).     } catch (Exception e) {         Assert.fail("No exception should be thrown while comparing both tuples").     } }
true;public;0;11;/**  * This test cases checks when two tuples only differ in one value, but this value is not  * in the fields list. In that case it should be seen as equal and then the first given tuple (value1) should be returned by reduce().  */ ;/**  * This test cases checks when two tuples only differ in one value, but this value is not  * in the fields list. In that case it should be seen as equal and then the first given tuple (value1) should be returned by reduce().  */ @Test public void testMinByComparisonSpecialCase1() {     SelectByMinFunction<Tuple5<Integer, Long, String, Long, Integer>> minByTuple = new SelectByMinFunction<Tuple5<Integer, Long, String, Long, Integer>>(tupleTypeInfo, new int[] { 0, 3 }).     try {         Assert.assertSame("SelectByMin must return the first given tuple", specialCaseBigger, minByTuple.reduce(specialCaseBigger, bigger)).         Assert.assertSame("SelectByMin must return the first given tuple", bigger, minByTuple.reduce(bigger, specialCaseBigger)).     } catch (Exception e) {         Assert.fail("No exception should be thrown while comparing both tuples").     } }
true;public;0;11;/**  * This test validates that when two tuples only differ in one value and that value's index is given  * at construction time. The smaller tuple must be returned then.  */ ;/**  * This test validates that when two tuples only differ in one value and that value's index is given  * at construction time. The smaller tuple must be returned then.  */ @Test public void testMinByComparisonSpecialCase2() {     SelectByMinFunction<Tuple5<Integer, Long, String, Long, Integer>> minByTuple = new SelectByMinFunction<Tuple5<Integer, Long, String, Long, Integer>>(tupleTypeInfo, new int[] { 0, 2, 1, 4, 3 }).     try {         Assert.assertSame("SelectByMin must return smaller tuple", smaller, minByTuple.reduce(specialCaseSmaller, smaller)).         Assert.assertSame("SelectByMin must return smaller tuple", smaller, minByTuple.reduce(smaller, specialCaseSmaller)).     } catch (Exception e) {         Assert.fail("No exception should be thrown while comparing both tuples").     } }
true;public;0;11;/**  * Checks whether reduce does behave as expected if both values are the same object.  */ ;/**  * Checks whether reduce does behave as expected if both values are the same object.  */ @Test public void testMinByComparisonMultiple() {     SelectByMinFunction<Tuple5<Integer, Long, String, Long, Integer>> minByTuple = new SelectByMinFunction<Tuple5<Integer, Long, String, Long, Integer>>(tupleTypeInfo, new int[] { 0, 1, 2, 3, 4 }).     try {         Assert.assertSame("SelectByMin must return smaller tuple", smaller, minByTuple.reduce(smaller, bigger)).         Assert.assertSame("SelectByMin must return smaller tuple", smaller, minByTuple.reduce(bigger, smaller)).     } catch (Exception e) {         Assert.fail("No exception should be thrown while comparing both tuples").     } }
