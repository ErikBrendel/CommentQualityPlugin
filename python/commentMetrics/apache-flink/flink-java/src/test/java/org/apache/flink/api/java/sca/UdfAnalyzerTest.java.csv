commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public String map(Tuple2<String, Integer> value) throws Exception {     return value.f0. }
false;public;0;5;;@Test public void testSingleFieldExtract() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map1.class, STRING_INT_TUPLE2_TYPE_INFO, Types.STRING). }
false;public;1;3;;public Tuple2<String, String> map(Tuple2<String, Integer> value) throws Exception {     return new Tuple2<String, String>(value.f0, value.f0). }
false;public;0;5;;@Test public void testForwardIntoTuple() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map2.class, STRING_INT_TUPLE2_TYPE_INFO, STRING_STRING_TUPLE2_TYPE_INFO). }
false;public;1;4;;@Override public Integer map(String[] value) throws Exception {     return value.length. }
false;public;0;5;;@Test public void testForwardWithArrayAttrAccess() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map3.class, TypeInformation.of(new TypeHint<String[]>() {     }), Types.INT). }
false;public;1;4;;@Override public String map(MyPojo value) throws Exception {     return value.field2. }
false;public;0;5;;@Test public void testForwardWithGenericTypePublicAttrAccess() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map4.class, new GenericTypeInfo<>(MyPojo.class), Types.STRING). }
false;public;1;4;;@Override public String map(MyPojo value) throws Exception {     return value.field2. }
false;public;0;5;;@Test public void testForwardWithPojoPublicAttrAccess() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map5.class, TypeInformation.of(new TypeHint<MyPojo>() {     }), Types.STRING). }
false;public;1;4;;@Override public String map(MyPojo value) throws Exception {     return value.field. }
false;public;0;5;;@Test public void testForwardWithPojoPrivateAttrAccess() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map6.class, TypeInformation.of(new TypeHint<MyPojo>() {     }), Types.STRING). }
false;public;1;7;;public Tuple2<String, String> map(Tuple2<String, Integer> value) throws Exception {     if (value.f0.equals("whatever")) {         return new Tuple2<String, String>(value.f0, value.f0).     } else {         return new Tuple2<String, String>("hello", value.f0).     } }
false;public;0;5;;@Test public void testForwardIntoTupleWithCondition() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map7.class, STRING_INT_TUPLE2_TYPE_INFO, STRING_STRING_TUPLE2_TYPE_INFO). }
false;public;1;7;;public String map(Tuple2<String, String> value) throws Exception {     if (value.f0.equals("whatever")) {         return value.f0.     } else {         return value.f1.     } }
false;public;0;5;;@Test public void testSingleFieldExtractWithCondition() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map8.class, STRING_STRING_TUPLE2_TYPE_INFO, Types.STRING). }
false;public;1;4;;public Tuple1<String> map(String value) throws Exception {     tuple.f0 = value.     return tuple. }
false;public;0;5;;@Test public void testForwardIntoTupleWithInstanceVar() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map9.class, Types.STRING, TypeInformation.of(new TypeHint<Tuple1<String>>() {     })). }
false;public;1;4;;public Tuple1<Tuple1<String>> map(String value) throws Exception {     tuple.f0.f0 = value.     return tuple. }
false;public;0;5;;@Test public void testForwardIntoTupleWithInstanceVar2() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map10.class, Types.STRING, TypeInformation.of(new TypeHint<Tuple1<Tuple1<String>>>() {     })). }
false;public;1;6;;public Tuple2<String, String> map(String value) throws Exception {     tuple.f0 = value.     modify().     tuple.f1 = value.     return tuple. }
false;private;0;3;;private void modify() {     tuple.f0 = null. }
false;public;0;5;;@Test public void testForwardIntoTupleWithInstanceVarChangedByOtherMethod() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map11.class, Types.STRING, STRING_STRING_TUPLE2_TYPE_INFO). }
false;public;1;4;;public Tuple2<Tuple1<String>, Tuple1<String>> map(Tuple2<String, Integer> value) throws Exception {     return new Tuple2<Tuple1<String>, Tuple1<String>>(new Tuple1<String>(value.f0), new Tuple1<String>(value.f0)). }
false;public;0;6;;@Test public void testForwardIntoNestedTuple() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map12.class, STRING_INT_TUPLE2_TYPE_INFO, TypeInformation.of(new TypeHint<Tuple2<Tuple1<String>, Tuple1<String>>>() {     })). }
false;public;1;7;;@SuppressWarnings("unchecked") public Tuple2<Tuple1<String>, Tuple1<String>> map(Tuple2<String, Integer> value) throws Exception {     Tuple2<?, ?> t = new Tuple2<Tuple1<String>, Tuple1<String>>(new Tuple1<String>(value.f0), new Tuple1<String>(value.f0)).     t.f0 = null.     return (Tuple2<Tuple1<String>, Tuple1<String>>) t. }
false;public;0;6;;@Test public void testForwardIntoNestedTupleWithVarAndModification() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map13.class, STRING_INT_TUPLE2_TYPE_INFO, TypeInformation.of(new TypeHint<Tuple2<Tuple1<String>, Tuple1<String>>>() {     })). }
false;public;1;5;;public Tuple2<String, String> map(Tuple2<String, Integer> value) throws Exception {     Tuple2<String, String> t = new Tuple2<String, String>().     t.f0 = value.f0.     return t. }
false;public;0;5;;@Test public void testForwardIntoTupleWithAssignment() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map14.class, STRING_INT_TUPLE2_TYPE_INFO, STRING_STRING_TUPLE2_TYPE_INFO). }
false;public;1;5;;public Tuple2<String, String> map(Tuple2<Tuple1<String>, Integer> value) throws Exception {     Tuple2<String, String> t = new Tuple2<String, String>().     t.f0 = value.f0.f0.     return t. }
false;public;0;6;;@Test public void testForwardIntoTupleWithInputPath() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map15.class, TypeInformation.of(new TypeHint<Tuple2<Tuple1<String>, Integer>>() {     }), STRING_STRING_TUPLE2_TYPE_INFO). }
false;public;1;6;;public MyPojo map(MyPojo value) throws Exception {     MyPojo p = new MyPojo().     p.setField(value.getField2()).     p.setField2(value.getField()).     return p. }
false;public;0;5;;@Test public void testForwardIntoPojoByGettersAndSetters() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map16.class, TypeInformation.of(new TypeHint<MyPojo>() {     }), TypeInformation.of(new TypeHint<MyPojo>() {     })). }
false;public;1;8;;public Tuple1<String> map(String value) throws Exception {     if (!tuple.f0.equals("")) {         tuple.f0 = "empty".     } else {         tuple.f0 = value.     }     return tuple. }
false;public;0;5;;@Test public void testForwardIntoTupleWithInstanceVarAndCondition() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map17.class, Types.STRING, TypeInformation.of(new TypeHint<Tuple1<String>>() {     })). }
false;public;1;4;;public ArrayList<String> map(Tuple1<String> value) throws Exception {     list.add(value.f0).     return list. }
false;public;0;5;;@Test public void testForwardIntoUnsupportedObject() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map18.class, TypeInformation.of(new TypeHint<Tuple1<String>>() {     }), TypeInformation.of(new TypeHint<java.util.ArrayList>() {     })). }
false;public;1;8;;@Override public Tuple1<Integer> map(Integer value) throws Exception {     Tuple1<Integer> tuple = new Tuple1<Integer>().     tuple.f0 = value.     Tuple1<Integer> tuple2 = new Tuple1<Integer>().     tuple2.f0 = tuple.f0.     return tuple2. }
false;public;0;5;;@Test public void testForwardWithNewTupleToNewTupleAssignment() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map19.class, Types.INT, TypeInformation.of(new TypeHint<Tuple1<Integer>>() {     })). }
false;public;1;8;;@Override public Tuple4<Integer, Integer, Integer, Integer> map(Tuple4<Integer, Integer, Integer, Integer> value) throws Exception {     Tuple4<Integer, Integer, Integer, Integer> t = new Tuple4<Integer, Integer, Integer, Integer>().     t.f0 = value.getField(0).     t.f1 = value.getField((int) 1L).     return t. }
false;public;0;6;;@Test public void testForwardWithGetMethod() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map20.class, TypeInformation.of(new TypeHint<Tuple4<Integer, Integer, Integer, Integer>>() {     }), TypeInformation.of(new TypeHint<Tuple4<Integer, Integer, Integer, Integer>>() {     })). }
false;public;1;7;;@Override public Tuple2<Integer, Integer> map(Tuple2<Integer, Integer> value) throws Exception {     Integer i = value.f0.     value.setField(value.f1, 0).     value.setField(i, 1).     return value. }
false;public;0;5;;@Test public void testForwardWithSetMethod() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map21.class, TypeInformation.of(new TypeHint<Tuple2<Integer, Integer>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Integer, Integer>>() {     })). }
false;public;1;7;;@Override public Tuple2<Integer, Integer> map(Tuple2<Integer, Integer> value) throws Exception {     Tuple2<Integer, Integer> t = new Tuple2<Integer, Integer>().     t.setField(value.f1, 0).     t.setField(value.getField(0), 1).     return t. }
false;public;0;5;;@Test public void testForwardIntoNewTupleWithSetMethod() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map22.class, TypeInformation.of(new TypeHint<Tuple2<Integer, Integer>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Integer, Integer>>() {     })). }
false;public;1;12;;@Override public Tuple1<Integer> map(Tuple1<Integer> value) throws Exception {     if (value.f0.equals(23)) {         return new Tuple1<Integer>(value.<Integer>getField(0)).     } else if (value.f0.equals(22)) {         Tuple1<Integer> inputContainer = new Tuple1<Integer>().         inputContainer.f0 = value.f0.         return new Tuple1<Integer>(inputContainer.<Integer>getField(0)).     } else {         return value.     } }
false;public;0;5;;@Test public void testForwardWithGetMethod2() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map23.class, TypeInformation.of(new TypeHint<Tuple1<Integer>>() {     }), TypeInformation.of(new TypeHint<Tuple1<Integer>>() {     })). }
false;public;1;7;;@Override public Tuple2<Integer, Integer> map(Tuple2<Integer, Integer> value) throws Exception {     value.setField(2, 0).     int i = 5.     value.setField(i * i + 2, 1).     return value. }
false;public;0;5;;@Test public void testForwardWithSetMethod2() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map24.class, TypeInformation.of(new TypeHint<Tuple2<Integer, Integer>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Integer, Integer>>() {     })). }
false;public;1;5;;@Override public Tuple2<Integer, Integer> map(Tuple2<Integer, Integer> value) throws Exception {     value.f0 = value.f1.     return value. }
false;public;0;5;;@Test public void testForwardWithModifiedInput() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map25.class, TypeInformation.of(new TypeHint<Tuple2<Integer, Integer>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Integer, Integer>>() {     })). }
false;public;1;14;;@Override public Tuple2<Integer, Integer> map(Integer value) throws Exception {     Tuple2<Integer, Integer> tuple = new Tuple2<Integer, Integer>().     // non-input content     if (tuple.equals(new Tuple2<Integer, Integer>())) {         tuple.f0 = 123456.     }     if (tuple.equals(new Tuple2<Integer, Integer>())) {         tuple.f0 = value.     }     // forwarding     tuple.f1 = value.     return tuple. }
false;public;0;5;;@Test public void testForwardWithTuplesGetSetFieldMethods() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map26.class, Types.INT, TypeInformation.of(new TypeHint<Tuple2<Integer, Integer>>() {     })). }
false;public;1;19;;@Override public Tuple8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> map(Tuple8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> value) throws Exception {     Tuple8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer> tuple = new Tuple8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>().     // non-input content     if (tuple.f0 == null) {         tuple.setField(123456, 0).     } else {         tuple.setField(value.f0, 0).     }     // forwarding     tuple.setField(value.f2, 3).     tuple.setField(value.f3, 7).     // tuple.setField(value.f1, 3).     return tuple. }
false;public;0;6;;@Test public void testForwardWithTuplesGetSetFieldMethods2() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map27.class, TypeInformation.of(new TypeHint<Tuple8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>>() {     }), TypeInformation.of(new TypeHint<Tuple8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>>() {     })). }
false;public;1;7;;@Override public Integer map(Integer value) throws Exception {     if (value == null) {         value = 123.     }     return value. }
false;public;0;4;;@Test public void testForwardWithBranching1() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map28.class, Types.INT, Types.INT). }
false;public;1;14;;@Override public Tuple3<String, String, String> map(Tuple3<String, String, String> value) throws Exception {     String tmp = value.f0.     for (int i = 0. i < 2. i++) {         value.setField("Test", i).     }     Tuple3<String, String, String> tuple.     if (value.f0.equals("x")) {         tuple = new Tuple3<String, String, String>(tmp, value.f0, null).     } else {         tuple = new Tuple3<String, String, String>(tmp, value.f0, "").     }     return tuple. }
false;public;0;6;;@Test public void testForwardWithBranching2() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map29.class, TypeInformation.of(new TypeHint<Tuple3<String, String, String>>() {     }), TypeInformation.of(new TypeHint<Tuple3<String, String, String>>() {     })). }
false;public;1;10;;@Override public String map(Tuple2<String, String> value) throws Exception {     String tmp.     if (value.f0.equals("")) {         tmp = value.f0.     } else {         tmp = value.f1.     }     return tmp. }
false;public;0;5;;@Test public void testForwardWithBranching3() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map30.class, STRING_STRING_TUPLE2_TYPE_INFO, Types.STRING). }
false;public;1;8;;@Override public ExtendingTuple map(Tuple2<String, String> value) throws Exception {     ExtendingTuple t = new ExtendingTuple().     t.f1 = value.f1.     t.setFirstField().     t.f0 = t.getSecondField().     return t. }
false;public;0;5;;@Test public void testForwardWithInheritance() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map31.class, STRING_STRING_TUPLE2_TYPE_INFO, STRING_STRING_TUPLE2_TYPE_INFO). }
false;public;1;14;;@Override public Tuple8<Boolean, Character, Byte, Short, Integer, Long, Float, Double> map(Tuple8<Boolean, Character, Byte, Short, Integer, Long, Float, Double> value) throws Exception {     boolean f0 = value.f0.     char f1 = value.f1.     byte f2 = value.f2.     short f3 = value.f3.     int f4 = value.f4.     long f5 = value.f5.     float f6 = value.f6.     double f7 = value.f7.     return new Tuple8<Boolean, Character, Byte, Short, Integer, Long, Float, Double>(f0, f1, f2, f3, f4, f5, f6, f7). }
false;public;0;6;;@Test public void testForwardWithUnboxingAndBoxing() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map32.class, TypeInformation.of(new TypeHint<Tuple8<Boolean, Character, Byte, Short, Integer, Long, Float, Double>>() {     }), TypeInformation.of(new TypeHint<Tuple8<Boolean, Character, Byte, Short, Integer, Long, Float, Double>>() {     })). }
false;public;1;11;;@Override public Tuple2<Long, Long> map(Tuple2<Long, Long> value) throws Exception {     Tuple2<Long, Long> t = new Tuple2<Long, Long>().     if (value.f0 != null) {         t.f0 = value.f0.     } else {         t.f0 = value.f1.     }     return t. }
false;public;0;5;;@Test public void testForwardWithBranching4() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map33.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     })). }
false;public;1;12;;@Override public Tuple2<Long, Long> map(Tuple2<Long, Long> value) throws Exception {     if (value != new Object()) {         return value.     } else if (value.f0 == 1L && value.f1 == 2L) {         t = value.         t.f0 = 23L.         return t.     }     return new Tuple2<Long, Long>(value.f0, value.f1). }
false;public;0;5;;@Test public void testForwardWithBranching5() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map34.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     })). }
false;public;1;6;;@Override public Tuple2<String[], String[]> map(String[] value) throws Exception {     String[] tmp = value.     value[0] = "Hello".     return new Tuple2<String[], String[]>(value, tmp). }
false;public;0;5;;@Test public void testForwardWithArrayModification() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map35.class, TypeInformation.of(new TypeHint<String[]>() {     }), TypeInformation.of(new TypeHint<Tuple2<String[], String[]>>() {     })). }
false;public;1;9;;@Override public Tuple3<String, String, String> map(Tuple3<String, String, String> value) throws Exception {     int i = 0.     do {         value.setField("", i).         i++.     } while (i >= 2).     return value. }
false;public;0;5;;@Test public void testForwardWithBranching6() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map36.class, TypeInformation.of(new TypeHint<Tuple3<String, String, String>>() {     }), TypeInformation.of(new TypeHint<Tuple3<String, String, String>>() {     })). }
false;public;1;6;;@SuppressWarnings("unchecked") @Override public Tuple1<Tuple1<String>> map(Tuple1<Tuple1<String>> value) throws Exception {     ((Tuple1<String>) value.getField(Integer.parseInt("2."))).f0 = "Hello".     return value. }
false;public;0;5;;@Test public void testForwardWithGetAndModification() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map37.class, TypeInformation.of(new TypeHint<Tuple1<Tuple1<String>>>() {     }), TypeInformation.of(new TypeHint<Tuple1<Tuple1<String>>>() {     })). }
false;public;1;5;;@Override public MyPojo2 map(MyPojo2 value) throws Exception {     value.setField2("test").     return value. }
false;public;0;6;;@Test public void testForwardWithInheritance2() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map38.class, TypeInformation.of(new TypeHint<MyPojo2>() {     }), TypeInformation.of(new TypeHint<MyPojo2>() {     })). }
false;public;1;6;;@Override public MyPojo map(MyPojo value) throws Exception {     MyPojo mp = new MyPojo().     mp.field = value.field2.     return mp. }
false;public;0;6;;@Test public void testForwardWithGenericTypeOutput() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map39.class, TypeInformation.of(new TypeHint<GenericTypeInfo<MyPojo>>() {     }), TypeInformation.of(new TypeHint<GenericTypeInfo<MyPojo>>() {     })). }
false;public;1;4;;@Override public MyPojo map(MyPojo value) throws Exception {     return recursiveFunction(value). }
false;private;1;7;;private MyPojo recursiveFunction(MyPojo value) {     if (value.field.equals("xyz")) {         value.field = value.field + "x".         return recursiveFunction(value).     }     return value. }
false;public;0;6;;@Test public void testForwardWithRecursion() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map40.class, TypeInformation.of(new TypeHint<MyPojo>() {     }), TypeInformation.of(new TypeHint<MyPojo>() {     })). }
false;public;1;6;;@Override public MyPojo map(MyPojo value) throws Exception {     field = value.     getRuntimeContext().getIntCounter("test").getLocalValue().     return field. }
false;public;0;6;;@Test public void testForwardWithGetRuntimeContext() {     compareAnalyzerResultWithAnnotationsSingleInput(MapFunction.class, Map41.class, TypeInformation.of(new TypeHint<MyPojo>() {     }), TypeInformation.of(new TypeHint<MyPojo>() {     })). }
false;public;2;4;;@Override public void flatMap(Tuple1<Integer> value, Collector<Tuple1<Integer>> out) throws Exception {     out.collect(value). }
false;public;0;5;;@Test public void testForwardWithCollector() {     compareAnalyzerResultWithAnnotationsSingleInput(FlatMapFunction.class, FlatMap1.class, TypeInformation.of(new TypeHint<Tuple1<Integer>>() {     }), TypeInformation.of(new TypeHint<Tuple1<Integer>>() {     })). }
false;public;2;7;;@Override public void flatMap(Tuple2<Long, Long> edge, Collector<Tuple2<Long, Long>> out) {     invertedEdge.f0 = edge.f1.     invertedEdge.f1 = edge.f0.     out.collect(invertedEdge).     out.collect(invertedEdge). }
false;public;0;5;;@Test public void testForwardWith2Collectors() {     compareAnalyzerResultWithAnnotationsSingleInput(FlatMapFunction.class, FlatMap2.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     })). }
false;public;2;5;;@Override public void flatMap(Tuple1<Integer> value, Collector<Tuple1<Integer>> out) throws Exception {     addToCollector(out).     out.collect(value). }
false;private;1;3;;private void addToCollector(Collector<Tuple1<Integer>> out) {     out.collect(new Tuple1<Integer>()). }
false;public;0;5;;@Test public void testForwardWithCollectorPassing() {     compareAnalyzerResultWithAnnotationsSingleInput(FlatMapFunction.class, FlatMap3.class, TypeInformation.of(new TypeHint<Tuple1<Integer>>() {     }), TypeInformation.of(new TypeHint<Tuple1<Integer>>() {     })). }
false;public;2;4;;@Override public Tuple2<Long, Long> join(Tuple2<Long, Long> vertexWithComponent, Tuple2<Long, Long> edge) {     return new Tuple2<Long, Long>(edge.f1, vertexWithComponent.f1). }
false;public;0;5;;@Test public void testForwardWithDualInput() {     compareAnalyzerResultWithAnnotationsDualInput(JoinFunction.class, Join1.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     })). }
false;public;3;6;;@Override public void join(Tuple2<Long, Long> candidate, Tuple2<Long, Long> old, Collector<Tuple2<Long, Long>> out) {     if (candidate.f1 < old.f1) {         out.collect(candidate).     } }
false;public;0;5;;@Test public void testForwardWithDualInputAndCollector() {     compareAnalyzerResultWithAnnotationsDualInput(FlatJoinFunction.class, Join2.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     })). }
false;public;2;4;;@Override public void reduce(Iterable<Tuple2<Long, Long>> values, Collector<Tuple2<Long, Long>> out) throws Exception {     out.collect(values.iterator().next()). }
false;public;0;5;;@Test public void testForwardWithIterable() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce1.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), new String[] { "0" }). }
false;public;2;16;;@Override public void reduce(Iterable<Tuple2<Long, Long>> values, Collector<Tuple2<Long, Long>> out) throws Exception {     final Iterator<Tuple2<Long, Long>> it = values.iterator().     Tuple2<Long, Long> outTuple = new Tuple2<Long, Long>().     Tuple2<Long, Long> first = it.next().     outTuple.f0 = first.f1.     outTuple.f1 = first.f0.     while (it.hasNext()) {         Tuple2<Long, Long> t = it.next().         if (t.f0 == 42) {             outTuple.f1 += t.f0.         }     }     out.collect(outTuple). }
false;public;0;5;;@Test public void testForwardWithIterable2() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce2.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), new String[] { "0", "1" }). }
false;public;2;6;;@Override public void reduce(Iterable<MyPojo> values, Collector<MyPojo> out) throws Exception {     for (MyPojo value : values) {         out.collect(value).     } }
false;public;0;6;;@Test public void testForwardWithIterable3() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce3.class, TypeInformation.of(new TypeHint<MyPojo>() {     }), TypeInformation.of(new TypeHint<MyPojo>() {     }), new String[] { "field2" }). }
false;public;2;8;;@Override public void reduce(Iterable<Tuple2<Long, Long>> values, Collector<Long> out) throws Exception {     Long id = 0L.     for (Tuple2<Long, Long> value : values) {         id = value.f0.     }     out.collect(id). }
false;public;0;5;;@Test public void testForwardWithAtLeastOneIterationAssumption() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce4.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), Types.LONG, new String[] { "f0" }). }
false;public;2;14;;@SuppressWarnings("unchecked") @Override public void reduce(Iterable<Tuple2<Long, Long>> values, Collector<Long> out) throws Exception {     Long id = 0L.     @SuppressWarnings("rawtypes")     Iterator it = values.iterator().     if (it.hasNext()) {         id = ((Tuple2<Long, Long>) it.next()).f0.     } else {         System.out.println("hello world").     }     out.collect(id). }
false;public;0;6;;@Test public void testForwardWithAtLeastOneIterationAssumptionForJavac() {     // this test simulates javac behaviour in Eclipse IDE     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce4Javac.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), Types.LONG, new String[] { "f0" }). }
false;public;2;11;;@Override public void reduce(Iterable<Tuple2<Long, Long>> values, Collector<Long> out) throws Exception {     Long id = 0L.     for (Tuple2<Long, Long> value : values) {         id = value.f0.         if (value != null) {             id = value.f1.         }     }     out.collect(id). }
false;public;0;5;;@Test public void testForwardWithAtLeastOneIterationAssumption2() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce5.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), Types.LONG, new String[] { "f1" }). }
false;public;2;9;;@Override public void reduce(Iterable<Tuple2<Long, Long>> values, Collector<Long> out) throws Exception {     Long id = 0L.     for (Tuple2<Long, Long> value : values) {         id = value.f0.     }     id = 0L.     out.collect(id). }
false;public;0;5;;@Test public void testForwardWithAtLeastOneIterationAssumption3() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce6.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), Types.LONG, new String[] { "f0" }). }
false;public;2;9;;@Override public void reduce(Iterable<Tuple2<Long, Long>> values, Collector<Long> out) throws Exception {     Long id = 0L.     for (Tuple2<Long, Long> value : values) {         id = value.f0.     }     id = 0L.     out.collect(id). }
false;public;0;5;;@Test public void testForwardWithAtLeastOneIterationAssumption4() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce7.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), Types.LONG, new String[] { "f0" }). }
false;public;2;9;;@Override public void reduce(Iterable<Tuple2<Long, Long>> values, Collector<Long> out) throws Exception {     Long id = 0L.     Iterator<Tuple2<Long, Long>> it = values.iterator().     while (it.hasNext()) {         id = it.next().f0.     }     out.collect(id). }
false;public;0;5;;@Test public void testForwardWithAtLeastOneIterationAssumption5() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce8.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), Types.LONG, new String[] { "f0" }). }
false;public;2;9;;@Override public void reduce(Iterable<Tuple2<Long, Long>> values, Collector<Tuple2<Long, Long>> out) throws Exception {     Tuple2<Long, Long> rv = null.     Iterator<Tuple2<Long, Long>> it = values.iterator().     while (it.hasNext()) {         rv = it.next().     }     out.collect(rv). }
false;public;0;5;;@Test public void testForwardWithAtLeastOneIterationAssumption6() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce9.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), new String[] { "f0" }). }
false;public;2;12;;@Override public void reduce(Iterable<Tuple2<Long, Long>> values, Collector<Boolean> out) throws Exception {     Iterator<Tuple2<Long, Long>> it = values.iterator().     boolean f = it.hasNext().     if (!f) {         System.out.println().     }     if (f) {         System.out.println().     }     out.collect(f). }
false;public;0;5;;@Test public void testForwardWithAtLeastOneIterationAssumption7() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(GroupReduceFunction.class, GroupReduce10.class, TypeInformation.of(new TypeHint<Tuple2<Long, Long>>() {     }), Types.BOOLEAN, new String[] { "f0" }). }
false;public;2;4;;@Override public MyPojo reduce(MyPojo value1, MyPojo value2) throws Exception {     return new MyPojo(value1.getField(), value2.getField2()). }
false;public;0;7;;@Test public void testForwardWithReduce() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(ReduceFunction.class, Reduce1.class, TypeInformation.of(new TypeHint<MyPojo>() {     }), TypeInformation.of(new TypeHint<MyPojo>() {     }), new String[] { "field" }). }
false;public;2;7;;@Override public MyPojo reduce(MyPojo value1, MyPojo value2) throws Exception {     if (value1.field != null && value1.field.isEmpty()) {         return value2.     }     return value1. }
false;public;0;7;;@Test public void testForwardWithBranchingReduce() {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(ReduceFunction.class, Reduce2.class, TypeInformation.of(new TypeHint<MyPojo>() {     }), TypeInformation.of(new TypeHint<MyPojo>() {     }), new String[] { "field" }). }
false;public;1;4;;@Override public String map(String value) throws Exception {     return null. }
false;public;1;7;;@Override public String map(String value) throws Exception {     if (value.equals("test")) {         return null.     }     return "". }
false;public;2;8;;@Override public void flatMap(String value, Collector<String> out) throws Exception {     String s = null.     if ("dd".equals("")) {         s = "".     }     out.collect(s). }
false;public;0;30;;@Test public void testNullReturnException() {     try {         final UdfAnalyzer ua = new UdfAnalyzer(MapFunction.class, NullReturnMapper1.class, "operator", BasicTypeInfo.STRING_TYPE_INFO, null, BasicTypeInfo.STRING_TYPE_INFO, null, null, true).         ua.analyze().         Assert.fail().     } catch (CodeErrorException e) {     // ok     }     try {         final UdfAnalyzer ua = new UdfAnalyzer(MapFunction.class, NullReturnMapper2.class, "operator", BasicTypeInfo.STRING_TYPE_INFO, null, BasicTypeInfo.STRING_TYPE_INFO, null, null, true).         ua.analyze().         Assert.fail().     } catch (CodeErrorException e) {     // ok     }     try {         final UdfAnalyzer ua = new UdfAnalyzer(FlatMapFunction.class, NullReturnFlatMapper.class, "operator", BasicTypeInfo.STRING_TYPE_INFO, null, BasicTypeInfo.STRING_TYPE_INFO, null, null, true).         ua.analyze().         Assert.fail().     } catch (CodeErrorException e) {     // ok     } }
false;public;1;5;;@Override public String map(String value) throws Exception {     test = "test".     return "". }
false;public;0;12;;@Test public void testPutStaticException() {     try {         final UdfAnalyzer ua = new UdfAnalyzer(MapFunction.class, PutStaticMapper.class, "operator", BasicTypeInfo.STRING_TYPE_INFO, null, BasicTypeInfo.STRING_TYPE_INFO, null, null, true).         ua.analyze().         Assert.fail().     } catch (CodeErrorException e) {     // ok     } }
false;public;1;5;;@Override public boolean filter(Tuple2<String, String> value) throws Exception {     value.f0 = value.f1.     return false. }
false;public;0;12;;@Test public void testFilterModificationException1() {     try {         final UdfAnalyzer ua = new UdfAnalyzer(FilterFunction.class, FilterMod1.class, "operator", STRING_STRING_TUPLE2_TYPE_INFO, null, null, null, null, true).         ua.analyze().         Assert.fail().     } catch (CodeErrorException e) {     // ok     } }
false;public;1;5;;@Override public boolean filter(Tuple2<String, String> value) throws Exception {     value.f0 = "".     return false. }
false;public;0;12;;@Test public void testFilterModificationException2() {     try {         final UdfAnalyzer ua = new UdfAnalyzer(FilterFunction.class, FilterMod2.class, "operator", STRING_STRING_TUPLE2_TYPE_INFO, null, null, null, null, true).         ua.analyze().         Assert.fail().     } catch (CodeErrorException e) {     // ok     } }
false;public;0;3;;public String getField() {     return field. }
false;public;1;3;;public void setField(String field) {     this.field = field. }
false;public;0;3;;public String getField2() {     return field2. }
false;public;1;3;;public void setField2(String field2) {     this.field2 = field2. }
false;public;0;3;;public void setFirstField() {     setField("Hello", 0). }
false;public;0;3;;public String getSecondField() {     return getField(1). }
false;public,static;4;4;;public static void compareAnalyzerResultWithAnnotationsSingleInput(Class<?> baseClass, Class<?> clazz, TypeInformation<?> inType, TypeInformation<?> outType) {     compareAnalyzerResultWithAnnotationsSingleInputWithKeys(baseClass, clazz, inType, outType, null). }
false;public,static;5;19;;@SuppressWarnings({ "rawtypes", "unchecked" }) public static void compareAnalyzerResultWithAnnotationsSingleInputWithKeys(Class<?> baseClass, Class<?> clazz, TypeInformation<?> inType, TypeInformation<?> outType, String[] keys) {     // expected     final Set<Annotation> annotations = FunctionAnnotation.readSingleForwardAnnotations(clazz).     SingleInputSemanticProperties expected = SemanticPropUtil.getSemanticPropsSingle(annotations, inType, outType).     if (expected == null) {         expected = new SingleInputSemanticProperties().     }     // actual     final UdfAnalyzer ua = new UdfAnalyzer(baseClass, clazz, "operator", inType, null, outType, (keys == null) ? null : new Keys.ExpressionKeys(keys, inType), null, true).     ua.analyze().     final SingleInputSemanticProperties actual = (SingleInputSemanticProperties) ua.getSemanticProperties().     assertEquals(expected.toString(), actual.toString()). }
false;public,static;5;4;;public static void compareAnalyzerResultWithAnnotationsDualInput(Class<?> baseClass, Class<?> clazz, TypeInformation<?> in1Type, TypeInformation<?> in2Type, TypeInformation<?> outType) {     compareAnalyzerResultWithAnnotationsDualInputWithKeys(baseClass, clazz, in1Type, in2Type, outType, null, null). }
false;public,static;7;17;;@SuppressWarnings({ "rawtypes", "unchecked" }) public static void compareAnalyzerResultWithAnnotationsDualInputWithKeys(Class<?> baseClass, Class<?> clazz, TypeInformation<?> in1Type, TypeInformation<?> in2Type, TypeInformation<?> outType, String[] keys1, String[] keys2) {     // expected     final Set<Annotation> annotations = FunctionAnnotation.readDualForwardAnnotations(clazz).     final DualInputSemanticProperties expected = SemanticPropUtil.getSemanticPropsDual(annotations, in1Type, in2Type, outType).     // actual     final UdfAnalyzer ua = new UdfAnalyzer(baseClass, clazz, "operator", in1Type, in2Type, outType, (keys1 == null) ? null : new Keys.ExpressionKeys(keys1, in1Type), (keys2 == null) ? null : new Keys.ExpressionKeys(keys2, in2Type), true).     ua.analyze().     final DualInputSemanticProperties actual = (DualInputSemanticProperties) ua.getSemanticProperties().     assertEquals(expected.toString(), actual.toString()). }
