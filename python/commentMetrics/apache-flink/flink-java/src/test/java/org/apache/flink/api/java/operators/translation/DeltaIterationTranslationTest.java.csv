commented;modifiers;parameterAmount;loc;comment;code
false;public;0;99;;@Test public void testCorrectTranslation() {     try {         final String jobName = "Test JobName".         final String iterationName = "Test Name".         final String beforeNextWorksetMap = "Some Mapper".         final String aggregatorName = "AggregatorName".         final int[] iterationKeys = new int[] { 2 }.         final int numIterations = 13.         final int defaultParallelism = 133.         final int iterationParallelism = 77.         ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().         // ------------ construct the test program ------------------         {             env.setParallelism(defaultParallelism).             @SuppressWarnings("unchecked")             DataSet<Tuple3<Double, Long, String>> initialSolutionSet = env.fromElements(new Tuple3<Double, Long, String>(3.44, 5L, "abc")).             @SuppressWarnings("unchecked")             DataSet<Tuple2<Double, String>> initialWorkSet = env.fromElements(new Tuple2<Double, String>(1.23, "abc")).             DeltaIteration<Tuple3<Double, Long, String>, Tuple2<Double, String>> iteration = initialSolutionSet.iterateDelta(initialWorkSet, numIterations, iterationKeys).             iteration.name(iterationName).parallelism(iterationParallelism).             iteration.registerAggregator(aggregatorName, new LongSumAggregator()).             // test that multiple workset consumers are supported             DataSet<Tuple2<Double, String>> worksetSelfJoin = iteration.getWorkset().map(new IdentityMapper<Tuple2<Double, String>>()).join(iteration.getWorkset()).where(1).equalTo(1).projectFirst(0, 1).             DataSet<Tuple3<Double, Long, String>> joined = worksetSelfJoin.join(iteration.getSolutionSet()).where(1).equalTo(2).with(new SolutionWorksetJoin()).             DataSet<Tuple3<Double, Long, String>> result = iteration.closeWith(joined, joined.map(new NextWorksetMapper()).name(beforeNextWorksetMap)).             result.output(new DiscardingOutputFormat<Tuple3<Double, Long, String>>()).             result.writeAsText("/dev/null").         }         Plan p = env.createProgramPlan(jobName).         // ------------- validate the plan ----------------         assertEquals(jobName, p.getJobName()).         assertEquals(defaultParallelism, p.getDefaultParallelism()).         // validate the iteration         GenericDataSinkBase<?> sink1, sink2.         {             Iterator<? extends GenericDataSinkBase<?>> sinks = p.getDataSinks().iterator().             sink1 = sinks.next().             sink2 = sinks.next().         }         DeltaIterationBase<?, ?> iteration = (DeltaIterationBase<?, ?>) sink1.getInput().         // check that multi consumer translation works for iterations         assertEquals(iteration, sink2.getInput()).         // check the basic iteration properties         assertEquals(numIterations, iteration.getMaximumNumberOfIterations()).         assertArrayEquals(iterationKeys, iteration.getSolutionSetKeyFields()).         assertEquals(iterationParallelism, iteration.getParallelism()).         assertEquals(iterationName, iteration.getName()).         MapOperatorBase<?, ?, ?> nextWorksetMapper = (MapOperatorBase<?, ?, ?>) iteration.getNextWorkset().         InnerJoinOperatorBase<?, ?, ?, ?> solutionSetJoin = (InnerJoinOperatorBase<?, ?, ?, ?>) iteration.getSolutionSetDelta().         InnerJoinOperatorBase<?, ?, ?, ?> worksetSelfJoin = (InnerJoinOperatorBase<?, ?, ?, ?>) solutionSetJoin.getFirstInput().         MapOperatorBase<?, ?, ?> worksetMapper = (MapOperatorBase<?, ?, ?>) worksetSelfJoin.getFirstInput().         assertEquals(IdentityMapper.class, worksetMapper.getUserCodeWrapper().getUserCodeClass()).         assertEquals(NextWorksetMapper.class, nextWorksetMapper.getUserCodeWrapper().getUserCodeClass()).         if (solutionSetJoin.getUserCodeWrapper().getUserCodeObject() instanceof WrappingFunction) {             WrappingFunction<?> wf = (WrappingFunction<?>) solutionSetJoin.getUserCodeWrapper().getUserCodeObject().             assertEquals(SolutionWorksetJoin.class, wf.getWrappedFunction().getClass()).         } else {             assertEquals(SolutionWorksetJoin.class, solutionSetJoin.getUserCodeWrapper().getUserCodeClass()).         }         assertEquals(beforeNextWorksetMap, nextWorksetMapper.getName()).         assertEquals(aggregatorName, iteration.getAggregators().getAllRegisteredAggregators().iterator().next().getName()).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;35;;@Test public void testRejectWhenSolutionSetKeysDontMatchJoin() {     try {         ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().         @SuppressWarnings("unchecked")         DataSet<Tuple3<Double, Long, String>> initialSolutionSet = env.fromElements(new Tuple3<Double, Long, String>(3.44, 5L, "abc")).         @SuppressWarnings("unchecked")         DataSet<Tuple2<Double, String>> initialWorkSet = env.fromElements(new Tuple2<Double, String>(1.23, "abc")).         DeltaIteration<Tuple3<Double, Long, String>, Tuple2<Double, String>> iteration = initialSolutionSet.iterateDelta(initialWorkSet, 10, 1).         try {             iteration.getWorkset().join(iteration.getSolutionSet()).where(1).equalTo(2).             fail("Accepted invalid program.").         } catch (InvalidProgramException e) {         // all good!         }         try {             iteration.getSolutionSet().join(iteration.getWorkset()).where(2).equalTo(1).             fail("Accepted invalid program.").         } catch (InvalidProgramException e) {         // all good!         }     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;0;35;;@Test public void testRejectWhenSolutionSetKeysDontMatchCoGroup() {     try {         ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment().         @SuppressWarnings("unchecked")         DataSet<Tuple3<Double, Long, String>> initialSolutionSet = env.fromElements(new Tuple3<Double, Long, String>(3.44, 5L, "abc")).         @SuppressWarnings("unchecked")         DataSet<Tuple2<Double, String>> initialWorkSet = env.fromElements(new Tuple2<Double, String>(1.23, "abc")).         DeltaIteration<Tuple3<Double, Long, String>, Tuple2<Double, String>> iteration = initialSolutionSet.iterateDelta(initialWorkSet, 10, 1).         try {             iteration.getWorkset().coGroup(iteration.getSolutionSet()).where(1).equalTo(2).with(new SolutionWorksetCoGroup1()).             fail("Accepted invalid program.").         } catch (InvalidProgramException e) {         // all good!         }         try {             iteration.getSolutionSet().coGroup(iteration.getWorkset()).where(2).equalTo(1).with(new SolutionWorksetCoGroup2()).             fail("Accepted invalid program.").         } catch (InvalidProgramException e) {         // all good!         }     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail(e.getMessage()).     } }
false;public;2;4;;@Override public Tuple3<Double, Long, String> join(Tuple2<Double, String> first, Tuple3<Double, Long, String> second) {     return null. }
false;public;1;4;;@Override public Tuple2<Double, String> map(Tuple3<Double, Long, String> value) {     return null. }
false;public;1;4;;@Override public T map(T value) throws Exception {     return value. }
false;public;3;4;;@Override public void coGroup(Iterable<Tuple2<Double, String>> first, Iterable<Tuple3<Double, Long, String>> second, Collector<Tuple3<Double, Long, String>> out) { }
false;public;3;4;;@Override public void coGroup(Iterable<Tuple3<Double, Long, String>> second, Iterable<Tuple2<Double, String>> first, Collector<Tuple3<Double, Long, String>> out) { }
