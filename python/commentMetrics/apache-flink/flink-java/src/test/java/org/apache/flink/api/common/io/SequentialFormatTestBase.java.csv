commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public int compare(FileInputSplit o1, FileInputSplit o2) {     int pathOrder = o1.getPath().getName().compareTo(o2.getPath().getName()).     return pathOrder == 0 ? Long.signum(o1.getStart() - o2.getStart()) : pathOrder. }
true;public;0;13;/**  * Count how many bytes would be written if all records were directly serialized.  */ ;/**  * Count how many bytes would be written if all records were directly serialized.  */ @Before public void calcRawDataSize() throws IOException {     int recordIndex = 0.     for (int fileIndex = 0. fileIndex < this.parallelism. fileIndex++) {         ByteCounter byteCounter = new ByteCounter().         for (int fileCount = 0. fileCount < this.getNumberOfTuplesPerFile(fileIndex). fileCount++, recordIndex++) {             writeRecord(this.getRecord(recordIndex), new DataOutputViewStreamWrapper(byteCounter)).         }         this.rawDataSizes[fileIndex] = byteCounter.getLength().     } }
true;public;0;29;/**  * Checks if the expected input splits were created.  */ ;/**  * Checks if the expected input splits were created.  */ @Test public void checkInputSplits() throws IOException {     FileInputSplit[] inputSplits = this.createInputFormat().createInputSplits(0).     Arrays.sort(inputSplits, new InputSplitSorter()).     int splitIndex = 0.     for (int fileIndex = 0. fileIndex < this.parallelism. fileIndex++) {         List<FileInputSplit> sameFileSplits = new ArrayList<FileInputSplit>().         Path lastPath = inputSplits[splitIndex].getPath().         for (. splitIndex < inputSplits.length. splitIndex++) {             if (!inputSplits[splitIndex].getPath().equals(lastPath)) {                 break.             }             sameFileSplits.add(inputSplits[splitIndex]).         }         Assert.assertEquals(this.getExpectedBlockCount(fileIndex), sameFileSplits.size()).         long lastBlockLength = this.rawDataSizes[fileIndex] % (this.blockSize - getInfoSize()) + getInfoSize().         for (int index = 0. index < sameFileSplits.size(). index++) {             Assert.assertEquals(this.blockSize * index, sameFileSplits.get(index).getStart()).             if (index < sameFileSplits.size() - 1) {                 Assert.assertEquals(this.blockSize, sameFileSplits.get(index).getLength()).             }         }         Assert.assertEquals(lastBlockLength, sameFileSplits.get(sameFileSplits.size() - 1).getLength()).     } }
true;public;0;30;/**  * Tests if the expected sequence and amount of data can be read.  */ ;/**  * Tests if the expected sequence and amount of data can be read.  */ @Test public void checkRead() throws Exception {     BinaryInputFormat<T> input = this.createInputFormat().     FileInputSplit[] inputSplits = input.createInputSplits(0).     Arrays.sort(inputSplits, new InputSplitSorter()).     int readCount = 0.     for (FileInputSplit inputSplit : inputSplits) {         input.open(inputSplit).         input.reopen(inputSplit, input.getCurrentState()).         T record = createInstance().         while (!input.reachedEnd()) {             if (input.nextRecord(record) != null) {                 this.checkEquals(this.getRecord(readCount), record).                 if (!input.reachedEnd()) {                     Tuple2<Long, Long> state = input.getCurrentState().                     input = this.createInputFormat().                     input.reopen(inputSplit, state).                 }                 readCount++.             }         }     }     Assert.assertEquals(this.numberOfTuples, readCount). }
true;public;0;6;/**  * Tests the statistics of the given format.  */ ;/**  * Tests the statistics of the given format.  */ @Test public void checkStatistics() {     BinaryInputFormat<T> input = this.createInputFormat().     BaseStatistics statistics = input.getStatistics(null).     Assert.assertEquals(this.numberOfTuples, statistics.getNumberOfRecords()). }
false;public;0;4;;@After public void cleanup() {     this.deleteRecursively(this.tempFile). }
false;private;1;9;;private void deleteRecursively(File file) {     if (file.isDirectory()) {         for (File subFile : file.listFiles()) {             this.deleteRecursively(subFile).         }     } else {         file.delete().     } }
true;public;0;27;/**  * Write out the tuples in a temporary file and return it.  */ ;/**  * Write out the tuples in a temporary file and return it.  */ @Before public void writeTuples() throws IOException {     this.tempFile = File.createTempFile("BinaryInputFormat", null).     this.tempFile.deleteOnExit().     Configuration configuration = new Configuration().     configuration.setLong(BinaryOutputFormat.BLOCK_SIZE_PARAMETER_KEY, this.blockSize).     if (this.parallelism == 1) {         BinaryOutputFormat<T> output = createOutputFormat(this.tempFile.toURI().toString(), configuration).         for (int index = 0. index < this.numberOfTuples. index++) {             output.writeRecord(this.getRecord(index)).         }         output.close().     } else {         this.tempFile.delete().         this.tempFile.mkdir().         int recordIndex = 0.         for (int fileIndex = 0. fileIndex < this.parallelism. fileIndex++) {             BinaryOutputFormat<T> output = createOutputFormat(this.tempFile.toURI() + "/" + (fileIndex + 1), configuration).             for (int fileCount = 0. fileCount < this.getNumberOfTuplesPerFile(fileIndex). fileCount++, recordIndex++) {                 output.writeRecord(this.getRecord(recordIndex)).             }             output.close().         }     } }
false;private;1;3;;private int getNumberOfTuplesPerFile(int fileIndex) {     return this.numberOfTuples / this.parallelism. }
true;public;0;12;/**  * Tests if the length of the file matches the expected value.  */ ;/**  * Tests if the length of the file matches the expected value.  */ @Test public void checkLength() {     File[] files = this.tempFile.isDirectory() ? this.tempFile.listFiles() : new File[] { this.tempFile }.     Arrays.sort(files).     for (int fileIndex = 0. fileIndex < this.parallelism. fileIndex++) {         long lastBlockLength = this.rawDataSizes[fileIndex] % (this.blockSize - getInfoSize()).         long expectedLength = (this.getExpectedBlockCount(fileIndex) - 1) * this.blockSize + getInfoSize() + lastBlockLength.         Assert.assertEquals(expectedLength, files[fileIndex].length()).     } }
false;protected,abstract;0;1;;protected abstract BinaryInputFormat<T> createInputFormat().
false;protected,abstract;2;2;;protected abstract BinaryOutputFormat<T> createOutputFormat(String path, Configuration configuration) throws IOException.
false;protected,abstract;0;1;;protected abstract int getInfoSize().
true;protected,abstract;1;1;/**  * Returns the record to write at the given position.  */ ;/**  * Returns the record to write at the given position.  */ protected abstract T getRecord(int index).
false;protected,abstract;0;1;;protected abstract T createInstance().
false;protected,abstract;2;1;;protected abstract void writeRecord(T record, DataOutputView outputView) throws IOException.
true;protected,abstract;2;1;/**  * Checks if both records are equal.  */ ;/**  * Checks if both records are equal.  */ protected abstract void checkEquals(T expected, T actual).
false;private;1;6;;private int getExpectedBlockCount(int fileIndex) {     int expectedBlockCount = (int) Math.ceil((double) this.rawDataSizes[fileIndex] / (this.blockSize - getInfoSize())).     return expectedBlockCount. }
false;public,static;0;13;;@Parameters public static List<Object[]> getParameters() {     ArrayList<Object[]> params = new ArrayList<Object[]>().     for (int parallelism = 1. parallelism <= 2. parallelism++) {         // numberOfTuples, blockSize, parallelism         params.add(new Object[] { 100, BinaryOutputFormat.NATIVE_BLOCK_SIZE, parallelism }).         params.add(new Object[] { 100, 1000, parallelism }).         params.add(new Object[] { 100, 1 << 20, parallelism }).         params.add(new Object[] { 10000, 1000, parallelism }).         params.add(new Object[] { 10000, 1 << 20, parallelism }).     }     return params. }
true;public;0;3;/**  * Returns the length.  *  * @return the length  */ ;/**  * Returns the length.  *  * @return the length  */ public int getLength() {     return this.length. }
false;public;1;4;;@Override public void write(int b) throws IOException {     this.length++. }
