commented;modifiers;parameterAmount;loc;comment;code
false;public;0;35;;@Test public void translateDistinctPlain() {     try {         final int parallelism = 8.         ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment(parallelism).         DataSet<Tuple3<Double, StringValue, LongValue>> initialData = getSourceDataSet(env).         initialData.distinct().output(new DiscardingOutputFormat<Tuple3<Double, StringValue, LongValue>>()).         Plan p = env.createProgramPlan().         GenericDataSinkBase<?> sink = p.getDataSinks().iterator().next().         // currently distinct is translated to a Reduce         ReduceOperatorBase<?, ?> reducer = (ReduceOperatorBase<?, ?>) sink.getInput().         // check types         assertEquals(initialData.getType(), reducer.getOperatorInfo().getInputType()).         assertEquals(initialData.getType(), reducer.getOperatorInfo().getOutputType()).         // check keys         assertArrayEquals(new int[] { 0, 1, 2 }, reducer.getKeyColumns(0)).         // parallelism was not configured on the operator         assertTrue(reducer.getParallelism() == 1 || reducer.getParallelism() == -1).         assertTrue(reducer.getInput() instanceof GenericDataSourceBase<?, ?>).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail("Test caused an error: " + e.getMessage()).     } }
false;public;0;35;;@Test public void translateDistinctPlain2() {     try {         final int parallelism = 8.         ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment(parallelism).         DataSet<CustomType> initialData = getSourcePojoDataSet(env).         initialData.distinct().output(new DiscardingOutputFormat<CustomType>()).         Plan p = env.createProgramPlan().         GenericDataSinkBase<?> sink = p.getDataSinks().iterator().next().         // currently distinct is translated to a Reduce         ReduceOperatorBase<?, ?> reducer = (ReduceOperatorBase<?, ?>) sink.getInput().         // check types         assertEquals(initialData.getType(), reducer.getOperatorInfo().getInputType()).         assertEquals(initialData.getType(), reducer.getOperatorInfo().getOutputType()).         // check keys         assertArrayEquals(new int[] { 0 }, reducer.getKeyColumns(0)).         // parallelism was not configured on the operator         assertTrue(reducer.getParallelism() == 1 || reducer.getParallelism() == -1).         assertTrue(reducer.getInput() instanceof GenericDataSourceBase<?, ?>).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail("Test caused an error: " + e.getMessage()).     } }
false;public;0;35;;@Test public void translateDistinctPosition() {     try {         final int parallelism = 8.         ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment(parallelism).         DataSet<Tuple3<Double, StringValue, LongValue>> initialData = getSourceDataSet(env).         initialData.distinct(1, 2).output(new DiscardingOutputFormat<Tuple3<Double, StringValue, LongValue>>()).         Plan p = env.createProgramPlan().         GenericDataSinkBase<?> sink = p.getDataSinks().iterator().next().         // currently distinct is translated to a Reduce         ReduceOperatorBase<?, ?> reducer = (ReduceOperatorBase<?, ?>) sink.getInput().         // check types         assertEquals(initialData.getType(), reducer.getOperatorInfo().getInputType()).         assertEquals(initialData.getType(), reducer.getOperatorInfo().getOutputType()).         // check keys         assertArrayEquals(new int[] { 1, 2 }, reducer.getKeyColumns(0)).         // parallelism was not configured on the operator         assertTrue(reducer.getParallelism() == 1 || reducer.getParallelism() == -1).         assertTrue(reducer.getInput() instanceof GenericDataSourceBase<?, ?>).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail("Test caused an error: " + e.getMessage()).     } }
false;public;1;3;;public StringValue getKey(Tuple3<Double, StringValue, LongValue> value) {     return value.f1. }
false;public;0;51;;@Test public void translateDistinctKeySelector() {     try {         final int parallelism = 8.         ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment(parallelism).         DataSet<Tuple3<Double, StringValue, LongValue>> initialData = getSourceDataSet(env).         initialData.distinct(new KeySelector<Tuple3<Double, StringValue, LongValue>, StringValue>() {              public StringValue getKey(Tuple3<Double, StringValue, LongValue> value) {                 return value.f1.             }         }).setParallelism(4).output(new DiscardingOutputFormat<Tuple3<Double, StringValue, LongValue>>()).         Plan p = env.createProgramPlan().         GenericDataSinkBase<?> sink = p.getDataSinks().iterator().next().         MapOperatorBase<?, ?, ?> keyRemover = (MapOperatorBase<?, ?, ?>) sink.getInput().         PlanUnwrappingReduceOperator<?, ?> reducer = (PlanUnwrappingReduceOperator<?, ?>) keyRemover.getInput().         MapOperatorBase<?, ?, ?> keyExtractor = (MapOperatorBase<?, ?, ?>) reducer.getInput().         // check the parallelisms         assertEquals(1, keyExtractor.getParallelism()).         assertEquals(4, reducer.getParallelism()).         // check types         TypeInformation<?> keyValueInfo = new TupleTypeInfo<Tuple2<StringValue, Tuple3<Double, StringValue, LongValue>>>(new ValueTypeInfo<StringValue>(StringValue.class), initialData.getType()).         assertEquals(initialData.getType(), keyExtractor.getOperatorInfo().getInputType()).         assertEquals(keyValueInfo, keyExtractor.getOperatorInfo().getOutputType()).         assertEquals(keyValueInfo, reducer.getOperatorInfo().getInputType()).         assertEquals(keyValueInfo, reducer.getOperatorInfo().getOutputType()).         assertEquals(keyValueInfo, keyRemover.getOperatorInfo().getInputType()).         assertEquals(initialData.getType(), keyRemover.getOperatorInfo().getOutputType()).         // check keys         assertEquals(KeyExtractingMapper.class, keyExtractor.getUserCodeWrapper().getUserCodeClass()).         assertTrue(keyExtractor.getInput() instanceof GenericDataSourceBase<?, ?>).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail("Test caused an error: " + e.getMessage()).     } }
false;public;0;35;;@Test public void translateDistinctExpressionKey() {     try {         final int parallelism = 8.         ExecutionEnvironment env = ExecutionEnvironment.createLocalEnvironment(parallelism).         DataSet<CustomType> initialData = getSourcePojoDataSet(env).         initialData.distinct("myInt").output(new DiscardingOutputFormat<CustomType>()).         Plan p = env.createProgramPlan().         GenericDataSinkBase<?> sink = p.getDataSinks().iterator().next().         // currently distinct is translated to a Reduce         ReduceOperatorBase<?, ?> reducer = (ReduceOperatorBase<?, ?>) sink.getInput().         // check types         assertEquals(initialData.getType(), reducer.getOperatorInfo().getInputType()).         assertEquals(initialData.getType(), reducer.getOperatorInfo().getOutputType()).         // check keys         assertArrayEquals(new int[] { 0 }, reducer.getKeyColumns(0)).         // parallelism was not configured on the operator         assertTrue(reducer.getParallelism() == 1 || reducer.getParallelism() == -1).         assertTrue(reducer.getInput() instanceof GenericDataSourceBase<?, ?>).     } catch (Exception e) {         System.err.println(e.getMessage()).         e.printStackTrace().         fail("Test caused an error: " + e.getMessage()).     } }
false;private,static;1;5;;@SuppressWarnings("unchecked") private static DataSet<Tuple3<Double, StringValue, LongValue>> getSourceDataSet(ExecutionEnvironment env) {     return env.fromElements(new Tuple3<Double, StringValue, LongValue>(3.141592, new StringValue("foobar"), new LongValue(77))).setParallelism(1). }
false;private,static;1;5;;private static DataSet<CustomType> getSourcePojoDataSet(ExecutionEnvironment env) {     List<CustomType> data = new ArrayList<CustomType>().     data.add(new CustomType(1)).     return env.fromCollection(data). }
false;public;0;4;;@Override public String toString() {     return "" + myInt. }
