commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;45;;@Override protected org.apache.flink.api.common.operators.SingleInputOperator<?, T, ?> translateToDataFlow(Operator<T> input) {     final ReduceFunction<T> function = new DistinctFunction<>().     String name = getName() != null ? getName() : "Distinct at " + distinctLocationName.     if (keys instanceof Keys.ExpressionKeys) {         int[] logicalKeyPositions = keys.computeLogicalKeyPositions().         UnaryOperatorInformation<T, T> operatorInfo = new UnaryOperatorInformation<>(getInputType(), getResultType()).         ReduceOperatorBase<T, ReduceFunction<T>> po = new ReduceOperatorBase<>(function, operatorInfo, logicalKeyPositions, name).         po.setCombineHint(hint).         po.setInput(input).         po.setParallelism(getParallelism()).         // make sure that distinct preserves the partitioning for the fields on which they operate         if (getType().isTupleType()) {             SingleInputSemanticProperties sProps = new SingleInputSemanticProperties().             for (int field : keys.computeLogicalKeyPositions()) {                 sProps.addForwardedField(field, field).             }             po.setSemanticProperties(sProps).         }         return po.     } else if (keys instanceof SelectorFunctionKeys) {         @SuppressWarnings("unchecked")         SelectorFunctionKeys<T, ?> selectorKeys = (SelectorFunctionKeys<T, ?>) keys.         org.apache.flink.api.common.operators.SingleInputOperator<?, T, ?> po = translateSelectorFunctionDistinct(selectorKeys, function, getResultType(), name, input, parallelism, hint).         return po.     } else {         throw new UnsupportedOperationException("Unrecognized key type.").     } }
true;public;1;5;/**  * Sets the strategy to use for the combine phase of the reduce.  *  * <p>If this method is not called, then the default hint will be used.  * ({@link org.apache.flink.api.common.operators.base.ReduceOperatorBase.CombineHint#OPTIMIZER_CHOOSES})  *  * @param strategy The hint to use.  * @return The DistinctOperator object, for function call chaining.  */ ;/**  * Sets the strategy to use for the combine phase of the reduce.  *  * <p>If this method is not called, then the default hint will be used.  * ({@link org.apache.flink.api.common.operators.base.ReduceOperatorBase.CombineHint#OPTIMIZER_CHOOSES})  *  * @param strategy The hint to use.  * @return The DistinctOperator object, for function call chaining.  */ @PublicEvolving public DistinctOperator<T> setCombineHint(CombineHint strategy) {     this.hint = strategy.     return this. }
false;private,static;7;22;;// -------------------------------------------------------------------------------------------- private static <IN, K> org.apache.flink.api.common.operators.SingleInputOperator<?, IN, ?> translateSelectorFunctionDistinct(SelectorFunctionKeys<IN, ?> rawKeys, ReduceFunction<IN> function, TypeInformation<IN> outputType, String name, Operator<IN> input, int parallelism, CombineHint hint) {     @SuppressWarnings("unchecked")     final SelectorFunctionKeys<IN, K> keys = (SelectorFunctionKeys<IN, K>) rawKeys.     TypeInformation<Tuple2<K, IN>> typeInfoWithKey = KeyFunctions.createTypeWithKey(keys).     Operator<Tuple2<K, IN>> keyedInput = KeyFunctions.appendKeyExtractor(input, keys).     PlanUnwrappingReduceOperator<IN, K> reducer = new PlanUnwrappingReduceOperator<>(function, keys, name, outputType, typeInfoWithKey).     reducer.setInput(keyedInput).     reducer.setCombineHint(hint).     reducer.setParallelism(parallelism).     return KeyFunctions.appendKeyRemover(reducer, keys). }
false;public;2;4;;@Override public T reduce(T value1, T value2) throws Exception {     return value1. }
