commented;modifiers;parameterAmount;loc;comment;code
true;public;1;10;/**  * Sets the order of keys for range partitioning.  * NOTE: Only valid for {@link PartitionMethod#RANGE}.  *  * @param orders array of orders for each specified partition key  * @return The partitioneOperator with properly set orders for given keys  */ ;/**  * Sets the order of keys for range partitioning.  * NOTE: Only valid for {@link PartitionMethod#RANGE}.  *  * @param orders array of orders for each specified partition key  * @return The partitioneOperator with properly set orders for given keys  */ @PublicEvolving public PartitionOperator<T> withOrders(Order... orders) {     Preconditions.checkState(pMethod == PartitionMethod.RANGE, "Orders cannot be applied for %s partition " + "method", pMethod).     Preconditions.checkArgument(pKeys.getOriginalKeyFieldTypes().length == orders.length, "The number of key " + "fields and orders should be the same.").     this.orders = orders.     return this. }
true;public;0;4;/**  * Gets the custom partitioner from this partitioning.  *  * @return The custom partitioner.  */ ;// -------------------------------------------------------------------------------------------- // Properties // -------------------------------------------------------------------------------------------- /**  * Gets the custom partitioner from this partitioning.  *  * @return The custom partitioner.  */ @Internal public Partitioner<?> getCustomPartitioner() {     return customPartitioner. }
false;protected;1;45;;// -------------------------------------------------------------------------------------------- // Translation // -------------------------------------------------------------------------------------------- protected org.apache.flink.api.common.operators.SingleInputOperator<?, T, ?> translateToDataFlow(Operator<T> input) {     String name = "Partition at " + partitionLocationName.     // distinguish between partition types     if (pMethod == PartitionMethod.REBALANCE) {         UnaryOperatorInformation<T, T> operatorInfo = new UnaryOperatorInformation<>(getType(), getType()).         PartitionOperatorBase<T> rebalancedInput = new PartitionOperatorBase<>(operatorInfo, pMethod, name).         rebalancedInput.setInput(input).         rebalancedInput.setParallelism(getParallelism()).         return rebalancedInput.     } else if (pMethod == PartitionMethod.HASH || pMethod == PartitionMethod.CUSTOM || pMethod == PartitionMethod.RANGE) {         if (pKeys instanceof Keys.ExpressionKeys) {             int[] logicalKeyPositions = pKeys.computeLogicalKeyPositions().             UnaryOperatorInformation<T, T> operatorInfo = new UnaryOperatorInformation<>(getType(), getType()).             PartitionOperatorBase<T> partitionedInput = new PartitionOperatorBase<>(operatorInfo, pMethod, logicalKeyPositions, name).             partitionedInput.setInput(input).             partitionedInput.setParallelism(getParallelism()).             partitionedInput.setDistribution(distribution).             partitionedInput.setCustomPartitioner(customPartitioner).             partitionedInput.setOrdering(computeOrdering(pKeys, orders)).             return partitionedInput.         } else if (pKeys instanceof Keys.SelectorFunctionKeys) {             @SuppressWarnings("unchecked")             Keys.SelectorFunctionKeys<T, ?> selectorKeys = (Keys.SelectorFunctionKeys<T, ?>) pKeys.             return translateSelectorFunctionPartitioner(selectorKeys, pMethod, name, input, getParallelism(), customPartitioner, orders).         } else {             throw new UnsupportedOperationException("Unrecognized key type.").         }     } else {         throw new UnsupportedOperationException("Unsupported partitioning method: " + pMethod.name()).     } }
false;private,static;2;22;;private static <T> Ordering computeOrdering(Keys<T> pKeys, Order[] orders) {     Ordering ordering = new Ordering().     final int[] logicalKeyPositions = pKeys.computeLogicalKeyPositions().     if (orders == null) {         for (int key : logicalKeyPositions) {             ordering.appendOrdering(key, null, Order.ASCENDING).         }     } else {         final TypeInformation<?>[] originalKeyFieldTypes = pKeys.getOriginalKeyFieldTypes().         int index = 0.         for (int i = 0. i < originalKeyFieldTypes.length. i++) {             final int typeTotalFields = originalKeyFieldTypes[i].getTotalFields().             for (int j = index. j < index + typeTotalFields. j++) {                 ordering.appendOrdering(logicalKeyPositions[j], null, orders[i]).             }             index += typeTotalFields.         }     }     return ordering. }
false;private,static;7;23;;@SuppressWarnings("unchecked") private static <T, K> org.apache.flink.api.common.operators.SingleInputOperator<?, T, ?> translateSelectorFunctionPartitioner(SelectorFunctionKeys<T, ?> rawKeys, PartitionMethod pMethod, String name, Operator<T> input, int partitionDop, Partitioner<?> customPartitioner, Order[] orders) {     final SelectorFunctionKeys<T, K> keys = (SelectorFunctionKeys<T, K>) rawKeys.     TypeInformation<Tuple2<K, T>> typeInfoWithKey = KeyFunctions.createTypeWithKey(keys).     Operator<Tuple2<K, T>> keyedInput = KeyFunctions.appendKeyExtractor(input, keys).     PartitionOperatorBase<Tuple2<K, T>> keyedPartitionedInput = new PartitionOperatorBase<>(new UnaryOperatorInformation<>(typeInfoWithKey, typeInfoWithKey), pMethod, new int[] { 0 }, name).     keyedPartitionedInput.setInput(keyedInput).     keyedPartitionedInput.setCustomPartitioner(customPartitioner).     keyedPartitionedInput.setParallelism(partitionDop).     keyedPartitionedInput.setOrdering(new Ordering(0, null, orders != null ? orders[0] : Order.ASCENDING)).     return KeyFunctions.appendKeyRemover(keyedPartitionedInput, keys). }
