commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Internal public OutputFormat<T> getFormat() {     return format. }
false;public;0;4;;@Internal public TypeInformation<T> getType() {     return type. }
false;public;0;4;;@Internal public DataSet<T> getDataSet() {     return data. }
true;public;1;4;/**  * Pass a configuration to the OutputFormat.  * @param parameters Configuration parameters  */ ;/**  * Pass a configuration to the OutputFormat.  * @param parameters Configuration parameters  */ public DataSink<T> withParameters(Configuration parameters) {     this.parameters = parameters.     return this. }
true;public;2;32;/**  * Sorts each local partition of a {@link org.apache.flink.api.java.tuple.Tuple} data set  * on the specified field in the specified {@link Order} before it is emitted by the output format.  *  * <p><b>Note: Only tuple data sets can be sorted using integer field indices.</b>  *  * <p>The tuple data set can be sorted on multiple fields in different orders  * by chaining {@link #sortLocalOutput(int, Order)} calls.  *  * @param field The Tuple field on which the data set is locally sorted.  * @param order The Order in which the specified Tuple field is locally sorted.  * @return This data sink operator with specified output order.  *  * @see org.apache.flink.api.java.tuple.Tuple  * @see Order  *  * @deprecated Use {@link DataSet#sortPartition(int, Order)} instead  */ ;/**  * Sorts each local partition of a {@link org.apache.flink.api.java.tuple.Tuple} data set  * on the specified field in the specified {@link Order} before it is emitted by the output format.  *  * <p><b>Note: Only tuple data sets can be sorted using integer field indices.</b>  *  * <p>The tuple data set can be sorted on multiple fields in different orders  * by chaining {@link #sortLocalOutput(int, Order)} calls.  *  * @param field The Tuple field on which the data set is locally sorted.  * @param order The Order in which the specified Tuple field is locally sorted.  * @return This data sink operator with specified output order.  *  * @see org.apache.flink.api.java.tuple.Tuple  * @see Order  *  * @deprecated Use {@link DataSet#sortPartition(int, Order)} instead  */ @Deprecated @PublicEvolving public DataSink<T> sortLocalOutput(int field, Order order) {     // get flat keys     Keys.ExpressionKeys<T> ek = new Keys.ExpressionKeys<>(field, this.type).     int[] flatKeys = ek.computeLogicalKeyPositions().     if (!Keys.ExpressionKeys.isSortKey(field, this.type)) {         throw new InvalidProgramException("Selected sort key is not a sortable type").     }     if (this.sortKeyPositions == null) {         // set sorting info         this.sortKeyPositions = flatKeys.         this.sortOrders = new Order[flatKeys.length].         Arrays.fill(this.sortOrders, order).     } else {         // append sorting info to exising info         int oldLength = this.sortKeyPositions.length.         int newLength = oldLength + flatKeys.length.         this.sortKeyPositions = Arrays.copyOf(this.sortKeyPositions, newLength).         this.sortOrders = Arrays.copyOf(this.sortOrders, newLength).         for (int i = 0. i < flatKeys.length. i++) {             this.sortKeyPositions[oldLength + i] = flatKeys[i].             this.sortOrders[oldLength + i] = order.         }     }     return this. }
true;public;2;38;/**  * Sorts each local partition of a data set on the field(s) specified by the field expression  * in the specified {@link Order} before it is emitted by the output format.  *  * <p><b>Note: Non-composite types can only be sorted on the full element which is specified by  * a wildcard expression ("*" or "_").</b>  *  * <p>Data sets of composite types (Tuple or Pojo) can be sorted on multiple fields in different orders  * by chaining {@link #sortLocalOutput(String, Order)} calls.  *  * @param fieldExpression The field expression for the field(s) on which the data set is locally sorted.  * @param order The Order in which the specified field(s) are locally sorted.  * @return This data sink operator with specified output order.  *  * @see Order  *  * @deprecated Use {@link DataSet#sortPartition(String, Order)} instead  */ ;/**  * Sorts each local partition of a data set on the field(s) specified by the field expression  * in the specified {@link Order} before it is emitted by the output format.  *  * <p><b>Note: Non-composite types can only be sorted on the full element which is specified by  * a wildcard expression ("*" or "_").</b>  *  * <p>Data sets of composite types (Tuple or Pojo) can be sorted on multiple fields in different orders  * by chaining {@link #sortLocalOutput(String, Order)} calls.  *  * @param fieldExpression The field expression for the field(s) on which the data set is locally sorted.  * @param order The Order in which the specified field(s) are locally sorted.  * @return This data sink operator with specified output order.  *  * @see Order  *  * @deprecated Use {@link DataSet#sortPartition(String, Order)} instead  */ @Deprecated @PublicEvolving public DataSink<T> sortLocalOutput(String fieldExpression, Order order) {     int numFields.     int[] fields.     Order[] orders.     // compute flat field positions for (nested) sorting fields     Keys.ExpressionKeys<T> ek = new Keys.ExpressionKeys<>(fieldExpression, this.type).     fields = ek.computeLogicalKeyPositions().     if (!Keys.ExpressionKeys.isSortKey(fieldExpression, this.type)) {         throw new InvalidProgramException("Selected sort key is not a sortable type").     }     numFields = fields.length.     orders = new Order[numFields].     Arrays.fill(orders, order).     if (this.sortKeyPositions == null) {         // set sorting info         this.sortKeyPositions = fields.         this.sortOrders = orders.     } else {         // append sorting info to existing info         int oldLength = this.sortKeyPositions.length.         int newLength = oldLength + numFields.         this.sortKeyPositions = Arrays.copyOf(this.sortKeyPositions, newLength).         this.sortOrders = Arrays.copyOf(this.sortOrders, newLength).         for (int i = 0. i < numFields. i++) {             this.sortKeyPositions[oldLength + i] = fields[i].             this.sortOrders[oldLength + i] = orders[i].         }     }     return this. }
true;public;0;3;/**  * @return Configuration for the OutputFormat.  */ ;/**  * @return Configuration for the OutputFormat.  */ public Configuration getParameters() {     return this.parameters. }
false;public;1;4;;// -------------------------------------------------------------------------------------------- public DataSink<T> name(String name) {     this.name = name.     return this. }
false;protected;1;30;;// -------------------------------------------------------------------------------------------- protected GenericDataSinkBase<T> translateToDataFlow(Operator<T> input) {     // select the name (or create a default one)     String name = this.name != null ? this.name : this.format.toString().     GenericDataSinkBase<T> sink = new GenericDataSinkBase<>(this.format, new UnaryOperatorInformation<>(this.type, new NothingTypeInfo()), name).     // set input     sink.setInput(input).     // set parameters     if (this.parameters != null) {         sink.getParameters().addAll(this.parameters).     }     // set parallelism     if (this.parallelism > 0) {         // use specified parallelism         sink.setParallelism(this.parallelism).     } else {         // if no parallelism has been specified, use parallelism of input operator to enable chaining         sink.setParallelism(input.getParallelism()).     }     if (this.sortKeyPositions != null) {         // configure output sorting         Ordering ordering = new Ordering().         for (int i = 0. i < this.sortKeyPositions.length. i++) {             ordering.appendOrdering(this.sortKeyPositions[i], null, this.sortOrders[i]).         }         sink.setLocalOrder(ordering).     }     return sink. }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public String toString() {     return "DataSink '" + (this.name == null ? "<unnamed>" : this.name) + "' (" + this.format.toString() + ")". }
true;public;0;3;/**  * Returns the parallelism of this data sink.  *  * @return The parallelism of this data sink.  */ ;/**  * Returns the parallelism of this data sink.  *  * @return The parallelism of this data sink.  */ public int getParallelism() {     return this.parallelism. }
true;public;1;8;/**  * Sets the parallelism for this data sink.  * The degree must be 1 or more.  *  * @param parallelism The parallelism for this data sink. A value equal to {@link ExecutionConfig#PARALLELISM_DEFAULT}  *        will use the system default.  * @return This data sink with set parallelism.  */ ;/**  * Sets the parallelism for this data sink.  * The degree must be 1 or more.  *  * @param parallelism The parallelism for this data sink. A value equal to {@link ExecutionConfig#PARALLELISM_DEFAULT}  *        will use the system default.  * @return This data sink with set parallelism.  */ public DataSink<T> setParallelism(int parallelism) {     Preconditions.checkArgument(parallelism > 0 || parallelism == ExecutionConfig.PARALLELISM_DEFAULT, "The parallelism of an operator must be at least 1.").     this.parallelism = parallelism.     return this. }
true;public;0;4;/**  * Returns the minimum resources of this data sink. If no minimum resources have been set,  * this returns the default resource profile.  *  * @return The minimum resources of this data sink.  */ ;/**  * Returns the minimum resources of this data sink. If no minimum resources have been set,  * this returns the default resource profile.  *  * @return The minimum resources of this data sink.  */ @PublicEvolving public ResourceSpec getMinResources() {     return this.minResources. }
true;public;0;4;/**  * Returns the preferred resources of this data sink. If no preferred resources have been set,  * this returns the default resource profile.  *  * @return The preferred resources of this data sink.  */ ;/**  * Returns the preferred resources of this data sink. If no preferred resources have been set,  * this returns the default resource profile.  *  * @return The preferred resources of this data sink.  */ @PublicEvolving public ResourceSpec getPreferredResources() {     return this.preferredResources. }
true;private;2;11;/**  * Sets the minimum and preferred resources for this data sink. and the lower and upper resource limits  * will be considered in resource resize feature for future plan.  *  * @param minResources The minimum resources for this data sink.  * @param preferredResources The preferred resources for this data sink.  * @return The data sink with set minimum and preferred resources.  */ ;// --------------------------------------------------------------------------- // Fine-grained resource profiles are an incomplete work-in-progress feature // The setters are hence private at this point. // --------------------------------------------------------------------------- /**  * Sets the minimum and preferred resources for this data sink. and the lower and upper resource limits  * will be considered in resource resize feature for future plan.  *  * @param minResources The minimum resources for this data sink.  * @param preferredResources The preferred resources for this data sink.  * @return The data sink with set minimum and preferred resources.  */ private DataSink<T> setResources(ResourceSpec minResources, ResourceSpec preferredResources) {     Preconditions.checkNotNull(minResources, "The min resources must be not null.").     Preconditions.checkNotNull(preferredResources, "The preferred resources must be not null.").     Preconditions.checkArgument(minResources.isValid() && preferredResources.isValid() && minResources.lessThanOrEqual(preferredResources), "The values in resources must be not less than 0 and the preferred resources must be greater than the min resources.").     this.minResources = minResources.     this.preferredResources = preferredResources.     return this. }
true;private;1;9;/**  * Sets the resources for this data sink, and the minimum and preferred resources are the same by default.  *  * @param resources The resources for this data sink.  * @return The data sink with set minimum and preferred resources.  */ ;/**  * Sets the resources for this data sink, and the minimum and preferred resources are the same by default.  *  * @param resources The resources for this data sink.  * @return The data sink with set minimum and preferred resources.  */ private DataSink<T> setResources(ResourceSpec resources) {     Preconditions.checkNotNull(resources, "The resources must be not null.").     Preconditions.checkArgument(resources.isValid(), "The values in resources must be not less than 0.").     this.minResources = resources.     this.preferredResources = resources.     return this. }
