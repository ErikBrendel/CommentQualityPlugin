commented;modifiers;parameterAmount;loc;comment;code
true;public;1;25;/**  * Add a value to the current aggregation.  */ ;/**  * Add a value to the current aggregation.  */ @Override public void aggregate(T value) {     if (value == null) {         nullCount++.     } else if (isNan(value)) {         nanCount++.     } else if (isInfinite(value)) {         infinityCount++.     } else {         nonMissingCount++.         min.aggregate(value).         max.aggregate(value).         sum.aggregate(value).         double doubleValue = value.doubleValue().         double delta = doubleValue - mean.value().         mean = mean.add(delta / nonMissingCount).         m2 = m2.add(delta * (doubleValue - mean.value())).     } }
true;public;1;33;/**  * combine two aggregations.  */ ;/**  * combine two aggregations.  */ @Override public void combine(Aggregator<T, NumericColumnSummary<T>> otherSameType) {     NumericSummaryAggregator<T> other = (NumericSummaryAggregator<T>) otherSameType.     nullCount += other.nullCount.     nanCount += other.nanCount.     infinityCount += other.infinityCount.     if (nonMissingCount == 0) {         nonMissingCount = other.nonMissingCount.         min = other.min.         max = other.max.         sum = other.sum.         mean = other.mean.         m2 = other.m2.     } else if (other.nonMissingCount != 0) {         long combinedCount = nonMissingCount + other.nonMissingCount.         min.combine(other.min).         max.combine(other.max).         sum.combine(other.sum).         double deltaMean = other.mean.value() - mean.value().         mean = mean.add(deltaMean * other.nonMissingCount / combinedCount).         m2 = m2.add(other.m2).add(deltaMean * deltaMean * nonMissingCount * other.nonMissingCount / combinedCount).         nonMissingCount = combinedCount.     } }
false;public;0;22;;@Override public NumericColumnSummary<T> result() {     Double variance = null.     if (nonMissingCount > 1) {         variance = m2.value() / (nonMissingCount - 1).     }     return new NumericColumnSummary<T>(nonMissingCount, nullCount, nanCount, infinityCount, // if nonMissingCount was zero some fields should be undefined     nonMissingCount == 0 ? null : min.result(), nonMissingCount == 0 ? null : max.result(), nonMissingCount == 0 ? null : sum.result(), nonMissingCount == 0 ? null : mean.value(), variance, // standard deviation     variance == null ? null : Math.sqrt(variance)). }
false;protected,abstract;0;1;;// there isn't a generic way to calculate min, max, sum, isNan, isInfinite for all numeric types // so subclasses must implement these protected abstract Aggregator<T, T> initMin().
false;protected,abstract;0;1;;protected abstract Aggregator<T, T> initMax().
false;protected,abstract;0;1;;protected abstract Aggregator<T, T> initSum().
false;protected,abstract;1;1;;protected abstract boolean isNan(T number).
false;protected,abstract;1;1;;protected abstract boolean isInfinite(T number).
