commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public int getState() {     return state. }
false;public;1;3;;public void setState(int state) {     this.state = state. }
false;public;0;3;;public boolean isUdfBinary() {     return isBinary. }
false;public;0;3;;public boolean isIteratorTrueAssumptionApplied() {     return iteratorTrueAssumptionApplied. }
false;public;0;3;;public void applyIteratorTrueAssumption() {     iteratorTrueAssumptionApplied = true. }
false;public;1;6;;public void incrNewOperationCounters(boolean topLevel) {     newOperationCounterOverall++.     if (topLevel) {         newOperationCounterTopLevel++.     } }
false;public;0;3;;public boolean hasUdfCollector() {     return hasCollector. }
false;public;0;3;;public boolean hasUdfIterableInput() {     return isIterableInput. }
false;public;0;3;;public boolean isUdfReduceFunction() {     return isReduceFunction. }
false;public;0;3;;public String getInternalUdfClassName() {     return internalUdfClassName. }
false;public;0;3;;public List<TaggedValue> getCollectorValues() {     return collectorValues. }
false;public;0;73;;public boolean analyze() throws CodeAnalyzerException {     if (state == STATE_END_OF_ANALYZING) {         throw new IllegalStateException("Analyzing is already done.").     }     boolean discardReturnValues = false.     if (isIterableInput) {         if (keys1 == null || (keys2 == null && isBinary)) {             throw new IllegalArgumentException("This type of function requires key information for analysis.").         } else if (!(keys1 instanceof ExpressionKeys) || (!(keys2 instanceof ExpressionKeys) && isBinary)) {             // TODO currently only ExpressionKeys are supported as keys             discardReturnValues = true.         }     }     try {         final Object[] mn = findMethodNode(internalUdfClassName, baseClassMethod).         final NestedMethodAnalyzer nma = new NestedMethodAnalyzer(this, (String) mn[1], (MethodNode) mn[0], null, MAX_NESTING, true).         final TaggedValue result = nma.analyze().         setState(STATE_END_OF_ANALYZING).         // special case: FilterFunction         if (isFilterFunction) {             discardReturnValues = true.             // check for input modification             if (!filterInputCopy.equals(filterInputRef)) {                 addHintOrThrowException("Function modifies the input. This can lead to unexpected behaviour during runtime.").             }         }         if (!discardReturnValues) {             // merge return values of a collector             if (hasCollector) {                 returnValue = mergeReturnValues(collectorValues).             } else {                 returnValue = result.             }             // or is a reduce function             if ((isIterableInput || isReduceFunction) && returnValue != null) {                 if (returnValue.canContainFields()) {                     removeUngroupedInputsFromContainer(returnValue).                 } else if (returnValue.isInput() && !returnValue.isGrouped()) {                     returnValue = null.                 }             }         } else // any return value is invalid         {             returnValue = null.         }     } catch (Exception e) {         Throwable cause = e.getCause().         while (cause != null && !(cause instanceof CodeErrorException)) {             cause = cause.getCause().         }         if (cause instanceof CodeErrorException || e instanceof CodeErrorException) {             throw new CodeErrorException("Function code contains obvious errors. " + "If you think the code analysis is wrong at this point you can " + "disable the entire code analyzer in ExecutionConfig or add" + " @SkipCodeAnalysis to your function to disable the analysis.", (cause != null) ? cause : e).         }         throw new CodeAnalyzerException("Exception occurred during code analysis.", e).     }     return true. }
false;public;0;33;;public SemanticProperties getSemanticProperties() {     final SemanticProperties sp.     if (isBinary) {         sp = new DualInputSemanticProperties().         if (returnValue != null) {             String[] ff1Array = null.             final String ff1 = returnValue.toForwardedFieldsExpression(Input.INPUT_1).             if (ff1 != null && ff1.length() > 0) {                 ff1Array = new String[] { ff1 }.             }             String[] ff2Array = null.             final String ff2 = returnValue.toForwardedFieldsExpression(Input.INPUT_2).             if (ff2 != null && ff2.length() > 0) {                 ff2Array = new String[] { ff2 }.             }             SemanticPropUtil.getSemanticPropsDualFromString((DualInputSemanticProperties) sp, ff1Array, ff2Array, null, null, null, null, in1Type, in2Type, outType, true).         }     } else {         sp = new SingleInputSemanticProperties().         if (returnValue != null) {             String[] ffArray = null.             final String ff = returnValue.toForwardedFieldsExpression(Input.INPUT_1).             if (ff != null && ff.length() > 0) {                 ffArray = new String[] { ff }.             }             SemanticPropUtil.getSemanticPropsSingleFromString((SingleInputSemanticProperties) sp, ffArray, null, null, in1Type, outType, true).         }     }     return sp. }
false;public;0;29;;public void addSemanticPropertiesHints() {     boolean added = false.     if (returnValue != null) {         if (isBinary) {             final String ff1 = returnValue.toForwardedFieldsExpression(Input.INPUT_1).             if (ff1 != null && ff1.length() > 0) {                 added = true.                 hints.add("Possible annotation: " + "@ForwardedFieldsFirst(\"" + ff1 + "\")").             }             final String ff2 = returnValue.toForwardedFieldsExpression(Input.INPUT_2).             if (ff2 != null && ff2.length() > 0) {                 added = true.                 hints.add("Possible annotation: " + "@ForwardedFieldsSecond(\"" + ff2 + "\")").             }         } else {             final String ff = returnValue.toForwardedFieldsExpression(Input.INPUT_1).             if (ff != null && ff.length() > 0) {                 added = true.                 hints.add("Possible annotation: " + "@ForwardedFields(\"" + ff + "\")").             }         }     }     if (!added) {         hints.add("Possible annotations: none.").     } }
false;public;1;18;;public void printToLogger(Logger log) {     StringBuilder sb = new StringBuilder().     sb.append("Code analysis result for '" + externalUdfName + " (" + udfClass.getName() + ")':").     sb.append("\nNumber of object creations: " + newOperationCounterTopLevel + " in method / " + newOperationCounterOverall + " transitively").     for (String hint : hints) {         sb.append('\n').         sb.append(hint).     }     if (warning) {         log.warn(sb.toString()).     } else {         log.info(sb.toString()).     } }
false;public;0;16;;public TaggedValue getInput1AsTaggedValue() {     final int[] groupedKeys.     if (keys1 != null) {         groupedKeys = keys1.computeLogicalKeyPositions().     } else {         groupedKeys = null.     }     final TaggedValue input1 = convertTypeInfoToTaggedValue(Input.INPUT_1, in1Type, "", null, groupedKeys).     // store the input and a copy of it to check for modification afterwards     if (isFilterFunction) {         filterInputRef = input1.         filterInputCopy = input1.copy().     }     return input1. }
false;public;0;10;;public TaggedValue getInput2AsTaggedValue() {     final int[] groupedKeys.     if (keys2 != null) {         groupedKeys = keys2.computeLogicalKeyPositions().     } else {         groupedKeys = null.     }     return convertTypeInfoToTaggedValue(Input.INPUT_2, in2Type, "", null, groupedKeys). }
false;private;1;9;;private void addHintOrThrowException(String msg) {     if (throwErrorExceptions) {         throw new CodeErrorException(externalUdfName + ": " + msg).     } else {         warning = true.         hints.add(msg).     } }
false;public;0;3;;public void handleNullReturn() {     addHintOrThrowException("Function returns 'null' values. This can lead to errors during runtime."). }
false;public;0;3;;public void handlePutStatic() {     addHintOrThrowException("Function modifies static fields. This can lead to unexpected behaviour during runtime."). }
false;public;0;3;;public void handleInvalidTupleAccess() {     addHintOrThrowException("Function contains tuple accesses with invalid indexes. This can lead to errors during runtime."). }
