commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;42;/**  * Tries to clean the closure of the given object, if the object is a non-static inner  * class.  *  * @param func The object whose closure should be cleaned.  * @param checkSerializable Flag to indicate whether serializability should be checked after  *                          the closure cleaning attempt.  *  * @throws InvalidProgramException Thrown, if 'checkSerializable' is true, and the object was  *                                 not serializable after the closure cleaning.  *  * @throws RuntimeException A RuntimeException may be thrown, if the code of the class could not  *                          be loaded, in order to process during the closure cleaning.  */ ;/**  * Tries to clean the closure of the given object, if the object is a non-static inner  * class.  *  * @param func The object whose closure should be cleaned.  * @param checkSerializable Flag to indicate whether serializability should be checked after  *                          the closure cleaning attempt.  *  * @throws InvalidProgramException Thrown, if 'checkSerializable' is true, and the object was  *                                 not serializable after the closure cleaning.  *  * @throws RuntimeException A RuntimeException may be thrown, if the code of the class could not  *                          be loaded, in order to process during the closure cleaning.  */ public static void clean(Object func, boolean checkSerializable) {     if (func == null) {         return.     }     final Class<?> cls = func.getClass().     // First find the field name of the "this$0" field, this can     // be "this$x" depending on the nesting     boolean closureAccessed = false.     for (Field f : cls.getDeclaredFields()) {         if (f.getName().startsWith("this$")) {             // found a closure referencing field - now try to clean             closureAccessed |= cleanThis0(func, cls, f.getName()).         }     }     if (checkSerializable) {         try {             InstantiationUtil.serializeObject(func).         } catch (Exception e) {             String functionType = getSuperClassOrInterfaceName(func.getClass()).             String msg = functionType == null ? (func + " is not serializable.") : ("The implementation of the " + functionType + " is not serializable.").             if (closureAccessed) {                 msg += " The implementation accesses fields of its enclosing class, which is " + "a common reason for non-serializability. " + "A common solution is to make the function a proper (non-inner) class, or " + "a static inner class.".             } else {                 msg += " The object probably contains or references non serializable fields.".             }             throw new InvalidProgramException(msg, e).         }     } }
false;public,static;1;7;;public static void ensureSerializable(Object obj) {     try {         InstantiationUtil.serializeObject(obj).     } catch (Exception e) {         throw new InvalidProgramException("Object " + obj + " is not serializable", e).     } }
false;private,static;3;32;;private static boolean cleanThis0(Object func, Class<?> cls, String this0Name) {     This0AccessFinder this0Finder = new This0AccessFinder(this0Name).     getClassReader(cls).accept(this0Finder, 0).     final boolean accessesClosure = this0Finder.isThis0Accessed().     if (LOG.isDebugEnabled()) {         LOG.debug(this0Name + " is accessed: " + accessesClosure).     }     if (!accessesClosure) {         Field this0.         try {             this0 = func.getClass().getDeclaredField(this0Name).         } catch (NoSuchFieldException e) {             // has no this$0, just return             throw new RuntimeException("Could not set " + this0Name + ": " + e).         }         try {             this0.setAccessible(true).             this0.set(func, null).         } catch (Exception e) {             // should not happen, since we use setAccessible             throw new RuntimeException("Could not set " + this0Name + " to null. " + e.getMessage(), e).         }     }     return accessesClosure. }
false;private,static;1;8;;private static ClassReader getClassReader(Class<?> cls) {     String className = cls.getName().replaceFirst("^.*\\.", "") + ".class".     try {         return new ClassReader(cls.getResourceAsStream(className)).     } catch (IOException e) {         throw new RuntimeException("Could not create ClassReader: " + e.getMessage(), e).     } }
false;private,static;1;13;;private static String getSuperClassOrInterfaceName(Class<?> cls) {     Class<?> superclass = cls.getSuperclass().     if (superclass.getName().startsWith("org.apache.flink")) {         return superclass.getSimpleName().     } else {         for (Class<?> inFace : cls.getInterfaces()) {             if (inFace.getName().startsWith("org.apache.flink")) {                 return inFace.getSimpleName().             }         }         return null.     } }
false;public;0;3;;public boolean isThis0Accessed() {     return isThis0Accessed. }
false;public;4;6;;@Override public void visitFieldInsn(int op, String owner, String name, String desc) {     if (op == Opcodes.GETFIELD && name.equals(this0Name)) {         isThis0Accessed = true.     } }
false;public;5;12;;@Override public MethodVisitor visitMethod(int access, String name, String desc, String sig, String[] exceptions) {     return new MethodVisitor(Opcodes.ASM5) {          @Override         public void visitFieldInsn(int op, String owner, String name, String desc) {             if (op == Opcodes.GETFIELD && name.equals(this0Name)) {                 isThis0Accessed = true.             }         }     }. }
