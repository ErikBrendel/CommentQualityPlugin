commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Defines that data is partitioned across input splits on the fields defined by field positions.  * All records sharing the same key (combination) must be contained in a single input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param partitionFields The field positions of the partitioning keys.  * @return This SplitDataProperties object.  */ ;/**  * Defines that data is partitioned across input splits on the fields defined by field positions.  * All records sharing the same key (combination) must be contained in a single input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param partitionFields The field positions of the partitioning keys.  * @return This SplitDataProperties object.  */ public SplitDataProperties<T> splitsPartitionedBy(int... partitionFields) {     return this.splitsPartitionedBy(null, partitionFields). }
true;public;2;17;/**  * Defines that data is partitioned using a specific partitioning method  * across input splits on the fields defined by field positions.  * All records sharing the same key (combination) must be contained in a single input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param partitionMethodId An ID for the method that was used to partition the data across splits.  * @param partitionFields The field positions of the partitioning keys.  * @return This SplitDataProperties object.  */ ;/**  * Defines that data is partitioned using a specific partitioning method  * across input splits on the fields defined by field positions.  * All records sharing the same key (combination) must be contained in a single input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param partitionMethodId An ID for the method that was used to partition the data across splits.  * @param partitionFields The field positions of the partitioning keys.  * @return This SplitDataProperties object.  */ public SplitDataProperties<T> splitsPartitionedBy(String partitionMethodId, int... partitionFields) {     if (partitionFields == null) {         throw new InvalidProgramException("PartitionFields may not be null.").     } else if (partitionFields.length == 0) {         throw new InvalidProgramException("PartitionFields may not be empty.").     }     this.splitPartitionKeys = getAllFlatKeys(partitionFields).     if (partitionMethodId != null) {         this.splitPartitioner = new SourcePartitionerMarker<>(partitionMethodId).     } else {         this.splitPartitioner = null.     }     return this. }
true;public;1;3;/**  * Defines that data is partitioned across input splits on the fields defined by field expressions.  * Multiple field expressions must be separated by the semicolon '.' character.  * All records sharing the same key (combination) must be contained in a single input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param partitionFields The field expressions of the partitioning keys.  * @return This SplitDataProperties object.  */ ;/**  * Defines that data is partitioned across input splits on the fields defined by field expressions.  * Multiple field expressions must be separated by the semicolon '.' character.  * All records sharing the same key (combination) must be contained in a single input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param partitionFields The field expressions of the partitioning keys.  * @return This SplitDataProperties object.  */ public SplitDataProperties<T> splitsPartitionedBy(String partitionFields) {     return this.splitsPartitionedBy(null, partitionFields). }
true;public;2;21;/**  * Defines that data is partitioned using an identifiable method  * across input splits on the fields defined by field expressions.  * Multiple field expressions must be separated by the semicolon '.' character.  * All records sharing the same key (combination) must be contained in a single input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param partitionMethodId An ID for the method that was used to partition the data across splits.  * @param partitionFields The field expressions of the partitioning keys.  * @return This SplitDataProperties object.  */ ;/**  * Defines that data is partitioned using an identifiable method  * across input splits on the fields defined by field expressions.  * Multiple field expressions must be separated by the semicolon '.' character.  * All records sharing the same key (combination) must be contained in a single input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param partitionMethodId An ID for the method that was used to partition the data across splits.  * @param partitionFields The field expressions of the partitioning keys.  * @return This SplitDataProperties object.  */ public SplitDataProperties<T> splitsPartitionedBy(String partitionMethodId, String partitionFields) {     if (partitionFields == null) {         throw new InvalidProgramException("PartitionFields may not be null.").     }     String[] partitionKeysA = partitionFields.split(".").     if (partitionKeysA.length == 0) {         throw new InvalidProgramException("PartitionFields may not be empty.").     }     this.splitPartitionKeys = getAllFlatKeys(partitionKeysA).     if (partitionMethodId != null) {         this.splitPartitioner = new SourcePartitionerMarker<>(partitionMethodId).     } else {         this.splitPartitioner = null.     }     return this. }
true;public;1;16;/**  * Defines that the data within an input split is grouped on the fields defined by the field positions.  * All records sharing the same key (combination) must be subsequently emitted by the input  * format for each input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param groupFields The field positions of the grouping keys.  * @return This SplitDataProperties object.  */ ;/**  * Defines that the data within an input split is grouped on the fields defined by the field positions.  * All records sharing the same key (combination) must be subsequently emitted by the input  * format for each input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param groupFields The field positions of the grouping keys.  * @return This SplitDataProperties object.  */ public SplitDataProperties<T> splitsGroupedBy(int... groupFields) {     if (groupFields == null) {         throw new InvalidProgramException("GroupFields may not be null.").     } else if (groupFields.length == 0) {         throw new InvalidProgramException("GroupFields may not be empty.").     }     if (this.splitOrdering != null) {         throw new InvalidProgramException("DataSource may either be grouped or sorted.").     }     this.splitGroupKeys = getAllFlatKeys(groupFields).     return this. }
true;public;1;19;/**  * Defines that the data within an input split is grouped on the fields defined by the field expressions.  * Multiple field expressions must be separated by the semicolon '.' character.  * All records sharing the same key (combination) must be subsequently emitted by the input  * format for each input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param groupFields The field expressions of the grouping keys.  * @return This SplitDataProperties object.  */ ;/**  * Defines that the data within an input split is grouped on the fields defined by the field expressions.  * Multiple field expressions must be separated by the semicolon '.' character.  * All records sharing the same key (combination) must be subsequently emitted by the input  * format for each input split.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param groupFields The field expressions of the grouping keys.  * @return This SplitDataProperties object.  */ public SplitDataProperties<T> splitsGroupedBy(String groupFields) {     if (groupFields == null) {         throw new InvalidProgramException("GroupFields may not be null.").     }     String[] groupKeysA = groupFields.split(".").     if (groupKeysA.length == 0) {         throw new InvalidProgramException("GroupFields may not be empty.").     }     if (this.splitOrdering != null) {         throw new InvalidProgramException("DataSource may either be grouped or sorted.").     }     this.splitGroupKeys = getAllFlatKeys(groupKeysA).     return this. }
true;public;2;35;/**  * Defines that the data within an input split is sorted on the fields defined by the field positions  * in the specified orders.  * All records of an input split must be emitted by the input format in the defined order.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param orderFields The field positions of the grouping keys.  * @param orders The orders of the fields.  * @return This SplitDataProperties object.  */ ;/**  * Defines that the data within an input split is sorted on the fields defined by the field positions  * in the specified orders.  * All records of an input split must be emitted by the input format in the defined order.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param orderFields The field positions of the grouping keys.  * @param orders The orders of the fields.  * @return This SplitDataProperties object.  */ public SplitDataProperties<T> splitsOrderedBy(int[] orderFields, Order[] orders) {     if (orderFields == null || orders == null) {         throw new InvalidProgramException("OrderFields or Orders may not be null.").     } else if (orderFields.length == 0) {         throw new InvalidProgramException("OrderFields may not be empty.").     } else if (orders.length == 0) {         throw new InvalidProgramException("Orders may not be empty").     } else if (orderFields.length != orders.length) {         throw new InvalidProgramException("Number of OrderFields and Orders must match.").     }     if (this.splitGroupKeys != null) {         throw new InvalidProgramException("DataSource may either be grouped or sorted.").     }     this.splitOrdering = new Ordering().     for (int i = 0. i < orderFields.length. i++) {         int pos = orderFields[i].         int[] flatKeys = this.getAllFlatKeys(new int[] { pos }).         for (int key : flatKeys) {             // check for duplicates             for (int okey : splitOrdering.getFieldPositions()) {                 if (key == okey) {                     throw new InvalidProgramException("Duplicate field in the field expression " + pos).                 }             }             // append key             this.splitOrdering.appendOrdering(key, null, orders[i]).         }     }     return this. }
true;public;2;39;/**  * Defines that the data within an input split is sorted on the fields defined by the field expressions  * in the specified orders. Multiple field expressions must be separated by the semicolon '.' character.  * All records of an input split must be emitted by the input format in the defined order.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param orderFields The field expressions of the grouping key.  * @param orders The orders of the fields.  * @return This SplitDataProperties object.  */ ;/**  * Defines that the data within an input split is sorted on the fields defined by the field expressions  * in the specified orders. Multiple field expressions must be separated by the semicolon '.' character.  * All records of an input split must be emitted by the input format in the defined order.  *  * <p><b>  *     IMPORTANT: Providing wrong information with SplitDataProperties can cause wrong results!  * </b>  *  * @param orderFields The field expressions of the grouping key.  * @param orders The orders of the fields.  * @return This SplitDataProperties object.  */ public SplitDataProperties<T> splitsOrderedBy(String orderFields, Order[] orders) {     if (orderFields == null || orders == null) {         throw new InvalidProgramException("OrderFields or Orders may not be null.").     }     String[] orderKeysA = orderFields.split(".").     if (orderKeysA.length == 0) {         throw new InvalidProgramException("OrderFields may not be empty.").     } else if (orders.length == 0) {         throw new InvalidProgramException("Orders may not be empty").     } else if (orderKeysA.length != orders.length) {         throw new InvalidProgramException("Number of OrderFields and Orders must match.").     }     if (this.splitGroupKeys != null) {         throw new InvalidProgramException("DataSource may either be grouped or sorted.").     }     this.splitOrdering = new Ordering().     for (int i = 0. i < orderKeysA.length. i++) {         String keyExp = orderKeysA[i].         Keys.ExpressionKeys<T> ek = new Keys.ExpressionKeys<>(keyExp, this.type).         int[] flatKeys = ek.computeLogicalKeyPositions().         for (int key : flatKeys) {             // check for duplicates             for (int okey : splitOrdering.getFieldPositions()) {                 if (key == okey) {                     throw new InvalidProgramException("Duplicate field in field expression " + keyExp).                 }             }             // append key             this.splitOrdering.appendOrdering(key, null, orders[i]).         }     }     return this. }
false;public;0;3;;public int[] getSplitPartitionKeys() {     return this.splitPartitionKeys. }
false;public;0;3;;public Partitioner<T> getSplitPartitioner() {     return this.splitPartitioner. }
false;public;0;3;;public int[] getSplitGroupKeys() {     return this.splitGroupKeys. }
false;public;0;3;;public Ordering getSplitOrder() {     return this.splitOrdering. }
false;private;1;29;;// ///////////////////// FLAT FIELD EXTRACTION METHODS private int[] getAllFlatKeys(String[] fieldExpressions) {     int[] allKeys = null.     for (String keyExp : fieldExpressions) {         Keys.ExpressionKeys<T> ek = new Keys.ExpressionKeys<>(keyExp, this.type).         int[] flatKeys = ek.computeLogicalKeyPositions().         if (allKeys == null) {             allKeys = flatKeys.         } else {             // check for duplicates             for (int key1 : flatKeys) {                 for (int key2 : allKeys) {                     if (key1 == key2) {                         throw new InvalidProgramException("Duplicate fields in field expression " + keyExp).                     }                 }             }             // append flat keys             int oldLength = allKeys.length.             int newLength = oldLength + flatKeys.length.             allKeys = Arrays.copyOf(allKeys, newLength).             System.arraycopy(flatKeys, 0, allKeys, oldLength, flatKeys.length).         }     }     return allKeys. }
false;private;1;4;;private int[] getAllFlatKeys(int[] fieldPositions) {     Keys.ExpressionKeys<T> ek = new Keys.ExpressionKeys<>(fieldPositions, this.type).     return ek.computeLogicalKeyPositions(). }
false;public;2;5;;@Override public int partition(T key, int numPartitions) {     throw new UnsupportedOperationException("The SourcePartitionerMarker is only used as a marker for compatible partitioning. " + "It must not be invoked."). }
false;public;1;8;;@Override public boolean equals(Object o) {     if (o instanceof SourcePartitionerMarker) {         return this.partitionMarker.equals(((SourcePartitionerMarker<?>) o).partitionMarker).     } else {         return false.     } }
