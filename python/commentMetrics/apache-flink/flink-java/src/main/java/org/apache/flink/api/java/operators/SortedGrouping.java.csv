commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;// -------------------------------------------------------------------------------------------- protected int[] getGroupSortKeyPositions() {     return this.groupSortKeyPositions. }
false;protected;0;3;;protected Order[] getGroupSortOrders() {     return this.groupSortOrders. }
false;protected;0;9;;protected Ordering getGroupOrdering() {     Ordering o = new Ordering().     for (int i = 0. i < this.groupSortKeyPositions.length. i++) {         o.appendOrdering(this.groupSortKeyPositions[i], null, this.groupSortOrders[i]).     }     return o. }
true;public;1;8;/**  * Uses a custom partitioner for the grouping.  *  * @param partitioner The custom partitioner.  * @return The grouping object itself, to allow for method chaining.  */ ;/**  * Uses a custom partitioner for the grouping.  *  * @param partitioner The custom partitioner.  * @return The grouping object itself, to allow for method chaining.  */ public SortedGrouping<T> withPartitioner(Partitioner<?> partitioner) {     Preconditions.checkNotNull(partitioner).     getKeys().validateCustomPartitioner(partitioner, null).     this.customPartitioner = partitioner.     return this. }
false;protected;0;3;;protected Keys.SelectorFunctionKeys<T, ?> getSortSelectionFunctionKey() {     return this.groupSortSelectorFunctionKey. }
true;public;1;8;/**  * Applies a GroupReduce transformation on a grouped and sorted {@link DataSet}.  *  * <p>The transformation calls a {@link org.apache.flink.api.common.functions.RichGroupReduceFunction} for each group of the DataSet.  * A GroupReduceFunction can iterate over all elements of a group and emit any  *   number of output elements including none.  *  * @param reducer The GroupReduceFunction that is applied on each group of the DataSet.  * @return A GroupReduceOperator that represents the reduced DataSet.  *  * @see org.apache.flink.api.common.functions.RichGroupReduceFunction  * @see GroupReduceOperator  * @see DataSet  */ ;/**  * Applies a GroupReduce transformation on a grouped and sorted {@link DataSet}.  *  * <p>The transformation calls a {@link org.apache.flink.api.common.functions.RichGroupReduceFunction} for each group of the DataSet.  * A GroupReduceFunction can iterate over all elements of a group and emit any  *   number of output elements including none.  *  * @param reducer The GroupReduceFunction that is applied on each group of the DataSet.  * @return A GroupReduceOperator that represents the reduced DataSet.  *  * @see org.apache.flink.api.common.functions.RichGroupReduceFunction  * @see GroupReduceOperator  * @see DataSet  */ public <R> GroupReduceOperator<T, R> reduceGroup(GroupReduceFunction<T, R> reducer) {     if (reducer == null) {         throw new NullPointerException("GroupReduce function must not be null.").     }     TypeInformation<R> resultType = TypeExtractor.getGroupReduceReturnTypes(reducer, inputDataSet.getType(), Utils.getCallLocationName(), true).     return new GroupReduceOperator<>(this, resultType, inputDataSet.clean(reducer), Utils.getCallLocationName()). }
true;public;1;9;/**  * Applies a GroupCombineFunction on a grouped {@link DataSet}.  * A CombineFunction is similar to a GroupReduceFunction but does not perform a full data exchange. Instead, the  * CombineFunction calls the combine method once per partition for combining a group of results. This  * operator is suitable for combining values into an intermediate format before doing a proper groupReduce where  * the data is shuffled across the node for further reduction. The GroupReduce operator can also be supplied with  * a combiner by implementing the RichGroupReduce function. The combine method of the RichGroupReduce function  * demands input and output type to be the same. The CombineFunction, on the other side, can have an arbitrary  * output type.  * @param combiner The GroupCombineFunction that is applied on the DataSet.  * @return A GroupCombineOperator which represents the combined DataSet.  */ ;/**  * Applies a GroupCombineFunction on a grouped {@link DataSet}.  * A CombineFunction is similar to a GroupReduceFunction but does not perform a full data exchange. Instead, the  * CombineFunction calls the combine method once per partition for combining a group of results. This  * operator is suitable for combining values into an intermediate format before doing a proper groupReduce where  * the data is shuffled across the node for further reduction. The GroupReduce operator can also be supplied with  * a combiner by implementing the RichGroupReduce function. The combine method of the RichGroupReduce function  * demands input and output type to be the same. The CombineFunction, on the other side, can have an arbitrary  * output type.  * @param combiner The GroupCombineFunction that is applied on the DataSet.  * @return A GroupCombineOperator which represents the combined DataSet.  */ public <R> GroupCombineOperator<T, R> combineGroup(GroupCombineFunction<T, R> combiner) {     if (combiner == null) {         throw new NullPointerException("GroupCombine function must not be null.").     }     TypeInformation<R> resultType = TypeExtractor.getGroupCombineReturnTypes(combiner, this.getInputDataSet().getType(), Utils.getCallLocationName(), true).     return new GroupCombineOperator<>(this, resultType, inputDataSet.clean(combiner), Utils.getCallLocationName()). }
true;public;1;7;/**  * Returns a new set containing the first n elements in this grouped and sorted {@link DataSet}.  * @param n The desired number of elements for each group.  * @return A GroupReduceOperator that represents the DataSet containing the elements.  */ ;/**  * Returns a new set containing the first n elements in this grouped and sorted {@link DataSet}.  * @param n The desired number of elements for each group.  * @return A GroupReduceOperator that represents the DataSet containing the elements.  */ public GroupReduceOperator<T, T> first(int n) {     if (n < 1) {         throw new InvalidProgramException("Parameter n of first(n) must be at least 1.").     }     return reduceGroup(new FirstReducer<T>(n)). }
true;public;2;13;/**  * Sorts {@link org.apache.flink.api.java.tuple.Tuple} elements within a group on the specified field in the specified {@link Order}.  *  * <p><b>Note: Only groups of Tuple or Pojo elements can be sorted.</b>  *  * <p>Groups can be sorted by multiple fields by chaining {@link #sortGroup(int, Order)} calls.  *  * @param field The Tuple field on which the group is sorted.  * @param order The Order in which the specified Tuple field is sorted.  * @return A SortedGrouping with specified order of group element.  *  * @see org.apache.flink.api.java.tuple.Tuple  * @see Order  */ ;// -------------------------------------------------------------------------------------------- // Group Operations // -------------------------------------------------------------------------------------------- /**  * Sorts {@link org.apache.flink.api.java.tuple.Tuple} elements within a group on the specified field in the specified {@link Order}.  *  * <p><b>Note: Only groups of Tuple or Pojo elements can be sorted.</b>  *  * <p>Groups can be sorted by multiple fields by chaining {@link #sortGroup(int, Order)} calls.  *  * @param field The Tuple field on which the group is sorted.  * @param order The Order in which the specified Tuple field is sorted.  * @return A SortedGrouping with specified order of group element.  *  * @see org.apache.flink.api.java.tuple.Tuple  * @see Order  */ public SortedGrouping<T> sortGroup(int field, Order order) {     if (groupSortSelectorFunctionKey != null) {         throw new InvalidProgramException("Chaining sortGroup with KeySelector sorting is not supported").     }     if (!Keys.ExpressionKeys.isSortKey(field, inputDataSet.getType())) {         throw new InvalidProgramException("Selected sort key is not a sortable type").     }     ExpressionKeys<T> ek = new ExpressionKeys<>(field, inputDataSet.getType()).     addSortGroupInternal(ek, order).     return this. }
true;public;2;13;/**  * Sorts {@link org.apache.flink.api.java.tuple.Tuple} or POJO elements within a group on the specified field in the specified {@link Order}.  *  * <p><b>Note: Only groups of Tuple or Pojo elements can be sorted.</b>  *  * <p>Groups can be sorted by multiple fields by chaining {@link #sortGroup(String, Order)} calls.  *  * @param field The Tuple or Pojo field on which the group is sorted.  * @param order The Order in which the specified field is sorted.  * @return A SortedGrouping with specified order of group element.  *  * @see org.apache.flink.api.java.tuple.Tuple  * @see Order  */ ;/**  * Sorts {@link org.apache.flink.api.java.tuple.Tuple} or POJO elements within a group on the specified field in the specified {@link Order}.  *  * <p><b>Note: Only groups of Tuple or Pojo elements can be sorted.</b>  *  * <p>Groups can be sorted by multiple fields by chaining {@link #sortGroup(String, Order)} calls.  *  * @param field The Tuple or Pojo field on which the group is sorted.  * @param order The Order in which the specified field is sorted.  * @return A SortedGrouping with specified order of group element.  *  * @see org.apache.flink.api.java.tuple.Tuple  * @see Order  */ public SortedGrouping<T> sortGroup(String field, Order order) {     if (groupSortSelectorFunctionKey != null) {         throw new InvalidProgramException("Chaining sortGroup with KeySelector sorting is not supported").     }     if (!Keys.ExpressionKeys.isSortKey(field, inputDataSet.getType())) {         throw new InvalidProgramException("Selected sort key is not a sortable type").     }     ExpressionKeys<T> ek = new ExpressionKeys<>(field, inputDataSet.getType()).     addSortGroupInternal(ek, order).     return this. }
false;private;2;14;;private void addSortGroupInternal(ExpressionKeys<T> ek, Order order) {     Preconditions.checkArgument(order != null, "Order can not be null").     int[] additionalKeyPositions = ek.computeLogicalKeyPositions().     int newLength = this.groupSortKeyPositions.length + additionalKeyPositions.length.     this.groupSortKeyPositions = Arrays.copyOf(this.groupSortKeyPositions, newLength).     this.groupSortOrders = Arrays.copyOf(this.groupSortOrders, newLength).     int pos = newLength - additionalKeyPositions.length.     int off = newLength - additionalKeyPositions.length.     for (. pos < newLength. pos++) {         this.groupSortKeyPositions[pos] = additionalKeyPositions[pos - off].         // use the same order         this.groupSortOrders[pos] = order.     } }
