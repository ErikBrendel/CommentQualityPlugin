commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;7;;private static Class<?>[] extractTypeClasses(TypeInformation[] fieldTypes) {     Class<?>[] classes = new Class<?>[fieldTypes.length].     for (int i = 0. i < fieldTypes.length. i++) {         classes[i] = fieldTypes[i].getTypeClass().     }     return classes. }
false;private,static;1;7;;private static int[] sequentialScanOrder(int arity) {     int[] sequentialOrder = new int[arity].     for (int i = 0. i < arity. i++) {         sequentialOrder[i] = i.     }     return sequentialOrder. }
false;private,static;1;13;;private static boolean[] toFieldMask(int[] selectedFields) {     int maxField = 0.     for (int selectedField : selectedFields) {         maxField = Math.max(maxField, selectedField).     }     boolean[] mask = new boolean[maxField + 1].     Arrays.fill(mask, false).     for (int selectedField : selectedFields) {         mask[selectedField] = true.     }     return mask. }
false;private,static;1;12;;private static int[] toFieldPosMap(int[] selectedFields) {     int[] fieldIdxs = Arrays.copyOf(selectedFields, selectedFields.length).     Arrays.sort(fieldIdxs).     int[] fieldPosMap = new int[selectedFields.length].     for (int i = 0. i < selectedFields.length. i++) {         int pos = Arrays.binarySearch(fieldIdxs, selectedFields[i]).         fieldPosMap[pos] = i.     }     return fieldPosMap. }
false;protected;2;13;;@Override protected Row fillRecord(Row reuse, Object[] parsedValues) {     Row reuseRow.     if (reuse == null) {         reuseRow = new Row(arity).     } else {         reuseRow = reuse.     }     for (int i = 0. i < parsedValues.length. i++) {         reuseRow.setField(i, parsedValues[i]).     }     return reuseRow. }
false;protected;4;76;;@Override protected boolean parseRecord(Object[] holders, byte[] bytes, int offset, int numBytes) throws ParseException {     byte[] fieldDelimiter = this.getFieldDelimiter().     boolean[] fieldIncluded = this.fieldIncluded.     int startPos = offset.     int limit = offset + numBytes.     int field = 0.     int output = 0.     while (field < fieldIncluded.length) {         // check valid start position         if (startPos > limit || (startPos == limit && field != fieldIncluded.length - 1)) {             if (isLenient()) {                 return false.             } else {                 throw new ParseException("Row too short: " + new String(bytes, offset, numBytes, getCharset())).             }         }         if (fieldIncluded[field]) {             // parse field             FieldParser<Object> parser = (FieldParser<Object>) this.getFieldParsers()[fieldPosMap[output]].             int latestValidPos = startPos.             startPos = parser.resetErrorStateAndParse(bytes, startPos, limit, fieldDelimiter, holders[fieldPosMap[output]]).             if (!isLenient() && (parser.getErrorState() != FieldParser.ParseErrorState.NONE)) {                 // the error state EMPTY_COLUMN is ignored                 if (parser.getErrorState() != FieldParser.ParseErrorState.EMPTY_COLUMN) {                     throw new ParseException(String.format("Parsing error for column %1$s of row '%2$s' originated by %3$s: %4$s.", field + 1, new String(bytes, offset, numBytes), parser.getClass().getSimpleName(), parser.getErrorState())).                 }             }             holders[fieldPosMap[output]] = parser.getLastResult().             // or empty with emptyColumnAsNull enabled             if (startPos < 0 || (emptyColumnAsNull && (parser.getErrorState().equals(FieldParser.ParseErrorState.EMPTY_COLUMN)))) {                 holders[fieldPosMap[output]] = null.                 startPos = skipFields(bytes, latestValidPos, limit, fieldDelimiter).             }             output++.         } else {             // skip field             startPos = skipFields(bytes, startPos, limit, fieldDelimiter).         }         // check if something went wrong         if (startPos < 0) {             throw new ParseException(String.format("Unexpected parser position for column %1$s of row '%2$s'", field + 1, new String(bytes, offset, numBytes))).         } else if (startPos == limit && field != fieldIncluded.length - 1 && !FieldParser.endsWithDelimiter(bytes, startPos - 1, fieldDelimiter)) {             // and the end is not a field delimiter indicating an empty last field.             if (isLenient()) {                 return false.             } else {                 throw new ParseException("Row too short: " + new String(bytes, offset, numBytes)).             }         }         field++.     }     return true. }
false;public;0;4;;@Override public TypeInformation<Row> getProducedType() {     return new RowTypeInfo(this.fieldTypeInfos). }
