commented;modifiers;parameterAmount;loc;comment;code
false;private;5;33;;private void configure(String lineDelimiter, String fieldDelimiter, PojoTypeInfo<OUT> pojoTypeInfo, String[] fieldNames, boolean[] includedFieldsMask) {     if (includedFieldsMask == null) {         includedFieldsMask = createDefaultMask(fieldNames.length).     }     for (String name : fieldNames) {         if (name == null) {             throw new NullPointerException("Field name must not be null.").         }         if (pojoTypeInfo.getFieldIndex(name) < 0) {             throw new IllegalArgumentException("Field \"" + name + "\" not part of POJO type " + pojoTypeInfo.getTypeClass().getCanonicalName()).         }     }     setDelimiter(lineDelimiter).     setFieldDelimiter(fieldDelimiter).     Class<?>[] classes = new Class<?>[fieldNames.length].     for (int i = 0. i < fieldNames.length. i++) {         try {             classes[i] = pojoTypeInfo.getTypeAt(pojoTypeInfo.getFieldIndex(fieldNames[i])).getTypeClass().         } catch (IndexOutOfBoundsException e) {             throw new IllegalArgumentException("Invalid field name: " + fieldNames[i]).         }     }     this.pojoTypeClass = pojoTypeInfo.getTypeClass().     this.pojoTypeInfo = pojoTypeInfo.     setFieldsGeneric(includedFieldsMask, classes).     setOrderOfPOJOFields(fieldNames). }
false;private;1;21;;private void setOrderOfPOJOFields(String[] fieldNames) {     Preconditions.checkNotNull(fieldNames).     int includedCount = 0.     for (boolean isIncluded : fieldIncluded) {         if (isIncluded) {             includedCount++.         }     }     Preconditions.checkArgument(includedCount == fieldNames.length, includedCount + " CSV fields and " + fieldNames.length + " POJO fields selected. The number of selected CSV and POJO fields must be equal.").     for (String field : fieldNames) {         Preconditions.checkNotNull(field, "The field name cannot be null.").         Preconditions.checkArgument(pojoTypeInfo.getFieldIndex(field) != -1, "Field \"" + field + "\" is not a member of POJO class " + pojoTypeClass.getName()).     }     pojoFieldNames = Arrays.copyOfRange(fieldNames, 0, fieldNames.length). }
false;public;1;20;;@Override public void open(FileInputSplit split) throws IOException {     super.open(split).     pojoFields = new Field[pojoFieldNames.length].     Map<String, Field> allFields = new HashMap<String, Field>().     findAllFields(pojoTypeClass, allFields).     for (int i = 0. i < pojoFieldNames.length. i++) {         pojoFields[i] = allFields.get(pojoFieldNames[i]).         if (pojoFields[i] != null) {             pojoFields[i].setAccessible(true).         } else {             throw new RuntimeException("There is no field called \"" + pojoFieldNames[i] + "\" in " + pojoTypeClass.getName()).         }     } }
true;private;2;9;/**  * Finds all declared fields in a class and all its super classes.  *  * @param clazz Class for which all declared fields are found  * @param allFields Map containing all found fields so far  */ ;/**  * Finds all declared fields in a class and all its super classes.  *  * @param clazz Class for which all declared fields are found  * @param allFields Map containing all found fields so far  */ private void findAllFields(Class<?> clazz, Map<String, Field> allFields) {     for (Field field : clazz.getDeclaredFields()) {         allFields.put(field.getName(), field).     }     if (clazz.getSuperclass() != null) {         findAllFields(clazz.getSuperclass(), allFields).     } }
false;public;2;11;;@Override public OUT fillRecord(OUT reuse, Object[] parsedValues) {     for (int i = 0. i < parsedValues.length. i++) {         try {             pojoFields[i].set(reuse, parsedValues[i]).         } catch (IllegalAccessException e) {             throw new RuntimeException("Parsed value could not be set in POJO field \"" + pojoFieldNames[i] + "\"", e).         }     }     return reuse. }
