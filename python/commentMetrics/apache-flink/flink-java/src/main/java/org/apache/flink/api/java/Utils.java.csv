commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;3;;public static String getCallLocationName() {     return getCallLocationName(4). }
false;public,static;1;11;;public static String getCallLocationName(int depth) {     StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace().     if (stackTrace.length <= depth) {         return "<unknown>".     }     StackTraceElement elem = stackTrace[depth].     return String.format("%s(%s:%d)", elem.getMethodName(), elem.getFileName(), elem.getLineNumber()). }
false;public;1;2;;@Override public void configure(Configuration parameters) { }
false;public;2;2;;@Override public void open(int taskNumber, int numTasks) { }
false;public;1;4;;@Override public void writeRecord(T record) {     counter++. }
false;public;0;4;;@Override public void close() {     getRuntimeContext().getLongCounter(id).add(counter). }
false;public;1;2;;@Override public void configure(Configuration parameters) { }
false;public;2;4;;@Override public void open(int taskNumber, int numTasks) {     this.accumulator = new SerializedListAccumulator<>(). }
false;public;1;4;;@Override public void writeRecord(T record) throws IOException {     accumulator.add(record, serializer). }
false;public;0;5;;@Override public void close() {     // Important: should only be added in close method to minimize traffic of accumulators     getRuntimeContext().addAccumulator(id, accumulator). }
false;public;0;3;;public long getCount() {     return count. }
false;public;0;3;;public long getChecksum() {     return checksum. }
false;public;1;5;;@Override public void add(ChecksumHashCode value) {     this.count += value.count.     this.checksum += value.checksum. }
false;public;0;4;;@Override public ChecksumHashCode getLocalValue() {     return this. }
false;public;0;5;;@Override public void resetLocal() {     this.count = 0.     this.checksum = 0. }
false;public;1;4;;@Override public void merge(Accumulator<ChecksumHashCode, ChecksumHashCode> other) {     this.add(other.getLocalValue()). }
false;public;0;4;;@Override public ChecksumHashCode clone() {     return new ChecksumHashCode(count, checksum). }
false;public;1;9;;@Override public boolean equals(Object obj) {     if (obj instanceof ChecksumHashCode) {         ChecksumHashCode other = (ChecksumHashCode) obj.         return this.count == other.count && this.checksum == other.checksum.     } else {         return false.     } }
false;public;0;4;;@Override public int hashCode() {     return (int) (this.count + this.checksum). }
false;public;0;4;;@Override public String toString() {     return String.format("ChecksumHashCode 0x%016x, count %d", this.checksum, this.count). }
false;public;1;2;;@Override public void configure(Configuration parameters) { }
false;public;2;2;;@Override public void open(int taskNumber, int numTasks) { }
false;public;1;6;;@Override public void writeRecord(T record) throws IOException {     counter++.     // convert 32-bit integer to non-negative long     checksum += record.hashCode() & 0xffffffffL. }
false;public;0;5;;@Override public void close() throws IOException {     ChecksumHashCode update = new ChecksumHashCode(counter, checksum).     getRuntimeContext().addAccumulator(id, update). }
true;public,static;1;3;/**  * Debugging utility to understand the hierarchy of serializers created by the Java API.  * Tested in GroupReduceITCase.testGroupByGenericType()  */ ;// -------------------------------------------------------------------------------------------- /**  * Debugging utility to understand the hierarchy of serializers created by the Java API.  * Tested in GroupReduceITCase.testGroupByGenericType()  */ public static <T> String getSerializerTree(TypeInformation<T> ti) {     return getSerializerTree(ti, 0). }
false;private,static;2;20;;private static <T> String getSerializerTree(TypeInformation<T> ti, int indent) {     String ret = "".     if (ti instanceof CompositeType) {         ret += StringUtils.repeat(' ', indent) + ti.getClass().getSimpleName() + "\n".         CompositeType<T> cti = (CompositeType<T>) ti.         String[] fieldNames = cti.getFieldNames().         for (int i = 0. i < cti.getArity(). i++) {             TypeInformation<?> fieldType = cti.getTypeAt(i).             ret += StringUtils.repeat(' ', indent + 2) + fieldNames[i] + ":" + getSerializerTree(fieldType, indent).         }     } else {         if (ti instanceof GenericTypeInfo) {             ret += StringUtils.repeat(' ', indent) + "GenericTypeInfo (" + ti.getTypeClass().getSimpleName() + ")\n".             ret += getGenericTypeTree(ti.getTypeClass(), indent + 4).         } else {             ret += StringUtils.repeat(' ', indent) + ti.toString() + "\n".         }     }     return ret. }
false;private,static;2;14;;private static String getGenericTypeTree(Class<?> type, int indent) {     String ret = "".     for (Field field : type.getDeclaredFields()) {         if (Modifier.isStatic(field.getModifiers()) || Modifier.isTransient(field.getModifiers())) {             continue.         }         ret += StringUtils.repeat(' ', indent) + field.getName() + ":" + field.getType().getName() + (field.getType().isEnum() ? " (is enum)" : "") + "\n".         if (!field.getType().isPrimitive()) {             ret += getGenericTypeTree(field.getType(), indent + 4).         }     }     return ret. }
