commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Continues a Join transformation.  *  * <p>Defines the {@link Tuple} fields of the first join {@link DataSet} that should be used as join keys.  *  * <p><b>Note: Fields can only be selected as join keys on Tuple DataSets.</b>  *  * @param fields The indexes of the other Tuple fields of the first join DataSets that should be used as keys.  * @return An incomplete Join transformation.  *           Call {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(int...)} or  *           {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(KeySelector)}  *           to continue the Join.  *  * @see Tuple  * @see DataSet  */ ;/**  * Continues a Join transformation.  *  * <p>Defines the {@link Tuple} fields of the first join {@link DataSet} that should be used as join keys.  *  * <p><b>Note: Fields can only be selected as join keys on Tuple DataSets.</b>  *  * @param fields The indexes of the other Tuple fields of the first join DataSets that should be used as keys.  * @return An incomplete Join transformation.  *           Call {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(int...)} or  *           {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(KeySelector)}  *           to continue the Join.  *  * @see Tuple  * @see DataSet  */ public JoinOperatorSetsPredicateBase where(int... fields) {     return new JoinOperatorSetsPredicateBase(new Keys.ExpressionKeys<>(fields, input1.getType())). }
true;public;1;3;/**  * Continues a Join transformation.  *  * <p>Defines the fields of the first join {@link DataSet} that should be used as grouping keys. Fields  * are the names of member fields of the underlying type of the data set.  *  * @param fields The  fields of the first join DataSets that should be used as keys.  * @return An incomplete Join transformation.  *           Call {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(int...)} or  *           {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(KeySelector)}  *           to continue the Join.  *  * @see Tuple  * @see DataSet  */ ;/**  * Continues a Join transformation.  *  * <p>Defines the fields of the first join {@link DataSet} that should be used as grouping keys. Fields  * are the names of member fields of the underlying type of the data set.  *  * @param fields The  fields of the first join DataSets that should be used as keys.  * @return An incomplete Join transformation.  *           Call {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(int...)} or  *           {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(KeySelector)}  *           to continue the Join.  *  * @see Tuple  * @see DataSet  */ public JoinOperatorSetsPredicateBase where(String... fields) {     return new JoinOperatorSetsPredicateBase(new Keys.ExpressionKeys<>(fields, input1.getType())). }
true;public;1;4;/**  * Continues a Join transformation and defines a {@link KeySelector} function for the first join {@link DataSet}.  *  * <p>The KeySelector function is called for each element of the first DataSet and extracts a single  * key value on which the DataSet is joined.  *  * @param keySelector The KeySelector function which extracts the key values from the DataSet on which it is joined.  * @return An incomplete Join transformation.  *           Call {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(int...)} or  *           {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(KeySelector)}  *           to continue the Join.  *  * @see KeySelector  * @see DataSet  */ ;/**  * Continues a Join transformation and defines a {@link KeySelector} function for the first join {@link DataSet}.  *  * <p>The KeySelector function is called for each element of the first DataSet and extracts a single  * key value on which the DataSet is joined.  *  * @param keySelector The KeySelector function which extracts the key values from the DataSet on which it is joined.  * @return An incomplete Join transformation.  *           Call {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(int...)} or  *           {@link org.apache.flink.api.java.operators.join.JoinOperatorSetsBase.JoinOperatorSetsPredicateBase#equalTo(KeySelector)}  *           to continue the Join.  *  * @see KeySelector  * @see DataSet  */ public <K> JoinOperatorSetsPredicateBase where(KeySelector<I1, K> keySelector) {     TypeInformation<K> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input1.getType()).     return new JoinOperatorSetsPredicateBase(new Keys.SelectorFunctionKeys<>(keySelector, input1.getType(), keyType)). }
true;public;1;3;/**  * Continues a Join transformation and defines the {@link Tuple} fields of the second join  * {@link DataSet} that should be used as join keys.  *  * <p><b>Note: Fields can only be selected as join keys on Tuple DataSets.</b>  *  * <p>The resulting {@link JoinFunctionAssigner} needs to be finished by providing a  * {@link JoinFunction} by calling {@link JoinFunctionAssigner#with(JoinFunction)}  *  * @param fields The indexes of the Tuple fields of the second join DataSet that should be used as keys.  * @return A JoinFunctionAssigner.  */ ;/**  * Continues a Join transformation and defines the {@link Tuple} fields of the second join  * {@link DataSet} that should be used as join keys.  *  * <p><b>Note: Fields can only be selected as join keys on Tuple DataSets.</b>  *  * <p>The resulting {@link JoinFunctionAssigner} needs to be finished by providing a  * {@link JoinFunction} by calling {@link JoinFunctionAssigner#with(JoinFunction)}  *  * @param fields The indexes of the Tuple fields of the second join DataSet that should be used as keys.  * @return A JoinFunctionAssigner.  */ public JoinFunctionAssigner<I1, I2> equalTo(int... fields) {     return createJoinFunctionAssigner(new Keys.ExpressionKeys<>(fields, input2.getType())). }
true;public;1;3;/**  * Continues a Join transformation and defines the fields of the second join  * {@link DataSet} that should be used as join keys.  *  * <p>The resulting {@link JoinFunctionAssigner} needs to be finished by providing a  * {@link JoinFunction} by calling {@link JoinFunctionAssigner#with(JoinFunction)}  *  * @param fields The fields of the second join DataSet that should be used as keys.  * @return A JoinFunctionAssigner.  */ ;/**  * Continues a Join transformation and defines the fields of the second join  * {@link DataSet} that should be used as join keys.  *  * <p>The resulting {@link JoinFunctionAssigner} needs to be finished by providing a  * {@link JoinFunction} by calling {@link JoinFunctionAssigner#with(JoinFunction)}  *  * @param fields The fields of the second join DataSet that should be used as keys.  * @return A JoinFunctionAssigner.  */ public JoinFunctionAssigner<I1, I2> equalTo(String... fields) {     return createJoinFunctionAssigner(new Keys.ExpressionKeys<>(fields, input2.getType())). }
true;public;1;4;/**  * Continues a Join transformation and defines a {@link KeySelector} function for the second join {@link DataSet}.  *  * <p>The KeySelector function is called for each element of the second DataSet and extracts a single  * key value on which the DataSet is joined.  *  * <p>The resulting {@link JoinFunctionAssigner} needs to be finished by providing a  * {@link JoinFunction} by calling {@link JoinFunctionAssigner#with(JoinFunction)}  *  * @param keySelector The KeySelector function which extracts the key values from the second DataSet on which it is joined.  * @return A JoinFunctionAssigner.  */ ;/**  * Continues a Join transformation and defines a {@link KeySelector} function for the second join {@link DataSet}.  *  * <p>The KeySelector function is called for each element of the second DataSet and extracts a single  * key value on which the DataSet is joined.  *  * <p>The resulting {@link JoinFunctionAssigner} needs to be finished by providing a  * {@link JoinFunction} by calling {@link JoinFunctionAssigner#with(JoinFunction)}  *  * @param keySelector The KeySelector function which extracts the key values from the second DataSet on which it is joined.  * @return A JoinFunctionAssigner.  */ public <K> JoinFunctionAssigner<I1, I2> equalTo(KeySelector<I2, K> keySelector) {     TypeInformation<K> keyType = TypeExtractor.getKeySelectorTypes(keySelector, input2.getType()).     return createJoinFunctionAssigner(new Keys.SelectorFunctionKeys<>(keySelector, input2.getType(), keyType)). }
false;protected;1;4;;protected JoinFunctionAssigner<I1, I2> createJoinFunctionAssigner(Keys<I2> keys2) {     DefaultJoin<I1, I2> join = createDefaultJoin(keys2).     return new DefaultJoinFunctionAssigner(join). }
false;protected;1;16;;protected DefaultJoin<I1, I2> createDefaultJoin(Keys<I2> keys2) {     if (keys2 == null) {         throw new NullPointerException("The join keys may not be null.").     }     if (keys2.isEmpty()) {         throw new InvalidProgramException("The join keys may not be empty.").     }     try {         keys1.areCompatible(keys2).     } catch (Keys.IncompatibleKeysException e) {         throw new InvalidProgramException("The pair of join keys are not compatible with each other.", e).     }     return new DefaultJoin<>(input1, input2, keys1, keys2, joinHint, Utils.getCallLocationName(4), joinType). }
false;public;1;3;;public <R> EquiJoin<I1, I2, R> with(JoinFunction<I1, I2, R> joinFunction) {     return defaultJoin.with(joinFunction). }
false;public;1;3;;public <R> EquiJoin<I1, I2, R> with(FlatJoinFunction<I1, I2, R> joinFunction) {     return defaultJoin.with(joinFunction). }
