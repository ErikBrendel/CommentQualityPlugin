commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns whether using key selector or not.  */ ;/**  * Returns whether using key selector or not.  */ public boolean useKeySelector() {     return useKeySelector. }
true;public;2;11;/**  * Appends an additional sort order with the specified field in the specified order to the  * local partition sorting of the DataSet.  *  * @param field The field index of the additional sort order of the local partition sorting.  * @param order The order of the additional sort order of the local partition sorting.  * @return The DataSet with sorted local partitions.  */ ;/**  * Appends an additional sort order with the specified field in the specified order to the  * local partition sorting of the DataSet.  *  * @param field The field index of the additional sort order of the local partition sorting.  * @param order The order of the additional sort order of the local partition sorting.  * @return The DataSet with sorted local partitions.  */ public SortPartitionOperator<T> sortPartition(int field, Order order) {     if (useKeySelector) {         throw new InvalidProgramException("Expression keys cannot be appended after a KeySelector").     }     ensureSortableKey(field).     keys.add(new Keys.ExpressionKeys<>(field, getType())).     orders.add(order).     return this. }
true;public;2;11;/**  * Appends an additional sort order with the specified field in the specified order to the  * local partition sorting of the DataSet.  *  * @param field The field expression referring to the field of the additional sort order of  *              the local partition sorting.  * @param order The order of the additional sort order of the local partition sorting.  * @return The DataSet with sorted local partitions.  */ ;/**  * Appends an additional sort order with the specified field in the specified order to the  * local partition sorting of the DataSet.  *  * @param field The field expression referring to the field of the additional sort order of  *              the local partition sorting.  * @param order The order of the additional sort order of the local partition sorting.  * @return The DataSet with sorted local partitions.  */ public SortPartitionOperator<T> sortPartition(String field, Order order) {     if (useKeySelector) {         throw new InvalidProgramException("Expression keys cannot be appended after a KeySelector").     }     ensureSortableKey(field).     keys.add(new Keys.ExpressionKeys<>(field, getType())).     orders.add(order).     return this. }
false;public;2;3;;public <K> SortPartitionOperator<T> sortPartition(KeySelector<T, K> keyExtractor, Order order) {     throw new InvalidProgramException("KeySelector cannot be chained."). }
false;private;1;5;;private void ensureSortableKey(int field) throws InvalidProgramException {     if (!Keys.ExpressionKeys.isSortKey(field, getType())) {         throw new InvalidProgramException("Selected sort key is not a sortable type").     } }
false;private;1;5;;private void ensureSortableKey(String field) throws InvalidProgramException {     if (!Keys.ExpressionKeys.isSortKey(field, getType())) {         throw new InvalidProgramException("Selected sort key is not a sortable type").     } }
false;private;1;5;;private <K> void ensureSortableKey(Keys.SelectorFunctionKeys<T, K> sortKey) {     if (!sortKey.getKeyType().isSortKeyType()) {         throw new InvalidProgramException("Selected sort key is not a sortable type").     } }
false;protected;1;41;;// -------------------------------------------------------------------------------------------- // Translation // -------------------------------------------------------------------------------------------- protected org.apache.flink.api.common.operators.SingleInputOperator<?, T, ?> translateToDataFlow(Operator<T> input) {     String name = "Sort at " + sortLocationName.     if (useKeySelector) {         return translateToDataFlowWithKeyExtractor(input, (Keys.SelectorFunctionKeys<T, ?>) keys.get(0), orders.get(0), name).     }     // flatten sort key positions     List<Integer> allKeyPositions = new ArrayList<>().     List<Order> allOrders = new ArrayList<>().     for (int i = 0, length = keys.size(). i < length. i++) {         int[] sortKeyPositions = keys.get(i).computeLogicalKeyPositions().         Order order = orders.get(i).         for (int sortKeyPosition : sortKeyPositions) {             allKeyPositions.add(sortKeyPosition).             allOrders.add(order).         }     }     Ordering partitionOrdering = new Ordering().     for (int i = 0, length = allKeyPositions.size(). i < length. i++) {         partitionOrdering.appendOrdering(allKeyPositions.get(i), null, allOrders.get(i)).     }     // distinguish between partition types     UnaryOperatorInformation<T, T> operatorInfo = new UnaryOperatorInformation<>(getType(), getType()).     SortPartitionOperatorBase<T> noop = new SortPartitionOperatorBase<>(operatorInfo, partitionOrdering, name).     noop.setInput(input).     if (this.getParallelism() < 0) {         // use parallelism of input if not explicitly specified         noop.setParallelism(input.getParallelism()).     } else {         // use explicitly specified parallelism         noop.setParallelism(this.getParallelism()).     }     return noop. }
false;private;4;27;;private <K> org.apache.flink.api.common.operators.SingleInputOperator<?, T, ?> translateToDataFlowWithKeyExtractor(Operator<T> input, Keys.SelectorFunctionKeys<T, K> keys, Order order, String name) {     TypeInformation<Tuple2<K, T>> typeInfoWithKey = KeyFunctions.createTypeWithKey(keys).     Keys.ExpressionKeys<Tuple2<K, T>> newKey = new Keys.ExpressionKeys<>(0, typeInfoWithKey).     Operator<Tuple2<K, T>> keyedInput = KeyFunctions.appendKeyExtractor(input, keys).     int[] sortKeyPositions = newKey.computeLogicalKeyPositions().     Ordering partitionOrdering = new Ordering().     for (int keyPosition : sortKeyPositions) {         partitionOrdering.appendOrdering(keyPosition, null, order).     }     // distinguish between partition types     UnaryOperatorInformation<Tuple2<K, T>, Tuple2<K, T>> operatorInfo = new UnaryOperatorInformation<>(typeInfoWithKey, typeInfoWithKey).     SortPartitionOperatorBase<Tuple2<K, T>> noop = new SortPartitionOperatorBase<>(operatorInfo, partitionOrdering, name).     noop.setInput(keyedInput).     if (this.getParallelism() < 0) {         // use parallelism of input if not explicitly specified         noop.setParallelism(input.getParallelism()).     } else {         // use explicitly specified parallelism         noop.setParallelism(this.getParallelism()).     }     return KeyFunctions.appendKeyRemover(noop, keys). }
