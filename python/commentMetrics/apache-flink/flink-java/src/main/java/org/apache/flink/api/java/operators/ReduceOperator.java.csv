commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected ReduceFunction<IN> getFunction() {     return function. }
false;public;0;20;;@Override @Internal public SingleInputSemanticProperties getSemanticProperties() {     SingleInputSemanticProperties props = super.getSemanticProperties().     // offset semantic information by extracted key fields     if (props != null && this.grouper != null && this.grouper.keys instanceof SelectorFunctionKeys) {         int offset = ((SelectorFunctionKeys<?, ?>) this.grouper.keys).getKeyType().getTotalFields().         if (this.grouper instanceof SortedGrouping) {             offset += ((SortedGrouping<?>) this.grouper).getSortSelectionFunctionKey().getKeyType().getTotalFields().         }         props = SemanticPropUtil.addSourceFieldOffset(props, this.getInputType().getTotalFields(), offset).     }     return props. }
false;protected;1;51;;@Override protected org.apache.flink.api.common.operators.SingleInputOperator<?, IN, ?> translateToDataFlow(Operator<IN> input) {     String name = getName() != null ? getName() : "Reduce at " + defaultName.     // distinguish between grouped reduce and non-grouped reduce     if (grouper == null) {         // non grouped reduce         UnaryOperatorInformation<IN, IN> operatorInfo = new UnaryOperatorInformation<>(getInputType(), getInputType()).         ReduceOperatorBase<IN, ReduceFunction<IN>> po = new ReduceOperatorBase<>(function, operatorInfo, new int[0], name).         po.setInput(input).         // the parallelism for a non grouped reduce can only be 1         po.setParallelism(1).         return po.     }     if (grouper.getKeys() instanceof SelectorFunctionKeys) {         // reduce with key selector function         @SuppressWarnings("unchecked")         SelectorFunctionKeys<IN, ?> selectorKeys = (SelectorFunctionKeys<IN, ?>) grouper.getKeys().         org.apache.flink.api.common.operators.SingleInputOperator<?, IN, ?> po = translateSelectorFunctionReducer(selectorKeys, function, getInputType(), name, input, getParallelism(), hint).         ((PlanUnwrappingReduceOperator<?, ?>) po.getInput()).setCustomPartitioner(grouper.getCustomPartitioner()).         return po.     } else if (grouper.getKeys() instanceof Keys.ExpressionKeys) {         // reduce with field positions         int[] logicalKeyPositions = grouper.getKeys().computeLogicalKeyPositions().         UnaryOperatorInformation<IN, IN> operatorInfo = new UnaryOperatorInformation<>(getInputType(), getInputType()).         ReduceOperatorBase<IN, ReduceFunction<IN>> po = new ReduceOperatorBase<>(function, operatorInfo, logicalKeyPositions, name).         po.setCustomPartitioner(grouper.getCustomPartitioner()).         po.setInput(input).         po.setParallelism(getParallelism()).         po.setCombineHint(hint).         return po.     } else {         throw new UnsupportedOperationException("Unrecognized key type.").     } }
true;public;1;5;/**  * Sets the strategy to use for the combine phase of the reduce.  *  * <p>If this method is not called, then the default hint will be used.  * ({@link org.apache.flink.api.common.operators.base.ReduceOperatorBase.CombineHint#OPTIMIZER_CHOOSES})  *  * @param strategy The hint to use.  * @return The ReduceOperator object, for function call chaining.  */ ;/**  * Sets the strategy to use for the combine phase of the reduce.  *  * <p>If this method is not called, then the default hint will be used.  * ({@link org.apache.flink.api.common.operators.base.ReduceOperatorBase.CombineHint#OPTIMIZER_CHOOSES})  *  * @param strategy The hint to use.  * @return The ReduceOperator object, for function call chaining.  */ @PublicEvolving public ReduceOperator<IN> setCombineHint(CombineHint strategy) {     this.hint = strategy.     return this. }
false;private,static;7;21;;// -------------------------------------------------------------------------------------------- private static <T, K> org.apache.flink.api.common.operators.SingleInputOperator<?, T, ?> translateSelectorFunctionReducer(SelectorFunctionKeys<T, ?> rawKeys, ReduceFunction<T> function, TypeInformation<T> inputType, String name, Operator<T> input, int parallelism, CombineHint hint) {     @SuppressWarnings("unchecked")     final SelectorFunctionKeys<T, K> keys = (SelectorFunctionKeys<T, K>) rawKeys.     TypeInformation<Tuple2<K, T>> typeInfoWithKey = KeyFunctions.createTypeWithKey(keys).     Operator<Tuple2<K, T>> keyedInput = KeyFunctions.appendKeyExtractor(input, keys).     PlanUnwrappingReduceOperator<T, K> reducer = new PlanUnwrappingReduceOperator<>(function, keys, name, inputType, typeInfoWithKey).     reducer.setInput(keyedInput).     reducer.setParallelism(parallelism).     reducer.setCombineHint(hint).     return KeyFunctions.appendKeyRemover(reducer, keys). }
