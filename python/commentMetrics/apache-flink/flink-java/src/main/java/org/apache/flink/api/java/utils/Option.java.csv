commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Define an alternative / short name of the parameter.  * Only one alternative per parameter is allowed.  *  * @param shortName - short version of the parameter name  * @return the updated Option  */ ;/**  * Define an alternative / short name of the parameter.  * Only one alternative per parameter is allowed.  *  * @param shortName - short version of the parameter name  * @return the updated Option  */ public Option alt(String shortName) {     this.shortName = shortName.     return this. }
true;public;1;4;/**  * Define the type of the Option.  *  * @param type - the type which the value of the Option can be casted to.  * @return the updated Option  */ ;/**  * Define the type of the Option.  *  * @param type - the type which the value of the Option can be casted to.  * @return the updated Option  */ public Option type(OptionType type) {     this.type = type.     return this. }
true;public;1;12;/**  * Define a default value for the option.  *  * @param defaultValue - the default value  * @return the updated Option  * @throws RequiredParametersException if the list of possible values for the parameter is not empty and the default  *                                     value passed is not in the list.  */ ;/**  * Define a default value for the option.  *  * @param defaultValue - the default value  * @return the updated Option  * @throws RequiredParametersException if the list of possible values for the parameter is not empty and the default  *                                     value passed is not in the list.  */ public Option defaultValue(String defaultValue) throws RequiredParametersException {     if (this.choices.isEmpty()) {         return this.setDefaultValue(defaultValue).     } else {         if (this.choices.contains(defaultValue)) {             return this.setDefaultValue(defaultValue).         } else {             throw new RequiredParametersException("Default value " + defaultValue + " is not in the list of valid values for option " + this.longName).         }     } }
true;public;1;13;/**  * Restrict the list of possible values of the parameter.  *  * @param choices - the allowed values of the parameter.  * @return the updated Option  */ ;/**  * Restrict the list of possible values of the parameter.  *  * @param choices - the allowed values of the parameter.  * @return the updated Option  */ public Option choices(String... choices) throws RequiredParametersException {     if (this.defaultValue != null) {         if (Arrays.asList(choices).contains(defaultValue)) {             Collections.addAll(this.choices, choices).         } else {             throw new RequiredParametersException("Valid values for option " + this.longName + " do not contain defined default value " + defaultValue).         }     } else {         Collections.addAll(this.choices, choices).     }     return this. }
true;public;1;4;/**  * Add a help text, explaining the parameter.  *  * @param helpText - the help text.  * @return the updated Option  */ ;/**  * Add a help text, explaining the parameter.  *  * @param helpText - the help text.  * @return the updated Option  */ public Option help(String helpText) {     this.helpText = helpText.     return this. }
false;public;0;3;;public String getName() {     return this.longName. }
false;public;0;3;;public boolean hasAlt() {     return this.shortName != null. }
false;public;0;3;;public boolean hasType() {     return this.type != null. }
false;public;0;3;;public OptionType getType() {     return this.type. }
false;public;0;3;;public String getAlt() {     return this.shortName. }
false;public;0;3;;public String getHelpText() {     return this.helpText. }
false;public;0;3;;public Set<String> getChoices() {     return this.choices. }
false;public;0;3;;public boolean hasDefaultValue() {     return this.defaultValue != null. }
false;public;0;3;;public String getDefaultValue() {     return this.defaultValue. }
false;private;1;4;;private Option setDefaultValue(String defaultValue) {     this.defaultValue = defaultValue.     return this. }
false;public;1;37;;public boolean isCastableToDefinedType(String value) {     switch(this.type) {         case INTEGER:             try {                 Integer.parseInt(value).             } catch (NumberFormatException nfe) {                 return false.             }             return true.         case LONG:             try {                 Long.parseLong(value).             } catch (NumberFormatException nfe) {                 return false.             }             return true.         case FLOAT:             try {                 Float.parseFloat(value).             } catch (NumberFormatException nfe) {                 return false.             }             return true.         case DOUBLE:             try {                 Double.parseDouble(value).             } catch (NumberFormatException nfe) {                 return false.             }             return true.         case BOOLEAN:             return Objects.equals(value, "true") || Objects.equals(value, "false").         case STRING:             return true.     }     throw new IllegalStateException("Invalid value for OptionType " + this.type + " for option " + this.longName). }
