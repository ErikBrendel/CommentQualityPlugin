commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;// -------------------------------------------------------------------------------------------- public String getCharsetName() {     return charsetName. }
false;public;1;7;;public void setCharsetName(String charsetName) {     if (charsetName == null) {         throw new IllegalArgumentException("The charset name may not be null.").     }     this.charsetName = charsetName. }
false;public;0;3;;public boolean isSkipInvalidLines() {     return skipInvalidLines. }
false;public;1;3;;public void setSkipInvalidLines(boolean skipInvalidLines) {     this.skipInvalidLines = skipInvalidLines. }
false;public;1;15;;// -------------------------------------------------------------------------------------------- @Override public void configure(Configuration parameters) {     super.configure(parameters).     if (charsetName == null || !Charset.isSupported(charsetName)) {         throw new RuntimeException("Unsupported charset: " + charsetName).     }     if (charsetName.equalsIgnoreCase(StandardCharsets.US_ASCII.name())) {         ascii = true.     }     this.decoder = Charset.forName(charsetName).newDecoder().     this.byteWrapper = ByteBuffer.allocate(1). }
false;public;4;31;;// -------------------------------------------------------------------------------------------- @Override public StringValue readRecord(StringValue reuse, byte[] bytes, int offset, int numBytes) {     if (this.ascii) {         reuse.setValueAscii(bytes, offset, numBytes).         return reuse.     } else {         ByteBuffer byteWrapper = this.byteWrapper.         if (bytes != byteWrapper.array()) {             byteWrapper = ByteBuffer.wrap(bytes, 0, bytes.length).             this.byteWrapper = byteWrapper.         }         byteWrapper.limit(offset + numBytes).         byteWrapper.position(offset).         try {             CharBuffer result = this.decoder.decode(byteWrapper).             reuse.setValue(result).             return reuse.         } catch (CharacterCodingException e) {             if (skipInvalidLines) {                 return null.             } else {                 byte[] copy = new byte[numBytes].                 System.arraycopy(bytes, offset, copy, 0, numBytes).                 throw new RuntimeException("Line could not be encoded: " + Arrays.toString(copy), e).             }         }     } }
false;public;0;4;;// -------------------------------------------------------------------------------------------- @Override public String toString() {     return "TextValueInputFormat (" + Arrays.toString(getFilePaths()) + ") - " + this.charsetName + (this.skipInvalidLines ? "(skipping invalid lines)" : ""). }
false;public;0;4;;@Override public boolean supportsMultiPaths() {     return true. }
