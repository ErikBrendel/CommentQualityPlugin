commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean hasNext() {     return false. }
false;public;0;4;;@Override public IntermediateSampleData<T> next() {     return null. }
true;public,abstract;1;1;/**  * Sample algorithm for the first phase. It operates on a single partition.  *  * @param input The DataSet input of each partition.  * @return Intermediate sample output which will be used as the input of the second phase.  */ ;/**  * Sample algorithm for the first phase. It operates on a single partition.  *  * @param input The DataSet input of each partition.  * @return Intermediate sample output which will be used as the input of the second phase.  */ public abstract Iterator<IntermediateSampleData<T>> sampleInPartition(Iterator<T> input).
false;public;0;4;;@Override public boolean hasNext() {     return itr.hasNext(). }
false;public;0;4;;@Override public T next() {     return itr.next().getElement(). }
false;public;0;4;;@Override public void remove() {     itr.remove(). }
true;public;1;45;/**  * Sample algorithm for the second phase. This operation should be executed as the UDF of  * an all reduce operation.  *  * @param input The intermediate sample output generated in the first phase.  * @return The sampled output.  */ ;/**  * Sample algorithm for the second phase. This operation should be executed as the UDF of  * an all reduce operation.  *  * @param input The intermediate sample output generated in the first phase.  * @return The sampled output.  */ public Iterator<T> sampleInCoordinator(Iterator<IntermediateSampleData<T>> input) {     if (numSamples == 0) {         return emptyIterable.     }     // This queue holds fixed number elements with the top K weight for the coordinator.     PriorityQueue<IntermediateSampleData<T>> reservoir = new PriorityQueue<IntermediateSampleData<T>>(numSamples).     int index = 0.     IntermediateSampleData<T> smallest = null.     while (input.hasNext()) {         IntermediateSampleData<T> element = input.next().         if (index < numSamples) {             // Fill the queue with first K elements from input.             reservoir.add(element).             smallest = reservoir.peek().         } else {             // with the smallest weight, and append current element into the queue.             if (element.getWeight() > smallest.getWeight()) {                 reservoir.remove().                 reservoir.add(element).                 smallest = reservoir.peek().             }         }         index++.     }     final Iterator<IntermediateSampleData<T>> itr = reservoir.iterator().     return new Iterator<T>() {          @Override         public boolean hasNext() {             return itr.hasNext().         }          @Override         public T next() {             return itr.next().getElement().         }          @Override         public void remove() {             itr.remove().         }     }. }
true;public;1;4;/**  * Combine the first phase and second phase in sequence, implemented for test purpose only.  *  * @param input Source data.  * @return Sample result in sequence.  */ ;/**  * Combine the first phase and second phase in sequence, implemented for test purpose only.  *  * @param input Source data.  * @return Sample result in sequence.  */ @Override public Iterator<T> sample(Iterator<T> input) {     return sampleInCoordinator(sampleInPartition(input)). }
