commented;modifiers;parameterAmount;loc;comment;code
true;public;2;24;/**  * Reduce implementation, returns bigger tuple or value1 if both tuples are  * equal. Comparison highly depends on the order and amount of fields chosen  * as indices. All given fields (at construction time) are checked in the same  * order as defined (at construction time). If both tuples are equal in one  * index, the next index is compared. Or if no next index is available value1  * is returned.  * The tuple which has a bigger value at one index will be returned.  */ ;/**  * Reduce implementation, returns bigger tuple or value1 if both tuples are  * equal. Comparison highly depends on the order and amount of fields chosen  * as indices. All given fields (at construction time) are checked in the same  * order as defined (at construction time). If both tuples are equal in one  * index, the next index is compared. Or if no next index is available value1  * is returned.  * The tuple which has a bigger value at one index will be returned.  */ @SuppressWarnings({ "unchecked", "rawtypes" }) @Override public T reduce(T value1, T value2) throws Exception {     for (int index = 0. index < fields.length. index++) {         // Save position of compared key         int position = this.fields[index].         // Get both values - both implement comparable         Comparable comparable1 = value1.getFieldNotNull(position).         Comparable comparable2 = value2.getFieldNotNull(position).         // Compare values         int comp = comparable1.compareTo(comparable2).         // Return the smaller value.         if (comp > 0) {             return value1.         } else if (comp < 0) {             return value2.         }     }     return value1. }
