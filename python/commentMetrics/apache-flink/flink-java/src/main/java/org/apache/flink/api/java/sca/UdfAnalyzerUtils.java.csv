commented;modifiers;parameterAmount;loc;comment;code
false;public,static;5;55;;public static TaggedValue convertTypeInfoToTaggedValue(TaggedValue.Input input, TypeInformation<?> typeInfo, String flatFieldExpr, List<CompositeType.FlatFieldDescriptor> flatFieldDesc, int[] groupedKeys) {     // java tuples & scala tuples     if (typeInfo instanceof TupleTypeInfoBase) {         final TupleTypeInfoBase<?> tupleTypeInfo = (TupleTypeInfoBase<?>) typeInfo.         HashMap<String, TaggedValue> containerMapping = new HashMap<String, TaggedValue>().         for (int i = 0. i < tupleTypeInfo.getArity(). i++) {             final String fieldName.             // java             if (typeInfo instanceof TupleTypeInfo) {                 fieldName = "f" + i.             } else // scala             {                 fieldName = "_" + (i + 1).             }             containerMapping.put(fieldName, convertTypeInfoToTaggedValue(input, tupleTypeInfo.getTypeAt(i), (flatFieldExpr.length() > 0 ? flatFieldExpr + "." : "") + fieldName, tupleTypeInfo.getFlatFields(fieldName), groupedKeys)).         }         return new TaggedValue(Type.getObjectType("java/lang/Object"), containerMapping).     } else // pojos     if (typeInfo instanceof PojoTypeInfo) {         final PojoTypeInfo<?> pojoTypeInfo = (PojoTypeInfo<?>) typeInfo.         HashMap<String, TaggedValue> containerMapping = new HashMap<String, TaggedValue>().         for (int i = 0. i < pojoTypeInfo.getArity(). i++) {             final String fieldName = pojoTypeInfo.getPojoFieldAt(i).getField().getName().             containerMapping.put(fieldName, convertTypeInfoToTaggedValue(input, pojoTypeInfo.getTypeAt(i), (flatFieldExpr.length() > 0 ? flatFieldExpr + "." : "") + fieldName, pojoTypeInfo.getFlatFields(fieldName), groupedKeys)).         }         return new TaggedValue(Type.getObjectType("java/lang/Object"), containerMapping).     }     // atomic     boolean groupedField = false.     if (groupedKeys != null && flatFieldDesc != null) {         int flatFieldPos = flatFieldDesc.get(0).getPosition().         for (int groupedKey : groupedKeys) {             if (groupedKey == flatFieldPos) {                 groupedField = true.                 break.             }         }     }     return new TaggedValue(Type.getType(typeInfo.getTypeClass()), input, flatFieldExpr, groupedField, typeInfo.isBasicType() && typeInfo != BasicTypeInfo.DATE_TYPE_INFO). }
true;public,static;2;3;/**  * @return array that contains the method node and the name of the class where  * the method node has been found  */ ;/**  * @return array that contains the method node and the name of the class where  * the method node has been found  */ public static Object[] findMethodNode(String internalClassName, Method method) {     return findMethodNode(internalClassName, method.getName(), Type.getMethodDescriptor(method)). }
true;public,static;3;34;/**  * @return array that contains the method node and the name of the class where  * the method node has been found  */ ;/**  * @return array that contains the method node and the name of the class where  * the method node has been found  */ @SuppressWarnings("unchecked") public static Object[] findMethodNode(String internalClassName, String name, String desc) {     InputStream stream = null.     try {         // class that really implements the method         while (internalClassName != null) {             stream = Thread.currentThread().getContextClassLoader().getResourceAsStream(internalClassName.replace('.', '/') + ".class").             ClassReader cr = new ClassReader(stream).             final ClassNode cn = new ClassNode().             cr.accept(cn, 0).             for (MethodNode mn : (List<MethodNode>) cn.methods) {                 if (mn.name.equals(name) && mn.desc.equals(desc)) {                     return new Object[] { mn, cr.getClassName() }.                 }             }             internalClassName = cr.getSuperName().         }     } catch (IOException e) {         throw new IllegalStateException("Method '" + name + "' could not be found", e).     } finally {         if (stream != null) {             try {                 stream.close().             } catch (IOException e) {             // best effort cleanup             }         }     }     throw new IllegalStateException("Method '" + name + "' could not be found"). }
false;public,static;1;3;;public static boolean isTagged(Value value) {     return value instanceof TaggedValue. }
false;public,static;1;3;;public static TaggedValue tagged(Value value) {     return (TaggedValue) value. }
true;public,static;2;12;/**  * @return returns whether a value of the list of values is or contains  * important dependencies (inputs or collectors) that require special analysis  * (e.g. to dig into a nested method). The first argument can be skipped e.g.  * in order to skip the "this" of non-static method arguments.  */ ;/**  * @return returns whether a value of the list of values is or contains  * important dependencies (inputs or collectors) that require special analysis  * (e.g. to dig into a nested method). The first argument can be skipped e.g.  * in order to skip the "this" of non-static method arguments.  */ public static boolean hasImportantDependencies(List<? extends BasicValue> values, boolean skipFirst) {     for (BasicValue value : values) {         if (skipFirst) {             skipFirst = false.             continue.         }         if (hasImportantDependencies(value)) {             return true.         }     }     return false. }
true;public,static;1;18;/**  * @return returns whether a value is or contains important dependencies (inputs or collectors)  * that require special analysis (e.g. to dig into a nested method)  */ ;/**  * @return returns whether a value is or contains important dependencies (inputs or collectors)  * that require special analysis (e.g. to dig into a nested method)  */ public static boolean hasImportantDependencies(BasicValue bv) {     if (!isTagged(bv)) {         return false.     }     final TaggedValue value = tagged(bv).     if (value.isInput() || value.isCollector()) {         return true.     } else if (value.canContainFields() && value.getContainerMapping() != null) {         for (TaggedValue tv : value.getContainerMapping().values()) {             if (hasImportantDependencies(tv)) {                 return true.             }         }     }     return false. }
false;public,static;1;12;;public static TaggedValue mergeInputs(List<TaggedValue> returnValues) {     TaggedValue first = null.     for (TaggedValue tv : returnValues) {         if (first == null) {             first = tv.         } else if (!first.equals(tv)) {             return null.         }     }     return first. }
false;public,static;1;70;;public static TaggedValue mergeContainers(List<TaggedValue> returnValues) {     if (returnValues.size() == 0) {         return null.     }     Type returnType = null.     // do intersections of field names     Set<String> keys = null.     for (TaggedValue tv : returnValues) {         if (keys == null) {             keys = new HashSet<String>(tv.getContainerMapping().keySet()).             returnType = tv.getType().         } else {             keys.retainAll(tv.getContainerMapping().keySet()).         }     }     // filter mappings with undefined state     final HashMap<String, TaggedValue> resultMapping = new HashMap<String, TaggedValue>(keys.size()).     final List<String> filteredMappings = new ArrayList<String>(keys.size()).     for (TaggedValue tv : returnValues) {         final Map<String, TaggedValue> cm = tv.getContainerMapping().         for (String key : keys) {             if (cm.containsKey(key)) {                 // add mapping with undefined state to filter                 if (!filteredMappings.contains(key) && cm.get(key) == null) {                     filteredMappings.add(key).                 } else // add mapping to result mapping                 if (!resultMapping.containsKey(key) && !filteredMappings.contains(key)) {                     resultMapping.put(key, cm.get(key)).                 } else // remove it from result                 if (resultMapping.containsKey(key) && filteredMappings.contains(key)) {                     resultMapping.remove(key).                 } else // remove it and mark it as mapping with undefined state in filter                 if (resultMapping.containsKey(key) && !filteredMappings.contains(key) && !cm.get(key).equals(resultMapping.get(key))) {                     filteredMappings.add(key).                     resultMapping.remove(key).                 }             }         }     }     // recursively merge contained mappings     Iterator<Map.Entry<String, TaggedValue>> it = resultMapping.entrySet().iterator().     while (it.hasNext()) {         Map.Entry<String, TaggedValue> entry = it.next().         TaggedValue value = mergeReturnValues(Collections.singletonList(entry.getValue())).         if (value == null) {             it.remove().         } else {             entry.setValue(value).         }     }     if (resultMapping.size() > 0) {         return new TaggedValue(returnType, resultMapping).     }     return null. }
false;public,static;1;22;;public static TaggedValue mergeReturnValues(List<TaggedValue> returnValues) {     if (returnValues.size() == 0 || returnValues.get(0) == null) {         return null.     }     // check if either all inputs or all containers     boolean allInputs = returnValues.get(0).isInput().     for (TaggedValue tv : returnValues) {         if (tv == null || tv.isInput() != allInputs) {             return null.         }         // check if there are uninteresting values         if (tv.canNotContainInput()) {             return null.         }     }     if (allInputs) {         return mergeInputs(returnValues).     }     return mergeContainers(returnValues). }
false;public,static;1;17;;public static void removeUngroupedInputsFromContainer(TaggedValue value) {     if (value.getContainerMapping() != null) {         Iterator<Map.Entry<String, TaggedValue>> it = value.getContainerMapping().entrySet().iterator().         while (it.hasNext()) {             Map.Entry<String, TaggedValue> entry = it.next().             if (entry.getValue() == null) {                 continue.             } else if (entry.getValue().isInput() && !entry.getValue().isGrouped()) {                 it.remove().             } else if (entry.getValue().canContainFields()) {                 removeUngroupedInputsFromContainer(entry.getValue()).             }         }     } }
false;public,static;1;14;;public static TaggedValue removeUngroupedInputs(TaggedValue value) {     if (value.isInput()) {         if (value.isGrouped()) {             return value.         }     } else if (value.canContainFields()) {         removeUngroupedInputsFromContainer(value).         if (value.getContainerMapping() != null && value.getContainerMapping().size() > 0) {             return value.         }     }     return null. }
