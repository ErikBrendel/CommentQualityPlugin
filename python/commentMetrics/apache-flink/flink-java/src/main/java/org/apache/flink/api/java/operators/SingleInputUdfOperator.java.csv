commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;0;1;;protected abstract Function getFunction().
false;public;1;8;;// -------------------------------------------------------------------------------------------- // Fluent API methods // -------------------------------------------------------------------------------------------- @Override public O withParameters(Configuration parameters) {     this.parameters = parameters.     @SuppressWarnings("unchecked")     O returnType = (O) this.     return returnType. }
false;public;2;19;;@Override public O withBroadcastSet(DataSet<?> data, String name) {     if (data == null) {         throw new IllegalArgumentException("Broadcast variable data must not be null.").     }     if (name == null) {         throw new IllegalArgumentException("Broadcast variable name must not be null.").     }     if (this.broadcastVariables == null) {         this.broadcastVariables = new HashMap<String, DataSet<?>>().     }     this.broadcastVariables.put(name, data).     @SuppressWarnings("unchecked")     O returnType = (O) this.     return returnType. }
true;public;1;26;/**  * Adds semantic information about forwarded fields of the user-defined function.  * The forwarded fields information declares fields which are never modified by the function and  * which are forwarded at the same position to the output or unchanged copied to another position in the output.  *  * <p>Fields that are forwarded at the same position are specified by their position.  * The specified position must be valid for the input and output data type and have the same type.  * For example <code>withForwardedFields("f2")</code> declares that the third field of a Java input tuple is  * copied to the third field of an output tuple.  *  * <p>Fields which are unchanged copied to another position in the output are declared by specifying the  * source field reference in the input and the target field reference in the output.  * {@code withForwardedFields("f0->f2")} denotes that the first field of the Java input tuple is  * unchanged copied to the third field of the Java output tuple. When using a wildcard ("*") ensure that  * the number of declared fields and their types in input and output type match.  *  * <p>Multiple forwarded fields can be annotated in one ({@code withForwardedFields("f2. f3->f0. f4")})  * or separate Strings ({@code withForwardedFields("f2", "f3->f0", "f4")}).  * Please refer to the JavaDoc of {@link org.apache.flink.api.common.functions.Function} or Flink's documentation for  * details on field references such as nested fields and wildcard.  *  * <p>It is not possible to override existing semantic information about forwarded fields which was  * for example added by a {@link org.apache.flink.api.java.functions.FunctionAnnotation.ForwardedFields} class annotation.  *  * <p><b>NOTE: Adding semantic information for functions is optional!  * If used correctly, semantic information can help the Flink optimizer to generate more efficient execution plans.  * However, incorrect semantic information can cause the optimizer to generate incorrect execution plans which compute wrong results!  * So be careful when adding semantic information.  * </b>  *  * @param forwardedFields A list of field forward expressions.  * @return This operator with annotated forwarded field information.  *  * @see org.apache.flink.api.java.functions.FunctionAnnotation  * @see org.apache.flink.api.java.functions.FunctionAnnotation.ForwardedFields  */ ;/**  * Adds semantic information about forwarded fields of the user-defined function.  * The forwarded fields information declares fields which are never modified by the function and  * which are forwarded at the same position to the output or unchanged copied to another position in the output.  *  * <p>Fields that are forwarded at the same position are specified by their position.  * The specified position must be valid for the input and output data type and have the same type.  * For example <code>withForwardedFields("f2")</code> declares that the third field of a Java input tuple is  * copied to the third field of an output tuple.  *  * <p>Fields which are unchanged copied to another position in the output are declared by specifying the  * source field reference in the input and the target field reference in the output.  * {@code withForwardedFields("f0->f2")} denotes that the first field of the Java input tuple is  * unchanged copied to the third field of the Java output tuple. When using a wildcard ("*") ensure that  * the number of declared fields and their types in input and output type match.  *  * <p>Multiple forwarded fields can be annotated in one ({@code withForwardedFields("f2. f3->f0. f4")})  * or separate Strings ({@code withForwardedFields("f2", "f3->f0", "f4")}).  * Please refer to the JavaDoc of {@link org.apache.flink.api.common.functions.Function} or Flink's documentation for  * details on field references such as nested fields and wildcard.  *  * <p>It is not possible to override existing semantic information about forwarded fields which was  * for example added by a {@link org.apache.flink.api.java.functions.FunctionAnnotation.ForwardedFields} class annotation.  *  * <p><b>NOTE: Adding semantic information for functions is optional!  * If used correctly, semantic information can help the Flink optimizer to generate more efficient execution plans.  * However, incorrect semantic information can cause the optimizer to generate incorrect execution plans which compute wrong results!  * So be careful when adding semantic information.  * </b>  *  * @param forwardedFields A list of field forward expressions.  * @return This operator with annotated forwarded field information.  *  * @see org.apache.flink.api.java.functions.FunctionAnnotation  * @see org.apache.flink.api.java.functions.FunctionAnnotation.ForwardedFields  */ public O withForwardedFields(String... forwardedFields) {     if (this.udfSemantics == null) {         // extract semantic properties from function annotations         setSemanticProperties(extractSemanticAnnotations(getFunction().getClass())).     }     if (this.udfSemantics == null || this.analyzedUdfSemantics) {         // discard analyzed semantic properties         setSemanticProperties(new SingleInputSemanticProperties()).         SemanticPropUtil.getSemanticPropsSingleFromString(this.udfSemantics, forwardedFields, null, null, this.getInputType(), this.getResultType()).     } else {         if (udfWithForwardedFieldsAnnotation(getFunction().getClass())) {             // refuse semantic information as it would override the function annotation             throw new SemanticProperties.InvalidSemanticAnnotationException("Forwarded field information " + "has already been added by a function annotation for this operator. " + "Cannot overwrite function annotations.").         } else {             SemanticPropUtil.getSemanticPropsSingleFromString(this.udfSemantics, forwardedFields, null, null, this.getInputType(), this.getResultType()).         }     }     @SuppressWarnings("unchecked")     O returnType = (O) this.     return returnType. }
true;public;1;12;/**  * Adds a type information hint about the return type of this operator. This method  * can be used in cases where Flink cannot determine automatically what the produced  * type of a function is. That can be the case if the function uses generic type variables  * in the return type that cannot be inferred from the input type.  *  * <p>Classes can be used as type hints for non-generic types (classes without generic parameters),  * but not for generic types like for example Tuples. For those generic types, please  * use the {@link #returns(TypeHint)} method.  *  * <p>Use this method the following way:  * <pre>{@code  *     DataSet<String[]> result =  *         data.flatMap(new FunctionWithNonInferrableReturnType())  *             .returns(String[].class).  * }</pre>  *  * @param typeClass The class of the returned data type.  * @return This operator with the type information corresponding to the given type class.  */ ;// ------------------------------------------------------------------------ // type hinting // ------------------------------------------------------------------------ /**  * Adds a type information hint about the return type of this operator. This method  * can be used in cases where Flink cannot determine automatically what the produced  * type of a function is. That can be the case if the function uses generic type variables  * in the return type that cannot be inferred from the input type.  *  * <p>Classes can be used as type hints for non-generic types (classes without generic parameters),  * but not for generic types like for example Tuples. For those generic types, please  * use the {@link #returns(TypeHint)} method.  *  * <p>Use this method the following way:  * <pre>{@code  *     DataSet<String[]> result =  *         data.flatMap(new FunctionWithNonInferrableReturnType())  *             .returns(String[].class).  * }</pre>  *  * @param typeClass The class of the returned data type.  * @return This operator with the type information corresponding to the given type class.  */ public O returns(Class<OUT> typeClass) {     requireNonNull(typeClass, "type class must not be null").     try {         return returns(TypeInformation.of(typeClass)).     } catch (InvalidTypesException e) {         throw new InvalidTypesException("Cannot infer the type information from the class alone." + "This is most likely because the class represents a generic type. In that case," + "please use the 'returns(TypeHint)' method instead.", e).     } }
true;public;1;11;/**  * Adds a type information hint about the return type of this operator. This method  * can be used in cases where Flink cannot determine automatically what the produced  * type of a function is. That can be the case if the function uses generic type variables  * in the return type that cannot be inferred from the input type.  *  * <p>Use this method the following way:  * <pre>{@code  *     DataSet<Tuple2<String, Double>> result =  *         data.flatMap(new FunctionWithNonInferrableReturnType())  *             .returns(new TypeHint<Tuple2<String, Double>>(){}).  * }</pre>  *  * @param typeHint The type hint for the returned data type.  * @return This operator with the type information corresponding to the given type hint.  */ ;/**  * Adds a type information hint about the return type of this operator. This method  * can be used in cases where Flink cannot determine automatically what the produced  * type of a function is. That can be the case if the function uses generic type variables  * in the return type that cannot be inferred from the input type.  *  * <p>Use this method the following way:  * <pre>{@code  *     DataSet<Tuple2<String, Double>> result =  *         data.flatMap(new FunctionWithNonInferrableReturnType())  *             .returns(new TypeHint<Tuple2<String, Double>>(){}).  * }</pre>  *  * @param typeHint The type hint for the returned data type.  * @return This operator with the type information corresponding to the given type hint.  */ public O returns(TypeHint<OUT> typeHint) {     requireNonNull(typeHint, "TypeHint must not be null").     try {         return returns(TypeInformation.of(typeHint)).     } catch (InvalidTypesException e) {         throw new InvalidTypesException("Cannot infer the type information from the type hint. " + "Make sure that the TypeHint does not use any generic type variables.").     } }
true;public;1;8;/**  * Adds a type information hint about the return type of this operator. This method  * can be used in cases where Flink cannot determine automatically what the produced  * type of a function is. That can be the case if the function uses generic type variables  * in the return type that cannot be inferred from the input type.  *  * <p>In most cases, the methods {@link #returns(Class)} and {@link #returns(TypeHint)}  * are preferable.  *  * @param typeInfo The type information for the returned data type.  * @return This operator using the given type information for the return type.  */ ;/**  * Adds a type information hint about the return type of this operator. This method  * can be used in cases where Flink cannot determine automatically what the produced  * type of a function is. That can be the case if the function uses generic type variables  * in the return type that cannot be inferred from the input type.  *  * <p>In most cases, the methods {@link #returns(Class)} and {@link #returns(TypeHint)}  * are preferable.  *  * @param typeInfo The type information for the returned data type.  * @return This operator using the given type information for the return type.  */ public O returns(TypeInformation<OUT> typeInfo) {     requireNonNull(typeInfo, "TypeInformation must not be null").     fillInType(typeInfo).     @SuppressWarnings("unchecked")     O returnType = (O) this.     return returnType. }
false;public;0;7;;// -------------------------------------------------------------------------------------------- // Accessors // -------------------------------------------------------------------------------------------- @Override @Internal public Map<String, DataSet<?>> getBroadcastSets() {     return this.broadcastVariables == null ? Collections.<String, DataSet<?>>emptyMap() : Collections.unmodifiableMap(this.broadcastVariables). }
false;public;0;4;;@Override public Configuration getParameters() {     return this.parameters. }
false;public;0;14;;@Override @Internal public SingleInputSemanticProperties getSemanticProperties() {     if (this.udfSemantics == null || analyzedUdfSemantics) {         SingleInputSemanticProperties props = extractSemanticAnnotations(getFunction().getClass()).         if (props != null) {             setSemanticProperties(props).         }     }     if (this.udfSemantics == null) {         setSemanticProperties(new SingleInputSemanticProperties()).     }     return this.udfSemantics. }
true;public;1;5;/**  * Sets the semantic properties for the user-defined function (UDF). The semantic properties  * define how fields of tuples and other objects are modified or preserved through this UDF.  * The configured properties can be retrieved via {@link UdfOperator#getSemanticProperties()}.  *  * @param properties The semantic properties for the UDF.  * @see UdfOperator#getSemanticProperties()  */ ;/**  * Sets the semantic properties for the user-defined function (UDF). The semantic properties  * define how fields of tuples and other objects are modified or preserved through this UDF.  * The configured properties can be retrieved via {@link UdfOperator#getSemanticProperties()}.  *  * @param properties The semantic properties for the UDF.  * @see UdfOperator#getSemanticProperties()  */ @Internal public void setSemanticProperties(SingleInputSemanticProperties properties) {     this.udfSemantics = properties.     this.analyzedUdfSemantics = false. }
false;protected;0;3;;protected boolean getAnalyzedUdfSemanticsFlag() {     return this.analyzedUdfSemantics. }
false;protected;0;3;;protected void setAnalyzedUdfSemanticsFlag() {     this.analyzedUdfSemantics = true. }
false;protected;1;4;;protected SingleInputSemanticProperties extractSemanticAnnotations(Class<?> udfClass) {     Set<Annotation> annotations = FunctionAnnotation.readSingleForwardAnnotations(udfClass).     return SemanticPropUtil.getSemanticPropsSingle(annotations, getInputType(), getResultType()). }
false;protected;1;4;;protected boolean udfWithForwardedFieldsAnnotation(Class<?> udfClass) {     return udfClass.getAnnotation(FunctionAnnotation.ForwardedFields.class) != null || udfClass.getAnnotation(FunctionAnnotation.NonForwardedFields.class) != null. }
