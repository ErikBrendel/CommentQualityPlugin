# id;timestamp;commentText;codeText;commentWords;codeWords
FunctionAnnotation -> private FunctionAnnotation();1405024514;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1405090423;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1406821655;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1411372797;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1420730997;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1422405541;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1433741389;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1446112342;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1454679829;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1455101486;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1461578869;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1475688973;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> private FunctionAnnotation();1500387300;Private constructor to prevent instantiation. This class is intended only as a container.;private FunctionAnnotation() {};private,constructor,to,prevent,instantiation,this,class,is,intended,only,as,a,container;private,function,annotation
FunctionAnnotation -> @Internal 	public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass);1454679829;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the forwarded fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;@Internal_	public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass) {__		_		ForwardedFieldsFirst forwardedFields1 = udfClass.getAnnotation(ForwardedFieldsFirst.class)__		ForwardedFieldsSecond forwardedFields2= udfClass.getAnnotation(ForwardedFieldsSecond.class)___		_		NonForwardedFieldsFirst nonForwardedFields1 = udfClass.getAnnotation(NonForwardedFieldsFirst.class)__		NonForwardedFieldsSecond nonForwardedFields2 = udfClass.getAnnotation(NonForwardedFieldsSecond.class)___		ReadFieldsFirst readSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		Set<Annotation> annotations = new HashSet<Annotation>()___		if (nonForwardedFields1 != null && forwardedFields1 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsFirst.class.getSimpleName() + " or " +_					NonForwardedFieldsFirst.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields1 != null) {_			annotations.add(forwardedFields1)__		} else if (nonForwardedFields1 != null) {_			annotations.add(nonForwardedFields1)__		}__		if (forwardedFields2 != null && nonForwardedFields2 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsSecond.class.getSimpleName() + " or " +_					NonForwardedFieldsSecond.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields2 != null) {_			annotations.add(forwardedFields2)__		} else if (nonForwardedFields2 != null) {_			annotations.add(nonForwardedFields2)__		}__		if (readSet1 != null) {_			annotations.add(readSet1)__		}_		if (readSet2 != null) {_			annotations.add(readSet2)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;internal,public,static,set,annotation,read,dual,forward,annotations,class,udf,class,forwarded,fields,first,forwarded,fields1,udf,class,get,annotation,forwarded,fields,first,class,forwarded,fields,second,forwarded,fields2,udf,class,get,annotation,forwarded,fields,second,class,non,forwarded,fields,first,non,forwarded,fields1,udf,class,get,annotation,non,forwarded,fields,first,class,non,forwarded,fields,second,non,forwarded,fields2,udf,class,get,annotation,non,forwarded,fields,second,class,read,fields,first,read,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,read,set2,udf,class,get,annotation,read,fields,second,class,set,annotation,annotations,new,hash,set,annotation,if,non,forwarded,fields1,null,forwarded,fields1,null,throw,new,invalid,program,exception,either,forwarded,fields,first,class,get,simple,name,or,non,forwarded,fields,first,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields1,null,annotations,add,forwarded,fields1,else,if,non,forwarded,fields1,null,annotations,add,non,forwarded,fields1,if,forwarded,fields2,null,non,forwarded,fields2,null,throw,new,invalid,program,exception,either,forwarded,fields,second,class,get,simple,name,or,non,forwarded,fields,second,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields2,null,annotations,add,forwarded,fields2,else,if,non,forwarded,fields2,null,annotations,add,non,forwarded,fields2,if,read,set1,null,annotations,add,read,set1,if,read,set2,null,annotations,add,read,set2,return,annotations,is,empty,annotations,null
FunctionAnnotation -> @Internal 	public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass);1455101486;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the forwarded fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;@Internal_	public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass) {__		_		ForwardedFieldsFirst forwardedFields1 = udfClass.getAnnotation(ForwardedFieldsFirst.class)__		ForwardedFieldsSecond forwardedFields2= udfClass.getAnnotation(ForwardedFieldsSecond.class)___		_		NonForwardedFieldsFirst nonForwardedFields1 = udfClass.getAnnotation(NonForwardedFieldsFirst.class)__		NonForwardedFieldsSecond nonForwardedFields2 = udfClass.getAnnotation(NonForwardedFieldsSecond.class)___		ReadFieldsFirst readSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		Set<Annotation> annotations = new HashSet<Annotation>()___		if (nonForwardedFields1 != null && forwardedFields1 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsFirst.class.getSimpleName() + " or " +_					NonForwardedFieldsFirst.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields1 != null) {_			annotations.add(forwardedFields1)__		} else if (nonForwardedFields1 != null) {_			annotations.add(nonForwardedFields1)__		}__		if (forwardedFields2 != null && nonForwardedFields2 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsSecond.class.getSimpleName() + " or " +_					NonForwardedFieldsSecond.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields2 != null) {_			annotations.add(forwardedFields2)__		} else if (nonForwardedFields2 != null) {_			annotations.add(nonForwardedFields2)__		}__		if (readSet1 != null) {_			annotations.add(readSet1)__		}_		if (readSet2 != null) {_			annotations.add(readSet2)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;internal,public,static,set,annotation,read,dual,forward,annotations,class,udf,class,forwarded,fields,first,forwarded,fields1,udf,class,get,annotation,forwarded,fields,first,class,forwarded,fields,second,forwarded,fields2,udf,class,get,annotation,forwarded,fields,second,class,non,forwarded,fields,first,non,forwarded,fields1,udf,class,get,annotation,non,forwarded,fields,first,class,non,forwarded,fields,second,non,forwarded,fields2,udf,class,get,annotation,non,forwarded,fields,second,class,read,fields,first,read,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,read,set2,udf,class,get,annotation,read,fields,second,class,set,annotation,annotations,new,hash,set,annotation,if,non,forwarded,fields1,null,forwarded,fields1,null,throw,new,invalid,program,exception,either,forwarded,fields,first,class,get,simple,name,or,non,forwarded,fields,first,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields1,null,annotations,add,forwarded,fields1,else,if,non,forwarded,fields1,null,annotations,add,non,forwarded,fields1,if,forwarded,fields2,null,non,forwarded,fields2,null,throw,new,invalid,program,exception,either,forwarded,fields,second,class,get,simple,name,or,non,forwarded,fields,second,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields2,null,annotations,add,forwarded,fields2,else,if,non,forwarded,fields2,null,annotations,add,non,forwarded,fields2,if,read,set1,null,annotations,add,read,set1,if,read,set2,null,annotations,add,read,set2,return,annotations,is,empty,annotations,null
FunctionAnnotation -> @Internal 	public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass);1461578869;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the forwarded fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;@Internal_	public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass) {__		_		ForwardedFieldsFirst forwardedFields1 = udfClass.getAnnotation(ForwardedFieldsFirst.class)__		ForwardedFieldsSecond forwardedFields2= udfClass.getAnnotation(ForwardedFieldsSecond.class)___		_		NonForwardedFieldsFirst nonForwardedFields1 = udfClass.getAnnotation(NonForwardedFieldsFirst.class)__		NonForwardedFieldsSecond nonForwardedFields2 = udfClass.getAnnotation(NonForwardedFieldsSecond.class)___		ReadFieldsFirst readSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		Set<Annotation> annotations = new HashSet<Annotation>()___		if (nonForwardedFields1 != null && forwardedFields1 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsFirst.class.getSimpleName() + " or " +_					NonForwardedFieldsFirst.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields1 != null) {_			annotations.add(forwardedFields1)__		} else if (nonForwardedFields1 != null) {_			annotations.add(nonForwardedFields1)__		}__		if (forwardedFields2 != null && nonForwardedFields2 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsSecond.class.getSimpleName() + " or " +_					NonForwardedFieldsSecond.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields2 != null) {_			annotations.add(forwardedFields2)__		} else if (nonForwardedFields2 != null) {_			annotations.add(nonForwardedFields2)__		}__		if (readSet1 != null) {_			annotations.add(readSet1)__		}_		if (readSet2 != null) {_			annotations.add(readSet2)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;internal,public,static,set,annotation,read,dual,forward,annotations,class,udf,class,forwarded,fields,first,forwarded,fields1,udf,class,get,annotation,forwarded,fields,first,class,forwarded,fields,second,forwarded,fields2,udf,class,get,annotation,forwarded,fields,second,class,non,forwarded,fields,first,non,forwarded,fields1,udf,class,get,annotation,non,forwarded,fields,first,class,non,forwarded,fields,second,non,forwarded,fields2,udf,class,get,annotation,non,forwarded,fields,second,class,read,fields,first,read,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,read,set2,udf,class,get,annotation,read,fields,second,class,set,annotation,annotations,new,hash,set,annotation,if,non,forwarded,fields1,null,forwarded,fields1,null,throw,new,invalid,program,exception,either,forwarded,fields,first,class,get,simple,name,or,non,forwarded,fields,first,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields1,null,annotations,add,forwarded,fields1,else,if,non,forwarded,fields1,null,annotations,add,non,forwarded,fields1,if,forwarded,fields2,null,non,forwarded,fields2,null,throw,new,invalid,program,exception,either,forwarded,fields,second,class,get,simple,name,or,non,forwarded,fields,second,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields2,null,annotations,add,forwarded,fields2,else,if,non,forwarded,fields2,null,annotations,add,non,forwarded,fields2,if,read,set1,null,annotations,add,read,set1,if,read,set2,null,annotations,add,read,set2,return,annotations,is,empty,annotations,null
FunctionAnnotation -> @Internal 	public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass);1475688973;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the forwarded fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;@Internal_	public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass) {__		_		ForwardedFieldsFirst forwardedFields1 = udfClass.getAnnotation(ForwardedFieldsFirst.class)__		ForwardedFieldsSecond forwardedFields2= udfClass.getAnnotation(ForwardedFieldsSecond.class)___		_		NonForwardedFieldsFirst nonForwardedFields1 = udfClass.getAnnotation(NonForwardedFieldsFirst.class)__		NonForwardedFieldsSecond nonForwardedFields2 = udfClass.getAnnotation(NonForwardedFieldsSecond.class)___		ReadFieldsFirst readSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		Set<Annotation> annotations = new HashSet<Annotation>()___		if (nonForwardedFields1 != null && forwardedFields1 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsFirst.class.getSimpleName() + " or " +_					NonForwardedFieldsFirst.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields1 != null) {_			annotations.add(forwardedFields1)__		} else if (nonForwardedFields1 != null) {_			annotations.add(nonForwardedFields1)__		}__		if (forwardedFields2 != null && nonForwardedFields2 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsSecond.class.getSimpleName() + " or " +_					NonForwardedFieldsSecond.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields2 != null) {_			annotations.add(forwardedFields2)__		} else if (nonForwardedFields2 != null) {_			annotations.add(nonForwardedFields2)__		}__		if (readSet1 != null) {_			annotations.add(readSet1)__		}_		if (readSet2 != null) {_			annotations.add(readSet2)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;internal,public,static,set,annotation,read,dual,forward,annotations,class,udf,class,forwarded,fields,first,forwarded,fields1,udf,class,get,annotation,forwarded,fields,first,class,forwarded,fields,second,forwarded,fields2,udf,class,get,annotation,forwarded,fields,second,class,non,forwarded,fields,first,non,forwarded,fields1,udf,class,get,annotation,non,forwarded,fields,first,class,non,forwarded,fields,second,non,forwarded,fields2,udf,class,get,annotation,non,forwarded,fields,second,class,read,fields,first,read,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,read,set2,udf,class,get,annotation,read,fields,second,class,set,annotation,annotations,new,hash,set,annotation,if,non,forwarded,fields1,null,forwarded,fields1,null,throw,new,invalid,program,exception,either,forwarded,fields,first,class,get,simple,name,or,non,forwarded,fields,first,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields1,null,annotations,add,forwarded,fields1,else,if,non,forwarded,fields1,null,annotations,add,non,forwarded,fields1,if,forwarded,fields2,null,non,forwarded,fields2,null,throw,new,invalid,program,exception,either,forwarded,fields,second,class,get,simple,name,or,non,forwarded,fields,second,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields2,null,annotations,add,forwarded,fields2,else,if,non,forwarded,fields2,null,annotations,add,non,forwarded,fields2,if,read,set1,null,annotations,add,read,set1,if,read,set2,null,annotations,add,read,set2,return,annotations,is,empty,annotations,null
FunctionAnnotation -> @Internal 	public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass);1500387300;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the forwarded fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;@Internal_	public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass) {__		_		ForwardedFieldsFirst forwardedFields1 = udfClass.getAnnotation(ForwardedFieldsFirst.class)__		ForwardedFieldsSecond forwardedFields2 = udfClass.getAnnotation(ForwardedFieldsSecond.class)___		_		NonForwardedFieldsFirst nonForwardedFields1 = udfClass.getAnnotation(NonForwardedFieldsFirst.class)__		NonForwardedFieldsSecond nonForwardedFields2 = udfClass.getAnnotation(NonForwardedFieldsSecond.class)___		ReadFieldsFirst readSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		Set<Annotation> annotations = new HashSet<Annotation>()___		if (nonForwardedFields1 != null && forwardedFields1 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsFirst.class.getSimpleName() + " or " +_					NonForwardedFieldsFirst.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields1 != null) {_			annotations.add(forwardedFields1)__		} else if (nonForwardedFields1 != null) {_			annotations.add(nonForwardedFields1)__		}__		if (forwardedFields2 != null && nonForwardedFields2 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsSecond.class.getSimpleName() + " or " +_					NonForwardedFieldsSecond.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields2 != null) {_			annotations.add(forwardedFields2)__		} else if (nonForwardedFields2 != null) {_			annotations.add(nonForwardedFields2)__		}__		if (readSet1 != null) {_			annotations.add(readSet1)__		}_		if (readSet2 != null) {_			annotations.add(readSet2)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;internal,public,static,set,annotation,read,dual,forward,annotations,class,udf,class,forwarded,fields,first,forwarded,fields1,udf,class,get,annotation,forwarded,fields,first,class,forwarded,fields,second,forwarded,fields2,udf,class,get,annotation,forwarded,fields,second,class,non,forwarded,fields,first,non,forwarded,fields1,udf,class,get,annotation,non,forwarded,fields,first,class,non,forwarded,fields,second,non,forwarded,fields2,udf,class,get,annotation,non,forwarded,fields,second,class,read,fields,first,read,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,read,set2,udf,class,get,annotation,read,fields,second,class,set,annotation,annotations,new,hash,set,annotation,if,non,forwarded,fields1,null,forwarded,fields1,null,throw,new,invalid,program,exception,either,forwarded,fields,first,class,get,simple,name,or,non,forwarded,fields,first,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields1,null,annotations,add,forwarded,fields1,else,if,non,forwarded,fields1,null,annotations,add,non,forwarded,fields1,if,forwarded,fields2,null,non,forwarded,fields2,null,throw,new,invalid,program,exception,either,forwarded,fields,second,class,get,simple,name,or,non,forwarded,fields,second,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields2,null,annotations,add,forwarded,fields2,else,if,non,forwarded,fields2,null,annotations,add,non,forwarded,fields2,if,read,set1,null,annotations,add,read,set1,if,read,set2,null,annotations,add,read,set2,return,annotations,is,empty,annotations,null
FunctionAnnotation -> @Internal 	public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass);1454679829;Reads the annotations of a user defined function with one input and returns semantic properties according to the forwarded fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;@Internal_	public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass) {_		ForwardedFields forwardedFields = udfClass.getAnnotation(ForwardedFields.class)__		NonForwardedFields nonForwardedFields = udfClass.getAnnotation(NonForwardedFields.class)__		ReadFields readSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> annotations = new HashSet<Annotation>()__		if(forwardedFields != null) {_			annotations.add(forwardedFields)__		}_		if(nonForwardedFields != null) {_			if(!annotations.isEmpty()) {_				throw new InvalidProgramException("Either " + ForwardedFields.class.getSimpleName() + " or " +_						NonForwardedFields.class.getSimpleName() + " can be annotated to a function, not both.")__			}_			annotations.add(nonForwardedFields)__		}_		if(readSet != null) {_			annotations.add(readSet)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;internal,public,static,set,annotation,read,single,forward,annotations,class,udf,class,forwarded,fields,forwarded,fields,udf,class,get,annotation,forwarded,fields,class,non,forwarded,fields,non,forwarded,fields,udf,class,get,annotation,non,forwarded,fields,class,read,fields,read,set,udf,class,get,annotation,read,fields,class,set,annotation,annotations,new,hash,set,annotation,if,forwarded,fields,null,annotations,add,forwarded,fields,if,non,forwarded,fields,null,if,annotations,is,empty,throw,new,invalid,program,exception,either,forwarded,fields,class,get,simple,name,or,non,forwarded,fields,class,get,simple,name,can,be,annotated,to,a,function,not,both,annotations,add,non,forwarded,fields,if,read,set,null,annotations,add,read,set,return,annotations,is,empty,annotations,null
FunctionAnnotation -> @Internal 	public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass);1455101486;Reads the annotations of a user defined function with one input and returns semantic properties according to the forwarded fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;@Internal_	public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass) {_		ForwardedFields forwardedFields = udfClass.getAnnotation(ForwardedFields.class)__		NonForwardedFields nonForwardedFields = udfClass.getAnnotation(NonForwardedFields.class)__		ReadFields readSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> annotations = new HashSet<Annotation>()__		if(forwardedFields != null) {_			annotations.add(forwardedFields)__		}_		if(nonForwardedFields != null) {_			if(!annotations.isEmpty()) {_				throw new InvalidProgramException("Either " + ForwardedFields.class.getSimpleName() + " or " +_						NonForwardedFields.class.getSimpleName() + " can be annotated to a function, not both.")__			}_			annotations.add(nonForwardedFields)__		}_		if(readSet != null) {_			annotations.add(readSet)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;internal,public,static,set,annotation,read,single,forward,annotations,class,udf,class,forwarded,fields,forwarded,fields,udf,class,get,annotation,forwarded,fields,class,non,forwarded,fields,non,forwarded,fields,udf,class,get,annotation,non,forwarded,fields,class,read,fields,read,set,udf,class,get,annotation,read,fields,class,set,annotation,annotations,new,hash,set,annotation,if,forwarded,fields,null,annotations,add,forwarded,fields,if,non,forwarded,fields,null,if,annotations,is,empty,throw,new,invalid,program,exception,either,forwarded,fields,class,get,simple,name,or,non,forwarded,fields,class,get,simple,name,can,be,annotated,to,a,function,not,both,annotations,add,non,forwarded,fields,if,read,set,null,annotations,add,read,set,return,annotations,is,empty,annotations,null
FunctionAnnotation -> @Internal 	public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass);1461578869;Reads the annotations of a user defined function with one input and returns semantic properties according to the forwarded fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;@Internal_	public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass) {_		ForwardedFields forwardedFields = udfClass.getAnnotation(ForwardedFields.class)__		NonForwardedFields nonForwardedFields = udfClass.getAnnotation(NonForwardedFields.class)__		ReadFields readSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> annotations = new HashSet<Annotation>()__		if(forwardedFields != null) {_			annotations.add(forwardedFields)__		}_		if(nonForwardedFields != null) {_			if(!annotations.isEmpty()) {_				throw new InvalidProgramException("Either " + ForwardedFields.class.getSimpleName() + " or " +_						NonForwardedFields.class.getSimpleName() + " can be annotated to a function, not both.")__			}_			annotations.add(nonForwardedFields)__		}_		if(readSet != null) {_			annotations.add(readSet)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;internal,public,static,set,annotation,read,single,forward,annotations,class,udf,class,forwarded,fields,forwarded,fields,udf,class,get,annotation,forwarded,fields,class,non,forwarded,fields,non,forwarded,fields,udf,class,get,annotation,non,forwarded,fields,class,read,fields,read,set,udf,class,get,annotation,read,fields,class,set,annotation,annotations,new,hash,set,annotation,if,forwarded,fields,null,annotations,add,forwarded,fields,if,non,forwarded,fields,null,if,annotations,is,empty,throw,new,invalid,program,exception,either,forwarded,fields,class,get,simple,name,or,non,forwarded,fields,class,get,simple,name,can,be,annotated,to,a,function,not,both,annotations,add,non,forwarded,fields,if,read,set,null,annotations,add,read,set,return,annotations,is,empty,annotations,null
FunctionAnnotation -> @Internal 	public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass);1475688973;Reads the annotations of a user defined function with one input and returns semantic properties according to the forwarded fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;@Internal_	public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass) {_		ForwardedFields forwardedFields = udfClass.getAnnotation(ForwardedFields.class)__		NonForwardedFields nonForwardedFields = udfClass.getAnnotation(NonForwardedFields.class)__		ReadFields readSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> annotations = new HashSet<Annotation>()__		if(forwardedFields != null) {_			annotations.add(forwardedFields)__		}_		if(nonForwardedFields != null) {_			if(!annotations.isEmpty()) {_				throw new InvalidProgramException("Either " + ForwardedFields.class.getSimpleName() + " or " +_						NonForwardedFields.class.getSimpleName() + " can be annotated to a function, not both.")__			}_			annotations.add(nonForwardedFields)__		}_		if(readSet != null) {_			annotations.add(readSet)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;internal,public,static,set,annotation,read,single,forward,annotations,class,udf,class,forwarded,fields,forwarded,fields,udf,class,get,annotation,forwarded,fields,class,non,forwarded,fields,non,forwarded,fields,udf,class,get,annotation,non,forwarded,fields,class,read,fields,read,set,udf,class,get,annotation,read,fields,class,set,annotation,annotations,new,hash,set,annotation,if,forwarded,fields,null,annotations,add,forwarded,fields,if,non,forwarded,fields,null,if,annotations,is,empty,throw,new,invalid,program,exception,either,forwarded,fields,class,get,simple,name,or,non,forwarded,fields,class,get,simple,name,can,be,annotated,to,a,function,not,both,annotations,add,non,forwarded,fields,if,read,set,null,annotations,add,read,set,return,annotations,is,empty,annotations,null
FunctionAnnotation -> @Internal 	public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass);1500387300;Reads the annotations of a user defined function with one input and returns semantic properties according to the forwarded fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;@Internal_	public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass) {_		ForwardedFields forwardedFields = udfClass.getAnnotation(ForwardedFields.class)__		NonForwardedFields nonForwardedFields = udfClass.getAnnotation(NonForwardedFields.class)__		ReadFields readSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> annotations = new HashSet<Annotation>()__		if (forwardedFields != null) {_			annotations.add(forwardedFields)__		}_		if (nonForwardedFields != null) {_			if (!annotations.isEmpty()) {_				throw new InvalidProgramException("Either " + ForwardedFields.class.getSimpleName() + " or " +_						NonForwardedFields.class.getSimpleName() + " can be annotated to a function, not both.")__			}_			annotations.add(nonForwardedFields)__		}_		if (readSet != null) {_			annotations.add(readSet)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;internal,public,static,set,annotation,read,single,forward,annotations,class,udf,class,forwarded,fields,forwarded,fields,udf,class,get,annotation,forwarded,fields,class,non,forwarded,fields,non,forwarded,fields,udf,class,get,annotation,non,forwarded,fields,class,read,fields,read,set,udf,class,get,annotation,read,fields,class,set,annotation,annotations,new,hash,set,annotation,if,forwarded,fields,null,annotations,add,forwarded,fields,if,non,forwarded,fields,null,if,annotations,is,empty,throw,new,invalid,program,exception,either,forwarded,fields,class,get,simple,name,or,non,forwarded,fields,class,get,simple,name,can,be,annotated,to,a,function,not,both,annotations,add,non,forwarded,fields,if,read,set,null,annotations,add,read,set,return,annotations,is,empty,annotations,null
FunctionAnnotation -> public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass);1422405541;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the forwarded fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass) {__		_		ForwardedFieldsFirst forwardedFields1 = udfClass.getAnnotation(ForwardedFieldsFirst.class)__		ForwardedFieldsSecond forwardedFields2= udfClass.getAnnotation(ForwardedFieldsSecond.class)___		_		NonForwardedFieldsFirst nonForwardedFields1 = udfClass.getAnnotation(NonForwardedFieldsFirst.class)__		NonForwardedFieldsSecond nonForwardedFields2 = udfClass.getAnnotation(NonForwardedFieldsSecond.class)___		ReadFieldsFirst readSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		Set<Annotation> annotations = new HashSet<Annotation>()___		if (nonForwardedFields1 != null && forwardedFields1 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsFirst.class.getSimpleName() + " or " +_					NonForwardedFieldsFirst.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields1 != null) {_			annotations.add(forwardedFields1)__		} else if (nonForwardedFields1 != null) {_			annotations.add(nonForwardedFields1)__		}__		if (forwardedFields2 != null && nonForwardedFields2 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsSecond.class.getSimpleName() + " or " +_					NonForwardedFieldsSecond.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields2 != null) {_			annotations.add(forwardedFields2)__		} else if (nonForwardedFields2 != null) {_			annotations.add(nonForwardedFields2)__		}__		if (readSet1 != null) {_			annotations.add(readSet1)__		}_		if (readSet2 != null) {_			annotations.add(readSet2)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;public,static,set,annotation,read,dual,forward,annotations,class,udf,class,forwarded,fields,first,forwarded,fields1,udf,class,get,annotation,forwarded,fields,first,class,forwarded,fields,second,forwarded,fields2,udf,class,get,annotation,forwarded,fields,second,class,non,forwarded,fields,first,non,forwarded,fields1,udf,class,get,annotation,non,forwarded,fields,first,class,non,forwarded,fields,second,non,forwarded,fields2,udf,class,get,annotation,non,forwarded,fields,second,class,read,fields,first,read,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,read,set2,udf,class,get,annotation,read,fields,second,class,set,annotation,annotations,new,hash,set,annotation,if,non,forwarded,fields1,null,forwarded,fields1,null,throw,new,invalid,program,exception,either,forwarded,fields,first,class,get,simple,name,or,non,forwarded,fields,first,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields1,null,annotations,add,forwarded,fields1,else,if,non,forwarded,fields1,null,annotations,add,non,forwarded,fields1,if,forwarded,fields2,null,non,forwarded,fields2,null,throw,new,invalid,program,exception,either,forwarded,fields,second,class,get,simple,name,or,non,forwarded,fields,second,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields2,null,annotations,add,forwarded,fields2,else,if,non,forwarded,fields2,null,annotations,add,non,forwarded,fields2,if,read,set1,null,annotations,add,read,set1,if,read,set2,null,annotations,add,read,set2,return,annotations,is,empty,annotations,null
FunctionAnnotation -> public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass);1433741389;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the forwarded fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass) {__		_		ForwardedFieldsFirst forwardedFields1 = udfClass.getAnnotation(ForwardedFieldsFirst.class)__		ForwardedFieldsSecond forwardedFields2= udfClass.getAnnotation(ForwardedFieldsSecond.class)___		_		NonForwardedFieldsFirst nonForwardedFields1 = udfClass.getAnnotation(NonForwardedFieldsFirst.class)__		NonForwardedFieldsSecond nonForwardedFields2 = udfClass.getAnnotation(NonForwardedFieldsSecond.class)___		ReadFieldsFirst readSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		Set<Annotation> annotations = new HashSet<Annotation>()___		if (nonForwardedFields1 != null && forwardedFields1 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsFirst.class.getSimpleName() + " or " +_					NonForwardedFieldsFirst.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields1 != null) {_			annotations.add(forwardedFields1)__		} else if (nonForwardedFields1 != null) {_			annotations.add(nonForwardedFields1)__		}__		if (forwardedFields2 != null && nonForwardedFields2 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsSecond.class.getSimpleName() + " or " +_					NonForwardedFieldsSecond.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields2 != null) {_			annotations.add(forwardedFields2)__		} else if (nonForwardedFields2 != null) {_			annotations.add(nonForwardedFields2)__		}__		if (readSet1 != null) {_			annotations.add(readSet1)__		}_		if (readSet2 != null) {_			annotations.add(readSet2)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;public,static,set,annotation,read,dual,forward,annotations,class,udf,class,forwarded,fields,first,forwarded,fields1,udf,class,get,annotation,forwarded,fields,first,class,forwarded,fields,second,forwarded,fields2,udf,class,get,annotation,forwarded,fields,second,class,non,forwarded,fields,first,non,forwarded,fields1,udf,class,get,annotation,non,forwarded,fields,first,class,non,forwarded,fields,second,non,forwarded,fields2,udf,class,get,annotation,non,forwarded,fields,second,class,read,fields,first,read,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,read,set2,udf,class,get,annotation,read,fields,second,class,set,annotation,annotations,new,hash,set,annotation,if,non,forwarded,fields1,null,forwarded,fields1,null,throw,new,invalid,program,exception,either,forwarded,fields,first,class,get,simple,name,or,non,forwarded,fields,first,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields1,null,annotations,add,forwarded,fields1,else,if,non,forwarded,fields1,null,annotations,add,non,forwarded,fields1,if,forwarded,fields2,null,non,forwarded,fields2,null,throw,new,invalid,program,exception,either,forwarded,fields,second,class,get,simple,name,or,non,forwarded,fields,second,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields2,null,annotations,add,forwarded,fields2,else,if,non,forwarded,fields2,null,annotations,add,non,forwarded,fields2,if,read,set1,null,annotations,add,read,set1,if,read,set2,null,annotations,add,read,set2,return,annotations,is,empty,annotations,null
FunctionAnnotation -> public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass);1446112342;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the forwarded fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;public static Set<Annotation> readDualForwardAnnotations(Class<?> udfClass) {__		_		ForwardedFieldsFirst forwardedFields1 = udfClass.getAnnotation(ForwardedFieldsFirst.class)__		ForwardedFieldsSecond forwardedFields2= udfClass.getAnnotation(ForwardedFieldsSecond.class)___		_		NonForwardedFieldsFirst nonForwardedFields1 = udfClass.getAnnotation(NonForwardedFieldsFirst.class)__		NonForwardedFieldsSecond nonForwardedFields2 = udfClass.getAnnotation(NonForwardedFieldsSecond.class)___		ReadFieldsFirst readSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		Set<Annotation> annotations = new HashSet<Annotation>()___		if (nonForwardedFields1 != null && forwardedFields1 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsFirst.class.getSimpleName() + " or " +_					NonForwardedFieldsFirst.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields1 != null) {_			annotations.add(forwardedFields1)__		} else if (nonForwardedFields1 != null) {_			annotations.add(nonForwardedFields1)__		}__		if (forwardedFields2 != null && nonForwardedFields2 != null) {_			throw new InvalidProgramException("Either " + ForwardedFieldsSecond.class.getSimpleName() + " or " +_					NonForwardedFieldsSecond.class.getSimpleName() + " can be annotated to a function, not both.")__		} else if (forwardedFields2 != null) {_			annotations.add(forwardedFields2)__		} else if (nonForwardedFields2 != null) {_			annotations.add(nonForwardedFields2)__		}__		if (readSet1 != null) {_			annotations.add(readSet1)__		}_		if (readSet2 != null) {_			annotations.add(readSet2)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;public,static,set,annotation,read,dual,forward,annotations,class,udf,class,forwarded,fields,first,forwarded,fields1,udf,class,get,annotation,forwarded,fields,first,class,forwarded,fields,second,forwarded,fields2,udf,class,get,annotation,forwarded,fields,second,class,non,forwarded,fields,first,non,forwarded,fields1,udf,class,get,annotation,non,forwarded,fields,first,class,non,forwarded,fields,second,non,forwarded,fields2,udf,class,get,annotation,non,forwarded,fields,second,class,read,fields,first,read,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,read,set2,udf,class,get,annotation,read,fields,second,class,set,annotation,annotations,new,hash,set,annotation,if,non,forwarded,fields1,null,forwarded,fields1,null,throw,new,invalid,program,exception,either,forwarded,fields,first,class,get,simple,name,or,non,forwarded,fields,first,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields1,null,annotations,add,forwarded,fields1,else,if,non,forwarded,fields1,null,annotations,add,non,forwarded,fields1,if,forwarded,fields2,null,non,forwarded,fields2,null,throw,new,invalid,program,exception,either,forwarded,fields,second,class,get,simple,name,or,non,forwarded,fields,second,class,get,simple,name,can,be,annotated,to,a,function,not,both,else,if,forwarded,fields2,null,annotations,add,forwarded,fields2,else,if,non,forwarded,fields2,null,annotations,add,non,forwarded,fields2,if,read,set1,null,annotations,add,read,set1,if,read,set2,null,annotations,add,read,set2,return,annotations,is,empty,annotations,null
FunctionAnnotation -> public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass);1422405541;Reads the annotations of a user defined function with one input and returns semantic properties according to the forwarded fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass) {_		ForwardedFields forwardedFields = udfClass.getAnnotation(ForwardedFields.class)__		NonForwardedFields nonForwardedFields = udfClass.getAnnotation(NonForwardedFields.class)__		ReadFields readSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> annotations = new HashSet<Annotation>()__		if(forwardedFields != null) {_			annotations.add(forwardedFields)__		}_		if(nonForwardedFields != null) {_			if(!annotations.isEmpty()) {_				throw new InvalidProgramException("Either " + ForwardedFields.class.getSimpleName() + " or " +_						NonForwardedFields.class.getSimpleName() + " can be annotated to a function, not both.")__			}_			annotations.add(nonForwardedFields)__		}_		if(readSet != null) {_			annotations.add(readSet)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;public,static,set,annotation,read,single,forward,annotations,class,udf,class,forwarded,fields,forwarded,fields,udf,class,get,annotation,forwarded,fields,class,non,forwarded,fields,non,forwarded,fields,udf,class,get,annotation,non,forwarded,fields,class,read,fields,read,set,udf,class,get,annotation,read,fields,class,set,annotation,annotations,new,hash,set,annotation,if,forwarded,fields,null,annotations,add,forwarded,fields,if,non,forwarded,fields,null,if,annotations,is,empty,throw,new,invalid,program,exception,either,forwarded,fields,class,get,simple,name,or,non,forwarded,fields,class,get,simple,name,can,be,annotated,to,a,function,not,both,annotations,add,non,forwarded,fields,if,read,set,null,annotations,add,read,set,return,annotations,is,empty,annotations,null
FunctionAnnotation -> public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass);1433741389;Reads the annotations of a user defined function with one input and returns semantic properties according to the forwarded fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass) {_		ForwardedFields forwardedFields = udfClass.getAnnotation(ForwardedFields.class)__		NonForwardedFields nonForwardedFields = udfClass.getAnnotation(NonForwardedFields.class)__		ReadFields readSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> annotations = new HashSet<Annotation>()__		if(forwardedFields != null) {_			annotations.add(forwardedFields)__		}_		if(nonForwardedFields != null) {_			if(!annotations.isEmpty()) {_				throw new InvalidProgramException("Either " + ForwardedFields.class.getSimpleName() + " or " +_						NonForwardedFields.class.getSimpleName() + " can be annotated to a function, not both.")__			}_			annotations.add(nonForwardedFields)__		}_		if(readSet != null) {_			annotations.add(readSet)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;public,static,set,annotation,read,single,forward,annotations,class,udf,class,forwarded,fields,forwarded,fields,udf,class,get,annotation,forwarded,fields,class,non,forwarded,fields,non,forwarded,fields,udf,class,get,annotation,non,forwarded,fields,class,read,fields,read,set,udf,class,get,annotation,read,fields,class,set,annotation,annotations,new,hash,set,annotation,if,forwarded,fields,null,annotations,add,forwarded,fields,if,non,forwarded,fields,null,if,annotations,is,empty,throw,new,invalid,program,exception,either,forwarded,fields,class,get,simple,name,or,non,forwarded,fields,class,get,simple,name,can,be,annotated,to,a,function,not,both,annotations,add,non,forwarded,fields,if,read,set,null,annotations,add,read,set,return,annotations,is,empty,annotations,null
FunctionAnnotation -> public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass);1446112342;Reads the annotations of a user defined function with one input and returns semantic properties according to the forwarded fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the forwarded fields.;public static Set<Annotation> readSingleForwardAnnotations(Class<?> udfClass) {_		ForwardedFields forwardedFields = udfClass.getAnnotation(ForwardedFields.class)__		NonForwardedFields nonForwardedFields = udfClass.getAnnotation(NonForwardedFields.class)__		ReadFields readSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> annotations = new HashSet<Annotation>()__		if(forwardedFields != null) {_			annotations.add(forwardedFields)__		}_		if(nonForwardedFields != null) {_			if(!annotations.isEmpty()) {_				throw new InvalidProgramException("Either " + ForwardedFields.class.getSimpleName() + " or " +_						NonForwardedFields.class.getSimpleName() + " can be annotated to a function, not both.")__			}_			annotations.add(nonForwardedFields)__		}_		if(readSet != null) {_			annotations.add(readSet)__		}__		return !annotations.isEmpty() ? annotations : null__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,forwarded,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,forwarded,fields;public,static,set,annotation,read,single,forward,annotations,class,udf,class,forwarded,fields,forwarded,fields,udf,class,get,annotation,forwarded,fields,class,non,forwarded,fields,non,forwarded,fields,udf,class,get,annotation,non,forwarded,fields,class,read,fields,read,set,udf,class,get,annotation,read,fields,class,set,annotation,annotations,new,hash,set,annotation,if,forwarded,fields,null,annotations,add,forwarded,fields,if,non,forwarded,fields,null,if,annotations,is,empty,throw,new,invalid,program,exception,either,forwarded,fields,class,get,simple,name,or,non,forwarded,fields,class,get,simple,name,can,be,annotated,to,a,function,not,both,annotations,add,non,forwarded,fields,if,read,set,null,annotations,add,read,set,return,annotations,is,empty,annotations,null
FunctionAnnotation -> public static Set<Annotation> readSingleConstantAnnotations(Class<?> udfClass);1405024514;Reads the annotations of a user defined function with one input and returns semantic properties according to the constant fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the constant fields.;public static Set<Annotation> readSingleConstantAnnotations(Class<?> udfClass) {_		ConstantFields constantSet = udfClass.getAnnotation(ConstantFields.class)__		ConstantFieldsExcept notConstantSet = udfClass.getAnnotation(ConstantFieldsExcept.class)__		ReadFields readfieldSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> result = null___		if (notConstantSet != null && constantSet != null) {_			throw new InvalidProgramException("Either " + ConstantFields.class.getSimpleName() + " or " + _					ConstantFieldsExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		if (notConstantSet != null) {_			result = new HashSet<Annotation>()__			result.add(notConstantSet)__		}_		if (constantSet != null) {_			result = new HashSet<Annotation>()__			result.add(constantSet)__		}__		if (readfieldSet != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet)__		}__		return result__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,constant,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,constant,fields;public,static,set,annotation,read,single,constant,annotations,class,udf,class,constant,fields,constant,set,udf,class,get,annotation,constant,fields,class,constant,fields,except,not,constant,set,udf,class,get,annotation,constant,fields,except,class,read,fields,readfield,set,udf,class,get,annotation,read,fields,class,set,annotation,result,null,if,not,constant,set,null,constant,set,null,throw,new,invalid,program,exception,either,constant,fields,class,get,simple,name,or,constant,fields,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,if,not,constant,set,null,result,new,hash,set,annotation,result,add,not,constant,set,if,constant,set,null,result,new,hash,set,annotation,result,add,constant,set,if,readfield,set,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set,return,result
FunctionAnnotation -> public static Set<Annotation> readSingleConstantAnnotations(Class<?> udfClass);1405090423;Reads the annotations of a user defined function with one input and returns semantic properties according to the constant fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the constant fields.;public static Set<Annotation> readSingleConstantAnnotations(Class<?> udfClass) {_		ConstantFields constantSet = udfClass.getAnnotation(ConstantFields.class)__		ConstantFieldsExcept notConstantSet = udfClass.getAnnotation(ConstantFieldsExcept.class)__		ReadFields readfieldSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> result = null___		if (notConstantSet != null && constantSet != null) {_			throw new InvalidProgramException("Either " + ConstantFields.class.getSimpleName() + " or " + _					ConstantFieldsExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		if (notConstantSet != null) {_			result = new HashSet<Annotation>()__			result.add(notConstantSet)__		}_		if (constantSet != null) {_			result = new HashSet<Annotation>()__			result.add(constantSet)__		}__		if (readfieldSet != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet)__		}__		return result__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,constant,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,constant,fields;public,static,set,annotation,read,single,constant,annotations,class,udf,class,constant,fields,constant,set,udf,class,get,annotation,constant,fields,class,constant,fields,except,not,constant,set,udf,class,get,annotation,constant,fields,except,class,read,fields,readfield,set,udf,class,get,annotation,read,fields,class,set,annotation,result,null,if,not,constant,set,null,constant,set,null,throw,new,invalid,program,exception,either,constant,fields,class,get,simple,name,or,constant,fields,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,if,not,constant,set,null,result,new,hash,set,annotation,result,add,not,constant,set,if,constant,set,null,result,new,hash,set,annotation,result,add,constant,set,if,readfield,set,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set,return,result
FunctionAnnotation -> public static Set<Annotation> readSingleConstantAnnotations(Class<?> udfClass);1406821655;Reads the annotations of a user defined function with one input and returns semantic properties according to the constant fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the constant fields.;public static Set<Annotation> readSingleConstantAnnotations(Class<?> udfClass) {_		ConstantFields constantSet = udfClass.getAnnotation(ConstantFields.class)__		ConstantFieldsExcept notConstantSet = udfClass.getAnnotation(ConstantFieldsExcept.class)__		ReadFields readfieldSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> result = null___		if (notConstantSet != null && constantSet != null) {_			throw new InvalidProgramException("Either " + ConstantFields.class.getSimpleName() + " or " + _					ConstantFieldsExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		if (notConstantSet != null) {_			result = new HashSet<Annotation>()__			result.add(notConstantSet)__		}_		if (constantSet != null) {_			result = new HashSet<Annotation>()__			result.add(constantSet)__		}__		if (readfieldSet != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet)__		}__		return result__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,constant,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,constant,fields;public,static,set,annotation,read,single,constant,annotations,class,udf,class,constant,fields,constant,set,udf,class,get,annotation,constant,fields,class,constant,fields,except,not,constant,set,udf,class,get,annotation,constant,fields,except,class,read,fields,readfield,set,udf,class,get,annotation,read,fields,class,set,annotation,result,null,if,not,constant,set,null,constant,set,null,throw,new,invalid,program,exception,either,constant,fields,class,get,simple,name,or,constant,fields,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,if,not,constant,set,null,result,new,hash,set,annotation,result,add,not,constant,set,if,constant,set,null,result,new,hash,set,annotation,result,add,constant,set,if,readfield,set,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set,return,result
FunctionAnnotation -> public static Set<Annotation> readSingleConstantAnnotations(Class<?> udfClass);1411372797;Reads the annotations of a user defined function with one input and returns semantic properties according to the constant fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the constant fields.;public static Set<Annotation> readSingleConstantAnnotations(Class<?> udfClass) {_		ConstantFields constantSet = udfClass.getAnnotation(ConstantFields.class)__		ConstantFieldsExcept notConstantSet = udfClass.getAnnotation(ConstantFieldsExcept.class)__		ReadFields readfieldSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> result = null___		if (notConstantSet != null && constantSet != null) {_			throw new InvalidProgramException("Either " + ConstantFields.class.getSimpleName() + " or " + _					ConstantFieldsExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		if (notConstantSet != null) {_			result = new HashSet<Annotation>()__			result.add(notConstantSet)__		}_		if (constantSet != null) {_			result = new HashSet<Annotation>()__			result.add(constantSet)__		}__		if (readfieldSet != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet)__		}__		return result__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,constant,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,constant,fields;public,static,set,annotation,read,single,constant,annotations,class,udf,class,constant,fields,constant,set,udf,class,get,annotation,constant,fields,class,constant,fields,except,not,constant,set,udf,class,get,annotation,constant,fields,except,class,read,fields,readfield,set,udf,class,get,annotation,read,fields,class,set,annotation,result,null,if,not,constant,set,null,constant,set,null,throw,new,invalid,program,exception,either,constant,fields,class,get,simple,name,or,constant,fields,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,if,not,constant,set,null,result,new,hash,set,annotation,result,add,not,constant,set,if,constant,set,null,result,new,hash,set,annotation,result,add,constant,set,if,readfield,set,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set,return,result
FunctionAnnotation -> public static Set<Annotation> readSingleConstantAnnotations(Class<?> udfClass);1420730997;Reads the annotations of a user defined function with one input and returns semantic properties according to the constant fields annotated.__@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the constant fields.;public static Set<Annotation> readSingleConstantAnnotations(Class<?> udfClass) {_		ConstantFields constantSet = udfClass.getAnnotation(ConstantFields.class)__		ConstantFieldsExcept notConstantSet = udfClass.getAnnotation(ConstantFieldsExcept.class)__		ReadFields readfieldSet = udfClass.getAnnotation(ReadFields.class)___		Set<Annotation> result = null___		if (notConstantSet != null && constantSet != null) {_			throw new InvalidProgramException("Either " + ConstantFields.class.getSimpleName() + " or " + _					ConstantFieldsExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		if (notConstantSet != null) {_			result = new HashSet<Annotation>()__			result.add(notConstantSet)__		}_		if (constantSet != null) {_			result = new HashSet<Annotation>()__			result.add(constantSet)__		}__		if (readfieldSet != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet)__		}__		return result__	};reads,the,annotations,of,a,user,defined,function,with,one,input,and,returns,semantic,properties,according,to,the,constant,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,constant,fields;public,static,set,annotation,read,single,constant,annotations,class,udf,class,constant,fields,constant,set,udf,class,get,annotation,constant,fields,class,constant,fields,except,not,constant,set,udf,class,get,annotation,constant,fields,except,class,read,fields,readfield,set,udf,class,get,annotation,read,fields,class,set,annotation,result,null,if,not,constant,set,null,constant,set,null,throw,new,invalid,program,exception,either,constant,fields,class,get,simple,name,or,constant,fields,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,if,not,constant,set,null,result,new,hash,set,annotation,result,add,not,constant,set,if,constant,set,null,result,new,hash,set,annotation,result,add,constant,set,if,readfield,set,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set,return,result
FunctionAnnotation -> public static Set<Annotation> readDualConstantAnnotations(Class<?> udfClass);1405024514;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the constant fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the constant fields.;public static Set<Annotation> readDualConstantAnnotations(Class<?> udfClass) {__		_		ConstantFieldsFirst constantSet1 = udfClass.getAnnotation(ConstantFieldsFirst.class)__		ConstantFieldsSecond constantSet2= udfClass.getAnnotation(ConstantFieldsSecond.class)___		_		ConstantFieldsFirstExcept notConstantSet1 = udfClass.getAnnotation(ConstantFieldsFirstExcept.class)__		ConstantFieldsSecondExcept notConstantSet2 = udfClass.getAnnotation(ConstantFieldsSecondExcept.class)___		ReadFieldsFirst readfieldSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readfieldSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		if (notConstantSet1 != null && constantSet1 != null) {_			throw new InvalidProgramException("Either " + ConstantFieldsFirst.class.getSimpleName() + " or " + _					ConstantFieldsFirstExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		if (constantSet2 != null && notConstantSet2 != null) {_			throw new InvalidProgramException("Either " + ConstantFieldsSecond.class.getSimpleName() + " or " + _					ConstantFieldsSecondExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		Set<Annotation> result = null___		if (notConstantSet2 != null) {_			result = new HashSet<Annotation>()__			result.add(notConstantSet2)__		}_		if (constantSet2 != null) {_			result = new HashSet<Annotation>()__			result.add(constantSet2)__		}__		if (readfieldSet2 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet2)__		}__		if (notConstantSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(notConstantSet1)__		}_		if (constantSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(constantSet1)__		}__		if (readfieldSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet1)__		}__		return result__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,constant,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,constant,fields;public,static,set,annotation,read,dual,constant,annotations,class,udf,class,constant,fields,first,constant,set1,udf,class,get,annotation,constant,fields,first,class,constant,fields,second,constant,set2,udf,class,get,annotation,constant,fields,second,class,constant,fields,first,except,not,constant,set1,udf,class,get,annotation,constant,fields,first,except,class,constant,fields,second,except,not,constant,set2,udf,class,get,annotation,constant,fields,second,except,class,read,fields,first,readfield,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,readfield,set2,udf,class,get,annotation,read,fields,second,class,if,not,constant,set1,null,constant,set1,null,throw,new,invalid,program,exception,either,constant,fields,first,class,get,simple,name,or,constant,fields,first,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,if,constant,set2,null,not,constant,set2,null,throw,new,invalid,program,exception,either,constant,fields,second,class,get,simple,name,or,constant,fields,second,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,set,annotation,result,null,if,not,constant,set2,null,result,new,hash,set,annotation,result,add,not,constant,set2,if,constant,set2,null,result,new,hash,set,annotation,result,add,constant,set2,if,readfield,set2,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set2,if,not,constant,set1,null,if,result,null,result,new,hash,set,annotation,result,add,not,constant,set1,if,constant,set1,null,if,result,null,result,new,hash,set,annotation,result,add,constant,set1,if,readfield,set1,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set1,return,result
FunctionAnnotation -> public static Set<Annotation> readDualConstantAnnotations(Class<?> udfClass);1405090423;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the constant fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the constant fields.;public static Set<Annotation> readDualConstantAnnotations(Class<?> udfClass) {__		_		ConstantFieldsFirst constantSet1 = udfClass.getAnnotation(ConstantFieldsFirst.class)__		ConstantFieldsSecond constantSet2= udfClass.getAnnotation(ConstantFieldsSecond.class)___		_		ConstantFieldsFirstExcept notConstantSet1 = udfClass.getAnnotation(ConstantFieldsFirstExcept.class)__		ConstantFieldsSecondExcept notConstantSet2 = udfClass.getAnnotation(ConstantFieldsSecondExcept.class)___		ReadFieldsFirst readfieldSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readfieldSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		if (notConstantSet1 != null && constantSet1 != null) {_			throw new InvalidProgramException("Either " + ConstantFieldsFirst.class.getSimpleName() + " or " + _					ConstantFieldsFirstExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		if (constantSet2 != null && notConstantSet2 != null) {_			throw new InvalidProgramException("Either " + ConstantFieldsSecond.class.getSimpleName() + " or " + _					ConstantFieldsSecondExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		Set<Annotation> result = null___		if (notConstantSet2 != null) {_			result = new HashSet<Annotation>()__			result.add(notConstantSet2)__		}_		if (constantSet2 != null) {_			result = new HashSet<Annotation>()__			result.add(constantSet2)__		}__		if (readfieldSet2 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet2)__		}__		if (notConstantSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(notConstantSet1)__		}_		if (constantSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(constantSet1)__		}__		if (readfieldSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet1)__		}__		return result__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,constant,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,constant,fields;public,static,set,annotation,read,dual,constant,annotations,class,udf,class,constant,fields,first,constant,set1,udf,class,get,annotation,constant,fields,first,class,constant,fields,second,constant,set2,udf,class,get,annotation,constant,fields,second,class,constant,fields,first,except,not,constant,set1,udf,class,get,annotation,constant,fields,first,except,class,constant,fields,second,except,not,constant,set2,udf,class,get,annotation,constant,fields,second,except,class,read,fields,first,readfield,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,readfield,set2,udf,class,get,annotation,read,fields,second,class,if,not,constant,set1,null,constant,set1,null,throw,new,invalid,program,exception,either,constant,fields,first,class,get,simple,name,or,constant,fields,first,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,if,constant,set2,null,not,constant,set2,null,throw,new,invalid,program,exception,either,constant,fields,second,class,get,simple,name,or,constant,fields,second,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,set,annotation,result,null,if,not,constant,set2,null,result,new,hash,set,annotation,result,add,not,constant,set2,if,constant,set2,null,result,new,hash,set,annotation,result,add,constant,set2,if,readfield,set2,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set2,if,not,constant,set1,null,if,result,null,result,new,hash,set,annotation,result,add,not,constant,set1,if,constant,set1,null,if,result,null,result,new,hash,set,annotation,result,add,constant,set1,if,readfield,set1,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set1,return,result
FunctionAnnotation -> public static Set<Annotation> readDualConstantAnnotations(Class<?> udfClass);1406821655;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the constant fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the constant fields.;public static Set<Annotation> readDualConstantAnnotations(Class<?> udfClass) {__		_		ConstantFieldsFirst constantSet1 = udfClass.getAnnotation(ConstantFieldsFirst.class)__		ConstantFieldsSecond constantSet2= udfClass.getAnnotation(ConstantFieldsSecond.class)___		_		ConstantFieldsFirstExcept notConstantSet1 = udfClass.getAnnotation(ConstantFieldsFirstExcept.class)__		ConstantFieldsSecondExcept notConstantSet2 = udfClass.getAnnotation(ConstantFieldsSecondExcept.class)___		ReadFieldsFirst readfieldSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readfieldSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		if (notConstantSet1 != null && constantSet1 != null) {_			throw new InvalidProgramException("Either " + ConstantFieldsFirst.class.getSimpleName() + " or " + _					ConstantFieldsFirstExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		if (constantSet2 != null && notConstantSet2 != null) {_			throw new InvalidProgramException("Either " + ConstantFieldsSecond.class.getSimpleName() + " or " + _					ConstantFieldsSecondExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		Set<Annotation> result = null___		if (notConstantSet2 != null) {_			result = new HashSet<Annotation>()__			result.add(notConstantSet2)__		}_		if (constantSet2 != null) {_			result = new HashSet<Annotation>()__			result.add(constantSet2)__		}__		if (readfieldSet2 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet2)__		}__		if (notConstantSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(notConstantSet1)__		}_		if (constantSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(constantSet1)__		}__		if (readfieldSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet1)__		}__		return result__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,constant,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,constant,fields;public,static,set,annotation,read,dual,constant,annotations,class,udf,class,constant,fields,first,constant,set1,udf,class,get,annotation,constant,fields,first,class,constant,fields,second,constant,set2,udf,class,get,annotation,constant,fields,second,class,constant,fields,first,except,not,constant,set1,udf,class,get,annotation,constant,fields,first,except,class,constant,fields,second,except,not,constant,set2,udf,class,get,annotation,constant,fields,second,except,class,read,fields,first,readfield,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,readfield,set2,udf,class,get,annotation,read,fields,second,class,if,not,constant,set1,null,constant,set1,null,throw,new,invalid,program,exception,either,constant,fields,first,class,get,simple,name,or,constant,fields,first,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,if,constant,set2,null,not,constant,set2,null,throw,new,invalid,program,exception,either,constant,fields,second,class,get,simple,name,or,constant,fields,second,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,set,annotation,result,null,if,not,constant,set2,null,result,new,hash,set,annotation,result,add,not,constant,set2,if,constant,set2,null,result,new,hash,set,annotation,result,add,constant,set2,if,readfield,set2,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set2,if,not,constant,set1,null,if,result,null,result,new,hash,set,annotation,result,add,not,constant,set1,if,constant,set1,null,if,result,null,result,new,hash,set,annotation,result,add,constant,set1,if,readfield,set1,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set1,return,result
FunctionAnnotation -> public static Set<Annotation> readDualConstantAnnotations(Class<?> udfClass);1411372797;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the constant fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the constant fields.;public static Set<Annotation> readDualConstantAnnotations(Class<?> udfClass) {__		_		ConstantFieldsFirst constantSet1 = udfClass.getAnnotation(ConstantFieldsFirst.class)__		ConstantFieldsSecond constantSet2= udfClass.getAnnotation(ConstantFieldsSecond.class)___		_		ConstantFieldsFirstExcept notConstantSet1 = udfClass.getAnnotation(ConstantFieldsFirstExcept.class)__		ConstantFieldsSecondExcept notConstantSet2 = udfClass.getAnnotation(ConstantFieldsSecondExcept.class)___		ReadFieldsFirst readfieldSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readfieldSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		if (notConstantSet1 != null && constantSet1 != null) {_			throw new InvalidProgramException("Either " + ConstantFieldsFirst.class.getSimpleName() + " or " + _					ConstantFieldsFirstExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		if (constantSet2 != null && notConstantSet2 != null) {_			throw new InvalidProgramException("Either " + ConstantFieldsSecond.class.getSimpleName() + " or " + _					ConstantFieldsSecondExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		Set<Annotation> result = null___		if (notConstantSet2 != null) {_			result = new HashSet<Annotation>()__			result.add(notConstantSet2)__		}_		if (constantSet2 != null) {_			result = new HashSet<Annotation>()__			result.add(constantSet2)__		}__		if (readfieldSet2 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet2)__		}__		if (notConstantSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(notConstantSet1)__		}_		if (constantSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(constantSet1)__		}__		if (readfieldSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet1)__		}__		return result__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,constant,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,constant,fields;public,static,set,annotation,read,dual,constant,annotations,class,udf,class,constant,fields,first,constant,set1,udf,class,get,annotation,constant,fields,first,class,constant,fields,second,constant,set2,udf,class,get,annotation,constant,fields,second,class,constant,fields,first,except,not,constant,set1,udf,class,get,annotation,constant,fields,first,except,class,constant,fields,second,except,not,constant,set2,udf,class,get,annotation,constant,fields,second,except,class,read,fields,first,readfield,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,readfield,set2,udf,class,get,annotation,read,fields,second,class,if,not,constant,set1,null,constant,set1,null,throw,new,invalid,program,exception,either,constant,fields,first,class,get,simple,name,or,constant,fields,first,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,if,constant,set2,null,not,constant,set2,null,throw,new,invalid,program,exception,either,constant,fields,second,class,get,simple,name,or,constant,fields,second,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,set,annotation,result,null,if,not,constant,set2,null,result,new,hash,set,annotation,result,add,not,constant,set2,if,constant,set2,null,result,new,hash,set,annotation,result,add,constant,set2,if,readfield,set2,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set2,if,not,constant,set1,null,if,result,null,result,new,hash,set,annotation,result,add,not,constant,set1,if,constant,set1,null,if,result,null,result,new,hash,set,annotation,result,add,constant,set1,if,readfield,set1,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set1,return,result
FunctionAnnotation -> public static Set<Annotation> readDualConstantAnnotations(Class<?> udfClass);1420730997;Reads the annotations of a user defined function with two inputs and returns semantic properties according to the constant fields annotated._@param udfClass The user defined function, represented by its class._@return	The DualInputSemanticProperties containing the constant fields.;public static Set<Annotation> readDualConstantAnnotations(Class<?> udfClass) {__		_		ConstantFieldsFirst constantSet1 = udfClass.getAnnotation(ConstantFieldsFirst.class)__		ConstantFieldsSecond constantSet2= udfClass.getAnnotation(ConstantFieldsSecond.class)___		_		ConstantFieldsFirstExcept notConstantSet1 = udfClass.getAnnotation(ConstantFieldsFirstExcept.class)__		ConstantFieldsSecondExcept notConstantSet2 = udfClass.getAnnotation(ConstantFieldsSecondExcept.class)___		ReadFieldsFirst readfieldSet1 = udfClass.getAnnotation(ReadFieldsFirst.class)__		ReadFieldsSecond readfieldSet2 = udfClass.getAnnotation(ReadFieldsSecond.class)___		if (notConstantSet1 != null && constantSet1 != null) {_			throw new InvalidProgramException("Either " + ConstantFieldsFirst.class.getSimpleName() + " or " + _					ConstantFieldsFirstExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		if (constantSet2 != null && notConstantSet2 != null) {_			throw new InvalidProgramException("Either " + ConstantFieldsSecond.class.getSimpleName() + " or " + _					ConstantFieldsSecondExcept.class.getSimpleName() + " can be annotated to a function, not both.")__		}__		Set<Annotation> result = null___		if (notConstantSet2 != null) {_			result = new HashSet<Annotation>()__			result.add(notConstantSet2)__		}_		if (constantSet2 != null) {_			result = new HashSet<Annotation>()__			result.add(constantSet2)__		}__		if (readfieldSet2 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet2)__		}__		if (notConstantSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(notConstantSet1)__		}_		if (constantSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(constantSet1)__		}__		if (readfieldSet1 != null) {_			if (result == null) {_				result = new HashSet<Annotation>()__			}_			result.add(readfieldSet1)__		}__		return result__	};reads,the,annotations,of,a,user,defined,function,with,two,inputs,and,returns,semantic,properties,according,to,the,constant,fields,annotated,param,udf,class,the,user,defined,function,represented,by,its,class,return,the,dual,input,semantic,properties,containing,the,constant,fields;public,static,set,annotation,read,dual,constant,annotations,class,udf,class,constant,fields,first,constant,set1,udf,class,get,annotation,constant,fields,first,class,constant,fields,second,constant,set2,udf,class,get,annotation,constant,fields,second,class,constant,fields,first,except,not,constant,set1,udf,class,get,annotation,constant,fields,first,except,class,constant,fields,second,except,not,constant,set2,udf,class,get,annotation,constant,fields,second,except,class,read,fields,first,readfield,set1,udf,class,get,annotation,read,fields,first,class,read,fields,second,readfield,set2,udf,class,get,annotation,read,fields,second,class,if,not,constant,set1,null,constant,set1,null,throw,new,invalid,program,exception,either,constant,fields,first,class,get,simple,name,or,constant,fields,first,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,if,constant,set2,null,not,constant,set2,null,throw,new,invalid,program,exception,either,constant,fields,second,class,get,simple,name,or,constant,fields,second,except,class,get,simple,name,can,be,annotated,to,a,function,not,both,set,annotation,result,null,if,not,constant,set2,null,result,new,hash,set,annotation,result,add,not,constant,set2,if,constant,set2,null,result,new,hash,set,annotation,result,add,constant,set2,if,readfield,set2,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set2,if,not,constant,set1,null,if,result,null,result,new,hash,set,annotation,result,add,not,constant,set1,if,constant,set1,null,if,result,null,result,new,hash,set,annotation,result,add,constant,set1,if,readfield,set1,null,if,result,null,result,new,hash,set,annotation,result,add,readfield,set1,return,result
