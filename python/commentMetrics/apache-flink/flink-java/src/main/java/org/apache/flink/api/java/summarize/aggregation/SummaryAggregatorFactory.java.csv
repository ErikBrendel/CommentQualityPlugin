commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;9;;@SuppressWarnings("unchecked") public static <R extends Tuple> TupleSummaryAggregator<R> create(TupleTypeInfoBase<?> inType) {     Aggregator[] columnAggregators = new Aggregator[inType.getArity()].     for (int field = 0. field < inType.getArity(). field++) {         Class clazz = inType.getTypeAt(field).getTypeClass().         columnAggregators[field] = SummaryAggregatorFactory.create(clazz).     }     return new TupleSummaryAggregator<>(columnAggregators). }
true;public,static;1;49;/**  * Create a SummaryAggregator for the supplied type.  * @param <T> the type to aggregate  * @param <R> the result type of the aggregation  */ ;/**  * Create a SummaryAggregator for the supplied type.  * @param <T> the type to aggregate  * @param <R> the result type of the aggregation  */ @SuppressWarnings("unchecked") public static <T, R> Aggregator<T, R> create(Class<T> type) {     if (type == Long.class) {         return (Aggregator<T, R>) new LongSummaryAggregator().     } else if (type == LongValue.class) {         return (Aggregator<T, R>) new ValueSummaryAggregator.LongValueSummaryAggregator().     } else if (type == Integer.class) {         return (Aggregator<T, R>) new IntegerSummaryAggregator().     } else if (type == IntValue.class) {         return (Aggregator<T, R>) new ValueSummaryAggregator.IntegerValueSummaryAggregator().     } else if (type == Double.class) {         return (Aggregator<T, R>) new DoubleSummaryAggregator().     } else if (type == DoubleValue.class) {         return (Aggregator<T, R>) new ValueSummaryAggregator.DoubleValueSummaryAggregator().     } else if (type == Float.class) {         return (Aggregator<T, R>) new FloatSummaryAggregator().     } else if (type == FloatValue.class) {         return (Aggregator<T, R>) new ValueSummaryAggregator.FloatValueSummaryAggregator().     } else if (type == Short.class) {         return (Aggregator<T, R>) new ShortSummaryAggregator().     } else if (type == ShortValue.class) {         return (Aggregator<T, R>) new ValueSummaryAggregator.ShortValueSummaryAggregator().     } else if (type == Boolean.class) {         return (Aggregator<T, R>) new BooleanSummaryAggregator().     } else if (type == BooleanValue.class) {         return (Aggregator<T, R>) new ValueSummaryAggregator.BooleanValueSummaryAggregator().     } else if (type == String.class) {         return (Aggregator<T, R>) new StringSummaryAggregator().     } else if (type == StringValue.class) {         return (Aggregator<T, R>) new ValueSummaryAggregator.StringValueSummaryAggregator().     } else {         // rather than error for unsupported types do something very generic         return (Aggregator<T, R>) new ObjectSummaryAggregator().     } }
