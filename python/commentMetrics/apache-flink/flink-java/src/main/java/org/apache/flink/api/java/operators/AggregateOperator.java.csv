commented;modifiers;parameterAmount;loc;comment;code
false;public;2;17;;public AggregateOperator<IN> and(Aggregations function, int field) {     Preconditions.checkNotNull(function).     TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) getType().     if (field < 0 || field >= inType.getArity()) {         throw new IllegalArgumentException("Aggregation field position is out of range.").     }     AggregationFunctionFactory factory = function.getFactory().     AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass()).     this.aggregationFunctions.add(aggFunct).     this.fields.add(field).     return this. }
false;public;1;3;;public AggregateOperator<IN> andSum(int field) {     return this.and(Aggregations.SUM, field). }
false;public;1;3;;public AggregateOperator<IN> andMin(int field) {     return this.and(Aggregations.MIN, field). }
false;public;1;3;;public AggregateOperator<IN> andMax(int field) {     return this.and(Aggregations.MAX, field). }
false;protected;1;88;;@SuppressWarnings("unchecked") @Override @Internal protected org.apache.flink.api.common.operators.base.GroupReduceOperatorBase<IN, IN, GroupReduceFunction<IN, IN>> translateToDataFlow(Operator<IN> input) {     // sanity check     if (this.aggregationFunctions.isEmpty() || this.aggregationFunctions.size() != this.fields.size()) {         throw new IllegalStateException().     }     // construct the aggregation function     AggregationFunction<Object>[] aggFunctions = new AggregationFunction[this.aggregationFunctions.size()].     int[] fields = new int[this.fields.size()].     StringBuilder genName = new StringBuilder().     for (int i = 0. i < fields.length. i++) {         aggFunctions[i] = (AggregationFunction<Object>) this.aggregationFunctions.get(i).         fields[i] = this.fields.get(i).         genName.append(aggFunctions[i].toString()).append('(').append(fields[i]).append(')').append(',').     }     genName.append(" at ").append(aggregateLocationName).     genName.setLength(genName.length() - 1).     @SuppressWarnings("rawtypes")     RichGroupReduceFunction<IN, IN> function = new AggregatingUdf(aggFunctions, fields).     String name = getName() != null ? getName() : genName.toString().     // distinguish between grouped reduce and non-grouped reduce     if (this.grouping == null) {         // non grouped aggregation         UnaryOperatorInformation<IN, IN> operatorInfo = new UnaryOperatorInformation<>(getInputType(), getResultType()).         GroupReduceOperatorBase<IN, IN, GroupReduceFunction<IN, IN>> po = new GroupReduceOperatorBase<IN, IN, GroupReduceFunction<IN, IN>>(function, operatorInfo, new int[0], name).         po.setCombinable(true).         // set input         po.setInput(input).         // set parallelism         po.setParallelism(this.getParallelism()).         return po.     }     if (this.grouping.getKeys() instanceof Keys.ExpressionKeys) {         // grouped aggregation         int[] logicalKeyPositions = this.grouping.getKeys().computeLogicalKeyPositions().         UnaryOperatorInformation<IN, IN> operatorInfo = new UnaryOperatorInformation<>(getInputType(), getResultType()).         GroupReduceOperatorBase<IN, IN, GroupReduceFunction<IN, IN>> po = new GroupReduceOperatorBase<IN, IN, GroupReduceFunction<IN, IN>>(function, operatorInfo, logicalKeyPositions, name).         po.setCombinable(true).         po.setInput(input).         po.setParallelism(this.getParallelism()).         po.setCustomPartitioner(grouping.getCustomPartitioner()).         SingleInputSemanticProperties props = new SingleInputSemanticProperties().         for (int keyField : logicalKeyPositions) {             boolean keyFieldUsedInAgg = false.             for (int aggField : fields) {                 if (keyField == aggField) {                     keyFieldUsedInAgg = true.                     break.                 }             }             if (!keyFieldUsedInAgg) {                 props.addForwardedField(keyField, keyField).             }         }         po.setSemanticProperties(props).         return po.     } else if (this.grouping.getKeys() instanceof Keys.SelectorFunctionKeys) {         throw new UnsupportedOperationException("Aggregate does not support grouping with KeySelector functions, yet.").     } else {         throw new UnsupportedOperationException("Unrecognized key type.").     } }
false;public;1;6;;@Override public void open(Configuration parameters) throws Exception {     for (AggregationFunction<Object> aggFunction : aggFunctions) {         aggFunction.initializeAggregate().     } }
false;public;2;25;;@Override public void reduce(Iterable<T> records, Collector<T> out) {     final AggregationFunction<Object>[] aggFunctions = this.aggFunctions.     final int[] fieldPositions = this.fieldPositions.     // aggregators are initialized from before     T outT = null.     for (T record : records) {         outT = record.         for (int i = 0. i < fieldPositions.length. i++) {             Object val = record.getFieldNotNull(fieldPositions[i]).             aggFunctions[i].aggregate(val).         }     }     for (int i = 0. i < fieldPositions.length. i++) {         Object aggVal = aggFunctions[i].getAggregate().         outT.setField(aggVal, fieldPositions[i]).         aggFunctions[i].initializeAggregate().     }     out.collect(outT). }
false;public;2;4;;@Override public void combine(Iterable<T> records, Collector<T> out) {     reduce(records, out). }
