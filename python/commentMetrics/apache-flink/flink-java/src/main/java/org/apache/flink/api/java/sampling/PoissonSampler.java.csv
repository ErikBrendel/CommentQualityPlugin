# id;timestamp;commentText;codeText;commentWords;codeWords
PoissonSampler -> public PoissonSampler(double fraction);1440164487;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element.;public PoissonSampler(double fraction) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be non-negative.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__		}_	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element;public,poisson,sampler,double,fraction,preconditions,check,argument,fraction,0,fraction,should,be,non,negative,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction
PoissonSampler -> public PoissonSampler(double fraction);1442312441;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element.;public PoissonSampler(double fraction) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be non-negative.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__		}_		this.random = new Random()__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element;public,poisson,sampler,double,fraction,preconditions,check,argument,fraction,0,fraction,should,be,non,negative,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,random,new,random
PoissonSampler -> public PoissonSampler(double fraction);1445420638;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element.;public PoissonSampler(double fraction) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be non-negative.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__		}_		this.random = new XORShiftRandom()__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element;public,poisson,sampler,double,fraction,preconditions,check,argument,fraction,0,fraction,should,be,non,negative,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,random,new,xorshift,random
PoissonSampler -> public PoissonSampler(double fraction);1452182456;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element.;public PoissonSampler(double fraction) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be non-negative.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__		}_		this.random = new XORShiftRandom()__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element;public,poisson,sampler,double,fraction,preconditions,check,argument,fraction,0,fraction,should,be,non,negative,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,random,new,xorshift,random
PoissonSampler -> public PoissonSampler(double fraction);1455477986;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element.;public PoissonSampler(double fraction) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be non-negative.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__		}_		this.random = new XORShiftRandom()__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element;public,poisson,sampler,double,fraction,preconditions,check,argument,fraction,0,fraction,should,be,non,negative,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,random,new,xorshift,random
PoissonSampler -> public PoissonSampler(double fraction);1462899491;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element.;public PoissonSampler(double fraction) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be non-negative.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__		}_		this.random = new XORShiftRandom()__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element;public,poisson,sampler,double,fraction,preconditions,check,argument,fraction,0,fraction,should,be,non,negative,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,random,new,xorshift,random
PoissonSampler -> public PoissonSampler(double fraction);1500387231;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element.;public PoissonSampler(double fraction) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be non-negative.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__		}_		this.random = new XORShiftRandom()__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element;public,poisson,sampler,double,fraction,preconditions,check,argument,fraction,0,fraction,should,be,non,negative,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,random,new,xorshift,random
PoissonSampler -> public PoissonSampler(double fraction, long seed);1440164487;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element._@param seed     Random number generator seed for internal PoissonDistribution.;public PoissonSampler(double fraction, long seed) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be positive.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__			this.poissonDistribution.reseedRandomGenerator(seed)__		}_	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element,param,seed,random,number,generator,seed,for,internal,poisson,distribution;public,poisson,sampler,double,fraction,long,seed,preconditions,check,argument,fraction,0,fraction,should,be,positive,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,poisson,distribution,reseed,random,generator,seed
PoissonSampler -> public PoissonSampler(double fraction, long seed);1442312441;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element._@param seed     Random number generator seed for internal PoissonDistribution.;public PoissonSampler(double fraction, long seed) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be positive.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__			this.poissonDistribution.reseedRandomGenerator(seed)__		}_		this.random = new Random(seed)__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element,param,seed,random,number,generator,seed,for,internal,poisson,distribution;public,poisson,sampler,double,fraction,long,seed,preconditions,check,argument,fraction,0,fraction,should,be,positive,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,poisson,distribution,reseed,random,generator,seed,this,random,new,random,seed
PoissonSampler -> public PoissonSampler(double fraction, long seed);1445420638;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element._@param seed     Random number generator seed for internal PoissonDistribution.;public PoissonSampler(double fraction, long seed) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be positive.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__			this.poissonDistribution.reseedRandomGenerator(seed)__		}_		this.random = new XORShiftRandom(seed)__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element,param,seed,random,number,generator,seed,for,internal,poisson,distribution;public,poisson,sampler,double,fraction,long,seed,preconditions,check,argument,fraction,0,fraction,should,be,positive,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,poisson,distribution,reseed,random,generator,seed,this,random,new,xorshift,random,seed
PoissonSampler -> public PoissonSampler(double fraction, long seed);1452182456;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element._@param seed     Random number generator seed for internal PoissonDistribution.;public PoissonSampler(double fraction, long seed) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be positive.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__			this.poissonDistribution.reseedRandomGenerator(seed)__		}_		this.random = new XORShiftRandom(seed)__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element,param,seed,random,number,generator,seed,for,internal,poisson,distribution;public,poisson,sampler,double,fraction,long,seed,preconditions,check,argument,fraction,0,fraction,should,be,positive,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,poisson,distribution,reseed,random,generator,seed,this,random,new,xorshift,random,seed
PoissonSampler -> public PoissonSampler(double fraction, long seed);1455477986;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element._@param seed     Random number generator seed for internal PoissonDistribution.;public PoissonSampler(double fraction, long seed) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be positive.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__			this.poissonDistribution.reseedRandomGenerator(seed)__		}_		this.random = new XORShiftRandom(seed)__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element,param,seed,random,number,generator,seed,for,internal,poisson,distribution;public,poisson,sampler,double,fraction,long,seed,preconditions,check,argument,fraction,0,fraction,should,be,positive,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,poisson,distribution,reseed,random,generator,seed,this,random,new,xorshift,random,seed
PoissonSampler -> public PoissonSampler(double fraction, long seed);1462899491;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element._@param seed     Random number generator seed for internal PoissonDistribution.;public PoissonSampler(double fraction, long seed) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be positive.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__			this.poissonDistribution.reseedRandomGenerator(seed)__		}_		this.random = new XORShiftRandom(seed)__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element,param,seed,random,number,generator,seed,for,internal,poisson,distribution;public,poisson,sampler,double,fraction,long,seed,preconditions,check,argument,fraction,0,fraction,should,be,positive,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,poisson,distribution,reseed,random,generator,seed,this,random,new,xorshift,random,seed
PoissonSampler -> public PoissonSampler(double fraction, long seed);1500387231;Create a poisson sampler which can sample elements with replacement.__@param fraction The expected count of each element._@param seed     Random number generator seed for internal PoissonDistribution.;public PoissonSampler(double fraction, long seed) {_		Preconditions.checkArgument(fraction >= 0, "fraction should be positive.")__		this.fraction = fraction__		if (this.fraction > 0) {_			this.poissonDistribution = new PoissonDistribution(fraction)__			this.poissonDistribution.reseedRandomGenerator(seed)__		}_		this.random = new XORShiftRandom(seed)__	};create,a,poisson,sampler,which,can,sample,elements,with,replacement,param,fraction,the,expected,count,of,each,element,param,seed,random,number,generator,seed,for,internal,poisson,distribution;public,poisson,sampler,double,fraction,long,seed,preconditions,check,argument,fraction,0,fraction,should,be,positive,this,fraction,fraction,if,this,fraction,0,this,poisson,distribution,new,poisson,distribution,fraction,this,poisson,distribution,reseed,random,generator,seed,this,random,new,xorshift,random,seed
PoissonSampler -> @Override 	public Iterator<T> sample(final Iterator<T> input);1440164487;Sample the input elements, for each input element, generate its count following a poisson_distribution.__@param input Elements to be sampled._@return The sampled result which is lazy computed upon input elements.;@Override_	public Iterator<T> sample(final Iterator<T> input) {_		if (fraction == 0) {_			return EMPTY_ITERABLE__		}_		_		return new SampledIterator<T>() {_			T currentElement__			int currentCount = 0__			_			@Override_			public boolean hasNext() {_				if (currentCount > 0) {_					return true__				} else {_					moveToNextElement()___					if (currentCount > 0) {_						return true__					} else {_						return false__					}_				}_			}__			private void moveToNextElement() {_				while (input.hasNext()) {_					currentElement = input.next()__					currentCount = poissonDistribution.sample()__					if (currentCount > 0) {_						break__					}_				}_			}_			_			@Override_			public T next() {_				if (currentCount == 0) {_					moveToNextElement()__				}__				if (currentCount == 0) {_					return null__				} else {_					currentCount--__					return currentElement__				}_			}_		}__	};sample,the,input,elements,for,each,input,element,generate,its,count,following,a,poisson,distribution,param,input,elements,to,be,sampled,return,the,sampled,result,which,is,lazy,computed,upon,input,elements;override,public,iterator,t,sample,final,iterator,t,input,if,fraction,0,return,return,new,sampled,iterator,t,t,current,element,int,current,count,0,override,public,boolean,has,next,if,current,count,0,return,true,else,move,to,next,element,if,current,count,0,return,true,else,return,false,private,void,move,to,next,element,while,input,has,next,current,element,input,next,current,count,poisson,distribution,sample,if,current,count,0,break,override,public,t,next,if,current,count,0,move,to,next,element,if,current,count,0,return,null,else,current,count,return,current,element
PoissonSampler -> @Override 	public Iterator<T> sample(final Iterator<T> input);1442312441;Sample the input elements, for each input element, generate its count following a poisson_distribution.__@param input Elements to be sampled._@return The sampled result which is lazy computed upon input elements.;@Override_	public Iterator<T> sample(final Iterator<T> input) {_		if (fraction == 0) {_			return EMPTY_ITERABLE__		}_		_		return new SampledIterator<T>() {_			T currentElement__			int currentCount = 0__			_			@Override_			public boolean hasNext() {_				if (currentCount > 0) {_					return true__				} else {_					samplingProcess()__					if (currentCount > 0) {_						return true__					} else {_						return false__					}_				}_			}_			_			@Override_			public T next() {_				if (currentCount <= 0) {_					samplingProcess()__				}_				currentCount--__				return currentElement__			}_			_			public int poisson_ge1(double p){_				_				double q = Math.pow(Math.E, -p)__				_				double t = q + (1 - q) * random.nextDouble()__				int k = 1__				_				t = t * random.nextDouble()__				while (t > q) {_					k++__					t = t * random.nextDouble()__				}_				return k__			}_			_			private void skipGapElements(int num) {_				_				int elementCount = 0__				while (input.hasNext() && elementCount < num){_					currentElement = input.next()__					elementCount++__				}_			}_			_			private void samplingProcess(){_				if (fraction <= THRESHOLD) {_					double u = Math.max(random.nextDouble(), EPSILON)__					int gap = (int) (Math.log(u) / -fraction)__					skipGapElements(gap)__					if (input.hasNext()) {_						currentElement = input.next()__						currentCount = poisson_ge1(fraction)__					}_				} else {_					while (input.hasNext()){_						currentElement = input.next()__						currentCount = poissonDistribution.sample()__						if (currentCount > 0) {_							break__						}_					}_				}_			}_		}__	};sample,the,input,elements,for,each,input,element,generate,its,count,following,a,poisson,distribution,param,input,elements,to,be,sampled,return,the,sampled,result,which,is,lazy,computed,upon,input,elements;override,public,iterator,t,sample,final,iterator,t,input,if,fraction,0,return,return,new,sampled,iterator,t,t,current,element,int,current,count,0,override,public,boolean,has,next,if,current,count,0,return,true,else,sampling,process,if,current,count,0,return,true,else,return,false,override,public,t,next,if,current,count,0,sampling,process,current,count,return,current,element,public,int,double,p,double,q,math,pow,math,e,p,double,t,q,1,q,random,next,double,int,k,1,t,t,random,next,double,while,t,q,k,t,t,random,next,double,return,k,private,void,skip,gap,elements,int,num,int,element,count,0,while,input,has,next,element,count,num,current,element,input,next,element,count,private,void,sampling,process,if,fraction,threshold,double,u,math,max,random,next,double,epsilon,int,gap,int,math,log,u,fraction,skip,gap,elements,gap,if,input,has,next,current,element,input,next,current,count,fraction,else,while,input,has,next,current,element,input,next,current,count,poisson,distribution,sample,if,current,count,0,break
PoissonSampler -> @Override 	public Iterator<T> sample(final Iterator<T> input);1445420638;Sample the input elements, for each input element, generate its count following a poisson_distribution.__@param input Elements to be sampled._@return The sampled result which is lazy computed upon input elements.;@Override_	public Iterator<T> sample(final Iterator<T> input) {_		if (fraction == 0) {_			return EMPTY_ITERABLE__		}_		_		return new SampledIterator<T>() {_			T currentElement__			int currentCount = 0__			_			@Override_			public boolean hasNext() {_				if (currentCount > 0) {_					return true__				} else {_					samplingProcess()__					if (currentCount > 0) {_						return true__					} else {_						return false__					}_				}_			}_			_			@Override_			public T next() {_				if (currentCount <= 0) {_					samplingProcess()__				}_				currentCount--__				return currentElement__			}_			_			public int poisson_ge1(double p){_				_				double q = Math.pow(Math.E, -p)__				_				double t = q + (1 - q) * random.nextDouble()__				int k = 1__				_				t = t * random.nextDouble()__				while (t > q) {_					k++__					t = t * random.nextDouble()__				}_				return k__			}_			_			private void skipGapElements(int num) {_				_				int elementCount = 0__				while (input.hasNext() && elementCount < num){_					currentElement = input.next()__					elementCount++__				}_			}_			_			private void samplingProcess(){_				if (fraction <= THRESHOLD) {_					double u = Math.max(random.nextDouble(), EPSILON)__					int gap = (int) (Math.log(u) / -fraction)__					skipGapElements(gap)__					if (input.hasNext()) {_						currentElement = input.next()__						currentCount = poisson_ge1(fraction)__					}_				} else {_					while (input.hasNext()){_						currentElement = input.next()__						currentCount = poissonDistribution.sample()__						if (currentCount > 0) {_							break__						}_					}_				}_			}_		}__	};sample,the,input,elements,for,each,input,element,generate,its,count,following,a,poisson,distribution,param,input,elements,to,be,sampled,return,the,sampled,result,which,is,lazy,computed,upon,input,elements;override,public,iterator,t,sample,final,iterator,t,input,if,fraction,0,return,return,new,sampled,iterator,t,t,current,element,int,current,count,0,override,public,boolean,has,next,if,current,count,0,return,true,else,sampling,process,if,current,count,0,return,true,else,return,false,override,public,t,next,if,current,count,0,sampling,process,current,count,return,current,element,public,int,double,p,double,q,math,pow,math,e,p,double,t,q,1,q,random,next,double,int,k,1,t,t,random,next,double,while,t,q,k,t,t,random,next,double,return,k,private,void,skip,gap,elements,int,num,int,element,count,0,while,input,has,next,element,count,num,current,element,input,next,element,count,private,void,sampling,process,if,fraction,threshold,double,u,math,max,random,next,double,epsilon,int,gap,int,math,log,u,fraction,skip,gap,elements,gap,if,input,has,next,current,element,input,next,current,count,fraction,else,while,input,has,next,current,element,input,next,current,count,poisson,distribution,sample,if,current,count,0,break
PoissonSampler -> @Override 	public Iterator<T> sample(final Iterator<T> input);1452182456;Sample the input elements, for each input element, generate its count following a poisson_distribution.__@param input Elements to be sampled._@return The sampled result which is lazy computed upon input elements.;@Override_	public Iterator<T> sample(final Iterator<T> input) {_		if (fraction == 0) {_			return EMPTY_ITERABLE__		}_		_		return new SampledIterator<T>() {_			T currentElement__			int currentCount = 0__			_			@Override_			public boolean hasNext() {_				if (currentCount > 0) {_					return true__				} else {_					samplingProcess()__					if (currentCount > 0) {_						return true__					} else {_						return false__					}_				}_			}_			_			@Override_			public T next() {_				if (currentCount <= 0) {_					samplingProcess()__				}_				currentCount--__				return currentElement__			}_			_			public int poisson_ge1(double p) {_				_				double q = Math.pow(Math.E, -p)__				_				double t = q + (1 - q) * random.nextDouble()__				int k = 1__				_				t = t * random.nextDouble()__				while (t > q) {_					k++__					t = t * random.nextDouble()__				}_				return k__			}_			_			private void skipGapElements(int num) {_				_				int elementCount = 0__				while (input.hasNext() && elementCount < num) {_					currentElement = input.next()__					elementCount++__				}_			}_			_			private void samplingProcess() {_				if (fraction <= THRESHOLD) {_					double u = Math.max(random.nextDouble(), EPSILON)__					int gap = (int) (Math.log(u) / -fraction)__					skipGapElements(gap)__					if (input.hasNext()) {_						currentElement = input.next()__						currentCount = poisson_ge1(fraction)__					}_				} else {_					while (input.hasNext()) {_						currentElement = input.next()__						currentCount = poissonDistribution.sample()__						if (currentCount > 0) {_							break__						}_					}_				}_			}_		}__	};sample,the,input,elements,for,each,input,element,generate,its,count,following,a,poisson,distribution,param,input,elements,to,be,sampled,return,the,sampled,result,which,is,lazy,computed,upon,input,elements;override,public,iterator,t,sample,final,iterator,t,input,if,fraction,0,return,return,new,sampled,iterator,t,t,current,element,int,current,count,0,override,public,boolean,has,next,if,current,count,0,return,true,else,sampling,process,if,current,count,0,return,true,else,return,false,override,public,t,next,if,current,count,0,sampling,process,current,count,return,current,element,public,int,double,p,double,q,math,pow,math,e,p,double,t,q,1,q,random,next,double,int,k,1,t,t,random,next,double,while,t,q,k,t,t,random,next,double,return,k,private,void,skip,gap,elements,int,num,int,element,count,0,while,input,has,next,element,count,num,current,element,input,next,element,count,private,void,sampling,process,if,fraction,threshold,double,u,math,max,random,next,double,epsilon,int,gap,int,math,log,u,fraction,skip,gap,elements,gap,if,input,has,next,current,element,input,next,current,count,fraction,else,while,input,has,next,current,element,input,next,current,count,poisson,distribution,sample,if,current,count,0,break
PoissonSampler -> @Override 	public Iterator<T> sample(final Iterator<T> input);1455477986;Sample the input elements, for each input element, generate its count following a poisson_distribution.__@param input Elements to be sampled._@return The sampled result which is lazy computed upon input elements.;@Override_	public Iterator<T> sample(final Iterator<T> input) {_		if (fraction == 0) {_			return EMPTY_ITERABLE__		}_		_		return new SampledIterator<T>() {_			T currentElement__			int currentCount = 0__			_			@Override_			public boolean hasNext() {_				if (currentCount > 0) {_					return true__				} else {_					samplingProcess()__					if (currentCount > 0) {_						return true__					} else {_						return false__					}_				}_			}_			_			@Override_			public T next() {_				if (currentCount <= 0) {_					samplingProcess()__				}_				currentCount--__				return currentElement__			}_			_			public int poisson_ge1(double p) {_				_				double q = Math.pow(Math.E, -p)__				_				double t = q + (1 - q) * random.nextDouble()__				int k = 1__				_				t = t * random.nextDouble()__				while (t > q) {_					k++__					t = t * random.nextDouble()__				}_				return k__			}_			_			private void skipGapElements(int num) {_				_				int elementCount = 0__				while (input.hasNext() && elementCount < num) {_					currentElement = input.next()__					elementCount++__				}_			}_			_			private void samplingProcess() {_				if (fraction <= THRESHOLD) {_					double u = Math.max(random.nextDouble(), EPSILON)__					int gap = (int) (Math.log(u) / -fraction)__					skipGapElements(gap)__					if (input.hasNext()) {_						currentElement = input.next()__						currentCount = poisson_ge1(fraction)__					}_				} else {_					while (input.hasNext()) {_						currentElement = input.next()__						currentCount = poissonDistribution.sample()__						if (currentCount > 0) {_							break__						}_					}_				}_			}_		}__	};sample,the,input,elements,for,each,input,element,generate,its,count,following,a,poisson,distribution,param,input,elements,to,be,sampled,return,the,sampled,result,which,is,lazy,computed,upon,input,elements;override,public,iterator,t,sample,final,iterator,t,input,if,fraction,0,return,return,new,sampled,iterator,t,t,current,element,int,current,count,0,override,public,boolean,has,next,if,current,count,0,return,true,else,sampling,process,if,current,count,0,return,true,else,return,false,override,public,t,next,if,current,count,0,sampling,process,current,count,return,current,element,public,int,double,p,double,q,math,pow,math,e,p,double,t,q,1,q,random,next,double,int,k,1,t,t,random,next,double,while,t,q,k,t,t,random,next,double,return,k,private,void,skip,gap,elements,int,num,int,element,count,0,while,input,has,next,element,count,num,current,element,input,next,element,count,private,void,sampling,process,if,fraction,threshold,double,u,math,max,random,next,double,epsilon,int,gap,int,math,log,u,fraction,skip,gap,elements,gap,if,input,has,next,current,element,input,next,current,count,fraction,else,while,input,has,next,current,element,input,next,current,count,poisson,distribution,sample,if,current,count,0,break
PoissonSampler -> @Override 	public Iterator<T> sample(final Iterator<T> input);1462899491;Sample the input elements, for each input element, generate its count following a poisson_distribution.__@param input Elements to be sampled._@return The sampled result which is lazy computed upon input elements.;@Override_	public Iterator<T> sample(final Iterator<T> input) {_		if (fraction == 0) {_			return EMPTY_ITERABLE__		}_		_		return new SampledIterator<T>() {_			T currentElement__			int currentCount = 0__			_			@Override_			public boolean hasNext() {_				if (currentCount > 0) {_					return true__				} else {_					samplingProcess()__					if (currentCount > 0) {_						return true__					} else {_						return false__					}_				}_			}_			_			@Override_			public T next() {_				if (currentCount <= 0) {_					samplingProcess()__				}_				currentCount--__				return currentElement__			}_			_			public int poisson_ge1(double p) {_				_				double q = Math.pow(Math.E, -p)__				_				double t = q + (1 - q) * random.nextDouble()__				int k = 1__				_				t = t * random.nextDouble()__				while (t > q) {_					k++__					t = t * random.nextDouble()__				}_				return k__			}_			_			private void skipGapElements(int num) {_				_				int elementCount = 0__				while (input.hasNext() && elementCount < num) {_					currentElement = input.next()__					elementCount++__				}_			}_			_			private void samplingProcess() {_				if (fraction <= THRESHOLD) {_					double u = Math.max(random.nextDouble(), EPSILON)__					int gap = (int) (Math.log(u) / -fraction)__					skipGapElements(gap)__					if (input.hasNext()) {_						currentElement = input.next()__						currentCount = poisson_ge1(fraction)__					}_				} else {_					while (input.hasNext()) {_						currentElement = input.next()__						currentCount = poissonDistribution.sample()__						if (currentCount > 0) {_							break__						}_					}_				}_			}_		}__	};sample,the,input,elements,for,each,input,element,generate,its,count,following,a,poisson,distribution,param,input,elements,to,be,sampled,return,the,sampled,result,which,is,lazy,computed,upon,input,elements;override,public,iterator,t,sample,final,iterator,t,input,if,fraction,0,return,return,new,sampled,iterator,t,t,current,element,int,current,count,0,override,public,boolean,has,next,if,current,count,0,return,true,else,sampling,process,if,current,count,0,return,true,else,return,false,override,public,t,next,if,current,count,0,sampling,process,current,count,return,current,element,public,int,double,p,double,q,math,pow,math,e,p,double,t,q,1,q,random,next,double,int,k,1,t,t,random,next,double,while,t,q,k,t,t,random,next,double,return,k,private,void,skip,gap,elements,int,num,int,element,count,0,while,input,has,next,element,count,num,current,element,input,next,element,count,private,void,sampling,process,if,fraction,threshold,double,u,math,max,random,next,double,epsilon,int,gap,int,math,log,u,fraction,skip,gap,elements,gap,if,input,has,next,current,element,input,next,current,count,fraction,else,while,input,has,next,current,element,input,next,current,count,poisson,distribution,sample,if,current,count,0,break
PoissonSampler -> @Override 	public Iterator<T> sample(final Iterator<T> input);1500387231;Sample the input elements, for each input element, generate its count following a poisson_distribution.__@param input Elements to be sampled._@return The sampled result which is lazy computed upon input elements.;@Override_	public Iterator<T> sample(final Iterator<T> input) {_		if (fraction == 0) {_			return emptyIterable__		}__		return new SampledIterator<T>() {_			T currentElement__			int currentCount = 0___			@Override_			public boolean hasNext() {_				if (currentCount > 0) {_					return true__				} else {_					samplingProcess()__					if (currentCount > 0) {_						return true__					} else {_						return false__					}_				}_			}__			@Override_			public T next() {_				if (currentCount <= 0) {_					samplingProcess()__				}_				currentCount--__				return currentElement__			}__			public int poisson_ge1(double p) {_				_				double q = Math.pow(Math.E, -p)__				_				double t = q + (1 - q) * random.nextDouble()__				int k = 1__				_				t = t * random.nextDouble()__				while (t > q) {_					k++__					t = t * random.nextDouble()__				}_				return k__			}__			private void skipGapElements(int num) {_				_				int elementCount = 0__				while (input.hasNext() && elementCount < num) {_					currentElement = input.next()__					elementCount++__				}_			}__			private void samplingProcess() {_				if (fraction <= THRESHOLD) {_					double u = Math.max(random.nextDouble(), EPSILON)__					int gap = (int) (Math.log(u) / -fraction)__					skipGapElements(gap)__					if (input.hasNext()) {_						currentElement = input.next()__						currentCount = poisson_ge1(fraction)__					}_				} else {_					while (input.hasNext()) {_						currentElement = input.next()__						currentCount = poissonDistribution.sample()__						if (currentCount > 0) {_							break__						}_					}_				}_			}_		}__	};sample,the,input,elements,for,each,input,element,generate,its,count,following,a,poisson,distribution,param,input,elements,to,be,sampled,return,the,sampled,result,which,is,lazy,computed,upon,input,elements;override,public,iterator,t,sample,final,iterator,t,input,if,fraction,0,return,empty,iterable,return,new,sampled,iterator,t,t,current,element,int,current,count,0,override,public,boolean,has,next,if,current,count,0,return,true,else,sampling,process,if,current,count,0,return,true,else,return,false,override,public,t,next,if,current,count,0,sampling,process,current,count,return,current,element,public,int,double,p,double,q,math,pow,math,e,p,double,t,q,1,q,random,next,double,int,k,1,t,t,random,next,double,while,t,q,k,t,t,random,next,double,return,k,private,void,skip,gap,elements,int,num,int,element,count,0,while,input,has,next,element,count,num,current,element,input,next,element,count,private,void,sampling,process,if,fraction,threshold,double,u,math,max,random,next,double,epsilon,int,gap,int,math,log,u,fraction,skip,gap,elements,gap,if,input,has,next,current,element,input,next,current,count,fraction,else,while,input,has,next,current,element,input,next,current,count,poisson,distribution,sample,if,current,count,0,break
