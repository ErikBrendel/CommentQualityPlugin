commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Override public boolean hasNext() {     if (currentCount > 0) {         return true.     } else {         samplingProcess().         if (currentCount > 0) {             return true.         } else {             return false.         }     } }
false;public;0;8;;@Override public T next() {     if (currentCount <= 0) {         samplingProcess().     }     currentCount--.     return currentElement. }
false;public;1;14;;public int poisson_ge1(double p) {     // sample 'k' from Poisson(p), conditioned to k >= 1.     double q = Math.pow(Math.E, -p).     // simulate a poisson trial such that k >= 1.     double t = q + (1 - q) * random.nextDouble().     int k = 1.     // continue standard poisson generation trials.     t = t * random.nextDouble().     while (t > q) {         k++.         t = t * random.nextDouble().     }     return k. }
false;private;1;8;;private void skipGapElements(int num) {     // skip the elements that occurrence number is zero.     int elementCount = 0.     while (input.hasNext() && elementCount < num) {         currentElement = input.next().         elementCount++.     } }
false;private;0;19;;private void samplingProcess() {     if (fraction <= THRESHOLD) {         double u = Math.max(random.nextDouble(), EPSILON).         int gap = (int) (Math.log(u) / -fraction).         skipGapElements(gap).         if (input.hasNext()) {             currentElement = input.next().             currentCount = poisson_ge1(fraction).         }     } else {         while (input.hasNext()) {             currentElement = input.next().             currentCount = poissonDistribution.sample().             if (currentCount > 0) {                 break.             }         }     } }
true;public;1;78;/**  * Sample the input elements, for each input element, generate its count following a poisson  * distribution.  *  * @param input Elements to be sampled.  * @return The sampled result which is lazy computed upon input elements.  */ ;/**  * Sample the input elements, for each input element, generate its count following a poisson  * distribution.  *  * @param input Elements to be sampled.  * @return The sampled result which is lazy computed upon input elements.  */ @Override public Iterator<T> sample(final Iterator<T> input) {     if (fraction == 0) {         return emptyIterable.     }     return new SampledIterator<T>() {          T currentElement.          int currentCount = 0.          @Override         public boolean hasNext() {             if (currentCount > 0) {                 return true.             } else {                 samplingProcess().                 if (currentCount > 0) {                     return true.                 } else {                     return false.                 }             }         }          @Override         public T next() {             if (currentCount <= 0) {                 samplingProcess().             }             currentCount--.             return currentElement.         }          public int poisson_ge1(double p) {             // sample 'k' from Poisson(p), conditioned to k >= 1.             double q = Math.pow(Math.E, -p).             // simulate a poisson trial such that k >= 1.             double t = q + (1 - q) * random.nextDouble().             int k = 1.             // continue standard poisson generation trials.             t = t * random.nextDouble().             while (t > q) {                 k++.                 t = t * random.nextDouble().             }             return k.         }          private void skipGapElements(int num) {             // skip the elements that occurrence number is zero.             int elementCount = 0.             while (input.hasNext() && elementCount < num) {                 currentElement = input.next().                 elementCount++.             }         }          private void samplingProcess() {             if (fraction <= THRESHOLD) {                 double u = Math.max(random.nextDouble(), EPSILON).                 int gap = (int) (Math.log(u) / -fraction).                 skipGapElements(gap).                 if (input.hasNext()) {                     currentElement = input.next().                     currentCount = poisson_ge1(fraction).                 }             } else {                 while (input.hasNext()) {                     currentElement = input.next().                     currentCount = poissonDistribution.sample().                     if (currentCount > 0) {                         break.                     }                 }             }         }     }. }
