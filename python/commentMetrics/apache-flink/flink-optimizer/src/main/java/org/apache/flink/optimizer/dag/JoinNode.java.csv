commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Gets the contract object for this match node.  *  * @return The contract.  */ ;// ------------------------------------------------------------------------ /**  * Gets the contract object for this match node.  *  * @return The contract.  */ @Override public InnerJoinOperatorBase<?, ?, ?, ?> getOperator() {     return (InnerJoinOperatorBase<?, ?, ?, ?>) super.getOperator(). }
false;public;0;4;;@Override public String getOperatorName() {     return "Join". }
false;protected;0;4;;@Override protected List<OperatorDescriptorDual> getPossibleProperties() {     return this.dataProperties. }
false;public;1;12;;public void makeJoinWithSolutionSet(int solutionsetInputIndex) {     OperatorDescriptorDual op.     if (solutionsetInputIndex == 0) {         op = new HashJoinBuildFirstProperties(this.keys1, this.keys2).     } else if (solutionsetInputIndex == 1) {         op = new HashJoinBuildSecondProperties(this.keys1, this.keys2).     } else {         throw new IllegalArgumentException().     }     this.dataProperties = Collections.singletonList(op). }
true;protected;1;16;/**  * The default estimates build on the principle of inclusion: The smaller input key domain is included in the larger  * input key domain. We also assume that every key from the larger input has one join partner in the smaller input.  * The result cardinality is hence the larger one.  */ ;/**  * The default estimates build on the principle of inclusion: The smaller input key domain is included in the larger  * input key domain. We also assume that every key from the larger input has one join partner in the smaller input.  * The result cardinality is hence the larger one.  */ @Override protected void computeOperatorSpecificDefaultEstimates(DataStatistics statistics) {     long card1 = getFirstPredecessorNode().getEstimatedNumRecords().     long card2 = getSecondPredecessorNode().getEstimatedNumRecords().     this.estimatedNumRecords = (card1 < 0 || card2 < 0) ? -1 : Math.max(card1, card2).     if (this.estimatedNumRecords >= 0) {         float width1 = getFirstPredecessorNode().getEstimatedAvgWidthPerOutputRecord().         float width2 = getSecondPredecessorNode().getEstimatedAvgWidthPerOutputRecord().         float width = (width1 <= 0 || width2 <= 0) ? -1 : width1 + width2.         if (width > 0) {             this.estimatedOutputSize = (long) (width * this.estimatedNumRecords).         }     } }
false;private;3;73;;private List<OperatorDescriptorDual> getDataProperties(InnerJoinOperatorBase<?, ?, ?, ?> joinOperatorBase, JoinHint joinHint, Partitioner<?> customPartitioner) {     // see if an internal hint dictates the strategy to use     Configuration conf = joinOperatorBase.getParameters().     String localStrategy = conf.getString(Optimizer.HINT_LOCAL_STRATEGY, null).     if (localStrategy != null) {         final AbstractJoinDescriptor fixedDriverStrat.         if (Optimizer.HINT_LOCAL_STRATEGY_SORT_BOTH_MERGE.equals(localStrategy) || Optimizer.HINT_LOCAL_STRATEGY_SORT_FIRST_MERGE.equals(localStrategy) || Optimizer.HINT_LOCAL_STRATEGY_SORT_SECOND_MERGE.equals(localStrategy) || Optimizer.HINT_LOCAL_STRATEGY_MERGE.equals(localStrategy)) {             fixedDriverStrat = new SortMergeInnerJoinDescriptor(this.keys1, this.keys2).         } else if (Optimizer.HINT_LOCAL_STRATEGY_HASH_BUILD_FIRST.equals(localStrategy)) {             fixedDriverStrat = new HashJoinBuildFirstProperties(this.keys1, this.keys2).         } else if (Optimizer.HINT_LOCAL_STRATEGY_HASH_BUILD_SECOND.equals(localStrategy)) {             fixedDriverStrat = new HashJoinBuildSecondProperties(this.keys1, this.keys2).         } else {             throw new CompilerException("Invalid local strategy hint for match contract: " + localStrategy).         }         if (customPartitioner != null) {             fixedDriverStrat.setCustomPartitioner(customPartitioner).         }         ArrayList<OperatorDescriptorDual> list = new ArrayList<OperatorDescriptorDual>().         list.add(fixedDriverStrat).         return list.     } else {         ArrayList<OperatorDescriptorDual> list = new ArrayList<OperatorDescriptorDual>().         joinHint = joinHint == null ? JoinHint.OPTIMIZER_CHOOSES : joinHint.         switch(joinHint) {             case BROADCAST_HASH_FIRST:                 list.add(new HashJoinBuildFirstProperties(this.keys1, this.keys2, true, false, false)).                 break.             case BROADCAST_HASH_SECOND:                 list.add(new HashJoinBuildSecondProperties(this.keys1, this.keys2, false, true, false)).                 break.             case REPARTITION_HASH_FIRST:                 list.add(new HashJoinBuildFirstProperties(this.keys1, this.keys2, false, false, true)).                 break.             case REPARTITION_HASH_SECOND:                 list.add(new HashJoinBuildSecondProperties(this.keys1, this.keys2, false, false, true)).                 break.             case REPARTITION_SORT_MERGE:                 list.add(new SortMergeInnerJoinDescriptor(this.keys1, this.keys2, false, false, true)).                 break.             case OPTIMIZER_CHOOSES:                 list.add(new SortMergeInnerJoinDescriptor(this.keys1, this.keys2)).                 list.add(new HashJoinBuildFirstProperties(this.keys1, this.keys2)).                 list.add(new HashJoinBuildSecondProperties(this.keys1, this.keys2)).                 break.             default:                 throw new CompilerException("Unrecognized join hint: " + joinHint).         }         if (customPartitioner != null) {             for (OperatorDescriptorDual descr : list) {                 ((AbstractJoinDescriptor) descr).setCustomPartitioner(customPartitioner).             }         }         return list.     } }
