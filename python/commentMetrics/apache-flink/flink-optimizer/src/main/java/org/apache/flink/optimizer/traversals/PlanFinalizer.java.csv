commented;modifiers;parameterAmount;loc;comment;code
false;public;3;45;;public OptimizedPlan createFinalPlan(List<SinkPlanNode> sinks, String jobName, Plan originalPlan) {     this.memoryConsumerWeights = 0.     // traverse the graph     for (SinkPlanNode node : sinks) {         node.accept(this).     }     // assign the memory to each node     if (this.memoryConsumerWeights > 0) {         for (PlanNode node : this.allNodes) {             // assign memory to the driver strategy of the node             final int consumerWeight = node.getMemoryConsumerWeight().             if (consumerWeight > 0) {                 final double relativeMem = (double) consumerWeight / this.memoryConsumerWeights.                 node.setRelativeMemoryPerSubtask(relativeMem).                 if (Optimizer.LOG.isDebugEnabled()) {                     Optimizer.LOG.debug("Assigned " + relativeMem + " of total memory to each subtask of " + node.getProgramOperator().getName() + ".").                 }             }             // assign memory to the local and global strategies of the channels             for (Channel c : node.getInputs()) {                 if (c.getLocalStrategy().dams()) {                     final double relativeMem = 1.0 / this.memoryConsumerWeights.                     c.setRelativeMemoryLocalStrategy(relativeMem).                     if (Optimizer.LOG.isDebugEnabled()) {                         Optimizer.LOG.debug("Assigned " + relativeMem + " of total memory to each local strategy " + "instance of " + c + ".").                     }                 }                 if (c.getTempMode() != TempMode.NONE) {                     final double relativeMem = 1.0 / this.memoryConsumerWeights.                     c.setRelativeTempMemory(relativeMem).                     if (Optimizer.LOG.isDebugEnabled()) {                         Optimizer.LOG.debug("Assigned " + relativeMem + " of total memory to each instance of the temp " + "table for " + c + ".").                     }                 }             }         }     }     return new OptimizedPlan(this.sources, this.sinks, this.allNodes, jobName, originalPlan). }
false;public;1;101;;@Override public boolean preVisit(PlanNode visitable) {     // if we come here again, prevent a further descend     if (!this.allNodes.add(visitable)) {         return false.     }     if (visitable instanceof SinkPlanNode) {         this.sinks.add((SinkPlanNode) visitable).     } else if (visitable instanceof SourcePlanNode) {         this.sources.add((SourcePlanNode) visitable).     } else if (visitable instanceof BinaryUnionPlanNode) {         BinaryUnionPlanNode unionNode = (BinaryUnionPlanNode) visitable.         if (unionNode.unionsStaticAndDynamicPath()) {             unionNode.setDriverStrategy(DriverStrategy.UNION_WITH_CACHED).         }     } else if (visitable instanceof BulkPartialSolutionPlanNode) {         // tell the partial solution about the iteration node that contains it         final BulkPartialSolutionPlanNode pspn = (BulkPartialSolutionPlanNode) visitable.         final IterationPlanNode iteration = this.stackOfIterationNodes.peekLast().         // sanity check!         if (!(iteration instanceof BulkIterationPlanNode)) {             throw new CompilerException("Bug: Error finalizing the plan. " + "Cannot associate the node for a partial solutions with its containing iteration.").         }         pspn.setContainingIterationNode((BulkIterationPlanNode) iteration).     } else if (visitable instanceof WorksetPlanNode) {         // tell the partial solution about the iteration node that contains it         final WorksetPlanNode wspn = (WorksetPlanNode) visitable.         final IterationPlanNode iteration = this.stackOfIterationNodes.peekLast().         // sanity check!         if (!(iteration instanceof WorksetIterationPlanNode)) {             throw new CompilerException("Bug: Error finalizing the plan. " + "Cannot associate the node for a partial solutions with its containing iteration.").         }         wspn.setContainingIterationNode((WorksetIterationPlanNode) iteration).     } else if (visitable instanceof SolutionSetPlanNode) {         // tell the partial solution about the iteration node that contains it         final SolutionSetPlanNode sspn = (SolutionSetPlanNode) visitable.         final IterationPlanNode iteration = this.stackOfIterationNodes.peekLast().         // sanity check!         if (!(iteration instanceof WorksetIterationPlanNode)) {             throw new CompilerException("Bug: Error finalizing the plan. " + "Cannot associate the node for a partial solutions with its containing iteration.").         }         sspn.setContainingIterationNode((WorksetIterationPlanNode) iteration).     }     // one child candidate could have been referenced by multiple parents.     for (Channel conn : visitable.getInputs()) {         conn.setTarget(visitable).         conn.getSource().addOutgoingChannel(conn).     }     for (Channel c : visitable.getBroadcastInputs()) {         c.setTarget(visitable).         c.getSource().addOutgoingChannel(c).     }     // count the memory consumption     this.memoryConsumerWeights += visitable.getMemoryConsumerWeight().     for (Channel c : visitable.getInputs()) {         if (c.getLocalStrategy().dams()) {             this.memoryConsumerWeights++.         }         if (c.getTempMode() != TempMode.NONE) {             this.memoryConsumerWeights++.         }     }     for (Channel c : visitable.getBroadcastInputs()) {         if (c.getLocalStrategy().dams()) {             this.memoryConsumerWeights++.         }         if (c.getTempMode() != TempMode.NONE) {             this.memoryConsumerWeights++.         }     }     // pass the visitor to the iteration's step function     if (visitable instanceof IterationPlanNode) {         // push the iteration node onto the stack         final IterationPlanNode iterNode = (IterationPlanNode) visitable.         this.stackOfIterationNodes.addLast(iterNode).         // recurse         ((IterationPlanNode) visitable).acceptForStepFunction(this).         // pop the iteration node from the stack         this.stackOfIterationNodes.removeLast().     }     return true. }
false;public;1;2;;@Override public void postVisit(PlanNode visitable) { }
