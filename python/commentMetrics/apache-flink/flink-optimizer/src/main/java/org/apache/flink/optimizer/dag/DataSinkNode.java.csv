commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Gets the input of the sink.  *  * @return The input connection.  */ ;// -------------------------------------------------------------------------------------- /**  * Gets the input of the sink.  *  * @return The input connection.  */ public DagConnection getInputConnection() {     return this.input. }
true;public;0;7;/**  * Gets the predecessor of this node.  *  * @return The predecessor, or null, if no predecessor has been set.  */ ;/**  * Gets the predecessor of this node.  *  * @return The predecessor, or null, if no predecessor has been set.  */ public OptimizerNode getPredecessorNode() {     if (this.input != null) {         return input.getSource().     } else {         return null.     } }
true;public;0;4;/**  * Gets the operator for which this optimizer sink node was created.  *  * @return The node's underlying operator.  */ ;/**  * Gets the operator for which this optimizer sink node was created.  *  * @return The node's underlying operator.  */ @Override public GenericDataSinkBase<?> getOperator() {     return (GenericDataSinkBase<?>) super.getOperator(). }
false;public;0;4;;@Override public String getOperatorName() {     return "Data Sink". }
false;public;0;4;;@Override public List<DagConnection> getIncomingConnections() {     return Collections.singletonList(this.input). }
true;public;0;4;/**  * Gets all outgoing connections, which is an empty set for the data sink.  *  * @return An empty list.  */ ;/**  * Gets all outgoing connections, which is an empty set for the data sink.  *  * @return An empty list.  */ @Override public List<DagConnection> getOutgoingConnections() {     return Collections.emptyList(). }
false;public;2;14;;@Override public void setInput(Map<Operator<?>, OptimizerNode> contractToNode, ExecutionMode defaultExchangeMode) {     Operator<?> children = getOperator().getInput().     final OptimizerNode pred.     final DagConnection conn.     pred = contractToNode.get(children).     conn = new DagConnection(pred, this, defaultExchangeMode).     // create the connection and add it     this.input = conn.     pred.addOutgoingConnection(conn). }
true;protected;1;5;/**  * Computes the estimated outputs for the data sink. Since the sink does not modify anything, it simply  * copies the output estimates from its direct predecessor.  */ ;/**  * Computes the estimated outputs for the data sink. Since the sink does not modify anything, it simply  * copies the output estimates from its direct predecessor.  */ @Override protected void computeOperatorSpecificDefaultEstimates(DataStatistics statistics) {     this.estimatedNumRecords = getPredecessorNode().getEstimatedNumRecords().     this.estimatedOutputSize = getPredecessorNode().getEstimatedOutputSize(). }
false;public;1;20;;@Override public void computeInterestingPropertiesForInputs(CostEstimator estimator) {     final InterestingProperties iProps = new InterestingProperties().     {         final RequestedGlobalProperties partitioningProps = new RequestedGlobalProperties().         iProps.addGlobalProperties(partitioningProps).     }     {         final Ordering localOrder = getOperator().getLocalOrder().         final RequestedLocalProperties orderProps = new RequestedLocalProperties().         if (localOrder != null) {             orderProps.setOrdering(localOrder).         }         iProps.addLocalProperties(orderProps).     }     this.input.setInterestingProperties(iProps). }
false;public;0;11;;// -------------------------------------------------------------------------------------------- // Branch Handling // -------------------------------------------------------------------------------------------- @Override public void computeUnclosedBranchStack() {     if (this.openBranches != null) {         return.     }     // we need to track open branches even in the sinks, because they get "closed" when     // we build a single "root" for the data flow plan     addClosedBranches(getPredecessorNode().closedBranchingNodes).     this.openBranches = getPredecessorNode().getBranchesForParent(this.input). }
false;protected;1;5;;@Override protected List<UnclosedBranchDescriptor> getBranchesForParent(DagConnection parent) {     // return our own stack of open branches, because nothing is added     return this.openBranches. }
false;public;1;45;;// -------------------------------------------------------------------------------------------- // Recursive Optimization // -------------------------------------------------------------------------------------------- @Override public List<PlanNode> getAlternativePlans(CostEstimator estimator) {     // check if we have a cached version     if (this.cachedPlans != null) {         return this.cachedPlans.     }     // calculate alternative sub-plans for predecessor     List<? extends PlanNode> subPlans = getPredecessorNode().getAlternativePlans(estimator).     List<PlanNode> outputPlans = new ArrayList<PlanNode>().     final int parallelism = getParallelism().     final int inDop = getPredecessorNode().getParallelism().     final ExecutionMode executionMode = this.input.getDataExchangeMode().     final boolean dopChange = parallelism != inDop.     final boolean breakPipeline = this.input.isBreakingPipeline().     InterestingProperties ips = this.input.getInterestingProperties().     for (PlanNode p : subPlans) {         for (RequestedGlobalProperties gp : ips.getGlobalProperties()) {             for (RequestedLocalProperties lp : ips.getLocalProperties()) {                 Channel c = new Channel(p).                 gp.parameterizeChannel(c, dopChange, executionMode, breakPipeline).                 lp.parameterizeChannel(c).                 c.setRequiredLocalProps(lp).                 c.setRequiredGlobalProps(gp).                 // no need to check whether the created properties meet what we need in case                 // of ordering or global ordering, because the only interesting properties we have                 // are what we require                 outputPlans.add(new SinkPlanNode(this, "DataSink (" + this.getOperator().getName() + ")", c)).             }         }     }     // cost and prune the plans     for (PlanNode node : outputPlans) {         estimator.costOperator(node).     }     prunePlanAlternatives(outputPlans).     this.cachedPlans = outputPlans.     return outputPlans. }
false;public;0;4;;// -------------------------------------------------------------------------------------------- // Function Annotation Handling // -------------------------------------------------------------------------------------------- @Override public SemanticProperties getSemanticProperties() {     return new EmptySemanticProperties(). }
false;public;1;11;;// -------------------------------------------------------------------------------------------- // Miscellaneous // -------------------------------------------------------------------------------------------- @Override public void accept(Visitor<OptimizerNode> visitor) {     if (visitor.preVisit(this)) {         if (getPredecessorNode() != null) {             getPredecessorNode().accept(visitor).         } else {             throw new CompilerException().         }         visitor.postVisit(this).     } }
