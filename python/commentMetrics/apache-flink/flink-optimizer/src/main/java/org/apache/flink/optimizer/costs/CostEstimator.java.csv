# id;timestamp;commentText;codeText;commentWords;codeWords
CostEstimator -> public void costOperator(PlanNode n);1426843274;This method computes the cost of an operator. The cost is composed of cost for input shipping,_locally processing an input, and running the operator.__It requires at least that all inputs are set and have a proper ship strategy set,_which is not equal to <tt>NONE</tt>.__@param n The node to compute the costs for.;public void costOperator(PlanNode n) {_		_		final Costs totalCosts = new Costs()__		final long availableMemory = n.getGuaranteedAvailableMemory()__		_		_		for (Channel channel : n.getInputs()) {_			final Costs costs = new Costs()__			_			_			_			_			_			_			_			_			_			_			_			_			_			switch (channel.getShipStrategy()) {_			case NONE:_				throw new CompilerException(_					"Cannot determine costs: Shipping strategy has not been set for an input.")__			case FORWARD:__				break__			case PARTITION_RANDOM:_				addRandomPartitioningCost(channel, costs)__				break__			case PARTITION_HASH:_			case PARTITION_CUSTOM:_				addHashPartitioningCost(channel, costs)__				break__			case PARTITION_RANGE:_				addRangePartitionCost(channel, costs)__				break__			case BROADCAST:_				addBroadcastCost(channel, channel.getReplicationFactor(), costs)__				break__			case PARTITION_FORCED_REBALANCE:_				addRandomPartitioningCost(channel, costs)__				break__			default:_				throw new CompilerException("Unknown shipping strategy for input: " + channel.getShipStrategy())__			}_			_			switch (channel.getLocalStrategy()) {_			case NONE:_				break__			case SORT:_			case COMBININGSORT:_				addLocalSortCost(channel, costs)__				break__			default:_				throw new CompilerException("Unsupported local strategy for input: " + channel.getLocalStrategy())__			}_			_			if (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE) {_				addArtificialDamCost(channel, 0, costs)__			}_			_			_			if (channel.isOnDynamicPath()) {_				costs.multiplyWith(channel.getCostWeight())__			}_			_			totalCosts.addCosts(costs)__		} _		_		Channel firstInput = null__		Channel secondInput = null__		Costs driverCosts = new Costs()__		int costWeight = 1__		_		_		if (n.isOnDynamicPath()) {_			costWeight = n.getCostWeight()__		}_		_		_		{_			Iterator<Channel> channels = n.getInputs().iterator()__			if (channels.hasNext()) {_				firstInput = channels.next()__			}_			if (channels.hasNext()) {_				secondInput = channels.next()__			}_		}__		_		switch (n.getDriverStrategy()) {_		case NONE:_		case UNARY_NO_OP:_		case BINARY_NO_OP:	_		case COLLECTOR_MAP:_		case MAP:_		case MAP_PARTITION:_		case FLAT_MAP:_			_		case ALL_GROUP_REDUCE:_		case ALL_REDUCE:_			_			_		case CO_GROUP:_		case SORTED_GROUP_REDUCE:_		case SORTED_REDUCE:_			_			_		case SORTED_GROUP_COMBINE:_			__			_		case ALL_GROUP_COMBINE:_			_		case UNION:_			_			_			break__		case MERGE:_			addLocalMergeCost(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST:_			addHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND:_			addHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST_CACHED:_			addCachedHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND_CACHED:_			addCachedHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_FIRST:_			addBlockNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_SECOND:_			addBlockNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_FIRST:_			addStreamedNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_SECOND:_			addStreamedNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		default:_			throw new CompilerException("Unknown local strategy: " + n.getDriverStrategy().name())__		}_		_		totalCosts.addCosts(driverCosts)__		n.setCosts(totalCosts)__	};this,method,computes,the,cost,of,an,operator,the,cost,is,composed,of,cost,for,input,shipping,locally,processing,an,input,and,running,the,operator,it,requires,at,least,that,all,inputs,are,set,and,have,a,proper,ship,strategy,set,which,is,not,equal,to,tt,none,tt,param,n,the,node,to,compute,the,costs,for;public,void,cost,operator,plan,node,n,final,costs,total,costs,new,costs,final,long,available,memory,n,get,guaranteed,available,memory,for,channel,channel,n,get,inputs,final,costs,costs,new,costs,switch,channel,get,ship,strategy,case,none,throw,new,compiler,exception,cannot,determine,costs,shipping,strategy,has,not,been,set,for,an,input,case,forward,break,case,add,random,partitioning,cost,channel,costs,break,case,case,add,hash,partitioning,cost,channel,costs,break,case,add,range,partition,cost,channel,costs,break,case,broadcast,add,broadcast,cost,channel,channel,get,replication,factor,costs,break,case,add,random,partitioning,cost,channel,costs,break,default,throw,new,compiler,exception,unknown,shipping,strategy,for,input,channel,get,ship,strategy,switch,channel,get,local,strategy,case,none,break,case,sort,case,combiningsort,add,local,sort,cost,channel,costs,break,default,throw,new,compiler,exception,unsupported,local,strategy,for,input,channel,get,local,strategy,if,channel,get,temp,mode,null,channel,get,temp,mode,temp,mode,none,add,artificial,dam,cost,channel,0,costs,if,channel,is,on,dynamic,path,costs,multiply,with,channel,get,cost,weight,total,costs,add,costs,costs,channel,first,input,null,channel,second,input,null,costs,driver,costs,new,costs,int,cost,weight,1,if,n,is,on,dynamic,path,cost,weight,n,get,cost,weight,iterator,channel,channels,n,get,inputs,iterator,if,channels,has,next,first,input,channels,next,if,channels,has,next,second,input,channels,next,switch,n,get,driver,strategy,case,none,case,case,case,case,map,case,case,case,case,case,case,case,case,case,case,union,break,case,merge,add,local,merge,cost,first,input,second,input,driver,costs,cost,weight,break,case,add,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,default,throw,new,compiler,exception,unknown,local,strategy,n,get,driver,strategy,name,total,costs,add,costs,driver,costs,n,set,costs,total,costs
CostEstimator -> public void costOperator(PlanNode n);1429616249;This method computes the cost of an operator. The cost is composed of cost for input shipping,_locally processing an input, and running the operator.__It requires at least that all inputs are set and have a proper ship strategy set,_which is not equal to <tt>NONE</tt>.__@param n The node to compute the costs for.;public void costOperator(PlanNode n) {_		_		final Costs totalCosts = new Costs()__		final long availableMemory = n.getGuaranteedAvailableMemory()__		_		_		for (Channel channel : n.getInputs()) {_			final Costs costs = new Costs()__			_			_			_			_			_			_			_			_			_			_			_			_			_			switch (channel.getShipStrategy()) {_			case NONE:_				throw new CompilerException(_					"Cannot determine costs: Shipping strategy has not been set for an input.")__			case FORWARD:__				break__			case PARTITION_RANDOM:_				addRandomPartitioningCost(channel, costs)__				break__			case PARTITION_HASH:_			case PARTITION_CUSTOM:_				addHashPartitioningCost(channel, costs)__				break__			case PARTITION_RANGE:_				addRangePartitionCost(channel, costs)__				break__			case BROADCAST:_				addBroadcastCost(channel, channel.getReplicationFactor(), costs)__				break__			case PARTITION_FORCED_REBALANCE:_				addRandomPartitioningCost(channel, costs)__				break__			default:_				throw new CompilerException("Unknown shipping strategy for input: " + channel.getShipStrategy())__			}_			_			switch (channel.getLocalStrategy()) {_			case NONE:_				break__			case SORT:_			case COMBININGSORT:_				addLocalSortCost(channel, costs)__				break__			default:_				throw new CompilerException("Unsupported local strategy for input: " + channel.getLocalStrategy())__			}_			_			if (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE) {_				addArtificialDamCost(channel, 0, costs)__			}_			_			_			if (channel.isOnDynamicPath()) {_				costs.multiplyWith(channel.getCostWeight())__			}_			_			totalCosts.addCosts(costs)__		} _		_		Channel firstInput = null__		Channel secondInput = null__		Costs driverCosts = new Costs()__		int costWeight = 1__		_		_		if (n.isOnDynamicPath()) {_			costWeight = n.getCostWeight()__		}_		_		_		{_			Iterator<Channel> channels = n.getInputs().iterator()__			if (channels.hasNext()) {_				firstInput = channels.next()__			}_			if (channels.hasNext()) {_				secondInput = channels.next()__			}_		}__		_		switch (n.getDriverStrategy()) {_		case NONE:_		case UNARY_NO_OP:_		case BINARY_NO_OP:	_		case COLLECTOR_MAP:_		case MAP:_		case MAP_PARTITION:_		case FLAT_MAP:_			_		case ALL_GROUP_REDUCE:_		case ALL_REDUCE:_			_			_		case CO_GROUP:_		case CO_GROUP_RAW:_		case SORTED_GROUP_REDUCE:_		case SORTED_REDUCE:_			_			_		case SORTED_GROUP_COMBINE:_			__			_		case ALL_GROUP_COMBINE:_			_		case UNION:_			_			_			break__		case MERGE:_			addLocalMergeCost(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST:_			addHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND:_			addHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST_CACHED:_			addCachedHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND_CACHED:_			addCachedHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_FIRST:_			addBlockNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_SECOND:_			addBlockNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_FIRST:_			addStreamedNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_SECOND:_			addStreamedNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		default:_			throw new CompilerException("Unknown local strategy: " + n.getDriverStrategy().name())__		}_		_		totalCosts.addCosts(driverCosts)__		n.setCosts(totalCosts)__	};this,method,computes,the,cost,of,an,operator,the,cost,is,composed,of,cost,for,input,shipping,locally,processing,an,input,and,running,the,operator,it,requires,at,least,that,all,inputs,are,set,and,have,a,proper,ship,strategy,set,which,is,not,equal,to,tt,none,tt,param,n,the,node,to,compute,the,costs,for;public,void,cost,operator,plan,node,n,final,costs,total,costs,new,costs,final,long,available,memory,n,get,guaranteed,available,memory,for,channel,channel,n,get,inputs,final,costs,costs,new,costs,switch,channel,get,ship,strategy,case,none,throw,new,compiler,exception,cannot,determine,costs,shipping,strategy,has,not,been,set,for,an,input,case,forward,break,case,add,random,partitioning,cost,channel,costs,break,case,case,add,hash,partitioning,cost,channel,costs,break,case,add,range,partition,cost,channel,costs,break,case,broadcast,add,broadcast,cost,channel,channel,get,replication,factor,costs,break,case,add,random,partitioning,cost,channel,costs,break,default,throw,new,compiler,exception,unknown,shipping,strategy,for,input,channel,get,ship,strategy,switch,channel,get,local,strategy,case,none,break,case,sort,case,combiningsort,add,local,sort,cost,channel,costs,break,default,throw,new,compiler,exception,unsupported,local,strategy,for,input,channel,get,local,strategy,if,channel,get,temp,mode,null,channel,get,temp,mode,temp,mode,none,add,artificial,dam,cost,channel,0,costs,if,channel,is,on,dynamic,path,costs,multiply,with,channel,get,cost,weight,total,costs,add,costs,costs,channel,first,input,null,channel,second,input,null,costs,driver,costs,new,costs,int,cost,weight,1,if,n,is,on,dynamic,path,cost,weight,n,get,cost,weight,iterator,channel,channels,n,get,inputs,iterator,if,channels,has,next,first,input,channels,next,if,channels,has,next,second,input,channels,next,switch,n,get,driver,strategy,case,none,case,case,case,case,map,case,case,case,case,case,case,case,case,case,case,case,union,break,case,merge,add,local,merge,cost,first,input,second,input,driver,costs,cost,weight,break,case,add,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,default,throw,new,compiler,exception,unknown,local,strategy,n,get,driver,strategy,name,total,costs,add,costs,driver,costs,n,set,costs,total,costs
CostEstimator -> public void costOperator(PlanNode n);1441724271;This method computes the cost of an operator. The cost is composed of cost for input shipping,_locally processing an input, and running the operator.__It requires at least that all inputs are set and have a proper ship strategy set,_which is not equal to <tt>NONE</tt>.__@param n The node to compute the costs for.;public void costOperator(PlanNode n) {_		_		final Costs totalCosts = new Costs()__		final long availableMemory = n.getGuaranteedAvailableMemory()__		_		_		for (Channel channel : n.getInputs()) {_			final Costs costs = new Costs()__			_			_			_			_			_			_			_			_			_			_			_			_			_			switch (channel.getShipStrategy()) {_			case NONE:_				throw new CompilerException(_					"Cannot determine costs: Shipping strategy has not been set for an input.")__			case FORWARD:__				break__			case PARTITION_RANDOM:_				addRandomPartitioningCost(channel, costs)__				break__			case PARTITION_HASH:_			case PARTITION_CUSTOM:_				addHashPartitioningCost(channel, costs)__				break__			case PARTITION_RANGE:_				addRangePartitionCost(channel, costs)__				break__			case BROADCAST:_				addBroadcastCost(channel, channel.getReplicationFactor(), costs)__				break__			case PARTITION_FORCED_REBALANCE:_				addRandomPartitioningCost(channel, costs)__				break__			default:_				throw new CompilerException("Unknown shipping strategy for input: " + channel.getShipStrategy())__			}_			_			switch (channel.getLocalStrategy()) {_			case NONE:_				break__			case SORT:_			case COMBININGSORT:_				addLocalSortCost(channel, costs)__				break__			default:_				throw new CompilerException("Unsupported local strategy for input: " + channel.getLocalStrategy())__			}_			_			if (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE) {_				addArtificialDamCost(channel, 0, costs)__			}_			_			_			if (channel.isOnDynamicPath()) {_				costs.multiplyWith(channel.getCostWeight())__			}_			_			totalCosts.addCosts(costs)__		} _		_		Channel firstInput = null__		Channel secondInput = null__		Costs driverCosts = new Costs()__		int costWeight = 1__		_		_		if (n.isOnDynamicPath()) {_			costWeight = n.getCostWeight()__		}_		_		_		{_			Iterator<Channel> channels = n.getInputs().iterator()__			if (channels.hasNext()) {_				firstInput = channels.next()__			}_			if (channels.hasNext()) {_				secondInput = channels.next()__			}_		}__		_		switch (n.getDriverStrategy()) {_		case NONE:_		case UNARY_NO_OP:_		case BINARY_NO_OP:	_		case COLLECTOR_MAP:_		case MAP:_		case MAP_PARTITION:_		case FLAT_MAP:_			_		case ALL_GROUP_REDUCE:_		case ALL_REDUCE:_			_			_		case CO_GROUP:_		case CO_GROUP_RAW:_		case SORTED_GROUP_REDUCE:_		case SORTED_REDUCE:_			_			_		case SORTED_GROUP_COMBINE:_			__			_		case ALL_GROUP_COMBINE:_			_		case UNION:_			_			_			break__		case INNER_MERGE:_			addLocalMergeCost(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST:_			addHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND:_			addHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST_CACHED:_			addCachedHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND_CACHED:_			addCachedHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_FIRST:_			addBlockNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_SECOND:_			addBlockNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_FIRST:_			addStreamedNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_SECOND:_			addStreamedNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		default:_			throw new CompilerException("Unknown local strategy: " + n.getDriverStrategy().name())__		}_		_		totalCosts.addCosts(driverCosts)__		n.setCosts(totalCosts)__	};this,method,computes,the,cost,of,an,operator,the,cost,is,composed,of,cost,for,input,shipping,locally,processing,an,input,and,running,the,operator,it,requires,at,least,that,all,inputs,are,set,and,have,a,proper,ship,strategy,set,which,is,not,equal,to,tt,none,tt,param,n,the,node,to,compute,the,costs,for;public,void,cost,operator,plan,node,n,final,costs,total,costs,new,costs,final,long,available,memory,n,get,guaranteed,available,memory,for,channel,channel,n,get,inputs,final,costs,costs,new,costs,switch,channel,get,ship,strategy,case,none,throw,new,compiler,exception,cannot,determine,costs,shipping,strategy,has,not,been,set,for,an,input,case,forward,break,case,add,random,partitioning,cost,channel,costs,break,case,case,add,hash,partitioning,cost,channel,costs,break,case,add,range,partition,cost,channel,costs,break,case,broadcast,add,broadcast,cost,channel,channel,get,replication,factor,costs,break,case,add,random,partitioning,cost,channel,costs,break,default,throw,new,compiler,exception,unknown,shipping,strategy,for,input,channel,get,ship,strategy,switch,channel,get,local,strategy,case,none,break,case,sort,case,combiningsort,add,local,sort,cost,channel,costs,break,default,throw,new,compiler,exception,unsupported,local,strategy,for,input,channel,get,local,strategy,if,channel,get,temp,mode,null,channel,get,temp,mode,temp,mode,none,add,artificial,dam,cost,channel,0,costs,if,channel,is,on,dynamic,path,costs,multiply,with,channel,get,cost,weight,total,costs,add,costs,costs,channel,first,input,null,channel,second,input,null,costs,driver,costs,new,costs,int,cost,weight,1,if,n,is,on,dynamic,path,cost,weight,n,get,cost,weight,iterator,channel,channels,n,get,inputs,iterator,if,channels,has,next,first,input,channels,next,if,channels,has,next,second,input,channels,next,switch,n,get,driver,strategy,case,none,case,case,case,case,map,case,case,case,case,case,case,case,case,case,case,case,union,break,case,add,local,merge,cost,first,input,second,input,driver,costs,cost,weight,break,case,add,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,default,throw,new,compiler,exception,unknown,local,strategy,n,get,driver,strategy,name,total,costs,add,costs,driver,costs,n,set,costs,total,costs
CostEstimator -> public void costOperator(PlanNode n);1444400361;This method computes the cost of an operator. The cost is composed of cost for input shipping,_locally processing an input, and running the operator.__It requires at least that all inputs are set and have a proper ship strategy set,_which is not equal to <tt>NONE</tt>.__@param n The node to compute the costs for.;public void costOperator(PlanNode n) {_		_		final Costs totalCosts = new Costs()__		final long availableMemory = n.getGuaranteedAvailableMemory()__		_		_		for (Channel channel : n.getInputs()) {_			final Costs costs = new Costs()__			_			_			_			_			_			_			_			_			_			_			_			_			_			switch (channel.getShipStrategy()) {_			case NONE:_				throw new CompilerException(_					"Cannot determine costs: Shipping strategy has not been set for an input.")__			case FORWARD:__				break__			case PARTITION_RANDOM:_				addRandomPartitioningCost(channel, costs)__				break__			case PARTITION_HASH:_			case PARTITION_CUSTOM:_				addHashPartitioningCost(channel, costs)__				break__			case PARTITION_RANGE:_				addRangePartitionCost(channel, costs)__				break__			case BROADCAST:_				addBroadcastCost(channel, channel.getReplicationFactor(), costs)__				break__			case PARTITION_FORCED_REBALANCE:_				addRandomPartitioningCost(channel, costs)__				break__			default:_				throw new CompilerException("Unknown shipping strategy for input: " + channel.getShipStrategy())__			}_			_			switch (channel.getLocalStrategy()) {_			case NONE:_				break__			case SORT:_			case COMBININGSORT:_				addLocalSortCost(channel, costs)__				break__			default:_				throw new CompilerException("Unsupported local strategy for input: " + channel.getLocalStrategy())__			}_			_			if (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE) {_				addArtificialDamCost(channel, 0, costs)__			}_			_			_			if (channel.isOnDynamicPath()) {_				costs.multiplyWith(channel.getCostWeight())__			}_			_			totalCosts.addCosts(costs)__		} _		_		Channel firstInput = null__		Channel secondInput = null__		Costs driverCosts = new Costs()__		int costWeight = 1__		_		_		if (n.isOnDynamicPath()) {_			costWeight = n.getCostWeight()__		}_		_		_		{_			Iterator<Channel> channels = n.getInputs().iterator()__			if (channels.hasNext()) {_				firstInput = channels.next()__			}_			if (channels.hasNext()) {_				secondInput = channels.next()__			}_		}__		_		switch (n.getDriverStrategy()) {_		case NONE:_		case UNARY_NO_OP:_		case BINARY_NO_OP:	_		case COLLECTOR_MAP:_		case MAP:_		case MAP_PARTITION:_		case FLAT_MAP:_			_		case ALL_GROUP_REDUCE:_		case ALL_REDUCE:_			_			_		case CO_GROUP:_		case CO_GROUP_RAW:_		case SORTED_GROUP_REDUCE:_		case SORTED_REDUCE:_			_			_		case SORTED_GROUP_COMBINE:_			__			_		case ALL_GROUP_COMBINE:_			_		case UNION:_			_			_			break__		case INNER_MERGE:_		case FULL_OUTER_MERGE:_		case LEFT_OUTER_MERGE:_		case RIGHT_OUTER_MERGE:_			addLocalMergeCost(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST:_			addHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND:_			addHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST_CACHED:_			addCachedHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND_CACHED:_			addCachedHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_FIRST:_			addBlockNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_SECOND:_			addBlockNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_FIRST:_			addStreamedNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_SECOND:_			addStreamedNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		default:_			throw new CompilerException("Unknown local strategy: " + n.getDriverStrategy().name())__		}_		_		totalCosts.addCosts(driverCosts)__		n.setCosts(totalCosts)__	};this,method,computes,the,cost,of,an,operator,the,cost,is,composed,of,cost,for,input,shipping,locally,processing,an,input,and,running,the,operator,it,requires,at,least,that,all,inputs,are,set,and,have,a,proper,ship,strategy,set,which,is,not,equal,to,tt,none,tt,param,n,the,node,to,compute,the,costs,for;public,void,cost,operator,plan,node,n,final,costs,total,costs,new,costs,final,long,available,memory,n,get,guaranteed,available,memory,for,channel,channel,n,get,inputs,final,costs,costs,new,costs,switch,channel,get,ship,strategy,case,none,throw,new,compiler,exception,cannot,determine,costs,shipping,strategy,has,not,been,set,for,an,input,case,forward,break,case,add,random,partitioning,cost,channel,costs,break,case,case,add,hash,partitioning,cost,channel,costs,break,case,add,range,partition,cost,channel,costs,break,case,broadcast,add,broadcast,cost,channel,channel,get,replication,factor,costs,break,case,add,random,partitioning,cost,channel,costs,break,default,throw,new,compiler,exception,unknown,shipping,strategy,for,input,channel,get,ship,strategy,switch,channel,get,local,strategy,case,none,break,case,sort,case,combiningsort,add,local,sort,cost,channel,costs,break,default,throw,new,compiler,exception,unsupported,local,strategy,for,input,channel,get,local,strategy,if,channel,get,temp,mode,null,channel,get,temp,mode,temp,mode,none,add,artificial,dam,cost,channel,0,costs,if,channel,is,on,dynamic,path,costs,multiply,with,channel,get,cost,weight,total,costs,add,costs,costs,channel,first,input,null,channel,second,input,null,costs,driver,costs,new,costs,int,cost,weight,1,if,n,is,on,dynamic,path,cost,weight,n,get,cost,weight,iterator,channel,channels,n,get,inputs,iterator,if,channels,has,next,first,input,channels,next,if,channels,has,next,second,input,channels,next,switch,n,get,driver,strategy,case,none,case,case,case,case,map,case,case,case,case,case,case,case,case,case,case,case,union,break,case,case,case,case,add,local,merge,cost,first,input,second,input,driver,costs,cost,weight,break,case,add,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,default,throw,new,compiler,exception,unknown,local,strategy,n,get,driver,strategy,name,total,costs,add,costs,driver,costs,n,set,costs,total,costs
CostEstimator -> public void costOperator(PlanNode n);1445264262;This method computes the cost of an operator. The cost is composed of cost for input shipping,_locally processing an input, and running the operator.__It requires at least that all inputs are set and have a proper ship strategy set,_which is not equal to <tt>NONE</tt>.__@param n The node to compute the costs for.;public void costOperator(PlanNode n) {_		_		final Costs totalCosts = new Costs()__		final long availableMemory = n.getGuaranteedAvailableMemory()__		_		_		for (Channel channel : n.getInputs()) {_			final Costs costs = new Costs()__			_			_			_			_			_			_			_			_			_			_			_			_			_			switch (channel.getShipStrategy()) {_			case NONE:_				throw new CompilerException(_					"Cannot determine costs: Shipping strategy has not been set for an input.")__			case FORWARD:__				break__			case PARTITION_RANDOM:_				addRandomPartitioningCost(channel, costs)__				break__			case PARTITION_HASH:_			case PARTITION_CUSTOM:_				addHashPartitioningCost(channel, costs)__				break__			case PARTITION_RANGE:_				addRangePartitionCost(channel, costs)__				break__			case BROADCAST:_				addBroadcastCost(channel, channel.getReplicationFactor(), costs)__				break__			case PARTITION_FORCED_REBALANCE:_				addRandomPartitioningCost(channel, costs)__				break__			default:_				throw new CompilerException("Unknown shipping strategy for input: " + channel.getShipStrategy())__			}_			_			switch (channel.getLocalStrategy()) {_			case NONE:_				break__			case SORT:_			case COMBININGSORT:_				addLocalSortCost(channel, costs)__				break__			default:_				throw new CompilerException("Unsupported local strategy for input: " + channel.getLocalStrategy())__			}_			_			if (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE) {_				addArtificialDamCost(channel, 0, costs)__			}_			_			_			if (channel.isOnDynamicPath()) {_				costs.multiplyWith(channel.getCostWeight())__			}_			_			totalCosts.addCosts(costs)__		} _		_		Channel firstInput = null__		Channel secondInput = null__		Costs driverCosts = new Costs()__		int costWeight = 1__		_		_		if (n.isOnDynamicPath()) {_			costWeight = n.getCostWeight()__		}_		_		_		{_			Iterator<Channel> channels = n.getInputs().iterator()__			if (channels.hasNext()) {_				firstInput = channels.next()__			}_			if (channels.hasNext()) {_				secondInput = channels.next()__			}_		}__		_		switch (n.getDriverStrategy()) {_		case NONE:_		case UNARY_NO_OP:_		case BINARY_NO_OP:	_		case COLLECTOR_MAP:_		case MAP:_		case MAP_PARTITION:_		case FLAT_MAP:_			_		case ALL_GROUP_REDUCE:_		case ALL_REDUCE:_			_			_		case CO_GROUP:_		case CO_GROUP_RAW:_		case SORTED_GROUP_REDUCE:_		case SORTED_REDUCE:_			_			_		case SORTED_GROUP_COMBINE:_			__			_		case ALL_GROUP_COMBINE:_			_		case UNION:_			_			_			break__		case INNER_MERGE:_		case FULL_OUTER_MERGE:_		case LEFT_OUTER_MERGE:_		case RIGHT_OUTER_MERGE:_			addLocalMergeCost(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST:_		case RIGHT_HYBRIDHASH_BUILD_FIRST:_			addHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND:_		case LEFT_HYBRIDHASH_BUILD_SECOND:_			addHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST_CACHED:_			addCachedHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND_CACHED:_			addCachedHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_FIRST:_			addBlockNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_SECOND:_			addBlockNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_FIRST:_			addStreamedNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_SECOND:_			addStreamedNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		default:_			throw new CompilerException("Unknown local strategy: " + n.getDriverStrategy().name())__		}_		_		totalCosts.addCosts(driverCosts)__		n.setCosts(totalCosts)__	};this,method,computes,the,cost,of,an,operator,the,cost,is,composed,of,cost,for,input,shipping,locally,processing,an,input,and,running,the,operator,it,requires,at,least,that,all,inputs,are,set,and,have,a,proper,ship,strategy,set,which,is,not,equal,to,tt,none,tt,param,n,the,node,to,compute,the,costs,for;public,void,cost,operator,plan,node,n,final,costs,total,costs,new,costs,final,long,available,memory,n,get,guaranteed,available,memory,for,channel,channel,n,get,inputs,final,costs,costs,new,costs,switch,channel,get,ship,strategy,case,none,throw,new,compiler,exception,cannot,determine,costs,shipping,strategy,has,not,been,set,for,an,input,case,forward,break,case,add,random,partitioning,cost,channel,costs,break,case,case,add,hash,partitioning,cost,channel,costs,break,case,add,range,partition,cost,channel,costs,break,case,broadcast,add,broadcast,cost,channel,channel,get,replication,factor,costs,break,case,add,random,partitioning,cost,channel,costs,break,default,throw,new,compiler,exception,unknown,shipping,strategy,for,input,channel,get,ship,strategy,switch,channel,get,local,strategy,case,none,break,case,sort,case,combiningsort,add,local,sort,cost,channel,costs,break,default,throw,new,compiler,exception,unsupported,local,strategy,for,input,channel,get,local,strategy,if,channel,get,temp,mode,null,channel,get,temp,mode,temp,mode,none,add,artificial,dam,cost,channel,0,costs,if,channel,is,on,dynamic,path,costs,multiply,with,channel,get,cost,weight,total,costs,add,costs,costs,channel,first,input,null,channel,second,input,null,costs,driver,costs,new,costs,int,cost,weight,1,if,n,is,on,dynamic,path,cost,weight,n,get,cost,weight,iterator,channel,channels,n,get,inputs,iterator,if,channels,has,next,first,input,channels,next,if,channels,has,next,second,input,channels,next,switch,n,get,driver,strategy,case,none,case,case,case,case,map,case,case,case,case,case,case,case,case,case,case,case,union,break,case,case,case,case,add,local,merge,cost,first,input,second,input,driver,costs,cost,weight,break,case,case,add,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,case,add,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,default,throw,new,compiler,exception,unknown,local,strategy,n,get,driver,strategy,name,total,costs,add,costs,driver,costs,n,set,costs,total,costs
CostEstimator -> public void costOperator(PlanNode n);1448491524;This method computes the cost of an operator. The cost is composed of cost for input shipping,_locally processing an input, and running the operator.__It requires at least that all inputs are set and have a proper ship strategy set,_which is not equal to <tt>NONE</tt>.__@param n The node to compute the costs for.;public void costOperator(PlanNode n) {_		_		final Costs totalCosts = new Costs()__		final long availableMemory = n.getGuaranteedAvailableMemory()__		_		_		for (Channel channel : n.getInputs()) {_			final Costs costs = new Costs()__			_			_			_			_			_			_			_			_			_			_			_			_			_			switch (channel.getShipStrategy()) {_			case NONE:_				throw new CompilerException(_					"Cannot determine costs: Shipping strategy has not been set for an input.")__			case FORWARD:__				break__			case PARTITION_RANDOM:_				addRandomPartitioningCost(channel, costs)__				break__			case PARTITION_HASH:_			case PARTITION_CUSTOM:_				addHashPartitioningCost(channel, costs)__				break__			case PARTITION_RANGE:_				addRangePartitionCost(channel, costs)__				break__			case BROADCAST:_				addBroadcastCost(channel, channel.getReplicationFactor(), costs)__				break__			case PARTITION_FORCED_REBALANCE:_				addRandomPartitioningCost(channel, costs)__				break__			default:_				throw new CompilerException("Unknown shipping strategy for input: " + channel.getShipStrategy())__			}_			_			switch (channel.getLocalStrategy()) {_			case NONE:_				break__			case SORT:_			case COMBININGSORT:_				addLocalSortCost(channel, costs)__				break__			default:_				throw new CompilerException("Unsupported local strategy for input: " + channel.getLocalStrategy())__			}_			_			if (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE) {_				addArtificialDamCost(channel, 0, costs)__			}_			_			_			if (channel.isOnDynamicPath()) {_				costs.multiplyWith(channel.getCostWeight())__			}_			_			totalCosts.addCosts(costs)__		} _		_		Channel firstInput = null__		Channel secondInput = null__		Costs driverCosts = new Costs()__		int costWeight = 1__		_		_		if (n.isOnDynamicPath()) {_			costWeight = n.getCostWeight()__		}_		_		_		{_			Iterator<Channel> channels = n.getInputs().iterator()__			if (channels.hasNext()) {_				firstInput = channels.next()__			}_			if (channels.hasNext()) {_				secondInput = channels.next()__			}_		}__		_		switch (n.getDriverStrategy()) {_		case NONE:_		case UNARY_NO_OP:_		case BINARY_NO_OP:_		case MAP:_		case MAP_PARTITION:_		case FLAT_MAP:_			_		case ALL_GROUP_REDUCE:_		case ALL_REDUCE:_			_			_		case CO_GROUP:_		case CO_GROUP_RAW:_		case SORTED_GROUP_REDUCE:_		case SORTED_REDUCE:_			_			_		case SORTED_GROUP_COMBINE:_			__			_		case ALL_GROUP_COMBINE:_			_		case UNION:_			_			_			break__		case INNER_MERGE:_		case FULL_OUTER_MERGE:_		case LEFT_OUTER_MERGE:_		case RIGHT_OUTER_MERGE:_			addLocalMergeCost(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST:_		case RIGHT_HYBRIDHASH_BUILD_FIRST:_			addHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND:_		case LEFT_HYBRIDHASH_BUILD_SECOND:_			addHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST_CACHED:_			addCachedHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND_CACHED:_			addCachedHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_FIRST:_			addBlockNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_SECOND:_			addBlockNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_FIRST:_			addStreamedNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_SECOND:_			addStreamedNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		default:_			throw new CompilerException("Unknown local strategy: " + n.getDriverStrategy().name())__		}_		_		totalCosts.addCosts(driverCosts)__		n.setCosts(totalCosts)__	};this,method,computes,the,cost,of,an,operator,the,cost,is,composed,of,cost,for,input,shipping,locally,processing,an,input,and,running,the,operator,it,requires,at,least,that,all,inputs,are,set,and,have,a,proper,ship,strategy,set,which,is,not,equal,to,tt,none,tt,param,n,the,node,to,compute,the,costs,for;public,void,cost,operator,plan,node,n,final,costs,total,costs,new,costs,final,long,available,memory,n,get,guaranteed,available,memory,for,channel,channel,n,get,inputs,final,costs,costs,new,costs,switch,channel,get,ship,strategy,case,none,throw,new,compiler,exception,cannot,determine,costs,shipping,strategy,has,not,been,set,for,an,input,case,forward,break,case,add,random,partitioning,cost,channel,costs,break,case,case,add,hash,partitioning,cost,channel,costs,break,case,add,range,partition,cost,channel,costs,break,case,broadcast,add,broadcast,cost,channel,channel,get,replication,factor,costs,break,case,add,random,partitioning,cost,channel,costs,break,default,throw,new,compiler,exception,unknown,shipping,strategy,for,input,channel,get,ship,strategy,switch,channel,get,local,strategy,case,none,break,case,sort,case,combiningsort,add,local,sort,cost,channel,costs,break,default,throw,new,compiler,exception,unsupported,local,strategy,for,input,channel,get,local,strategy,if,channel,get,temp,mode,null,channel,get,temp,mode,temp,mode,none,add,artificial,dam,cost,channel,0,costs,if,channel,is,on,dynamic,path,costs,multiply,with,channel,get,cost,weight,total,costs,add,costs,costs,channel,first,input,null,channel,second,input,null,costs,driver,costs,new,costs,int,cost,weight,1,if,n,is,on,dynamic,path,cost,weight,n,get,cost,weight,iterator,channel,channels,n,get,inputs,iterator,if,channels,has,next,first,input,channels,next,if,channels,has,next,second,input,channels,next,switch,n,get,driver,strategy,case,none,case,case,case,map,case,case,case,case,case,case,case,case,case,case,case,union,break,case,case,case,case,add,local,merge,cost,first,input,second,input,driver,costs,cost,weight,break,case,case,add,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,case,add,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,default,throw,new,compiler,exception,unknown,local,strategy,n,get,driver,strategy,name,total,costs,add,costs,driver,costs,n,set,costs,total,costs
CostEstimator -> public void costOperator(PlanNode n);1453866659;This method computes the cost of an operator. The cost is composed of cost for input shipping,_locally processing an input, and running the operator.__It requires at least that all inputs are set and have a proper ship strategy set,_which is not equal to <tt>NONE</tt>.__@param n The node to compute the costs for.;public void costOperator(PlanNode n) {_		_		final Costs totalCosts = new Costs()__		final long availableMemory = n.getGuaranteedAvailableMemory()__		_		_		for (Channel channel : n.getInputs()) {_			final Costs costs = new Costs()__			_			_			_			_			_			_			_			_			_			_			_			_			_			switch (channel.getShipStrategy()) {_			case NONE:_				throw new CompilerException(_					"Cannot determine costs: Shipping strategy has not been set for an input.")__			case FORWARD:__				break__			case PARTITION_RANDOM:_				addRandomPartitioningCost(channel, costs)__				break__			case PARTITION_HASH:_			case PARTITION_CUSTOM:_				addHashPartitioningCost(channel, costs)__				break__			case PARTITION_RANGE:_				addRangePartitionCost(channel, costs)__				break__			case BROADCAST:_				addBroadcastCost(channel, channel.getReplicationFactor(), costs)__				break__			case PARTITION_FORCED_REBALANCE:_				addRandomPartitioningCost(channel, costs)__				break__			default:_				throw new CompilerException("Unknown shipping strategy for input: " + channel.getShipStrategy())__			}_			_			switch (channel.getLocalStrategy()) {_			case NONE:_				break__			case SORT:_			case COMBININGSORT:_				addLocalSortCost(channel, costs)__				break__			default:_				throw new CompilerException("Unsupported local strategy for input: " + channel.getLocalStrategy())__			}_			_			if (channel.getTempMode() != null && channel.getTempMode() != TempMode.NONE) {_				addArtificialDamCost(channel, 0, costs)__			}_			_			_			if (channel.isOnDynamicPath()) {_				costs.multiplyWith(channel.getCostWeight())__			}_			_			totalCosts.addCosts(costs)__		} _		_		Channel firstInput = null__		Channel secondInput = null__		Costs driverCosts = new Costs()__		int costWeight = 1__		_		_		if (n.isOnDynamicPath()) {_			costWeight = n.getCostWeight()__		}_		_		_		{_			Iterator<Channel> channels = n.getInputs().iterator()__			if (channels.hasNext()) {_				firstInput = channels.next()__			}_			if (channels.hasNext()) {_				secondInput = channels.next()__			}_		}__		_		switch (n.getDriverStrategy()) {_		case NONE:_		case UNARY_NO_OP:_		case BINARY_NO_OP:_		case MAP:_		case MAP_PARTITION:_		case FLAT_MAP:_			_		case ALL_GROUP_REDUCE:_		case ALL_REDUCE:_			_			_		case CO_GROUP:_		case CO_GROUP_RAW:_		case SORTED_GROUP_REDUCE:_		case SORTED_REDUCE:_			_			_		case SORTED_GROUP_COMBINE:_			__			_		case ALL_GROUP_COMBINE:_			_		case UNION:_			_			_			break__		case INNER_MERGE:_		case FULL_OUTER_MERGE:_		case LEFT_OUTER_MERGE:_		case RIGHT_OUTER_MERGE:_			addLocalMergeCost(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST:_		case RIGHT_HYBRIDHASH_BUILD_FIRST:_		case LEFT_HYBRIDHASH_BUILD_FIRST:_		case FULL_OUTER_HYBRIDHASH_BUILD_FIRST:_			addHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND:_		case LEFT_HYBRIDHASH_BUILD_SECOND:_		case RIGHT_HYBRIDHASH_BUILD_SECOND:_		case FULL_OUTER_HYBRIDHASH_BUILD_SECOND:_			addHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_FIRST_CACHED:_			addCachedHybridHashCosts(firstInput, secondInput, driverCosts, costWeight)__			break__		case HYBRIDHASH_BUILD_SECOND_CACHED:_			addCachedHybridHashCosts(secondInput, firstInput, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_FIRST:_			addBlockNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_BLOCKED_OUTER_SECOND:_			addBlockNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_FIRST:_			addStreamedNestedLoopsCosts(firstInput, secondInput, availableMemory, driverCosts, costWeight)__			break__		case NESTEDLOOP_STREAMED_OUTER_SECOND:_			addStreamedNestedLoopsCosts(secondInput, firstInput, availableMemory, driverCosts, costWeight)__			break__		default:_			throw new CompilerException("Unknown local strategy: " + n.getDriverStrategy().name())__		}_		_		totalCosts.addCosts(driverCosts)__		n.setCosts(totalCosts)__	};this,method,computes,the,cost,of,an,operator,the,cost,is,composed,of,cost,for,input,shipping,locally,processing,an,input,and,running,the,operator,it,requires,at,least,that,all,inputs,are,set,and,have,a,proper,ship,strategy,set,which,is,not,equal,to,tt,none,tt,param,n,the,node,to,compute,the,costs,for;public,void,cost,operator,plan,node,n,final,costs,total,costs,new,costs,final,long,available,memory,n,get,guaranteed,available,memory,for,channel,channel,n,get,inputs,final,costs,costs,new,costs,switch,channel,get,ship,strategy,case,none,throw,new,compiler,exception,cannot,determine,costs,shipping,strategy,has,not,been,set,for,an,input,case,forward,break,case,add,random,partitioning,cost,channel,costs,break,case,case,add,hash,partitioning,cost,channel,costs,break,case,add,range,partition,cost,channel,costs,break,case,broadcast,add,broadcast,cost,channel,channel,get,replication,factor,costs,break,case,add,random,partitioning,cost,channel,costs,break,default,throw,new,compiler,exception,unknown,shipping,strategy,for,input,channel,get,ship,strategy,switch,channel,get,local,strategy,case,none,break,case,sort,case,combiningsort,add,local,sort,cost,channel,costs,break,default,throw,new,compiler,exception,unsupported,local,strategy,for,input,channel,get,local,strategy,if,channel,get,temp,mode,null,channel,get,temp,mode,temp,mode,none,add,artificial,dam,cost,channel,0,costs,if,channel,is,on,dynamic,path,costs,multiply,with,channel,get,cost,weight,total,costs,add,costs,costs,channel,first,input,null,channel,second,input,null,costs,driver,costs,new,costs,int,cost,weight,1,if,n,is,on,dynamic,path,cost,weight,n,get,cost,weight,iterator,channel,channels,n,get,inputs,iterator,if,channels,has,next,first,input,channels,next,if,channels,has,next,second,input,channels,next,switch,n,get,driver,strategy,case,none,case,case,case,map,case,case,case,case,case,case,case,case,case,case,case,union,break,case,case,case,case,add,local,merge,cost,first,input,second,input,driver,costs,cost,weight,break,case,case,case,case,add,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,case,case,case,add,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,first,input,second,input,driver,costs,cost,weight,break,case,add,cached,hybrid,hash,costs,second,input,first,input,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,block,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,first,input,second,input,available,memory,driver,costs,cost,weight,break,case,add,streamed,nested,loops,costs,second,input,first,input,available,memory,driver,costs,cost,weight,break,default,throw,new,compiler,exception,unknown,local,strategy,n,get,driver,strategy,name,total,costs,add,costs,driver,costs,n,set,costs,total,costs
