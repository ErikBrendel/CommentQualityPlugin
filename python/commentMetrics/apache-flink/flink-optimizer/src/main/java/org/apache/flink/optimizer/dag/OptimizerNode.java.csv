commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;0;1;/**  * Gets the name of this node, which is the name of the function/operator, or  * data source / data sink.  *  * @return The node name.  */ ;// ------------------------------------------------------------------------ // Methods specific to unary- / binary- / special nodes // ------------------------------------------------------------------------ /**  * Gets the name of this node, which is the name of the function/operator, or  * data source / data sink.  *  * @return The node name.  */ public abstract String getOperatorName().
true;public,abstract;2;2;/**  * This function connects the predecessors to this operator.  *  * @param operatorToNode The map from program operators to optimizer nodes.  * @param defaultExchangeMode The data exchange mode to use, if the operator does not  *                            specify one.  */ ;/**  * This function connects the predecessors to this operator.  *  * @param operatorToNode The map from program operators to optimizer nodes.  * @param defaultExchangeMode The data exchange mode to use, if the operator does not  *                            specify one.  */ public abstract void setInput(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode).
true;public;2;18;/**  * This function connects the operators that produce the broadcast inputs to this operator.  *  * @param operatorToNode The map from program operators to optimizer nodes.  * @param defaultExchangeMode The data exchange mode to use, if the operator does not  *                            specify one.  *  * @throws CompilerException  */ ;/**  * This function connects the operators that produce the broadcast inputs to this operator.  *  * @param operatorToNode The map from program operators to optimizer nodes.  * @param defaultExchangeMode The data exchange mode to use, if the operator does not  *                            specify one.  *  * @throws CompilerException  */ public void setBroadcastInputs(Map<Operator<?>, OptimizerNode> operatorToNode, ExecutionMode defaultExchangeMode) {     // skip for Operators that don't support broadcast variables     if (!(getOperator() instanceof AbstractUdfOperator<?, ?>)) {         return.     }     // get all broadcast inputs     AbstractUdfOperator<?, ?> operator = ((AbstractUdfOperator<?, ?>) getOperator()).     // create connections and add them     for (Map.Entry<String, Operator<?>> input : operator.getBroadcastInputs().entrySet()) {         OptimizerNode predecessor = operatorToNode.get(input.getValue()).         DagConnection connection = new DagConnection(predecessor, this, ShipStrategyType.BROADCAST, defaultExchangeMode).         addBroadcastConnection(input.getKey(), connection).         predecessor.addOutgoingConnection(connection).     } }
true;public,abstract;0;1;/**  * Gets all incoming connections of this node.  * This method needs to be overridden by subclasses to return the children.  *  * @return The list of incoming connections.  */ ;/**  * Gets all incoming connections of this node.  * This method needs to be overridden by subclasses to return the children.  *  * @return The list of incoming connections.  */ public abstract List<DagConnection> getIncomingConnections().
true;public,abstract;1;1;/**  * Tells the node to compute the interesting properties for its inputs. The interesting properties  * for the node itself must have been computed before.  * The node must then see how many of interesting properties it preserves and add its own.  *  * @param estimator The {@code CostEstimator} instance to use for plan cost estimation.  */ ;/**  * Tells the node to compute the interesting properties for its inputs. The interesting properties  * for the node itself must have been computed before.  * The node must then see how many of interesting properties it preserves and add its own.  *  * @param estimator The {@code CostEstimator} instance to use for plan cost estimation.  */ public abstract void computeInterestingPropertiesForInputs(CostEstimator estimator).
true;public,abstract;0;1;/**  * This method causes the node to compute the description of open branches in its sub-plan. An open branch  * describes, that a (transitive) child node had multiple outputs, which have not all been re-joined in the  * sub-plan. This method needs to set the <code>openBranches</code> field to a stack of unclosed branches, the  * latest one top. A branch is considered closed, if some later node sees all of the branching node's outputs,  * no matter if there have been more branches to different paths in the meantime.  */ ;/**  * This method causes the node to compute the description of open branches in its sub-plan. An open branch  * describes, that a (transitive) child node had multiple outputs, which have not all been re-joined in the  * sub-plan. This method needs to set the <code>openBranches</code> field to a stack of unclosed branches, the  * latest one top. A branch is considered closed, if some later node sees all of the branching node's outputs,  * no matter if there have been more branches to different paths in the meantime.  */ public abstract void computeUnclosedBranchStack().
false;protected;1;17;;protected List<UnclosedBranchDescriptor> computeUnclosedBranchStackForBroadcastInputs(List<UnclosedBranchDescriptor> branchesSoFar) {     // handle the data flow branching for the broadcast inputs     for (DagConnection broadcastInput : getBroadcastConnections()) {         OptimizerNode bcSource = broadcastInput.getSource().         addClosedBranches(bcSource.closedBranchingNodes).         List<UnclosedBranchDescriptor> bcBranches = bcSource.getBranchesForParent(broadcastInput).         ArrayList<UnclosedBranchDescriptor> mergedBranches = new ArrayList<UnclosedBranchDescriptor>().         mergeLists(branchesSoFar, bcBranches, mergedBranches, true).         branchesSoFar = mergedBranches.isEmpty() ? Collections.<UnclosedBranchDescriptor>emptyList() : mergedBranches.     }     return branchesSoFar. }
true;public,abstract;1;1;/**  * Computes the plan alternatives for this node, an implicitly for all nodes that are children of  * this node. This method must determine for each alternative the global and local properties  * and the costs. This method may recursively call <code>getAlternatives()</code> on its children  * to get their plan alternatives, and build its own alternatives on top of those.  *  * @param estimator  *        The cost estimator used to estimate the costs of each plan alternative.  * @return A list containing all plan alternatives.  */ ;/**  * Computes the plan alternatives for this node, an implicitly for all nodes that are children of  * this node. This method must determine for each alternative the global and local properties  * and the costs. This method may recursively call <code>getAlternatives()</code> on its children  * to get their plan alternatives, and build its own alternatives on top of those.  *  * @param estimator  *        The cost estimator used to estimate the costs of each plan alternative.  * @return A list containing all plan alternatives.  */ public abstract List<PlanNode> getAlternativePlans(CostEstimator estimator).
true;public,abstract;1;2;/**  * This method implements the visit of a depth-first graph traversing visitor. Implementers must first  * call the <code>preVisit()</code> method, then hand the visitor to their children, and finally call  * the <code>postVisit()</code> method.  *  * @param visitor  *        The graph traversing visitor.  * @see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor)  */ ;/**  * This method implements the visit of a depth-first graph traversing visitor. Implementers must first  * call the <code>preVisit()</code> method, then hand the visitor to their children, and finally call  * the <code>postVisit()</code> method.  *  * @param visitor  *        The graph traversing visitor.  * @see org.apache.flink.util.Visitable#accept(org.apache.flink.util.Visitor)  */ @Override public abstract void accept(Visitor<OptimizerNode> visitor).
false;public,abstract;0;1;;public abstract SemanticProperties getSemanticProperties().
false;public;0;14;;// ------------------------------------------------------------------------ // Getters / Setters // ------------------------------------------------------------------------ @Override public Iterable<OptimizerNode> getPredecessors() {     List<OptimizerNode> allPredecessors = new ArrayList<OptimizerNode>().     for (DagConnection dagConnection : getIncomingConnections()) {         allPredecessors.add(dagConnection.getSource()).     }     for (DagConnection conn : getBroadcastConnections()) {         allPredecessors.add(conn.getSource()).     }     return allPredecessors. }
true;public;0;3;/**  * Gets the ID of this node. If the id has not yet been set, this method returns -1.  *  * @return This node's id, or -1, if not yet set.  */ ;/**  * Gets the ID of this node. If the id has not yet been set, this method returns -1.  *  * @return This node's id, or -1, if not yet set.  */ public int getId() {     return this.id. }
true;public;1;11;/**  * Sets the ID of this node.  *  * @param id  *        The id for this node.  */ ;/**  * Sets the ID of this node.  *  * @param id  *        The id for this node.  */ public void initId(int id) {     if (id <= 0) {         throw new IllegalArgumentException().     }     if (this.id == -1) {         this.id = id.     } else {         throw new IllegalStateException("Id has already been initialized.").     } }
true;public;2;4;/**  * Adds the broadcast connection identified by the given {@code name} to this node.  *  * @param broadcastConnection The connection to add.  */ ;/**  * Adds the broadcast connection identified by the given {@code name} to this node.  *  * @param broadcastConnection The connection to add.  */ public void addBroadcastConnection(String name, DagConnection broadcastConnection) {     this.broadcastConnectionNames.add(name).     this.broadcastConnections.add(broadcastConnection). }
true;public;0;3;/**  * Return the list of names associated with broadcast inputs for this node.  */ ;/**  * Return the list of names associated with broadcast inputs for this node.  */ public List<String> getBroadcastConnectionNames() {     return this.broadcastConnectionNames. }
true;public;0;3;/**  * Return the list of inputs associated with broadcast variables for this node.  */ ;/**  * Return the list of inputs associated with broadcast variables for this node.  */ public List<DagConnection> getBroadcastConnections() {     return this.broadcastConnections. }
true;public;1;11;/**  * Adds a new outgoing connection to this node.  *  * @param connection  *        The connection to add.  */ ;/**  * Adds a new outgoing connection to this node.  *  * @param connection  *        The connection to add.  */ public void addOutgoingConnection(DagConnection connection) {     if (this.outgoingConnections == null) {         this.outgoingConnections = new ArrayList<DagConnection>().     } else {         if (this.outgoingConnections.size() == 64) {             throw new CompilerException("Cannot currently handle nodes with more than 64 outputs.").         }     }     this.outgoingConnections.add(connection). }
true;public;0;3;/**  * The list of outgoing connections from this node to succeeding tasks.  *  * @return The list of outgoing connections.  */ ;/**  * The list of outgoing connections from this node to succeeding tasks.  *  * @return The list of outgoing connections.  */ public List<DagConnection> getOutgoingConnections() {     return this.outgoingConnections. }
true;public;0;3;/**  * Gets the operator represented by this optimizer node.  *  * @return This node's operator.  */ ;/**  * Gets the operator represented by this optimizer node.  *  * @return This node's operator.  */ public Operator<?> getOperator() {     return this.operator. }
true;public;0;3;/**  * Gets the parallelism for the operator represented by this optimizer node.  * The parallelism denotes how many parallel instances of the operator on will be  * spawned during the execution. If this value is {@link ExecutionConfig#PARALLELISM_DEFAULT}  * then the system will take the default number of parallel instances.  *  * @return The parallelism of the operator.  */ ;/**  * Gets the parallelism for the operator represented by this optimizer node.  * The parallelism denotes how many parallel instances of the operator on will be  * spawned during the execution. If this value is {@link ExecutionConfig#PARALLELISM_DEFAULT}  * then the system will take the default number of parallel instances.  *  * @return The parallelism of the operator.  */ public int getParallelism() {     return this.parallelism. }
true;public;1;6;/**  * Sets the parallelism for this optimizer node.  * The parallelism denotes how many parallel instances of the operator will be  * spawned during the execution.  *  * @param parallelism The parallelism to set. If this value is {@link ExecutionConfig#PARALLELISM_DEFAULT}  *        then the system will take the default number of parallel instances.  * @throws IllegalArgumentException If the parallelism is smaller than one.  */ ;/**  * Sets the parallelism for this optimizer node.  * The parallelism denotes how many parallel instances of the operator will be  * spawned during the execution.  *  * @param parallelism The parallelism to set. If this value is {@link ExecutionConfig#PARALLELISM_DEFAULT}  *        then the system will take the default number of parallel instances.  * @throws IllegalArgumentException If the parallelism is smaller than one.  */ public void setParallelism(int parallelism) {     if (parallelism < 1 && parallelism != ExecutionConfig.PARALLELISM_DEFAULT) {         throw new IllegalArgumentException("Parallelism of " + parallelism + " is invalid.").     }     this.parallelism = parallelism. }
true;public;0;3;/**  * Gets the amount of memory that all subtasks of this task have jointly available.  *  * @return The total amount of memory across all subtasks.  */ ;/**  * Gets the amount of memory that all subtasks of this task have jointly available.  *  * @return The total amount of memory across all subtasks.  */ public long getMinimalMemoryAcrossAllSubTasks() {     return this.minimalMemoryPerSubTask == -1 ? -1 : this.minimalMemoryPerSubTask * this.parallelism. }
false;public;0;3;;public boolean isOnDynamicPath() {     return this.onDynamicPath. }
false;public;1;33;;public void identifyDynamicPath(int costWeight) {     boolean anyDynamic = false.     boolean allDynamic = true.     for (DagConnection conn : getIncomingConnections()) {         boolean dynamicIn = conn.isOnDynamicPath().         anyDynamic |= dynamicIn.         allDynamic &= dynamicIn.     }     for (DagConnection conn : getBroadcastConnections()) {         boolean dynamicIn = conn.isOnDynamicPath().         anyDynamic |= dynamicIn.         allDynamic &= dynamicIn.     }     if (anyDynamic) {         this.onDynamicPath = true.         this.costWeight = costWeight.         if (!allDynamic) {             // mark the connections where the source is not dynamic as cached             for (DagConnection conn : getIncomingConnections()) {                 if (!conn.getSource().isOnDynamicPath()) {                     conn.setMaterializationMode(conn.getMaterializationMode().makeCached()).                 }             }         // broadcast variables are always cached, because they stay unchanged available in the         // runtime context of the functions         }     } }
false;public;0;3;;public int getCostWeight() {     return this.costWeight. }
false;public;0;11;;public int getMaxDepth() {     int maxDepth = 0.     for (DagConnection conn : getIncomingConnections()) {         maxDepth = Math.max(maxDepth, conn.getMaxDepth()).     }     for (DagConnection conn : getBroadcastConnections()) {         maxDepth = Math.max(maxDepth, conn.getMaxDepth()).     }     return maxDepth. }
true;public;0;3;/**  * Gets the properties that are interesting for this node to produce.  *  * @return The interesting properties for this node, or null, if not yet computed.  */ ;/**  * Gets the properties that are interesting for this node to produce.  *  * @return The interesting properties for this node, or null, if not yet computed.  */ public InterestingProperties getInterestingProperties() {     return this.intProps. }
false;public;0;4;;@Override public long getEstimatedOutputSize() {     return this.estimatedOutputSize. }
false;public;0;4;;@Override public long getEstimatedNumRecords() {     return this.estimatedNumRecords. }
false;public;1;3;;public void setEstimatedOutputSize(long estimatedOutputSize) {     this.estimatedOutputSize = estimatedOutputSize. }
false;public;1;3;;public void setEstimatedNumRecords(long estimatedNumRecords) {     this.estimatedNumRecords = estimatedNumRecords. }
false;public;0;8;;@Override public float getEstimatedAvgWidthPerOutputRecord() {     if (this.estimatedOutputSize > 0 && this.estimatedNumRecords > 0) {         return ((float) this.estimatedOutputSize) / this.estimatedNumRecords.     } else {         return -1.0f.     } }
true;public;0;3;/**  * Checks whether this node has branching output. A node's output is branched, if it has more  * than one output connection.  *  * @return True, if the node's output branches. False otherwise.  */ ;/**  * Checks whether this node has branching output. A node's output is branched, if it has more  * than one output connection.  *  * @return True, if the node's output branches. False otherwise.  */ public boolean isBranching() {     return getOutgoingConnections() != null && getOutgoingConnections().size() > 1. }
false;public;0;8;;public void markAllOutgoingConnectionsAsPipelineBreaking() {     if (this.outgoingConnections == null) {         throw new IllegalStateException("The outgoing connections have not yet been initialized.").     }     for (DagConnection conn : getOutgoingConnections()) {         conn.markBreaksPipeline().     } }
true;public;0;8;/**  * Checks, if all outgoing connections have their interesting properties set from their target nodes.  *  * @return True, if on all outgoing connections, the interesting properties are set. False otherwise.  */ ;// ------------------------------------------------------------------------ // Miscellaneous // ------------------------------------------------------------------------ /**  * Checks, if all outgoing connections have their interesting properties set from their target nodes.  *  * @return True, if on all outgoing connections, the interesting properties are set. False otherwise.  */ public boolean haveAllOutputConnectionInterestingProperties() {     for (DagConnection conn : getOutgoingConnections()) {         if (conn.getInterestingProperties() == null) {             return false.         }     }     return true. }
true;public;0;13;/**  * Computes all the interesting properties that are relevant to this node. The interesting  * properties are a union of the interesting properties on each outgoing connection.  * However, if two interesting properties on the outgoing connections overlap,  * the interesting properties will occur only once in this set. For that, this  * method deduplicates and merges the interesting properties.  * This method returns copies of the original interesting properties objects and  * leaves the original objects, contained by the connections, unchanged.  */ ;/**  * Computes all the interesting properties that are relevant to this node. The interesting  * properties are a union of the interesting properties on each outgoing connection.  * However, if two interesting properties on the outgoing connections overlap,  * the interesting properties will occur only once in this set. For that, this  * method deduplicates and merges the interesting properties.  * This method returns copies of the original interesting properties objects and  * leaves the original objects, contained by the connections, unchanged.  */ public void computeUnionOfInterestingPropertiesFromSuccessors() {     List<DagConnection> conns = getOutgoingConnections().     if (conns.size() == 0) {         // no incoming, we have none ourselves         this.intProps = new InterestingProperties().     } else {         this.intProps = conns.get(0).getInterestingProperties().clone().         for (int i = 1. i < conns.size(). i++) {             this.intProps.addInterestingProperties(conns.get(i).getInterestingProperties()).         }     }     this.intProps.dropTrivials(). }
false;public;0;9;;public void clearInterestingProperties() {     this.intProps = null.     for (DagConnection conn : getIncomingConnections()) {         conn.clearInterestingProperties().     }     for (DagConnection conn : getBroadcastConnections()) {         conn.clearInterestingProperties().     } }
true;public;1;59;/**  * Causes this node to compute its output estimates (such as number of rows, size in bytes)  * based on the inputs and the compiler hints. The compiler hints are instantiated with conservative  * default values which are used if no other values are provided. Nodes may access the statistics to  * determine relevant information.  *  * @param statistics  *        The statistics object which may be accessed to get statistical information.  *        The parameter may be null, if no statistics are available.  */ ;/**  * Causes this node to compute its output estimates (such as number of rows, size in bytes)  * based on the inputs and the compiler hints. The compiler hints are instantiated with conservative  * default values which are used if no other values are provided. Nodes may access the statistics to  * determine relevant information.  *  * @param statistics  *        The statistics object which may be accessed to get statistical information.  *        The parameter may be null, if no statistics are available.  */ public void computeOutputEstimates(DataStatistics statistics) {     // sanity checking     for (DagConnection c : getIncomingConnections()) {         if (c.getSource() == null) {             throw new CompilerException("Bug: Estimate computation called before inputs have been set.").         }     }     // let every operator do its computation     computeOperatorSpecificDefaultEstimates(statistics).     if (this.estimatedOutputSize < 0) {         this.estimatedOutputSize = -1.     }     if (this.estimatedNumRecords < 0) {         this.estimatedNumRecords = -1.     }     // overwrite default estimates with hints, if given     if (getOperator() == null || getOperator().getCompilerHints() == null) {         return.     }     CompilerHints hints = getOperator().getCompilerHints().     if (hints.getOutputSize() >= 0) {         this.estimatedOutputSize = hints.getOutputSize().     }     if (hints.getOutputCardinality() >= 0) {         this.estimatedNumRecords = hints.getOutputCardinality().     }     if (hints.getFilterFactor() >= 0.0f) {         if (this.estimatedNumRecords >= 0) {             this.estimatedNumRecords = (long) (this.estimatedNumRecords * hints.getFilterFactor()).             if (this.estimatedOutputSize >= 0) {                 this.estimatedOutputSize = (long) (this.estimatedOutputSize * hints.getFilterFactor()).             }         } else if (this instanceof SingleInputNode) {             OptimizerNode pred = ((SingleInputNode) this).getPredecessorNode().             if (pred != null && pred.getEstimatedNumRecords() >= 0) {                 this.estimatedNumRecords = (long) (pred.getEstimatedNumRecords() * hints.getFilterFactor()).             }         }     }     // use the width to infer the cardinality (given size) and vice versa     if (hints.getAvgOutputRecordSize() >= 1) {         // the estimated number of rows based on size         if (this.estimatedNumRecords == -1 && this.estimatedOutputSize >= 0) {             this.estimatedNumRecords = (long) (this.estimatedOutputSize / hints.getAvgOutputRecordSize()).         } else if (this.estimatedOutputSize == -1 && this.estimatedNumRecords >= 0) {             this.estimatedOutputSize = (long) (this.estimatedNumRecords * hints.getAvgOutputRecordSize()).         }     } }
false;protected,abstract;1;1;;protected abstract void computeOperatorSpecificDefaultEstimates(DataStatistics statistics).
true;protected;0;3;/**  * Reads all stub annotations, i.e. which fields remain constant, what cardinality bounds the  * functions have, which fields remain unique.  */ ;// ------------------------------------------------------------------------ // Reading of stub annotations // ------------------------------------------------------------------------ /**  * Reads all stub annotations, i.e. which fields remain constant, what cardinality bounds the  * functions have, which fields remain unique.  */ protected void readStubAnnotations() {     readUniqueFieldsAnnotation(). }
false;protected;0;11;;protected void readUniqueFieldsAnnotation() {     if (this.operator.getCompilerHints() != null) {         Set<FieldSet> uniqueFieldSets = operator.getCompilerHints().getUniqueFields().         if (uniqueFieldSets != null) {             if (this.uniqueFields == null) {                 this.uniqueFields = new HashSet<FieldSet>().             }             this.uniqueFields.addAll(uniqueFieldSets).         }     } }
true;public;0;3;/**  * Gets the FieldSets which are unique in the output of the node.  */ ;// ------------------------------------------------------------------------ // Access of stub annotations // ------------------------------------------------------------------------ /**  * Gets the FieldSets which are unique in the output of the node.  */ public Set<FieldSet> getUniqueFields() {     return this.uniqueFields == null ? Collections.<FieldSet>emptySet() : this.uniqueFields. }
false;public;2;14;;@Override public int compare(PlanNode o1, PlanNode o2) {     for (OptimizerNode branchDeterminer : branchDeterminers) {         PlanNode n1 = o1.getCandidateAtBranchPoint(branchDeterminer).         PlanNode n2 = o2.getCandidateAtBranchPoint(branchDeterminer).         int hash1 = System.identityHashCode(n1).         int hash2 = System.identityHashCode(n2).         if (hash1 != hash2) {             return hash1 - hash2.         }     }     return 0. }
false;protected;1;103;;// -------------------------------------------------------------------------------------------- // Pruning // -------------------------------------------------------------------------------------------- protected void prunePlanAlternatives(List<PlanNode> plans) {     if (plans.isEmpty()) {         throw new CompilerException("No plan meeting the requirements could be created @ " + this + ". Most likely reason: Too restrictive plan hints.").     }     // shortcut for the simple case     if (plans.size() == 1) {         return.     }     if (this.openBranches == null || this.openBranches.isEmpty()) {         prunePlanAlternativesWithCommonBranching(plans).     } else {         // partition the candidates into groups that made the same sub-plan candidate         // choice at the latest unclosed branch point         final OptimizerNode[] branchDeterminers = new OptimizerNode[this.openBranches.size()].         for (int i = 0. i < branchDeterminers.length. i++) {             branchDeterminers[i] = this.openBranches.get(this.openBranches.size() - 1 - i).getBranchingNode().         }         // this sorter sorts by the candidate choice at the branch point         Comparator<PlanNode> sorter = new Comparator<PlanNode>() {              @Override             public int compare(PlanNode o1, PlanNode o2) {                 for (OptimizerNode branchDeterminer : branchDeterminers) {                     PlanNode n1 = o1.getCandidateAtBranchPoint(branchDeterminer).                     PlanNode n2 = o2.getCandidateAtBranchPoint(branchDeterminer).                     int hash1 = System.identityHashCode(n1).                     int hash2 = System.identityHashCode(n2).                     if (hash1 != hash2) {                         return hash1 - hash2.                     }                 }                 return 0.             }         }.         Collections.sort(plans, sorter).         List<PlanNode> result = new ArrayList<PlanNode>().         List<PlanNode> turn = new ArrayList<PlanNode>().         final PlanNode[] determinerChoice = new PlanNode[branchDeterminers.length].         while (!plans.isEmpty()) {             // take one as the determiner             turn.clear().             PlanNode determiner = plans.remove(plans.size() - 1).             turn.add(determiner).             for (int i = 0. i < determinerChoice.length. i++) {                 determinerChoice[i] = determiner.getCandidateAtBranchPoint(branchDeterminers[i]).             }             // go backwards through the plans and find all that are equal             boolean stillEqual = true.             for (int k = plans.size() - 1. k >= 0 && stillEqual. k--) {                 PlanNode toCheck = plans.get(k).                 for (int i = 0. i < branchDeterminers.length. i++) {                     PlanNode checkerChoice = toCheck.getCandidateAtBranchPoint(branchDeterminers[i]).                     if (checkerChoice != determinerChoice[i]) {                         // not the same anymore                         stillEqual = false.                         break.                     }                 }                 if (stillEqual) {                     // the same                     plans.remove(k).                     turn.add(toCheck).                 }             }             // now that we have only plans with the same branch alternatives, prune!             if (turn.size() > 1) {                 prunePlanAlternativesWithCommonBranching(turn).             }             result.addAll(turn).         }         // after all turns are complete         plans.clear().         plans.addAll(result).     } }
false;protected;1;81;;protected void prunePlanAlternativesWithCommonBranching(List<PlanNode> plans) {     // for each interesting property, which plans are cheapest     final RequestedGlobalProperties[] gps = this.intProps.getGlobalProperties().toArray(new RequestedGlobalProperties[this.intProps.getGlobalProperties().size()]).     final RequestedLocalProperties[] lps = this.intProps.getLocalProperties().toArray(new RequestedLocalProperties[this.intProps.getLocalProperties().size()]).     final PlanNode[][] toKeep = new PlanNode[gps.length][].     final PlanNode[] cheapestForGlobal = new PlanNode[gps.length].     // the overall cheapest plan     PlanNode cheapest = null.     // go over all plans from the list     for (PlanNode candidate : plans) {         // check if that plan is the overall cheapest         if (cheapest == null || (cheapest.getCumulativeCosts().compareTo(candidate.getCumulativeCosts()) > 0)) {             cheapest = candidate.         }         // find the interesting global properties that this plan matches         for (int i = 0. i < gps.length. i++) {             if (gps[i].isMetBy(candidate.getGlobalProperties())) {                 if (cheapestForGlobal[i] == null || (cheapestForGlobal[i].getCumulativeCosts().compareTo(candidate.getCumulativeCosts()) > 0)) {                     cheapestForGlobal[i] = candidate.                 }                 final PlanNode[] localMatches.                 if (toKeep[i] == null) {                     localMatches = new PlanNode[lps.length].                     toKeep[i] = localMatches.                 } else {                     localMatches = toKeep[i].                 }                 for (int k = 0. k < lps.length. k++) {                     if (lps[k].isMetBy(candidate.getLocalProperties())) {                         final PlanNode previous = localMatches[k].                         if (previous == null || previous.getCumulativeCosts().compareTo(candidate.getCumulativeCosts()) > 0) {                             // this one is cheaper!                             localMatches[k] = candidate.                         }                     }                 }             }         }     }     // all plans are set now     plans.clear().     // add the cheapest plan     if (cheapest != null) {         plans.add(cheapest).         // remember that that plan is in the set         cheapest.setPruningMarker().     }     // add all others, which are optimal for some interesting properties     for (int i = 0. i < gps.length. i++) {         if (toKeep[i] != null) {             final PlanNode[] localMatches = toKeep[i].             for (final PlanNode n : localMatches) {                 if (n != null && !n.isPruneMarkerSet()) {                     n.setPruningMarker().                     plans.add(n).                 }             }         }         if (cheapestForGlobal[i] != null) {             final PlanNode n = cheapestForGlobal[i].             if (!n.isPruneMarkerSet()) {                 n.setPruningMarker().                 plans.add(n).             }         }     } }
false;public;0;3;;// -------------------------------------------------------------------------------------------- // Handling of branches // -------------------------------------------------------------------------------------------- public boolean hasUnclosedBranches() {     return this.openBranches != null && !this.openBranches.isEmpty(). }
false;public;0;3;;public Set<OptimizerNode> getClosedBranchingNodes() {     return this.closedBranchingNodes. }
false;public;0;3;;public List<UnclosedBranchDescriptor> getOpenBranches() {     return this.openBranches. }
false;protected;1;38;;protected List<UnclosedBranchDescriptor> getBranchesForParent(DagConnection toParent) {     if (this.outgoingConnections.size() == 1) {         // return our own stack of open branches, because nothing is added         if (this.openBranches == null || this.openBranches.isEmpty()) {             return Collections.emptyList().         } else {             return new ArrayList<UnclosedBranchDescriptor>(this.openBranches).         }     } else if (this.outgoingConnections.size() > 1) {         // we branch add a branch info to the stack         List<UnclosedBranchDescriptor> branches = new ArrayList<UnclosedBranchDescriptor>(4).         if (this.openBranches != null) {             branches.addAll(this.openBranches).         }         // find out, which output number the connection to the parent         int num.         for (num = 0. num < this.outgoingConnections.size(). num++) {             if (this.outgoingConnections.get(num) == toParent) {                 break.             }         }         if (num >= this.outgoingConnections.size()) {             throw new CompilerException("Error in compiler: " + "Parent to get branch info for is not contained in the outgoing connections.").         }         // create the description and add it         long bitvector = 0x1L << num.         branches.add(new UnclosedBranchDescriptor(this, bitvector)).         return branches.     } else {         throw new CompilerException("Error in compiler: Cannot get branch info for successor in a node with no successors.").     } }
false;protected;1;13;;protected void removeClosedBranches(List<UnclosedBranchDescriptor> openList) {     if (openList == null || openList.isEmpty() || this.closedBranchingNodes == null || this.closedBranchingNodes.isEmpty()) {         return.     }     Iterator<UnclosedBranchDescriptor> it = openList.iterator().     while (it.hasNext()) {         if (this.closedBranchingNodes.contains(it.next().getBranchingNode())) {             // this branch was already closed --> remove it from the list             it.remove().         }     } }
false;protected;1;11;;protected void addClosedBranches(Set<OptimizerNode> alreadyClosed) {     if (alreadyClosed == null || alreadyClosed.isEmpty()) {         return.     }     if (this.closedBranchingNodes == null) {         this.closedBranchingNodes = new HashSet<OptimizerNode>(alreadyClosed).     } else {         this.closedBranchingNodes.addAll(alreadyClosed).     } }
false;protected;1;7;;protected void addClosedBranch(OptimizerNode alreadyClosed) {     if (this.closedBranchingNodes == null) {         this.closedBranchingNodes = new HashSet<OptimizerNode>().     }     this.closedBranchingNodes.add(alreadyClosed). }
true;protected;2;21;/**  * Checks whether to candidate plans for the sub-plan of this node are comparable. The two  * alternative plans are comparable, if  *  * a) There is no branch in the sub-plan of this node  * b) Both candidates have the same candidate as the child at the last open branch.  *  * @param plan1 The root node of the first candidate plan.  * @param plan2 The root node of the second candidate plan.  * @return True if the nodes are branch compatible in the inputs.  */ ;/**  * Checks whether to candidate plans for the sub-plan of this node are comparable. The two  * alternative plans are comparable, if  *  * a) There is no branch in the sub-plan of this node  * b) Both candidates have the same candidate as the child at the last open branch.  *  * @param plan1 The root node of the first candidate plan.  * @param plan2 The root node of the second candidate plan.  * @return True if the nodes are branch compatible in the inputs.  */ protected boolean areBranchCompatible(PlanNode plan1, PlanNode plan2) {     if (plan1 == null || plan2 == null) {         throw new NullPointerException().     }     // in most plans, that will be the dominant case     if (this.hereJoinedBranches == null || this.hereJoinedBranches.isEmpty()) {         return true.     }     for (OptimizerNode joinedBrancher : hereJoinedBranches) {         final PlanNode branch1Cand = plan1.getCandidateAtBranchPoint(joinedBrancher).         final PlanNode branch2Cand = plan2.getCandidateAtBranchPoint(joinedBrancher).         if (branch1Cand != null && branch2Cand != null && branch1Cand != branch2Cand) {             return false.         }     }     return true. }
true;protected,final;4;100;/**  * The node IDs are assigned in graph-traversal order (pre-order), hence, each list is  * sorted by ID in ascending order and all consecutive lists start with IDs in ascending order.  *  * @param markJoinedBranchesAsPipelineBreaking True, if the  */ ;/**  * The node IDs are assigned in graph-traversal order (pre-order), hence, each list is  * sorted by ID in ascending order and all consecutive lists start with IDs in ascending order.  *  * @param markJoinedBranchesAsPipelineBreaking True, if the  */ protected final boolean mergeLists(List<UnclosedBranchDescriptor> child1open, List<UnclosedBranchDescriptor> child2open, List<UnclosedBranchDescriptor> result, boolean markJoinedBranchesAsPipelineBreaking) {     // remove branches which have already been closed     removeClosedBranches(child1open).     removeClosedBranches(child2open).     result.clear().     // 3) both are set, then we need to merge.     if (child1open == null || child1open.isEmpty()) {         if (child2open != null && !child2open.isEmpty()) {             result.addAll(child2open).         }         return false.     }     if (child2open == null || child2open.isEmpty()) {         result.addAll(child1open).         return false.     }     int index1 = child1open.size() - 1.     int index2 = child2open.size() - 1.     boolean didCloseABranch = false.     // and eliminates duplicates     while (index1 >= 0 || index2 >= 0) {         int id1 = -1.         int id2 = index2 >= 0 ? child2open.get(index2).getBranchingNode().getId() : -1.         while (index1 >= 0 && (id1 = child1open.get(index1).getBranchingNode().getId()) > id2) {             result.add(child1open.get(index1)).             index1--.         }         while (index2 >= 0 && (id2 = child2open.get(index2).getBranchingNode().getId()) > id1) {             result.add(child2open.get(index2)).             index2--.         }         // match: they share a common branching child         if (id1 == id2) {             didCloseABranch = true.             // if this is the latest common child, remember it             OptimizerNode currBanchingNode = child1open.get(index1).getBranchingNode().             long vector1 = child1open.get(index1).getJoinedPathsVector().             long vector2 = child2open.get(index2).getJoinedPathsVector().             // if it is the same, add it only once, otherwise process the join of the paths             if (vector1 == vector2) {                 result.add(child1open.get(index1)).             } else {                 // mark the branch as a point where we break the pipeline                 if (markJoinedBranchesAsPipelineBreaking) {                     currBanchingNode.markAllOutgoingConnectionsAsPipelineBreaking().                 }                 if (this.hereJoinedBranches == null) {                     this.hereJoinedBranches = new ArrayList<OptimizerNode>(2).                 }                 this.hereJoinedBranches.add(currBanchingNode).                 // see, if this node closes the branch                 long joinedInputs = vector1 | vector2.                 // this is 2^size - 1, which is all bits set at positions 0..size-1                 long allInputs = (0x1L << currBanchingNode.getOutgoingConnections().size()) - 1.                 if (joinedInputs == allInputs) {                     // closed - we can remove it from the stack                     addClosedBranch(currBanchingNode).                 } else {                     // not quite closed                     result.add(new UnclosedBranchDescriptor(currBanchingNode, joinedInputs)).                 }             }             index1--.             index2--.         }     }     // merged. now we need to reverse the list, because we added the elements in reverse order     Collections.reverse(result).     return didCloseABranch. }
false;public;0;4;;@Override public OptimizerNode getOptimizerNode() {     return this. }
false;public;0;4;;@Override public PlanNode getPlanNode() {     return null. }
false;public;0;9;;@Override public Iterable<DumpableConnection<OptimizerNode>> getDumpableInputs() {     List<DumpableConnection<OptimizerNode>> allInputs = new ArrayList<DumpableConnection<OptimizerNode>>().     allInputs.addAll(getIncomingConnections()).     allInputs.addAll(getBroadcastConnections()).     return allInputs. }
false;public;0;15;;@Override public String toString() {     StringBuilder bld = new StringBuilder().     bld.append(getOperatorName()).     bld.append(" (").append(getOperator().getName()).append(") ").     int i = 1.     for (DagConnection conn : getIncomingConnections()) {         String shipStrategyName = conn.getShipStrategy() == null ? "null" : conn.getShipStrategy().name().         bld.append('(').append(i++).append(":").append(shipStrategyName).append(')').     }     return bld.toString(). }
false;public;0;3;;public OptimizerNode getBranchingNode() {     return this.branchingNode. }
false;public;0;3;;public long getJoinedPathsVector() {     return this.joinedPathsVector. }
false;public;0;4;;@Override public String toString() {     return "(" + this.branchingNode.getOperator() + ") [" + this.joinedPathsVector + "]". }
